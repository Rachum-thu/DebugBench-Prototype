[
    {
        "slug": "maximal-rectangle",
        "description": "Given a rows x cols\u00a0binary matrix filled with 0's and 1's, find the largest rectangle containing only 1's and return its area.",
        "examples": [
            "Input: matrix = [[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"0\"]]\nOutput: 6\nExplanation: The maximal rectangle is shown in the above picture.",
            "Input: matrix = [[\"0\"]]\nOutput: 0",
            "Input: matrix = [[\"1\"]]\nOutput: 1"
        ],
        "constraints": "rows == matrix.length\ncols == matrix[i].length\n1 <= row, cols <= 200\nmatrix[i][j] is '0' or '1'.",
        "release_time": 1691836401,
        "oracle_code": "class Pair<T, U> {\n    public final T first;\n    public final U second;\n\n    public Pair(T first, U second) {\n        this.first = first;\n        this.second = second;\n    }\n}\n\nclass Solution {\n    public int maximalRectangle(char[][] matrix) {\n        int n = matrix.length, m = matrix[0].length;\n        int[] nums = new int[m];\n        for (int j = 0; j < m; j++) {\n            nums[j] = matrix[0][j] - '0';\n        }\n        int max = maximumAreaHistogram(nums);\n        for (int i = 1; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (matrix[i][j] == '0') {\n                    nums[j] = 0;\n                } else {\n                    nums[j] += (matrix[i][j] - '0');\n                }\n            }\n            max = Math.max(max, maximumAreaHistogram(nums));\n        }\n        return max;\n    }\n    public int maximumAreaHistogram(int[] heights) {\n        Stack<Pair<Integer, Integer>> stack1 = new Stack<>();\n        int[] left = new int[heights.length];\n        int pseudoIndex = -1;\n        //NSL\n        for (int i = 0; i < heights.length; i++) {\n            if (stack1.size() == 0) {\n                left[i] = pseudoIndex;\n            } else if (stack1.size() > 0 && stack1.peek().first < heights[i]) {\n                left[i] = stack1.peek().second;\n            } else if (stack1.size() > 0 && stack1.peek().first >= heights[i]) {\n                while (stack1.size() > 0 && stack1.peek().first >= heights[i]) {\n                    stack1.pop();\n                }\n                if (stack1.size() == 0) {\n                    left[i] = pseudoIndex;\n                } else {\n                    left[i] = stack1.peek().second;\n                }\n            }\n            stack1.push(new Pair<>(heights[i], i));\n        }\n        //NSR\n        Stack<Pair<Integer, Integer>> stack2 = new Stack<>();\n        int[] right = new int[heights.length];\n        pseudoIndex = heights.length;\n        for (int i = heights.length - 1; i >= 0; i--) {\n            if (stack2.size() == 0) {\n                right[i] = pseudoIndex;\n            } else if (stack2.size() > 0 && stack2.peek().first < heights[i]) {\n                right[i] = stack2.peek().second;\n            } else if (stack2.size() > 0 && stack2.peek().first >= heights[i]) {\n                while (stack2.size() > 0 && stack2.peek().first >= heights[i]) {\n                    stack2.pop();\n                }\n                if (stack2.size() == 0) {\n                    right[i] = pseudoIndex;\n                } else {\n                    right[i] = stack2.peek().second;\n                }\n            }\n            stack2.push(new Pair<>(heights[i], i));\n        }\n\n        int[] width = new int[heights.length];\n        for (int i = 0; i < heights.length; i++) {\n            width[i] = right[i] - left[i] - 1;\n        }\n\n        int[] area = new int[heights.length];\n        int maxArea = 0;\n        for (int i = 0; i < heights.length; i++) {\n            area[i] = heights[i] * width[i];\n            if (area[i] > maxArea) maxArea = area[i];\n        }\n        return maxArea;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Pair<T, U> {\\n    public final T first;\\n    public final U second;\\n\\n    public Pair(T first, U second) {\\n        this.first = first;\\n        this.second = second;\\n    }\\n}\\n\\nclass Solution {\\n    public int maximalRectangle(char[][] matrix) {\\n        int n = matrix.length, m = matrix[0].length;\\n        int[] nums = new int[m];\\n        for (int j = 0; j < m; j++) {\\n            nums[j] = matrix[0][j] - \\'0\\';\\n        }\\n        int max = maximumAreaHistogram(nums);\\n        for (int i = 1; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (matrix[i][j] == \\'0\\') {\\n                    nums[j] = 0;\\n                } else {\\n                    nums[j] += (matrix[i][j] - \\'0\\');\\n                }\\n            }\\n            max = Math.max(max, maximumAreaHistogram(nums));\\n        }\\n        return max;\\n    }\\n    public int maximumAreaHistogram(int[] heights) {\\n        Stack<Pair<Integer, Integer>> stack1 = new Stack<>();\\n        int[] left = new int[heights.length];\\n        int pseudoIndex = -1;\\n        //NSL\\n        for (int i = 0; i < heights.length; i++) {\\n            if (stack1.size() == 0) {\\n                left[i] = pseudoIndex;\\n            } else if (stack1.size() > 0 && stack1.peek().first < heights[i]) {\\n                left[i] = stack1.peek().second;\\n            } else if (stack1.size() > 0 && stack1.peek().first >= heights[i]) {\\n                while (stack1.size() > 0 && stack1.peek().first >= heights[i]) {\\n                    stack1.pop();\\n                }\\n                if (stack1.size() == 0) {\\n                    left[i] = pseudoIndex;\\n                } else {\\n                    left[i] = stack1.peek().second;\\n                }\\n            }\\n            stack1.push(new Pair<>(heights[i], i));\\n        }\\n        //NSR\\n        Stack<Pair<Integer, Integer>> stack2 = new Stack<>();\\n        int[] right = new int[heights.length];\\n        pseudoIndex = heights.length;\\n        for (int i = heights.length - 1; i >= 0; i--) {\\n            if (stack2.size() == 0) {\\n                right[i] = pseudoIndex;\\n            } else if (stack2.size() > 0 && stack2.peek().first < heights[i]) {\\n                right[i] = stack2.peek().second;\\n            } else if (stack2.size() > 0 && stack2.peek().first >= heights[i]) {\\n                while (stack2.size() > 0 && stack2.peek().first >= heights[i]) {\\n                    stack2.pop();\\n                }\\n                if (stack2.size() == 0) {\\n                    right[i] = pseudoIndex;\\n                } else {\\n                    right[i] = stack2.peek().second;\\n                }\\n            }\\n            stack2.push(new Pair<>(heights[i], i));\\n        }\\n\\n        int[] width = new int[heights.length];\\n        for (int i = 0; i < heights.length; i++) {\\n            width[i] = right[i] - left[i] - 1;\\n        }\\n\\n        int[] area = new int[heights.length];\\n        int maxArea = 0;\\n        for (int i = 0; i < heights.length; i++) {\\n            area[i] = heights[i] * width[i];\\n            if (area[i] > maxArea) maxArea = area[i];\\n        }\\n        return maxArea;\\n    }\\n}\\n```",
        "level": "hard",
        "buggy_code": "\nclass Pair<T, U> {\n    public final T first;\n    public final U second;\n\n    public Pair(T first, U second) {\n        this.first = first;\n        this.second = second;\n    }\n}\n\nclass Solution {\n    public int maximalRectangle(char[][] matrix) {\n        int n = matrix.length, m = matrix[0].length;\n        int[] nums = new int[m];\n        for (int j = 0; j < m; j++) {\n            nums[j] = matrix[0][j] - '0';\n        }\n        int max = maximumAreaHistogram(nums);\n        for (int i = 1; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (matrix[i][j] == '0') {\n                    nums[j] = 0;\n                } else {\n                    nums[j] += (matrix[i][j] - '0');\n                }\n            }\n            max = Math.max(max, maximumAreaHistogram(nums));\n        }\n        return max;\n    }\n    public int maximumAreaHistogram(int[] heights) {\n        Stack<Pair<Integer, Integer>> stack1 = new Stack<>();\n        int[] left = new int[heights.length];\n        int pseudoIndex = -1;\n        //NSL\n        for (int i = 0; i < heights.length; i++) {\n            if (stack1.size() == 0) {\n                left[i] = pseudoIndex;\n            } else if (stack1.size() > 0 && stack1.peek().first < heights[i]) {\n                left[i] = stack1.peek().second;\n            } else if (stack1.size() > 0 && stack1.peek().first >= heights[i]) {\n                while (stack1.size() > 0 && stack1.peek().first == heights[i]) {\n                    stack1.pop();\n                }\n                if (stack1.size() == 0) {\n                    left[i] = pseudoIndex;\n                } else {\n                    left[i] = stack1.peek().second;\n                }\n            }\n            stack1.push(new Pair<>(heights[i], i));\n        }\n        //NSR\n        Stack<Pair<Integer, Integer>> stack2 = new Stack<>();\n        int[] right = new int[heights.length];\n        pseudoIndex = heights.length;\n        for (int i = heights.length - 1; i >= 0; i--) {\n            if (stack2.size() == 0) {\n                right[i] = pseudoIndex;\n            } else if (stack2.size() > 0 && stack2.peek().first < heights[i]) {\n                right[i] = stack2.peek().second;\n            } else if (stack2.size() > 0 && stack2.peek().first >= heights[i]) {\n                while (stack2.size() > 0 && stack2.peek().first == heights[i]) {\n                    stack2.pop();\n                }\n                if (stack2.size() == 0) {\n                    right[i] = pseudoIndex;\n                } else {\n                    right[i] = stack2.peek().second;\n                }\n            }\n            stack2.push(new Pair<>(heights[i], i));\n        }\n\n        int[] width = new int[heights.length];\n        for (int i = 0; i < heights.length; i++) {\n            width[i] = right[i] - left[i] - 1;\n        }\n\n        int[] area = new int[heights.length];\n        int maxArea = 0;\n        for (int i = 0; i < heights.length; i++) {\n            area[i] = heights[i] * width[i];\n            if (area[i] > maxArea) maxArea = area[i];\n        }\n        return maxArea;\n    }\n}\n",
        "explanations": "\nThe while condition is using the '==' operator instead of '>=' for comparing stack1.peek().first and stack2.peek().first with heights[i], which will cause unwanted execution of the loop, thus resulting in incorrect results.\n"
    },
    {
        "slug": "same-tree",
        "description": "Given the roots of two binary trees p and q, write a function to check if they are the same or not.\nTwo binary trees are considered the same if they are structurally identical, and the nodes have the same value.",
        "examples": [
            "Input: p = [1,2,3], q = [1,2,3]\nOutput: true",
            "Input: p = [1,2], q = [1,null,2]\nOutput: false",
            "Input: p = [1,2,1], q = [1,1,2]\nOutput: false"
        ],
        "constraints": "The number of nodes in both trees is in the range [0, 100].\n-104 <= Node.val <= 104",
        "release_time": 1691573493,
        "oracle_code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n   \n    public boolean isSameTree(TreeNode p, TreeNode q) {\n     if (p == null && q == null) {\n            return true;\n        }\n        \n        if (p == null || q == null) {\n            return false;\n        }\n        \n        if (p.val != q.val) {\n            return false;\n        }\n        \n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n\n        \n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n   \\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n     if (p == null && q == null) {\\n            return true;\\n        }\\n        \\n        if (p == null || q == null) {\\n            return false;\\n        }\\n        \\n        if (p.val != q.val) {\\n            return false;\\n        }\\n        \\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n\\n        \\n    }\\n}\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\n\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n     if (p = null && q == null) {\n            return true;\n        }\n        \n        if (p == null || q == null) {\n            return false;\n        }\n        \n        if (p.val != q.val) {\n            return false;\n        }\n        \n        return isSameTree(p.left, q.left) && isSameTree(p.right,=q.right);\n\n        \n    }\n}\n",
        "explanations": "\nIn the equality test, \"==\" should be used instead of assignment operator \"=\".\n"
    },
    {
        "slug": "number-of-laser-beams-in-a-bank",
        "description": "Anti-theft security devices are activated inside a bank. You are given a 0-indexed binary string array bank representing the floor plan of the bank, which is an m x n 2D matrix. bank[i] represents the ith row, consisting of '0's and '1's. '0' means the cell is empty, while'1' means the cell has a security device.\nThere is one laser beam between any two security devices if both conditions are met:\n\nThe two devices are located on two different rows: r1 and r2, where r1 < r2.\nFor each row i where r1 < i < r2, there are no security devices in the ith row.\n\nLaser beams are independent, i.e., one beam does not interfere nor join with another.\nReturn the total number of laser beams in the bank.",
        "examples": [
            "Input: bank = [\"011001\",\"000000\",\"010100\",\"001000\"]\nOutput: 8\nExplanation: Between each of the following device pairs, there is one beam. In total, there are 8 beams:\n * bank[0][1] -- bank[2][1]\n * bank[0][1] -- bank[2][3]\n * bank[0][2] -- bank[2][1]\n * bank[0][2] -- bank[2][3]\n * bank[0][5] -- bank[2][1]\n * bank[0][5] -- bank[2][3]\n * bank[2][1] -- bank[3][2]\n * bank[2][3] -- bank[3][2]\nNote that there is no beam between any device on the 0th row with any on the 3rd row.\nThis is because the 2nd row contains security devices, which breaks the second condition.",
            "Input: bank = [\"000\",\"111\",\"000\"]\nOutput: 0\nExplanation: There does not exist two devices located on two different rows."
        ],
        "constraints": "m == bank.length\nn == bank[i].length\n1 <= m, n <= 500\nbank[i][j] is either '0' or '1'.",
        "release_time": 1671532567,
        "oracle_code": "class Solution {\n    public int numberOfBeams(String[] bank) {\n        int prevLazer =0;\n        int ans =0;\n        for(String s:bank){\n            int curLazer = 0;\n            for(char c: s.toCharArray()){\n                if(c=='1'){\n                    curLazer++;\n                }\n            }\n            if(curLazer >0){\n                ans += (curLazer * prevLazer);\n                prevLazer = curLazer;\n            }\n        }\n        return ans;\n    }\n}",
        "content": "\\n# java Code\\n```\\nclass Solution {\\n    public int numberOfBeams(String[] bank) {\\n        int prevLazer =0;\\n        int ans =0;\\n        for(String s:bank){\\n            int curLazer = 0;\\n            for(char c: s.toCharArray()){\\n                if(c==\\'1\\'){\\n                    curLazer++;\\n                }\\n            }\\n            if(curLazer >0){\\n                ans += (curLazer * prevLazer);\\n                prevLazer = curLazer;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\n    public int numberOfBeams(String[] bank) {\n        int prevLazer =0;\n        int ans =0;\n        for(String s:bank){\n            int curLazer = 0;\n            for(char c: s.toCharArray()){\n                if(c=='1'){\n                    curLazer++;\n                }\n            }\n            if(curLazer = 0){\n                ans += (curLazer * prevLazer);\n                prevLazer = curLazer;\n            }\n        }\n        return ans;\n    }\n}\n",
        "explanations": "\nAn assignment operator (=) is used instead of comparison operator (==) in the if condition.\n"
    },
    {
        "slug": "shortest-path-in-a-grid-with-obstacles-elimination",
        "description": "You are given an m x n integer matrix grid where each cell is either 0 (empty) or 1 (obstacle). You can move up, down, left, or right from and to an empty cell in one step.\nReturn the minimum number of steps to walk from the upper left corner (0, 0) to the lower right corner (m - 1, n - 1) given that you can eliminate at most k obstacles. If it is not possible to find such walk return -1.",
        "examples": [
            "Input: grid = [[0,0,0],[1,1,0],[0,0,0],[0,1,1],[0,0,0]], k = 1\nOutput: 6\nExplanation: \nThe shortest path without eliminating any obstacle is 10.\nThe shortest path with one obstacle elimination at position (3,2) is 6. Such path is (0,0) -> (0,1) -> (0,2) -> (1,2) -> (2,2) -> (3,2) -> (4,2).",
            "Input: grid = [[0,1,1],[1,1,1],[1,0,0]], k = 1\nOutput: -1\nExplanation: We need to eliminate at least two obstacles to find such a walk."
        ],
        "constraints": "m == grid.length\nn == grid[i].length\n1 <= m, n <= 40\n1 <= k <= m * n\ngrid[i][j] is either 0 or 1.\ngrid[0][0] == grid[m - 1][n - 1] == 0",
        "release_time": 1667138796,
        "oracle_code": "class Solution {\n    int [] dirs = {0, 1, 0, -1, 0};\n    public int shortestPath(int[][] grid, int k) {\n        int m = grid.length, n = grid[0].length;\n        if(k >= m+n -2) return m+n-2;\n        \n        boolean[][][] visited = new boolean [m][n][k+1];\n        Queue<int[]> q = new LinkedList<>();\n        q.offer(new int[]{0, 0, k, 0});\n        visited[0][0][k] = true;\n        \n        while(!q.isEmpty()){\n            int [] top = q.poll();\n          \n            int r = top[0], c = top[1], curk = top[2], dist = top[3];\n            \n            if(r == m-1 && c == n -1) return dist;\n            for(int i = 0; i< 4; i++){\n                int nr = r + dirs[i], nc = c + dirs[i + 1];\n                if(nr < 0 || nr == m || nc < 0 || nc == n) continue;\n                int newK = curk - grid[nr][nc];\n            \n                if(newK >= 0 && !visited[nr][nc][newK]){\n                    visited[nr][nc][newK] = true;\n                    q.offer(new int[]{nr, nc, newK, dist + 1});\n                }\n            }\n        }\n        return -1;\n    }\n}",
        "content": "```\\nclass Solution {\\n    int [] dirs = {0, 1, 0, -1, 0};\\n    public int shortestPath(int[][] grid, int k) {\\n        int m = grid.length, n = grid[0].length;\\n        if(k >= m+n -2) return m+n-2;\\n        \\n        boolean[][][] visited = new boolean [m][n][k+1];\\n        Queue<int[]> q = new LinkedList<>();\\n        q.offer(new int[]{0, 0, k, 0});\\n        visited[0][0][k] = true;\\n        \\n        while(!q.isEmpty()){\\n            int [] top = q.poll();\\n          \\n            int r = top[0], c = top[1], curk = top[2], dist = top[3];\\n            \\n            if(r == m-1 && c == n -1) return dist;\\n            for(int i = 0; i< 4; i++){\\n                int nr = r + dirs[i], nc = c + dirs[i + 1];\\n                if(nr < 0 || nr == m || nc < 0 || nc == n) continue;\\n                int newK = curk - grid[nr][nc];\\n            \\n                if(newK >= 0 && !visited[nr][nc][newK]){\\n                    visited[nr][nc][newK] = true;\\n                    q.offer(new int[]{nr, nc, newK, dist + 1});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
        "level": "hard",
        "buggy_code": "\nclass Solution {\n    int [] dirs = {0, 1, 0, -1, 0};\n    public int shortestPath(int[][] grid, int k) {\n        int m = grid.length, n = grid[0].length;\n        if(k = m+n -2) return m+n-2;\n        \n        boolean[][][] visited = new boolean [m][n][k+1];\n        Queue<int[]> q = new LinkedList<>();\n        q.offer(new int[]{0, 0, k, 0});\n        visited[0][0][k] = true;\n        \n        while(!q.isEmpty()){\n            int [] top = q.poll();\n          \n            int r = top[0], c = top[1], curk = top[2], dist = top[3];\n            \n            if(r == m-1 && c == n -1) return dist;\n            for(int i = 0; i< 4; i++){\n                int nr = r + dirs[i], nc = c + dirs[i + 1];\n                if(nr < 0 || nr == m || nc < 0 || nc == n) continue;\n                int newK = curk - grid[nr][nc];\n            \n                if(newK >= 0 && !visited[nr][nc][newK]){\n                    visited[nr][nc][newK] = true;\n                    q.offer(new int[]{nr, nc, newK, dist + 1});\n                }\n            }\n        }\n        return -1;\n    }\n}\n",
        "explanations": "\nThe bug is in the if statement (if(k = m+n -2)); it should be if(k >= m+n -2).\n"
    },
    {
        "slug": "reverse-words-in-a-string",
        "description": "Given an input string s, reverse the order of the words.\nA word is defined as a sequence of non-space characters. The words in s will be separated by at least one space.\nReturn a string of the words in reverse order concatenated by a single space.\nNote that s may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words. Do not include any extra spaces.",
        "examples": [
            "Input: s = \"the sky is blue\"\nOutput: \"blue is sky the\"",
            "Input: s = \"  hello world  \"\nOutput: \"world hello\"\nExplanation: Your reversed string should not contain leading or trailing spaces.",
            "Input: s = \"a good   example\"\nOutput: \"example good a\"\nExplanation: You need to reduce multiple spaces between two words to a single space in the reversed string."
        ],
        "constraints": "1 <= s.length <= 104\ns contains English letters (upper-case and lower-case), digits, and spaces ' '.\nThere is at least one word in s.\n\n\u00a0\nFollow-up:\u00a0If the string data type is mutable in your language, can\u00a0you solve it\u00a0in-place\u00a0with\u00a0O(1)\u00a0extra space?",
        "release_time": 1692301725,
        "oracle_code": "class Solution {\n    public String reverseWords(String s) {\n        StringBuilder ans = new StringBuilder();\n        for(int i=s.length()-1; i>=0; i--){\n            if(s.charAt(i)==' '){\n                continue;\n            }\n            int start=-1;\n            for(int y=i-1; y>=0; y--){\n                if(s.charAt(y)==' '){\n                    start=y;\n                    break;\n                }\n            }\n            ans.append(s.substring(start+1, i+1) + \" \");\n            i=start;\n        }\n        ans.deleteCharAt(ans.length()-1);\n        return ans.toString();\n    }\n}",
        "content": "# Approach\\n- Two Pointer Approach\\n- Using Trim and Split\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public String reverseWords(String s) {\\n        StringBuilder ans = new StringBuilder();\\n        for(int i=s.length()-1; i>=0; i--){\\n            if(s.charAt(i)==\\' \\'){\\n                continue;\\n            }\\n            int start=-1;\\n            for(int y=i-1; y>=0; y--){\\n                if(s.charAt(y)==\\' \\'){\\n                    start=y;\\n                    break;\\n                }\\n            }\\n            ans.append(s.substring(start+1, i+1) + \" \");\\n            i=start;\\n        }\\n        ans.deleteCharAt(ans.length()-1);\\n        return ans.toString();\\n    }\\n}\\n```\\n```\\nclass Solution {\\n    public String reverseWords(String s) {\\n        String[] temp = s.trim().split(\" \");\\n        StringBuilder ans = new StringBuilder();\\n        for(int i=temp.length-1; i>0; i--){\\n            if(temp[i]==\"\"){\\n                continue;\\n            }\\n            ans.append(temp[i]+\" \");\\n        }\\n        ans.append(temp[0]);\\n        return ans.toString();\\n    }\\n}\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\n    public String reverseWords(String s) {\n        StringBuilder ans = new StringBuilder();\n        for(int i=s.length()-1; i>=0; i--){\n            if(s.charAt(i)==' '){\n                continue;\n            }\n            int start=-1;\n            for(int y=i-1; y>=0; y--){\n                if(s.charAt(y)==' '){\n                    start=y;\n                    break;\n                }\n            }\n            ans.append(s.substring(start+1, i+1) + \" \");\n            i=start;\n        }\n        ans.deleteCharAt(ans.length()-1);\n        return ans.toString()==s;\n    }\n}\n",
        "explanations": "\nThe method is expected to return a String, but the bug makes it return a boolean.\n"
    },
    {
        "slug": "transpose-matrix",
        "description": "Given a 2D integer array matrix, return the transpose of matrix.\nThe transpose of a matrix is the matrix flipped over its main diagonal, switching the matrix's row and column indices.",
        "examples": [
            "Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]\nOutput: [[1,4,7],[2,5,8],[3,6,9]]",
            "Input: matrix = [[1,2,3],[4,5,6]]\nOutput: [[1,4],[2,5],[3,6]]"
        ],
        "constraints": "m == matrix.length\nn == matrix[i].length\n1 <= m, n <= 1000\n1 <= m * n <= 105\n-109 <= matrix[i][j] <= 109",
        "release_time": 1683736465,
        "oracle_code": "class Solution {\n    public int[][] transpose(int[][] matrix) {\n        int[][] ans = new int[matrix[0].length][matrix.length];\n        int row = 0;\n        int col = 0;\n\n        for(int i = 0; i < matrix.length; i++) {\n            for(int j = 0; j < matrix[0].length; j++) {\n                ans[row][col] = matrix[i][j];\n\n                row++;\n\n                if(row % ans.length == 0) {\n                    row = 0;\n                    col++;\n                }\n            }\n        }\n        return ans;\n    }\n}",
        "content": "# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] transpose(int[][] matrix) {\\n        int[][] ans = new int[matrix[0].length][matrix.length];\\n        int row = 0;\\n        int col = 0;\\n\\n        for(int i = 0; i < matrix.length; i++) {\\n            for(int j = 0; j < matrix[0].length; j++) {\\n                ans[row][col] = matrix[i][j];\\n\\n                row++;\\n\\n                if(row % ans.length == 0) {\\n                    row = 0;\\n                    col++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\n    public int[][] transpose(int[][] matrix) {\n        int[][] ans = new int[matrix[0].length][matrix.length];\n        int row = 0;\n        int col = 0;\n\n        for(int i = 0; i < matrix.length; i++) {\n            for(int j = 0; j < matrix[0].length; j++) {\n                ans[row][col] = matrix[i][j];\n\n                row++;\n\n                if(row = ans.length) {\n                    row = 0;\n                    col++;\n                }\n            }\n        }\n        return ans;\n    }\n}\n",
        "explanations": "\nInstead of checking if 'row' is equal to 'ans.length', the code wrongly assigns 'ans.length' to 'row'.\n"
    },
    {
        "slug": "a-number-after-a-double-reversal",
        "description": "Reversing an integer means to reverse all its digits.\n\nFor example, reversing 2021 gives 1202. Reversing 12300 gives 321 as the leading zeros are not retained.\n\nGiven an integer num, reverse num to get reversed1, then reverse reversed1 to get reversed2. Return true if reversed2 equals num. Otherwise return false.",
        "examples": [
            "Input: num = 526\nOutput: true\nExplanation: Reverse num to get 625, then reverse 625 to get 526, which equals num.",
            "Input: num = 1800\nOutput: false\nExplanation: Reverse num to get 81, then reverse 81 to get 18, which does not equal num.",
            "Input: num = 0\nOutput: true\nExplanation: Reverse num to get 0, then reverse 0 to get 0, which equals num."
        ],
        "constraints": "0 <= num <= 106",
        "release_time": 1686977158,
        "oracle_code": "class Solution {\n    public boolean isSameAfterReversals(int num) \n    {\n        int n=num,ans=0;\n        while(n!=0)\n        {\n            int l=n%10;\n            ans=(ans*10)+l;\n            n=n/10;\n        } \n        String s1=Integer.toString(num);\n        String s2=Integer.toString(ans);\n        if(s1.length()==s2.length())  return true;\n        return false;\n    }\n}",
        "content": "# Intuition\\nStep 1: Reverse the number and store it in a variable.\\nStep 2: Take the two integers and convert it into String.\\nStep 3: Check whether both of the string length is equal or not.\\nStep 4: If it is equal return true, else return false.\\n\\n# Approach\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isSameAfterReversals(int num) \\n    {\\n        int n=num,ans=0;\\n        while(n!=0)\\n        {\\n            int l=n%10;\\n            ans=(ans*10)+l;\\n            n=n/10;\\n        } \\n        String s1=Integer.toString(num);\\n        String s2=Integer.toString(ans);\\n        if(s1.length()==s2.length())  return true;\\n        return false;\\n    }\\n}\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\n    public boolean isSameAfterReversals(int num) \n    {\n        int n=num,ans=0;\n        while(n!=0)\n        {\n            int l=n%10;\n            ans=(ans*10)+l;\n            n=n/10;\n        } \n        String s1=Integer.toString(num);\n        String s2=Integer.toString(ans);\n        if(s1.length()=s2.length())  return true;\n        return false;\n    }\n}\n",
        "explanations": "\nThe bug is in the condition of if statement, used assignment operator '=' instead of '=='.\n"
    },
    {
        "slug": "lowest-common-ancestor-of-a-binary-search-tree",
        "description": "Given a binary search tree (BST), find the lowest common ancestor (LCA) node of two given nodes in the BST.\nAccording to the definition of LCA on Wikipedia: \u201cThe lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).\u201d",
        "examples": [
            "Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8\nOutput: 6\nExplanation: The LCA of nodes 2 and 8 is 6.",
            "Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4\nOutput: 2\nExplanation: The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.",
            "Input: root = [2,1], p = 2, q = 1\nOutput: 2"
        ],
        "constraints": "The number of nodes in the tree is in the range [2, 105].\n-109 <= Node.val <= 109\nAll Node.val are unique.\np != q\np and q will exist in the BST.",
        "release_time": 1681332056,
        "oracle_code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\n\nclass Solution {\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        if(root == null || root == p || root == q)return root;\n\n        TreeNode left = lowestCommonAncestor(root.left, p , q);\n        TreeNode right = lowestCommonAncestor(root.right, p ,q);\n\n        if(left == null)return right;\n        if(right == null)return left;\n        else{\n            return root;\n        }\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\n\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if(root == null || root == p || root == q)return root;\\n\\n        TreeNode left = lowestCommonAncestor(root.left, p , q);\\n        TreeNode right = lowestCommonAncestor(root.right, p ,q);\\n\\n        if(left == null)return right;\\n        if(right == null)return left;\\n        else{\\n            return root;\\n        }\\n    }\\n}\\n```",
        "level": "medium",
        "buggy_code": "\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\n\nclass Solution {\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        if(root = null || root == p || root == q)return root;\n\n        TreeNode left = lowestCommonAncestor(root.left, p , q);\n        TreeNode right = lowestCommonAncestor(root.right, p ,q);\n\n        if(left == null)return right;\n        if(right == null)return left;\n        else{\n            return root;\n        }\n    }\n}\n",
        "explanations": "\nThe first if statement in the lowestCommonAncestor function is supposed to compare root with null, p, q, but instead it assigns null to the root variable which leads to NullPointerException.\n"
    },
    {
        "slug": "goat-latin",
        "description": "You are given a string sentence that consist of words separated by spaces. Each word consists of lowercase and uppercase letters only.\nWe would like to convert the sentence to \"Goat Latin\" (a made-up language similar to Pig Latin.) The rules of Goat Latin are as follows:\n\nIf a word begins with a vowel ('a', 'e', 'i', 'o', or 'u'), append \"ma\" to the end of the word.\n\n\t\nFor example, the word \"apple\" becomes \"applema\".\n\n\nIf a word begins with a consonant (i.e., not a vowel), remove the first letter and append it to the end, then add \"ma\".\n\t\nFor example, the word \"goat\" becomes \"oatgma\".\n\n\nAdd one letter 'a' to the end of each word per its word index in the sentence, starting with 1.\n\t\nFor example, the first word gets \"a\" added to the end, the second word gets \"aa\" added to the end, and so on.\n\n\n\nReturn the final sentence representing the conversion from sentence to Goat Latin.",
        "examples": [
            "Input: sentence = \"I speak Goat Latin\"\nOutput: \"Imaa peaksmaaa oatGmaaaa atinLmaaaaa\"",
            "Input: sentence = \"The quick brown fox jumped over the lazy dog\"\nOutput: \"heTmaa uickqmaaa rownbmaaaa oxfmaaaaa umpedjmaaaaaa overmaaaaaaa hetmaaaaaaaa azylmaaaaaaaaa ogdmaaaaaaaaaa\""
        ],
        "constraints": "1 <= sentence.length <= 150\nsentence consists of English letters and spaces.\nsentence has no leading or trailing spaces.\nAll the words in sentence are separated by a single space.",
        "release_time": 1683445696,
        "oracle_code": "class Solution {\n    public String toGoatLatin(String sentence) {\n        sentence.toLowerCase();\n        String[] words=sentence.split(\" \",0);\n        int i=1;\n        String ans=\"\";\n        for(String word:words){\n           \n            char p1=word.charAt(0);\n            char p=word.toLowerCase().charAt(0);\n            String k=\"\";\n            if(p=='a'||p=='i'||p=='o'||p=='e'||p=='u'){\n                k+=word+\"ma\";\n            }\n            else{\n                k+=word.substring(1,word.length());\n                k+=p1;\n                k+=\"ma\";\n            }\n            for(int m=0;m<i;m++){\n               k+='a';\n            }\n            ans+=k;\n            if(i!=words.length)ans+=\" \";\n            i++;\n        }\n        return ans;\n    }\n}",
        "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public String toGoatLatin(String sentence) {\\n        sentence.toLowerCase();\\n        String[] words=sentence.split(\" \",0);\\n        int i=1;\\n        String ans=\"\";\\n        for(String word:words){\\n           \\n            char p1=word.charAt(0);\\n            char p=word.toLowerCase().charAt(0);\\n            String k=\"\";\\n            if(p==\\'a\\'||p==\\'i\\'||p==\\'o\\'||p==\\'e\\'||p==\\'u\\'){\\n                k+=word+\"ma\";\\n            }\\n            else{\\n                k+=word.substring(1,word.length());\\n                k+=p1;\\n                k+=\"ma\";\\n            }\\n            for(int m=0;m<i;m++){\\n               k+=\\'a\\';\\n            }\\n            ans+=k;\\n            if(i!=words.length)ans+=\" \";\\n            i++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\n    public String toGoatLatin(String sentence) {\n        sentence.toLowerCase();\n        String[] words=sentence.split(\" \",0);\n        int i=1;\n        String ans=\"\";\n        for(String word:words){\n           \n            char p1=word.charAt(0);\n            char p=word.toLowerCase().charAt(0);\n            String k=\"\";\n            if(p=='a'||p=='i'||p=='o'||p=='e'||p=='u'){\n                k+=word+\"ma\";\n            }\n            else{\n                k+=word.substring(1,word.length());\n                k+=p1;\n                k+=\"ma\";\n            }\n            for(int m=0;m<i;m++){\n               k+='a';\n            }\n            ans+=k;\n            if(i==words.length)ans+=\" \";\n            i++;\n        }\n        return ans;\n    }\n}\n",
        "explanations": "\nThe bug is with the if condition where it equates i with words.length instead of checking if it's not equal, causing additional space at the end of the sentence.\n"
    },
    {
        "slug": "number-of-arithmetic-triplets",
        "description": "You are given a 0-indexed, strictly increasing integer array nums and a positive integer diff. A triplet (i, j, k) is an arithmetic triplet if the following conditions are met:\n\ni < j < k,\nnums[j] - nums[i] == diff, and\nnums[k] - nums[j] == diff.\n\nReturn the number of unique arithmetic triplets.",
        "examples": [
            "Input: nums = [0,1,4,6,7,10], diff = 3\nOutput: 2\nExplanation:\n(1, 2, 4) is an arithmetic triplet because both 7 - 4 == 3 and 4 - 1 == 3.\n(2, 4, 5) is an arithmetic triplet because both 10 - 7 == 3 and 7 - 4 == 3.",
            "Input: nums = [4,5,6,7,8,9], diff = 2\nOutput: 2\nExplanation:\n(0, 2, 4) is an arithmetic triplet because both 8 - 6 == 2 and 6 - 4 == 2.\n(1, 3, 5) is an arithmetic triplet because both 9 - 7 == 2 and 7 - 5 == 2."
        ],
        "constraints": "3 <= nums.length <= 200\n0 <= nums[i] <= 200\n1 <= diff <= 50\nnums is strictly increasing.",
        "release_time": 1688291896,
        "oracle_code": "class Solution {\n    public int arithmeticTriplets(int[] nums, int diff) {\n        int ans =0;\n        for(int i=0; i<nums.length-2;i++){\n            int count =0;\n            for(int j=i+1; j<nums.length; j++){\n                if(nums[j]-nums[i]==diff || nums[j]-nums[i]==2*diff){\n                    count++;\n                }\n            }\n            if(count >= 2){\n                ans++;\n            }\n        }\n\n        return ans;\n        \n    }\n}",
        "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe have to find a triplet of (i, j, k) such that \\ni<j<k , \\nnums[j] - nums[i] == diff, and \\nnums[k] - nums[j] == diff\\n\\nin other word we can also say nums[k]-nums[i]== 2*diff. To reduce the time complexity I use only 2 loop remove the loop for k and include it in j iterartion such that nums[j]-nums[i] == 2*diff. So in every iterartion of j we will get 2 condition nums[j]-nums[i] == diff and nums[j]-nums[i] == 2*diff when these 2 condition get satisfied in j iterartion, We get 1 count as answer. So for every iteration when count>=2 we add 1 to ans and at last return it.\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int arithmeticTriplets(int[] nums, int diff) {\\n        int ans =0;\\n        for(int i=0; i<nums.length-2;i++){\\n            int count =0;\\n            for(int j=i+1; j<nums.length; j++){\\n                if(nums[j]-nums[i]==diff || nums[j]-nums[i]==2*diff){\\n                    count++;\\n                }\\n            }\\n            if(count >= 2){\\n                ans++;\\n            }\\n        }\\n\\n        return ans;\\n        \\n    }\\n}\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\n    public int arithmeticTriplets(int[] nums, int diff) {\n        int ans =0;\n        for(int i=0; i<nums.length-2;i++){\n            int count =0;\n            for(int j=i+1; j<nums.length; j++){\n                if(nums[j]-nums[i]=diff || nums[j]-nums[i]=2*diff){\n                    count++;\n                }\n            }\n            if(count >= 2){\n                ans++;\n            }\n        }\n\n        return ans;\n        \n    }\n}\n",
        "explanations": "\nIn the if-statement, assignment operator \"=\" is used instead of comparison operator \"==\". \n"
    },
    {
        "slug": "is-graph-bipartite",
        "description": "There is an undirected graph with n nodes, where each node is numbered between 0 and n - 1. You are given a 2D array graph, where graph[u] is an array of nodes that node u is adjacent to. More formally, for each v in graph[u], there is an undirected edge between node u and node v. The graph has the following properties:\n\nThere are no self-edges (graph[u] does not contain u).\nThere are no parallel edges (graph[u] does not contain duplicate values).\nIf v is in graph[u], then u is in graph[v] (the graph is undirected).\nThe graph may not be connected, meaning there may be two nodes u and v such that there is no path between them.\n\nA graph is bipartite if the nodes can be partitioned into two independent sets A and B such that every edge in the graph connects a node in set A and a node in set B.\nReturn true if and only if it is bipartite.",
        "examples": [
            "Input: graph = [[1,2,3],[0,2],[0,1,3],[0,2]]\nOutput: false\nExplanation: There is no way to partition the nodes into two independent sets such that every edge connects a node in one and a node in the other.",
            "Input: graph = [[1,3],[0,2],[1,3],[0,2]]\nOutput: true\nExplanation: We can partition the nodes into two sets: {0, 2} and {1, 3}."
        ],
        "constraints": "graph.length == n\n1 <= n <= 100\n0 <= graph[u].length < n\n0 <= graph[u][i] <= n - 1\ngraph[u]\u00a0does not contain\u00a0u.\nAll the values of graph[u] are unique.\nIf graph[u] contains v, then graph[v] contains u.",
        "release_time": 1684457315,
        "oracle_code": "class Solution {\n\tint[] colors;\n    public boolean isBipartite(int[][] graph) {\n        HashMap<Integer, ArrayList<Integer>> adj = new HashMap<Integer, ArrayList<Integer>>();\n\t\tcolors = new int[graph.length];\n\t\t\n\t\tfor (int i = 0; i < graph.length; i++) {\n\t\t\tadj.putIfAbsent(i, new ArrayList<Integer>());\n\t\t\tfor(int j=0;j<graph[i].length;j++){\n                adj.get(i).add(graph[i][j]);\n            }\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < colors.length; i++) {\n\t\t\tif(colors[i]==0 && adj.get(i)==null) {\n\t\t\t\tcolors[i]=1;\n\t\t\t}\n\t\t\telse if(colors[i]==0 && !(adj.get(i)==null)) {\n\t\t\t\tif(!bfs(adj, i)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tprivate boolean bfs(HashMap<Integer, ArrayList<Integer>> adj, int node) {\n\t\tArrayList<Integer> que = new ArrayList<Integer>();\n\t\tque.add(node);\n\t\tcolors[node] = 1;\n\t\tint c =0;\n\t\twhile(que.size()>0) {\n\t\t\t\n\t\t\tfor(int i=0;i<adj.get(que.get(0)).size();i++) {\n\t\t\t\tif(colors[adj.get(que.get(0)).get(i)]==0) {\n\t\t\t\t\tif(colors[que.get(0)]==1) {\n\t\t\t\t\t\tcolors[adj.get(que.get(0)).get(i)] = 2;\n\t\t\t\t\t\tque.add(adj.get(que.get(0)).get(i));\n\t\t\t\t\t}\n\t\t\t\t\telse if(colors[que.get(0)]==2) {\n\t\t\t\t\t\tcolors[adj.get(que.get(0)).get(i)] = 1;\n\t\t\t\t\t\tque.add(adj.get(que.get(0)).get(i));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(colors[que.get(0)]==colors[adj.get(que.get(0)).get(i)]) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n            }\n\t\t\tque.remove(0);\n\t\t}\n\t\treturn true\t;\n\t}\n}",
        "content": "# PLEASE UPVOTE!!!\\n\\n# Intuition & Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing BFS and Graph Coloring Approach.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\nN is no of edges\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\nN is no of edges\\n\\n# Code\\n```\\nclass Solution {\\n\\tint[] colors;\\n    public boolean isBipartite(int[][] graph) {\\n        HashMap<Integer, ArrayList<Integer>> adj = new HashMap<Integer, ArrayList<Integer>>();\\n\\t\\tcolors = new int[graph.length];\\n\\t\\t\\n\\t\\tfor (int i = 0; i < graph.length; i++) {\\n\\t\\t\\tadj.putIfAbsent(i, new ArrayList<Integer>());\\n\\t\\t\\tfor(int j=0;j<graph[i].length;j++){\\n                adj.get(i).add(graph[i][j]);\\n            }\\n\\t\\t}\\n\\t\\t\\n\\t\\tfor (int i = 0; i < colors.length; i++) {\\n\\t\\t\\tif(colors[i]==0 && adj.get(i)==null) {\\n\\t\\t\\t\\tcolors[i]=1;\\n\\t\\t\\t}\\n\\t\\t\\telse if(colors[i]==0 && !(adj.get(i)==null)) {\\n\\t\\t\\t\\tif(!bfs(adj, i)) {\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n\\t\\n\\tprivate boolean bfs(HashMap<Integer, ArrayList<Integer>> adj, int node) {\\n\\t\\tArrayList<Integer> que = new ArrayList<Integer>();\\n\\t\\tque.add(node);\\n\\t\\tcolors[node] = 1;\\n\\t\\tint c =0;\\n\\t\\twhile(que.size()>0) {\\n\\t\\t\\t\\n\\t\\t\\tfor(int i=0;i<adj.get(que.get(0)).size();i++) {\\n\\t\\t\\t\\tif(colors[adj.get(que.get(0)).get(i)]==0) {\\n\\t\\t\\t\\t\\tif(colors[que.get(0)]==1) {\\n\\t\\t\\t\\t\\t\\tcolors[adj.get(que.get(0)).get(i)] = 2;\\n\\t\\t\\t\\t\\t\\tque.add(adj.get(que.get(0)).get(i));\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse if(colors[que.get(0)]==2) {\\n\\t\\t\\t\\t\\t\\tcolors[adj.get(que.get(0)).get(i)] = 1;\\n\\t\\t\\t\\t\\t\\tque.add(adj.get(que.get(0)).get(i));\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tif(colors[que.get(0)]==colors[adj.get(que.get(0)).get(i)]) {\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t}\\n            }\\n\\t\\t\\tque.remove(0);\\n\\t\\t}\\n\\t\\treturn true\\t;\\n\\t}\\n}\\n\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\n\tint[] colors;\n    public boolean isBipartite(int[][] graph) {\n        HashMap<Integer, ArrayList<Integer>> adj = new HashMap<Integer, ArrayList<Integer>>();\n\t\tcolors = new int[graph.length];\n\t\t\n\t\tfor (int i = 0; i < graph.length; i++) {\n\t\t\tadj.putIfAbsent(i, new ArrayList<Integer>());\n\t\t\tfor(int j=0;j<graph[i].length;j++){\n                adj.get(i).add(graph[i][j]);\n            }\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < colors.length; i++) {\n\t\t\tif(colors[i] = 0 && adj.get(i)==null) {\n\t\t\t\tcolors[i]=1;\n\t\t\t}\n\t\t\telse if(colors[i] = 0 && !(adj.get(i)==null)) {\n\t\t\t\tif(!bfs(adj, i)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tprivate boolean bfs(HashMap<Integer, ArrayList<Integer>> adj, int node) {\n\t\tArrayList<Integer> que = new ArrayList<Integer>();\n\t\tque.add(node);\n\t\tcolors[node] = 1;\n\t\tint c =0;\n\t\twhile(que.size() > 0) {\n\t\t\t\n\t\t\tfor(int i=0;i<adj.get(que.get(0)).size();i++) {\n\t\t\t\tif(colors[adj.get(que.get(0)).get(i)] = 0) {\n\t\t\t\t\tif(colors[que.get(0)] == 1) {\n\t\t\t\t\t\tcolors[adj.get(que.get(0)).get(i)] = 2;\n\t\t\t\t\t\tque.add(adj.get(que.get(0)).get(i));\n\t\t\t\t\t}\n\t\t\t\t\telse if(colors[que.get(0)] == 2) {\n\t\t\t\t\t\tcolors[adj.get(que.get(0)).get(i)] = 1;\n\t\t\t\t\t\tque.add(adj.get(que.get(0)).get(i));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(colors[que.get(0)] == colors[adj.get(que.get(0)).get(i)]) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n            }\n\t\t\tque.remove(0);\n\t\t}\n\t\treturn true\t;\n\t}\n}\n",
        "explanations": "\nThe bug is in the two if statements where there is assignment (=) instead of equality (==) check.\n"
    },
    {
        "slug": "remove-colored-pieces-if-both-neighbors-are-the-same-color",
        "description": "There are n pieces arranged in a line, and each piece is colored either by 'A' or by 'B'. You are given a string colors of length n where colors[i] is the color of the ith piece.\nAlice and Bob are playing a game where they take alternating turns removing pieces from the line. In this game, Alice moves first.\n\nAlice is only allowed to remove a piece colored 'A' if both its neighbors are also colored 'A'. She is not allowed to remove pieces that are colored 'B'.\nBob is only allowed to remove a piece colored 'B' if both its neighbors are also colored 'B'. He is not allowed to remove pieces that are colored 'A'.\nAlice and Bob cannot remove pieces from the edge of the line.\nIf a player cannot make a move on their turn, that player loses and the other player wins.\n\nAssuming Alice and Bob play optimally, return true if Alice wins, or return false if Bob wins.",
        "examples": [
            "Input: colors = \"AAABABB\"\nOutput: true\nExplanation:\nAAABABB -> AABABB\nAlice moves first.\nShe removes the second 'A' from the left since that is the only 'A' whose neighbors are both 'A'.\n\nNow it's Bob's turn.\nBob cannot make a move on his turn since there are no 'B's whose neighbors are both 'B'.\nThus, Alice wins, so return true.",
            "Input: colors = \"AA\"\nOutput: false\nExplanation:\nAlice has her turn first.\nThere are only two 'A's and both are on the edge of the line, so she cannot move on her turn.\nThus, Bob wins, so return false.",
            "Input: colors = \"ABBBBBBBAAA\"\nOutput: false\nExplanation:\nABBBBBBBAAA -> ABBBBBBBAA\nAlice moves first.\nHer only option is to remove the second to last 'A' from the right.\n\nABBBBBBBAA -> ABBBBBBAA\nNext is Bob's turn.\nHe has many options for which 'B' piece to remove. He can pick any.\n\nOn Alice's second turn, she has no more pieces that she can remove.\nThus, Bob wins, so return false."
        ],
        "constraints": "1 <=\u00a0colors.length <= 105\ncolors\u00a0consists of only the letters\u00a0'A'\u00a0and\u00a0'B'",
        "release_time": 1657989117,
        "oracle_code": "class Solution {\n    public boolean winnerOfGame(String s) {\n        //count the triplets\nint n = s.length();\n    \n        int a=0;\n        int b=0;\n        \n        for(int i=1; i<n-1; i++)\n        {\n            if(s.charAt(i)=='A' && s.charAt(i-1)=='A' && s.charAt(i+1)=='A' )\n        a++;\n            else if(s.charAt(i)=='B' && s.charAt(i-1)=='B' && s.charAt(i+1)=='B' )\n        b++;\n            \n            }\n        if(a<=b)\n            return false;\n        else\n            return true;\n        \n    \n    }\n}",
        "content": "Idea behind it is that you need to count the number of triplets of both A and B \\nint a -> number of triplets of \\'A\\'\\nint b -> number of triplets of \\'B\\'\\nif(b>=a) BOB wins else Alice wins\\n\\nAs Alice has to make a move first so if she wants to win there should be atleast  1 more  triplets of A than B\\n\\nEg There are 4 triplets of both A and B  (a=4, b=4) \\n1. Alice removes 1 A (a=3, b=4)\\n2. Bob removes 1 B (a=3, b=3)\\n3. (a=2, b=3)\\n4. (a=2, b=2)\\n5. (a=1, b=2)\\n6. (a=1, b=1)\\n7. (a=0, b=1)\\n\\nClearly Alice will lose if both have same number of triplets\\nCode \\n\\n```\\nclass Solution {\\n    public boolean winnerOfGame(String s) {\\n        //count the triplets\\nint n = s.length();\\n    \\n        int a=0;\\n        int b=0;\\n        \\n        for(int i=1; i<n-1; i++)\\n        {\\n            if(s.charAt(i)==\\'A\\' && s.charAt(i-1)==\\'A\\' && s.charAt(i+1)==\\'A\\' )\\n        a++;\\n            else if(s.charAt(i)==\\'B\\' && s.charAt(i-1)==\\'B\\' && s.charAt(i+1)==\\'B\\' )\\n        b++;\\n            \\n            }\\n        if(a<=b)\\n            return false;\\n        else\\n            return true;\\n        \\n    \\n    }\\n}\\n```\\nIf this helped you then please UpVote\\nThanks\\n\\n\\n",
        "level": "medium",
        "buggy_code": "\nclass Solution {\n    public boolean winnerOfGame(String s) {\n        //count the triplets\n        int n = s.length();\n    \n        int a=0;\n        int b=0;\n        \n        for(int i=1; i<n-1; i++)\n        {\n            if(s.charAt(i)=='A' && s.charAt(i-1)=='A' && s.charAt(i+1)=='A' )\n                a++;\n            else if(s.charAt(i)=='B' && s.charAt(i-1)=='B' && s.charAt(i+1)=='B' )\n                b++;\n        }\n        if(a == b)\n            return false;\n        else\n            return true;\n    }\n}\n",
        "explanations": "\nThe \"a == b\" should be \"a <= b\". In the added bug, Python evaluates it as equality not assignment.\n"
    },
    {
        "slug": "reverse-nodes-in-even-length-groups",
        "description": "You are given the head of a linked list.\nThe nodes in the linked list are sequentially assigned to non-empty groups whose lengths form the sequence of the natural numbers (1, 2, 3, 4, ...). The length of a group is the number of nodes assigned to it. In other words,\n\nThe 1st node is assigned to the first group.\nThe 2nd and the 3rd nodes are assigned to the second group.\nThe 4th, 5th, and 6th nodes are assigned to the third group, and so on.\n\nNote that the length of the last group may be less than or equal to 1 + the length of the second to last group.\nReverse the nodes in each group with an even length, and return the head of the modified linked list.",
        "examples": [
            "Input: head = [5,2,6,3,9,1,7,3,8,4]\nOutput: [5,6,2,3,9,1,4,8,3,7]\nExplanation:\n- The length of the first group is 1, which is odd, hence no reversal occurs.\n- The length of the second group is 2, which is even, hence the nodes are reversed.\n- The length of the third group is 3, which is odd, hence no reversal occurs.\n- The length of the last group is 4, which is even, hence the nodes are reversed.",
            "Input: head = [1,1,0,6]\nOutput: [1,0,1,6]\nExplanation:\n- The length of the first group is 1. No reversal occurs.\n- The length of the second group is 2. The nodes are reversed.\n- The length of the last group is 1. No reversal occurs.",
            "Input: head = [1,1,0,6,5]\nOutput: [1,0,1,5,6]\nExplanation:\n- The length of the first group is 1. No reversal occurs.\n- The length of the second group is 2. The nodes are reversed.\n- The length of the last group is 2. The nodes are reversed."
        ],
        "constraints": "The number of nodes in the list is in the range [1, 105].\n0 <= Node.val <= 105",
        "release_time": 1675553997,
        "oracle_code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode reverseEvenLengthGroups(ListNode head) {\n        if(head == null) return head;\n\n        int groupSize = 1;\n        int count = 0;\n        ListNode left = null;\n        ListNode ptr = head;\n        ListNode last = null;\n        \n        while(ptr != null) {\n            count++;\n            if(count == groupSize) {\n                if(groupSize  % 2 == 0) {\n                    ListNode end = ptr.next;\n                   // reverse\n                    ListNode cur = left;\n                    ListNode next = null;\n                    ListNode prev = ptr.next;\n                    while(cur != end) {\n                        next = cur.next;\n                        cur.next = prev;\n                        prev = cur;\n                        cur = next;\n                    }\n                    // connect\n                    last.next = prev;\n                    ptr = left;\n                   \n                }\n                last = ptr;\n                left = ptr.next;\n                count = 0;\n                groupSize++;\n            }\n            ptr = ptr.next;\n        }\n\n        if(count > 0 && count % 2 == 0) {\n            // reverse\n            ListNode cur = left;\n            ListNode next = null;\n            ListNode prev = ptr;\n\n            while(cur != null) {\n                next = cur.next;\n                cur.next = prev;\n                prev = cur;\n                cur = next;\n            }\n\n            last.next = prev;\n        }\n\n        return head;\n    }\n\n}",
        "content": "# Approach\\nUse sliding window idea by keeping track of last node (of previous group), left node (of current group), pointer node (traverse list), groupSize, count of nodes in current group.\\n\\nOnce you start iterating, you will have to reverse current group if it meets the 2 conditions.\\n1. Count == groupSize\\n2. groupSize is even\\n\\nYou reverse and connect the reversed list back to your main list. Then you must update your iteration pointer since it will be in the back of the reversed list.\\n\\nAlso update last seen node (of previous group), new left node, count, and groupsize.\\n\\nDo the same reverse for the remaining nodes.\\n\\n# Complexity\\n- Time complexity:\\nO(N): One iteration of list is done.\\n\\n- Space complexity:\\nO(1): Constant # of variables/pointers\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        if(head == null) return head;\\n\\n        int groupSize = 1;\\n        int count = 0;\\n        ListNode left = null;\\n        ListNode ptr = head;\\n        ListNode last = null;\\n        \\n        while(ptr != null) {\\n            count++;\\n            if(count == groupSize) {\\n                if(groupSize  % 2 == 0) {\\n                    ListNode end = ptr.next;\\n                   // reverse\\n                    ListNode cur = left;\\n                    ListNode next = null;\\n                    ListNode prev = ptr.next;\\n                    while(cur != end) {\\n                        next = cur.next;\\n                        cur.next = prev;\\n                        prev = cur;\\n                        cur = next;\\n                    }\\n                    // connect\\n                    last.next = prev;\\n                    ptr = left;\\n                   \\n                }\\n                last = ptr;\\n                left = ptr.next;\\n                count = 0;\\n                groupSize++;\\n            }\\n            ptr = ptr.next;\\n        }\\n\\n        if(count > 0 && count % 2 == 0) {\\n            // reverse\\n            ListNode cur = left;\\n            ListNode next = null;\\n            ListNode prev = ptr;\\n\\n            while(cur != null) {\\n                next = cur.next;\\n                cur.next = prev;\\n                prev = cur;\\n                cur = next;\\n            }\\n\\n            last.next = prev;\\n        }\\n\\n        return head;\\n    }\\n\\n}\\n```",
        "level": "medium",
        "buggy_code": "\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode reverseEvenLengthGroups(ListNode head) {\n        if(head == null) return head;\n\n        int groupSize = 1;\n        int count = 0;\n        ListNode left = null;\n        ListNode ptr = head;\n        ListNode last = null;\n        \n        while(ptr != null) {\n            count++;\n            if(count = groupSize) { \n                if(groupSize  % 2 == 0) {\n                    ListNode end = ptr.next;\n                   // reverse\n                    ListNode cur = left;\n                    ListNode next = null;\n                    ListNode prev = ptr.next;\n                    while(cur != end) {\n                        next = cur.next;\n                        cur.next = prev;\n                        prev = cur;\n                        cur = next;\n                    }\n                    // connect\n                    last.next = prev;\n                    ptr = left;\n                   \n                }\n                last = ptr;\n                left = ptr.next;\n                count = 0;\n                groupSize++;\n            }\n            ptr = ptr.next;\n        }\n\n        if(count > 0 && count % 2 == 0) {\n            // reverse\n            ListNode cur = left;\n            ListNode next = null;\n            ListNode prev = ptr;\n\n            while(cur != null) {\n                next = cur.next;\n                cur.next = prev;\n                prev = cur;\n                cur = next;\n            }\n\n            last.next = prev;\n        }\n\n        return head;\n    }\n\n}\n",
        "explanations": "\nThe == operator was replaced with = in the condition (count = groupSize), making it an assignment statement.\n"
    },
    {
        "slug": "set-matrix-zeroes",
        "description": "Given an m x n integer matrix matrix, if an element is 0, set its entire row and column to 0's.\nYou must do it in place.",
        "examples": [
            "Input: matrix = [[1,1,1],[1,0,1],[1,1,1]]\nOutput: [[1,0,1],[0,0,0],[1,0,1]]",
            "Input: matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]\nOutput: [[0,0,0,0],[0,4,5,0],[0,3,1,0]]"
        ],
        "constraints": "m == matrix.length\nn == matrix[0].length\n1 <= m, n <= 200\n-231 <= matrix[i][j] <= 231 - 1",
        "release_time": 1692355209,
        "oracle_code": "class Solution {\n    public void setZeroes(int[][] matrix) {\n        ArrayList<Integer> row = new ArrayList<>();\n        ArrayList<Integer> col = new ArrayList<>();\n        for(int i=0; i<matrix.length; i++){\n            for(int j=0; j<matrix[0].length; j++){\n                if(matrix[i][j] == 0){\n                    row.add(i);\n                    col.add(j);\n                }\n            }\n        }\n\n         for(int i=0; i<matrix.length; i++){\n            if(row.contains(i)){\n                for(int j=0; j<matrix[0].length; j++){\n                    matrix[i][j] = 0;\n                }\n            }\n            else{\n                for(int j=0; j<matrix[0].length; j++){\n                    if(col.contains(j)){\n                        matrix[i][j] = 0;\n                    }\n                }\n            }\n        }\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nstoring data in first row and first col.\\n\\n# Complexity\\n- Time complexity:\\n- O(n*m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# brute force code :\\n```\\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n        ArrayList<Integer> row = new ArrayList<>();\\n        ArrayList<Integer> col = new ArrayList<>();\\n        for(int i=0; i<matrix.length; i++){\\n            for(int j=0; j<matrix[0].length; j++){\\n                if(matrix[i][j] == 0){\\n                    row.add(i);\\n                    col.add(j);\\n                }\\n            }\\n        }\\n\\n         for(int i=0; i<matrix.length; i++){\\n            if(row.contains(i)){\\n                for(int j=0; j<matrix[0].length; j++){\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n            else{\\n                for(int j=0; j<matrix[0].length; j++){\\n                    if(col.contains(j)){\\n                        matrix[i][j] = 0;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n}\\n```\\ntime - c for upper one is O(n+m)\\n\\n\\n\\n#  Optimize code\\n```\\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n        boolean fr = false, fc = false;\\n        for(int i=0; i<matrix.length; i++){\\n            for(int j=0; j<matrix[0].length; j++){\\n                if(matrix[i][j] == 0){\\n                    if(i == 0) fr = true;\\n                    if(j == 0) fc = true;\\n                    matrix[i][0] = 0;\\n                    matrix[0][j] = 0;\\n                }\\n            }\\n        }\\n        for(int i=1; i<matrix.length; i++){\\n            for(int j=1; j<matrix[0].length; j++){\\n                if(matrix[i][0] == 0 || matrix[0][j] == 0){\\n                    matrix[i][j] = 0;\\n                }  \\n            }\\n        }\\n\\n        if(fr) {\\n            for(int i=0; i<matrix[0].length; i++){\\n                matrix[0][i] = 0;\\n            }\\n        }\\n        if(fc) {\\n            for(int i=0; i<matrix.length; i++){\\n                matrix[i][0] = 0;\\n            }\\n        }\\n    }\\n}\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\n    public void setZeroes(int[][] matrix) {\n        ArrayList<Integer> row = new ArrayList<>();\n        ArrayList<Integer> col = new ArrayList<>();\n        for(int i=0; i<matrix.length; i++){\n            for(int j=0; j<matrix[0].length; j++){\n                if(matrix[i][j] = 0){\n                    row.add(i);\n                    col.add(j);\n                }\n            }\n        }\n\n         for(int i=0; i<matrix.length; i++){\n            if(row.contains(i)){\n                for(int j=0; j<matrix[0].length; j++){\n                    matrix[i][j] = 0;\n                }\n            }\n            else{\n                for(int j=0; j<matrix[0].length; j++){\n                    if(col.contains(j)){\n                        matrix[i][j] = 0;\n                    }\n                }\n            }\n        }\n    }\n} \n  \n",
        "explanations": " \nThe \"==\" operator replaced with \"=\" in the if condition, which is assignment operation. \n"
    },
    {
        "slug": "find-nearest-point-that-has-the-same-x-or-y-coordinate",
        "description": "You are given two integers, x and y, which represent your current location on a Cartesian grid: (x, y). You are also given an array points where each points[i] = [ai, bi] represents that a point exists at (ai, bi). A point is valid if it shares the same x-coordinate or the same y-coordinate as your location.\nReturn the index (0-indexed) of the valid point with the smallest Manhattan distance from your current location. If there are multiple, return the valid point with the smallest index. If there are no valid points, return -1.\nThe Manhattan distance between two points (x1, y1) and (x2, y2) is abs(x1 - x2) + abs(y1 - y2).",
        "examples": [
            "Input: x = 3, y = 4, points = [[1,2],[3,1],[2,4],[2,3],[4,4]]\nOutput: 2\nExplanation: Of all the points, only [3,1], [2,4] and [4,4] are valid. Of the valid points, [2,4] and [4,4] have the smallest Manhattan distance from your current location, with a distance of 1. [2,4] has the smallest index, so return 2.",
            "Input: x = 3, y = 4, points = [[3,4]]\nOutput: 0\nExplanation: The answer is allowed to be on the same location as your current location.",
            "Input: x = 3, y = 4, points = [[2,3]]\nOutput: -1\nExplanation: There are no valid points."
        ],
        "constraints": "1 <= points.length <= 104\npoints[i].length == 2\n1 <= x, y, ai, bi <= 104",
        "release_time": 1678131044,
        "oracle_code": "class Solution {\n    public int nearestValidPoint(int x, int y, int[][] points) {\n        \n        int sIndex = 100000;\n        int sDistance = 100000;\n\n        for (int i = 0; i < points.length; i++) {\n            \n            // Check if is a valid point\n            if (points[i][0] == x || points[i][1] == y) {\n\n                // Check if it is better than the previous best\n                int distance = Math.abs(x - points[i][0]) + Math.abs(y - points[i][1]);\n                if (sDistance > distance) {\n                    sDistance = distance;\n                    sIndex = i;\n                }\n            }\n        }\n\n        // Check if we have a valid point to return\n        if (sIndex == 100000)\n            return -1;\n        return sIndex;\n    }\n}",
        "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe solution involves a simple **iteration of the array**. \\n\\n*At each iteration* we have to check if **the point is valid**, in this case we have to check if the distance of this point is shorter than the distance that we found in previous iterations.\\n\\n**Note:** The initialization of sIndex and sDistance is higher than the *maximum value allowed by the input conditions*.\\n \\n# Complexity\\n- **Time complexity:** $O(n)$\\n- **Speed Beats:** 100%\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- **Space complexity:** $O(1)$\\n- **Memory Beats:** 78.3%\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int nearestValidPoint(int x, int y, int[][] points) {\\n        \\n        int sIndex = 100000;\\n        int sDistance = 100000;\\n\\n        for (int i = 0; i < points.length; i++) {\\n            \\n            // Check if is a valid point\\n            if (points[i][0] == x || points[i][1] == y) {\\n\\n                // Check if it is better than the previous best\\n                int distance = Math.abs(x - points[i][0]) + Math.abs(y - points[i][1]);\\n                if (sDistance > distance) {\\n                    sDistance = distance;\\n                    sIndex = i;\\n                }\\n            }\\n        }\\n\\n        // Check if we have a valid point to return\\n        if (sIndex == 100000)\\n            return -1;\\n        return sIndex;\\n    }\\n}\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\n    public int nearestValidPoint(int x, int y, int[][] points) {\n        \n        int sIndex = 100000;\n        int sDistance = 100000;\n\n        for (int i = 0; i < points.length; i++) {\n            \n            // Check if is a valid point\n            if (points[i][0] = x || points[i][1] = y) {\n\n                // Check if it is better than the previous best\n                int distance = Math.abs(x - points[i][0]) + Math.abs(y - points[i][1]);\n                if (sDistance > distance) {\n                    sDistance = distance;\n                    sIndex = i;\n                }\n            }\n        }\n\n        // Check if we have a valid point to return\n        if (sIndex = 100000)\n            return -1;\n        return sIndex;\n    }\n}\n",
        "explanations": "\nThe if conditions in the code are using single equals = (assignment operator) instead of double equals == (comparison operator) leading to incorrect logic.\n"
    },
    {
        "slug": "domino-and-tromino-tiling",
        "description": "You have two types of tiles: a 2 x 1 domino shape and a tromino shape. You may rotate these shapes.\n\nGiven an integer n, return the number of ways to tile an 2 x n board. Since the answer may be very large, return it modulo 109 + 7.\nIn a tiling, every square must be covered by a tile. Two tilings are different if and only if there are two 4-directionally adjacent cells on the board such that exactly one of the tilings has both squares occupied by a tile.",
        "examples": [
            "Input: n = 3\nOutput: 5\nExplanation: The five different ways are show above.",
            "Input: n = 1\nOutput: 1"
        ],
        "constraints": "1 <= n <= 1000",
        "release_time": 1671862293,
        "oracle_code": "class Solution {\n    private long[] dp;\n    int MOD = (int)Math.pow(10 , 9) + 7;\n    public long solve(int n){\n        if(n==0) return 1;\n        if(n<3) return n;\n\n        if(dp[n]!=-1) return dp[n];\n\n        return dp[n] = 2*solve(n-1)%MOD+solve(n-3)%MOD;\n    }\n    public int numTilings(int n) {\n        this.dp = new long[n+1];\n        Arrays.fill(dp , -1);\n\n        return (int)solve(n)%MOD;\n    }\n}",
        "content": "# Intuition\\n- The basic approach to solve this problem was by using brute force recursion.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- Then after realising the over-lapping sub problems in it the whole problem was solved using the memoization technique of Dynamic Programming\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(N*N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N)$$ + recursive stack space\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private long[] dp;\\n    int MOD = (int)Math.pow(10 , 9) + 7;\\n    public long solve(int n){\\n        if(n==0) return 1;\\n        if(n<3) return n;\\n\\n        if(dp[n]!=-1) return dp[n];\\n\\n        return dp[n] = 2*solve(n-1)%MOD+solve(n-3)%MOD;\\n    }\\n    public int numTilings(int n) {\\n        this.dp = new long[n+1];\\n        Arrays.fill(dp , -1);\\n\\n        return (int)solve(n)%MOD;\\n    }\\n}\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\n    private long[] dp;\n    int MOD = (int)Math.pow(10 , 9) + 7;\n    public long solve(int n){\n        if(n==0) return 1;\n        if(n<3) return n;\n\n        if(dp[n] = -1) return dp[n];\n\n        return dp[n] == 2*solve(n-1)%MOD+solve(n-3)%MOD;\n    }\n    public int numTilings(int n) {\n        this.dp = new long[n+1];\n        Arrays.fill(dp , -1);\n\n        return (int)solve(n)%MOD;\n    }\n}\n",
        "explanations": "\nIn the solve method, the assignment operator should be == in the if condition and the equality operator should be = in return statement.\n"
    },
    {
        "slug": "longest-valid-parentheses",
        "description": "Given a string containing just the characters '(' and ')', return the length of the longest valid (well-formed) parentheses substring.",
        "examples": [
            "Input: s = \"(()\"\nOutput: 2\nExplanation: The longest valid parentheses substring is \"()\".",
            "Input: s = \")()())\"\nOutput: 4\nExplanation: The longest valid parentheses substring is \"()()\".",
            "Input: s = \"\"\nOutput: 0"
        ],
        "constraints": "0 <= s.length <= 3 * 104\ns[i] is '(', or ')'.",
        "release_time": 1688495250,
        "oracle_code": "class Solution {\n    public int longestValidParentheses(String s) {\n        Stack<Integer> st = new Stack<>();\n        st.push(-1);\n        int n = 0;\n        for(int i = 0; i < s.length(); i++)\n        {\n            if(s.charAt(i) == '(')\n                st.push(i);\n            else if(s.charAt(i) == ')')\n            {\n                st.pop();\n                if(st.empty())\n                    st.push(i);\n                else\n                    n = Math.max(n, i - st.peek());\n            }\n        }\n        return n;\n    }\n}",
        "content": "\\n# Code\\n```\\nclass Solution {\\n    public int longestValidParentheses(String s) {\\n        Stack<Integer> st = new Stack<>();\\n        st.push(-1);\\n        int n = 0;\\n        for(int i = 0; i < s.length(); i++)\\n        {\\n            if(s.charAt(i) == \\'(\\')\\n                st.push(i);\\n            else if(s.charAt(i) == \\')\\')\\n            {\\n                st.pop();\\n                if(st.empty())\\n                    st.push(i);\\n                else\\n                    n = Math.max(n, i - st.peek());\\n            }\\n        }\\n        return n;\\n    }\\n}\\n```",
        "level": "hard",
        "buggy_code": "\nclass Solution {\n    public int longestValidParentheses(String s) {\n        Stack<Integer> st = new Stack<>();\n        st.push(-1);\n        int n = 0;\n        for(int i = 0; i < s.length(); i++)\n        {\n            if(s.charAt(i) = '(')\n                st.push(i);\n            else if(s.charAt(i) == ')')\n            {\n                st.pop();\n                if(st.empty())\n                    st.push(i);\n                else\n                    n = Math.max(n, i - st.peek());\n            }\n        }\n        return n;\n    }\n}\n",
        "explanations": "\nThe bug is in the if statement where = is used instead of == for comparison.\n"
    },
    {
        "slug": "loud-and-rich",
        "description": "There is a group of n people labeled from 0 to n - 1 where each person has a different amount of money and a different level of quietness.\nYou are given an array richer where richer[i] = [ai, bi] indicates that ai has more money than bi and an integer array quiet where quiet[i] is the quietness of the ith person. All the given data in richer are logically correct (i.e., the data will not lead you to a situation where x is richer than y and y is richer than x at the same time).\nReturn an integer array answer where answer[x] = y if y is the least quiet person (that is, the person y with the smallest value of quiet[y]) among all people who definitely have equal to or more money than the person x.",
        "examples": [
            "Input: richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]], quiet = [3,2,5,4,6,1,7,0]\nOutput: [5,5,2,5,4,5,6,7]\nExplanation: \nanswer[0] = 5.\nPerson 5 has more money than 3, which has more money than 1, which has more money than 0.\nThe only person who is quieter (has lower quiet[x]) is person 7, but it is not clear if they have more money than person 0.\nanswer[7] = 7.\nAmong all people that definitely have equal to or more money than person 7 (which could be persons 3, 4, 5, 6, or 7), the person who is the quietest (has lower quiet[x]) is person 7.\nThe other answers can be filled out with similar reasoning.",
            "Input: richer = [], quiet = [0]\nOutput: [0]"
        ],
        "constraints": "n == quiet.length\n1 <= n <= 500\n0 <= quiet[i] < n\nAll the values of quiet are unique.\n0 <= richer.length <= n * (n - 1) / 2\n0 <= ai, bi < n\nai != bi\nAll the pairs of richer are unique.\nThe observations in richer are all logically consistent.",
        "release_time": 1670637012,
        "oracle_code": "class Solution {\n    int ans[];\n    Map<Integer,List<Integer>> map=new HashMap<>();\n    int temp[]=new int[0];\n    int curr_node=0;\n    List<Integer> vis=new ArrayList<Integer>();\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\n        \n        ans=new int[quiet.length];\n        for(int i=0;i<=richer.length;i++){\n            \n            if(!map.containsKey(i)){\n                map.put(i,new ArrayList());\n            }\n            if(i<richer.length && !map.containsKey(richer[i][0])){\n                map.put(richer[i][0],new ArrayList());\n                map.get(richer[i][0]).add(richer[i][1]);\n            }\n            else if(i<richer.length){\n                map.get(richer[i][0]).add(richer[i][1]);\n            }\n        }\n        \n        Comparator<pair> comp=new Comparator<pair>(){\n            public int compare(pair p1,pair p2){\n                if(p1.cost>p2.cost){\n                    return 1;\n                }\n                else{\n                    return -1;\n                }\n\n            }\n        };\n        PriorityQueue<pair> pq=new PriorityQueue<>(comp);\n        for(int i=0;i<quiet.length;i++){\n            ans[i]=-1;\n            pq.add(new pair(i,quiet[i]));\n        }\n        \n        while(!pq.isEmpty()){\n            pair top=pq.poll();\n            //System.out.println(top.node+\" \"+top.cost);\n            curr_node=top.node;\n            if(!vis.contains(top.node)){\n            dfs(top.node);\n            }\n        }\n        return ans;\n       \n    }\n    public void dfs(int node){\n        //System.out.println(node);\n        if(ans[node]==-1){\n            ans[node]=curr_node;\n        }\n        if(!vis.contains(node) && map.containsKey(node)){\n            vis.add(node);\n             \n            for(int i : map.get(node)){\n            dfs(i);\n        \n        }\n        }\n            \n    }\n}\n\nclass pair{\n    int node,cost;\n    pair(int node,int cost){\n        this.node=node;\n        this.cost=cost;\n    }\n}",
        "content": "\\n# Code\\n```\\nclass Solution {\\n    int ans[];\\n    Map<Integer,List<Integer>> map=new HashMap<>();\\n    int temp[]=new int[0];\\n    int curr_node=0;\\n    List<Integer> vis=new ArrayList<Integer>();\\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\\n        \\n        ans=new int[quiet.length];\\n        for(int i=0;i<=richer.length;i++){\\n            \\n            if(!map.containsKey(i)){\\n                map.put(i,new ArrayList());\\n            }\\n            if(i<richer.length && !map.containsKey(richer[i][0])){\\n                map.put(richer[i][0],new ArrayList());\\n                map.get(richer[i][0]).add(richer[i][1]);\\n            }\\n            else if(i<richer.length){\\n                map.get(richer[i][0]).add(richer[i][1]);\\n            }\\n        }\\n        \\n        Comparator<pair> comp=new Comparator<pair>(){\\n            public int compare(pair p1,pair p2){\\n                if(p1.cost>p2.cost){\\n                    return 1;\\n                }\\n                else{\\n                    return -1;\\n                }\\n\\n            }\\n        };\\n        PriorityQueue<pair> pq=new PriorityQueue<>(comp);\\n        for(int i=0;i<quiet.length;i++){\\n            ans[i]=-1;\\n            pq.add(new pair(i,quiet[i]));\\n        }\\n        \\n        while(!pq.isEmpty()){\\n            pair top=pq.poll();\\n            //System.out.println(top.node+\" \"+top.cost);\\n            curr_node=top.node;\\n            if(!vis.contains(top.node)){\\n            dfs(top.node);\\n            }\\n        }\\n        return ans;\\n       \\n    }\\n    public void dfs(int node){\\n        //System.out.println(node);\\n        if(ans[node]==-1){\\n            ans[node]=curr_node;\\n        }\\n        if(!vis.contains(node) && map.containsKey(node)){\\n            vis.add(node);\\n             \\n            for(int i : map.get(node)){\\n            dfs(i);\\n        \\n        }\\n        }\\n            \\n    }\\n}\\n\\nclass pair{\\n    int node,cost;\\n    pair(int node,int cost){\\n        this.node=node;\\n        this.cost=cost;\\n    }\\n}\\n\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\n    int ans[];\n    Map<Integer,List<Integer>> map=new HashMap<>();\n    int temp[]=new int[0];\n    int curr_node=0;\n    List<Integer> vis=new ArrayList<Integer>();\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\n        \n        ans=new int[quiet.length];\n        for(int i=0;i<=richer.length;i++){\n            \n            if(!map.containsKey(i)){\n                map.put(i,new ArrayList());\n            }\n            if(i<richer.length && !map.containsKey(richer[i][0])){\n                map.put(richer[i][0],new ArrayList());\n                map.get(richer[i][0]).add(richer[i][1]);\n            }\n            else if(i<richer.length){\n                map.get(richer[i][0]).add(richer[i][1]);\n            }\n        }\n        \n        Comparator<pair> comp=new Comparator<pair>(){\n            public int compare(pair p1,pair p2){\n                if(p1.cost == p2.cost){   \n                    return 1;\n                }\n                else{\n                    return -1;\n                }\n\n            }\n        };\n        PriorityQueue<pair> pq=new PriorityQueue<>(comp);\n        for(int i=0;i<quiet.length;i++){\n            ans[i]=-1;\n            pq.add(new pair(i,quiet[i]));\n        }\n        \n        while(!pq.isEmpty()){\n            pair top=pq.poll();\n            curr_node=top.node;\n            if(!vis.contains(top.node)){\n            dfs(top.node);\n            }\n        }\n        return ans;\n       \n    }\n    public void dfs(int node){\n        if(ans[node]==-1){\n            ans[node]=curr_node;\n        }\n        if(!vis.contains(node) && map.containsKey(node)){\n            vis.add(node);\n             \n            for(int i : map.get(node)){\n            dfs(i);\n        \n        }\n        }\n            \n    }\n}\n\nclass pair{\n    int node,cost;\n    pair(int node,int cost){\n        this.node=node;\n        this.cost=cost;\n    }\n}\n",
        "explanations": "\nThe bug is placed in the comparator for priority queue. Using == instead of > gives wrong ordering.\n"
    },
    {
        "slug": "largest-3-same-digit-number-in-string",
        "description": "You are given a string num representing a large integer. An integer is good if it meets the following conditions:\n\nIt is a substring of num with length 3.\nIt consists of only one unique digit.\n\nReturn the maximum good integer as a string or an empty string \"\" if no such integer exists.\nNote:\n\nA substring is a contiguous sequence of characters within a string.\nThere may be leading zeroes in num or a good integer.",
        "examples": [
            "Input: num = \"6777133339\"\nOutput: \"777\"\nExplanation: There are two distinct good integers: \"777\" and \"333\".\n\"777\" is the largest, so we return \"777\".",
            "Input: num = \"2300019\"\nOutput: \"000\"\nExplanation: \"000\" is the only good integer.",
            "Input: num = \"42352338\"\nOutput: \"\"\nExplanation: No substring of length 3 consists of only one unique digit. Therefore, there are no good integers."
        ],
        "constraints": "3 <= num.length <= 1000\nnum only consists of digits.",
        "release_time": 1663654171,
        "oracle_code": "class Solution {\n    public String largestGoodInteger(String num) {\n        int n=-1;\n        StringBuilder sb = new StringBuilder();\n        for(int i=0;i<num.length()-2;i++){\n            if(num.charAt(i)==num.charAt(i+1) && num.charAt(i)==num.charAt(i+2)){\n                sb.append(num.charAt(i));\n                sb.append(num.charAt(i));\n                sb.append(num.charAt(i));\n                if(Integer.parseInt(sb.toString())>n)\n                    n=Integer.parseInt(sb.toString());\n                sb.setLength(0);\n            }\n        }\n        if(n==-1)\n            return \"\";\n        String s = Integer.toString(n);\n        if(s.equals(\"0\"))\n            return \"000\";\n        return s;\n    }\n}",
        "content": "```\\nclass Solution {\\n    public String largestGoodInteger(String num) {\\n        int n=-1;\\n        StringBuilder sb = new StringBuilder();\\n        for(int i=0;i<num.length()-2;i++){\\n            if(num.charAt(i)==num.charAt(i+1) && num.charAt(i)==num.charAt(i+2)){\\n                sb.append(num.charAt(i));\\n                sb.append(num.charAt(i));\\n                sb.append(num.charAt(i));\\n                if(Integer.parseInt(sb.toString())>n)\\n                    n=Integer.parseInt(sb.toString());\\n                sb.setLength(0);\\n            }\\n        }\\n        if(n==-1)\\n            return \"\";\\n        String s = Integer.toString(n);\\n        if(s.equals(\"0\"))\\n            return \"000\";\\n        return s;\\n    }\\n}\\n```\\nKindly upvote if you like the code.",
        "level": "easy",
        "buggy_code": "\nclass Solution {\n    public String largestGoodInteger(String num) {\n        int n=-1;\n        StringBuilder sb = new StringBuilder();\n        for(int i=0;i<num.length()-2;i++){\n            if(num.charAt(i)==num.charAt(i+1) && num.charAt(i)==num.charAt(i+2)){\n                sb.append(num.charAt(i));\n                sb.append(num.charAt(i));\n                sb.append(num.charAt(i));\n                if(Integer.parseInt(sb.toString())=n)\n                    n=Integer.parseInt(sb.toString());\n                sb.setLength(0);\n            }\n        }\n        if(n==-1)\n            return \"\";\n        String s = Integer.toString(n);\n        if(s.equals(\"0\"))\n            return \"000\";\n        return s;\n    }\n}\n",
        "explanations": "\nI have added a bug which is a very common mistake in java. The assignment operator \"=\" is used in an if block instead of the comparison operator \"==\".\n"
    },
    {
        "slug": "reverse-words-in-a-string",
        "description": "Given an input string s, reverse the order of the words.\nA word is defined as a sequence of non-space characters. The words in s will be separated by at least one space.\nReturn a string of the words in reverse order concatenated by a single space.\nNote that s may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words. Do not include any extra spaces.",
        "examples": [
            "Input: s = \"the sky is blue\"\nOutput: \"blue is sky the\"",
            "Input: s = \"  hello world  \"\nOutput: \"world hello\"\nExplanation: Your reversed string should not contain leading or trailing spaces.",
            "Input: s = \"a good   example\"\nOutput: \"example good a\"\nExplanation: You need to reduce multiple spaces between two words to a single space in the reversed string."
        ],
        "constraints": "1 <= s.length <= 104\ns contains English letters (upper-case and lower-case), digits, and spaces ' '.\nThere is at least one word in s.\n\n\u00a0\nFollow-up:\u00a0If the string data type is mutable in your language, can\u00a0you solve it\u00a0in-place\u00a0with\u00a0O(1)\u00a0extra space?",
        "release_time": 1688410064,
        "oracle_code": "class Solution {\n    public String reverseWords(String s) {\n     s = s.trim();\n     int left = 0, right = s.length() - 1;\n     String ans = \"\";\n     String temp = \"\";\n     //Iterate the string and keep on adding to form a word\n\t//If empty space is encountered then add the current word to the result\n     while(left <= right) {\n         char ch = s.charAt(left);\n         if(ch != ' ')\n         temp += ch;\n         else if(ch == ' ') {\n             if(!ans.equals(\"\"))\n             ans = temp.trim() + \" \" + ans.trim();\n             else \n             ans = temp.trim();\n             temp = \"\";\n         }\n         left ++;\n     }\n//If not empty string then add to the result(Last word is added)\n     if(!temp.equals(\"\")) {\n         if(!ans.equals(\"\"))\n          ans = temp.trim() + \" \" + ans.trim();\n         else \n          ans = temp.trim();\n     }\n     return ans;\n    }\n}",
        "content": "\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String reverseWords(String s) {\\n     s = s.trim();\\n     int left = 0, right = s.length() - 1;\\n     String ans = \"\";\\n     String temp = \"\";\\n     //Iterate the string and keep on adding to form a word\\n\\t//If empty space is encountered then add the current word to the result\\n     while(left <= right) {\\n         char ch = s.charAt(left);\\n         if(ch != \\' \\')\\n         temp += ch;\\n         else if(ch == \\' \\') {\\n             if(!ans.equals(\"\"))\\n             ans = temp.trim() + \" \" + ans.trim();\\n             else \\n             ans = temp.trim();\\n             temp = \"\";\\n         }\\n         left ++;\\n     }\\n//If not empty string then add to the result(Last word is added)\\n     if(!temp.equals(\"\")) {\\n         if(!ans.equals(\"\"))\\n          ans = temp.trim() + \" \" + ans.trim();\\n         else \\n          ans = temp.trim();\\n     }\\n     return ans;\\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
        "level": "medium",
        "buggy_code": "\nclass Solution {\n    public String reverseWords(String s) {\n     s = s.trim();\n     int left = 0, right = s.length() - 1;\n     String ans = \"\";\n     String temp = \"\";\n     while(left <= right) {\n         char ch = s.charAt(left);\n         if(ch != ' ')\n         temp += ch;\n         else if(ch = ' ') {\n             if(!ans.equals(\"\"))\n             ans = temp.trim() + \" \" + ans.trim();\n             else \n             ans = temp.trim();\n             temp = \"\";\n         }\n         left ++;\n     }\n     if(!temp.equals(\"\")) {\n         if(!ans.equals(\"\"))\n          ans = temp.trim() + \" \" + ans.trim();\n         else \n          ans = temp.trim();\n     }\n     return ans;\n    }\n}\n",
        "explanations": "\nIn the second if condition, = is used instead of == causing an assignment instead of comparison.\n"
    },
    {
        "slug": "n-ary-tree-preorder-traversal",
        "description": "Given the root of an n-ary tree, return the preorder traversal of its nodes' values.\nNary-Tree input serialization is represented in their level order traversal. Each group of children is separated by the null value (See examples)",
        "examples": [
            "Input: root = [1,null,3,2,4,null,5,6]\nOutput: [1,3,5,6,2,4]",
            "Input: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]\nOutput: [1,2,3,6,7,11,14,4,8,12,5,9,13,10]"
        ],
        "constraints": "The number of nodes in the tree is in the range [0, 104].\n0 <= Node.val <= 104\nThe height of the n-ary tree is less than or equal to 1000.",
        "release_time": 1676960316,
        "oracle_code": "class Solution {\n    List<Integer> arr = new ArrayList<>();\n    public List<Integer> preorder(Node root) {\n        if (root==null) return arr;\n        arr.add(root.val);\n        for (Node i : root.children) {\n            preorder(i);\n        }\n        return arr;\n    }\n}",
        "content": "# Code\\n```\\nclass Solution {\\n    List<Integer> arr = new ArrayList<>();\\n    public List<Integer> preorder(Node root) {\\n        if (root==null) return arr;\\n        arr.add(root.val);\\n        for (Node i : root.children) {\\n            preorder(i);\\n        }\\n        return arr;\\n    }\\n}\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\n    List<Integer> arr = new ArrayList<>();\n    public List<Integer> preorder(Node root) {\n        if (root=null) return arr; \n        arr.add(root.val);\n        for (Node i : root.children) {\n            preorder(i);\n        }\n        return arr;\n    }\n}\n",
        "explanations": "\nThe bug is in the comparison operation, where it must use \"==\" but uses \"=\".\n"
    },
    {
        "slug": "combination-sum",
        "description": "Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order.\nThe same number may be chosen from candidates an unlimited number of times. Two combinations are unique if the frequency of at least one of the chosen numbers is different.\nThe test cases are generated such that the number of unique combinations that sum up to target is less than 150 combinations for the given input.",
        "examples": [
            "Input: candidates = [2,3,6,7], target = 7\nOutput: [[2,2,3],[7]]\nExplanation:\n2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.\n7 is a candidate, and 7 = 7.\nThese are the only two combinations.",
            "Input: candidates = [2,3,5], target = 8\nOutput: [[2,2,2,2],[2,3,3],[3,5]]",
            "Input: candidates = [2], target = 1\nOutput: []"
        ],
        "constraints": "1 <= candidates.length <= 30\n2 <= candidates[i] <= 40\nAll elements of candidates are distinct.\n1 <= target <= 40",
        "release_time": 1692131867,
        "oracle_code": "class Solution {\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\n        List<List<Integer>> result = new ArrayList<>();\n        List<Integer> currentSubset = new ArrayList<>();\n\n        findCombination(0, target, candidates, currentSubset, result);\n        return result;\n    }\n\n    public static void findCombination(int index, int target, int[] candidates, List<Integer> currentSubset, List<List<Integer>> result) {\n        // checks if we have explored all the elements of array\n        if(index == candidates.length) {\n            if(target == 0) {\n                result.add(new ArrayList<>(currentSubset));\n            }\n            return;\n        }\n\n        if(candidates[index] <= target) {\n            currentSubset.add(candidates[index]);\n            \n            // After adding the element of curr index, iterate the left path until the base condition is met\n            findCombination(index, target - candidates[index], candidates, currentSubset, result);\n        \n            // this is required because when the above recursion call \n            // is executed then the Data structure still has curr index element so we need to remove it\n            currentSubset.remove(currentSubset.size() - 1);\n        }\n\n        // check for the next element of array\n        findCombination(index + 1, target, candidates, currentSubset, result);\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe need to explore all the options for each element and find a combination such that sum of the combination is equal to target. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nat each index we have two options\\n1) pick the element (left path)\\n2) dont pick the element (right path)\\n\\n- now when we pick the element (the left path), then we add that element in our data structure and reduce the target value.\\n    \\nLets consider the following\\n \\n    structure of the function F() - \\n\\n            F(index, target - arr[index], empty Data Structure)\\n\\n    arr -   [2,   3,   6,   7]  \\ttarget = 7\\n            (0), (1), (2), (3)\\n\\n                                F(0, 7, [])\\n                                   /   \\\\\\n                                  /     \\\\\\n                                 /       \\\\\\n              (1-left)->  F(0, 5, [2])    F(1, 7, [])  <-(1-right)\\n                             /   \\\\      \\t     \\n                            /     \\\\ \\t  \\n                           /       \\\\        \\n    (2-left)->  F(0, 3, [2,2])    F(1, 5, [2])   <-(2-right)\\n\\nat Step`(1-left)`we took the element at index 0, added it to the data structure and then reduced the value of target to`7 - 2 = 5`\\n\\nLet\\'s say that we explored all the paths of`(2-left)`so now when the path backtracks to`(1-left)`we remove the last added value in the data structure i.e.`2`and then again try to explore the right path i.e.`(2-right)`.\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        List<Integer> currentSubset = new ArrayList<>();\\n\\n        findCombination(0, target, candidates, currentSubset, result);\\n        return result;\\n    }\\n\\n    public static void findCombination(int index, int target, int[] candidates, List<Integer> currentSubset, List<List<Integer>> result) {\\n        // checks if we have explored all the elements of array\\n        if(index == candidates.length) {\\n            if(target == 0) {\\n                result.add(new ArrayList<>(currentSubset));\\n            }\\n            return;\\n        }\\n\\n        if(candidates[index] <= target) {\\n            currentSubset.add(candidates[index]);\\n            \\n            // After adding the element of curr index, iterate the left path until the base condition is met\\n            findCombination(index, target - candidates[index], candidates, currentSubset, result);\\n        \\n            // this is required because when the above recursion call \\n            // is executed then the Data structure still has curr index element so we need to remove it\\n            currentSubset.remove(currentSubset.size() - 1);\\n        }\\n\\n        // check for the next element of array\\n        findCombination(index + 1, target, candidates, currentSubset, result);\\n    }\\n}\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\n        List<List<Integer>> result = new ArrayList<>();\n        List<Integer> currentSubset = new ArrayList<>();\n\n        findCombination(0, target, candidates, currentSubset, result);\n        return result;\n    }\n\n    public static void findCombination(int index, int target, int[] candidates, List<Integer> currentSubset, List<List<Integer>> result) {\n        // checks if we have explored all the elements of array\n        if(index == candidates.length) {\n            if(target = 0) {\n                result.add(new ArrayList<>(currentSubset));\n            }\n            return;\n        }\n\n        if(candidates[index] <= target) {\n            currentSubset.add(candidates[index]);\n            \n            // After adding the element of curr index, iterate the left path until the base condition is met\n            findCombination(index, target - candidates[index], candidates, currentSubset, result);\n        \n            // this is required because when the above recursion call \n            // is executed then the Data structure still has curr index element so we need to remove it\n            currentSubset.remove(currentSubset.size() - 1);\n        }\n\n        // check for the next element of array\n        findCombination(index + 1, target, candidates, currentSubset, result);\n    }\n}\n",
        "explanations": "\nConfused assignment operator (=) with equality operator (==) in if condition, causing a logic error.\n"
    },
    {
        "slug": "account-balance-after-rounded-purchase",
        "description": "Initially, you have a bank account balance of 100 dollars.\nYou are given an integer purchaseAmount representing the amount you will spend on a purchase in dollars.\nAt the store where you will make the purchase, the purchase amount is rounded to the nearest multiple of 10. In other words, you pay a non-negative amount, roundedAmount, such that roundedAmount is a multiple of 10 and abs(roundedAmount - purchaseAmount) is minimized.\nIf there is more than one nearest multiple of 10, the largest multiple is chosen.\nReturn an integer denoting your account balance after making a purchase worth purchaseAmount dollars from the store.\nNote: 0 is considered to be a multiple of 10 in this problem.",
        "examples": [
            "Input: purchaseAmount = 9\nOutput: 90\nExplanation: In this example, the nearest multiple of 10 to 9 is 10. Hence, your account balance becomes 100 - 10 = 90.",
            "Input: purchaseAmount = 15\nOutput: 80\nExplanation: In this example, there are two nearest multiples of 10 to 15: 10 and 20. So, the larger multiple, 20, is chosen.\nHence, your account balance becomes 100 - 20 = 80."
        ],
        "constraints": "0 <= purchaseAmount <= 100",
        "release_time": 1691437848,
        "oracle_code": "class Solution {\n    public int accountBalanceAfterPurchase(int amt) {\n        if(amt%10 == 0)\n        {\n            return 100-amt;\n        }\n        int ans=100-amt;\n        return amt%10 >= 5 ? (ans/10)*10 : ((ans/10)+1)*10;\n    }\n}",
        "content": "# Complexity\\n- Time complexity: $$O(1)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int accountBalanceAfterPurchase(int amt) {\\n        if(amt%10 == 0)\\n        {\\n            return 100-amt;\\n        }\\n        int ans=100-amt;\\n        return amt%10 >= 5 ? (ans/10)*10 : ((ans/10)+1)*10;\\n    }\\n}\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\n    public int accountBalanceAfterPurchase(int amt) {\n        if(amt%10 = 0) \n        {\n            return 100-amt;\n        }\n        int ans=100-amt;\n        return amt%10 >= 5 ? (ans/10)*10 : ((ans/10)+1)*10;\n    }\n}\n",
        "explanations": "\nUsed assignment (=) operator in if statement condition instead of equality (==) operator.\n"
    },
    {
        "slug": "minimum-distance-to-the-target-element",
        "description": "Given an integer array nums (0-indexed) and two integers target and start, find an index i such that nums[i] == target and abs(i - start) is minimized. Note that\u00a0abs(x)\u00a0is the absolute value of x.\nReturn abs(i - start).\nIt is guaranteed that target exists in nums.",
        "examples": [
            "Input: nums = [1,2,3,4,5], target = 5, start = 3\nOutput: 1\nExplanation: nums[4] = 5 is the only value equal to target, so the answer is abs(4 - 3) = 1.",
            "Input: nums = [1], target = 1, start = 0\nOutput: 0\nExplanation: nums[0] = 1 is the only value equal to target, so the answer is abs(0 - 0) = 0.",
            "Input: nums = [1,1,1,1,1,1,1,1,1,1], target = 1, start = 0\nOutput: 0\nExplanation: Every value of nums is 1, but nums[0] minimizes abs(i - start), which is abs(0 - 0) = 0."
        ],
        "constraints": "1 <= nums.length <= 1000\n1 <= nums[i] <= 104\n0 <= start < nums.length\ntarget is in nums.",
        "release_time": 1687435674,
        "oracle_code": "class Solution {\n    public int getMinDistance(int[] nums, int target, int start) {\n     int n = nums.length;\n     int min = Integer.MAX_VALUE;\n     for(int i=0;i<n;i++){\n         if(nums[i]==target){\n          if(Math.abs(i-start)<min){\n              min = Math.abs(i-start);\n          }   \n         }\n     }\n     return min;   \n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n     int n = nums.length;\\n     int min = Integer.MAX_VALUE;\\n     for(int i=0;i<n;i++){\\n         if(nums[i]==target){\\n          if(Math.abs(i-start)<min){\\n              min = Math.abs(i-start);\\n          }   \\n         }\\n     }\\n     return min;   \\n    }\\n}\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\n    public int getMinDistance(int[] nums, int target, int start) {\n     int n = nums.length;\n     int min = Integer.MAX_VALUE;\n     for(int i=0;i<n;i++){\n         if(nums[i]=target){\n          if(Math.abs(i-start)<min){\n              min = Math.abs(i-start);\n          }   \n         }\n     }\n     return min;   \n    }\n}\n",
        "explanations": "\nThe bug is in the if statement. Instead of using '==' for comparison, '=' is used, which is assignment.\n"
    },
    {
        "slug": "sum-of-left-leaves",
        "description": "Given the root of a binary tree, return the sum of all left leaves.\nA leaf is a node with no children. A left leaf is a leaf that is the left child of another node.",
        "examples": [
            "Input: root = [3,9,20,null,null,15,7]\nOutput: 24\nExplanation: There are two left leaves in the binary tree, with values 9 and 15 respectively.",
            "Input: root = [1]\nOutput: 0"
        ],
        "constraints": "The number of nodes in the tree is in the range [1, 1000].\n-1000 <= Node.val <= 1000",
        "release_time": 1689484464,
        "oracle_code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n\n    static int result;\n\n    public int sumOfLeftLeaves(TreeNode root) {\n        result=0;\n\n        task(root.left, true);\n\n        task(root.right, false);\n\n        return result;\n    }\n\n    static void task(TreeNode root, boolean flag){\n        if(root == null) return;\n\n        if(flag && root.left==null && root.right==null) result+=root.val;\n\n        task(root.left, true);\n        task(root.right, false);\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n\\n    static int result;\\n\\n    public int sumOfLeftLeaves(TreeNode root) {\\n        result=0;\\n\\n        task(root.left, true);\\n\\n        task(root.right, false);\\n\\n        return result;\\n    }\\n\\n    static void task(TreeNode root, boolean flag){\\n        if(root == null) return;\\n\\n        if(flag && root.left==null && root.right==null) result+=root.val;\\n\\n        task(root.left, true);\\n        task(root.right, false);\\n    }\\n}\\n```",
        "level": "easy",
        "buggy_code": "\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n\n    static int result;\n\n    public int sumOfLeftLeaves(TreeNode root) {\n        result=0;\n\n        task(root.left, true);\n\n        task(root.right, false);\n\n        return result;\n    }\n\n    static void task(TreeNode root, boolean flag){\n        if(root == null) return;\n\n        if(flag = root.left==null && root.right==null) result+=root.val;\n\n        task(root.left, true);\n        task(root.right, false);\n    }\n}\n",
        "explanations": "\nThe boolean flag is erroneously assigned a value in the if condition check.\n"
    },
    {
        "slug": "minimum-falling-path-sum-ii",
        "description": "Given an n x n integer matrix grid, return the minimum sum of a falling path with non-zero shifts.\nA falling path with non-zero shifts is a choice of exactly one element from each row of grid such that no two elements chosen in adjacent rows are in the same column.",
        "examples": [
            "Input: grid = [[1,2,3],[4,5,6],[7,8,9]]\nOutput: 13\nExplanation: \nThe possible falling paths are:\n[1,5,9], [1,5,7], [1,6,7], [1,6,8],\n[2,4,8], [2,4,9], [2,6,7], [2,6,8],\n[3,4,8], [3,4,9], [3,5,7], [3,5,9]\nThe falling path with the smallest sum is\u00a0[1,5,7], so the answer is\u00a013.",
            "Input: grid = [[7]]\nOutput: 7"
        ],
        "constraints": "n == grid.length == grid[i].length\n1 <= n <= 200\n-99 <= grid[i][j] <= 99",
        "release_time": 1668185090,
        "oracle_code": "class Solution {\n    int m;\n    int n;\n    Integer memo[][];\n\n    public int minFallingPathSum(int[][] grid) {   \n         m=grid.length;\n         n=grid[0].length;\n        //<<---------------for Recursive Soln--------------->>\n         memo=new Integer[m][n];//memo [][]\n\n         int recRes=Integer.MAX_VALUE;\n\n         //iterate over the 1st rows col \n        //  for(int col=0;col<n;col++)\n        //            recRes=Math.min(recRes,minFallingPathSum_Rec(grid,0,col));\n\n      //<<---------------for Recursive Soln--------------->>\n        //  return recRes;\n\n          //<<---------------for Tabulation  Soln--------------->>\n         int Tabulation_Ans=minFallingPathSum_Tabulation(grid);\n         return Tabulation_Ans;\n    }\n\n    public int minFallingPathSum_Rec(int[][] grid,int i,int j){\n            \n            if(j<0 || j>=n || i<0 || i>=m)\n                           return Integer.MAX_VALUE;\n\n            if(i==m-1)\n                     return grid[i][j];\n\n            if(memo[i][j]!=null)\n                        return memo[i][j];\n\n            int lowerLeftSum=Integer.MAX_VALUE;\n            int lowerRightSum=Integer.MAX_VALUE;\n\n            for(int col=0;col<=j-1;col++)\n                    lowerLeftSum=Math.min(lowerLeftSum,minFallingPathSum_Rec(grid,i+1,col));\n\n            for(int col=j+1;col<=n-1;col++)\n                    lowerRightSum=Math.min(lowerRightSum,minFallingPathSum_Rec(grid,i+1,col));\n\n          return memo[i][j]=Math.min(lowerLeftSum,lowerRightSum)+grid[i][j];\n\n     }//rec--->>memorization\n\n\n\n\n     int minFallingPathSum_Tabulation(int[][] grid){\n          int dp[][]=new int[m][n];\n\n          for(int i=m-1;i>=0;i--){\n              for(int j=n-1;j>=0;j--){\n                    \n                    if(i==m-1)\n                     {\n                         dp[i][j]=grid[i][j];\n                         continue;\n                     }//base case : if the last row \n                \n                int lowerLeftSum=Integer.MAX_VALUE;\n                int lowerRightSum=Integer.MAX_VALUE;\n                //for lower left sum calculation \n                for(int col=0;col<=j-1;col++){\n                    lowerLeftSum=Math.min(lowerLeftSum,((col<0)?Integer.MAX_VALUE:dp[i+1][col]));\n                }\n                \n                //for lower right sum calculation \n                for(int col=j+1;col<=n-1;col++){\n                    lowerRightSum=Math.min(lowerRightSum,((col>=n)?Integer.MAX_VALUE:dp[i+1][col]));\n                \n                }\n                \n                dp[i][j]=Math.min(lowerLeftSum,lowerRightSum)+grid[i][j];\n              \n              }//inner \n          }//ouer \n           \n\n          int Ans=Integer.MAX_VALUE;\n\n          for(int COL=0;COL<n;COL++){\n              Ans=Math.min(Ans,dp[0][COL]);\n          }\n          \n          return Ans;\n     \n     }//tabulation soln:derived from the recursive soln \n}",
        "content": "# Intuition\\nat any particular cell grid(i,j) we need the minm of all cells of f(i+1,{0 to j-1}) and all minm of cells of f(i+1,{j+1 to n-1})\\n\\n\\n# I have shared both recursive/memo code and alternate tabulation code on same code space . Have a look into the soln and do let me know if any confusion . Please do upvote if you find the soln helpful \\uD83D\\uDE80\\n\\n# Code\\n```\\nclass Solution {\\n    int m;\\n    int n;\\n    Integer memo[][];\\n\\n    public int minFallingPathSum(int[][] grid) {   \\n         m=grid.length;\\n         n=grid[0].length;\\n        //<<---------------for Recursive Soln--------------->>\\n         memo=new Integer[m][n];//memo [][]\\n\\n         int recRes=Integer.MAX_VALUE;\\n\\n         //iterate over the 1st rows col \\n        //  for(int col=0;col<n;col++)\\n        //            recRes=Math.min(recRes,minFallingPathSum_Rec(grid,0,col));\\n\\n      //<<---------------for Recursive Soln--------------->>\\n        //  return recRes;\\n\\n          //<<---------------for Tabulation  Soln--------------->>\\n         int Tabulation_Ans=minFallingPathSum_Tabulation(grid);\\n         return Tabulation_Ans;\\n    }\\n\\n    public int minFallingPathSum_Rec(int[][] grid,int i,int j){\\n            \\n            if(j<0 || j>=n || i<0 || i>=m)\\n                           return Integer.MAX_VALUE;\\n\\n            if(i==m-1)\\n                     return grid[i][j];\\n\\n            if(memo[i][j]!=null)\\n                        return memo[i][j];\\n\\n            int lowerLeftSum=Integer.MAX_VALUE;\\n            int lowerRightSum=Integer.MAX_VALUE;\\n\\n            for(int col=0;col<=j-1;col++)\\n                    lowerLeftSum=Math.min(lowerLeftSum,minFallingPathSum_Rec(grid,i+1,col));\\n\\n            for(int col=j+1;col<=n-1;col++)\\n                    lowerRightSum=Math.min(lowerRightSum,minFallingPathSum_Rec(grid,i+1,col));\\n\\n          return memo[i][j]=Math.min(lowerLeftSum,lowerRightSum)+grid[i][j];\\n\\n     }//rec--->>memorization\\n\\n\\n\\n\\n     int minFallingPathSum_Tabulation(int[][] grid){\\n          int dp[][]=new int[m][n];\\n\\n          for(int i=m-1;i>=0;i--){\\n              for(int j=n-1;j>=0;j--){\\n                    \\n                    if(i==m-1)\\n                     {\\n                         dp[i][j]=grid[i][j];\\n                         continue;\\n                     }//base case : if the last row \\n                \\n                int lowerLeftSum=Integer.MAX_VALUE;\\n                int lowerRightSum=Integer.MAX_VALUE;\\n                //for lower left sum calculation \\n                for(int col=0;col<=j-1;col++){\\n                    lowerLeftSum=Math.min(lowerLeftSum,((col<0)?Integer.MAX_VALUE:dp[i+1][col]));\\n                }\\n                \\n                //for lower right sum calculation \\n                for(int col=j+1;col<=n-1;col++){\\n                    lowerRightSum=Math.min(lowerRightSum,((col>=n)?Integer.MAX_VALUE:dp[i+1][col]));\\n                \\n                }\\n                \\n                dp[i][j]=Math.min(lowerLeftSum,lowerRightSum)+grid[i][j];\\n              \\n              }//inner \\n          }//ouer \\n           \\n\\n          int Ans=Integer.MAX_VALUE;\\n\\n          for(int COL=0;COL<n;COL++){\\n              Ans=Math.min(Ans,dp[0][COL]);\\n          }\\n          \\n          return Ans;\\n     \\n     }//tabulation soln:derived from the recursive soln \\n}\\n```",
        "level": "hard",
        "buggy_code": "\nclass Solution {\n    int m;\n    int n;\n    Integer memo[][];\n\n    public int minFallingPathSum(int[][] grid) {   \n         m=grid.length;\n         n=grid[0].length;\n        //<<---------------for Recursive Soln--------------->>\n         memo=new Integer[m][n];//memo [][]\n\n         int recRes=Integer.MAX_VALUE;\n\n         //iterate over the 1st rows col \n        //  for(int col=0;col<n;col++)\n        //            recRes=Math.min(recRes,minFallingPathSum_Rec(grid,0,col));\n\n      //<<---------------for Recursive Soln--------------->>\n        //  return recRes;\n\n          //<<---------------for Tabulation  Soln--------------->>\n         int Tabulation_Ans=minFallingPathSum_Tabulation(grid);\n         return Tabulation_Ans;\n    }\n\n    public int minFallingPathSum_Rec(int[][] grid,int i,int j){\n            \n            if(j<0 || j>=n || i<0 || i>=m)\n                           return Integer.MAX_VALUE;\n\n            if(i=m-1)\n                     return grid[i][j];\n\n            if(memo[i][j]!=null)\n                        return memo[i][j];\n\n            int lowerLeftSum=Integer.MAX_VALUE;\n            int lowerRightSum=Integer.MAX_VALUE;\n\n            for(int col=0;col<=j-1;col++)\n                    lowerLeftSum=Math.min(lowerLeftSum,minFallingPathSum_Rec(grid,i+1,col));\n\n            for(int col=j+1;col<=n-1;col++)\n                    lowerRightSum=Math.min(lowerRightSum,minFallingPathSum_Rec(grid,i+1,col));\n\n          return memo[i][j]=Math.min(lowerLeftSum,lowerRightSum)+grid[i][j];\n\n     }//rec--->>memorization\n\n\n\n\n     int minFallingPathSum_Tabulation(int[][] grid){\n          int dp[][]=new int[m][n];\n\n          for(int i=m-1;i>=0;i--){\n              for(int j=n-1;j>=0;j--){\n                    \n                    if(i==m-1)\n                     {\n                         dp[i][j]=grid[i][j];\n                         continue;\n                     }//base case : if the last row \n                \n                int lowerLeftSum=Integer.MAX_VALUE;\n                int lowerRightSum=Integer.MAX_VALUE;\n                //for lower left sum calculation \n                for(int col=0;col<=j-1;col++){\n                    lowerLeftSum=Math.min(lowerLeftSum,((col<0)?Integer.MAX_VALUE:dp[i+1][col]));\n                }\n                \n                //for lower right sum calculation \n                for(int col=j+1;col<=n-1;col++){\n                    lowerRightSum=Math.min(lowerRightSum,((col>=n)?Integer.MAX_VALUE:dp[i+1][col]));\n                \n                }\n                \n                dp[i][j]=Math.min(lowerLeftSum,lowerRightSum)+grid[i][j];\n              \n              }//inner \n          }//ouer \n           \n\n          int Ans=Integer.MAX_VALUE;\n\n          for(int COL=0;COL<n;COL++){\n              Ans=Math.min(Ans,dp[0][COL]);\n          }\n          \n          return Ans;\n     \n     }//tabulation soln:derived from the recursive soln \n}\n",
        "explanations": "\nIn minFallingPathSum_Rec method, equivalence operator (==) is replaced with assignment operator (=) causing a compile error.\n"
    },
    {
        "slug": "destroying-asteroids",
        "description": "You are given an integer mass, which represents the original mass of a planet. You are further given an integer array asteroids, where asteroids[i] is the mass of the ith asteroid.\nYou can arrange for the planet to collide with the asteroids in any arbitrary order. If the mass of the planet is greater than or equal to the mass of the asteroid, the asteroid is destroyed and the planet gains the mass of the asteroid. Otherwise, the planet is destroyed.\nReturn true if all asteroids can be destroyed. Otherwise, return false.",
        "examples": [
            "Input: mass = 10, asteroids = [3,9,19,5,21]\nOutput: true\nExplanation: One way to order the asteroids is [9,19,5,3,21]:\n- The planet collides with the asteroid with a mass of 9. New planet mass: 10 + 9 = 19\n- The planet collides with the asteroid with a mass of 19. New planet mass: 19 + 19 = 38\n- The planet collides with the asteroid with a mass of 5. New planet mass: 38 + 5 = 43\n- The planet collides with the asteroid with a mass of 3. New planet mass: 43 + 3 = 46\n- The planet collides with the asteroid with a mass of 21. New planet mass: 46 + 21 = 67\nAll asteroids are destroyed.",
            "Input: mass = 5, asteroids = [4,9,23,4]\nOutput: false\nExplanation: \nThe planet cannot ever gain enough mass to destroy the asteroid with a mass of 23.\nAfter the planet destroys the other asteroids, it will have a mass of 5 + 4 + 9 + 4 = 22.\nThis is less than 23, so a collision would not destroy the last asteroid."
        ],
        "constraints": "1 <= mass <= 105\n1 <= asteroids.length <= 105\n1 <= asteroids[i] <= 105",
        "release_time": 1680364813,
        "oracle_code": "class Solution {\n    public boolean asteroidsDestroyed(int mass, int[] asteroids) {\n        Arrays.sort(asteroids);\n        int c=0;\n        long s=(long)mass;\n        for(int i=0;i<asteroids.length;i++)\n        {\n            long d=(long)asteroids[i];\n            if(s>=d)\n            {\n                c+=1;\n                s+=d;\n            }\n        }\n        if(c==asteroids.length)return true;\n        else return false;\n    }\n}",
        "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean asteroidsDestroyed(int mass, int[] asteroids) {\\n        Arrays.sort(asteroids);\\n        int c=0;\\n        long s=(long)mass;\\n        for(int i=0;i<asteroids.length;i++)\\n        {\\n            long d=(long)asteroids[i];\\n            if(s>=d)\\n            {\\n                c+=1;\\n                s+=d;\\n            }\\n        }\\n        if(c==asteroids.length)return true;\\n        else return false;\\n    }\\n}\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\n    public boolean asteroidsDestroyed(int mass, int[] asteroids) {\n        Arrays.sort(asteroids);\n        int c=0;\n        long s=(long)mass;\n        for(int i=0;i<asteroids.length;i++)\n        {\n            long d=(long)asteroids[i];\n            if(s==d)\n            {\n                c+=1;\n                s+=d;\n            }\n        }\n        if(c=asteroids.length)return true;\n        else return false;\n    }\n}\n",
        "explanations": "\nBug introduced in logic with (s==d) instead of (s>=d) and assignment operator (c=asteroids.length) instead of equal operator (c==asteroids.length).\n"
    },
    {
        "slug": "make-array-strictly-increasing",
        "description": "Given two integer arrays\u00a0arr1 and arr2, return the minimum number of operations (possibly zero) needed\u00a0to make arr1 strictly increasing.\nIn one operation, you can choose two indices\u00a00 <=\u00a0i < arr1.length\u00a0and\u00a00 <= j < arr2.length\u00a0and do the assignment\u00a0arr1[i] = arr2[j].\nIf there is no way to make\u00a0arr1\u00a0strictly increasing,\u00a0return\u00a0-1.",
        "examples": [
            "Input: arr1 = [1,5,3,6,7], arr2 = [1,3,2,4]\nOutput: 1\nExplanation: Replace 5 with 2, then arr1 = [1, 2, 3, 6, 7].",
            "Input: arr1 = [1,5,3,6,7], arr2 = [4,3,1]\nOutput: 2\nExplanation: Replace 5 with 3 and then replace 3 with 4. arr1 = [1, 3, 4, 6, 7].",
            "Input: arr1 = [1,5,3,6,7], arr2 = [1,6,3,3]\nOutput: -1\nExplanation: You can't make arr1 strictly increasing."
        ],
        "constraints": "1 <= arr1.length, arr2.length <= 2000\n0 <= arr1[i], arr2[i] <= 10^9",
        "release_time": 1686968225,
        "oracle_code": "class Solution { \n    public int makeArrayIncreasing(int[] arr1, int[] arr2) {\n        Arrays.sort(arr2);\n        \n        int answer = helper(0, -1, arr1, arr2);\n        \n        return answer < Integer.MAX_VALUE-100 ? answer : -1;\n    }\n    \n    Map<Pair<Integer, Integer>, Integer> dp = new HashMap<>();\n    private int helper(int i, int prev, int[] arr1, int[] arr2) {\n        if (i == arr1.length) {\n            return 0;\n        }\n        if (dp.containsKey(new Pair<>(i, prev))) {\n            return dp.get(new Pair<>(i, prev));\n        }\n\n        int operation = Integer.MAX_VALUE-100;\n\n        \n        if (arr1[i] > prev) {\n            operation = helper(i + 1, arr1[i], arr1, arr2);\n        }\n\n       \n        int idx = binarySearch(arr2, prev);\n\n        \n        if (idx < arr2.length) {\n            operation = Math.min(operation, 1 + helper(i + 1, arr2[idx], arr1, arr2));\n        }\n\n        dp.put(new Pair<>(i, prev),operation);\n        return operation;\n    }\n    \n    private static int binarySearch(int[] arr, int value) {\n        int left = 0, right = arr.length-1;\n        while (left <= right) {\n            int mid = left+(right-left) / 2;\n            if (arr[mid] <= value) {\n                left = mid + 1;\n            } else {\n                right = mid-1;\n            }\n        }\n        return left;\n    } \n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\n\\nclass Solution { \\n    public int makeArrayIncreasing(int[] arr1, int[] arr2) {\\n        Arrays.sort(arr2);\\n        \\n        int answer = helper(0, -1, arr1, arr2);\\n        \\n        return answer < Integer.MAX_VALUE-100 ? answer : -1;\\n    }\\n    \\n    Map<Pair<Integer, Integer>, Integer> dp = new HashMap<>();\\n    private int helper(int i, int prev, int[] arr1, int[] arr2) {\\n        if (i == arr1.length) {\\n            return 0;\\n        }\\n        if (dp.containsKey(new Pair<>(i, prev))) {\\n            return dp.get(new Pair<>(i, prev));\\n        }\\n\\n        int operation = Integer.MAX_VALUE-100;\\n\\n        \\n        if (arr1[i] > prev) {\\n            operation = helper(i + 1, arr1[i], arr1, arr2);\\n        }\\n\\n       \\n        int idx = binarySearch(arr2, prev);\\n\\n        \\n        if (idx < arr2.length) {\\n            operation = Math.min(operation, 1 + helper(i + 1, arr2[idx], arr1, arr2));\\n        }\\n\\n        dp.put(new Pair<>(i, prev),operation);\\n        return operation;\\n    }\\n    \\n    private static int binarySearch(int[] arr, int value) {\\n        int left = 0, right = arr.length-1;\\n        while (left <= right) {\\n            int mid = left+(right-left) / 2;\\n            if (arr[mid] <= value) {\\n                left = mid + 1;\\n            } else {\\n                right = mid-1;\\n            }\\n        }\\n        return left;\\n    } \\n}\\n```",
        "level": "hard",
        "buggy_code": "\nclass Solution { \n    public int makeArrayIncreasing(int[] arr1, int[] arr2) {\n        Arrays.sort(arr2);\n        \n        int answer = helper(0, -1, arr1, arr2);\n        \n        return answer < Integer.MAX_VALUE-100 ? answer : -1;\n    }\n    \n    Map<Pair<Integer, Integer>, Integer> dp = new HashMap<>();\n    private int helper(int i, int prev, int[] arr1, int[] arr2) {\n        if (i == arr1.length) {\n            return 0;\n        }\n        if (dp.containsKey(new Pair<>(i, prev))) {\n            return dp.get(new Pair<>(i, prev));\n        }\n\n        int operation = Integer.MAX_VALUE-100;\n\n        \n        if (arr1[i] > prev) {\n            operation = helper(i + 1, arr1[i], arr1, arr2);\n        }\n\n       \n        int idx = binarySearch(arr2, prev);\n\n        \n        if (idx < arr2.length) {\n            operation == Math.min(operation, 1 + helper(i + 1, arr2[idx], arr1, arr2));\n        }\n\n        dp.put(new Pair<>(i, prev),operation);\n        return operation;\n    }\n    \n    private static int binarySearch(int[] arr, int value) {\n        int left = 0, right = arr.length-1;\n        while (left <= right) {\n            int mid = left+(right-left) / 2;\n            if (arr[mid] <= value) {\n                left = mid + 1;\n            } else {\n                right = mid-1;\n            }\n        }\n        return left;\n    } \n}\n",
        "explanations": "\nUsed equality (==) instead of assignment (=) in the min calculation, causing syntax error.\n"
    },
    {
        "slug": "design-graph-with-shortest-path-calculator",
        "description": "There is a directed weighted graph that consists of n nodes numbered from 0 to n - 1. The edges of the graph are initially represented by the given array edges where edges[i] = [fromi, toi, edgeCosti] meaning that there is an edge from fromi to toi with the cost edgeCosti.\nImplement the Graph class:\n\nGraph(int n, int[][] edges) initializes the object with n nodes and the given edges.\naddEdge(int[] edge) adds an edge to the list of edges where edge = [from, to, edgeCost]. It is guaranteed that there is no edge between the two nodes before adding this one.\nint shortestPath(int node1, int node2) returns the minimum cost of a path from node1 to node2. If no path exists, return -1. The cost of a path is the sum of the costs of the edges in the path.",
        "examples": [
            "Input\n[\"Graph\", \"shortestPath\", \"shortestPath\", \"addEdge\", \"shortestPath\"]\n[[4, [[0, 2, 5], [0, 1, 2], [1, 2, 1], [3, 0, 3]]], [3, 2], [0, 3], [[1, 3, 4]], [0, 3]]\nOutput\n[null, 6, -1, null, 6]\n\nExplanation\nGraph g = new Graph(4, [[0, 2, 5], [0, 1, 2], [1, 2, 1], [3, 0, 3]]);\ng.shortestPath(3, 2); // return 6. The shortest path from 3 to 2 in the first diagram above is 3 -> 0 -> 1 -> 2 with a total cost of 3 + 2 + 1 = 6.\ng.shortestPath(0, 3); // return -1. There is no path from 0 to 3.\ng.addEdge([1, 3, 4]); // We add an edge from node 1 to node 3, and we get the second diagram above.\ng.shortestPath(0, 3); // return 6. The shortest path from 0 to 3 now is 0 -> 1 -> 3 with a total cost of 2 + 4 = 6."
        ],
        "constraints": "1 <= n <= 100\n0 <= edges.length <= n * (n - 1)\nedges[i].length == edge.length == 3\n0 <= fromi, toi, from, to, node1, node2 <= n - 1\n1 <= edgeCosti, edgeCost <= 106\nThere are no repeated edges and no self-loops in the graph at any point.\nAt most 100 calls will be made for addEdge.\nAt most 100 calls will be made for shortestPath.",
        "release_time": 1681574555,
        "oracle_code": "class Graph {\n    List<List<int[]>> adj=new ArrayList<>();\n    int n;\n    public Graph(int n, int[][] edges) {\n        for(int i=0;i<n;i++){\n            adj.add(new ArrayList<>());\n        }\n        this.n=n;\n        for(int edge[]: edges){\n            adj.get(edge[0]).add(new int[]{edge[1],edge[2]});\n        }\n    }\n    \n    public void addEdge(int[] edge) {\n        adj.get(edge[0]).add(new int[]{edge[1],edge[2]});\n    }\n    \n    public int shortestPath(int node1, int node2) {\n        int dist[]=new int[n+1];\n        Arrays.fill(dist,Integer.MAX_VALUE);\n        dist[node1]=0;\n        PriorityQueue<int[]> pq=new PriorityQueue<>((a,b)->a[1]-b[1]);\n        pq.add(new int[]{node1,0});\n        while(!pq.isEmpty()){\n            int u=pq.poll()[0];\n            for(int p[]: adj.get(u)){\n                int v=p[0];\n                int w=p[1];\n                if(dist[v]>dist[u]+w){\n                    dist[v]=dist[u]+w;\n                    pq.add(new int[]{v,dist[v]});\n                }\n            }\n        }\n        if(dist[node2]==Integer.MAX_VALUE){\n                return -1;\n        }\n        return dist[node2];\n    }\n    \n}\n\n/**\n * Your Graph object will be instantiated and called as such:\n * Graph obj = new Graph(n, edges);\n * obj.addEdge(edge);\n * int param_2 = obj.shortestPath(node1,node2);\n */",
        "content": "\\n\\n# Code\\n```\\nclass Graph {\\n    List<List<int[]>> adj=new ArrayList<>();\\n    int n;\\n    public Graph(int n, int[][] edges) {\\n        for(int i=0;i<n;i++){\\n            adj.add(new ArrayList<>());\\n        }\\n        this.n=n;\\n        for(int edge[]: edges){\\n            adj.get(edge[0]).add(new int[]{edge[1],edge[2]});\\n        }\\n    }\\n    \\n    public void addEdge(int[] edge) {\\n        adj.get(edge[0]).add(new int[]{edge[1],edge[2]});\\n    }\\n    \\n    public int shortestPath(int node1, int node2) {\\n        int dist[]=new int[n+1];\\n        Arrays.fill(dist,Integer.MAX_VALUE);\\n        dist[node1]=0;\\n        PriorityQueue<int[]> pq=new PriorityQueue<>((a,b)->a[1]-b[1]);\\n        pq.add(new int[]{node1,0});\\n        while(!pq.isEmpty()){\\n            int u=pq.poll()[0];\\n            for(int p[]: adj.get(u)){\\n                int v=p[0];\\n                int w=p[1];\\n                if(dist[v]>dist[u]+w){\\n                    dist[v]=dist[u]+w;\\n                    pq.add(new int[]{v,dist[v]});\\n                }\\n            }\\n        }\\n        if(dist[node2]==Integer.MAX_VALUE){\\n                return -1;\\n        }\\n        return dist[node2];\\n    }\\n    \\n}\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph obj = new Graph(n, edges);\\n * obj.addEdge(edge);\\n * int param_2 = obj.shortestPath(node1,node2);\\n */",
        "level": "hard",
        "buggy_code": "\nclass Graph {\n    List<List<int[]>> adj=new ArrayList<>();\n    int n;\n    public Graph(int n, int[][] edges) {\n        for(int i=0;i<n;i++){\n            adj.add(new ArrayList<>());\n        }\n        this.n=n;\n        for(int edge[]: edges){\n            adj.get(edge[0]).add(new int[]{edge[1],edge[2]});\n        }\n    }\n    \n    public void addEdge(int[] edge) {\n        adj.get(edge[0]).add(new int[]{edge[1],edge[2]});\n    }\n    \n    public int shortestPath(int node1, int node2) {\n        int dist[]=new int[n+1];\n        Arrays.fill(dist,Integer.MAX_VALUE);\n        dist[node1]=0;\n        PriorityQueue<int[]> pq=new PriorityQueue<>((a,b)->a[1]-b[1]);\n        pq.add(new int[]{node1,0});\n        while(!pq.isEmpty()){\n            int u=pq.poll()[0];\n            for(int p[]: adj.get(u)){\n                int v=p[0];\n                int w=p[1];\n                if(dist[v]==dist[u]+w){\n                    dist[v]=dist[u]+w;\n                    pq.add(new int[]{v,dist[v]});\n                }\n            }\n        }\n        if(dist[node2]==Integer.MAX_VALUE){\n                return -1;\n        }\n        return dist[node2];\n    }\n    \n}\n",
        "explanations": "\nChanged \"dist[v]>dist[u]+w\" to \"dist[v]==dist[u]+w\", which causes incorrect shortest path calculation.\n"
    },
    {
        "slug": "erect-the-fence",
        "description": "You are given an array trees where trees[i] = [xi, yi] represents the location of a tree in the garden.\nFence the entire garden using the minimum length of rope, as it is expensive. The garden is well-fenced only if all the trees are enclosed.\nReturn the coordinates of trees that are exactly located on the fence perimeter. You may return the answer in any order.",
        "examples": [
            "Input: trees = [[1,1],[2,2],[2,0],[2,4],[3,3],[4,2]]\nOutput: [[1,1],[2,0],[4,2],[3,3],[2,4]]\nExplanation: All the trees will be on the perimeter of the fence except the tree at [2, 2], which will be inside the fence.",
            "Input: trees = [[1,2],[2,2],[4,2]]\nOutput: [[4,2],[2,2],[1,2]]\nExplanation: The fence forms a line that passes through all the trees."
        ],
        "constraints": "1 <= trees.length <= 3000\ntrees[i].length == 2\n0 <= xi, yi <= 100\nAll the given positions are unique.",
        "release_time": 1668873110,
        "oracle_code": "class Solution {\n    \n    public int[][] outerTrees(int[][] trees) {\n        if(trees.length == 3){\n            return trees;\n        }\n        Stack<int[]> upper = new Stack<>();\n        Stack<int[]> lower = new Stack<>();\n        \n        Arrays.sort(trees,(p,q) ->\n                  q[0]-p[0]==0?q[1]-p[1]:q[0]-p[0]);\n        \n        for(int i = 0 ; i < trees.length ; i++){\n            int size = trees.length;\n            while(upper.size() >= 2 && angle(upper.get(upper.size() - 2),upper.get(upper.size() - 1),trees[i]) > 0){\n                upper.pop();  \n                }\n            while(lower.size() >= 2 && angle(lower.get(lower.size() - 2),lower.get(lower.size() - 1),trees[i]) < 0){\n                 lower.pop();  \n              }\n            upper.push(trees[i]);\n            lower.push(trees[i]);\n        }\n        \n        \n        Set<int[]> res= new HashSet<>(lower);\n        res.addAll(upper);\n        return res.toArray(new int[res.size()][]);\n    }\n    \n    public int angle(int[] A , int[] B , int[] C){\n        return (C[0] - A[0]) * (B[1] - A[1]) - (B[0] - A[0]) * (C[1] - A[1]);\n    }\n}",
        "content": "```\\nclass Solution {\\n    \\n    public int[][] outerTrees(int[][] trees) {\\n        if(trees.length == 3){\\n            return trees;\\n        }\\n        Stack<int[]> upper = new Stack<>();\\n        Stack<int[]> lower = new Stack<>();\\n        \\n        Arrays.sort(trees,(p,q) ->\\n                  q[0]-p[0]==0?q[1]-p[1]:q[0]-p[0]);\\n        \\n        for(int i = 0 ; i < trees.length ; i++){\\n            int size = trees.length;\\n            while(upper.size() >= 2 && angle(upper.get(upper.size() - 2),upper.get(upper.size() - 1),trees[i]) > 0){\\n                upper.pop();  \\n                }\\n            while(lower.size() >= 2 && angle(lower.get(lower.size() - 2),lower.get(lower.size() - 1),trees[i]) < 0){\\n                 lower.pop();  \\n              }\\n            upper.push(trees[i]);\\n            lower.push(trees[i]);\\n        }\\n        \\n        \\n        Set<int[]> res= new HashSet<>(lower);\\n        res.addAll(upper);\\n        return res.toArray(new int[res.size()][]);\\n    }\\n    \\n    public int angle(int[] A , int[] B , int[] C){\\n        return (C[0] - A[0]) * (B[1] - A[1]) - (B[0] - A[0]) * (C[1] - A[1]);\\n    }\\n}\\n```\\n\\n**Upvote Please**",
        "level": "hard",
        "buggy_code": "\nclass Solution {\n    \n    public int[][] outerTrees(int[][] trees) {\n        if(trees.length = 3){\n            return trees;\n        }\n        Stack<int[]> upper = new Stack<>();\n        Stack<int[]> lower = new Stack<>();\n        \n        Arrays.sort(trees,(p,q) ->\n                  q[0]-p[0]==0?q[1]-p[1]:q[0]-p[0]);\n        \n        for(int i = 0 ; i < trees.length ; i++){\n            int size = trees.length;\n            while(upper.size() >= 2 && angle(upper.get(upper.size() - 2),upper.get(upper.size() - 1),trees[i]) > 0){\n                upper.pop();  \n                }\n            while(lower.size() >= 2 && angle(lower.get(lower.size() - 2),lower.get(lower.size() - 1),trees[i]) < 0){\n                 lower.pop();  \n              }\n            upper.push(trees[i]);\n            lower.push(trees[i]);\n        }\n        \n        \n        Set<int[]> res= new HashSet<>(lower);\n        res.addAll(upper);\n        return res.toArray(new int[res.size()][]);\n    }\n    \n    public int angle(int[] A , int[] B , int[] C){\n        return (C[0] - A[0]) * (B[1] - A[1]) - (B[0] - A[0]) * (C[1] - A[1]);\n    }\n}\n",
        "explanations": "\nThe bug lies in the if statement checking length of trees, where == is replaced with =.\n"
    },
    {
        "slug": "relative-ranks",
        "description": "You are given an integer array score of size n, where score[i] is the score of the ith athlete in a competition. All the scores are guaranteed to be unique.\nThe athletes are placed based on their scores, where the 1st place athlete has the highest score, the 2nd place athlete has the 2nd highest score, and so on. The placement of each athlete determines their rank:\n\nThe 1st place athlete's rank is \"Gold Medal\".\nThe 2nd place athlete's rank is \"Silver Medal\".\nThe 3rd place athlete's rank is \"Bronze Medal\".\nFor the 4th place to the nth place athlete, their rank is their placement number (i.e., the xth place athlete's rank is \"x\").\n\nReturn an array answer of size n where answer[i] is the rank of the ith athlete.",
        "examples": [
            "Input: score = [5,4,3,2,1]\nOutput: [\"Gold Medal\",\"Silver Medal\",\"Bronze Medal\",\"4\",\"5\"]\nExplanation: The placements are [1st, 2nd, 3rd, 4th, 5th].",
            "Input: score = [10,3,8,9,4]\nOutput: [\"Gold Medal\",\"5\",\"Bronze Medal\",\"Silver Medal\",\"4\"]\nExplanation: The placements are [1st, 5th, 3rd, 2nd, 4th]."
        ],
        "constraints": "n == score.length\n1 <= n <= 104\n0 <= score[i] <= 106\nAll the values in score are unique.",
        "release_time": 1683184626,
        "oracle_code": "class Solution {\n    public String[] findRelativeRanks(int[] score) {\n         int n=score.length;\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[b]-score[a]);\n        for(int i=0;i<n;i++) pq.add(i);\n      String[] ans = new String[n];\n                int i=1;\n        while(!pq.isEmpty()){\n            int idx=pq.poll();\n         if(i==1)   { ans[idx]=\"Gold Medal\"; i++;}\n         else if(i==2)   { ans[idx]=\"Silver Medal\"; i++;}\n         else if(i==3)   { ans[idx]=\"Bronze Medal\"; i++;}\n         else ans[idx]=Integer.toString(i++);\n        }\n        return ans;  \n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String[] findRelativeRanks(int[] score) {\\n         int n=score.length;\\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[b]-score[a]);\\n        for(int i=0;i<n;i++) pq.add(i);\\n      String[] ans = new String[n];\\n                int i=1;\\n        while(!pq.isEmpty()){\\n            int idx=pq.poll();\\n         if(i==1)   { ans[idx]=\"Gold Medal\"; i++;}\\n         else if(i==2)   { ans[idx]=\"Silver Medal\"; i++;}\\n         else if(i==3)   { ans[idx]=\"Bronze Medal\"; i++;}\\n         else ans[idx]=Integer.toString(i++);\\n        }\\n        return ans;  \\n    }\\n}\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\n    public String[] findRelativeRanks(int[] score) {\n         int n=score.length;\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[b]-score[a]);\n        for(int i=0;i<n;i++) pq.add(i);\n        String[] ans = new String[n];\n        int i=1;\n        while(!pq.isEmpty()){\n            int idx=pq.poll();\n            if(i=1) { ans[idx]=\"Gold Medal\"; i++;} \n            else if(i=2) { ans[idx]=\"Silver Medal\"; i++;} \n            else if(i=3) { ans[idx]=\"Bronze Medal\"; i++;} \n            else ans[idx]=Integer.toString(i++);\n        }\n        return ans;  \n    }\n}\n",
        "explanations": " \nThe '==' operator (equality check) is mistakenly replaced with '=' (assignment) in if conditions. \n"
    },
    {
        "slug": "move-zeroes",
        "description": "Given an integer array nums, move all 0's to the end of it while maintaining the relative order of the non-zero elements.\nNote that you must do this in-place without making a copy of the array.",
        "examples": [
            "Input: nums = [0,1,0,3,12]\nOutput: [1,3,12,0,0]",
            "Input: nums = [0]\nOutput: [0]"
        ],
        "constraints": "1 <= nums.length <= 104\n-231 <= nums[i] <= 231 - 1",
        "release_time": 1684064317,
        "oracle_code": "class Solution {\n    public void moveZeroes(int[] nums) {\n        int m=-1;\n        for(int i=0; i<nums.length; i++)\n        {\n            if(nums[i]==0)\n            {\n                if(m==-1 || nums[m]!=0)\n                {\n                    m=i;\n                }\n            }\n            else\n            {\n                if(m!=-1)\n                {\n                    int temp = nums[i];\n                    nums[i]=nums[m];\n                    nums[m]=temp;\n                    m++;\n                }\n            }\n        }\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe goal of this solution is to move all the zeroes in the input array nums to the end of the array while maintaining the relative order of the non-zero elements\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize a variable m to -1, which will keep track of the position of the first zero encountered.\\n2. Traverse the array nums from left to right: a. If the current element is zero, and m is -1 or the element at position m is non-zero, set m to the current index. b. If the current element is non-zero and m is not -1, swap the current element with the element at position m and increment m.\\n3. After the traversal, all the zeroes will be at the end of the array, and the relative order of the non-zero elements will be maintained.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n O(n), where n is the length of the input array nums. The algorithm iterates through the array once\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1), as the algorithm only uses a constant amount of extra space to store the variable m and the temporary variable temp used for swapping elements.\\n\\n# Code\\n```\\nclass Solution {\\n    public void moveZeroes(int[] nums) {\\n        int m=-1;\\n        for(int i=0; i<nums.length; i++)\\n        {\\n            if(nums[i]==0)\\n            {\\n                if(m==-1 || nums[m]!=0)\\n                {\\n                    m=i;\\n                }\\n            }\\n            else\\n            {\\n                if(m!=-1)\\n                {\\n                    int temp = nums[i];\\n                    nums[i]=nums[m];\\n                    nums[m]=temp;\\n                    m++;\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\n    public void moveZeroes(int[] nums) {\n        int m=-1;\n        for(int i=0; i<nums.length; i++)\n        {\n            if(nums[i]=0)\n            {\n                if(m==-1 || nums[m]!=0)\n                {\n                    m=i;\n                }\n            }\n            else\n            {\n                if(m!=-1)\n                {\n                    int temp = nums[i];\n                    nums[i]=nums[m];\n                    nums[m]=temp;\n                    m++;\n                }\n            }\n        }\n    }\n}\n",
        "explanations": "\nThe bug is in the 'if(nums[i]=0)' line, where it should be '==' for equality check.\n"
    },
    {
        "slug": "maximum-binary-tree",
        "description": "You are given an integer array nums with no duplicates. A maximum binary tree can be built recursively from nums using the following algorithm:\n\nCreate a root node whose value is the maximum value in nums.\nRecursively build the left subtree on the subarray prefix to the left of the maximum value.\nRecursively build the right subtree on the subarray suffix to the right of the maximum value.\n\nReturn the maximum binary tree built from nums.",
        "examples": [
            "Input: nums = [3,2,1,6,0,5]\nOutput: [6,3,5,null,2,0,null,null,1]\nExplanation: The recursive calls are as follow:\n- The largest value in [3,2,1,6,0,5] is 6. Left prefix is [3,2,1] and right suffix is [0,5].\n    - The largest value in [3,2,1] is 3. Left prefix is [] and right suffix is [2,1].\n        - Empty array, so no child.\n        - The largest value in [2,1] is 2. Left prefix is [] and right suffix is [1].\n            - Empty array, so no child.\n            - Only one element, so child is a node with value 1.\n    - The largest value in [0,5] is 5. Left prefix is [0] and right suffix is [].\n        - Only one element, so child is a node with value 0.\n        - Empty array, so no child.",
            "Input: nums = [3,2,1]\nOutput: [3,null,2,null,1]"
        ],
        "constraints": "1 <= nums.length <= 1000\n0 <= nums[i] <= 1000\nAll integers in nums are unique.",
        "release_time": 1685481921,
        "oracle_code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public TreeNode constructMaximumBinaryTree(int[] nums) {\n        TreeNode root= construct(nums,0,nums.length-1);\n        return root;\n    }\n    private static TreeNode construct(int arr[], int s, int e){\n        if(s>e)return null;\n        if(s==e) return new TreeNode(arr[s]);\n\n        int idx=findMax(arr,s,e);\n        TreeNode root=new TreeNode(arr[idx]);\n        root.left=construct(arr,s,idx-1);\n        root.right=construct(arr,idx+1,e);\n\n        return root;\n    }\n\n    private static int findMax(int arr[], int s, int e){\n        int max=Integer.MIN_VALUE;\n        int idx=-1;\n        for(int i=s;i<=e; i++)\n        {\n            if(arr[i]>max){\n                max=arr[i];\n                idx=i;\n            }\n        }\n         return idx;\n    }\n\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe code implements a solution to construct a maximum binary tree from an input array nums. The maximum binary tree is a binary tree where the root node has the maximum value in the array, and the left and right subtrees of the root are recursively constructed maximum binary trees from the elements to the left and right of the maximum value.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe code uses a recursive approach to construct the maximum binary tree. It defines two helper functions: constructMaximumBinaryTree and construct.\\n\\n1. constructMaximumBinaryTree function:\\n\\nThis is the main entry point of the code.\\nIt takes the input array nums as a parameter and returns the root of the constructed maximum binary tree.\\nInside this function, it calls the construct function, passing the nums array and the range from 0 to nums.length - 1.\\n2. construct function:\\n\\nThis function takes three parameters: the input array arr, the start index s, and the end index e of the current range.\\nIt constructs the maximum binary tree for the current range of elements in the array.\\nIt first checks if s is greater than e. If so, it means there are no elements in the current range, so it returns null.\\nIf s is equal to e, it means there is only one element in the current range. In this case, it creates a new TreeNode with the value of arr[s] and returns it.\\nIf there are more than one element in the current range, it finds the index of the maximum element using the findMax helper function.\\nIt creates a new TreeNode with the maximum value (arr[idx]) as the root.\\nIt recursively calls the construct function for the left subarray (from s to idx - 1) and assigns the returned value as the left child of the root.\\nIt recursively calls the construct function for the right subarray (from idx + 1 to e) and assigns the returned value as the right child of the root.\\nFinally, it returns the constructed root node of the maximum binary tree for the current range.\\n3. findMax function:\\n\\nThis helper function takes three parameters: the input array arr, the start index s, and the end index e of the current range.\\nIt iterates through the elements in the current range and finds the index of the maximum element.\\nIt initializes a variable max with the minimum integer value and idx with -1.\\nIt compares each element in the range with the current maximum value (max) and updates max and idx if a greater value is found.\\nFinally, it returns the index of the maximum element.\\nThe code uses recursion to divide the array into smaller subarrays and construct the maximum binary tree recursively. It constructs the root node based on the maximum value in the current range, assigns the left and right subtrees recursively, and returns the root node.\\n\\n# Complexity\\n- Time complexity: O(n^2) in worst case and O(n) in avg case.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe constructMaximumBinaryTree function calls the construct function, which performs a recursive construction of the maximum binary tree. The construct function divides the array into smaller subarrays and constructs the tree.\\nIn the worst case, each element in the array needs to be compared with every other element to find the maximum. This results in a time complexity of O(n^2), where n is the length of the nums array.\\nHowever, in the average case, the maximum element can be found in O(n) time. Therefore, the average time complexity of the construct function is O(n).\\nThe construct function is called recursively for each subarray, resulting in a total time complexity of O(n^2) in the worst case and O(n) in the average case.\\n\\n- Space complexity:  O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nThe space complexity is determined by the recursive calls and the stack space required for each call.\\nIn the worst case, when the construct function is called recursively for each subarray, the maximum stack depth is equal to the height of the binary tree. In the worst case, the height of the binary tree can be equal to n, resulting in a space complexity of O(n).\\nAdditionally, the construct function creates new TreeNode objects during the construction process. The number of TreeNode objects created is proportional to the number of elements in the nums array. Therefore, the space complexity for the TreeNode objects is also O(n).\\nOverall, the space complexity is O(n) due to the stack space and the space required for the TreeNode objects.\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode constructMaximumBinaryTree(int[] nums) {\\n        TreeNode root= construct(nums,0,nums.length-1);\\n        return root;\\n    }\\n    private static TreeNode construct(int arr[], int s, int e){\\n        if(s>e)return null;\\n        if(s==e) return new TreeNode(arr[s]);\\n\\n        int idx=findMax(arr,s,e);\\n        TreeNode root=new TreeNode(arr[idx]);\\n        root.left=construct(arr,s,idx-1);\\n        root.right=construct(arr,idx+1,e);\\n\\n        return root;\\n    }\\n\\n    private static int findMax(int arr[], int s, int e){\\n        int max=Integer.MIN_VALUE;\\n        int idx=-1;\\n        for(int i=s;i<=e; i++)\\n        {\\n            if(arr[i]>max){\\n                max=arr[i];\\n                idx=i;\\n            }\\n        }\\n         return idx;\\n    }\\n\\n}\\n```",
        "level": "medium",
        "buggy_code": "\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public TreeNode constructMaximumBinaryTree(int[] nums) {\n        TreeNode root= construct(nums,0,nums.length-1);\n        return root;\n    }\n    private static TreeNode construct(int arr[], int s, int e){\n        if(s>e)return null;\n        if(s = e) return new TreeNode(arr[s]);\n\n        int idx=findMax(arr,s,e);\n        TreeNode root=new TreeNode(arr[idx]);\n        root.left=construct(arr,s,idx-1);\n        root.right=construct(arr,idx+1,e);\n\n        return root;\n    }\n\n    private static int findMax(int arr[], int s, int e){\n        int max=Integer.MIN_VALUE;\n        int idx=-1;\n        for(int i=s;i<=e; i++){\n            if(arr[i]>max){\n                max=arr[i];\n                idx=i;\n            }\n        }\n         return idx;\n    }\n}\n",
        "explanations": "\nUsed assignment operator = instead of equivalence operator == to compare s and e.\n"
    },
    {
        "slug": "move-zeroes",
        "description": "Given an integer array nums, move all 0's to the end of it while maintaining the relative order of the non-zero elements.\nNote that you must do this in-place without making a copy of the array.",
        "examples": [
            "Input: nums = [0,1,0,3,12]\nOutput: [1,3,12,0,0]",
            "Input: nums = [0]\nOutput: [0]"
        ],
        "constraints": "1 <= nums.length <= 104\n-231 <= nums[i] <= 231 - 1",
        "release_time": 1688630198,
        "oracle_code": "class Solution {\n    public void moveZeroes(int[] arr) {\n    int n = arr.length;\n    if(n<=1) return;\n    int s=0;\n    int e=1;\n    while(e<n){\n        if(arr[s]==0 && arr[e]!=0){\n            int temp = arr[s];\n            arr[s] = arr[e];\n            arr[e] = temp;\n            s++;\n            e++;\n        }else if(arr[s]==0 && arr[e]==0){\n            e++;\n        }else{\n            s++;\n            e++;\n        }\n    }\n    }\n}",
        "content": "# Intuition: Keep two pointer start and end at index 0 and 1 and follow three steps:\\n-> If element at start is 0 and end is non zero then swap them and move both pointers.\\n-> If element at both start and end is zero then move end pointer.\\n-> If both are non zeros then just move both pointers ahead till end reaches array length.   \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach: Two Pointer\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public void moveZeroes(int[] arr) {\\n    int n = arr.length;\\n    if(n<=1) return;\\n    int s=0;\\n    int e=1;\\n    while(e<n){\\n        if(arr[s]==0 && arr[e]!=0){\\n            int temp = arr[s];\\n            arr[s] = arr[e];\\n            arr[e] = temp;\\n            s++;\\n            e++;\\n        }else if(arr[s]==0 && arr[e]==0){\\n            e++;\\n        }else{\\n            s++;\\n            e++;\\n        }\\n    }\\n    }\\n}\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\n    public void moveZeroes(int[] arr) {\n    int n = arr.length;\n    if(n<=1) return;\n    int s=0;\n    int e=1;\n    while(e<n){\n        if(arr[s]=0 && arr[e]!=0){ \n            int temp = arr[s];\n            arr[s] = arr[e];\n            arr[e] = temp;\n            s++;\n            e++;\n        }else if(arr[s]==0 && arr[e]==0){\n            e++;\n        }else{\n            s++;\n            e++;\n        }\n    }\n    }\n}\n",
        "explanations": "\nUsed assignment operator (=) instead of comparison operator (==) in the if condition check.\n"
    },
    {
        "slug": "check-completeness-of-a-binary-tree",
        "description": "Given the root of a binary tree, determine if it is a complete binary tree.\nIn a complete binary tree, every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h.",
        "examples": [
            "Input: root = [1,2,3,4,5,6]\nOutput: true\nExplanation: Every level before the last is full (ie. levels with node-values {1} and {2, 3}), and all nodes in the last level ({4, 5, 6}) are as far left as possible.",
            "Input: root = [1,2,3,4,5,null,7]\nOutput: false\nExplanation: The node with value 7 isn't as far left as possible."
        ],
        "constraints": "The number of nodes in the tree is in the range [1, 100].\n1 <= Node.val <= 1000",
        "release_time": 1678844682,
        "oracle_code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public boolean isCompleteTree(TreeNode root) {\n        boolean end = false;\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.offer(root);\n        while(!queue.isEmpty()) {\n            TreeNode currentNode = queue.poll();\n            if(currentNode == null) {\n                end = true;\n            } else {\n                if(end) {\n                    return false;\n                }\n                queue.offer(currentNode.left);\n                queue.offer(currentNode.right);\n            }\n        }\n        return true;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        boolean end = false;\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.offer(root);\\n        while(!queue.isEmpty()) {\\n            TreeNode currentNode = queue.poll();\\n            if(currentNode == null) {\\n                end = true;\\n            } else {\\n                if(end) {\\n                    return false;\\n                }\\n                queue.offer(currentNode.left);\\n                queue.offer(currentNode.right);\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
        "level": "medium",
        "buggy_code": "\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public boolean isCompleteTree(TreeNode root) {\n        boolean end = false;\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.offer(root);\n        while(!queue.isEmpty()) {\n            TreeNode currentNode = queue.poll();\n            if(currentNode = null) {\n                end = true;\n            } else {\n                if(end) {\n                    return false;\n                }\n                queue.offer(currentNode.left);\n                queue.offer(currentNode.right);\n            }\n        }\n        return true;\n    }\n}\n",
        "explanations": "\nThe bug is in line \"if(currentNode = null)\" where assignment operator (=) is used instead of comparison operator (==).\n"
    },
    {
        "slug": "probability-of-a-two-boxes-having-the-same-number-of-distinct-balls",
        "description": "Given 2n balls of k distinct colors. You will be given an integer array balls of size k where balls[i] is the number of balls of color i.\nAll the balls will be shuffled uniformly at random, then we will distribute the first n balls to the first box and the remaining n balls to the other box (Please read the explanation of the second example carefully).\nPlease note that the two boxes are considered different. For example, if we have two balls of colors a and b, and two boxes [] and (), then the distribution [a] (b) is considered different than the distribution [b] (a) (Please read the explanation of the first example carefully).\nReturn the probability that the two boxes have the same number of distinct balls. Answers within 10-5 of the actual value will be accepted as correct.",
        "examples": [
            "Input: balls = [1,1]\nOutput: 1.00000\nExplanation: Only 2 ways to divide the balls equally:\n- A ball of color 1 to box 1 and a ball of color 2 to box 2\n- A ball of color 2 to box 1 and a ball of color 1 to box 2\nIn both ways, the number of distinct colors in each box is equal. The probability is 2/2 = 1",
            "Input: balls = [2,1,1]\nOutput: 0.66667\nExplanation: We have the set of balls [1, 1, 2, 3]\nThis set of balls will be shuffled randomly and we may have one of the 12 distinct shuffles with equal probability (i.e. 1/12):\n[1,1 / 2,3], [1,1 / 3,2], [1,2 / 1,3], [1,2 / 3,1], [1,3 / 1,2], [1,3 / 2,1], [2,1 / 1,3], [2,1 / 3,1], [2,3 / 1,1], [3,1 / 1,2], [3,1 / 2,1], [3,2 / 1,1]\nAfter that, we add the first two balls to the first box and the second two balls to the second box.\nWe can see that 8 of these 12 possible random distributions have the same number of distinct colors of balls in each box.\nProbability is 8/12 = 0.66667",
            "Input: balls = [1,2,1,2]\nOutput: 0.60000\nExplanation: The set of balls is [1, 2, 2, 3, 4, 4]. It is hard to display all the 180 possible random shuffles of this set but it is easy to check that 108 of them will have the same number of distinct colors in each box.\nProbability = 108 / 180 = 0.6"
        ],
        "constraints": "1 <= balls.length <= 8\n1 <= balls[i] <= 6\nsum(balls) is even.",
        "release_time": 1689418968,
        "oracle_code": "class Solution {\n    double possible = 0.0;\n    double valid = 0.0;\n    \n    public double getProbability(int[] balls) {\n        int[] first = new int[balls.length];\n        int[] second = new int[balls.length];\n        dfs(balls, first, second, 0, 0, 0);\n        return valid / possible;\n    }\n    \n    private void dfs(int[] balls, int[] first, int[] second, int num1, int num2, int idx) {\n        // finish all colors, check if this's a possible/valid distribution\n        if (idx == balls.length) {\n            // find one possible distribution\n            if (num1 == num2) {\n                // compute fake permutation\n                double distrib = permFake(first) * permFake(second);\n                possible += distrib;\n                \n                // find one valid distribution\n                if (unique(first) == unique(second)) {\n                    valid += distrib;\n                }\n            }\n            return;\n        }\n        \n        // distribute balls in current color to two bins\n        for (int b = 0; b <= balls[idx]; b++) {\n            first[idx] = b;\n            second[idx] = balls[idx] - b;\n            dfs (balls, first, second, num1 + first[idx], num2 + second[idx], idx + 1);\n        }\n    }\n    \n    // unique colors in \n    private int unique(int[] balls) {\n        int unique = 0;\n        for (int b: balls)\n            unique += b > 0 ? 1 : 0;\n        return unique;\n    }\n    \n    // return 1 / (b1!b2!b3!...bn!) \n    private double permFake(int[] balls) {\n        double ret = 1.0;\n        for (int b: balls)\n            ret /= factorial(b);\n        return ret;\n    }\n    \n    private int factorial(int n){\n        int ret = 1;\n        while (n > 0) {\n            ret *= n;\n            n--;\n        }\n        return ret;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    double possible = 0.0;\\n    double valid = 0.0;\\n    \\n    public double getProbability(int[] balls) {\\n        int[] first = new int[balls.length];\\n        int[] second = new int[balls.length];\\n        dfs(balls, first, second, 0, 0, 0);\\n        return valid / possible;\\n    }\\n    \\n    private void dfs(int[] balls, int[] first, int[] second, int num1, int num2, int idx) {\\n        // finish all colors, check if this\\'s a possible/valid distribution\\n        if (idx == balls.length) {\\n            // find one possible distribution\\n            if (num1 == num2) {\\n                // compute fake permutation\\n                double distrib = permFake(first) * permFake(second);\\n                possible += distrib;\\n                \\n                // find one valid distribution\\n                if (unique(first) == unique(second)) {\\n                    valid += distrib;\\n                }\\n            }\\n            return;\\n        }\\n        \\n        // distribute balls in current color to two bins\\n        for (int b = 0; b <= balls[idx]; b++) {\\n            first[idx] = b;\\n            second[idx] = balls[idx] - b;\\n            dfs (balls, first, second, num1 + first[idx], num2 + second[idx], idx + 1);\\n        }\\n    }\\n    \\n    // unique colors in \\n    private int unique(int[] balls) {\\n        int unique = 0;\\n        for (int b: balls)\\n            unique += b > 0 ? 1 : 0;\\n        return unique;\\n    }\\n    \\n    // return 1 / (b1!b2!b3!...bn!) \\n    private double permFake(int[] balls) {\\n        double ret = 1.0;\\n        for (int b: balls)\\n            ret /= factorial(b);\\n        return ret;\\n    }\\n    \\n    private int factorial(int n){\\n        int ret = 1;\\n        while (n > 0) {\\n            ret *= n;\\n            n--;\\n        }\\n        return ret;\\n    }\\n}\\n```",
        "level": "hard",
        "buggy_code": "\nclass Solution {\n    double possible = 0.0;\n    double valid = 0.0;\n    \n    public double getProbability(int[] balls) {\n        int[] first = new int[balls.length];\n        int[] second = new int[balls.length];\n        dfs(balls, first, second, 0, 0, 0);\n        return valid / possible;\n    }\n    \n    private void dfs(int[] balls, int[] first, int[] second, int num1, int num2, int idx) {\n        // finish all colors, check if this's a possible/valid distribution\n        if (idx == balls.length) {\n            // find one possible distribution\n            if (num1 = num2) {\n                // compute fake permutation\n                double distrib = permFake(first) * permFake(second);\n                possible += distrib;\n                \n                // find one valid distribution\n                if (unique(first) == unique(second)) {\n                    valid += distrib;\n                }\n            }\n            return;\n        }\n        \n        // distribute balls in current color to two bins\n        for (int b = 0; b <= balls[idx]; b++) {\n            first[idx] = b;\n            second[idx] = balls[idx] - b;\n            dfs (balls, first, second, num1 + first[idx], num2 + second[idx], idx + 1);\n        }\n    }\n    \n    // unique colors in \n    private int unique(int[] balls) {\n        int unique = 0;\n        for (int b: balls)\n            unique += b > 0 ? 1 : 0;\n        return unique;\n    }\n    \n    // return 1 / (b1!b2!b3!...bn!) \n    private double permFake(int[] balls) {\n        double ret = 1.0;\n        for (int b: balls)\n            ret /= factorial(b);\n        return ret;\n    }\n    \n    private int factorial(int n){\n        int ret = 1;\n        while (n > 0) {\n            ret *= n;\n            n--;\n        }\n        return ret;\n    }\n}\n",
        "explanations": "\nThe code 'if (num1 = num2)' will assign num2 to num1 instead of checking equality.\n"
    },
    {
        "slug": "max-area-of-island",
        "description": "You are given an m x n binary matrix grid. An island is a group of 1's (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.\nThe area of an island is the number of cells with a value 1 in the island.\nReturn the maximum area of an island in grid. If there is no island, return 0.",
        "examples": [
            "Input: grid = [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]\nOutput: 6\nExplanation: The answer is not 11, because the island must be connected 4-directionally.",
            "Input: grid = [[0,0,0,0,0,0,0,0]]\nOutput: 0"
        ],
        "constraints": "m == grid.length\nn == grid[i].length\n1 <= m, n <= 50\ngrid[i][j] is either 0 or 1.",
        "release_time": 1672631767,
        "oracle_code": "class Solution {\n    public int max = 0;\n    public int sum = 0;\n    public int maxAreaOfIsland(int[][] grid) {\n        for(int i = 0; i<grid.length;i++)\n        {\n            for(int j = 0; j<grid[i].length;j++)\n            {\n                if(grid[i][j]!=0)\n                {\n                    sum = 0; \n                    dfs(grid,i,j);\n                    max  = Math.max(max,sum);\n                }\n            }\n        }\n\n        return max;\n    }\n\n    private void dfs(int[][] grid ,int r ,int c)\n    {\n        if(r>=grid.length || c>=grid[0].length || r<0|| c<0 || grid[r][c]==0)\n        {\n            return ;\n        }\n\n        sum++;\n        grid[r][c] = 0;\n        dfs(grid,r,c+1);\n        dfs(grid,r,c-1);\n        dfs(grid,r+1,c);\n        dfs(grid,r-1,c);\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int max = 0;\\n    public int sum = 0;\\n    public int maxAreaOfIsland(int[][] grid) {\\n        for(int i = 0; i<grid.length;i++)\\n        {\\n            for(int j = 0; j<grid[i].length;j++)\\n            {\\n                if(grid[i][j]!=0)\\n                {\\n                    sum = 0; \\n                    dfs(grid,i,j);\\n                    max  = Math.max(max,sum);\\n                }\\n            }\\n        }\\n\\n        return max;\\n    }\\n\\n    private void dfs(int[][] grid ,int r ,int c)\\n    {\\n        if(r>=grid.length || c>=grid[0].length || r<0|| c<0 || grid[r][c]==0)\\n        {\\n            return ;\\n        }\\n\\n        sum++;\\n        grid[r][c] = 0;\\n        dfs(grid,r,c+1);\\n        dfs(grid,r,c-1);\\n        dfs(grid,r+1,c);\\n        dfs(grid,r-1,c);\\n    }\\n}\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\n    public int max = 0;\n    public int sum = 0;\n    public int maxAreaOfIsland(int[][] grid) {\n        for(int i = 0; i<grid.length;i++)\n        {\n            for(int j = 0; j<grid[i].length;j++)\n            {\n                if(grid[i][j] = 0)\n                {\n                    sum = 0; \n                    dfs(grid,i,j);\n                    max  = Math.max(max,sum);\n                }\n            }\n        }\n\n        return max;\n    }\n\n    private void dfs(int[][] grid ,int r ,int c)\n    {\n        if(r>=grid.length || c>=grid[0].length || r<0|| c<0 || grid[r][c]=0)\n        {\n            return ;\n        }\n\n        sum++;\n        grid[r][c] = 0;\n        dfs(grid,r,c+1);\n        dfs(grid,r,c-1);\n        dfs(grid,r+1,c);\n        dfs(grid,r-1,c);\n    }\n}\n",
        "explanations": "\nUsed = (assignment operator) instead of == (equality operator) in the if condition.\n"
    },
    {
        "slug": "trapping-rain-water",
        "description": "Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.",
        "examples": [
            "Input: height = [0,1,0,2,1,0,1,3,2,1,2,1]\nOutput: 6\nExplanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.",
            "Input: height = [4,2,0,3,2,5]\nOutput: 9"
        ],
        "constraints": "n == height.length\n1 <= n <= 2 * 104\n0 <= height[i] <= 105",
        "release_time": 1683960844,
        "oracle_code": "class Solution \n{\n    public int trap(int[] height) \n    {\n        int result = 0;\n        if(height==null || height.length<=2)\n            return result;\n        int left[] = new int[height.length];\n        int right[]= new int[height.length];\n        //scan from left to right\n        int max = height[0];\n        left[0] = height[0];\n        for(int i=1; i<height.length; i++)\n        {\n            if(height[i]<max)\n            {\n                left[i]=max;\n            }\n            else\n            {\n                left[i]=height[i];\n                max = height[i];\n            }\n        }\n        //scan from right to left\n        max = height[height.length-1];\n        right[height.length-1]=height[height.length-1];\n        for(int i=height.length-2; i>=0; i--)\n        {\n            if(height[i]<max)\n            {\n                right[i]=max;  \n            }\n            else\n            {  \n                right[i]=height[i];\n                max = height[i];\n            }\n        }\n    \n        for(int i=0; i<height.length; i++)\n        {\n            result+= Math.min(left[i],right[i])-height[i];\n        }\n        return result;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo calculate the trapped rainwater, we need to determine the effective height at each bar. The effective height at a specific bar is the minimum of the maximum heights on its left and right sides. The trapped rainwater can be calculated as the difference between the effective height and the actual height of each bar.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Check if the height array is null or has fewer than 2 elements. If so, return 0 since there are not enough bars to trap any rainwater.\\n2. Initialize a variable result to keep track of the total trapped rainwater.\\n3. Create two arrays, left and right, each with the same length as the height array. These arrays will store the maximum heights on the left and right sides of each bar, respectively.\\n4. Scan the height array from left to right:\\n- Initialize a variable max to store the maximum height encountered so far, starting with the height of the first bar.\\n- For each bar at index i, compare its height with the current max:\\n1. If the height of the current bar is less than the current max, set left[i] to max, indicating that the maximum height on the left side is still max.\\n1. Otherwise, update left[i] and max to the height of the current bar since it becomes the new maximum height encountered so far.\\n5. Scan the height array from right to left (similar to step 4) to populate the right array with the maximum heights on the right side of each bar.\\n6. Iterate over the height array:\\n- For each bar at index i, calculate the trapped rainwater by subtracting the actual height (height[i]) from the minimum of the maximum heights on the left and right sides (Math.min(left[i], right[i])).\\n- Add the calculated trapped rainwater to the result variable.\\n7. Return the final result which represents the total trapped rainwater.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the code is O(n), where n is the length of the height array. The code performs three separate scans over the height array, each taking linear time. Hence, the overall time complexity is linear.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the code is O(n), where n is the length of the height array. This is due to the additional arrays left and right that store the maximum heights on the left and right sides of each bar, respectively. The space required is proportional to the size of the input array.\\n\\n# Code\\n```\\nclass Solution \\n{\\n    public int trap(int[] height) \\n    {\\n        int result = 0;\\n        if(height==null || height.length<=2)\\n            return result;\\n        int left[] = new int[height.length];\\n        int right[]= new int[height.length];\\n        //scan from left to right\\n        int max = height[0];\\n        left[0] = height[0];\\n        for(int i=1; i<height.length; i++)\\n        {\\n            if(height[i]<max)\\n            {\\n                left[i]=max;\\n            }\\n            else\\n            {\\n                left[i]=height[i];\\n                max = height[i];\\n            }\\n        }\\n        //scan from right to left\\n        max = height[height.length-1];\\n        right[height.length-1]=height[height.length-1];\\n        for(int i=height.length-2; i>=0; i--)\\n        {\\n            if(height[i]<max)\\n            {\\n                right[i]=max;  \\n            }\\n            else\\n            {  \\n                right[i]=height[i];\\n                max = height[i];\\n            }\\n        }\\n    \\n        for(int i=0; i<height.length; i++)\\n        {\\n            result+= Math.min(left[i],right[i])-height[i];\\n        }\\n        return result;\\n    }\\n}\\n```",
        "level": "hard",
        "buggy_code": "\nclass Solution \n{\n    public int trap(int[] height) \n    {\n        int result = 0;\n        if(height = null || height.length<=2)\n            return result;\n        int left[] = new int[height.length];\n        int right[]= new int[height.length];\n        //scan from left to right\n        int max = height[0];\n        left[0] = height[0];\n        for(int i=1; i<height.length; i++)\n        {\n            if(height[i]<max)\n            {\n                left[i]=max;\n            }\n            else\n            {\n                left[i]=height[i];\n                max = height[i];\n            }\n        }\n        //scan from right to left\n        max = height[height.length-1];\n        right[height.length-1]=height[height.length-1];\n        for(int i=height.length-2; i>=0; i--)\n        {\n            if(height[i]<max)\n            {\n                right[i]=max;  \n            }\n            else\n            {  \n                right[i]=height[i];\n                max = height[i];\n            }\n        }\n    \n        for(int i=0; i<height.length; i++)\n        {\n            result+= Math.min(left[i],right[i])-height[i];\n        }\n        return result;\n    }\n}\n",
        "explanations": "\n= is an assignment operator, not a comparison operator. 'height = null' assigns null to height.\n"
    },
    {
        "slug": "airplane-seat-assignment-probability",
        "description": "n passengers board an airplane with exactly n seats. The first passenger has lost the ticket and picks a seat randomly. But after that, the rest of the passengers will:\n\nTake their own seat if it is still available, and\nPick other seats randomly when they find their seat occupied\n\nReturn the probability that the nth person gets his own seat.",
        "examples": [
            "Input: n = 1\nOutput: 1.00000\nExplanation: The first person can only get the first seat.",
            "Input: n = 2\nOutput: 0.50000\nExplanation: The second person has a probability of 0.5 to get the second seat (when first person gets the first seat)."
        ],
        "constraints": "1 <= n <= 105",
        "release_time": 1672300543,
        "oracle_code": "class Solution {\n    public double nthPersonGetsNthSeat(int n) {\n        if(n==1)\n        return 1.00000;\n        return 0.50000;\n    }\n}",
        "content": "\\n```\\nclass Solution {\\n    public double nthPersonGetsNthSeat(int n) {\\n        if(n==1)\\n        return 1.00000;\\n        return 0.50000;\\n    }\\n}\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\n    public double nthPersonGetsNthSeat(int n) {\n        if(n = 1)\n        return 1.00000;\n        return 0.50000;\n    }\n}\n",
        "explanations": "\nThe \"if(n = 1)\" is an assignment instead of a comparison resulting in a compilation error.\n"
    },
    {
        "slug": "neighboring-bitwise-xor",
        "description": "A 0-indexed array derived with length n is derived by computing the bitwise XOR\u00a0(\u2295) of adjacent values in a binary array original of length n.\nSpecifically, for each index i in the range [0, n - 1]:\n\nIf i = n - 1, then derived[i] = original[i] \u2295 original[0].\nOtherwise, derived[i] = original[i] \u2295 original[i + 1].\n\nGiven an array derived, your task is to determine whether there exists a valid binary array original that could have formed derived.\nReturn true if such an array exists or false otherwise.\n\nA binary array is an array containing only 0's and 1's",
        "examples": [
            "Input: derived = [1,1,0]\nOutput: true\nExplanation: A valid original array that gives derived is [0,1,0].\nderived[0] = original[0] \u2295 original[1] = 0 \u2295 1 = 1 \nderived[1] = original[1] \u2295 original[2] = 1 \u2295 0 = 1\nderived[2] = original[2] \u2295 original[0] = 0 \u2295 0 = 0",
            "Input: derived = [1,1]\nOutput: true\nExplanation: A valid original array that gives derived is [0,1].\nderived[0] = original[0] \u2295 original[1] = 1\nderived[1] = original[1] \u2295 original[0] = 1",
            "Input: derived = [1,0]\nOutput: false\nExplanation: There is no valid original array that gives derived."
        ],
        "constraints": "n == derived.length\n1 <= n\u00a0<= 105\nThe values in derived\u00a0are either 0's or 1's",
        "release_time": 1684037017,
        "oracle_code": "class Solution {\n    public boolean doesValidArrayExist(int[] de) {\n        int ans=0;\n        for(int a:de){\n            if(a==1)\n                ans++;\n        }\n        return (ans%2==0);\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] de) {\\n        int ans=0;\\n        for(int a:de){\\n            if(a==1)\\n                ans++;\\n        }\\n        return (ans%2==0);\\n    }\\n}\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\n    public boolean doesValidArrayExist(int[] de) {\n        int ans=0;\n        for(int a:de){\n            if(a=1)\n                ans++;\n        }\n        return (ans%2==0);\n    }\n}\n",
        "explanations": "\nUsing the assignment operator (=) in the if condition instead of the equality operator (==).\n"
    },
    {
        "slug": "relative-sort-array",
        "description": "Given two arrays arr1 and arr2, the elements of arr2 are distinct, and all elements in arr2 are also in arr1.\nSort the elements of arr1 such that the relative ordering of items in arr1 are the same as in arr2. Elements that do not appear in arr2 should be placed at the end of arr1 in ascending order.",
        "examples": [
            "Input: arr1 = [2,3,1,3,2,4,6,7,9,2,19], arr2 = [2,1,4,3,9,6]\nOutput: [2,2,2,1,4,3,3,9,6,7,19]",
            "Input: arr1 = [28,6,22,8,44,17], arr2 = [22,28,8,6]\nOutput: [22,28,8,6,17,44]"
        ],
        "constraints": "1 <= arr1.length, arr2.length <= 1000\n0 <= arr1[i], arr2[i] <= 1000\nAll the elements of arr2 are distinct.\nEach\u00a0arr2[i] is in arr1.",
        "release_time": 1691725804,
        "oracle_code": "import java.util.Arrays;\n\nclass Solution {\n    public int[] relativeSortArray(int[] arr1, int[] arr2) {\n        Arrays.sort(arr1);\n        int[] ans = new int[arr1.length];\n        int start = 0;\n        int end = arr1.length - 1;\n        int index = 0;\n\n        for (int i = 0; i < arr2.length; i++) {\n            int target = arr2[i];\n            start = 0;\n            end = arr1.length - 1;\n\n            while (end >= start) {\n                int mid = start + (end - start) / 2;\n                if (arr1[mid] == target) {\n                    for (int j = start; j <= end; j++) {\n                        if (arr1[j] == target) {\n                            ans[index++] = arr1[j];\n                        }\n                    }\n                    break;\n                }\n                if (arr1[mid] < target) {\n                    start = mid + 1;\n                } else {\n                    end = mid - 1;\n                }\n            }\n        }\n\n        for (int i = 0; i < arr1.length; i++) {\n            if (index == arr1.length) {\n                break;\n            }\n            boolean found = false;\n            for (int num : arr2) {\n                if (arr1[i] == num) {\n                    found = true;\n                    break;\n                }\n            }\n            if (!found) {\n                ans[index++] = arr1[i];\n            }\n        }\n\n        return ans;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.util.Arrays;\\n\\nclass Solution {\\n    public int[] relativeSortArray(int[] arr1, int[] arr2) {\\n        Arrays.sort(arr1);\\n        int[] ans = new int[arr1.length];\\n        int start = 0;\\n        int end = arr1.length - 1;\\n        int index = 0;\\n\\n        for (int i = 0; i < arr2.length; i++) {\\n            int target = arr2[i];\\n            start = 0;\\n            end = arr1.length - 1;\\n\\n            while (end >= start) {\\n                int mid = start + (end - start) / 2;\\n                if (arr1[mid] == target) {\\n                    for (int j = start; j <= end; j++) {\\n                        if (arr1[j] == target) {\\n                            ans[index++] = arr1[j];\\n                        }\\n                    }\\n                    break;\\n                }\\n                if (arr1[mid] < target) {\\n                    start = mid + 1;\\n                } else {\\n                    end = mid - 1;\\n                }\\n            }\\n        }\\n\\n        for (int i = 0; i < arr1.length; i++) {\\n            if (index == arr1.length) {\\n                break;\\n            }\\n            boolean found = false;\\n            for (int num : arr2) {\\n                if (arr1[i] == num) {\\n                    found = true;\\n                    break;\\n                }\\n            }\\n            if (!found) {\\n                ans[index++] = arr1[i];\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n\\n```",
        "level": "easy",
        "buggy_code": "\nimport java.util.Arrays;\n\nclass Solution {\n    public int[] relativeSortArray(int[] arr1, int[] arr2) {\n        Arrays.sort(arr1);\n        int[] ans = new int[arr1.length];\n        int start = 0;\n        int end = arr1.length - 1;\n        int index = 0;\n\n        for (int i = 0; i < arr2.length; i++) {\n            int target = arr2[i];\n            start = 0;\n            end = arr1.length - 1;\n\n            while (end >= start) {\n                int mid = start + (end - start) / 2;\n                if (arr1[mid] = target) {\n                    for (int j = start; j <= end; j++) {\n                        if (arr1[j] == target) {\n                            ans[index++] = arr1[j];\n                        }\n                    }\n                    break;\n                }\n                if (arr1[mid] < target) {\n                    start = mid + 1;\n                } else {\n                    end = mid - 1;\n                }\n            }\n        }\n\n        for (int i = 0; i < arr1.length; i++) {\n            if (index == arr1.length) {\n                break;\n            }\n            boolean found = false;\n            for (int num : arr2) {\n                if (arr1[i] = num) {\n                    found = true;\n                    break;\n                }\n            }\n            if (!found) {\n                ans[index++] = arr1[i];\n            }\n        }\n\n        return ans;\n    }\n}\n",
        "explanations": "\nThe comparison operator '==' is mistakenly replaced with the assignment operator '=' twice.\n"
    },
    {
        "slug": "check-if-binary-string-has-at-most-one-segment-of-ones",
        "description": "Given a binary string s \u200b\u200b\u200b\u200b\u200bwithout leading zeros, return true\u200b\u200b\u200b if s contains at most one contiguous segment of ones. Otherwise, return false.",
        "examples": [
            "Input: s = \"1001\"\nOutput: false\nExplanation: The ones do not form a contiguous segment.",
            "Input: s = \"110\"\nOutput: true"
        ],
        "constraints": "1 <= s.length <= 100\ns[i]\u200b\u200b\u200b\u200b is either '0' or '1'.\ns[0] is\u00a0'1'.",
        "release_time": 1691762677,
        "oracle_code": "class Solution {\n    public boolean checkOnesSegment(String s) {\n        int count=0;\n       int pos=0;\n       while(s.charAt(pos)!='1'){\n              pos++;\n            if(pos==s.length()){\n                return true;\n            }\n          }\n       \n       for(int i=pos;i<s.length();i++){\n          if(s.charAt(i)=='0'){\n              count++;\n          }\n          else if(count>0&&s.charAt(i)=='1'){\n              return false;\n          }\n       } \n       return true;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkOnesSegment(String s) {\\n        int count=0;\\n       int pos=0;\\n       while(s.charAt(pos)!=\\'1\\'){\\n              pos++;\\n            if(pos==s.length()){\\n                return true;\\n            }\\n          }\\n       \\n       for(int i=pos;i<s.length();i++){\\n          if(s.charAt(i)==\\'0\\'){\\n              count++;\\n          }\\n          else if(count>0&&s.charAt(i)==\\'1\\'){\\n              return false;\\n          }\\n       } \\n       return true;\\n    }\\n}\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\n    public boolean checkOnesSegment(String s) {\n        int count=0;\n        int pos=0;\n        while(s.charAt(pos)!='1'){\n            pos++;\n            if(pos=s.length()){\n                return true;\n            }\n        }\n   \n        for(int i=pos;i<s.length();i++){\n          if(s.charAt(i)=='0'){\n              count++;\n          }\n          else if(count>0&&s.charAt(i)=='1'){\n              return false;\n          }\n        } \n       \n        return true;\n    }\n}\n",
        "explanations": "\nThe bug is in pos=s.length(); where it should be pos==s.length(). '=' is assignment and '==' is to check equality.\n"
    }
]