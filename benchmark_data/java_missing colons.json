[
    {
        "slug": "similar-string-groups",
        "description": "Two strings, X and Y, are considered similar if either they are identical or we can make them equivalent by swapping at most two letters (in distinct positions) within the string X.\nFor example, \"tars\"\u00a0and \"rats\"\u00a0are similar (swapping at positions 0 and 2), and \"rats\" and \"arts\" are similar, but \"star\" is not similar to \"tars\", \"rats\", or \"arts\".\nTogether, these form two connected groups by similarity: {\"tars\", \"rats\", \"arts\"} and {\"star\"}.\u00a0 Notice that \"tars\" and \"arts\" are in the same group even though they are not similar.\u00a0 Formally, each group is such that a word is in the group if and only if it is similar to at least one other word in the group.\nWe are given a list strs of strings where every string in strs is an anagram of every other string in strs. How many groups are there?",
        "examples": [
            "Input: strs = [\"tars\",\"rats\",\"arts\",\"star\"]\nOutput: 2",
            "Input: strs = [\"omv\",\"ovm\"]\nOutput: 1"
        ],
        "constraints": "1 <= strs.length <= 300\n1 <= strs[i].length <= 300\nstrs[i] consists of lowercase letters only.\nAll words in strs have the same length and are anagrams of each other.",
        "release_time": 1682695025,
        "oracle_code": "class Solution {\n    boolean isSimilar(String str1,String str2)\n    {\n        int count=0;\n        for(int i=0;i<str1.length();i++)\n        {\n            if(str1.charAt(i)!=str2.charAt(i))\n            {\n                count++;\n                if(count>2)\n                {\n                    return false;\n                }\n            }\n            \n        }\n        return count==0 || count==2;\n    }\n    void dfs(String curr, String []strs, Set<String> visited)\n    {\n        //base condition\n        if(visited.contains(curr))\n        {\n            return;\n        }\n        visited.add(curr);\n        for(int i=0;i<strs.length;i++)\n        {\n         if(isSimilar(curr,strs[i]))\n         {\n             dfs(strs[i],strs,visited);\n         }   \n        }\n    }\n    public int numSimilarGroups(String[] strs)\n    {\n        int count =0;\n\n        //Base condition\n        if(strs==null ||strs.length ==0)\n        {\n            return 0;\n        }\n\n        //now create a set for visited elements which are similar\n        Set<String> visited = new HashSet<>();\n        for(String s:strs)\n        {\n            if(!visited.contains(s))\n            {\n                dfs(s,strs,visited);\n                count++;\n            }\n        }\n        return count;\n    }\n}",
        "content": "# Intuition\\n![WhatsApp_Image_2023-04-28_at_8.43.47_PM\\\\[1\\\\].jpeg](https://assets.leetcode.com/users/images/fade8110-e5ae-4339-8e4e-a041ca1adfa6_1682695005.1794102.jpeg)\\n![WhatsApp_Image_2023-04-28_at_8.44.14_PM\\\\[1\\\\].jpeg](https://assets.leetcode.com/users/images/bd87a21d-7162-4964-af6b-19a3bc4e3649_1682695016.060982.jpeg)\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    boolean isSimilar(String str1,String str2)\\n    {\\n        int count=0;\\n        for(int i=0;i<str1.length();i++)\\n        {\\n            if(str1.charAt(i)!=str2.charAt(i))\\n            {\\n                count++;\\n                if(count>2)\\n                {\\n                    return false;\\n                }\\n            }\\n            \\n        }\\n        return count==0 || count==2;\\n    }\\n    void dfs(String curr, String []strs, Set<String> visited)\\n    {\\n        //base condition\\n        if(visited.contains(curr))\\n        {\\n            return;\\n        }\\n        visited.add(curr);\\n        for(int i=0;i<strs.length;i++)\\n        {\\n         if(isSimilar(curr,strs[i]))\\n         {\\n             dfs(strs[i],strs,visited);\\n         }   \\n        }\\n    }\\n    public int numSimilarGroups(String[] strs)\\n    {\\n        int count =0;\\n\\n        //Base condition\\n        if(strs==null ||strs.length ==0)\\n        {\\n            return 0;\\n        }\\n\\n        //now create a set for visited elements which are similar\\n        Set<String> visited = new HashSet<>();\\n        for(String s:strs)\\n        {\\n            if(!visited.contains(s))\\n            {\\n                dfs(s,strs,visited);\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
        "level": "hard",
        "buggy_code": "\nclass Solution {\n    boolean isSimilar(String str1,String str2)\n    {\n        int count=0;\n        for(int i=0;i<str1.length();i++)\n        {\n            if(str1.charAt(i)!=str2.charAt(i))\n            {\n                count++;\n                if(count>2)\n                {\n                    return false\n                }\n            }\n            \n        }\n        return count==0 || count==2;\n    }\n    void dfs(String curr, String []strs, Set<String> visited)\n    {\n        //base condition\n        if(visited.contains(curr))\n        {\n            return;\n        }\n        visited.add(curr);\n        for(int i=0;i<strs.length;i++)\n        {\n         if(isSimilar(curr,strs[i]))\n         {\n             dfs(strs[i],strs,visited);\n         }   \n        }\n    }\n    public int numSimilarGroups(String[] strs)\n    {\n        int count =0;\n\n        //Base condition\n        if(strs==null ||strs.length ==0)\n        {\n            return 0;\n        }\n\n        //now create a set for visited elements which are similar\n        Set<String> visited = new HashSet<>();\n        for(String s:strs)\n        {\n            if(!visited.contains(s))\n            {\n                dfs(s,strs,visited);\n                count++;\n            }\n        }\n        return count;\n    }\n}\n",
        "explanations": "\nMissing semicolon after return false in isSimilar function causing a compile error.\n"
    },
    {
        "slug": "earliest-possible-day-of-full-bloom",
        "description": "You have n flower seeds. Every seed must be planted first before it can begin to grow, then bloom. Planting a seed takes time and so does the growth of a seed. You are given two 0-indexed integer arrays plantTime and growTime, of length n each:\n\nplantTime[i] is the number of full days it takes you to plant the ith seed. Every day, you can work on planting exactly one seed. You do not have to work on planting the same seed on consecutive days, but the planting of a seed is not complete until you have worked plantTime[i] days on planting it in total.\ngrowTime[i] is the number of full days it takes the ith seed to grow after being completely planted. After the last day of its growth, the flower blooms and stays bloomed forever.\n\nFrom the beginning of day 0, you can plant the seeds in any order.\nReturn the earliest possible day where all seeds are blooming.",
        "examples": [
            "Input: plantTime = [1,4,3], growTime = [2,3,1]\nOutput: 9\nExplanation: The grayed out pots represent planting days, colored pots represent growing days, and the flower represents the day it blooms.\nOne optimal way is:\nOn day 0, plant the 0th seed. The seed grows for 2 full days and blooms on day 3.\nOn days 1, 2, 3, and 4, plant the 1st seed. The seed grows for 3 full days and blooms on day 8.\nOn days 5, 6, and 7, plant the 2nd seed. The seed grows for 1 full day and blooms on day 9.\nThus, on day 9, all the seeds are blooming.",
            "Input: plantTime = [1,2,3,2], growTime = [2,1,2,1]\nOutput: 9\nExplanation: The grayed out pots represent planting days, colored pots represent growing days, and the flower represents the day it blooms.\nOne optimal way is:\nOn day 1, plant the 0th seed. The seed grows for 2 full days and blooms on day 4.\nOn days 0 and 3, plant the 1st seed. The seed grows for 1 full day and blooms on day 5.\nOn days 2, 4, and 5, plant the 2nd seed. The seed grows for 2 full days and blooms on day 8.\nOn days 6 and 7, plant the 3rd seed. The seed grows for 1 full day and blooms on day 9.\nThus, on day 9, all the seeds are blooming.",
            "Input: plantTime = [1], growTime = [1]\nOutput: 2\nExplanation: On day 0, plant the 0th seed. The seed grows for 1 full day and blooms on day 2.\nThus, on day 2, all the seeds are blooming."
        ],
        "constraints": "n == plantTime.length == growTime.length\n1 <= n <= 105\n1 <= plantTime[i], growTime[i] <= 104",
        "release_time": 1677868965,
        "oracle_code": "class Solution {\n    public int earliestFullBloom(int[] plantTime, int[] growTime) {\n       int max = 0;\n       for (int i : growTime){\n           if(max < i){\n               max = i;\n           }\n       }\n\n       int len = max;\n       int[] arr = new int[len + 1];\n       int tmp = 0;\n       int minTime = 0;\n       \n       for (int i = 0; i < plantTime.length; i++) {\n           arr[growTime[i]] += plantTime[i];\n       }\n\n       for (int i = len; i > 0; i--) {\n            if (arr[i] != 0) {\n                tmp = tmp + arr[i];\n                minTime = Math.max(minTime, tmp + i);\n            }\n       }\n\n       return minTime;\n    }\n}",
        "content": "![image.png](https://assets.leetcode.com/users/images/98855a88-cdb5-4c6f-ba41-3ba577588b51_1678010575.6496518.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int earliestFullBloom(int[] plantTime, int[] growTime) {\\n       int max = 0;\\n       for (int i : growTime){\\n           if(max < i){\\n               max = i;\\n           }\\n       }\\n\\n       int len = max;\\n       int[] arr = new int[len + 1];\\n       int tmp = 0;\\n       int minTime = 0;\\n       \\n       for (int i = 0; i < plantTime.length; i++) {\\n           arr[growTime[i]] += plantTime[i];\\n       }\\n\\n       for (int i = len; i > 0; i--) {\\n            if (arr[i] != 0) {\\n                tmp = tmp + arr[i];\\n                minTime = Math.max(minTime, tmp + i);\\n            }\\n       }\\n\\n       return minTime;\\n    }\\n}\\n\\n\\n```",
        "level": "hard",
        "buggy_code": "\nclass Solution {\n    public int earliestFullBloom(int[] plantTime, int[] growTime) {\n       int max = 0\n       for (int i : growTime){\n           if(max < i){\n               max = i;\n           }\n       }\n\n       int len = max;\n       int[] arr = new int[len + 1];\n       int tmp = 0;\n       int minTime = 0;\n       \n       for (int i = 0; i < plantTime.length; i++) {\n           arr[growTime[i]] += plantTime[i];\n       }\n\n       for (int i = len; i > 0; i--) {\n            if (arr[i] != 0) {\n                tmp = tmp + arr[i];\n                minTime = Math.max(minTime, tmp + i);\n            }\n       }\n\n       return minTime;\n    }\n}\n",
        "explanations": "\nMissing semicolon at the end of line assigning value to max variable causing a syntax error.\n"
    },
    {
        "slug": "jump-game-iv",
        "description": "Given an array of\u00a0integers arr, you are initially positioned at the first index of the array.\nIn one step you can jump from index i to index:\n\ni + 1 where:\u00a0i + 1 < arr.length.\ni - 1 where:\u00a0i - 1 >= 0.\nj where: arr[i] == arr[j] and i != j.\n\nReturn the minimum number of steps to reach the last index of the array.\nNotice that you can not jump outside of the array at any time.",
        "examples": [
            "Input: arr = [100,-23,-23,404,100,23,23,23,3,404]\nOutput: 3\nExplanation: You need three jumps from index 0 --> 4 --> 3 --> 9. Note that index 9 is the last index of the array.",
            "Input: arr = [7]\nOutput: 0\nExplanation: Start index is the last index. You do not need to jump.",
            "Input: arr = [7,6,9,6,9,6,9,7]\nOutput: 1\nExplanation: You can jump directly from index 0 to index 7 which is last index of the array."
        ],
        "constraints": "1 <= arr.length <= 5 * 104\n-108 <= arr[i] <= 108",
        "release_time": 1677998298,
        "oracle_code": "class Solution {\n    public int minJumps(int[] arr) {\n        Map<Integer,ArrayList<Integer>>hm=new HashMap<>();\n        for(int i=0;i<arr.length;i++){\n            if(hm.containsKey(arr[i])){\n                ArrayList<Integer>al=hm.get(arr[i]);\n                al.add(i);\n                hm.put(arr[i],al);\n            }\n            else{\n                ArrayList<Integer>al=new ArrayList<>();\n                al.add(i);\n                hm.put(arr[i],al);\n            }\n        }\n        boolean vis[]=new boolean[arr.length];\n        Queue<Integer>q=new LinkedList<>();\n        q.add(0);\n        int cnt=0;\n        while(!q.isEmpty()){\n            for(int k=q.size();k>0;k--){\n                int n=q.remove();\n                vis[n]=true;\n                if(n==arr.length-1) return cnt;\n                ArrayList<Integer>al=hm.get(arr[n]);\n                al.add(n-1);\n                al.add(n+1);\n                for(int i:al){\n                    if(i>=0&&i<arr.length&&!vis[i]){\n                        q.add(i);\n                    }\n                }\n                al.clear();\n            }\n            cnt++;\n        }\n        return 0;\n    }\n}",
        "content": "# Code\\n```\\nclass Solution {\\n    public int minJumps(int[] arr) {\\n        Map<Integer,ArrayList<Integer>>hm=new HashMap<>();\\n        for(int i=0;i<arr.length;i++){\\n            if(hm.containsKey(arr[i])){\\n                ArrayList<Integer>al=hm.get(arr[i]);\\n                al.add(i);\\n                hm.put(arr[i],al);\\n            }\\n            else{\\n                ArrayList<Integer>al=new ArrayList<>();\\n                al.add(i);\\n                hm.put(arr[i],al);\\n            }\\n        }\\n        boolean vis[]=new boolean[arr.length];\\n        Queue<Integer>q=new LinkedList<>();\\n        q.add(0);\\n        int cnt=0;\\n        while(!q.isEmpty()){\\n            for(int k=q.size();k>0;k--){\\n                int n=q.remove();\\n                vis[n]=true;\\n                if(n==arr.length-1) return cnt;\\n                ArrayList<Integer>al=hm.get(arr[n]);\\n                al.add(n-1);\\n                al.add(n+1);\\n                for(int i:al){\\n                    if(i>=0&&i<arr.length&&!vis[i]){\\n                        q.add(i);\\n                    }\\n                }\\n                al.clear();\\n            }\\n            cnt++;\\n        }\\n        return 0;\\n    }\\n}\\n```\\nUPVOTE IF U LIKE THE APPROACH",
        "level": "hard",
        "buggy_code": "\nclass Solution {\n    public int minJumps(int[] arr) {\n        Map<Integer,ArrayList<Integer>>hm=new HashMap<>();\n        for(int i=0;i<arr.length;i++){\n            if(hm.containsKey(arr[i])){\n                ArrayList<Integer>al=hm.get(arr[i]);\n                al.add(i);\n                hm.put(arr[i],al)\n            }\n            else{\n                ArrayList<Integer>al=new ArrayList<>();\n                al.add(i);\n                hm.put(arr[i],al);\n            }\n        }\n        boolean vis[]=new boolean[arr.length];\n        Queue<Integer>q=new LinkedList<>();\n        q.add(0);\n        int cnt=0;\n        while(!q.isEmpty()){\n            for(int k=q.size();k>0;k--){\n                int n=q.remove();\n                vis[n]=true;\n                if(n==arr.length-1) return cnt;\n                ArrayList<Integer>al=hm.get(arr[n]);\n                al.add(n-1);\n                al.add(n+1);\n                for(int i:al){\n                    if(i>=0&&i<arr.length&&!vis[i]){\n                        q.add(i);\n                    }\n                }\n                al.clear();\n            }\n            cnt++;\n        }\n        return 0;\n    }\n}\n",
        "explanations": "\nMissing semicolon at the end of the statement where a value is put into the hashmap.\n"
    },
    {
        "slug": "maximum-average-pass-ratio",
        "description": "There is a school that has classes of students and each class will be having a final exam. You are given a 2D integer array classes, where classes[i] = [passi, totali]. You know beforehand that in the ith class, there are totali total students, but only passi number of students will pass the exam.\nYou are also given an integer extraStudents. There are another extraStudents brilliant students that are guaranteed to pass the exam of any class they are assigned to. You want to assign each of the extraStudents students to a class in a way that maximizes the average pass ratio across all the classes.\nThe pass ratio of a class is equal to the number of students of the class that will pass the exam divided by the total number of students of the class. The average pass ratio is the sum of pass ratios of all the classes divided by the number of the classes.\nReturn the maximum possible average pass ratio after assigning the extraStudents students. Answers within 10-5 of the actual answer will be accepted.",
        "examples": [
            "Input: classes = [[1,2],[3,5],[2,2]], extraStudents = 2\nOutput: 0.78333\nExplanation: You can assign the two extra students to the first class. The average pass ratio will be equal to (3/4 + 3/5 + 2/2) / 3 = 0.78333.",
            "Input: classes = [[2,4],[3,9],[4,5],[2,10]], extraStudents = 4\nOutput: 0.53485"
        ],
        "constraints": "1 <= classes.length <= 105\nclasses[i].length == 2\n1 <= passi <= totali <= 105\n1 <= extraStudents <= 105",
        "release_time": 1675841173,
        "oracle_code": "class Solution {\n    public double maxAverageRatio(int[][] classes, int extraStudents) {\n        PriorityQueue<Class> pq = new PriorityQueue<>(new Compare());\n        for(int[] cl : classes){\n            pq.add(new Class(cl));\n        }\n        while(extraStudents > 0){\n            Class c = pq.remove();\n            c.addExtraStudent();\n            extraStudents--;\n            pq.add(c);\n        }\n        double sum = 0;\n        while(!pq.isEmpty()){\n            Class c = pq.remove();\n            sum += c.pass / c.total;\n        }\n        return sum / classes.length;\n    }\n}\nclass Class{\n    double pass;\n    double total;\n    double inc;\n    public Class(int[] cl){\n        pass = cl[0];\n        total = cl[1];\n        inc = (pass + 1) / (total + 1) - pass / total;\n    }\n    public void addExtraStudent(){\n        pass += 1;\n        total += 1;\n        inc = (pass + 1) / (total + 1) - pass / total;\n    }\n}\nclass Compare implements Comparator<Class>{\n    public int compare(Class c1, Class c2){\n        if(c1.inc < c2.inc){\n            return 1;\n        }else if(c1.inc > c2.inc){\n            return -1;\n        }else{\n            return 0;\n        }\n    }\n}",
        "content": "\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public double maxAverageRatio(int[][] classes, int extraStudents) {\\n        PriorityQueue<Class> pq = new PriorityQueue<>(new Compare());\\n        for(int[] cl : classes){\\n            pq.add(new Class(cl));\\n        }\\n        while(extraStudents > 0){\\n            Class c = pq.remove();\\n            c.addExtraStudent();\\n            extraStudents--;\\n            pq.add(c);\\n        }\\n        double sum = 0;\\n        while(!pq.isEmpty()){\\n            Class c = pq.remove();\\n            sum += c.pass / c.total;\\n        }\\n        return sum / classes.length;\\n    }\\n}\\nclass Class{\\n    double pass;\\n    double total;\\n    double inc;\\n    public Class(int[] cl){\\n        pass = cl[0];\\n        total = cl[1];\\n        inc = (pass + 1) / (total + 1) - pass / total;\\n    }\\n    public void addExtraStudent(){\\n        pass += 1;\\n        total += 1;\\n        inc = (pass + 1) / (total + 1) - pass / total;\\n    }\\n}\\nclass Compare implements Comparator<Class>{\\n    public int compare(Class c1, Class c2){\\n        if(c1.inc < c2.inc){\\n            return 1;\\n        }else if(c1.inc > c2.inc){\\n            return -1;\\n        }else{\\n            return 0;\\n        }\\n    }\\n}\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\n    public double maxAverageRatio(int[][] classes, int extraStudents) {\n        PriorityQueue<Class> pq = new PriorityQueue<>(new Compare());\n        for(int[] cl : classes){\n            pq.add(new Class(cl));\n        }\n        while(extraStudents > 0){\n            Class c = pq.remove();\n            c.addExtraStudent()\n            extraStudents--;\n            pq.add(c);\n        }\n        double sum = 0;\n        while(!pq.isEmpty()){\n            Class c = pq.remove();\n            sum += c.pass / c.total;\n        }\n        return sum / classes.length;\n    }\n}\nclass Class{\n    double pass;\n    double total;\n    double inc;\n    public Class(int[] cl){\n        pass = cl[0];\n        total = cl[1];\n        inc = (pass + 1) / (total + 1) - pass / total;\n    }\n    public void addExtraStudent(){\n        pass += 1;\n        total += 1;\n        inc = (pass + 1) / (total + 1) - pass / total;\n    }\n}\nclass Compare implements Comparator<Class>{\n    public int compare(Class c1, Class c2){\n        if(c1.inc < c2.inc){\n            return 1;\n        }else if(c1.inc > c2.inc){\n            return -1;\n        }else{\n            return 0;\n        }\n    }\n}\n",
        "explanations": "\nMissed semi-colon at the end of c.addExtraStudent() inside while loop causing syntax error.\n"
    },
    {
        "slug": "count-negative-numbers-in-a-sorted-matrix",
        "description": "Given a m x n matrix grid which is sorted in non-increasing order both row-wise and column-wise, return the number of negative numbers in grid.",
        "examples": [
            "Input: grid = [[4,3,2,-1],[3,2,1,-1],[1,1,-1,-2],[-1,-1,-2,-3]]\nOutput: 8\nExplanation: There are 8 negatives number in the matrix.",
            "Input: grid = [[3,2],[1,0]]\nOutput: 0"
        ],
        "constraints": "m == grid.length\nn == grid[i].length\n1 <= m, n <= 100\n-100 <= grid[i][j] <= 100",
        "release_time": 1686193447,
        "oracle_code": "class Solution:\n    def countNegatives(self, grid: List[List[int]]) -> int:\n        ROWS, COLS = len(grid), len(grid[0])\n        negatives = 0\n        col = 0\n        for row in range(ROWS - 1, -1, -1):\n            while col < COLS and grid[row][col] >= 0:\n                col += 1\n            negatives += COLS - col\n        return negatives",
        "content": "# Intuition\\nThe key idea is to take advantage of the sorted nature of the matrix, where both the rows and columns are sorted in non-increasing order. This means that once we find a negative number in a row, all the following numbers in that row will also be negative. Similarly, if a cell at the top of a column is negative, all the cells below it in that column will also be negative.\\n\\n# Approach\\nNegative numbers will form a staircase. So we start from the bottom-left, and follow along the staircase. For each row, we find the edge of the staircase, add all the count of elements to the right to the answer, and then move up a row and repeat.\\n\\n# Complexity\\n- Time complexity: O(m + n) - We visit each row and column at most once.\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def countNegatives(self, grid: List[List[int]]) -> int:\\n        ROWS, COLS = len(grid), len(grid[0])\\n        negatives = 0\\n        col = 0\\n        for row in range(ROWS - 1, -1, -1):\\n            while col < COLS and grid[row][col] >= 0:\\n                col += 1\\n            negatives += COLS - col\\n        return negatives\\n\\n```\\n\\n# Get Faster Interview Prep Results with Top Algos\\nWe all know how time-consuming it is to prepare for interviews and how frustratingly difficult it is to improve. We made **Top Algos** - a tool recommends the perfect algorithm problem based on your current skill level to help you improve the fastest in the shortest amount of time. Top Algos is your personalized coach that learns your skill level and finds the best problem you need to solve to improve.\\n\\nThe beta version of the product is available for **free** right now! You can sign up at https://topalgos.xyz/.",
        "level": "easy",
        "buggy_code": "\nclass Solution:\n    def countNegatives(self, grid: List[List[int]]) -> int:\n        ROWS, COLS = len(grid), len(grid[0])\n        negatives = 0\n        for row in range(ROWS - 1, -1, -1):\n            col = 0\n            while col < COLS and grid[row][col] >= 0:\n                col += 1\n            negatives += COLS - col\n        return negatives\n",
        "explanations": "\nThe 'col' variable is not reset to 0 at the start of each row iteration.\n"
    },
    {
        "slug": "largest-number-after-digit-swaps-by-parity",
        "description": "You are given a positive integer num. You may swap any two digits of num that have the same parity (i.e. both odd digits or both even digits).\nReturn the largest possible value of num after any number of swaps.",
        "examples": [
            "Input: num = 1234\nOutput: 3412\nExplanation: Swap the digit 3 with the digit 1, this results in the number 3214.\nSwap the digit 2 with the digit 4, this results in the number 3412.\nNote that there may be other sequences of swaps but it can be shown that 3412 is the largest possible number.\nAlso note that we may not swap the digit 4 with the digit 1 since they are of different parities.",
            "Input: num = 65875\nOutput: 87655\nExplanation: Swap the digit 8 with the digit 6, this results in the number 85675.\nSwap the first digit 5 with the digit 7, this results in the number 87655.\nNote that there may be other sequences of swaps but it can be shown that 87655 is the largest possible number."
        ],
        "constraints": "1 <= num <= 109",
        "release_time": 1669374075,
        "oracle_code": "class Solution {\n    public int largestInteger(int num) {\n        String numString = \"\"+ num;\n        List<Integer> even = new ArrayList<>();\n        List<Integer> odd = new ArrayList<>();\n        for(Character c : numString.toCharArray()){\n            int n = Character.getNumericValue(c);\n            if(n%2==0){\n                even.add(n);\n            }else{\n                odd.add(n);\n            }\n        }\n        Collections.sort(even, Collections.reverseOrder());\n        Collections.sort(odd, Collections.reverseOrder());\n        String res =\"\";\n        int one=0, two=0;\n        for(int i=0; i<numString.length(); i++){\n            int n = Character.getNumericValue(numString.charAt(i));\n            if(n%2==0){\n                res += even.get(one);\n                one++;\n            }else{\n                res += odd.get(two);\n                two++;\n            }\n        }\n        return Integer.parseInt(res);\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nused string and list to store the even and odd elements\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nconverted num in string then added all values from string to even and odd list as per its type;\\nthen sorted both string in desc order\\nas we check from the original string if got even number we will put max even number from even list and incresed even list pointer same for the odd number\\n\\nConverted result string to integer to get int res and returned it\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int largestInteger(int num) {\\n        String numString = \"\"+ num;\\n        List<Integer> even = new ArrayList<>();\\n        List<Integer> odd = new ArrayList<>();\\n        for(Character c : numString.toCharArray()){\\n            int n = Character.getNumericValue(c);\\n            if(n%2==0){\\n                even.add(n);\\n            }else{\\n                odd.add(n);\\n            }\\n        }\\n        Collections.sort(even, Collections.reverseOrder());\\n        Collections.sort(odd, Collections.reverseOrder());\\n        String res =\"\";\\n        int one=0, two=0;\\n        for(int i=0; i<numString.length(); i++){\\n            int n = Character.getNumericValue(numString.charAt(i));\\n            if(n%2==0){\\n                res += even.get(one);\\n                one++;\\n            }else{\\n                res += odd.get(two);\\n                two++;\\n            }\\n        }\\n        return Integer.parseInt(res);\\n    }\\n}\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\n    public int largestInteger(int num) {\n        String numString = \"\"+ num;\n        List<Integer> even = new ArrayList<>();\n        List<Integer> odd = new ArrayList<>();\n        for(Character c : numString.toCharArray())\n            int n = Character.getNumericValue(c);\n            if(n%2==0){\n                even.add(n);\n            }else{\n                odd.add(n);\n            }\n        }\n        Collections.sort(even, Collections.reverseOrder());\n        Collections.sort(odd, Collections.reverseOrder());\n        String res =\"\";\n        int one=0, two=0;\n        for(int i=0; i<numString.length(); i++){\n            int n = Character.getNumericValue(numString.charAt(i));\n            if(n%2==0){\n                res += even.get(one);\n                one++;\n            }else{\n                res += odd.get(two);\n                two++;\n            }\n        }\n        return Integer.parseInt(res);\n    }\n}\n",
        "explanations": "\nI removed a colon from the 'for' loop so, it's a syntax error.\n"
    },
    {
        "slug": "design-authentication-manager",
        "description": "There is an authentication system that works with authentication tokens. For each session, the user will receive a new authentication token that will expire timeToLive seconds after the currentTime. If the token is renewed, the expiry time will be extended to expire timeToLive seconds after the (potentially different) currentTime.\nImplement the AuthenticationManager class:\n\nAuthenticationManager(int timeToLive) constructs the AuthenticationManager and sets the timeToLive.\ngenerate(string tokenId, int currentTime) generates a new token with the given tokenId at the given currentTime in seconds.\nrenew(string tokenId, int currentTime) renews the unexpired token with the given tokenId at the given currentTime in seconds. If there are no unexpired tokens with the given tokenId, the request is ignored, and nothing happens.\ncountUnexpiredTokens(int currentTime) returns the number of unexpired tokens at the given currentTime.\n\nNote that if a token expires at time t, and another action happens on time t (renew or countUnexpiredTokens), the expiration takes place before the other actions.",
        "examples": [
            "Input\n[\"AuthenticationManager\", \"renew\", \"generate\", \"countUnexpiredTokens\", \"generate\", \"renew\", \"renew\", \"countUnexpiredTokens\"]\n[[5], [\"aaa\", 1], [\"aaa\", 2], [6], [\"bbb\", 7], [\"aaa\", 8], [\"bbb\", 10], [15]]\nOutput\n[null, null, null, 1, null, null, null, 0]\n\nExplanation\nAuthenticationManager authenticationManager = new AuthenticationManager(5); // Constructs the AuthenticationManager with timeToLive = 5 seconds.\nauthenticationManager.renew(\"aaa\", 1); // No token exists with tokenId \"aaa\" at time 1, so nothing happens.\nauthenticationManager.generate(\"aaa\", 2); // Generates a new token with tokenId \"aaa\" at time 2.\nauthenticationManager.countUnexpiredTokens(6); // The token with tokenId \"aaa\" is the only unexpired one at time 6, so return 1.\nauthenticationManager.generate(\"bbb\", 7); // Generates a new token with tokenId \"bbb\" at time 7.\nauthenticationManager.renew(\"aaa\", 8); // The token with tokenId \"aaa\" expired at time 7, and 8 >= 7, so at time 8 the renew request is ignored, and nothing happens.\nauthenticationManager.renew(\"bbb\", 10); // The token with tokenId \"bbb\" is unexpired at time 10, so the renew request is fulfilled and now the token will expire at time 15.\nauthenticationManager.countUnexpiredTokens(15); // The token with tokenId \"bbb\" expires at time 15, and the token with tokenId \"aaa\" expired at time 7, so currently no token is unexpired, so return 0."
        ],
        "constraints": "1 <= timeToLive <= 108\n1 <= currentTime <= 108\n1 <= tokenId.length <= 5\ntokenId consists only of lowercase letters.\nAll calls to generate will contain unique values of tokenId.\nThe values of currentTime across all the function calls will be strictly increasing.\nAt most 2000 calls will be made to all functions combined.",
        "release_time": 1673449685,
        "oracle_code": "class AuthenticationManager {\n\n    int time=0;\n\n    HashMap<String,Integer>mp=new HashMap<>();\n\n    public AuthenticationManager(int timeToLive) {\n        \n    time=timeToLive;\n\n    }\n    \n    public void generate(String tokenId, int currentTime) {\n        \n    mp.put(tokenId,currentTime+time);\n\n    }\n    \n    public void renew(String tokenId, int currentTime) {\n        \n    if(!mp.containsKey(tokenId)||mp.get(tokenId)<=currentTime)\n    {\n    return;\n    }\n\n    mp.put(tokenId,currentTime+time);\n\n    }\n    \n    public int countUnexpiredTokens(int currentTime) {\n    \n    List<String>lr=new ArrayList<>(mp.keySet());\n    \n    for(int i=0;i<lr.size();i++){\n    \n    if(mp.get(lr.get(i))<=currentTime)mp.remove(lr.get(i));\n\n    }\n\n    return mp.size();\n    \n    }\n}\n\n/**\n * Your AuthenticationManager object will be instantiated and called as such:\n * AuthenticationManager obj = new AuthenticationManager(timeToLive);\n * obj.generate(tokenId,currentTime);\n * obj.renew(tokenId,currentTime);\n * int param_3 = obj.countUnexpiredTokens(currentTime);\n */",
        "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass AuthenticationManager {\\n\\n    int time=0;\\n\\n    HashMap<String,Integer>mp=new HashMap<>();\\n\\n    public AuthenticationManager(int timeToLive) {\\n        \\n    time=timeToLive;\\n\\n    }\\n    \\n    public void generate(String tokenId, int currentTime) {\\n        \\n    mp.put(tokenId,currentTime+time);\\n\\n    }\\n    \\n    public void renew(String tokenId, int currentTime) {\\n        \\n    if(!mp.containsKey(tokenId)||mp.get(tokenId)<=currentTime)\\n    {\\n    return;\\n    }\\n\\n    mp.put(tokenId,currentTime+time);\\n\\n    }\\n    \\n    public int countUnexpiredTokens(int currentTime) {\\n    \\n    List<String>lr=new ArrayList<>(mp.keySet());\\n    \\n    for(int i=0;i<lr.size();i++){\\n    \\n    if(mp.get(lr.get(i))<=currentTime)mp.remove(lr.get(i));\\n\\n    }\\n\\n    return mp.size();\\n    \\n    }\\n}\\n\\n/**\\n * Your AuthenticationManager object will be instantiated and called as such:\\n * AuthenticationManager obj = new AuthenticationManager(timeToLive);\\n * obj.generate(tokenId,currentTime);\\n * obj.renew(tokenId,currentTime);\\n * int param_3 = obj.countUnexpiredTokens(currentTime);\\n */\\n```",
        "level": "medium",
        "buggy_code": "\nclass AuthenticationManager {\n\n    int time=0;\n\n    HashMap<String,Integer>mp=new HashMap<>();\n\n    public AuthenticationManager(int timeToLive) {\n        \n    time=timeToLive\n\n    }\n    \n    public void generate(String tokenId, int currentTime) {\n        \n    mp.put(tokenId,currentTime+time);\n\n    }\n    \n    public void renew(String tokenId, int currentTime) {\n        \n    if(!mp.containsKey(tokenId)||mp.get(tokenId)<=currentTime)\n    {\n    return;\n    }\n\n    mp.put(tokenId,currentTime+time);\n\n    }\n    \n    public int countUnexpiredTokens(int currentTime) {\n    \n    List<String>lr=new ArrayList<>(mp.keySet());\n    \n    for(int i=0;i<lr.size();i++){\n    \n    if(mp.get(lr.get(i))<=currentTime)mp.remove(lr.get(i));\n\n    }\n\n    return mp.size();\n    \n    }\n}\n\n/**\n * Your AuthenticationManager object will be instantiated and called as such:\n * AuthenticationManager obj = new AuthenticationManager(timeToLive);\n * obj.generate(tokenId,currentTime);\n * obj.renew(tokenId,currentTime);\n * int param_3 = obj.countUnexpiredTokens(currentTime);\n */\n",
        "explanations": "\nThe code misses a semicolon to end the statement inside the constructor of the AuthenticationManager class.\n"
    },
    {
        "slug": "find-words-that-can-be-formed-by-characters",
        "description": "You are given an array of strings words and a string chars.\nA string is good if it can be formed by characters from chars (each character can only be used once).\nReturn the sum of lengths of all good strings in words.",
        "examples": [
            "Input: words = [\"cat\",\"bt\",\"hat\",\"tree\"], chars = \"atach\"\nOutput: 6\nExplanation: The strings that can be formed are \"cat\" and \"hat\" so the answer is 3 + 3 = 6.",
            "Input: words = [\"hello\",\"world\",\"leetcode\"], chars = \"welldonehoneyr\"\nOutput: 10\nExplanation: The strings that can be formed are \"hello\" and \"world\" so the answer is 5 + 5 = 10."
        ],
        "constraints": "1 <= words.length <= 1000\n1 <= words[i].length, chars.length <= 100\nwords[i] and chars consist of lowercase English letters.",
        "release_time": 1674641372,
        "oracle_code": "class Solution {\n    public int[] char_map;\n    public int countCharacters(String[] words, String chars) {\n        char_map=new int[26];\n       int ans=0;\n       for(char c : chars.toCharArray()){\n           char_map[c-'a']++;\n       }\n\n       for(String word: words){\n           int[] dummyArray = Arrays.copyOf(char_map, char_map.length);\n           int count =0;\n           for(char c: word.toCharArray()){\n               if(dummyArray[c-'a']>0){\n                   count++;\n                   dummyArray[c-'a']--;\n               }\n           }\n           if(count==word.length()){\n               ans+=word.length();\n           }\n       }\n       return ans;\n    }\n}",
        "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] char_map;\\n    public int countCharacters(String[] words, String chars) {\\n        char_map=new int[26];\\n       int ans=0;\\n       for(char c : chars.toCharArray()){\\n           char_map[c-\\'a\\']++;\\n       }\\n\\n       for(String word: words){\\n           int[] dummyArray = Arrays.copyOf(char_map, char_map.length);\\n           int count =0;\\n           for(char c: word.toCharArray()){\\n               if(dummyArray[c-\\'a\\']>0){\\n                   count++;\\n                   dummyArray[c-\\'a\\']--;\\n               }\\n           }\\n           if(count==word.length()){\\n               ans+=word.length();\\n           }\\n       }\\n       return ans;\\n    }\\n}\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\n    public int[] char_map;\n    public int countCharacters(String[] words, String chars) {\n        char_map=new int[26];\n       int ans=0;\n       for(char c : chars.toCharArray()){\n           char_map[c-'a']++;\n       }\n\n       for(String word: words){\n           int[] dummyArray = Arrays.copyOf(char_map, char_map.length);\n           int count =0\n           for(char c: word.toCharArray()){\n               if(dummyArray[c-'a']>0){\n                   count++;\n                   dummyArray[c-'a']--;\n               }\n           }\n           if(count==word.length()){\n               ans+=word.length();\n           }\n       }\n       return ans;\n    }\n}\n",
        "explanations": "\nMissing semicolon after the \"int count = 0\" statement, results in a compilation error.\n"
    },
    {
        "slug": "special-array-with-x-elements-greater-than-or-equal-x",
        "description": "You are given an array nums of non-negative integers. nums is considered special if there exists a number x such that there are exactly x numbers in nums that are greater than or equal to x.\nNotice that x does not have to be an element in nums.\nReturn x if the array is special, otherwise, return -1. It can be proven that if nums is special, the value for x is unique.",
        "examples": [
            "Input: nums = [3,5]\nOutput: 2\nExplanation: There are 2 values (3 and 5) that are greater than or equal to 2.",
            "Input: nums = [0,0]\nOutput: -1\nExplanation: No numbers fit the criteria for x.\nIf x = 0, there should be 0 numbers >= x, but there are 2.\nIf x = 1, there should be 1 number >= x, but there are 0.\nIf x = 2, there should be 2 numbers >= x, but there are 0.\nx cannot be greater since there are only 2 numbers in nums.",
            "Input: nums = [0,4,3,0,4]\nOutput: 3\nExplanation: There are 3 values that are greater than or equal to 3."
        ],
        "constraints": "1 <= nums.length <= 100\n0 <= nums[i] <= 1000",
        "release_time": 1691442100,
        "oracle_code": "class Solution {\n    public int countPossibility(int []nums,int x){\n        int cnt=0;\n        for(int n:nums) if(n>=x) cnt++;\n        return cnt;\n    }\n    public int specialArray(int[] nums) {\n        int maxi=Integer.MIN_VALUE,start=1,mid=0;\n        for(int x:nums) maxi=Math.max(maxi,x);\n        int end = maxi;\n        while(start<=end){\n            mid = (start+end)/2;\n            int check = countPossibility(nums,mid);\n            if(check==mid) return mid;\n            if(mid<check) start=mid+1;\n            else end=mid-1;\n        }\n        return -1;\n    }\n}",
        "content": "# Intuition\\n  First of all we will discuss Why Binary Search, even if the array is not sorted . Look here the array is not sorted but lemme tell you if we have some range so we can definitely apply binary search on range because range is something which will always be in a sorted fashion for example suppose we have the range [5,20] so here 5 to 20 means 5,6,7,8,9,10...till 20 which is sorted in itself. So remember we can apply Binary Search on **range** too.\\n\\nNow, here the array is not sorted so what left? Can we figure out some range? Yes we definitely can !! Just observe this atleast we will be having 1 such element which will be greater than other elements , right? so our range will definitely start from 1 now what will be the ending point ? It will definitely be the maximum element of an array. Now we have the range [1,max_element] on which we can apply Binary Search.\\n\\nNow we can apply standard binary search algorithm here which consist of 4 steps :\\nStep 1 : Calculate the mid point.\\nStep 2 : If the mid meets the desire result we will simply returns it.\\nStep 3 : a) If the mid has more greater number than obviously the numbers which are present before to mid will also has the greater numbers so in this situation it would be like a time waste to search in the left half , rather we can reduce our search space and will eliminate the left half and can jump to the right half.\\nStep 4 : b) Otherwise we will simply jump to left part instead of searching in right half.\\n\\n# Approach\\n  Binary Search Algorithm.\\n\\n# Complexity\\n- Time complexity:\\n  O(max)*logn\\n\\n- Space complexity:\\n  O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int countPossibility(int []nums,int x){\\n        int cnt=0;\\n        for(int n:nums) if(n>=x) cnt++;\\n        return cnt;\\n    }\\n    public int specialArray(int[] nums) {\\n        int maxi=Integer.MIN_VALUE,start=1,mid=0;\\n        for(int x:nums) maxi=Math.max(maxi,x);\\n        int end = maxi;\\n        while(start<=end){\\n            mid = (start+end)/2;\\n            int check = countPossibility(nums,mid);\\n            if(check==mid) return mid;\\n            if(mid<check) start=mid+1;\\n            else end=mid-1;\\n        }\\n        return -1;\\n    }\\n}\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\n    public int countPossibility(int []nums,int x){\n        int cnt=0;\n        for(int n:nums) if(n>=x) cnt++\n        return cnt;\n    }\n    public int specialArray(int[] nums) {\n        int maxi=Integer.MIN_VALUE,start=1,mid=0;\n        for(int x:nums) maxi=Math.max(maxi,x);\n        int end = maxi;\n        while(start<=end){\n            mid = (start+end)/2;\n            int check = countPossibility(nums,mid);\n            if(check==mid) return mid;\n            if(mid<check) start=mid+1;\n            else end=mid-1;\n        }\n        return -1;\n    }\n}\n",
        "explanations": "\nThe bug is the missing semicolon after incrementing cnt variable in countPossibility method.\n"
    },
    {
        "slug": "minimum-falling-path-sum-ii",
        "description": "Given an n x n integer matrix grid, return the minimum sum of a falling path with non-zero shifts.\nA falling path with non-zero shifts is a choice of exactly one element from each row of grid such that no two elements chosen in adjacent rows are in the same column.",
        "examples": [
            "Input: grid = [[1,2,3],[4,5,6],[7,8,9]]\nOutput: 13\nExplanation: \nThe possible falling paths are:\n[1,5,9], [1,5,7], [1,6,7], [1,6,8],\n[2,4,8], [2,4,9], [2,6,7], [2,6,8],\n[3,4,8], [3,4,9], [3,5,7], [3,5,9]\nThe falling path with the smallest sum is\u00a0[1,5,7], so the answer is\u00a013.",
            "Input: grid = [[7]]\nOutput: 7"
        ],
        "constraints": "n == grid.length == grid[i].length\n1 <= n <= 200\n-99 <= grid[i][j] <= 99",
        "release_time": 1668185090,
        "oracle_code": "class Solution {\n    int m;\n    int n;\n    Integer memo[][];\n\n    public int minFallingPathSum(int[][] grid) {   \n         m=grid.length;\n         n=grid[0].length;\n        //<<---------------for Recursive Soln--------------->>\n         memo=new Integer[m][n];//memo [][]\n\n         int recRes=Integer.MAX_VALUE;\n\n         //iterate over the 1st rows col \n        //  for(int col=0;col<n;col++)\n        //            recRes=Math.min(recRes,minFallingPathSum_Rec(grid,0,col));\n\n      //<<---------------for Recursive Soln--------------->>\n        //  return recRes;\n\n          //<<---------------for Tabulation  Soln--------------->>\n         int Tabulation_Ans=minFallingPathSum_Tabulation(grid);\n         return Tabulation_Ans;\n    }\n\n    public int minFallingPathSum_Rec(int[][] grid,int i,int j){\n            \n            if(j<0 || j>=n || i<0 || i>=m)\n                           return Integer.MAX_VALUE;\n\n            if(i==m-1)\n                     return grid[i][j];\n\n            if(memo[i][j]!=null)\n                        return memo[i][j];\n\n            int lowerLeftSum=Integer.MAX_VALUE;\n            int lowerRightSum=Integer.MAX_VALUE;\n\n            for(int col=0;col<=j-1;col++)\n                    lowerLeftSum=Math.min(lowerLeftSum,minFallingPathSum_Rec(grid,i+1,col));\n\n            for(int col=j+1;col<=n-1;col++)\n                    lowerRightSum=Math.min(lowerRightSum,minFallingPathSum_Rec(grid,i+1,col));\n\n          return memo[i][j]=Math.min(lowerLeftSum,lowerRightSum)+grid[i][j];\n\n     }//rec--->>memorization\n\n\n\n\n     int minFallingPathSum_Tabulation(int[][] grid){\n          int dp[][]=new int[m][n];\n\n          for(int i=m-1;i>=0;i--){\n              for(int j=n-1;j>=0;j--){\n                    \n                    if(i==m-1)\n                     {\n                         dp[i][j]=grid[i][j];\n                         continue;\n                     }//base case : if the last row \n                \n                int lowerLeftSum=Integer.MAX_VALUE;\n                int lowerRightSum=Integer.MAX_VALUE;\n                //for lower left sum calculation \n                for(int col=0;col<=j-1;col++){\n                    lowerLeftSum=Math.min(lowerLeftSum,((col<0)?Integer.MAX_VALUE:dp[i+1][col]));\n                }\n                \n                //for lower right sum calculation \n                for(int col=j+1;col<=n-1;col++){\n                    lowerRightSum=Math.min(lowerRightSum,((col>=n)?Integer.MAX_VALUE:dp[i+1][col]));\n                \n                }\n                \n                dp[i][j]=Math.min(lowerLeftSum,lowerRightSum)+grid[i][j];\n              \n              }//inner \n          }//ouer \n           \n\n          int Ans=Integer.MAX_VALUE;\n\n          for(int COL=0;COL<n;COL++){\n              Ans=Math.min(Ans,dp[0][COL]);\n          }\n          \n          return Ans;\n     \n     }//tabulation soln:derived from the recursive soln \n}",
        "content": "# Intuition\\nat any particular cell grid(i,j) we need the minm of all cells of f(i+1,{0 to j-1}) and all minm of cells of f(i+1,{j+1 to n-1})\\n\\n\\n# I have shared both recursive/memo code and alternate tabulation code on same code space . Have a look into the soln and do let me know if any confusion . Please do upvote if you find the soln helpful \\uD83D\\uDE80\\n\\n# Code\\n```\\nclass Solution {\\n    int m;\\n    int n;\\n    Integer memo[][];\\n\\n    public int minFallingPathSum(int[][] grid) {   \\n         m=grid.length;\\n         n=grid[0].length;\\n        //<<---------------for Recursive Soln--------------->>\\n         memo=new Integer[m][n];//memo [][]\\n\\n         int recRes=Integer.MAX_VALUE;\\n\\n         //iterate over the 1st rows col \\n        //  for(int col=0;col<n;col++)\\n        //            recRes=Math.min(recRes,minFallingPathSum_Rec(grid,0,col));\\n\\n      //<<---------------for Recursive Soln--------------->>\\n        //  return recRes;\\n\\n          //<<---------------for Tabulation  Soln--------------->>\\n         int Tabulation_Ans=minFallingPathSum_Tabulation(grid);\\n         return Tabulation_Ans;\\n    }\\n\\n    public int minFallingPathSum_Rec(int[][] grid,int i,int j){\\n            \\n            if(j<0 || j>=n || i<0 || i>=m)\\n                           return Integer.MAX_VALUE;\\n\\n            if(i==m-1)\\n                     return grid[i][j];\\n\\n            if(memo[i][j]!=null)\\n                        return memo[i][j];\\n\\n            int lowerLeftSum=Integer.MAX_VALUE;\\n            int lowerRightSum=Integer.MAX_VALUE;\\n\\n            for(int col=0;col<=j-1;col++)\\n                    lowerLeftSum=Math.min(lowerLeftSum,minFallingPathSum_Rec(grid,i+1,col));\\n\\n            for(int col=j+1;col<=n-1;col++)\\n                    lowerRightSum=Math.min(lowerRightSum,minFallingPathSum_Rec(grid,i+1,col));\\n\\n          return memo[i][j]=Math.min(lowerLeftSum,lowerRightSum)+grid[i][j];\\n\\n     }//rec--->>memorization\\n\\n\\n\\n\\n     int minFallingPathSum_Tabulation(int[][] grid){\\n          int dp[][]=new int[m][n];\\n\\n          for(int i=m-1;i>=0;i--){\\n              for(int j=n-1;j>=0;j--){\\n                    \\n                    if(i==m-1)\\n                     {\\n                         dp[i][j]=grid[i][j];\\n                         continue;\\n                     }//base case : if the last row \\n                \\n                int lowerLeftSum=Integer.MAX_VALUE;\\n                int lowerRightSum=Integer.MAX_VALUE;\\n                //for lower left sum calculation \\n                for(int col=0;col<=j-1;col++){\\n                    lowerLeftSum=Math.min(lowerLeftSum,((col<0)?Integer.MAX_VALUE:dp[i+1][col]));\\n                }\\n                \\n                //for lower right sum calculation \\n                for(int col=j+1;col<=n-1;col++){\\n                    lowerRightSum=Math.min(lowerRightSum,((col>=n)?Integer.MAX_VALUE:dp[i+1][col]));\\n                \\n                }\\n                \\n                dp[i][j]=Math.min(lowerLeftSum,lowerRightSum)+grid[i][j];\\n              \\n              }//inner \\n          }//ouer \\n           \\n\\n          int Ans=Integer.MAX_VALUE;\\n\\n          for(int COL=0;COL<n;COL++){\\n              Ans=Math.min(Ans,dp[0][COL]);\\n          }\\n          \\n          return Ans;\\n     \\n     }//tabulation soln:derived from the recursive soln \\n}\\n```",
        "level": "hard",
        "buggy_code": "\nclass Solution {\n    int m;\n    int n;\n    Integer memo[][];\n\n    public int minFallingPathSum(int[][] grid)   \n         m=grid.length;\n         n=grid[0].length;\n\n         memo=new Integer[m][n];\n\n         int recRes=Integer.MAX_VALUE;\n\n         int Tabulation_Ans=minFallingPathSum_Tabulation(grid);\n         return Tabulation_Ans;\n    }\n\n    public int minFallingPathSum_Rec(int[][] grid,int i,int j){\n            \n            if(j<0 || j>=n || i<0 || i>=m)\n                           return Integer.MAX_VALUE;\n\n            if(i==m-1)\n                     return grid[i][j];\n\n            if(memo[i][j]!=null)\n                        return memo[i][j];\n\n            int lowerLeftSum=Integer.MAX_VALUE;\n            int lowerRightSum=Integer.MAX_VALUE;\n\n            for(int col=0;col<=j-1;col++)\n                    lowerLeftSum=Math.min(lowerLeftSum,minFallingPathSum_Rec(grid,i+1,col));\n\n            for(int col=j+1;col<=n-1;col++)\n                    lowerRightSum=Math.min(lowerRightSum,minFallingPathSum_Rec(grid,i+1,col));\n\n          return memo[i][j]=Math.min(lowerLeftSum,lowerRightSum)+grid[i][j];\n\n     }\n\n\n     int minFallingPathSum_Tabulation(int[][] grid){\n          int dp[][]=new int[m][n];\n\n          for(int i=m-1;i>=0;i--){\n              for(int j=n-1;j>=0;j--){\n                    \n                    if(i==m-1)\n                     {\n                         dp[i][j]=grid[i][j];\n                         continue;\n                     }\n                \n                int lowerLeftSum=Integer.MAX_VALUE;\n                int lowerRightSum=Integer.MAX_VALUE;\n\n                for(int col=0;col<=j-1;col++){\n                    lowerLeftSum=Math.min(lowerLeftSum,((col<0)?Integer.MAX_VALUE:dp[i+1][col]));\n                }\n\n                for(int col=j+1;col<=n-1;col++){\n                    lowerRightSum=Math.min(lowerRightSum,((col>=n)?Integer.MAX_VALUE:dp[i+1][col]));\n                }\n                \n                dp[i][j]=Math.min(lowerLeftSum,lowerRightSum)+grid[i][j];\n              \n              }\n          }\n           \n\n          int Ans=Integer.MAX_VALUE;\n\n          for(int COL=0;COL<n;COL++){\n              Ans=Math.min(Ans,dp[0][COL]);\n          }\n          \n          return Ans;\n     \n     }\n}\n",
        "explanations": "\nThe missing open bracket after the method declaration in the minFallingPathSum method leads to a syntax error.\n"
    },
    {
        "slug": "find-all-people-with-secret",
        "description": "You are given an integer n indicating there are n people numbered from 0 to n - 1. You are also given a 0-indexed 2D integer array meetings where meetings[i] = [xi, yi, timei] indicates that person xi and person yi have a meeting at timei. A person may attend multiple meetings at the same time. Finally, you are given an integer firstPerson.\nPerson 0 has a secret and initially shares the secret with a person firstPerson at time 0. This secret is then shared every time a meeting takes place with a person that has the secret. More formally, for every meeting, if a person xi has the secret at timei, then they will share the secret with person yi, and vice versa.\nThe secrets are shared instantaneously. That is, a person may receive the secret and share it with people in other meetings within the same time frame.\nReturn a list of all the people that have the secret after all the meetings have taken place. You may return the answer in any order.",
        "examples": [
            "Input: n = 6, meetings = [[1,2,5],[2,3,8],[1,5,10]], firstPerson = 1\nOutput: [0,1,2,3,5]\nExplanation:\nAt time 0, person 0 shares the secret with person 1.\nAt time 5, person 1 shares the secret with person 2.\nAt time 8, person 2 shares the secret with person 3.\nAt time 10, person 1 shares the secret with person 5.\u200b\u200b\u200b\u200b\nThus, people 0, 1, 2, 3, and 5 know the secret after all the meetings.",
            "Input: n = 4, meetings = [[3,1,3],[1,2,2],[0,3,3]], firstPerson = 3\nOutput: [0,1,3]\nExplanation:\nAt time 0, person 0 shares the secret with person 3.\nAt time 2, neither person 1 nor person 2 know the secret.\nAt time 3, person 3 shares the secret with person 0 and person 1.\nThus, people 0, 1, and 3 know the secret after all the meetings.",
            "Input: n = 5, meetings = [[3,4,2],[1,2,1],[2,3,1]], firstPerson = 1\nOutput: [0,1,2,3,4]\nExplanation:\nAt time 0, person 0 shares the secret with person 1.\nAt time 1, person 1 shares the secret with person 2, and person 2 shares the secret with person 3.\nNote that person 2 can share the secret at the same time as receiving it.\nAt time 2, person 3 shares the secret with person 4.\nThus, people 0, 1, 2, 3, and 4 know the secret after all the meetings."
        ],
        "constraints": "2 <= n <= 105\n1 <= meetings.length <= 105\nmeetings[i].length == 3\n0 <= xi, yi <= n - 1\nxi != yi\n1 <= timei <= 105\n1 <= firstPerson <= n - 1",
        "release_time": 1687729516,
        "oracle_code": "class DisjointSet {\n    int[] root;\n    Long[] rank;\n    DisjointSet(int size, Set<Integer> secretKeepers) {\n        root = new int[size];\n        rank = new Long[size];\n        for (int i = 0; i < size; i++) {\n            root[i] = i;\n            rank[i] = secretKeepers.contains(i) ? Integer.MAX_VALUE : 1L;\n        }\n    }\n\n    public int find(int vertex) {\n        if(root[vertex] == vertex) return vertex;\n        return root[vertex] = find(root[vertex]);\n    }\n\n    public void union(int vertex1, int vertex2) {\n        int root1 = find(vertex1);\n        int root2 = find(vertex2);\n        if(root1 != root2) {\n            if(rank[root1] > rank[root2]) {\n                root[root2] = root1;\n            } else if (rank[root2] > rank[root1]) {\n                root[root1] = root2;\n            } else {\n                root[root2] = root1;\n                rank[root1]++;\n            }\n        }\n    }\n\n    public Set<Integer> getAllSecretKeepers(Set<Integer> secretKeepers, Set<Integer> visited) {\n        for (int vertex: visited) {\n            if(secretKeepers.contains(find(vertex)))\n                secretKeepers.add(vertex);\n            else \n                root[vertex] = vertex;\n        }\n        return secretKeepers;\n    }\n}\n\nclass Solution {\n    private int maxTime = Integer.MIN_VALUE;\n    private int minTime = Integer.MAX_VALUE;\n    public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {\n        Set<Integer> secretKeepers = new HashSet<>(List.of(0, firstPerson));\n        Map<Integer, List<Integer[]>> timeToMeetings = getTimeToMeetings(meetings);\n        DisjointSet disjointSet = new DisjointSet(n, secretKeepers);\n        for (int time = minTime; time <= maxTime; time++) {\n            if(!timeToMeetings.containsKey(time)) continue;\n            Set<Integer> visited = new HashSet<>();\n            for (Integer[] meeting: timeToMeetings.get(time)) {\n                int person1 = meeting[0], person2 = meeting[1];\n                disjointSet.union(person1, person2);\n                visited.add(person1);\n                visited.add(person2);\n            }\n            secretKeepers = disjointSet.getAllSecretKeepers(secretKeepers, visited);\n        }\n        return new ArrayList<>(secretKeepers);\n    }\n\n    private Map<Integer, List<Integer[]>> getTimeToMeetings(int[][] meetings) {\n        Map<Integer, List<Integer[]>> timeToMeetings = new HashMap<>();\n        for (int[] meeting: meetings) {\n            maxTime = Math.max(maxTime, meeting[2]);\n            minTime = Math.min(minTime, meeting[2]);\n            timeToMeetings.computeIfAbsent(meeting[2], e-> new ArrayList<>()).add(new Integer[]{meeting[0], meeting[1]});\n        }\n        return timeToMeetings;\n    }\n}",
        "content": "# Code\\n```\\nclass DisjointSet {\\n    int[] root;\\n    Long[] rank;\\n    DisjointSet(int size, Set<Integer> secretKeepers) {\\n        root = new int[size];\\n        rank = new Long[size];\\n        for (int i = 0; i < size; i++) {\\n            root[i] = i;\\n            rank[i] = secretKeepers.contains(i) ? Integer.MAX_VALUE : 1L;\\n        }\\n    }\\n\\n    public int find(int vertex) {\\n        if(root[vertex] == vertex) return vertex;\\n        return root[vertex] = find(root[vertex]);\\n    }\\n\\n    public void union(int vertex1, int vertex2) {\\n        int root1 = find(vertex1);\\n        int root2 = find(vertex2);\\n        if(root1 != root2) {\\n            if(rank[root1] > rank[root2]) {\\n                root[root2] = root1;\\n            } else if (rank[root2] > rank[root1]) {\\n                root[root1] = root2;\\n            } else {\\n                root[root2] = root1;\\n                rank[root1]++;\\n            }\\n        }\\n    }\\n\\n    public Set<Integer> getAllSecretKeepers(Set<Integer> secretKeepers, Set<Integer> visited) {\\n        for (int vertex: visited) {\\n            if(secretKeepers.contains(find(vertex)))\\n                secretKeepers.add(vertex);\\n            else \\n                root[vertex] = vertex;\\n        }\\n        return secretKeepers;\\n    }\\n}\\n\\nclass Solution {\\n    private int maxTime = Integer.MIN_VALUE;\\n    private int minTime = Integer.MAX_VALUE;\\n    public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {\\n        Set<Integer> secretKeepers = new HashSet<>(List.of(0, firstPerson));\\n        Map<Integer, List<Integer[]>> timeToMeetings = getTimeToMeetings(meetings);\\n        DisjointSet disjointSet = new DisjointSet(n, secretKeepers);\\n        for (int time = minTime; time <= maxTime; time++) {\\n            if(!timeToMeetings.containsKey(time)) continue;\\n            Set<Integer> visited = new HashSet<>();\\n            for (Integer[] meeting: timeToMeetings.get(time)) {\\n                int person1 = meeting[0], person2 = meeting[1];\\n                disjointSet.union(person1, person2);\\n                visited.add(person1);\\n                visited.add(person2);\\n            }\\n            secretKeepers = disjointSet.getAllSecretKeepers(secretKeepers, visited);\\n        }\\n        return new ArrayList<>(secretKeepers);\\n    }\\n\\n    private Map<Integer, List<Integer[]>> getTimeToMeetings(int[][] meetings) {\\n        Map<Integer, List<Integer[]>> timeToMeetings = new HashMap<>();\\n        for (int[] meeting: meetings) {\\n            maxTime = Math.max(maxTime, meeting[2]);\\n            minTime = Math.min(minTime, meeting[2]);\\n            timeToMeetings.computeIfAbsent(meeting[2], e-> new ArrayList<>()).add(new Integer[]{meeting[0], meeting[1]});\\n        }\\n        return timeToMeetings;\\n    }\\n}\\n```",
        "level": "hard",
        "buggy_code": "\nclass DisjointSet {\n    int[] root;\n    Long[] rank;\n    DisjointSet(int size, Set<Integer> secretKeepers) {\n        root = new int[size]\n        rank = new Long[size];\n        for (int i = 0; i < size; i++) {\n            root[i] = i;\n            rank[i] = secretKeepers.contains(i) ? Integer.MAX_VALUE : 1L;\n        }\n    }\n\n    public int find(int vertex) {\n        if(root[vertex] == vertex) return vertex;\n        return root[vertex] = find(root[vertex]);\n    }\n\n    public void union(int vertex1, int vertex2) {\n        int root1 = find(vertex1);\n        int root2 = find(vertex2);\n        if(root1 != root2) {\n            if(rank[root1] > rank[root2]) {\n                root[root2] = root1;\n            } else if (rank[root2] > rank[root1]) {\n                root[root1] = root2;\n            } else {\n                root[root2] = root1;\n                rank[root1]++;\n            }\n        }\n    }\n\n    public Set<Integer> getAllSecretKeepers(Set<Integer> secretKeepers, Set<Integer> visited) {\n        for (int vertex: visited) {\n            if(secretKeepers.contains(find(vertex)))\n                secretKeepers.add(vertex);\n            else \n                root[vertex] = vertex;\n        }\n        return secretKeepers;\n    }\n}\n\nclass Solution {\n    private int maxTime = Integer.MIN_VALUE;\n    private int minTime = Integer.MAX_VALUE;\n    public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {\n        Set<Integer> secretKeepers = new HashSet<>(List.of(0, firstPerson));\n        Map<Integer, List<Integer[]>> timeToMeetings = getTimeToMeetings(meetings);\n        DisjointSet disjointSet = new DisjointSet(n, secretKeepers);\n        for (int time = minTime; time <= maxTime; time++) {\n            if(!timeToMeetings.containsKey(time)) continue;\n            Set<Integer> visited = new HashSet<>();\n            for (Integer[] meeting: timeToMeetings.get(time)) {\n                int person1 = meeting[0], person2 = meeting[1];\n                disjointSet.union(person1, person2);\n                visited.add(person1);\n                visited.add(person2);\n            }\n            secretKeepers = disjointSet.getAllSecretKeepers(secretKeepers, visited);\n        }\n        return new ArrayList<>(secretKeepers);\n    }\n    private Map<Integer, List<Integer[]>> getTimeToMeetings(int[][] meetings) {\n        Map<Integer, List<Integer[]>> timeToMeetings = new HashMap<>();\n        for (int[] meeting: meetings) {\n            maxTime = Math.max(maxTime, meeting[2]);\n            minTime = Math.min(minTime, meeting[2]);\n            timeToMeetings.computeIfAbsent(meeting[2], e-> new ArrayList<>()).add(new Integer[]{meeting[0], meeting[1]});\n        }\n        return timeToMeetings;\n    }\n}\n",
        "explanations": "\nThe semicolon is missing after array initialization \"root = new int[size]\" causing a compile-time error.\n"
    },
    {
        "slug": "lfu-cache",
        "description": "Design and implement a data structure for a Least Frequently Used (LFU) cache.\nImplement the LFUCache class:\n\nLFUCache(int capacity) Initializes the object with the capacity of the data structure.\nint get(int key) Gets the value of the key if the key exists in the cache. Otherwise, returns -1.\nvoid put(int key, int value) Update the value of the key if present, or inserts the key if not already present. When the cache reaches its capacity, it should invalidate and remove the least frequently used key before inserting a new item. For this problem, when there is a tie (i.e., two or more keys with the same frequency), the least recently used key would be invalidated.\n\nTo determine the least frequently used key, a use counter is maintained for each key in the cache. The key with the smallest use counter is the least frequently used key.\nWhen a key is first inserted into the cache, its use counter is set to 1 (due to the put operation). The use counter for a key in the cache is incremented either a get or put operation is called on it.\nThe functions\u00a0get\u00a0and\u00a0put\u00a0must each run in O(1) average time complexity.",
        "examples": [
            "Input\n[\"LFUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"get\", \"put\", \"get\", \"get\", \"get\"]\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [3], [4, 4], [1], [3], [4]]\nOutput\n[null, null, null, 1, null, -1, 3, null, -1, 3, 4]\n\nExplanation\n// cnt(x) = the use counter for key x\n// cache=[] will show the last used order for tiebreakers (leftmost element is  most recent)\nLFUCache lfu = new LFUCache(2);\nlfu.put(1, 1);   // cache=[1,_], cnt(1)=1\nlfu.put(2, 2);   // cache=[2,1], cnt(2)=1, cnt(1)=1\nlfu.get(1);      // return 1\n                 // cache=[1,2], cnt(2)=1, cnt(1)=2\nlfu.put(3, 3);   // 2 is the LFU key because cnt(2)=1 is the smallest, invalidate 2.\n\u00a0                // cache=[3,1], cnt(3)=1, cnt(1)=2\nlfu.get(2);      // return -1 (not found)\nlfu.get(3);      // return 3\n                 // cache=[3,1], cnt(3)=2, cnt(1)=2\nlfu.put(4, 4);   // Both 1 and 3 have the same cnt, but 1 is LRU, invalidate 1.\n                 // cache=[4,3], cnt(4)=1, cnt(3)=2\nlfu.get(1);      // return -1 (not found)\nlfu.get(3);      // return 3\n                 // cache=[3,4], cnt(4)=1, cnt(3)=3\nlfu.get(4);      // return 4\n                 // cache=[4,3], cnt(4)=2, cnt(3)=3"
        ],
        "constraints": "1 <= capacity\u00a0<= 104\n0 <= key <= 105\n0 <= value <= 109\nAt most 2 * 105\u00a0calls will be made to get and put.",
        "release_time": 1678871787,
        "oracle_code": "class LFUCache {\n\n    final int capacity;\n    int curSize;\n    int minFrequency;\n    Map<Integer, DLLNode> cache;\n    Map<Integer, DoubleLinkedList> frequencyMap;\n\n    /*.*/\n    /*\n    * @param capacity: total capacity of LFU Cache\n    * @param curSize: current size of LFU cache\n    * @param minFrequency: frequency of the last linked list (the minimum frequency of entire LFU cache)\n    * @param cache: a hash map that has key to Node mapping, which used for storing all nodes by their keys\n    * @param frequencyMap: a hash map that has key to linked list mapping, which used for storing all\n    * double linked list by their frequencies\n    * */\n    public LFUCache(int capacity) {\n        this.capacity = capacity;\n        this.curSize = 0;\n        this.minFrequency = 0;\n\n        this.cache = new HashMap<>();\n        this.frequencyMap = new HashMap<>();\n    }\n\n    /** get node value by key, and then update node frequency as well as relocate that node **/\n    public int get(int key) {\n        DLLNode curNode = cache.get(key);\n        if (curNode == null) {\n            return -1;\n        }\n        updateNode(curNode);\n        return curNode.val;\n    }\n\n    /**\n     * add new node into LFU cache, as well as double linked list\n     * condition 1: if LFU cache has input key, update node value and node position in list\n     * condition 2: if LFU cache does NOT have input key\n     *  - sub condition 1: if LFU cache does NOT have enough space, remove the Least Recent Used node\n     *  in minimum frequency list, then add new node\n     *  - sub condition 2: if LFU cache has enough space, add new node directly\n     * **/\n    public void put(int key, int value) {\n        // corner case: check cache capacity initialization\n        if (capacity == 0) {\n            return;\n        }\n\n        if (cache.containsKey(key)) {\n            DLLNode curNode = cache.get(key);\n            curNode.val = value;\n            updateNode(curNode);\n        }\n        else {\n            curSize++;\n            if (curSize > capacity) {\n                // get minimum frequency list\n                DoubleLinkedList minFreqList = frequencyMap.get(minFrequency);\n                cache.remove(minFreqList.tail.prev.key);\n                minFreqList.removeNode(minFreqList.tail.prev);\n                curSize--;\n            }\n            // reset min frequency to 1 because of adding new node\n            minFrequency = 1;\n            DLLNode newNode = new DLLNode(key, value);\n\n            // get the list with frequency 1, and then add new node into the list, as well as into LFU cache\n            DoubleLinkedList curList = frequencyMap.getOrDefault(1, new DoubleLinkedList());\n            curList.addNode(newNode);\n            frequencyMap.put(1, curList);\n            cache.put(key, newNode);\n        }\n    }\n\n    public void updateNode(DLLNode curNode) {\n        int curFreq = curNode.frequency;\n        DoubleLinkedList curList = frequencyMap.get(curFreq);\n        curList.removeNode(curNode);\n\n        // if current list the the last list which has lowest frequency and current node is the only node in that list\n        // we need to remove the entire list and then increase min frequency value by 1\n        if (curFreq == minFrequency && curList.listSize == 0) {\n            minFrequency++;\n        }\n\n        curNode.frequency++;\n        // add current node to another list has current frequency + 1,\n        // if we do not have the list with this frequency, initialize it\n        DoubleLinkedList newList = frequencyMap.getOrDefault(curNode.frequency, new DoubleLinkedList());\n        newList.addNode(curNode);\n        frequencyMap.put(curNode.frequency, newList);\n    }\n\n    /*\n    * @param key: node key\n    * @param val: node value\n    * @param frequency: frequency count of current node\n    * (all nodes connected in same double linked list has same frequency)\n    * @param prev: previous pointer of current node\n    * @param next: next pointer of current node\n    * */\n    class DLLNode {\n        int key;\n        int val;\n        int frequency;\n        DLLNode prev;\n        DLLNode next;\n\n        public DLLNode(int key, int val) {\n            this.key = key;\n            this.val = val;\n            this.frequency = 1;\n        }\n    }\n\n    /*\n    * @param listSize: current size of double linked list\n    * @param head: head node of double linked list\n    * @param tail: tail node of double linked list\n    * */\n    class DoubleLinkedList {\n        int listSize;\n        DLLNode head;\n        DLLNode tail;\n        public DoubleLinkedList() {\n            this.listSize = 0;\n            this.head = new DLLNode(0, 0);\n            this.tail = new DLLNode(0, 0);\n            head.next = tail;\n            tail.prev = head;\n        }\n\n        /** add new node into head of list and increase list size by 1 **/\n        public void addNode(DLLNode curNode) {\n            DLLNode nextNode = head.next;\n            curNode.next = nextNode;\n            curNode.prev = head;\n            head.next = curNode;\n            nextNode.prev = curNode;\n            listSize++;\n        }\n\n        /** remove input node and decrease list size by 1**/\n        public void removeNode(DLLNode curNode) {\n            DLLNode prevNode = curNode.prev;\n            DLLNode nextNode = curNode.next;\n            prevNode.next = nextNode;\n            nextNode.prev = prevNode;\n            listSize--;\n        }\n\n    }\n}\n\n/**\n * Your LFUCache object will be instantiated and called as such:\n * LFUCache obj = new LFUCache(capacity);\n * int param_1 = obj.get(key);\n * obj.put(key,value);\n */",
        "content": "\\n\\n# Code\\n```\\nclass LFUCache {\\n\\n    final int capacity;\\n    int curSize;\\n    int minFrequency;\\n    Map<Integer, DLLNode> cache;\\n    Map<Integer, DoubleLinkedList> frequencyMap;\\n\\n    /*.*/\\n    /*\\n    * @param capacity: total capacity of LFU Cache\\n    * @param curSize: current size of LFU cache\\n    * @param minFrequency: frequency of the last linked list (the minimum frequency of entire LFU cache)\\n    * @param cache: a hash map that has key to Node mapping, which used for storing all nodes by their keys\\n    * @param frequencyMap: a hash map that has key to linked list mapping, which used for storing all\\n    * double linked list by their frequencies\\n    * */\\n    public LFUCache(int capacity) {\\n        this.capacity = capacity;\\n        this.curSize = 0;\\n        this.minFrequency = 0;\\n\\n        this.cache = new HashMap<>();\\n        this.frequencyMap = new HashMap<>();\\n    }\\n\\n    /** get node value by key, and then update node frequency as well as relocate that node **/\\n    public int get(int key) {\\n        DLLNode curNode = cache.get(key);\\n        if (curNode == null) {\\n            return -1;\\n        }\\n        updateNode(curNode);\\n        return curNode.val;\\n    }\\n\\n    /**\\n     * add new node into LFU cache, as well as double linked list\\n     * condition 1: if LFU cache has input key, update node value and node position in list\\n     * condition 2: if LFU cache does NOT have input key\\n     *  - sub condition 1: if LFU cache does NOT have enough space, remove the Least Recent Used node\\n     *  in minimum frequency list, then add new node\\n     *  - sub condition 2: if LFU cache has enough space, add new node directly\\n     * **/\\n    public void put(int key, int value) {\\n        // corner case: check cache capacity initialization\\n        if (capacity == 0) {\\n            return;\\n        }\\n\\n        if (cache.containsKey(key)) {\\n            DLLNode curNode = cache.get(key);\\n            curNode.val = value;\\n            updateNode(curNode);\\n        }\\n        else {\\n            curSize++;\\n            if (curSize > capacity) {\\n                // get minimum frequency list\\n                DoubleLinkedList minFreqList = frequencyMap.get(minFrequency);\\n                cache.remove(minFreqList.tail.prev.key);\\n                minFreqList.removeNode(minFreqList.tail.prev);\\n                curSize--;\\n            }\\n            // reset min frequency to 1 because of adding new node\\n            minFrequency = 1;\\n            DLLNode newNode = new DLLNode(key, value);\\n\\n            // get the list with frequency 1, and then add new node into the list, as well as into LFU cache\\n            DoubleLinkedList curList = frequencyMap.getOrDefault(1, new DoubleLinkedList());\\n            curList.addNode(newNode);\\n            frequencyMap.put(1, curList);\\n            cache.put(key, newNode);\\n        }\\n    }\\n\\n    public void updateNode(DLLNode curNode) {\\n        int curFreq = curNode.frequency;\\n        DoubleLinkedList curList = frequencyMap.get(curFreq);\\n        curList.removeNode(curNode);\\n\\n        // if current list the the last list which has lowest frequency and current node is the only node in that list\\n        // we need to remove the entire list and then increase min frequency value by 1\\n        if (curFreq == minFrequency && curList.listSize == 0) {\\n            minFrequency++;\\n        }\\n\\n        curNode.frequency++;\\n        // add current node to another list has current frequency + 1,\\n        // if we do not have the list with this frequency, initialize it\\n        DoubleLinkedList newList = frequencyMap.getOrDefault(curNode.frequency, new DoubleLinkedList());\\n        newList.addNode(curNode);\\n        frequencyMap.put(curNode.frequency, newList);\\n    }\\n\\n    /*\\n    * @param key: node key\\n    * @param val: node value\\n    * @param frequency: frequency count of current node\\n    * (all nodes connected in same double linked list has same frequency)\\n    * @param prev: previous pointer of current node\\n    * @param next: next pointer of current node\\n    * */\\n    class DLLNode {\\n        int key;\\n        int val;\\n        int frequency;\\n        DLLNode prev;\\n        DLLNode next;\\n\\n        public DLLNode(int key, int val) {\\n            this.key = key;\\n            this.val = val;\\n            this.frequency = 1;\\n        }\\n    }\\n\\n    /*\\n    * @param listSize: current size of double linked list\\n    * @param head: head node of double linked list\\n    * @param tail: tail node of double linked list\\n    * */\\n    class DoubleLinkedList {\\n        int listSize;\\n        DLLNode head;\\n        DLLNode tail;\\n        public DoubleLinkedList() {\\n            this.listSize = 0;\\n            this.head = new DLLNode(0, 0);\\n            this.tail = new DLLNode(0, 0);\\n            head.next = tail;\\n            tail.prev = head;\\n        }\\n\\n        /** add new node into head of list and increase list size by 1 **/\\n        public void addNode(DLLNode curNode) {\\n            DLLNode nextNode = head.next;\\n            curNode.next = nextNode;\\n            curNode.prev = head;\\n            head.next = curNode;\\n            nextNode.prev = curNode;\\n            listSize++;\\n        }\\n\\n        /** remove input node and decrease list size by 1**/\\n        public void removeNode(DLLNode curNode) {\\n            DLLNode prevNode = curNode.prev;\\n            DLLNode nextNode = curNode.next;\\n            prevNode.next = nextNode;\\n            nextNode.prev = prevNode;\\n            listSize--;\\n        }\\n\\n    }\\n}\\n\\n/**\\n * Your LFUCache object will be instantiated and called as such:\\n * LFUCache obj = new LFUCache(capacity);\\n * int param_1 = obj.get(key);\\n * obj.put(key,value);\\n */\\n```",
        "level": "hard",
        "buggy_code": "\nclass LFUCache {\n\n    final int capacity;\n    int curSize;\n    int minFrequency;\n    Map<Integer, DLLNode> cache;\n    Map<Integer, DoubleLinkedList> frequencyMap;\n\n    /*.*/\n    /*\n    public LFUCache(int capacity) {\n        this.capacity = capacity;\n        this.curSize = 0;\n        this.minFrequency = 0;\n\n        this.cache = new HashMap<>;\n        this.frequencyMap = new HashMap<>();\n    }\n\n    public int get(int key) {\n        DLLNode curNode = cache.get(key);\n        if (curNode == null) {\n            return -1;\n        }\n        updateNode(curNode);\n        return curNode.val;\n    }\n    \n    public void put(int key, int value) {\n        if (capacity == 0) {\n            return;\n        }\n\n        if (cache.containsKey(key)) {\n            DLLNode curNode = cache.get(key);\n            curNode.val = value;\n            updateNode(curNode);\n        }\n        else {\n            curSize++;\n            if (curSize > capacity) {\n                DoubleLinkedList minFreqList = frequencyMap.get(minFrequency);\n                cache.remove(minFreqList.tail.prev.key);\n                minFreqList.removeNode(minFreqList.tail.prev);\n                curSize--;\n            }\n            minFrequency = 1;\n            DLLNode newNode = new DLLNode(key, value);\n\n            DoubleLinkedList curList = frequencyMap.getOrDefault(1, new DoubleLinkedList());\n            curList.addNode(newNode);\n            frequencyMap.put(1, curList);\n            cache.put(key, newNode);\n        }\n    }\n    \n    public void updateNode(DLLNode curNode) {\n        int curFreq = curNode.frequency;\n        DoubleLinkedList curList = frequencyMap.get(curFreq);\n        curList.removeNode(curNode);\n\n        if (curFreq == minFrequency && curList.listSize == 0) {\n            minFrequency++;\n        }\n\n        curNode.frequency++;\n        DoubleLinkedList newList = frequencyMap.getOrDefault(curNode.frequency, new DoubleLinkedList());\n        newList.addNode(curNode);\n        frequencyMap.put(curNode.frequency, newList);\n    }\n\n    class DLLNode {\n        int key;\n        int val;\n        int frequency;\n        DLLNode prev;\n        DLLNode next;\n\n        public DLLNode(int key, int val) {\n            this.key = key;\n            this.val = val;\n            this.frequency = 1;\n        }\n    }\n\n    class DoubleLinkedList {\n        int listSize;\n        DLLNode head;\n        DLLNode tail;\n        public DoubleLinkedList() {\n            this.listSize = 0;\n            this.head = new DLLNode(0, 0);\n            this.tail = new DLLNode(0, 0);\n            head.next = tail;\n            tail.prev = head;\n        }\n        \n        public void addNode(DLLNode curNode) {\n            DLLNode nextNode = head.next;\n            curNode.next = nextNode;\n            curNode.prev = head;\n            head.next = curNode;\n            nextNode.prev = curNode;\n            listSize++;\n        }\n        \n        public void removeNode(DLLNode curNode) {\n            DLLNode prevNode = curNode.prev;\n            DLLNode nextNode = curNode.next;\n            prevNode.next = nextNode;\n            nextNode.prev = prevNode;\n            listSize--;\n        }\n    }\n}\n\n/**\n * Your LFUCache object will be instantiated and called as such:\n * LFUCache obj = new LFUCache(capacity);\n * int param_1 = obj.get(key);\n * obj.put(key,value);\n */\n \n",
        "explanations": "\nSyntax error due to missing parenthesis after new HashMap at line 18 and 19.\n"
    },
    {
        "slug": "the-number-of-weak-characters-in-the-game",
        "description": "You are playing a game that contains multiple characters, and each of the characters has two main properties: attack and defense. You are given a 2D integer array properties where properties[i] = [attacki, defensei] represents the properties of the ith character in the game.\nA character is said to be weak if any other character has both attack and defense levels strictly greater than this character's attack and defense levels. More formally, a character i is said to be weak if there exists another character j where attackj > attacki and defensej > defensei.\nReturn the number of weak characters.",
        "examples": [
            "Input: properties = [[5,5],[6,3],[3,6]]\nOutput: 0\nExplanation: No character has strictly greater attack and defense than the other.",
            "Input: properties = [[2,2],[3,3]]\nOutput: 1\nExplanation: The first character is weak because the second character has a strictly greater attack and defense.",
            "Input: properties = [[1,5],[10,4],[4,3]]\nOutput: 1\nExplanation: The third character is weak because the second character has a strictly greater attack and defense."
        ],
        "constraints": "2 <= properties.length <= 105\nproperties[i].length == 2\n1 <= attacki, defensei <= 105",
        "release_time": 1662691692,
        "oracle_code": "class Solution {\n    public int numberOfWeakCharacters(int[][] properties) {\n        Arrays.sort(properties, (a,b) -> (a[0] == b[0]) ? (a[1]-b[1]) : (b[0]-a[0]));\n        int count = 0, max = 0;\n        for(int[] arr: properties){\n            if(arr[1] < max)    count++;\n            max = Math.max(max, arr[1]);\n        }\n        return count;\n    }\n}",
        "content": "**Time Complexity : O(n*logn)**\\n**Java**\\n```\\nclass Solution {\\n    public int numberOfWeakCharacters(int[][] properties) {\\n        Arrays.sort(properties, (a,b) -> (a[0] == b[0]) ? (a[1]-b[1]) : (b[0]-a[0]));\\n        int count = 0, max = 0;\\n        for(int[] arr: properties){\\n            if(arr[1] < max)    count++;\\n            max = Math.max(max, arr[1]);\\n        }\\n        return count;\\n    }\\n}\\n```\\n**JavaScript**\\n```\\nvar numberOfWeakCharacters = function(properties) {\\n    properties.sort((a,b) => (a[0] == b[0]) ? (a[1]-b[1]) : (b[0]-a[0]))\\n    let count = 0, max = 0\\n    for(let arr of properties){\\n        if(arr[1] < max)    count++\\n        max = Math.max(max, arr[1])\\n    }\\n    return count\\n};\\n```\\n**Python**\\n```\\nclass Solution(object):\\n    def numberOfWeakCharacters(self, properties):\\n        properties.sort(key = lambda x: (-x[0], x[1]))\\n        count, mx = 0, 0\\n        for arr in properties:\\n            if arr[1] < mx:\\n                count += 1\\n            mx = max(mx, arr[1])\\n        return count\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\n    public int numberOfWeakCharacters(int[][] properties) {\n        Arrays.sort(properties, (a,b) -> (a[0] == b[0]) ? (a[1]-b[1]) : (b[0]-a[0]))\n        int count = 0, max = 0;\n        for(int[] arr: properties){\n            if(arr[1] < max)    count++;\n            max = Math.max(max, arr[1]);\n        }\n        return count;\n    }\n}\n",
        "explanations": "\nMissing semicolon at the end of the Arrays.sort line causes syntax error.\n"
    },
    {
        "slug": "sum-of-mutated-array-closest-to-target",
        "description": "Given an integer array arr and a target value target, return the integer value such that when we change all the integers larger than value in the given array to be equal to value, the sum of the array gets as close as possible (in absolute difference) to target.\nIn case of a tie, return the minimum such integer.\nNotice that the answer is not neccesarilly a number from arr.",
        "examples": [
            "Input: arr = [4,9,3], target = 10\nOutput: 3\nExplanation: When using 3 arr converts to [3, 3, 3] which sums 9 and that's the optimal answer.",
            "Input: arr = [2,3,5], target = 10\nOutput: 5",
            "Input: arr = [60864,25176,27249,21296,20204], target = 56803\nOutput: 11361"
        ],
        "constraints": "1 <= arr.length <= 104\n1 <= arr[i], target <= 105",
        "release_time": 1680185953,
        "oracle_code": "class Solution {\n    public int findBestValue(int[] arr, int target) {\n      int n = arr.length;\n        int lo = 0, hi = 0;\n        for (int i = 0; i < n; i++) {\n            hi = Math.max(hi, arr[i]);\n        }\n        \n        while (lo < hi) {\n            int mid = lo + (hi - lo) / 2;\n            int sum = 0;\n            for (int i = 0; i < n; i++) {\n                sum += Math.min(arr[i], mid);\n            }\n            if (sum >= target) {\n                hi = mid;\n            } else {\n                lo = mid + 1;\n            }\n        }\n        \n        int sum1 = 0, sum2 = 0;\n        for (int i = 0; i < n; i++) {\n            sum1 += Math.min(arr[i], lo);\n            sum2 += Math.min(arr[i], lo - 1);\n        }\n        \n        return Math.abs(sum2 - target) <= Math.abs(sum1 - target) ? lo - 1 : lo;\n    }\n}",
        "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int findBestValue(int[] arr, int target) {\\n      int n = arr.length;\\n        int lo = 0, hi = 0;\\n        for (int i = 0; i < n; i++) {\\n            hi = Math.max(hi, arr[i]);\\n        }\\n        \\n        while (lo < hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            int sum = 0;\\n            for (int i = 0; i < n; i++) {\\n                sum += Math.min(arr[i], mid);\\n            }\\n            if (sum >= target) {\\n                hi = mid;\\n            } else {\\n                lo = mid + 1;\\n            }\\n        }\\n        \\n        int sum1 = 0, sum2 = 0;\\n        for (int i = 0; i < n; i++) {\\n            sum1 += Math.min(arr[i], lo);\\n            sum2 += Math.min(arr[i], lo - 1);\\n        }\\n        \\n        return Math.abs(sum2 - target) <= Math.abs(sum1 - target) ? lo - 1 : lo;\\n    }\\n}\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\n    public int findBestValue(int[] arr, int target) {\n      int n = arr.length;\n        int lo = 0, hi = 0;\n        for (int i = 0; i < n; i++) {\n            hi = Math.max(hi, arr[i]);\n        \n        while (lo < hi) {\n            int mid = lo + (hi - lo) / 2;\n            int sum = 0;\n            for (int i = 0; i < n; i++) {\n                sum += Math.min(arr[i], mid);\n            }\n            if (sum >= target) {\n                hi = mid;\n            } else {\n                lo = mid + 1;\n            }\n        }\n        \n        int sum1 = 0, sum2 = 0;\n        for (int i = 0; i < n; i++) {\n            sum1 += Math.min(arr[i], lo);\n            sum2 += Math.min(arr[i], lo - 1);\n        }\n        \n        return Math.abs(sum2 - target) <= Math.abs(sum1 - target) ? lo - 1 : lo;\n    }\n}\n",
        "explanations": "\nMissing a closing bracket in for-loop causes the rest of code to be unreachable.\n"
    },
    {
        "slug": "rotating-the-box",
        "description": "You are given an m x n matrix of characters box representing a side-view of a box. Each cell of the box is one of the following:\n\nA stone '#'\nA stationary obstacle '*'\nEmpty '.'\n\nThe box is rotated 90 degrees clockwise, causing some of the stones to fall due to gravity. Each stone falls down until it lands on an obstacle, another stone, or the bottom of the box. Gravity does not affect the obstacles' positions, and the inertia from the box's rotation does not affect the stones' horizontal positions.\nIt is guaranteed that each stone in box rests on an obstacle, another stone, or the bottom of the box.\nReturn an n x m matrix representing the box after the rotation described above.",
        "examples": [
            "Input: box = [[\"#\",\".\",\"#\"]]\r\nOutput: [[\".\"],\r\n\u00a0        [\"#\"],\r\n\u00a0        [\"#\"]]",
            "Input: box = [[\"#\",\".\",\"*\",\".\"],\r\n\u00a0             [\"#\",\"#\",\"*\",\".\"]]\r\nOutput: [[\"#\",\".\"],\r\n\u00a0        [\"#\",\"#\"],\r\n\u00a0        [\"*\",\"*\"],\r\n\u00a0        [\".\",\".\"]]",
            "Input: box = [[\"#\",\"#\",\"*\",\".\",\"*\",\".\"],\r\n\u00a0             [\"#\",\"#\",\"#\",\"*\",\".\",\".\"],\r\n\u00a0             [\"#\",\"#\",\"#\",\".\",\"#\",\".\"]]\r\nOutput: [[\".\",\"#\",\"#\"],\r\n\u00a0        [\".\",\"#\",\"#\"],\r\n\u00a0        [\"#\",\"#\",\"*\"],\r\n\u00a0        [\"#\",\"*\",\".\"],\r\n\u00a0        [\"#\",\".\",\"*\"],\r\n\u00a0        [\"#\",\".\",\".\"]]"
        ],
        "constraints": "m == box.length\nn == box[i].length\n1 <= m, n <= 500\nbox[i][j] is either '#', '*', or '.'.",
        "release_time": 1621094749,
        "oracle_code": "// O(n^2) time | O(n^2) space\nclass Solution {\n    public char[][] rotateTheBox(char[][] box) {\n        int m = box.length;\n        int n = box[0].length;\n        char[][] matrix = new char[n][m];   \n        \n        turnBox(box, matrix, m, n); // turn the box clockwise 90 degree\n        \n        turnGravity(matrix, n, m); // cause that falling effect, since matrix turned so n,m\n        \n        return matrix;\n    }\n    \n    public void turnGravity(char[][] matrix, int m, int n){\n        for(int c = 0; c < n; c++){\n            int last  = m-1;\n            for(int r = m-1; r >= 0; r--){\n                char val =  matrix[r][c];\n                if(val == '.') continue;\n                if(val == '*') last = r-1;\n                if(val == '#') {\n                    matrix[r][c] = '.';\n                    matrix[last][c] = '#';\n                    last--;\n                }\n            }\n        }\n    }\n    \n    public void turnBox(char[][] box, char[][] matrix, int m, int n){\n\t// numbers represents sequence it would be copied\n\t//[4][1]\n\t//[5][2]\n\t//[6][3]\n        for(int i = 0, c = m-1; i < m; i++,c--){ // c: 4,3,2,1..\n            for(int j = 0, r = 0; j < n; j++, r++){ // r:0,1,2,3..\n               matrix[r][c] = box[i][j];\n            }\n        }\n    }\n}",
        "content": "**So idea here is**\\n1. First turn 90 degree\\n2. Make things fall\\n\\n```\\n// O(n^2) time | O(n^2) space\\nclass Solution {\\n    public char[][] rotateTheBox(char[][] box) {\\n        int m = box.length;\\n        int n = box[0].length;\\n        char[][] matrix = new char[n][m];   \\n        \\n        turnBox(box, matrix, m, n); // turn the box clockwise 90 degree\\n        \\n        turnGravity(matrix, n, m); // cause that falling effect, since matrix turned so n,m\\n        \\n        return matrix;\\n    }\\n    \\n    public void turnGravity(char[][] matrix, int m, int n){\\n        for(int c = 0; c < n; c++){\\n            int last  = m-1;\\n            for(int r = m-1; r >= 0; r--){\\n                char val =  matrix[r][c];\\n                if(val == \\'.\\') continue;\\n                if(val == \\'*\\') last = r-1;\\n                if(val == \\'#\\') {\\n                    matrix[r][c] = \\'.\\';\\n                    matrix[last][c] = \\'#\\';\\n                    last--;\\n                }\\n            }\\n        }\\n    }\\n    \\n    public void turnBox(char[][] box, char[][] matrix, int m, int n){\\n\\t// numbers represents sequence it would be copied\\n\\t//[4][1]\\n\\t//[5][2]\\n\\t//[6][3]\\n        for(int i = 0, c = m-1; i < m; i++,c--){ // c: 4,3,2,1..\\n            for(int j = 0, r = 0; j < n; j++, r++){ // r:0,1,2,3..\\n               matrix[r][c] = box[i][j];\\n            }\\n        }\\n    }\\n}\\n```",
        "level": "medium",
        "buggy_code": "\n// O(n^2) time | O(n^2) space\nclass Solution {\n    public char[][] rotateTheBox(char[][] box) {\n        int m = box.length;\n        int n = box[0].length;\n        char[][] matrix = new char[n][m]   \n        \n        turnBox(box, matrix, m, n); // turn the box clockwise 90 degree\n        \n        turnGravity(matrix, n, m); // cause that falling effect, since matrix turned so n,m\n        \n        return matrix;\n    }\n    \n    public void turnGravity(char[][] matrix, int m, int n){\n        for(int c = 0; c < n; c++){\n            int last  = m-1;\n            for(int r = m-1; r >= 0; r--){\n                char val =  matrix[r][c];\n                if(val == '.') continue;\n                if(val == '*') last = r-1;\n                if(val == '#') {\n                    matrix[r][c] = '.';\n                    matrix[last][c] = '#';\n                    last--;\n                }\n            }\n        }\n    }\n    \n    public void turnBox(char[][] box, char[][] matrix, int m, int n){\n\t// numbers represents sequence it would be copied\n\t//[4][1]\n\t//[5][2]\n\t//[6][3]\n        for(int i = 0, c = m-1; i < m; i++,c--){ // c: 4,3,2,1..\n            for(int j = 0, r = 0; j < n; j++, r++){ // r:0,1,2,3..\n               matrix[r][c] = box[i][j];\n            }\n        }\n    }\n}\n",
        "explanations": "\nThe missing semicolon after initializing `char[][] matrix` causes a syntax error.\n"
    },
    {
        "slug": "minimum-score-triangulation-of-polygon",
        "description": "You have a convex n-sided polygon where each vertex has an integer value. You are given an integer array values where values[i] is the value of the ith vertex (i.e., clockwise order).\nYou will triangulate the polygon into n - 2 triangles. For each triangle, the value of that triangle is the product of the values of its vertices, and the total score of the triangulation is the sum of these values over all n - 2 triangles in the triangulation.\nReturn the smallest possible total score that you can achieve with some triangulation of the polygon.",
        "examples": [
            "Input: values = [1,2,3]\nOutput: 6\nExplanation: The polygon is already triangulated, and the score of the only triangle is 6.",
            "Input: values = [3,7,4,5]\nOutput: 144\nExplanation: There are two triangulations, with possible scores: 3*7*5 + 4*5*7 = 245, or 3*4*5 + 3*4*7 = 144.\nThe minimum score is 144.",
            "Input: values = [1,3,1,4,1,5]\nOutput: 13\nExplanation: The minimum score triangulation has score 1*1*3 + 1*1*4 + 1*1*5 + 1*1*1 = 13."
        ],
        "constraints": "n == values.length\n3 <= n <= 50\n1 <= values[i] <= 100",
        "release_time": 1682753898,
        "oracle_code": "class Solution {\n    int[][] dp;\n    public int minScoreTriangulation(int[] values) {\n        int l=values.length;\n        dp = new int[l][l];\n        for(int[] i : dp) Arrays.fill(i,-1);\n        return solve(values,1,l-1); \n    }\n\n    public int solve(int[] values, int i,int j)\n    {\n        if(i>=j) return 0;\n        if(dp[i][j]!=-1) return dp[i][j];\n        int min=Integer.MAX_VALUE;\n        for(int k=i;k<j;k++)\n        {\n            int temp=solve(values,i,k)+solve(values,k+1,j)+\n                        values[i-1]*values[k]*values[j];\n            min=Math.min(min,temp);\n        }\n\n        return dp[i][j]=min;\n    }\n}",
        "content": "\\n# Complexity\\n- Time complexity: n^2\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: n^2\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int[][] dp;\\n    public int minScoreTriangulation(int[] values) {\\n        int l=values.length;\\n        dp = new int[l][l];\\n        for(int[] i : dp) Arrays.fill(i,-1);\\n        return solve(values,1,l-1); \\n    }\\n\\n    public int solve(int[] values, int i,int j)\\n    {\\n        if(i>=j) return 0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int min=Integer.MAX_VALUE;\\n        for(int k=i;k<j;k++)\\n        {\\n            int temp=solve(values,i,k)+solve(values,k+1,j)+\\n                        values[i-1]*values[k]*values[j];\\n            min=Math.min(min,temp);\\n        }\\n\\n        return dp[i][j]=min;\\n    }\\n}\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\n    int[][] dp;\n    public int minScoreTriangulation(int[] values) {\n        int l=values.length;\n        dp = new int[l][l];\n        for int[] i : dp) Arrays.fill(i,-1);\n        return solve(values,1,l-1); \n    }\n\n    public int solve(int[] values, int i,int j)\n    {\n        if(i>=j) return 0;\n        if(dp[i][j]!=-1) return dp[i][j];\n        int min=Integer.MAX_VALUE;\n        for(int k=i;k<j;k++)\n        {\n            int temp=solve(values,i,k)+solve(values,k+1,j)+\n                        values[i-1]*values[k]*values[j];\n            min=Math.min(min,temp);\n        }\n\n        return dp[i][j]=min;\n    }\n}\n",
        "explanations": "\nMissing a colon in the for-each loop of the minScoreTriangulation method.\n"
    },
    {
        "slug": "binary-search-tree-iterator",
        "description": "Implement the BSTIterator class that represents an iterator over the in-order traversal of a binary search tree (BST):\n\nBSTIterator(TreeNode root) Initializes an object of the BSTIterator class. The root of the BST is given as part of the constructor. The pointer should be initialized to a non-existent number smaller than any element in the BST.\nboolean hasNext() Returns true if there exists a number in the traversal to the right of the pointer, otherwise returns false.\nint next() Moves the pointer to the right, then returns the number at the pointer.\n\nNotice that by initializing the pointer to a non-existent smallest number, the first call to next() will return the smallest element in the BST.\nYou may assume that next() calls will always be valid. That is, there will be at least a next number in the in-order traversal when next() is called.",
        "examples": [
            "Input\n[\"BSTIterator\", \"next\", \"next\", \"hasNext\", \"next\", \"hasNext\", \"next\", \"hasNext\", \"next\", \"hasNext\"]\n[[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []]\nOutput\n[null, 3, 7, true, 9, true, 15, true, 20, false]\n\nExplanation\nBSTIterator bSTIterator = new BSTIterator([7, 3, 15, null, null, 9, 20]);\nbSTIterator.next();    // return 3\nbSTIterator.next();    // return 7\nbSTIterator.hasNext(); // return True\nbSTIterator.next();    // return 9\nbSTIterator.hasNext(); // return True\nbSTIterator.next();    // return 15\nbSTIterator.hasNext(); // return True\nbSTIterator.next();    // return 20\nbSTIterator.hasNext(); // return False"
        ],
        "constraints": "The number of nodes in the tree is in the range [1, 105].\n0 <= Node.val <= 106\nAt most 105 calls will be made to hasNext, and next.",
        "release_time": 1678076629,
        "oracle_code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass BSTIterator {\n\n    List<Integer> l;\n    int len;\n    int curr;\n\n    public BSTIterator(TreeNode root) {\n        BST1 B = new BST1();\n        B.inOrder(root);\n        this.l = B.l;\n        len = this.l.size();\n        this.curr = 0;\n\n    }\n\n    public int next() {\n        int data = -1;\n        if (curr < len) {\n            data = l.get(curr);\n            curr++;\n        }\n\n        return data;\n\n    }\n\n    public boolean hasNext() {\n        return curr < len;\n\n    }\n}\n\nclass BST1 {\n\n    List<Integer> l = new ArrayList<>();\n\n    public void inOrder(TreeNode root) {\n        if (root == null) {\n            return;\n        }\n        inOrder(root.left);\n        l.add(root.val);\n        inOrder(root.right);\n    }\n}\n\n/**\n * Your BSTIterator object will be instantiated and called as such:\n * BSTIterator obj = new BSTIterator(root);\n * int param_1 = obj.next();\n * boolean param_2 = obj.hasNext();\n */",
        "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass BSTIterator {\\n\\n    List<Integer> l;\\n    int len;\\n    int curr;\\n\\n    public BSTIterator(TreeNode root) {\\n        BST1 B = new BST1();\\n        B.inOrder(root);\\n        this.l = B.l;\\n        len = this.l.size();\\n        this.curr = 0;\\n\\n    }\\n\\n    public int next() {\\n        int data = -1;\\n        if (curr < len) {\\n            data = l.get(curr);\\n            curr++;\\n        }\\n\\n        return data;\\n\\n    }\\n\\n    public boolean hasNext() {\\n        return curr < len;\\n\\n    }\\n}\\n\\nclass BST1 {\\n\\n    List<Integer> l = new ArrayList<>();\\n\\n    public void inOrder(TreeNode root) {\\n        if (root == null) {\\n            return;\\n        }\\n        inOrder(root.left);\\n        l.add(root.val);\\n        inOrder(root.right);\\n    }\\n}\\n\\n/**\\n * Your BSTIterator object will be instantiated and called as such:\\n * BSTIterator obj = new BSTIterator(root);\\n * int param_1 = obj.next();\\n * boolean param_2 = obj.hasNext();\\n */\\n```",
        "level": "medium",
        "buggy_code": "\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass BSTIterator {\n\n    List<Integer> l;\n    int len;\n    int curr;\n\n    public BSTIterator(TreeNode root) {\n        BST1 B = new BST1()\n        B.inOrder(root);\n        this.l = B.l;\n        len = this.l.size();\n        this.curr = 0;\n\n    }\n\n    public int next() {\n        int data = -1;\n        if (curr < len) {\n            data = l.get(curr);\n            curr++;\n        }\n\n        return data;\n\n    }\n\n    public boolean hasNext() {\n        return curr < len;\n\n    }\n}\n\nclass BST1 {\n\n    List<Integer> l = new ArrayList<>();\n\n    public void inOrder(TreeNode root) {\n        if (root == null) {\n            return;\n        }\n        inOrder(root.left);\n        l.add(root.val);\n        inOrder(root.right);\n    }\n}\n\n/**\n * Your BSTIterator object will be instantiated and called as such:\n * BSTIterator obj = new BSTIterator(root);\n * int param_1 = obj.next();\n * boolean param_2 = obj.hasNext();\n */\n",
        "explanations": "\nA missing semicolon after instantiating BST1 class in the BSTIterator constructor causes a syntax error.\n"
    },
    {
        "slug": "merge-two-2d-arrays-by-summing-values",
        "description": "You are given two 2D integer arrays nums1 and nums2.\n\nnums1[i] = [idi, vali]\u00a0indicate that the number with the id idi has a value equal to vali.\nnums2[i] = [idi, vali]\u00a0indicate that the number with the id idi has a value equal to vali.\n\nEach array contains unique ids and is sorted in ascending order by id.\nMerge the two arrays into one array that is sorted in ascending order by id, respecting the following conditions:\n\nOnly ids that appear in at least one of the two arrays should be included in the resulting array.\nEach id should be included only once and its value should be the sum of the values of this id in the two arrays. If the id does not exist in one of the two arrays then its value in that array is considered to be 0.\n\nReturn the resulting array. The returned array must be sorted in ascending order by id.",
        "examples": [
            "Input: nums1 = [[1,2],[2,3],[4,5]], nums2 = [[1,4],[3,2],[4,1]]\nOutput: [[1,6],[2,3],[3,2],[4,6]]\nExplanation: The resulting array contains the following:\n- id = 1, the value of this id is 2 + 4 = 6.\n- id = 2, the value of this id is 3.\n- id = 3, the value of this id is 2.\n- id = 4, the value of this id is 5 + 1 = 6.",
            "Input: nums1 = [[2,4],[3,6],[5,5]], nums2 = [[1,3],[4,3]]\nOutput: [[1,3],[2,4],[3,6],[4,3],[5,5]]\nExplanation: There are no common ids, so we just include each id with its value in the resulting list."
        ],
        "constraints": "1 <= nums1.length, nums2.length <= 200\nnums1[i].length == nums2[j].length == 2\n1 <= idi, vali <= 1000\nBoth arrays contain unique ids.\nBoth arrays are in\u00a0strictly ascending order by id.",
        "release_time": 1677788157,
        "oracle_code": "class Solution {\n    public int[][] mergeArrays(int[][] nums1, int[][] nums2) {\n        \n        Map<Integer, Integer> map = new TreeMap<>();\n        int l1 = nums1.length;\n        int l2 = nums2.length;\n\n        for (int i = 0; i < l1; i++) {\n            if (!map.containsKey(nums1[i][0])) {\n                map.put(nums1[i][0], nums1[i][1]);\n            }\n            else {\n                map.put(nums1[i][0], (map.get(nums1[i][0]) + nums1[i][1]));\n            }\n            \n        }\n\n        for (int i = 0; i < l2; i++) {\n            if (!map.containsKey(nums2[i][0])) {\n                map.put(nums2[i][0], nums2[i][1]);\n            }\n            else {\n                map.put(nums2[i][0], (map.get(nums2[i][0]) + nums2[i][1]));\n            }\n            \n        }\n\n        int count = 0;\n        int[][] ans = new int[map.size()][2];\n\n        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {\n            ans[count][0] = entry.getKey();\n            ans[count][1] = entry.getValue();\n            count++;\n        }\n        \n        return ans;\n    }\n}",
        "content": "# Java\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] mergeArrays(int[][] nums1, int[][] nums2) {\\n        \\n        Map<Integer, Integer> map = new TreeMap<>();\\n        int l1 = nums1.length;\\n        int l2 = nums2.length;\\n\\n        for (int i = 0; i < l1; i++) {\\n            if (!map.containsKey(nums1[i][0])) {\\n                map.put(nums1[i][0], nums1[i][1]);\\n            }\\n            else {\\n                map.put(nums1[i][0], (map.get(nums1[i][0]) + nums1[i][1]));\\n            }\\n            \\n        }\\n\\n        for (int i = 0; i < l2; i++) {\\n            if (!map.containsKey(nums2[i][0])) {\\n                map.put(nums2[i][0], nums2[i][1]);\\n            }\\n            else {\\n                map.put(nums2[i][0], (map.get(nums2[i][0]) + nums2[i][1]));\\n            }\\n            \\n        }\\n\\n        int count = 0;\\n        int[][] ans = new int[map.size()][2];\\n\\n        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {\\n            ans[count][0] = entry.getKey();\\n            ans[count][1] = entry.getValue();\\n            count++;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\n    public int[][] mergeArrays(int[][] nums1, int[][] nums2) {\n        \n        Map<Integer, Integer> map = new TreeMap<>();\n        int l1 = nums1.length;\n        int l2 = nums2.length;\n\n        for (int i = 0; i < l1; i++) {\n            if (!map.containsKey(nums1[i][0])) {\n                map.put(nums1[i][0], nums1[i][1]);\n            }\n            else {\n                map.put(nums1[i][0], (map.get(nums1[i][0]) + nums1[i][1]));\n            }\n            \n        }\n\n        for (int i = 0; i < l2 i++) {\n            if (!map.containsKey(nums2[i][0])) {\n                map.put(nums2[i][0], nums2[i][1]);\n            }\n            else {\n                map.put(nums2[i][0], (map.get(nums2[i][0]) + nums2[i][1]));\n            }\n            \n        }\n\n        int count = 0;\n        int[][] ans = new int[map.size()][2];\n\n        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {\n            ans[count][0] = entry.getKey();\n            ans[count][1] = entry.getValue();\n            count++;\n        }\n        \n        return ans;\n    }\n}\n",
        "explanations": "\nThe bug is in the second for loop where the increment operator (++) is missed after l2. \n"
    },
    {
        "slug": "apply-discount-every-n-orders",
        "description": "There is a supermarket that is frequented by many customers. The products sold at the supermarket are represented as two parallel integer arrays products and prices, where the ith product has an ID of products[i] and a price of prices[i].\nWhen a customer is paying, their bill is represented as two parallel integer arrays product and amount, where the jth product they purchased has an ID of product[j], and amount[j] is how much of the product they bought. Their subtotal is calculated as the sum of each amount[j] * (price of the jth product).\nThe supermarket decided to have a sale. Every nth customer paying for their groceries will be given a percentage discount. The discount amount is given by discount, where they will be given discount percent off their subtotal. More formally, if their subtotal is bill, then they would actually pay bill * ((100 - discount) / 100).\nImplement the Cashier class:\n\nCashier(int n, int discount, int[] products, int[] prices) Initializes the object with n, the discount, and the products and their prices.\ndouble getBill(int[] product, int[] amount) Returns the final total of the bill with the discount applied (if any). Answers within 10-5 of the actual value will be accepted.",
        "examples": [
            "Input\n[\"Cashier\",\"getBill\",\"getBill\",\"getBill\",\"getBill\",\"getBill\",\"getBill\",\"getBill\"]\n[[3,50,[1,2,3,4,5,6,7],[100,200,300,400,300,200,100]],[[1,2],[1,2]],[[3,7],[10,10]],[[1,2,3,4,5,6,7],[1,1,1,1,1,1,1]],[[4],[10]],[[7,3],[10,10]],[[7,5,3,1,6,4,2],[10,10,10,9,9,9,7]],[[2,3,5],[5,3,2]]]\nOutput\n[null,500.0,4000.0,800.0,4000.0,4000.0,7350.0,2500.0]\nExplanation\nCashier cashier = new Cashier(3,50,[1,2,3,4,5,6,7],[100,200,300,400,300,200,100]);\ncashier.getBill([1,2],[1,2]);                        // return 500.0. 1st customer, no discount.\n                                                     // bill = 1 * 100 + 2 * 200 = 500.\ncashier.getBill([3,7],[10,10]);                      // return 4000.0. 2nd customer, no discount.\n                                                     // bill = 10 * 300 + 10 * 100 = 4000.\ncashier.getBill([1,2,3,4,5,6,7],[1,1,1,1,1,1,1]);    // return 800.0. 3rd customer, 50% discount.\n                                                     // Original bill = 1600\n                                                     // Actual bill = 1600 * ((100 - 50) / 100) = 800.\ncashier.getBill([4],[10]);                           // return 4000.0. 4th customer, no discount.\ncashier.getBill([7,3],[10,10]);                      // return 4000.0. 5th customer, no discount.\ncashier.getBill([7,5,3,1,6,4,2],[10,10,10,9,9,9,7]); // return 7350.0. 6th customer, 50% discount.\n                                                     // Original bill = 14700, but with\n                                                     // Actual bill = 14700 * ((100 - 50) / 100) = 7350.\ncashier.getBill([2,3,5],[5,3,2]);                    // return 2500.0.  7th customer, no discount."
        ],
        "constraints": "1 <= n <= 104\n0 <= discount <= 100\n1 <= products.length <= 200\nprices.length == products.length\n1 <= products[i] <= 200\n1 <= prices[i] <= 1000\nThe elements in products are unique.\n1 <= product.length <= products.length\namount.length == product.length\nproduct[j] exists in products.\n1 <= amount[j] <= 1000\nThe elements of product are unique.\nAt most 1000 calls will be made to getBill.\nAnswers within 10-5 of the actual value will be accepted.",
        "release_time": 1672208305,
        "oracle_code": "class Cashier {\n    HashMap<Integer,Integer>stock=new HashMap<>();\n    int n;\n    int discount;\n    int itr=0;\n    public Cashier(int n, int discount, int[] products, int[] prices) {\n        for(int i=0;i<products.length;i++){\n            stock.put(products[i],prices[i]);\n        }\n        this.n=n;\n        this.discount=discount;\n    }\n    \n    public double getBill(int[] product, int[] amount) {\n        double total=0;\n        for(int i=0;i<product.length;i++){\n            total+=(double)(amount[i]*stock.get(product[i]));\n        }\n        itr++;\n        if(itr==n){\n            total*=(double)(((100-discount)/100d));\n            itr=0;\n        }\n        return total;\n    }\n}\n\n/**\n * Your Cashier object will be instantiated and called as such:\n * Cashier obj = new Cashier(n, discount, products, prices);\n * double param_1 = obj.getBill(product,amount);\n */",
        "content": "# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Cashier {\\n    HashMap<Integer,Integer>stock=new HashMap<>();\\n    int n;\\n    int discount;\\n    int itr=0;\\n    public Cashier(int n, int discount, int[] products, int[] prices) {\\n        for(int i=0;i<products.length;i++){\\n            stock.put(products[i],prices[i]);\\n        }\\n        this.n=n;\\n        this.discount=discount;\\n    }\\n    \\n    public double getBill(int[] product, int[] amount) {\\n        double total=0;\\n        for(int i=0;i<product.length;i++){\\n            total+=(double)(amount[i]*stock.get(product[i]));\\n        }\\n        itr++;\\n        if(itr==n){\\n            total*=(double)(((100-discount)/100d));\\n            itr=0;\\n        }\\n        return total;\\n    }\\n}\\n\\n/**\\n * Your Cashier object will be instantiated and called as such:\\n * Cashier obj = new Cashier(n, discount, products, prices);\\n * double param_1 = obj.getBill(product,amount);\\n */\\n```",
        "level": "medium",
        "buggy_code": "\nclass Cashier {\n    HashMap<Integer,Integer>stock=new HashMap<>();\n    int n;\n    int discount;\n    int itr=0;\n    public Cashier(int n, int discount, int[] products, int[] prices) {\n        for(int i=0;i<products.length;i++)\n            stock.put(products[i],prices[i]);\n        }\n        this.n=n;\n        this.discount=discount;\n    }\n    \n    public double getBill(int[] product, int[] amount) {\n        double total=0;\n        for(int i=0;i<product.length;i++)\n            total+=(double)(amount[i]*stock.get(product[i]));\n        }\n        itr++;\n        if(itr==n)\n            total*=(double)(((100-discount)/100d));\n            itr=0;\n        }\n        return total;\n    }\n}\n\n/**\n * Your Cashier object will be instantiated and called as such:\n * Cashier obj = new Cashier(n, discount, products, prices);\n * double param_1 = obj.getBill(product,amount);\n */\n",
        "explanations": "\nCode blocks are not properly structured with the '{' and '}' symbols causing errors.\n"
    },
    {
        "slug": "relative-sort-array",
        "description": "Given two arrays arr1 and arr2, the elements of arr2 are distinct, and all elements in arr2 are also in arr1.\nSort the elements of arr1 such that the relative ordering of items in arr1 are the same as in arr2. Elements that do not appear in arr2 should be placed at the end of arr1 in ascending order.",
        "examples": [
            "Input: arr1 = [2,3,1,3,2,4,6,7,9,2,19], arr2 = [2,1,4,3,9,6]\nOutput: [2,2,2,1,4,3,3,9,6,7,19]",
            "Input: arr1 = [28,6,22,8,44,17], arr2 = [22,28,8,6]\nOutput: [22,28,8,6,17,44]"
        ],
        "constraints": "1 <= arr1.length, arr2.length <= 1000\n0 <= arr1[i], arr2[i] <= 1000\nAll the elements of arr2 are distinct.\nEach\u00a0arr2[i] is in arr1.",
        "release_time": 1691725804,
        "oracle_code": "import java.util.Arrays;\n\nclass Solution {\n    public int[] relativeSortArray(int[] arr1, int[] arr2) {\n        Arrays.sort(arr1);\n        int[] ans = new int[arr1.length];\n        int start = 0;\n        int end = arr1.length - 1;\n        int index = 0;\n\n        for (int i = 0; i < arr2.length; i++) {\n            int target = arr2[i];\n            start = 0;\n            end = arr1.length - 1;\n\n            while (end >= start) {\n                int mid = start + (end - start) / 2;\n                if (arr1[mid] == target) {\n                    for (int j = start; j <= end; j++) {\n                        if (arr1[j] == target) {\n                            ans[index++] = arr1[j];\n                        }\n                    }\n                    break;\n                }\n                if (arr1[mid] < target) {\n                    start = mid + 1;\n                } else {\n                    end = mid - 1;\n                }\n            }\n        }\n\n        for (int i = 0; i < arr1.length; i++) {\n            if (index == arr1.length) {\n                break;\n            }\n            boolean found = false;\n            for (int num : arr2) {\n                if (arr1[i] == num) {\n                    found = true;\n                    break;\n                }\n            }\n            if (!found) {\n                ans[index++] = arr1[i];\n            }\n        }\n\n        return ans;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.util.Arrays;\\n\\nclass Solution {\\n    public int[] relativeSortArray(int[] arr1, int[] arr2) {\\n        Arrays.sort(arr1);\\n        int[] ans = new int[arr1.length];\\n        int start = 0;\\n        int end = arr1.length - 1;\\n        int index = 0;\\n\\n        for (int i = 0; i < arr2.length; i++) {\\n            int target = arr2[i];\\n            start = 0;\\n            end = arr1.length - 1;\\n\\n            while (end >= start) {\\n                int mid = start + (end - start) / 2;\\n                if (arr1[mid] == target) {\\n                    for (int j = start; j <= end; j++) {\\n                        if (arr1[j] == target) {\\n                            ans[index++] = arr1[j];\\n                        }\\n                    }\\n                    break;\\n                }\\n                if (arr1[mid] < target) {\\n                    start = mid + 1;\\n                } else {\\n                    end = mid - 1;\\n                }\\n            }\\n        }\\n\\n        for (int i = 0; i < arr1.length; i++) {\\n            if (index == arr1.length) {\\n                break;\\n            }\\n            boolean found = false;\\n            for (int num : arr2) {\\n                if (arr1[i] == num) {\\n                    found = true;\\n                    break;\\n                }\\n            }\\n            if (!found) {\\n                ans[index++] = arr1[i];\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n\\n```",
        "level": "easy",
        "buggy_code": "\nimport java.util.Arrays;\n\nclass Solution {\n    public int[] relativeSortArray(int[] arr1, int[] arr2) {\n        Arrays.sort(arr1)\n        int[] ans = new int[arr1.length];\n        int start = 0;\n        int end = arr1.length - 1;\n        int index = 0;\n\n        for (int i = 0; i < arr2.length; i++) {\n            int target = arr2[i];\n            start = 0;\n            end = arr1.length - 1;\n\n            while (end >= start) {\n                int mid = start + (end - start) / 2;\n                if (arr1[mid] == target) {\n                    for (int j = start; j <= end; j++) {\n                        if (arr1[j] == target) {\n                            ans[index++] = arr1[j];\n                        }\n                    }\n                    break;\n                }\n                if (arr1[mid] < target) {\n                    start = mid + 1;\n                } else {\n                    end = mid - 1;\n                }\n            }\n        }\n\n        for (int i = 0; i < arr1.length; i++) {\n            if (index == arr1.length) {\n                break;\n            }\n            boolean found = false;\n            for (int num : arr2) {\n                if (arr1[i] == num) {\n                    found = true;\n                    break;\n                }\n            }\n            if (!found) {\n                ans[index++] = arr1[i];\n            }\n        }\n\n        return ans;\n    }\n}\n",
        "explanations": "\nOmitted a semicolon at the end of the line sorting the arr1 array.\n"
    },
    {
        "slug": "probability-of-a-two-boxes-having-the-same-number-of-distinct-balls",
        "description": "Given 2n balls of k distinct colors. You will be given an integer array balls of size k where balls[i] is the number of balls of color i.\nAll the balls will be shuffled uniformly at random, then we will distribute the first n balls to the first box and the remaining n balls to the other box (Please read the explanation of the second example carefully).\nPlease note that the two boxes are considered different. For example, if we have two balls of colors a and b, and two boxes [] and (), then the distribution [a] (b) is considered different than the distribution [b] (a) (Please read the explanation of the first example carefully).\nReturn the probability that the two boxes have the same number of distinct balls. Answers within 10-5 of the actual value will be accepted as correct.",
        "examples": [
            "Input: balls = [1,1]\nOutput: 1.00000\nExplanation: Only 2 ways to divide the balls equally:\n- A ball of color 1 to box 1 and a ball of color 2 to box 2\n- A ball of color 2 to box 1 and a ball of color 1 to box 2\nIn both ways, the number of distinct colors in each box is equal. The probability is 2/2 = 1",
            "Input: balls = [2,1,1]\nOutput: 0.66667\nExplanation: We have the set of balls [1, 1, 2, 3]\nThis set of balls will be shuffled randomly and we may have one of the 12 distinct shuffles with equal probability (i.e. 1/12):\n[1,1 / 2,3], [1,1 / 3,2], [1,2 / 1,3], [1,2 / 3,1], [1,3 / 1,2], [1,3 / 2,1], [2,1 / 1,3], [2,1 / 3,1], [2,3 / 1,1], [3,1 / 1,2], [3,1 / 2,1], [3,2 / 1,1]\nAfter that, we add the first two balls to the first box and the second two balls to the second box.\nWe can see that 8 of these 12 possible random distributions have the same number of distinct colors of balls in each box.\nProbability is 8/12 = 0.66667",
            "Input: balls = [1,2,1,2]\nOutput: 0.60000\nExplanation: The set of balls is [1, 2, 2, 3, 4, 4]. It is hard to display all the 180 possible random shuffles of this set but it is easy to check that 108 of them will have the same number of distinct colors in each box.\nProbability = 108 / 180 = 0.6"
        ],
        "constraints": "1 <= balls.length <= 8\n1 <= balls[i] <= 6\nsum(balls) is even.",
        "release_time": 1689418968,
        "oracle_code": "class Solution {\n    double possible = 0.0;\n    double valid = 0.0;\n    \n    public double getProbability(int[] balls) {\n        int[] first = new int[balls.length];\n        int[] second = new int[balls.length];\n        dfs(balls, first, second, 0, 0, 0);\n        return valid / possible;\n    }\n    \n    private void dfs(int[] balls, int[] first, int[] second, int num1, int num2, int idx) {\n        // finish all colors, check if this's a possible/valid distribution\n        if (idx == balls.length) {\n            // find one possible distribution\n            if (num1 == num2) {\n                // compute fake permutation\n                double distrib = permFake(first) * permFake(second);\n                possible += distrib;\n                \n                // find one valid distribution\n                if (unique(first) == unique(second)) {\n                    valid += distrib;\n                }\n            }\n            return;\n        }\n        \n        // distribute balls in current color to two bins\n        for (int b = 0; b <= balls[idx]; b++) {\n            first[idx] = b;\n            second[idx] = balls[idx] - b;\n            dfs (balls, first, second, num1 + first[idx], num2 + second[idx], idx + 1);\n        }\n    }\n    \n    // unique colors in \n    private int unique(int[] balls) {\n        int unique = 0;\n        for (int b: balls)\n            unique += b > 0 ? 1 : 0;\n        return unique;\n    }\n    \n    // return 1 / (b1!b2!b3!...bn!) \n    private double permFake(int[] balls) {\n        double ret = 1.0;\n        for (int b: balls)\n            ret /= factorial(b);\n        return ret;\n    }\n    \n    private int factorial(int n){\n        int ret = 1;\n        while (n > 0) {\n            ret *= n;\n            n--;\n        }\n        return ret;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    double possible = 0.0;\\n    double valid = 0.0;\\n    \\n    public double getProbability(int[] balls) {\\n        int[] first = new int[balls.length];\\n        int[] second = new int[balls.length];\\n        dfs(balls, first, second, 0, 0, 0);\\n        return valid / possible;\\n    }\\n    \\n    private void dfs(int[] balls, int[] first, int[] second, int num1, int num2, int idx) {\\n        // finish all colors, check if this\\'s a possible/valid distribution\\n        if (idx == balls.length) {\\n            // find one possible distribution\\n            if (num1 == num2) {\\n                // compute fake permutation\\n                double distrib = permFake(first) * permFake(second);\\n                possible += distrib;\\n                \\n                // find one valid distribution\\n                if (unique(first) == unique(second)) {\\n                    valid += distrib;\\n                }\\n            }\\n            return;\\n        }\\n        \\n        // distribute balls in current color to two bins\\n        for (int b = 0; b <= balls[idx]; b++) {\\n            first[idx] = b;\\n            second[idx] = balls[idx] - b;\\n            dfs (balls, first, second, num1 + first[idx], num2 + second[idx], idx + 1);\\n        }\\n    }\\n    \\n    // unique colors in \\n    private int unique(int[] balls) {\\n        int unique = 0;\\n        for (int b: balls)\\n            unique += b > 0 ? 1 : 0;\\n        return unique;\\n    }\\n    \\n    // return 1 / (b1!b2!b3!...bn!) \\n    private double permFake(int[] balls) {\\n        double ret = 1.0;\\n        for (int b: balls)\\n            ret /= factorial(b);\\n        return ret;\\n    }\\n    \\n    private int factorial(int n){\\n        int ret = 1;\\n        while (n > 0) {\\n            ret *= n;\\n            n--;\\n        }\\n        return ret;\\n    }\\n}\\n```",
        "level": "hard",
        "buggy_code": "\nclass Solution {\n    double possible = 0.0;\n    double valid = 0.0;\n    \n    public double getProbability(int[] balls) {\n        int[] first = new int[balls.length];\n        int[] second = new int[balls.length];\n        dfs(balls, first, second, 0, 0, 0)\n        return valid / possible;\n    }\n    \n    private void dfs(int[] balls, int[] first, int[] second, int num1, int num2, int idx) {\n        // finish all colors, check if this's a possible/valid distribution\n        if (idx == balls.length) {\n            if (num1 == num2) {\n                double distrib = permFake(first) * permFake(second);\n                possible += distrib;\n                if (unique(first) == unique(second)) {\n                    valid += distrib;\n                }\n            }\n            return;\n        }\n        for (int b = 0; b <= balls[idx]; b++) {\n            first[idx] = b;\n            second[idx] = balls[idx] - b;\n            dfs (balls, first, second, num1 + first[idx], num2 + second[idx], idx + 1);\n        }\n    }\n    \n    private int unique(int[] balls) {\n        int unique = 0;\n        for (int b: balls)\n            unique += b > 0 ? 1 : 0;\n        return unique;\n    }\n    \n    private double permFake(int[] balls) {\n        double ret = 1.0;\n        for (int b: balls)\n            ret /= factorial(b);\n        return ret;\n    }\n    \n    private int factorial(int n){\n        int ret = 1;\n        while (n > 0) {\n            ret *= n;\n            n--;\n        }\n        return ret;\n    }\n}\n",
        "explanations": "\nMissing semicolon at the end of the dfs function call inside the getProbability method.\n"
    },
    {
        "slug": "maximum-number-of-balloons",
        "description": "Given a string text, you want to use the characters of text to form as many instances of the word \"balloon\" as possible.\nYou can use each character in text at most once. Return the maximum number of instances that can be formed.",
        "examples": [
            "Input: text = \"nlaebolko\"\nOutput: 1",
            "Input: text = \"loonbalxballpoon\"\nOutput: 2",
            "Input: text = \"leetcode\"\nOutput: 0"
        ],
        "constraints": "1 <= text.length <= 104\ntext consists of lower case English letters only.",
        "release_time": 1688984016,
        "oracle_code": "class Solution {\n    public int maxNumberOfBalloons(String text) {\n        final int[][] cache = new int[2][5];\n        cache[0][0] = 97;  // a\n        cache[0][1] = 98;  // b\n        cache[0][2] = 108; // l\n        cache[0][3] = 110; // n\n        cache[0][4] = 111; // o\n        \n        // cacl letter frequencies\n        for (char ch : text.toCharArray()) {\n            final int intValue = ch;\n            for (int i = 0; i < 5; i++) {\n                if (intValue == cache[0][i]) {\n                    cache[1][i]++;\n                    break;\n                }\n            }\n        }\n\n        // l & o meet twice\n        cache[1][2] /= 2;\n        cache[1][4] /= 2;\n\n        // find the bottleneck\n        int min = Integer.MAX_VALUE;\n        for (int frequency: cache[1]) {\n            min = Math.min(min, frequency);\n        }\n\n        return min;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxNumberOfBalloons(String text) {\\n        final int[][] cache = new int[2][5];\\n        cache[0][0] = 97;  // a\\n        cache[0][1] = 98;  // b\\n        cache[0][2] = 108; // l\\n        cache[0][3] = 110; // n\\n        cache[0][4] = 111; // o\\n        \\n        // cacl letter frequencies\\n        for (char ch : text.toCharArray()) {\\n            final int intValue = ch;\\n            for (int i = 0; i < 5; i++) {\\n                if (intValue == cache[0][i]) {\\n                    cache[1][i]++;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        // l & o meet twice\\n        cache[1][2] /= 2;\\n        cache[1][4] /= 2;\\n\\n        // find the bottleneck\\n        int min = Integer.MAX_VALUE;\\n        for (int frequency: cache[1]) {\\n            min = Math.min(min, frequency);\\n        }\\n\\n        return min;\\n    }\\n}\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\n    public int maxNumberOfBalloons(String text) {\n        final int[][] cache = new int[2][5];\n        cache[0][0] = 97;  // a\n        cache[0][1] = 98;  // b\n        cache[0][2] = 108; // l\n        cache[0][3] = 110; // n\n        cache[0][4] = 111; // o\n        \n        // cacl letter frequencies\n        for (char ch : text.toCharArray()) {\n            final int intValue = ch;\n            for (int i = 0; i < 5; i++) {\n                if (intValue == cache[0][i]) {\n                    cache[1][i]++;\n                    break;\n                }\n            }\n        }\n\n        // l & o meet twice\n        cache[1][2] /= 2\n        cache[1][4] /= 2;\n\n        // find the bottleneck\n        int min = Integer.MAX_VALUE;\n        for (int frequency: cache[1]) {\n            min = Math.min(min, frequency);\n        }\n\n        return min;\n    }\n}\n",
        "explanations": "\nMissing semicolon at the end of a statement caused compilation error.\n"
    },
    {
        "slug": "max-sum-of-rectangle-no-larger-than-k",
        "description": "Given an m x n matrix matrix and an integer k, return the max sum of a rectangle in the matrix such that its sum is no larger than k.\nIt is guaranteed that there will be a rectangle with a sum no larger than k.",
        "examples": [
            "Input: matrix = [[1,0,1],[0,-2,3]], k = 2\nOutput: 2\nExplanation: Because the sum of the blue rectangle [[0, 1], [-2, 3]] is 2, and 2 is the max number no larger than k (k = 2).",
            "Input: matrix = [[2,2,-1]], k = 3\nOutput: 3"
        ],
        "constraints": "m == matrix.length\nn == matrix[i].length\n1 <= m, n <= 100\n-100 <= matrix[i][j] <= 100\n-105 <= k <= 105",
        "release_time": 1661575112,
        "oracle_code": "//Kadane's Algorithm Approach\n//600ms+  explained in video\n\nclass Solution {\n    public int maxSumSubmatrix(int[][] matrix, int k) {\n        int result = Integer.MIN_VALUE;\n        \n        for(int left =0 ;left<matrix[0].length; left++){\n            \n            int[] rSum = new int[matrix.length];\n            \n            for(int right = left;right<matrix[0].length;right++){\n                for(int row=0; row < matrix.length; row++)\n                    rSum[row] += matrix[row][right];\n\t\t\t\t\t\n\t\t\t\t\t//explanation of these 3 loops starts from 02:00 in Video\n                \n                TreeSet<Integer> set = new TreeSet<>();\n                \n                set.add(0);\n                int cs = 0;\n                \n                for(int a: rSum){\n                    cs += a;\n\t\t\t\t\t\n                    //if you don't understand what exactly is going on here\n\t\t\t\t\t// then watch the video from 12:27\n\t\t\t\t\t\n                    Integer target = set.ceiling(cs-k);\n                    \n                    if(target !=null)\n                        result = Math.max(result,cs-target);\n                    set.add(cs);\n                }\n            }\n        }\n        return result;\n    }\n}",
        "content": "*Please **Upvote** if you find this explanation helpful*\\n\\n**Video Explanation**\\n[Max Sum of Rectangle No Larger Than K | YouTube](https://www.youtube.com/watch?v=rztZyG5kpvM&feature=youtu.be)\\n\\n**Java Solution**\\n\\n```\\n//Kadane\\'s Algorithm Approach\\n//600ms+  explained in video\\n\\nclass Solution {\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        int result = Integer.MIN_VALUE;\\n        \\n        for(int left =0 ;left<matrix[0].length; left++){\\n            \\n            int[] rSum = new int[matrix.length];\\n            \\n            for(int right = left;right<matrix[0].length;right++){\\n                for(int row=0; row < matrix.length; row++)\\n                    rSum[row] += matrix[row][right];\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t//explanation of these 3 loops starts from 02:00 in Video\\n                \\n                TreeSet<Integer> set = new TreeSet<>();\\n                \\n                set.add(0);\\n                int cs = 0;\\n                \\n                for(int a: rSum){\\n                    cs += a;\\n\\t\\t\\t\\t\\t\\n                    //if you don\\'t understand what exactly is going on here\\n\\t\\t\\t\\t\\t// then watch the video from 12:27\\n\\t\\t\\t\\t\\t\\n                    Integer target = set.ceiling(cs-k);\\n                    \\n                    if(target !=null)\\n                        result = Math.max(result,cs-target);\\n                    set.add(cs);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```\\n\\n**Faster Approach**\\n```\\n//32ms - faster than 100%\\n\\nclass Solution {\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        for (int i = 0; i < matrix.length; i++) {\\n            for (int j = 0; j < matrix[0].length; j++) {\\n                if (i > 0) {\\n                    matrix[i][j] += matrix[i - 1][j];\\n                }\\n                if (j > 0) {\\n                    matrix[i][j] += matrix[i][j - 1];\\n                }\\n                if (i > 0 && j > 0) {\\n                    matrix[i][j] -= matrix[i - 1][j - 1];\\n                }\\n            }\\n        }\\n        int result = Integer.MIN_VALUE;\\n        \\n        int[][] dpHigh = new int[matrix.length][matrix.length + 1];\\n        int[][] dpLow = new int[matrix.length][matrix.length + 1];\\n        \\n        for (int i = matrix.length - 1; i >= 0; i--) {\\n            for (int h = 1; h <= matrix.length - i; h++) {\\n                int theValue = getSum(matrix, i, matrix[0].length - 1, h, 1);\\n                dpLow[i][h] = theValue;\\n                dpHigh[i][h] = theValue;\\n                if (theValue == k) {\\n                    return theValue;\\n                }\\n                if (theValue < k) {\\n                    result = Math.max(result, theValue);\\n                }\\n            }\\n        }\\n        \\n        for (int i = matrix.length - 1; i >= 0; i--) {\\n            for (int j = matrix[0].length - 2; j >= 0; j--) {\\n                for (int h = 1; h <= matrix.length - i; h++) {\\n                    int newSum = getSum(matrix, i, j, h, 1);\\n                    if (dpLow[i][h] > 0) {\\n                        dpHigh[i][h] += newSum;\\n                        dpLow[i][h] = newSum;\\n                    } else if (dpHigh[i][h] < 0) {\\n                        dpLow[i][h] += newSum;\\n                        dpHigh[i][h] = newSum;\\n                    } else {\\n                        dpHigh[i][h] += newSum;\\n                        dpLow[i][h] += newSum;\\n                    }\\n                    if (dpHigh[i][h] >= result && dpLow[i][h] <= k) {\\n                        for (int w = 1; w <= matrix[0].length - j; w++) {\\n                            int sum = getSum(matrix, i, j, h, w);\\n                            if (sum == k) {\\n                                return sum;\\n                            } else if (sum < k) {\\n                                result = Math.max(result, sum);\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    private int getSum(int[][] matrix, int i, int j, int h, int w) {\\n        int sum = matrix[i + h - 1][j + w - 1];\\n        if (i > 0) {\\n            sum -= matrix[i - 1][j + w - 1];\\n        }\\n        if (j > 0) {\\n            sum -= matrix[i + h - 1][j - 1];\\n        }\\n        if (i > 0 && j > 0) {\\n            sum += matrix[i - 1][j - 1];\\n        }\\n        return sum;\\n    }\\n}\\n```",
        "level": "hard",
        "buggy_code": "\nclass Solution {\n    public int maxSumSubmatrix(int[][] matrix, int k) {\n        int result = Integer.MIN_VALUE\n        \n        for(int left =0 ;left<matrix[0].length; left++){\n            \n            int[] rSum = new int[matrix.length];\n            \n            for(int right = left;right<matrix[0].length;right++){\n                for(int row=0; row < matrix.length; row++)\n                    rSum[row] += matrix[row][right];\n                \n                TreeSet<Integer> set = new TreeSet<>();\n                \n                set.add(0);\n                int cs = 0;\n                \n                for(int a: rSum){\n                    cs += a;\n                    \n                    Integer target = set.ceiling(cs-k);\n                    \n                    if(target !=null)\n                        result = Math.max(result,cs-target);\n                    set.add(cs);\n                }\n            }\n        }\n        return result;\n    }\n}\n",
        "explanations": "\nThe bug we introduced is by removing the semicolon at the end of line 'int result = Integer.MIN_VALUE'. This will result in a compilation error.\n"
    },
    {
        "slug": "maximum-ice-cream-bars",
        "description": "It is a sweltering summer day, and a boy wants to buy some ice cream bars.\nAt the store, there are n ice cream bars. You are given an array costs of length n, where costs[i] is the price of the ith ice cream bar in coins. The boy initially has coins coins to spend, and he wants to buy as many ice cream bars as possible.\u00a0\nNote: The boy can buy the ice cream bars in any order.\nReturn the maximum number of ice cream bars the boy can buy with coins coins.\nYou must solve the problem by counting sort.",
        "examples": [
            "Input: costs = [1,3,2,4,1], coins = 7\nOutput: 4\nExplanation: The boy can buy ice cream bars at indices 0,1,2,4 for a total price of 1 + 3 + 2 + 1 = 7.",
            "Input: costs = [10,6,8,7,7,8], coins = 5\nOutput: 0\nExplanation: The boy cannot afford any of the ice cream bars.",
            "Input: costs = [1,6,3,1,2,5], coins = 20\nOutput: 6\nExplanation: The boy can buy all the ice cream bars for a total price of 1 + 6 + 3 + 1 + 2 + 5 = 18."
        ],
        "constraints": "costs.length == n\n1 <= n <= 105\n1 <= costs[i] <= 105\n1 <= coins <= 108",
        "release_time": 1672980160,
        "oracle_code": "class Solution {\n    public int maxIceCream(int[] costs, int coins) {\n        int [] arr = new int [100001];\n        for(int x : costs)arr[x]++;\n        int count = 0;\n        int index = 1;\n//If coins can buy all the ice-cream at ith index.\n        while(index<100001 && coins>=index*arr[index]){\n            coins-=index*arr[index];\n            count+=arr[index];\n            index++;\n        }\n//If coins can buy onyl some of the ice-creams at ith index.\n        while(index<100001 && coins>=index){\n            coins-=index;\n            count++;\n        }\n        return count;\n    }\n}",
        "content": "# Code\\n```\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        int [] arr = new int [100001];\\n        for(int x : costs)arr[x]++;\\n        int count = 0;\\n        int index = 1;\\n//If coins can buy all the ice-cream at ith index.\\n        while(index<100001 && coins>=index*arr[index]){\\n            coins-=index*arr[index];\\n            count+=arr[index];\\n            index++;\\n        }\\n//If coins can buy onyl some of the ice-creams at ith index.\\n        while(index<100001 && coins>=index){\\n            coins-=index;\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```\\n\\n# Using priority Queue\\n```\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<Integer>(Collections.reverseOrder());\\n        int sum = 0;\\n        for(int x : costs){\\n            if(sum<=coins){\\n                sum+=x;\\n                pq.add(x);\\n            }else if(pq.peek()>x){\\n                sum = sum - pq.poll() + x;\\n                pq.add(x);\\n            }\\n        }\\n        while(sum>coins){\\n            sum-=pq.poll();\\n        }\\n        return pq.size();\\n    }\\n}\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\n    public int maxIceCream(int[] costs, int coins) {\n        int [] arr = new int [100001];\n        for(int x : costs)arr[x]++;\n        int count = 0;\n        int index = 1;\n//If coins can buy all the ice-cream at ith index.\n        while(index<100001 && coins>=index*arr[index])\n            coins-=index*arr[index];\n            count+=arr[index];\n            index++;\n        }\n\n        while(index<100001 && coins>=index){\n            coins-=index;\n            count++;\n        }\n        return count;\n    }\n}\n",
        "explanations": "\nMissed the opening brace in the first while loop, causing the last two increments to run unconditionally.\n"
    },
    {
        "slug": "populating-next-right-pointers-in-each-node",
        "description": "You are given a perfect binary tree where all leaves are on the same level, and every parent has two children. The binary tree has the following definition:\n\nstruct Node {\n  int val;\n  Node *left;\n  Node *right;\n  Node *next;\n}\n\nPopulate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.\nInitially, all next pointers are set to NULL.",
        "examples": [
            "Input: root = [1,2,3,4,5,6,7]\nOutput: [1,#,2,3,#,4,5,6,7,#]\nExplanation: Given the above perfect binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with '#' signifying the end of each level.",
            "Input: root = []\nOutput: []"
        ],
        "constraints": "The number of nodes in the tree is in the range [0, 212 - 1].\n-1000 <= Node.val <= 1000\n\n\u00a0\nFollow-up:\n\nYou may only use constant extra space.\nThe recursive approach is fine. You may assume implicit stack space does not count as extra space for this problem.",
        "release_time": 1674631361,
        "oracle_code": "class Solution {\n    public Node connect(Node node) {\n        Map<Integer, List<Node>> map = new HashMap<>();\n        goDFS(0, node, map);\n        for (int key : map.keySet()) {\n            List<Node> list = map.get(key);\n            for (int i = 1; i < list.size(); i++) {\n                list.get(i - 1).next = list.get(i);\n            }\n        }\n        return node;\n    }\n\n    private void goDFS(int lvl, Node node, Map<Integer, List<Node>> map) {\n        if (node == null) return;\n\n        List<Node> list = map.computeIfAbsent(lvl, k -> new ArrayList<>());\n        list.add(node);\n        lvl++;\n        goDFS(lvl, node.left, map);\n        goDFS(lvl, node.right, map);\n    }\n}",
        "content": "# Code\\n```\\nclass Solution {\\n    public Node connect(Node node) {\\n        Map<Integer, List<Node>> map = new HashMap<>();\\n        goDFS(0, node, map);\\n        for (int key : map.keySet()) {\\n            List<Node> list = map.get(key);\\n            for (int i = 1; i < list.size(); i++) {\\n                list.get(i - 1).next = list.get(i);\\n            }\\n        }\\n        return node;\\n    }\\n\\n    private void goDFS(int lvl, Node node, Map<Integer, List<Node>> map) {\\n        if (node == null) return;\\n\\n        List<Node> list = map.computeIfAbsent(lvl, k -> new ArrayList<>());\\n        list.add(node);\\n        lvl++;\\n        goDFS(lvl, node.left, map);\\n        goDFS(lvl, node.right, map);\\n    }\\n}\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\n    public Node connect(Node node) {\n        Map<Integer, List<Node>> map = new HashMap<>();\n        goDFS(0, node, map)\n        for (int key : map.keySet()) {\n            List<Node> list = map.get(key);\n            for (int i = 1; i < list.size(); i++) {\n                list.get(i - 1).next = list.get(i);\n            }\n        }\n        return node;\n    }\n\n    private void goDFS(int lvl, Node node, Map<Integer, List<Node>> map) {\n        if (node == null) return;\n\n        List<Node> list = map.computeIfAbsent(lvl, k -> new ArrayList<>());\n        list.add(node);\n        lvl++;\n        goDFS(lvl, node.left, map);\n        goDFS(lvl, node.right, map);\n    }\n}\n",
        "explanations": "\nMissing semicolon at the end of the 'goDFS(0, node, map)' line causes a syntax error.\n"
    },
    {
        "slug": "path-sum-ii",
        "description": "Given the root of a binary tree and an integer targetSum, return all root-to-leaf paths where the sum of the node values in the path equals targetSum. Each path should be returned as a list of the node values, not node references.\nA root-to-leaf path is a path starting from the root and ending at any leaf node. A leaf is a node with no children.",
        "examples": [
            "Input: root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22\nOutput: [[5,4,11,2],[5,8,4,5]]\nExplanation: There are two paths whose sum equals targetSum:\n5 + 4 + 11 + 2 = 22\n5 + 8 + 4 + 5 = 22",
            "Input: root = [1,2,3], targetSum = 5\nOutput: []",
            "Input: root = [1,2], targetSum = 0\nOutput: []"
        ],
        "constraints": "The number of nodes in the tree is in the range [0, 5000].\n-1000 <= Node.val <= 1000\n-1000 <= targetSum <= 1000",
        "release_time": 1678803647,
        "oracle_code": "class Solution {\n     List<List<Integer>> al = new ArrayList<>();\n    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {\n       \n        helper( new ArrayList<>(), root, targetSum);\n        return al;\n    }\n    void helper(List<Integer> li, TreeNode root, int targetSum)\n    {\n        if(root == null)\n        return;\n        li.add(root.val);\n        if(root.left == null && root.right == null)\n        {\n            int sum = 0;\n            for(int i: li)\n            sum+= i;\n            if(sum == targetSum)\n            al.add(li);\n        }\n        helper(new ArrayList<>(li), root.left, targetSum);\n        helper(new ArrayList<>(li), root.right, targetSum);\n    }\n}",
        "content": "\\n\\n# Code\\n```\\n\\nclass Solution {\\n     List<List<Integer>> al = new ArrayList<>();\\n    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {\\n       \\n        helper( new ArrayList<>(), root, targetSum);\\n        return al;\\n    }\\n    void helper(List<Integer> li, TreeNode root, int targetSum)\\n    {\\n        if(root == null)\\n        return;\\n        li.add(root.val);\\n        if(root.left == null && root.right == null)\\n        {\\n            int sum = 0;\\n            for(int i: li)\\n            sum+= i;\\n            if(sum == targetSum)\\n            al.add(li);\\n        }\\n        helper(new ArrayList<>(li), root.left, targetSum);\\n        helper(new ArrayList<>(li), root.right, targetSum);\\n    }\\n}\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\n     List<List<Integer>> al = new ArrayList<>();\n    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {\n\n        helper( new ArrayList<>(), root, targetSum);\n        return al;\n    }\n    void helper(List<Integer> li, TreeNode root, int targetSum)\n    {\n        if(root == null)\n        return;\n        li.add(root.val);\n        if(root.left == null && root.right == null)\n        {\n            int sum = 0;\n            for(int i: li)\n            sum = i;\n            if(sum == targetSum)\n            al.add(li);\n        }\n        helper(new ArrayList<>(li), root.left, targetSum);\n        helper(new ArrayList<>(li), root.right, targetSum);\n    }\n}\n",
        "explanations": "\nThe equals operator in the summing loop was replaced with the assignment operator, causing incorrect total sum calculation.\n"
    },
    {
        "slug": "maximum-number-of-integers-to-choose-from-a-range-i",
        "description": "You are given an integer array banned and two integers n and maxSum. You are choosing some number of integers following the below rules:\n\nThe chosen integers have to be in the range [1, n].\nEach integer can be chosen at most once.\nThe chosen integers should not be in the array banned.\nThe sum of the chosen integers should not exceed maxSum.\n\nReturn the maximum number of integers you can choose following the mentioned rules.",
        "examples": [
            "Input: banned = [1,6,5], n = 5, maxSum = 6\nOutput: 2\nExplanation: You can choose the integers 2 and 4.\n2 and 4 are from the range [1, 5], both did not appear in banned, and their sum is 6, which did not exceed maxSum.",
            "Input: banned = [1,2,3,4,5,6,7], n = 8, maxSum = 1\nOutput: 0\nExplanation: You cannot choose any integer while following the mentioned conditions.",
            "Input: banned = [11], n = 7, maxSum = 50\nOutput: 7\nExplanation: You can choose the integers 1, 2, 3, 4, 5, 6, and 7.\nThey are from the range [1, 7], all did not appear in banned, and their sum is 28, which did not exceed maxSum."
        ],
        "constraints": "1 <= banned.length <= 104\n1 <= banned[i], n <= 104\n1 <= maxSum <= 109",
        "release_time": 1679763684,
        "oracle_code": "class Solution {\n    public int maxCount(int[] banned, int n, int maxSum) {\n\n        // Create a HashSet of banned integers for fast lookup\n        Set<Integer> banSet = new HashSet<>();\n        for (int num : banned) {\n            banSet.add(num);\n        }\n\n        // Initialize count and sum to 0\n        int count = 0;\n        int sum = 0;\n\n        // Iterate over the range [1, n]\n        for (int i = 1; i <= n; i++) {\n\n            // Check if the current integer is not banned and adding it to sum does not exceed maxSum\n            if (!banSet.contains(i) && (sum + i <= maxSum)) {\n            // Increment count and add the current integer to sum\n                count++;\n                sum += i;\n            }\n        }\n    // Return the maximum count of chosen integers\n    return count;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(N)\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/bfae0867-a2e9-46fd-a802-cdd36cf2f897_1679763680.3311183.png)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxCount(int[] banned, int n, int maxSum) {\\n\\n        // Create a HashSet of banned integers for fast lookup\\n        Set<Integer> banSet = new HashSet<>();\\n        for (int num : banned) {\\n            banSet.add(num);\\n        }\\n\\n        // Initialize count and sum to 0\\n        int count = 0;\\n        int sum = 0;\\n\\n        // Iterate over the range [1, n]\\n        for (int i = 1; i <= n; i++) {\\n\\n            // Check if the current integer is not banned and adding it to sum does not exceed maxSum\\n            if (!banSet.contains(i) && (sum + i <= maxSum)) {\\n            // Increment count and add the current integer to sum\\n                count++;\\n                sum += i;\\n            }\\n        }\\n    // Return the maximum count of chosen integers\\n    return count;\\n    }\\n}\\n\\n\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\n    public int maxCount(int[] banned, int n, int maxSum) {\n\n        // Create a HashSet of banned integers for fast lookup\n        Set<Integer> banSet = new HashSet<>();\n        for (int num : banned) {\n            banSet.add(num;\n        }\n\n        // Initialize count and sum to 0\n        int count = 0;\n        int sum = 0;\n\n        // Iterate over the range [1, n]\n        for (int i = 1; i <= n; i++) {\n\n            // Check if the current integer is not banned and adding it to sum does not exceed maxSum\n            if (!banSet.contains(i) && sum + i <= maxSum) {\n            // Increment count and add the current integer to sum\n                count++;\n                sum += i;\n            }\n        }\n    // Return the maximum count of chosen integers\n    return count;\n    }\n}\n",
        "explanations": "\nThe closing parenthesis is missing after num inside the add() method of banSet.\n"
    },
    {
        "slug": "number-of-atoms",
        "description": "Given a string formula representing a chemical formula, return the count of each atom.\nThe atomic element always starts with an uppercase character, then zero or more lowercase letters, representing the name.\nOne or more digits representing that element's count may follow if the count is greater than 1. If the count is 1, no digits will follow.\n\nFor example, \"H2O\" and \"H2O2\" are possible, but \"H1O2\" is impossible.\n\nTwo formulas are concatenated together to produce another formula.\n\nFor example, \"H2O2He3Mg4\" is also a formula.\n\nA formula placed in parentheses, and a count (optionally added) is also a formula.\n\nFor example, \"(H2O2)\" and \"(H2O2)3\" are formulas.\n\nReturn the count of all elements as a string in the following form: the first name (in sorted order), followed by its count (if that count is more than 1), followed by the second name (in sorted order), followed by its count (if that count is more than 1), and so on.\nThe test cases are generated so that all the values in the output fit in a 32-bit integer.",
        "examples": [
            "Input: formula = \"H2O\"\nOutput: \"H2O\"\nExplanation: The count of elements are {'H': 2, 'O': 1}.",
            "Input: formula = \"Mg(OH)2\"\nOutput: \"H2MgO2\"\nExplanation: The count of elements are {'H': 2, 'Mg': 1, 'O': 2}.",
            "Input: formula = \"K4(ON(SO3)2)2\"\nOutput: \"K4N2O14S4\"\nExplanation: The count of elements are {'K': 4, 'N': 2, 'O': 14, 'S': 4}."
        ],
        "constraints": "1 <= formula.length <= 1000\nformula consists of English letters, digits, '(', and ')'.\nformula is always valid.",
        "release_time": 1601928748,
        "oracle_code": "class Solution {\n    Map<String, Integer> res = new TreeMap<>();\n    Stack<Integer> stack = new Stack<>();\n    int multiplier = 1;\n    \n    public String countOfAtoms(String formula) {\n        int end = formula.length() - 1, i = formula.length() - 1;\n        \n        while (i >= 0) {\n            if (formula.charAt(i) == '(') {\n                multiplier /= stack.pop();\n                i--;\n                continue;\n            }\n            \n            end = i;\n            int val = 1;\n            \n            if (Character.isDigit(formula.charAt(i))) {\n                while (Character.isDigit(formula.charAt(i))) i--;\n                val = Integer.parseInt(formula.substring(i+1, end+1));\n            } \n            stack.push(val);\n            multiplier *= val;\n            \n            end = i;\n            if (Character.isLetter(formula.charAt(i))) {\n                while(Character.isLowerCase(formula.charAt(i))) i--;\n                updateMap(formula.substring(i, end+1));\n            }\n            i--;\n        }\n        \n        StringBuilder rs = new StringBuilder();\n        for (Map.Entry<String, Integer> entry : res.entrySet()) {\n            rs.append(entry.getKey());\n            if (entry.getValue() > 1) rs.append(entry.getValue());\n        }\n        return rs.toString();\n    }\n    \n    private void updateMap(String key) {\n        if (res.get(key) == null) {\n            res.put(key, multiplier);\n        } else {\n            res.put(key, multiplier + res.get(key));\n        }\n\n        multiplier /= stack.pop();\n    }\n}",
        "content": "We essentially start from the back. Each time we encounter a number we add it to the stack. We can clearly see that going backwards, a number will always be preceeded by either `)` or `element`. So in the same loop we first parse the number followed by the element/bracket. If a number is not seen, we take the default 1 as the number.\\n\\nWe maintain the stack with the multipliers encountered and keep a `multiplier` variable to store the product. Upon poping the stack, we divide by this popped number.\\n\\nEverytime we encounter a `(`, we pop the stack. We again pop the stack after each element is processed.\\n\\nWe also use StringBuilder to optimize.\\n```\\nclass Solution {\\n    Map<String, Integer> res = new TreeMap<>();\\n    Stack<Integer> stack = new Stack<>();\\n    int multiplier = 1;\\n    \\n    public String countOfAtoms(String formula) {\\n        int end = formula.length() - 1, i = formula.length() - 1;\\n        \\n        while (i >= 0) {\\n            if (formula.charAt(i) == \\'(\\') {\\n                multiplier /= stack.pop();\\n                i--;\\n                continue;\\n            }\\n            \\n            end = i;\\n            int val = 1;\\n            \\n            if (Character.isDigit(formula.charAt(i))) {\\n                while (Character.isDigit(formula.charAt(i))) i--;\\n                val = Integer.parseInt(formula.substring(i+1, end+1));\\n            } \\n            stack.push(val);\\n            multiplier *= val;\\n            \\n            end = i;\\n            if (Character.isLetter(formula.charAt(i))) {\\n                while(Character.isLowerCase(formula.charAt(i))) i--;\\n                updateMap(formula.substring(i, end+1));\\n            }\\n            i--;\\n        }\\n        \\n        StringBuilder rs = new StringBuilder();\\n        for (Map.Entry<String, Integer> entry : res.entrySet()) {\\n            rs.append(entry.getKey());\\n            if (entry.getValue() > 1) rs.append(entry.getValue());\\n        }\\n        return rs.toString();\\n    }\\n    \\n    private void updateMap(String key) {\\n        if (res.get(key) == null) {\\n            res.put(key, multiplier);\\n        } else {\\n            res.put(key, multiplier + res.get(key));\\n        }\\n\\n        multiplier /= stack.pop();\\n    }\\n}\\n```",
        "level": "hard",
        "buggy_code": "\nclass Solution {\n    Map<String, Integer> res = new TreeMap<>();\n    Stack<Integer> stack = new Stack<>();\n    int multiplier = 1;\n    \n    public String countOfAtoms(String formula) {\n        int end = formula.length() - 1, i = formula.length() - 1;\n        \n        while (i >= 0) {\n            if (formula.charAt(i) == '(') {\n                multiplier /= stack.pop();\n                i--;\n                continue;\n            }\n            \n            end = i;\n            int val = 1;\n            \n            if (Character.isDigit(formula.charAt(i))) {\n                while (Character.isDigit(formula.charAt(i))) i--;\n                val = Integer.parseInt(formula.substring(i+1, end+1));\n            } \n            stack.push(val);\n            multiplier *= val;\n            \n            end = i;\n            if (Character.isLetter(formula.charAt(i))) {\n                while(Character.isLowerCase(formula.charAt(i))) i--;\n                updateMap(formula.substring(i, end+1));\n            }\n            --i;\n        }\n        \n        StringBuilder rs = new StringBuilder();\n        for (Map.Entry<String, Integer> entry, res.entrySet()) {\n            rs.append(entry.getKey());\n            if (entry.getValue() > 1) rs.append(entry.getValue());\n        }\n        return rs.toString();\n    }\n    \n    private void updateMap(String key) {\n        if (res.get(key) == null) {\n            res.put(key, multiplier);\n        } else {\n            res.put(key, multiplier + res.get(key));\n        }\n\n        multiplier /= stack.pop();\n    }\n}\n",
        "explanations": "\nMissing colon in the for each loop in the 'countOfAtoms' method.\n"
    },
    {
        "slug": "add-edges-to-make-degrees-of-all-nodes-even",
        "description": "There is an undirected graph consisting of n nodes numbered from 1 to n. You are given the integer n and a 2D array edges where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi. The graph can be disconnected.\nYou can add at most two additional edges (possibly none) to this graph so that there are no repeated edges and no self-loops.\nReturn true if it is possible to make the degree of each node in the graph even, otherwise return false.\nThe degree of a node is the number of edges connected to it.",
        "examples": [
            "Input: n = 5, edges = [[1,2],[2,3],[3,4],[4,2],[1,4],[2,5]]\nOutput: true\nExplanation: The above diagram shows a valid way of adding an edge.\nEvery node in the resulting graph is connected to an even number of edges.",
            "Input: n = 4, edges = [[1,2],[3,4]]\nOutput: true\nExplanation: The above diagram shows a valid way of adding two edges.",
            "Input: n = 4, edges = [[1,2],[1,3],[1,4]]\nOutput: false\nExplanation: It is not possible to obtain a valid graph with adding at most 2 edges."
        ],
        "constraints": "3 <= n <= 105\n2 <= edges.length <= 105\nedges[i].length == 2\n1 <= ai, bi <= n\nai != bi\nThere are no repeated edges.",
        "release_time": 1671336101,
        "oracle_code": "class Solution:\n    def isPossible(self, n: int, edges: List[List[int]]) -> bool:\n        graph = defaultdict(set)\n        for a, b in edges:\n            graph[a].add(b)\n            graph[b].add(a)\n        odds = [a for a in graph if len(graph[a]) % 2 == 1]\n        if not odds:\n            return True\n        elif len(odds) > 4 or len(odds) == 1 or len(odds) == 3:\n            return False\n        elif len(odds) == 2:\n            a, b = odds[0], odds[1]\n            if a not in graph[b]:\n                return True\n            for i in range(1, n + 1):\n                if i not in graph[a] and i not in graph[b]:\n                    return True\n            return False\n        else:\n            a, b, c, d = odds[0], odds[1], odds[2], odds[3]\n            if a not in graph[b] and c not in graph[d]:\n                return True\n            if a not in graph[c] and b not in graph[d]:\n                return True\n            if a not in graph[d] and b not in graph[c]:\n                return True\n            return False",
        "content": "**Observation**\\nThe key is to note that we can add **at most** two additional edges (possibly none) to the graph.\\n\\n**Implementation**\\nStep 1: Build the graph by going through all edges.\\nStep 2: Find every node with an odd degree.\\nStep 3: Consider each of the case where the number of the nodes with an odd degree is 0, 1, 2, 3, 4, and > 4.\\n\\n**Solution**\\n```\\nclass Solution:\\n    def isPossible(self, n: int, edges: List[List[int]]) -> bool:\\n        graph = defaultdict(set)\\n        for a, b in edges:\\n            graph[a].add(b)\\n            graph[b].add(a)\\n        odds = [a for a in graph if len(graph[a]) % 2 == 1]\\n        if not odds:\\n            return True\\n        elif len(odds) > 4 or len(odds) == 1 or len(odds) == 3:\\n            return False\\n        elif len(odds) == 2:\\n            a, b = odds[0], odds[1]\\n            if a not in graph[b]:\\n                return True\\n            for i in range(1, n + 1):\\n                if i not in graph[a] and i not in graph[b]:\\n                    return True\\n            return False\\n        else:\\n            a, b, c, d = odds[0], odds[1], odds[2], odds[3]\\n            if a not in graph[b] and c not in graph[d]:\\n                return True\\n            if a not in graph[c] and b not in graph[d]:\\n                return True\\n            if a not in graph[d] and b not in graph[c]:\\n                return True\\n            return False\\n```",
        "level": "hard",
        "buggy_code": "\nclass Solution:\n    def isPossible(self, n: int, edges: List[List[int]]) -> bool:\n        graph = defaultdict(set)\n        for a, b in edges\n            graph[a].add(b)\n            graph[b].add(a)\n        odds = [a for a in graph if len(graph[a]) % 2 == 1]\n        if not odds:\n            return True\n        elif len(odds) > 4 or len(odds) == 1 or len(odds) == 3:\n            return False\n        elif len(odds) == 2:\n            a, b = odds[0], odds[1]\n            if a not in graph[b]:\n                return True\n            for i in range(1, n + 1):\n                if i not in graph[a] and i not in graph[b]:\n                    return True\n            return False\n        else:\n            a, b, c, d = odds[0], odds[1], odds[2], odds[3]\n            if a not in graph[b] and c not in graph[d]:\n                return True\n            if a not in graph[c] and b not in graph[d]:\n                return True\n            if a not in graph[d] and b not in graph[c]:\n                return True\n            return False\n",
        "explanations": "\nMissing colon at the end of the for loop in line 4 causes a syntax error.\n"
    },
    {
        "slug": "smallest-range-covering-elements-from-k-lists",
        "description": "You have k lists of sorted integers in non-decreasing\u00a0order. Find the smallest range that includes at least one number from each of the k lists.\nWe define the range [a, b] is smaller than range [c, d] if b - a < d - c or a < c if b - a == d - c.",
        "examples": [
            "Input: nums = [[4,10,15,24,26],[0,9,12,20],[5,18,22,30]]\nOutput: [20,24]\nExplanation: \nList 1: [4, 10, 15, 24,26], 24 is in range [20,24].\nList 2: [0, 9, 12, 20], 20 is in range [20,24].\nList 3: [5, 18, 22, 30], 22 is in range [20,24].",
            "Input: nums = [[1,2,3],[1,2,3],[1,2,3]]\nOutput: [1,1]"
        ],
        "constraints": "nums.length == k\n1 <= k <= 3500\n1 <= nums[i].length <= 50\n-105 <= nums[i][j] <= 105\nnums[i]\u00a0is sorted in non-decreasing order.",
        "release_time": 1674752084,
        "oracle_code": "class Solution {\n    public int[] smallestRange(List<List<Integer>> nums) {\n        int k = nums.size();\n        List<Pair<Integer,Integer>> list = new ArrayList<>();\n        for(int i = 0;i<k;i++){\n            List<Integer> l = nums.get(i);\n            for(int nu : l){\n                list.add(new Pair(nu,i));\n            }\n        }\n        \n        Collections.sort(list,(a,b)-> a.getKey()-b.getKey());\n        int[] ans = new int[2];\n        ans[1] = ans[0] = Integer.MAX_VALUE; \n        int i = 0,j=0;\n        List<Integer> store = new ArrayList<>();\n        HashMap<Integer,Integer> mp = new HashMap<>();\n        int totalType = 0;\n        \n        while(j<list.size()){\n            int nu = list.get(j).getKey();\n            int type = list.get(j).getValue();\n            store.add(nu);\n            int val = mp.getOrDefault(type,0);\n            mp.put(type,val+1);\n            totalType++;\n            if(mp.size()<k){\n                j++;\n            }else if(mp.size()==k){\n                if(ans[0]==ans[1] && ans[1] == Integer.MAX_VALUE){\n                    ans[0] = store.get(0);\n                    ans[1] = store.get(store.size()-1);\n                }\n                int dif = store.get(store.size()-1)-store.get(0);\n                if(dif<ans[1]-ans[0]){\n                    ans[0] = store.get(0);\n                    ans[1] = store.get(store.size()-1);\n                }  \n                \n                while(mp.size()==k){\n                    dif = store.get(store.size()-1)-store.get(0);\n                    if(dif<ans[1]-ans[0]){\n                        ans[0] = store.get(0);\n                        ans[1] = store.get(store.size()-1);\n                    }\n                    store.remove(0);\n                    int t = list.get(i).getValue();\n                    int vv = (int) mp.get(t);\n                    mp.put(t,vv-1);\n                    if(vv==1){\n                        mp.remove(t);\n                    }\n                    i++;\n                }\n                \n                j++;\n                \n            }\n   \n        }\n        \n        \n        return ans;\n    }\n}",
        "content": "```\\nclass Solution {\\n    public int[] smallestRange(List<List<Integer>> nums) {\\n        int k = nums.size();\\n        List<Pair<Integer,Integer>> list = new ArrayList<>();\\n        for(int i = 0;i<k;i++){\\n            List<Integer> l = nums.get(i);\\n            for(int nu : l){\\n                list.add(new Pair(nu,i));\\n            }\\n        }\\n        \\n        Collections.sort(list,(a,b)-> a.getKey()-b.getKey());\\n        int[] ans = new int[2];\\n        ans[1] = ans[0] = Integer.MAX_VALUE; \\n        int i = 0,j=0;\\n        List<Integer> store = new ArrayList<>();\\n        HashMap<Integer,Integer> mp = new HashMap<>();\\n        int totalType = 0;\\n        \\n        while(j<list.size()){\\n            int nu = list.get(j).getKey();\\n            int type = list.get(j).getValue();\\n            store.add(nu);\\n            int val = mp.getOrDefault(type,0);\\n            mp.put(type,val+1);\\n            totalType++;\\n            if(mp.size()<k){\\n                j++;\\n            }else if(mp.size()==k){\\n                if(ans[0]==ans[1] && ans[1] == Integer.MAX_VALUE){\\n                    ans[0] = store.get(0);\\n                    ans[1] = store.get(store.size()-1);\\n                }\\n                int dif = store.get(store.size()-1)-store.get(0);\\n                if(dif<ans[1]-ans[0]){\\n                    ans[0] = store.get(0);\\n                    ans[1] = store.get(store.size()-1);\\n                }  \\n                \\n                while(mp.size()==k){\\n                    dif = store.get(store.size()-1)-store.get(0);\\n                    if(dif<ans[1]-ans[0]){\\n                        ans[0] = store.get(0);\\n                        ans[1] = store.get(store.size()-1);\\n                    }\\n                    store.remove(0);\\n                    int t = list.get(i).getValue();\\n                    int vv = (int) mp.get(t);\\n                    mp.put(t,vv-1);\\n                    if(vv==1){\\n                        mp.remove(t);\\n                    }\\n                    i++;\\n                }\\n                \\n                j++;\\n                \\n            }\\n   \\n        }\\n        \\n        \\n        return ans;\\n    }\\n}\\n```",
        "level": "hard",
        "buggy_code": "\nclass Solution {\n    public int[] smallestRange(List<List<Integer>> nums) {\n        int k = nums.size();\n        List<Pair<Integer,Integer>> list = new ArrayList<>();\n        for(int i = 0;i<k;i++){\n            List<Integer> l = nums.get(i);\n            for(int nu : l){\n                list.add(new Pair(nu,i));\n            }\n        }\n        \n        Collections.sort(list,(a,b)-> a.getKey()-b.getKey());\n        int[] ans = new int[2];\n        ans[1] = ans[0] = Integer.MAX_VALUE; \n        int i = 0,j=0;\n        List<Integer> store = new ArrayList<>();\n        HashMap<Integer,Integer> mp = new HashMap<>();\n        int totalType = 0;\n        \n        while(j<list.size()){\n            int nu = list.get(j).getKey();\n            int type = list.get(j).getValue();\n            store.add(nu);\n            int val = mp.getOrDefault(type,0);\n            mp.put(type,val+1);\n            totalType++\n            if(mp.size()<k){\n                j++;\n            }else if(mp.size()==k){\n                if(ans[0]==ans[1] && ans[1] == Integer.MAX_VALUE){\n                    ans[0] = store.get(0);\n                    ans[1] = store.get(store.size()-1);\n                }\n                int dif = store.get(store.size()-1)-store.get(0);\n                if(dif<ans[1]-ans[0]){\n                    ans[0] = store.get(0);\n                    ans[1] = store.get(store.size()-1);\n                }  \n                \n                while(mp.size()==k){\n                    dif = store.get(store.size()-1)-store.get(0);\n                    if(dif<ans[1]-ans[0]){\n                        ans[0] = store.get(0);\n                        ans[1] = store.get(store.size()-1);\n                    }\n                    store.remove(0);\n                    int t = list.get(i).getValue();\n                    int vv = (int) mp.get(t);\n                    mp.put(t,vv-1);\n                    if(vv==1){\n                        mp.remove(t);\n                    }\n                    i++;\n                }\n                \n                j++;\n            }\n        }\n        return ans;\n    }\n}\n",
        "explanations": "\nMissing a semicolon at the end of the line incrementing \"totalType\" variable.\n"
    },
    {
        "slug": "erect-the-fence",
        "description": "You are given an array trees where trees[i] = [xi, yi] represents the location of a tree in the garden.\nFence the entire garden using the minimum length of rope, as it is expensive. The garden is well-fenced only if all the trees are enclosed.\nReturn the coordinates of trees that are exactly located on the fence perimeter. You may return the answer in any order.",
        "examples": [
            "Input: trees = [[1,1],[2,2],[2,0],[2,4],[3,3],[4,2]]\nOutput: [[1,1],[2,0],[4,2],[3,3],[2,4]]\nExplanation: All the trees will be on the perimeter of the fence except the tree at [2, 2], which will be inside the fence.",
            "Input: trees = [[1,2],[2,2],[4,2]]\nOutput: [[4,2],[2,2],[1,2]]\nExplanation: The fence forms a line that passes through all the trees."
        ],
        "constraints": "1 <= trees.length <= 3000\ntrees[i].length == 2\n0 <= xi, yi <= 100\nAll the given positions are unique.",
        "release_time": 1668873110,
        "oracle_code": "class Solution {\n    \n    public int[][] outerTrees(int[][] trees) {\n        if(trees.length == 3){\n            return trees;\n        }\n        Stack<int[]> upper = new Stack<>();\n        Stack<int[]> lower = new Stack<>();\n        \n        Arrays.sort(trees,(p,q) ->\n                  q[0]-p[0]==0?q[1]-p[1]:q[0]-p[0]);\n        \n        for(int i = 0 ; i < trees.length ; i++){\n            int size = trees.length;\n            while(upper.size() >= 2 && angle(upper.get(upper.size() - 2),upper.get(upper.size() - 1),trees[i]) > 0){\n                upper.pop();  \n                }\n            while(lower.size() >= 2 && angle(lower.get(lower.size() - 2),lower.get(lower.size() - 1),trees[i]) < 0){\n                 lower.pop();  \n              }\n            upper.push(trees[i]);\n            lower.push(trees[i]);\n        }\n        \n        \n        Set<int[]> res= new HashSet<>(lower);\n        res.addAll(upper);\n        return res.toArray(new int[res.size()][]);\n    }\n    \n    public int angle(int[] A , int[] B , int[] C){\n        return (C[0] - A[0]) * (B[1] - A[1]) - (B[0] - A[0]) * (C[1] - A[1]);\n    }\n}",
        "content": "```\\nclass Solution {\\n    \\n    public int[][] outerTrees(int[][] trees) {\\n        if(trees.length == 3){\\n            return trees;\\n        }\\n        Stack<int[]> upper = new Stack<>();\\n        Stack<int[]> lower = new Stack<>();\\n        \\n        Arrays.sort(trees,(p,q) ->\\n                  q[0]-p[0]==0?q[1]-p[1]:q[0]-p[0]);\\n        \\n        for(int i = 0 ; i < trees.length ; i++){\\n            int size = trees.length;\\n            while(upper.size() >= 2 && angle(upper.get(upper.size() - 2),upper.get(upper.size() - 1),trees[i]) > 0){\\n                upper.pop();  \\n                }\\n            while(lower.size() >= 2 && angle(lower.get(lower.size() - 2),lower.get(lower.size() - 1),trees[i]) < 0){\\n                 lower.pop();  \\n              }\\n            upper.push(trees[i]);\\n            lower.push(trees[i]);\\n        }\\n        \\n        \\n        Set<int[]> res= new HashSet<>(lower);\\n        res.addAll(upper);\\n        return res.toArray(new int[res.size()][]);\\n    }\\n    \\n    public int angle(int[] A , int[] B , int[] C){\\n        return (C[0] - A[0]) * (B[1] - A[1]) - (B[0] - A[0]) * (C[1] - A[1]);\\n    }\\n}\\n```\\n\\n**Upvote Please**",
        "level": "hard",
        "buggy_code": "\nclass Solution {\n    \n    public int[][] outerTrees(int[][] trees) {\n        if(trees.length == 3)\n            return trees;\n        Stack<int[]> upper = new Stack<>();\n        Stack<int[]> lower = new Stack<>();\n        \n        Arrays.sort(trees,(p,q) ->\n                  q[0]-p[0]==0?q[1]-p[1]:q[0]-p[0]);\n        \n        for(int i = 0 ; i < trees.length ; i++){\n            int size = trees.length;\n            while(upper.size() >= 2 && angle(upper.get(upper.size() - 2),upper.get(upper.size() - 1),trees[i]) > 0){\n                upper.pop();\n                }\n            while(lower.size() >= 2 && angle(lower.get(lower.size() - 2),lower.get(lower.size() - 1),trees[i]) < 0){\n                 lower.pop();   \n              }\n            upper.push(trees[i]);\n            lower.push(trees[i])\n        }\n        \n        \n        Set<int[]> res= new HashSet<>(lower);\n        res.addAll(upper);\n        return res.toArray(new int[res.size()][]);\n    }\n    \n    public int angle(int[] A , int[] B , int[] C){\n        return (C[0] - A[0]) * (B[1] - A[1]) - (B[0] - A[0]) * (C[1] - A[1]);\n    }\n}\n",
        "explanations": "\nThe colon is missing at the end of the line \"lower.push(trees[i])\", causing Compile error.\n"
    },
    {
        "slug": "find-palindrome-with-fixed-length",
        "description": "Given an integer array queries and a positive integer intLength, return an array answer where answer[i] is either the queries[i]th smallest positive palindrome of length intLength or -1 if no such palindrome exists.\nA palindrome is a number that reads the same backwards and forwards. Palindromes cannot have leading zeros.",
        "examples": [
            "Input: queries = [1,2,3,4,5,90], intLength = 3\nOutput: [101,111,121,131,141,999]\nExplanation:\nThe first few palindromes of length 3 are:\n101, 111, 121, 131, 141, 151, 161, 171, 181, 191, 202, ...\nThe 90th palindrome of length 3 is 999.",
            "Input: queries = [2,4,6], intLength = 4\nOutput: [1111,1331,1551]\nExplanation:\nThe first six palindromes of length 4 are:\n1001, 1111, 1221, 1331, 1441, and 1551."
        ],
        "constraints": "1 <= queries.length <= 5 * 104\n1 <= queries[i] <= 109\n1 <= intLength\u00a0<= 15",
        "release_time": 1690442915,
        "oracle_code": "class Solution {\n    public long[] kthPalindrome(int[] queries, int intLength) {\n        int n=queries.length;\n        long ans[]=new long[n];\n        int ans_i=0;\n        \n        \n        int palindrome_present = ( intLength+1 )/2 ;\n        \n        long l=(long)Math.pow(10,palindrome_present-1); //10\n        long r=(long)Math.pow(10,palindrome_present)-1; //99\n        for(int q:queries){\n            if(q<=(r-l+1)){\n                String left_half=Long.toString(l+q-1);\n                String right_half=(new StringBuilder(left_half)).reverse().toString();\n                ans[ans_i]=Long.parseLong( left_half+right_half.substring(intLength % 2 ) );\n                \n            }\n            else{\n                ans[ans_i]=-1;\n            }\n            \n            ans_i++;\n        }\n        \n        return ans;\n    }\n}",
        "content": "# Intuition\\n![upvote.png](https://assets.leetcode.com/users/images/82cc68e9-a96c-40f4-a46a-e7c7966a60cc_1690442908.0847147.png)\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] kthPalindrome(int[] queries, int intLength) {\\n        int n=queries.length;\\n        long ans[]=new long[n];\\n        int ans_i=0;\\n        \\n        \\n        int palindrome_present = ( intLength+1 )/2 ;\\n        \\n        long l=(long)Math.pow(10,palindrome_present-1); //10\\n        long r=(long)Math.pow(10,palindrome_present)-1; //99\\n        for(int q:queries){\\n            if(q<=(r-l+1)){\\n                String left_half=Long.toString(l+q-1);\\n                String right_half=(new StringBuilder(left_half)).reverse().toString();\\n                ans[ans_i]=Long.parseLong( left_half+right_half.substring(intLength % 2 ) );\\n                \\n            }\\n            else{\\n                ans[ans_i]=-1;\\n            }\\n            \\n            ans_i++;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\n    public long[] kthPalindrome(int[] queries, int intLength) {\n        int n=queries.length;\n        long ans[]=new long[n];\n        int ans_i=0;\n        \n        \n        int palindrome_present = ( intLength+1 )/2 \n        \n        long l=(long)Math.pow(10,palindrome_present-1); //10\n        long r=(long)Math.pow(10,palindrome_present)-1; //99\n        for(int q:queries){\n            if(q<=(r-l+1)){\n                String left_half=Long.toString(l+q-1);\n                String right_half=(new StringBuilder(left_half)).reverse().toString();\n                ans[ans_i]=Long.parseLong( left_half+right_half.substring(intLength % 2 ) );\n                \n            }\n            else{\n                ans[ans_i]=-1;\n            }\n            \n            ans_i++;\n        }\n        \n        return ans;\n    }\n}\n",
        "explanations": "\nI inadvertently removed a semicolon after the assignment of variable 'palindrome_present'.\n"
    },
    {
        "slug": "subrectangle-queries",
        "description": "Implement the class SubrectangleQueries\u00a0which receives a rows x cols rectangle as a matrix of integers in the constructor and supports two methods:\n1.\u00a0updateSubrectangle(int row1, int col1, int row2, int col2, int newValue)\n\nUpdates all values with newValue in the subrectangle whose upper left coordinate is (row1,col1) and bottom right coordinate is (row2,col2).\n\n2.\u00a0getValue(int row, int col)\n\nReturns the current value of the coordinate (row,col) from\u00a0the rectangle.",
        "examples": [
            "Input\n[\"SubrectangleQueries\",\"getValue\",\"updateSubrectangle\",\"getValue\",\"getValue\",\"updateSubrectangle\",\"getValue\",\"getValue\"]\n[[[[1,2,1],[4,3,4],[3,2,1],[1,1,1]]],[0,2],[0,0,3,2,5],[0,2],[3,1],[3,0,3,2,10],[3,1],[0,2]]\nOutput\n[null,1,null,5,5,null,10,5]\nExplanation\nSubrectangleQueries subrectangleQueries = new SubrectangleQueries([[1,2,1],[4,3,4],[3,2,1],[1,1,1]]);  \n// The initial rectangle (4x3) looks like:\n// 1 2 1\n// 4 3 4\n// 3 2 1\n// 1 1 1\nsubrectangleQueries.getValue(0, 2); // return 1\nsubrectangleQueries.updateSubrectangle(0, 0, 3, 2, 5);\n// After this update the rectangle looks like:\n// 5 5 5\n// 5 5 5\n// 5 5 5\n// 5 5 5 \nsubrectangleQueries.getValue(0, 2); // return 5\nsubrectangleQueries.getValue(3, 1); // return 5\nsubrectangleQueries.updateSubrectangle(3, 0, 3, 2, 10);\n// After this update the rectangle looks like:\n// 5   5   5\n// 5   5   5\n// 5   5   5\n// 10  10  10 \nsubrectangleQueries.getValue(3, 1); // return 10\nsubrectangleQueries.getValue(0, 2); // return 5",
            "Input\n[\"SubrectangleQueries\",\"getValue\",\"updateSubrectangle\",\"getValue\",\"getValue\",\"updateSubrectangle\",\"getValue\"]\n[[[[1,1,1],[2,2,2],[3,3,3]]],[0,0],[0,0,2,2,100],[0,0],[2,2],[1,1,2,2,20],[2,2]]\nOutput\n[null,1,null,100,100,null,20]\nExplanation\nSubrectangleQueries subrectangleQueries = new SubrectangleQueries([[1,1,1],[2,2,2],[3,3,3]]);\nsubrectangleQueries.getValue(0, 0); // return 1\nsubrectangleQueries.updateSubrectangle(0, 0, 2, 2, 100);\nsubrectangleQueries.getValue(0, 0); // return 100\nsubrectangleQueries.getValue(2, 2); // return 100\nsubrectangleQueries.updateSubrectangle(1, 1, 2, 2, 20);\nsubrectangleQueries.getValue(2, 2); // return 20"
        ],
        "constraints": "There will be at most 500\u00a0operations considering both methods:\u00a0updateSubrectangle and getValue.\n1 <= rows, cols <= 100\nrows ==\u00a0rectangle.length\ncols == rectangle[i].length\n0 <= row1 <= row2 < rows\n0 <= col1 <= col2 < cols\n1 <= newValue, rectangle[i][j] <= 10^9\n0 <= row < rows\n0 <= col < cols",
        "release_time": 1691178896,
        "oracle_code": "class SubrectangleQueries {\n    int[][] ans;\n    public SubrectangleQueries(int[][] rectangle) {\n        ans = rectangle;\n    }\n    \n    public void updateSubrectangle(int row1, int col1, int row2, int col2, int newValue) {\n        for(int i=row1; i<=row2; i++){\n            for(int j=col1; j<=col2; j++){\n                ans[i][j] = newValue;\n            }\n        }\n    }\n    \n    public int getValue(int row, int col) {\n        int val = ans[row][col];\n        return val;\n    }\n}\n\n/**\n * Your SubrectangleQueries object will be instantiated and called as such:\n * SubrectangleQueries obj = new SubrectangleQueries(rectangle);\n * obj.updateSubrectangle(row1,col1,row2,col2,newValue);\n * int param_2 = obj.getValue(row,col);\n */",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. The constructor initializes a 2D array \\'ans\\' to store the rectangle.\\n2. The \\'updateSubrectangle\\' function updates the subrectangle with the given \\'newValue\\' by iterating over the specified range and updating each element.\\n3. The \\'getValue\\' function retrieves the value at the specified row and column in \\'ans\\'.\\n\\n# Complexity\\n- Time complexity: O((row2 - row1 + 1) * (col2 - col1 + 1))\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass SubrectangleQueries {\\n    int[][] ans;\\n    public SubrectangleQueries(int[][] rectangle) {\\n        ans = rectangle;\\n    }\\n    \\n    public void updateSubrectangle(int row1, int col1, int row2, int col2, int newValue) {\\n        for(int i=row1; i<=row2; i++){\\n            for(int j=col1; j<=col2; j++){\\n                ans[i][j] = newValue;\\n            }\\n        }\\n    }\\n    \\n    public int getValue(int row, int col) {\\n        int val = ans[row][col];\\n        return val;\\n    }\\n}\\n\\n/**\\n * Your SubrectangleQueries object will be instantiated and called as such:\\n * SubrectangleQueries obj = new SubrectangleQueries(rectangle);\\n * obj.updateSubrectangle(row1,col1,row2,col2,newValue);\\n * int param_2 = obj.getValue(row,col);\\n */\\n```",
        "level": "medium",
        "buggy_code": "\nclass SubrectangleQueries {\n    int[][] ans;\n    public SubrectangleQueries(int[][] rectangle) {\n        ans = rectangle;\n    }\n    \n    public void updateSubrectangle(int row1, int col1, int row2, int col2, int newValue) {\n        for(int i=row1; i<=row2; i++)\n            for(int j=col1; j<=col2; j++)\n                ans[i][j] = newValue;\n            }\n        }\n    }\n    \n    public int getValue(int row, int col) {\n        int val = ans[row][col];\n        return val;\n    }\n}\n\n/**\n * Your SubrectangleQueries object will be instantiated and called as such:\n * SubrectangleQueries obj = new SubrectangleQueries(rectangle);\n * obj.updateSubrectangle(row1,col1,row2,col2,newValue);\n * int param_2 = obj.getValue(row,col);\n */\n",
        "explanations": "\nThe closing brace for the inner for loop in updateSubrectangle method is missing.\n"
    },
    {
        "slug": "binary-search-tree-iterator",
        "description": "Implement the BSTIterator class that represents an iterator over the in-order traversal of a binary search tree (BST):\n\nBSTIterator(TreeNode root) Initializes an object of the BSTIterator class. The root of the BST is given as part of the constructor. The pointer should be initialized to a non-existent number smaller than any element in the BST.\nboolean hasNext() Returns true if there exists a number in the traversal to the right of the pointer, otherwise returns false.\nint next() Moves the pointer to the right, then returns the number at the pointer.\n\nNotice that by initializing the pointer to a non-existent smallest number, the first call to next() will return the smallest element in the BST.\nYou may assume that next() calls will always be valid. That is, there will be at least a next number in the in-order traversal when next() is called.",
        "examples": [
            "Input\n[\"BSTIterator\", \"next\", \"next\", \"hasNext\", \"next\", \"hasNext\", \"next\", \"hasNext\", \"next\", \"hasNext\"]\n[[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []]\nOutput\n[null, 3, 7, true, 9, true, 15, true, 20, false]\n\nExplanation\nBSTIterator bSTIterator = new BSTIterator([7, 3, 15, null, null, 9, 20]);\nbSTIterator.next();    // return 3\nbSTIterator.next();    // return 7\nbSTIterator.hasNext(); // return True\nbSTIterator.next();    // return 9\nbSTIterator.hasNext(); // return True\nbSTIterator.next();    // return 15\nbSTIterator.hasNext(); // return True\nbSTIterator.next();    // return 20\nbSTIterator.hasNext(); // return False"
        ],
        "constraints": "The number of nodes in the tree is in the range [1, 105].\n0 <= Node.val <= 106\nAt most 105 calls will be made to hasNext, and next.",
        "release_time": 1678769853,
        "oracle_code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass BSTIterator {\n    Stack<TreeNode>s=new Stack<TreeNode>();\n    public BSTIterator(TreeNode root) {\n        pushAll(root);\n    }\n    \n    public int next() {\n        TreeNode temp=s.pop();\n        pushAll(temp.right);\n        return temp.val;\n    }\n    \n    public boolean hasNext() {\n        return !s.isEmpty();\n    }\n    public void pushAll(TreeNode node){\n        while(node!=null){\n            s.push(node);\n            node=node.left;\n        }\n    }\n}\n\n/**\n * Your BSTIterator object will be instantiated and called as such:\n * BSTIterator obj = new BSTIterator(root);\n * int param_1 = obj.next();\n * boolean param_2 = obj.hasNext();\n */",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(H)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass BSTIterator {\\n    Stack<TreeNode>s=new Stack<TreeNode>();\\n    public BSTIterator(TreeNode root) {\\n        pushAll(root);\\n    }\\n    \\n    public int next() {\\n        TreeNode temp=s.pop();\\n        pushAll(temp.right);\\n        return temp.val;\\n    }\\n    \\n    public boolean hasNext() {\\n        return !s.isEmpty();\\n    }\\n    public void pushAll(TreeNode node){\\n        while(node!=null){\\n            s.push(node);\\n            node=node.left;\\n        }\\n    }\\n}\\n\\n/**\\n * Your BSTIterator object will be instantiated and called as such:\\n * BSTIterator obj = new BSTIterator(root);\\n * int param_1 = obj.next();\\n * boolean param_2 = obj.hasNext();\\n */\\n```",
        "level": "medium",
        "buggy_code": "\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass BSTIterator {\n    Stack<TreeNode>s=new Stack<TreeNode>()\n    public BSTIterator(TreeNode root) {\n        pushAll(root);\n    }\n    \n    public int next() {\n        TreeNode temp=s.pop();\n        pushAll(temp.right);\n        return temp.val;\n    }\n    \n    public boolean hasNext() {\n        return !s.isEmpty();\n    }\n    public void pushAll(TreeNode node){\n        while(node!=null){\n            s.push(node);\n            node=node.left;\n        }\n    }\n}\n\n/**\n * Your BSTIterator object will be instantiated and called as such:\n * BSTIterator obj = new BSTIterator(root);\n * int param_1 = obj.next();\n * boolean param_2 = obj.hasNext();\n */\n ",
        "explanations": "\n The bug is the missing semicolon at the end of the stack initialization.\n "
    },
    {
        "slug": "number-of-provinces",
        "description": "There are n cities. Some of them are connected, while some are not. If city a is connected directly with city b, and city b is connected directly with city c, then city a is connected indirectly with city c.\nA province is a group of directly or indirectly connected cities and no other cities outside of the group.\nYou are given an n x n matrix isConnected where isConnected[i][j] = 1 if the ith city and the jth city are directly connected, and isConnected[i][j] = 0 otherwise.\nReturn the total number of provinces.",
        "examples": [
            "Input: isConnected = [[1,1,0],[1,1,0],[0,0,1]]\nOutput: 2",
            "Input: isConnected = [[1,0,0],[0,1,0],[0,0,1]]\nOutput: 3"
        ],
        "constraints": "1 <= n <= 200\nn == isConnected.length\nn == isConnected[i].length\nisConnected[i][j] is 1 or 0.\nisConnected[i][i] == 1\nisConnected[i][j] == isConnected[j][i]",
        "release_time": 1685857349,
        "oracle_code": "class DSU:\n    def __init__(self, n):\n        self.par = list(range(n))\n        self.rank = [1] * n\n        self.size = 1\n    def find(self, u):\n        if u != self.par[u]:\n            self.par[u] = self.find(self.par[u])\n        return self.par[u]\n    def union(self, u, v):\n        uu, vv = self.find(u), self.find(v)\n        if uu == vv:\n            return False\n        if self.rank[uu] > self.rank[vv]:\n            self.par[vv] = uu\n        elif self.rank[vv] > self.rank[uu]:\n            self.par[uu] = vv\n        else:\n            self.par[uu] = vv\n            self.rank[vv] += 1\n        self.size += 1\n        return True\n\nclass Solution:\n    def isConnected(self, u, v, G):\n        return G[u][v] == 1\n\n    def findCircleNum(self, G: List[List[int]]) -> int:\n        n = len(G)\n        uf = DSU(n)\n        if not G:\n            return 0\n        for u in range(n):\n            for v in range(u, n):\n                if self.isConnected(u, v, G):\n                    uf.union(u, v)\n        return len(set([uf.find(i) for i in range(n)]))",
        "content": "\\n# Code\\n```\\nclass DSU:\\n    def __init__(self, n):\\n        self.par = list(range(n))\\n        self.rank = [1] * n\\n        self.size = 1\\n    def find(self, u):\\n        if u != self.par[u]:\\n            self.par[u] = self.find(self.par[u])\\n        return self.par[u]\\n    def union(self, u, v):\\n        uu, vv = self.find(u), self.find(v)\\n        if uu == vv:\\n            return False\\n        if self.rank[uu] > self.rank[vv]:\\n            self.par[vv] = uu\\n        elif self.rank[vv] > self.rank[uu]:\\n            self.par[uu] = vv\\n        else:\\n            self.par[uu] = vv\\n            self.rank[vv] += 1\\n        self.size += 1\\n        return True\\n\\nclass Solution:\\n    def isConnected(self, u, v, G):\\n        return G[u][v] == 1\\n\\n    def findCircleNum(self, G: List[List[int]]) -> int:\\n        n = len(G)\\n        uf = DSU(n)\\n        if not G:\\n            return 0\\n        for u in range(n):\\n            for v in range(u, n):\\n                if self.isConnected(u, v, G):\\n                    uf.union(u, v)\\n        return len(set([uf.find(i) for i in range(n)]))\\n\\n```",
        "level": "medium",
        "buggy_code": "\nclass DSU:\n    def __init__(self, n)\n        self.par = list(range(n))\n        self.rank = [1] * n\n        self.size = 1\n    def find(self, u):\n        if u != self.par[u]:\n            self.par[u] = self.find(self.par[u])\n        return self.par[u]\n    def union(self, u, v):\n        uu, vv = self.find(u), self.find(v)\n        if uu == vv:\n            return False\n        if self.rank[uu] > self.rank[vv]:\n            self.par[vv] = uu\n        elif self.rank[vv] > self.rank[uu]:\n            self.par[uu] = vv\n        else:\n            self.par[uu] = vv\n            self.rank[vv] += 1\n        self.size += 1\n        return True\n\nclass Solution:\n    def isConnected(self, u, v, G):\n        return G[u][v] == 1\n\n    def findCircleNum(self, G: List[List[int]]) -> int:\n        n = len(G)\n        uf = DSU(n)\n        if not G:\n            return 0\n        for u in range(n):\n            for v in range(u, n):\n                if self.isConnected(u, v, G):\n                    uf.union(u, v)\n        return len(set([uf.find(i) for i in range(n)]))\n",
        "explanations": "\nThere is a missing colon after the '__init__' function definition in 'DSU' class. \n"
    },
    {
        "slug": "word-ladder-ii",
        "description": "A transformation sequence from word beginWord to word endWord using a dictionary wordList is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that:\n\nEvery adjacent pair of words differs by a single letter.\nEvery si for 1 <= i <= k is in wordList. Note that beginWord does not need to be in wordList.\nsk == endWord\n\nGiven two words, beginWord and endWord, and a dictionary wordList, return all the shortest transformation sequences from beginWord to endWord, or an empty list if no such sequence exists. Each sequence should be returned as a list of the words [beginWord, s1, s2, ..., sk].",
        "examples": [
            "Input: beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\nOutput: [[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],[\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]]\nExplanation:\u00a0There are 2 shortest transformation sequences:\n\"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> \"cog\"\n\"hit\" -> \"hot\" -> \"lot\" -> \"log\" -> \"cog\"",
            "Input: beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\nOutput: []\nExplanation: The endWord \"cog\" is not in wordList, therefore there is no valid transformation sequence."
        ],
        "constraints": "1 <= beginWord.length <= 5\nendWord.length == beginWord.length\n1 <= wordList.length <= 500\nwordList[i].length == beginWord.length\nbeginWord, endWord, and wordList[i] consist of lowercase English letters.\nbeginWord != endWord\nAll the words in wordList are unique.\nThe sum of all shortest transformation sequences does not exceed 105.",
        "release_time": 1692205615,
        "oracle_code": "class Solution {\n    String b;\n\n    // Create a hashmap of type word->level to get the idea \n    // on which level the word comes after the transformations.\n\n    HashMap < String, Integer > mpp;\n\n    // A list for storing the final answer.\n    List < List < String >> ans;\n    private void dfs(String word, List < String > seq) {\n\n        // Function for implementing backtracking using the created map\n        // in reverse order to find the transformation sequence in less time.\n\n        // Base condition :\n        // If word equals beginWord, we\\u2019ve found one of the sequences\n        // simply reverse the sequence and return. \n        if (word.equals(b)) {\n\n            // Since java works with reference, create\n            // a duplicate and store the reverse of it\n            List < String > dup = new ArrayList < > (seq);\n            Collections.reverse(dup);\n            ans.add(dup);\n            return;\n        }\n        int steps = mpp.get(word);\n        int sz = word.length();\n\n        // Replace each character of the word with letters from a-z \n        // and check whether the transformed word is present in the map\n        // and at the previous level or not.\n        for (int i = 0; i < sz; i++) {\n\n            for (char ch = 'a'; ch <= 'z'; ch++) {\n                char replacedCharArray[] = word.toCharArray();\n                replacedCharArray[i] = ch;\n                String replacedWord = new String(replacedCharArray);\n                if (mpp.containsKey(replacedWord) &&\n                    mpp.get(replacedWord) + 1 == steps) {\n\n                    seq.add(replacedWord);\n                    dfs(replacedWord, seq);\n\n                    // pop the current word from the back of the queue\n                    // to traverse other possibilities.\n                    seq.remove(seq.size() - 1);\n                }\n            }\n        }\n    }\n    public List < List < String >> findLadders(String beginWord, String endWord,\n        List < String > wordList) {\n\n        // Push all values of wordList into a set\n        // to make deletion from it easier and in less time complexity.\n        Set < String > st = new HashSet < String > ();\n        int len = wordList.size();\n        for (int i = 0; i < len; i++) {\n            st.add(wordList.get(i));\n        }\n\n        // Perform BFS traversal and push the string in the queue\n        // as soon as they\\u2019re found in the wordList.\n        Queue < String > q = new LinkedList < > ();\n        b = beginWord;\n        q.add(beginWord);\n        mpp = new HashMap < > ();\n\n        // beginWord initialised with level 1.\n        mpp.put(beginWord, 1);\n        int sizee = beginWord.length();\n        st.remove(beginWord);\n        while (!q.isEmpty()) {\n            String word = q.peek();\n            int steps = mpp.get(word);\n            q.remove();\n\n            // Break out if the word matches the endWord.\n            if (word.equals(endWord)) break;\n\n            // Replace each character of the word with letters from a-z \n            // and check whether the transformed word is present in the \n            // wordList or not, if yes then push to queue\n            for (int i = 0; i < sizee; i++) {\n\n                for (char ch = 'a'; ch <= 'z'; ch++) {\n                    char replacedCharArray[] = word.toCharArray();\n                    replacedCharArray[i] = ch;\n                    String replacedWord = new String(replacedCharArray);\n                    if (st.contains(replacedWord) == true) {\n                        q.add(replacedWord);\n                        st.remove(replacedWord);\n\n                        // push the word along with its level\n                        // in the map data structure.\n                        mpp.put(replacedWord, steps + 1);\n                    }\n                }\n\n\n            }\n        }\n        ans = new ArrayList < > ();\n\n        // If we reach the endWord, we stop and move to step-2\n        // that is to perform reverse dfs traversal.\n        if (mpp.containsKey(endWord) == true) {\n            List < String > seq = new ArrayList < > ();\n            seq.add(endWord);\n            dfs(endWord, seq);\n        }\n        return ans;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/1ea15e79-7ca5-4594-83b4-88b42dc1e6e7_1692205611.608349.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    String b;\\n\\n    // Create a hashmap of type word->level to get the idea \\n    // on which level the word comes after the transformations.\\n\\n    HashMap < String, Integer > mpp;\\n\\n    // A list for storing the final answer.\\n    List < List < String >> ans;\\n    private void dfs(String word, List < String > seq) {\\n\\n        // Function for implementing backtracking using the created map\\n        // in reverse order to find the transformation sequence in less time.\\n\\n        // Base condition :\\n        // If word equals beginWord, we\\u2019ve found one of the sequences\\n        // simply reverse the sequence and return. \\n        if (word.equals(b)) {\\n\\n            // Since java works with reference, create\\n            // a duplicate and store the reverse of it\\n            List < String > dup = new ArrayList < > (seq);\\n            Collections.reverse(dup);\\n            ans.add(dup);\\n            return;\\n        }\\n        int steps = mpp.get(word);\\n        int sz = word.length();\\n\\n        // Replace each character of the word with letters from a-z \\n        // and check whether the transformed word is present in the map\\n        // and at the previous level or not.\\n        for (int i = 0; i < sz; i++) {\\n\\n            for (char ch = \\'a\\'; ch <= \\'z\\'; ch++) {\\n                char replacedCharArray[] = word.toCharArray();\\n                replacedCharArray[i] = ch;\\n                String replacedWord = new String(replacedCharArray);\\n                if (mpp.containsKey(replacedWord) &&\\n                    mpp.get(replacedWord) + 1 == steps) {\\n\\n                    seq.add(replacedWord);\\n                    dfs(replacedWord, seq);\\n\\n                    // pop the current word from the back of the queue\\n                    // to traverse other possibilities.\\n                    seq.remove(seq.size() - 1);\\n                }\\n            }\\n        }\\n    }\\n    public List < List < String >> findLadders(String beginWord, String endWord,\\n        List < String > wordList) {\\n\\n        // Push all values of wordList into a set\\n        // to make deletion from it easier and in less time complexity.\\n        Set < String > st = new HashSet < String > ();\\n        int len = wordList.size();\\n        for (int i = 0; i < len; i++) {\\n            st.add(wordList.get(i));\\n        }\\n\\n        // Perform BFS traversal and push the string in the queue\\n        // as soon as they\\u2019re found in the wordList.\\n        Queue < String > q = new LinkedList < > ();\\n        b = beginWord;\\n        q.add(beginWord);\\n        mpp = new HashMap < > ();\\n\\n        // beginWord initialised with level 1.\\n        mpp.put(beginWord, 1);\\n        int sizee = beginWord.length();\\n        st.remove(beginWord);\\n        while (!q.isEmpty()) {\\n            String word = q.peek();\\n            int steps = mpp.get(word);\\n            q.remove();\\n\\n            // Break out if the word matches the endWord.\\n            if (word.equals(endWord)) break;\\n\\n            // Replace each character of the word with letters from a-z \\n            // and check whether the transformed word is present in the \\n            // wordList or not, if yes then push to queue\\n            for (int i = 0; i < sizee; i++) {\\n\\n                for (char ch = \\'a\\'; ch <= \\'z\\'; ch++) {\\n                    char replacedCharArray[] = word.toCharArray();\\n                    replacedCharArray[i] = ch;\\n                    String replacedWord = new String(replacedCharArray);\\n                    if (st.contains(replacedWord) == true) {\\n                        q.add(replacedWord);\\n                        st.remove(replacedWord);\\n\\n                        // push the word along with its level\\n                        // in the map data structure.\\n                        mpp.put(replacedWord, steps + 1);\\n                    }\\n                }\\n\\n\\n            }\\n        }\\n        ans = new ArrayList < > ();\\n\\n        // If we reach the endWord, we stop and move to step-2\\n        // that is to perform reverse dfs traversal.\\n        if (mpp.containsKey(endWord) == true) {\\n            List < String > seq = new ArrayList < > ();\\n            seq.add(endWord);\\n            dfs(endWord, seq);\\n        }\\n        return ans;\\n    }\\n}\\n```",
        "level": "hard",
        "buggy_code": "\nclass Solution {\n    String b;\n\n    HashMap < String, Integer > mpp;\n\n    List < List < String >> ans;\n    private void dfs(String word, List < String > seq) {\n\n        if (word.equals(b)) {\n\n            List < String > dup = new ArrayList < > (seq);\n            Collections.reverse(dup);\n            ans.add(dup);\n            return;\n        }\n        int steps = mpp.get(word);\n        int sz = word.length();\n\n        for (int i = 0; i < sz; i++) {\n\n            for (char ch = 'a'; ch <= 'z'; ch++) {\n                char replacedCharArray[] = word.toCharArray();\n                replacedCharArray[i] = ch;\n                String replacedWord = new String(replacedCharArray);\n                if (mpp.containsKey(replacedWord) &&\n                    mpp.get(replacedWord) + 1 == steps {\n\n                    seq.add(replacedWord);\n                    dfs(replacedWord, seq);\n\n                    seq.remove(seq.size() - 1);\n                }\n            }\n        }\n    }\n    public List < List < String >> findLadders(String beginWord, String endWord,\n        List < String > wordList) {\n\n        Set < String > st = new HashSet < String > ();\n        int len = wordList.size();\n        for (int i = 0; i < len; i++) {\n            st.add(wordList.get(i));\n        }\n\n        Queue < String > q = new LinkedList < > ();\n        b = beginWord;\n        q.add(beginWord);\n        mpp = new HashMap < > ();\n\n        mpp.put(beginWord, 1);\n        int sizee = beginWord.length();\n        st.remove(beginWord);\n        while (!q.isEmpty()) {\n            String word = q.peek();\n            int steps = mpp.get(word);\n            q.remove();\n\n            if (word.equals(endWord)) break;\n\n            for (int i = 0; i < sizee; i++) {\n\n                for (char ch = 'a'; ch <= 'z'; ch++) {\n                    char replacedCharArray[] = word.toCharArray();\n                    replacedCharArray[i] = ch;\n                    String replacedWord = new String(replacedCharArray);\n                    if (st.contains(replacedWord) == true) {\n                        q.add(replacedWord);\n                        st.remove(replacedWord);\n\n                        mpp.put(replacedWord, steps + 1);\n                    }\n                }\n\n\n            }\n        }\n        ans = new ArrayList < > ();\n\n        if (mpp.containsKey(endWord) == true) {\n            List < String > seq = new ArrayList < > ();\n            seq.add(endWord);\n            dfs(endWord, seq);\n        }\n        return ans;\n    }\n}\n",
        "explanations": "\nThe missing closing parenthesis after \"steps\" inside the \"if\" statement causes a compilation error.\n"
    },
    {
        "slug": "sign-of-the-product-of-an-array",
        "description": "There is a function signFunc(x) that returns:\n\n1 if x is positive.\n-1 if x is negative.\n0 if x is equal to 0.\n\nYou are given an integer array nums. Let product be the product of all values in the array nums.\nReturn signFunc(product).",
        "examples": [
            "Input: nums = [-1,-2,-3,-4,3,2,1]\nOutput: 1\nExplanation: The product of all values in the array is 144, and signFunc(144) = 1",
            "Input: nums = [1,5,0,2,-3]\nOutput: 0\nExplanation: The product of all values in the array is 0, and signFunc(0) = 0",
            "Input: nums = [-1,1,-1,1,-1]\nOutput: -1\nExplanation: The product of all values in the array is -1, and signFunc(-1) = -1"
        ],
        "constraints": "1 <= nums.length <= 1000\n-100 <= nums[i] <= 100",
        "release_time": 1682989041,
        "oracle_code": "class Solution { // Vezzz\n  public int arraySign(int[] nums) {\n    int z = 0;\n    for (int v : nums)\n      if (v == 0)\n        return 0;\n      else\n        z ^= v;\n    return z >> 31 | 1;\n  }\n}",
        "content": "# Intuition\\nOnly the sign bit matter.\\n\\n# Approach\\n- 2 negative sign bit cancel each other using xor.\\n- Early exit on `0`.\\n- Drag the sign bit over the whole int and set last bit.\\n\\n# Complexity\\n- Time complexity: *`O(n)`*\\n- Space complexity: *`O(1)`*\\n\\n# Code\\n```\\nclass Solution { // Vezzz\\n  public int arraySign(int[] nums) {\\n    int z = 0;\\n    for (int v : nums)\\n      if (v == 0)\\n        return 0;\\n      else\\n        z ^= v;\\n    return z >> 31 | 1;\\n  }\\n}\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution { \n  public int arraySign(int[] nums) {\n    int z = 0\n    for (int v : nums)\n      if (v == 0)\n        return 0;\n      else\n        z ^= v;\n    return z >> 31 | 1;\n  }\n}\n",
        "explanations": "\nThe missing semicolon (:) after int z = 0 causes a syntax error.\n"
    },
    {
        "slug": "sum-in-a-matrix",
        "description": "You are given a 0-indexed 2D integer array nums. Initially, your score is 0. Perform the following operations until the matrix becomes empty:\n\nFrom each row in the matrix, select the largest number and remove it. In the case of a tie, it does not matter which number is chosen.\nIdentify the highest number amongst all those removed in step 1. Add that number to your score.\n\nReturn the final score.",
        "examples": [
            "Input: nums = [[7,2,1],[6,4,2],[6,5,3],[3,2,1]]\nOutput: 15\nExplanation: In the first operation, we remove 7, 6, 6, and 3. We then add 7 to our score. Next, we remove 2, 4, 5, and 2. We add 5 to our score. Lastly, we remove 1, 2, 3, and 1. We add 3 to our score. Thus, our final score is 7 + 5 + 3 = 15.",
            "Input: nums = [[1]]\nOutput: 1\nExplanation: We remove 1 and add it to the answer. We return 1."
        ],
        "constraints": "1 <= nums.length <= 300\n1 <= nums[i].length <= 500\n0 <= nums[i][j] <= 103",
        "release_time": 1683993959,
        "oracle_code": "class Solution {\n    public int matrixSum(int[][] nums) {\n        int score = 0;\n        int n = nums.length;\n        int m = nums[0].length;\n        for(int[] a :nums)\n        {\n            Arrays.sort(a);\n        }\n        for(int i=0;i<m;i++)\n        {\n            int max = 0;\n            for(int j=0;j<n;j++)\n            {\n                max = Math.max(max,nums[j][i]);\n            }\n            score+=max;\n        }\n        return score;\n    }\n}",
        "content": "# Intuition\\n**First sort the array rowwise then add maximum for each column.**\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        int score = 0;\\n        int n = nums.length;\\n        int m = nums[0].length;\\n        for(int[] a :nums)\\n        {\\n            Arrays.sort(a);\\n        }\\n        for(int i=0;i<m;i++)\\n        {\\n            int max = 0;\\n            for(int j=0;j<n;j++)\\n            {\\n                max = Math.max(max,nums[j][i]);\\n            }\\n            score+=max;\\n        }\\n        return score;\\n    }\\n}\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\n    public int matrixSum(int[][] nums) {\n        int score = 0;\n        int n = nums.length\n        int m = nums[0].length;\n        for(int[] a :nums)\n        {\n            Arrays.sort(a);\n        }\n        for(int i=0;i<m;i++)\n        {\n            int max = 0;\n            for(int j=0;j<n;j++)\n            {\n                max = Math.max(max,nums[j][i]);\n            }\n            score+=max;\n        }\n        return score;\n    }\n}\n",
        "explanations": "\nThere is a missing semicolon at the end of the variable n declaration.\n"
    },
    {
        "slug": "design-graph-with-shortest-path-calculator",
        "description": "There is a directed weighted graph that consists of n nodes numbered from 0 to n - 1. The edges of the graph are initially represented by the given array edges where edges[i] = [fromi, toi, edgeCosti] meaning that there is an edge from fromi to toi with the cost edgeCosti.\nImplement the Graph class:\n\nGraph(int n, int[][] edges) initializes the object with n nodes and the given edges.\naddEdge(int[] edge) adds an edge to the list of edges where edge = [from, to, edgeCost]. It is guaranteed that there is no edge between the two nodes before adding this one.\nint shortestPath(int node1, int node2) returns the minimum cost of a path from node1 to node2. If no path exists, return -1. The cost of a path is the sum of the costs of the edges in the path.",
        "examples": [
            "Input\n[\"Graph\", \"shortestPath\", \"shortestPath\", \"addEdge\", \"shortestPath\"]\n[[4, [[0, 2, 5], [0, 1, 2], [1, 2, 1], [3, 0, 3]]], [3, 2], [0, 3], [[1, 3, 4]], [0, 3]]\nOutput\n[null, 6, -1, null, 6]\n\nExplanation\nGraph g = new Graph(4, [[0, 2, 5], [0, 1, 2], [1, 2, 1], [3, 0, 3]]);\ng.shortestPath(3, 2); // return 6. The shortest path from 3 to 2 in the first diagram above is 3 -> 0 -> 1 -> 2 with a total cost of 3 + 2 + 1 = 6.\ng.shortestPath(0, 3); // return -1. There is no path from 0 to 3.\ng.addEdge([1, 3, 4]); // We add an edge from node 1 to node 3, and we get the second diagram above.\ng.shortestPath(0, 3); // return 6. The shortest path from 0 to 3 now is 0 -> 1 -> 3 with a total cost of 2 + 4 = 6."
        ],
        "constraints": "1 <= n <= 100\n0 <= edges.length <= n * (n - 1)\nedges[i].length == edge.length == 3\n0 <= fromi, toi, from, to, node1, node2 <= n - 1\n1 <= edgeCosti, edgeCost <= 106\nThere are no repeated edges and no self-loops in the graph at any point.\nAt most 100 calls will be made for addEdge.\nAt most 100 calls will be made for shortestPath.",
        "release_time": 1681574555,
        "oracle_code": "class Graph {\n    List<List<int[]>> adj=new ArrayList<>();\n    int n;\n    public Graph(int n, int[][] edges) {\n        for(int i=0;i<n;i++){\n            adj.add(new ArrayList<>());\n        }\n        this.n=n;\n        for(int edge[]: edges){\n            adj.get(edge[0]).add(new int[]{edge[1],edge[2]});\n        }\n    }\n    \n    public void addEdge(int[] edge) {\n        adj.get(edge[0]).add(new int[]{edge[1],edge[2]});\n    }\n    \n    public int shortestPath(int node1, int node2) {\n        int dist[]=new int[n+1];\n        Arrays.fill(dist,Integer.MAX_VALUE);\n        dist[node1]=0;\n        PriorityQueue<int[]> pq=new PriorityQueue<>((a,b)->a[1]-b[1]);\n        pq.add(new int[]{node1,0});\n        while(!pq.isEmpty()){\n            int u=pq.poll()[0];\n            for(int p[]: adj.get(u)){\n                int v=p[0];\n                int w=p[1];\n                if(dist[v]>dist[u]+w){\n                    dist[v]=dist[u]+w;\n                    pq.add(new int[]{v,dist[v]});\n                }\n            }\n        }\n        if(dist[node2]==Integer.MAX_VALUE){\n                return -1;\n        }\n        return dist[node2];\n    }\n    \n}\n\n/**\n * Your Graph object will be instantiated and called as such:\n * Graph obj = new Graph(n, edges);\n * obj.addEdge(edge);\n * int param_2 = obj.shortestPath(node1,node2);\n */",
        "content": "\\n\\n# Code\\n```\\nclass Graph {\\n    List<List<int[]>> adj=new ArrayList<>();\\n    int n;\\n    public Graph(int n, int[][] edges) {\\n        for(int i=0;i<n;i++){\\n            adj.add(new ArrayList<>());\\n        }\\n        this.n=n;\\n        for(int edge[]: edges){\\n            adj.get(edge[0]).add(new int[]{edge[1],edge[2]});\\n        }\\n    }\\n    \\n    public void addEdge(int[] edge) {\\n        adj.get(edge[0]).add(new int[]{edge[1],edge[2]});\\n    }\\n    \\n    public int shortestPath(int node1, int node2) {\\n        int dist[]=new int[n+1];\\n        Arrays.fill(dist,Integer.MAX_VALUE);\\n        dist[node1]=0;\\n        PriorityQueue<int[]> pq=new PriorityQueue<>((a,b)->a[1]-b[1]);\\n        pq.add(new int[]{node1,0});\\n        while(!pq.isEmpty()){\\n            int u=pq.poll()[0];\\n            for(int p[]: adj.get(u)){\\n                int v=p[0];\\n                int w=p[1];\\n                if(dist[v]>dist[u]+w){\\n                    dist[v]=dist[u]+w;\\n                    pq.add(new int[]{v,dist[v]});\\n                }\\n            }\\n        }\\n        if(dist[node2]==Integer.MAX_VALUE){\\n                return -1;\\n        }\\n        return dist[node2];\\n    }\\n    \\n}\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph obj = new Graph(n, edges);\\n * obj.addEdge(edge);\\n * int param_2 = obj.shortestPath(node1,node2);\\n */",
        "level": "hard",
        "buggy_code": "\nclass Graph {\n    List<List<int[]>> adj=new ArrayList<>();\n    int n;\n    public Graph(int n, int[][] edges) {\n        for(int i=0;i<n;i++){\n            adj.add(new ArrayList<>());\n        }\n        this.n=n;\n        for(int edge: edges){\n            adj.get(edge[0]).add(new int[]{edge[1],edge[2]});\n        }\n    }\n    \n    public void addEdge(int[] edge) {\n        adj.get(edge[0]).add(new int[]{edge[1],edge[2]});\n    }\n    \n    public int shortestPath(int node1, int node2) {\n        int dist[]=new int[n+1];\n        Arrays.fill(dist,Integer.MAX_VALUE);\n        dist[node1]=0;\n        PriorityQueue<int[]> pq=new PriorityQueue<>((a,b)->a[1]-b[1]);\n        pq.add(new int[]{node1,0});\n        while(!pq.isEmpty()){\n            int u=pq.poll()[0];\n            for(int p[]: adj.get(u)){\n                int v=p[0];\n                int w=p[1];\n                if(dist[v]>dist[u]+w){\n                    dist[v]=dist[u]+w;\n                    pq.add(new int[]{v,dist[v]});\n                }\n            }\n        }\n        if(dist[node2]==Integer.MAX_VALUE){\n                return -1;\n        }\n        return dist[node2];\n    }\n}\n",
        "explanations": "\nThe missing brackets for the \"edge[]\" in for-loop inside the constructor causes wrong iteration.\n"
    },
    {
        "slug": "add-strings",
        "description": "Given two non-negative integers, num1 and num2 represented as string, return the sum of num1 and num2 as a string.\nYou must solve the problem without using any built-in library for handling large integers (such as BigInteger). You must also not convert the inputs to integers directly.",
        "examples": [
            "Input: num1 = \"11\", num2 = \"123\"\nOutput: \"134\"",
            "Input: num1 = \"456\", num2 = \"77\"\nOutput: \"533\"",
            "Input: num1 = \"0\", num2 = \"0\"\nOutput: \"0\""
        ],
        "constraints": "1 <= num1.length, num2.length <= 104\nnum1 and num2 consist of only digits.\nnum1 and num2 don't have any leading zeros except for the zero itself.",
        "release_time": 1692165728,
        "oracle_code": "class Solution:\n    def addStrings(self, num1: str, num2: str) -> str:\n        sys.set_int_max_str_digits(10000)\n        nattu = int(num1)\n        babu = int(num2)\n        result = str(nattu+babu)\n        return result",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def addStrings(self, num1: str, num2: str) -> str:\\n        sys.set_int_max_str_digits(10000)\\n        nattu = int(num1)\\n        babu = int(num2)\\n        result = str(nattu+babu)\\n        return result\\n\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution:\n    def addStrings(self, num1: str, num2: str) -> str:\n        sys.set_int_max_str_digits 10000\n        nattu = int(num1)\n        babu = int(num2)\n        result = str(nattu+babu)\n        return result\n",
        "explanations": "\nOmitted parentheses after sys.set_int_max_str_digits cause a syntax error in java.\n"
    },
    {
        "slug": "check-if-one-string-swap-can-make-strings-equal",
        "description": "You are given two strings s1 and s2 of equal length. A string swap is an operation where you choose two indices in a string (not necessarily different) and swap the characters at these indices.\nReturn true if it is possible to make both strings equal by performing at most one string swap on exactly one of the strings. Otherwise, return false.",
        "examples": [
            "Input: s1 = \"bank\", s2 = \"kanb\"\nOutput: true\nExplanation: For example, swap the first character with the last character of s2 to make \"bank\".",
            "Input: s1 = \"attack\", s2 = \"defend\"\nOutput: false\nExplanation: It is impossible to make them equal with one string swap.",
            "Input: s1 = \"kelb\", s2 = \"kelb\"\nOutput: true\nExplanation: The two strings are already equal, so no string swap operation is required."
        ],
        "constraints": "1 <= s1.length, s2.length <= 100\ns1.length == s2.length\ns1 and s2 consist of only lowercase English letters.",
        "release_time": 1679756521,
        "oracle_code": "class Solution {\n    public boolean areAlmostEqual(String s1, String s2) {\n        if(s1.equals(s2))\n        return true;\n        ArrayList<Character> ts=new ArrayList<>();\n        ArrayList<Character> ts1=new ArrayList<>();\n        int count=0;\n        for(int i=0;i<s1.length();i++){\n            if(s1.charAt(i)!=s2.charAt(i)){\n            ts.add(s1.charAt(i));\n            ts1.add(s2.charAt(i));    \n        }\n        }\n        for(Character co:ts){\n            if(!(ts1.contains(co)))\n            return false;\n        }\n        return (ts.size()==2 && ts1.size()==2)?true:false;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean areAlmostEqual(String s1, String s2) {\\n        if(s1.equals(s2))\\n        return true;\\n        ArrayList<Character> ts=new ArrayList<>();\\n        ArrayList<Character> ts1=new ArrayList<>();\\n        int count=0;\\n        for(int i=0;i<s1.length();i++){\\n            if(s1.charAt(i)!=s2.charAt(i)){\\n            ts.add(s1.charAt(i));\\n            ts1.add(s2.charAt(i));    \\n        }\\n        }\\n        for(Character co:ts){\\n            if(!(ts1.contains(co)))\\n            return false;\\n        }\\n        return (ts.size()==2 && ts1.size()==2)?true:false;\\n    }\\n}\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\n    public boolean areAlmostEqual(String s1, String s2) {\n        if(s1.equals(s2))\n        return true;\n        ArrayList<Character> ts=new ArrayList<>();\n        ArrayList<Character> ts1=new ArrayList<>();\n        int count=0;\n        for(int i=0;i<s1.length();i++){\n            if(s1.charAt(i)!=s2.charAt(i)){\n            ts.add(s1.charAt(i))\n            ts1.add(s2.charAt(i));    \n        }\n        }\n        for(Character co:ts){\n            if(!(ts1.contains(co)))\n            return false;\n        }\n        return (ts.size()==2 && ts1.size()==2)?true:false;\n    }\n}\n",
        "explanations": "\nThe bug is at line number 10, there should be a semicolon at the end.\n"
    },
    {
        "slug": "random-point-in-non-overlapping-rectangles",
        "description": "You are given an array of non-overlapping axis-aligned rectangles rects where rects[i] = [ai, bi, xi, yi] indicates that (ai, bi) is the bottom-left corner point of the ith rectangle and (xi, yi) is the top-right corner point of the ith rectangle. Design an algorithm to pick a random integer point inside the space covered by one of the given rectangles. A point on the perimeter of a rectangle is included in the space covered by the rectangle.\nAny integer point inside the space covered by one of the given rectangles should be equally likely to be returned.\nNote that an integer point is a point that has integer coordinates.\nImplement the Solution class:\n\nSolution(int[][] rects) Initializes the object with the given rectangles rects.\nint[] pick() Returns a random integer point [u, v] inside the space covered by one of the given rectangles.",
        "examples": [
            "Input\n[\"Solution\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\"]\n[[[[-2, -2, 1, 1], [2, 2, 4, 6]]], [], [], [], [], []]\nOutput\n[null, [1, -2], [1, -1], [-1, -2], [-2, -2], [0, 0]]\n\nExplanation\nSolution solution = new Solution([[-2, -2, 1, 1], [2, 2, 4, 6]]);\nsolution.pick(); // return [1, -2]\nsolution.pick(); // return [1, -1]\nsolution.pick(); // return [-1, -2]\nsolution.pick(); // return [-2, -2]\nsolution.pick(); // return [0, 0]"
        ],
        "constraints": "1 <= rects.length <= 100\nrects[i].length == 4\n-109 <= ai < xi <= 109\n-109 <= bi < yi <= 109\nxi - ai <= 2000\nyi - bi <= 2000\nAll the rectangles do not overlap.\nAt most 104 calls will be made to pick.",
        "release_time": 1683885250,
        "oracle_code": "class Solution {\n    \n    int[][] rects;\n    TreeMap<Integer, Integer> weightedRectIndex = new TreeMap<>();\n    int nPoints = 0;\n    \n    Random rng = new Random();\n\n    public Solution(int[][] rects) {\n        this.rects = rects;\n        int index = 0;\n        for (int[] rect : rects) {\n\t\t    // inserts cumulative weight key pointing to rectangle index\n            weightedRectIndex.put(nPoints, index++);\n            nPoints += width(rect) * height(rect);\n        }\n    }\n    \n    public int[] pick() {\n\t    // generates random point within total weight\n        int point = rng.nextInt(nPoints);\n\t\t// finds appropriate rectangle\n        var entry = weightedRectIndex.floorEntry(point);\n\t\t// find point within the current rectangle\n        int rectPoint = point - entry.getKey();\n        int[] rect = rects[entry.getValue()];\n        return new int[]{\n            rect[0] + rectPoint % width(rect), \n            rect[1] + rectPoint / width(rect)};\n    }\n    \n    private int width(int[] rect) {\n        return rect[2] - rect[0] + 1;\n    }\n    \n    private int height(int[] rect) {\n        return rect[3] - rect[1] + 1;\n    }\n}",
        "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    \\n    int[][] rects;\\n    TreeMap<Integer, Integer> weightedRectIndex = new TreeMap<>();\\n    int nPoints = 0;\\n    \\n    Random rng = new Random();\\n\\n    public Solution(int[][] rects) {\\n        this.rects = rects;\\n        int index = 0;\\n        for (int[] rect : rects) {\\n\\t\\t    // inserts cumulative weight key pointing to rectangle index\\n            weightedRectIndex.put(nPoints, index++);\\n            nPoints += width(rect) * height(rect);\\n        }\\n    }\\n    \\n    public int[] pick() {\\n\\t    // generates random point within total weight\\n        int point = rng.nextInt(nPoints);\\n\\t\\t// finds appropriate rectangle\\n        var entry = weightedRectIndex.floorEntry(point);\\n\\t\\t// find point within the current rectangle\\n        int rectPoint = point - entry.getKey();\\n        int[] rect = rects[entry.getValue()];\\n        return new int[]{\\n            rect[0] + rectPoint % width(rect), \\n            rect[1] + rectPoint / width(rect)};\\n    }\\n    \\n    private int width(int[] rect) {\\n        return rect[2] - rect[0] + 1;\\n    }\\n    \\n    private int height(int[] rect) {\\n        return rect[3] - rect[1] + 1;\\n    }\\n}\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\n    \n    int[][] rects;\n    TreeMap<Integer, Integer> weightedRectIndex = new TreeMap<>();\n    int nPoints = 0\n    \n    Random rng = new Random();\n\n    public Solution(int[][] rects) {\n        this.rects = rects;\n        int index = 0;\n        for (int[] rect : rects) {\n            weightedRectIndex.put(nPoints, index++);\n            nPoints += width(rect) * height(rect);\n        }\n    }\n    \n    public int[] pick() {\n        int point = rng.nextInt(nPoints);\n        var entry = weightedRectIndex.floorEntry(point);\n        int rectPoint = point - entry.getKey();\n        int[] rect = rects[entry.getValue()];\n        return new int[]{\n            rect[0] + rectPoint % width(rect), \n            rect[1] + rectPoint / width(rect)};\n    }\n    \n    private int width(int[] rect) {\n        return rect[2] - rect[0] + 1;\n    }\n    \n    private int height(int[] rect) {\n        return rect[3] - rect[1] + 1;\n    }\n}\n",
        "explanations": "\nMissing semicolon after 'int nPoints = 0' which results in syntax error.\n"
    }
]