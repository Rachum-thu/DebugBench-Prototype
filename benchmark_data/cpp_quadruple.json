[
    {
        "slug": "shortest-path-with-alternating-colors",
        "description": "You are given an integer n, the number of nodes in a directed graph where the nodes are labeled from 0 to n - 1. Each edge is red or blue in this graph, and there could be self-edges and parallel edges.\nYou are given two arrays redEdges and blueEdges where:\n\nredEdges[i] = [ai, bi] indicates that there is a directed red edge from node ai to node bi in the graph, and\nblueEdges[j] = [uj, vj] indicates that there is a directed blue edge from node uj to node vj in the graph.\n\nReturn an array answer of length n, where each answer[x] is the length of the shortest path from node 0 to node x such that the edge colors alternate along the path, or -1 if such a path does not exist.",
        "examples": [
            "Input: n = 3, redEdges = [[0,1],[1,2]], blueEdges = []\nOutput: [0,1,-1]",
            "Input: n = 3, redEdges = [[0,1]], blueEdges = [[2,1]]\nOutput: [0,1,-1]"
        ],
        "constraints": "1 <= n <= 100\n0 <= redEdges.length,\u00a0blueEdges.length <= 400\nredEdges[i].length == blueEdges[j].length == 2\n0 <= ai, bi, uj, vj < n",
        "oracle_code": "class Solution {\npublic:\n    vector<int> shortestAlternatingPaths(int n,vector<vector<int>>&redEdges,vector<vector<int>>& blueEdges) \n    {\n        multiset<int>temp;\n        vector<multiset<int>>redchilds(n,temp),bluechilds(n,temp);\n        for(auto j:redEdges)\n        {\n            redchilds[j[0]].insert(j[1]);\n        }\n        for(auto j:blueEdges)\n        {\n            bluechilds[j[0]].insert(j[1]);\n        }\n        vector<int>ans;\n        for(int i=0;i<n;i++)\n        {\n            //BFS for all\n            vector<multiset<int>>reds=redchilds,blues=bluechilds;\n            queue<pair<char,int>>visit;\n            visit.push({'n',0});//neutral='n'\n            int steps=0;\n            while(!visit.empty())\n            {\n                bool justbreak=false;\n                int n=visit.size();\n                for(int j=0;j<n;j++)\n                {\n                    pair<char,int>x=visit.front();\n                    visit.pop();\n                    if(x.second==i)\n                    {\n                        ans.push_back(steps);\n                        justbreak=true;\n                        break;\n                    }\n                    if(x.first=='n')\n                    {\n                        for(auto j:reds[x.second])\n                        {\n                            visit.push({'r',j});\n                            auto itr1=reds[x.second].find(j);\n                            reds[x.second].erase(itr1);\n                        }\n                        for(auto j:blues[x.second])\n                        {\n                            visit.push({'b',j});//blue='b'\n                            auto itr1=blues[x.second].find(j);\n                            blues[x.second].erase(itr1);\n                        }\n                    }\n                    else if(x.first=='b')\n                    {\n                        for(auto j:reds[x.second])\n                        {\n                            visit.push({'r',j});//red='r'\n                            auto itr1=reds[x.second].find(j);\n                            reds[x.second].erase(itr1);\n                        }\n                    }\n                    else if(x.first=='r')\n                    {\n                        for(auto j:blues[x.second])\n                        {\n                            visit.push({'b',j});\n                            auto itr1=blues[x.second].find(j);\n                            blues[x.second].erase(itr1);\n                        }\n                    }\n                }\n                if(justbreak)\n                {\n                    break;\n                }\n                steps++;\n            }\n            if(i==ans.size())\n            {\n                ans.push_back(-1);\n            }\n        }\n        return ans;\n    }\n};",
        "content": "*E denotes number of Edges*\\n\\n# Complexity\\n- Time complexity:\\nO((N^2)+(N)*(E)*LOG(E))\\n\\n- Space complexity:\\nO(E)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> shortestAlternatingPaths(int n,vector<vector<int>>&redEdges,vector<vector<int>>& blueEdges) \\n    {\\n        multiset<int>temp;\\n        vector<multiset<int>>redchilds(n,temp),bluechilds(n,temp);\\n        for(auto j:redEdges)\\n        {\\n            redchilds[j[0]].insert(j[1]);\\n        }\\n        for(auto j:blueEdges)\\n        {\\n            bluechilds[j[0]].insert(j[1]);\\n        }\\n        vector<int>ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            //BFS for all\\n            vector<multiset<int>>reds=redchilds,blues=bluechilds;\\n            queue<pair<char,int>>visit;\\n            visit.push({\\'n\\',0});//neutral=\\'n\\'\\n            int steps=0;\\n            while(!visit.empty())\\n            {\\n                bool justbreak=false;\\n                int n=visit.size();\\n                for(int j=0;j<n;j++)\\n                {\\n                    pair<char,int>x=visit.front();\\n                    visit.pop();\\n                    if(x.second==i)\\n                    {\\n                        ans.push_back(steps);\\n                        justbreak=true;\\n                        break;\\n                    }\\n                    if(x.first==\\'n\\')\\n                    {\\n                        for(auto j:reds[x.second])\\n                        {\\n                            visit.push({\\'r\\',j});\\n                            auto itr1=reds[x.second].find(j);\\n                            reds[x.second].erase(itr1);\\n                        }\\n                        for(auto j:blues[x.second])\\n                        {\\n                            visit.push({\\'b\\',j});//blue=\\'b\\'\\n                            auto itr1=blues[x.second].find(j);\\n                            blues[x.second].erase(itr1);\\n                        }\\n                    }\\n                    else if(x.first==\\'b\\')\\n                    {\\n                        for(auto j:reds[x.second])\\n                        {\\n                            visit.push({\\'r\\',j});//red=\\'r\\'\\n                            auto itr1=reds[x.second].find(j);\\n                            reds[x.second].erase(itr1);\\n                        }\\n                    }\\n                    else if(x.first==\\'r\\')\\n                    {\\n                        for(auto j:blues[x.second])\\n                        {\\n                            visit.push({\\'b\\',j});\\n                            auto itr1=blues[x.second].find(j);\\n                            blues[x.second].erase(itr1);\\n                        }\\n                    }\\n                }\\n                if(justbreak)\\n                {\\n                    break;\\n                }\\n                steps++;\\n            }\\n            if(i==ans.size())\\n            {\\n                ans.push_back(-1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "wrong comment mark",
            "unclosed string",
            "conditional statement error",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    vector<int> shortestAlternatingPaths(int n,vector<vector<int>>&redEdges,vector<vector<int>>& blueEdges) \n    {\n        multiset<int>temp;\n        vector<multiset<int>>redchilds(n,temp),bluechilds(n,temp);\n        for(auto j:redEdges)\n        {\n            redchilds[j[0]].insert(j[1]);\n        }\n        for(auto j:blueEdges)\n        {\n            bluechilds[j[0]].insert(j[1]);\n        }\n        vector<int>ans(n, -1);\n        for(int i=0;i<n;) \n        {\n            //BFS for all\n            vector<multiset<int>>reds=redchilds,blues=bluechilds;\n            queue<pair<char,int>>visit;\n            visit.push({'n',0});//neutral='n'\n            int steps=0;\n            while(!visit.empty()\n            {\n                bool justbreak=false;\n                int n=visit.size();\n                for(int j=0;j<n;j++)\n                {\n                    pair<char,int>x=visit.front();\n                    \n                    if(x.second==i)\n                    {\n                        ans[i]=steps;\n                        justbreak=true;\n                        break;\n                    }\n                    if(x.first=='n' || x.first == ans[i] % 2 + '0') \n                    {\n                        for(auto j:reds[x.second])\n                        {\n                            visit.push({'r\",j});\n                            auto itr1=reds[x.second].find(j);\n                            reds[x.second].erase(itr1);\n                        }\n                        for(auto j:blues[x.second])\n                        {\n                            visit.push({'b',j});//blue='b'\n                            auto itr1=blues[x.second].find(j);\n                            blues[x.second].erase(itr1);\n                        }\n                    }\n                    else if(x.first=='b')\n                    {\n                        for(auto j:reds[x.second])\n                        {\n                            visit.push({'r',j});//red='r'\n                            auto itr1=reds[x.second].find(j);\n                            reds[x.second].erase(itr1);\n                        }\n                    }\n                    else if(x.first=='r')\n                    {\n                        for(auto j:blues[x.second])\n                        {\n                            visit.push({'b',j});\n                            auto itr1=blues[x.second].find(j);\n                            blues[x.second].erase(itr1);\n                        }\n                    }\n                }\n                if(justbreak)\n                {\n                    break;\n                }\n                steps++;\n            }\n        }\n        return ans;\n    }\n};\n"
    },
    {
        "slug": "shortest-path-to-get-all-keys",
        "description": "You are given an m x n grid grid where:\n\n'.' is an empty cell.\n'#' is a wall.\n'@' is the starting point.\nLowercase letters represent keys.\nUppercase letters represent locks.\n\nYou start at the starting point and one move consists of walking one space in one of the four cardinal directions. You cannot walk outside the grid, or walk into a wall.\nIf you walk over a key, you can pick it up and you cannot walk over a lock unless you have its corresponding key.\nFor some 1 <= k <= 6, there is exactly one lowercase and one uppercase letter of the first k letters of the English alphabet in the grid. This means that there is exactly one key for each lock, and one lock for each key; and also that the letters used to represent the keys and locks were chosen in the same order as the English alphabet.\nReturn the lowest number of moves to acquire all keys. If it is impossible, return -1.",
        "examples": [
            "Input: grid = [\"@.a..\",\"###.#\",\"b.A.B\"]\nOutput: 8\nExplanation: Note that the goal is to obtain all the keys not to open all the locks.",
            "Input: grid = [\"@..aA\",\"..B#.\",\"....b\"]\nOutput: 6",
            "Input: grid = [\"@Aa\"]\nOutput: -1"
        ],
        "constraints": "m == grid.length\nn == grid[i].length\n1 <= m, n <= 30\ngrid[i][j] is either an English letter, '.', '#', or '@'.\u00a0\nThere is exactly one\u00a0'@'\u00a0in the grid.\nThe number of keys in the grid is in the range [1, 6].\nEach key in the grid is unique.\nEach key in the grid has a matching lock.",
        "oracle_code": "class Solution {\npublic:\n\n    int dir[4][2] = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};\n\n    int shortestPathAllKeys(vector<string>& grid) {\n        \n        int m = grid.size();\n        int n = grid[0].size();\n        queue<pair<pair<int, int>, int>> que;\n        vector<vector<unsigned long>> mapKey(m, vector<unsigned long>(n, 0));\n        int target = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if ('a' <= grid[i][j] && grid[i][j] <= 'f') {\n                    target |= 1 << (grid[i][j] - 'a');\n                    continue;\n                }\n\n                if (grid[i][j] == '@') {\n                    que.emplace(pair<int, int>(i, j), 0);\n                    mapKey[i][j] = 1;\n                }\n            }\n        }\n\n\n        int step = 0;\n        while (!que.empty()) {\n            int size = que.size();\n            for (int s = 0; s < size; s++) {\n                int i = que.front().first.first;\n                int j = que.front().first.second;\n                int key = que.front().second;\n                que.pop();\n                \n                if ('a' <= grid[i][j] && grid[i][j] <= 'f') {\n                    key |= 1 << (grid[i][j] - 'a');\n                    if (key == target)\n                        return step;\n\n                    mapKey[i][j] |= 1l << key;\n                }\n\n                for (int d = 0; d < 4; d++) {\n                    int newi = i + dir[d][0];\n                    int newj = j + dir[d][1];\n                    \n                    if (!(0 <= newi && newi < m && 0 <= newj && newj < n))\n                        continue;\n                        \n                    int val = grid[newi][newj];\n                    if (val == '#')\n                        continue;\n                        \n                    if ('A' <= val && val <= 'F' && (key & (1 << (val - 'A'))) == 0)\n                        continue;\n                        \n                    if (mapKey[newi][newj] & (1l << key))\n                        continue;\n                        \n                     mapKey[newi][newj] |= 1l << key;\n                     que.emplace(pair<int, int>(newi, newj), key);\n                }\n            }\n            step++;\n        }\n        return -1;\n    }\n};",
        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int dir[4][2] = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};\\n\\n    int shortestPathAllKeys(vector<string>& grid) {\\n        \\n        int m = grid.size();\\n        int n = grid[0].size();\\n        queue<pair<pair<int, int>, int>> que;\\n        vector<vector<unsigned long>> mapKey(m, vector<unsigned long>(n, 0));\\n        int target = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (\\'a\\' <= grid[i][j] && grid[i][j] <= \\'f\\') {\\n                    target |= 1 << (grid[i][j] - \\'a\\');\\n                    continue;\\n                }\\n\\n                if (grid[i][j] == \\'@\\') {\\n                    que.emplace(pair<int, int>(i, j), 0);\\n                    mapKey[i][j] = 1;\\n                }\\n            }\\n        }\\n\\n\\n        int step = 0;\\n        while (!que.empty()) {\\n            int size = que.size();\\n            for (int s = 0; s < size; s++) {\\n                int i = que.front().first.first;\\n                int j = que.front().first.second;\\n                int key = que.front().second;\\n                que.pop();\\n                \\n                if (\\'a\\' <= grid[i][j] && grid[i][j] <= \\'f\\') {\\n                    key |= 1 << (grid[i][j] - \\'a\\');\\n                    if (key == target)\\n                        return step;\\n\\n                    mapKey[i][j] |= 1l << key;\\n                }\\n\\n                for (int d = 0; d < 4; d++) {\\n                    int newi = i + dir[d][0];\\n                    int newj = j + dir[d][1];\\n                    \\n                    if (!(0 <= newi && newi < m && 0 <= newj && newj < n))\\n                        continue;\\n                        \\n                    int val = grid[newi][newj];\\n                    if (val == \\'#\\')\\n                        continue;\\n                        \\n                    if (\\'A\\' <= val && val <= \\'F\\' && (key & (1 << (val - \\'A\\'))) == 0)\\n                        continue;\\n                        \\n                    if (mapKey[newi][newj] & (1l << key))\\n                        continue;\\n                        \\n                     mapKey[newi][newj] |= 1l << key;\\n                     que.emplace(pair<int, int>(newi, newj), key);\\n                }\\n            }\\n            step++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
        "level": "hard",
        "type": [
            "== and = confusion",
            "statement separation",
            "unclosed string",
            "colon missing"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n\n    int dir[4][2] = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};\n\n    int shortestPathAllKeys(vector<string>& grid) {\n        \n        int m = grid.size();\n        int n = grid[0].size();\n        queue<pair<pair<int, int>, int>> que;\n        vector<vector<unsigned long>> mapKey(m, vector<unsigned long>(n, 0));\n        int target = 0;\n        for (int i = 0; i < m; i++) \n            for (int j = 0; j < n; j++) \n                if ('a' <= grid[i][j] && grid[i][j] <= 'f') {\n                    target |= 1  (grid[i][j] - 'a\");\n                    continue;\n\n                if (grid[i][j] = '@') {\n                    que.emplace(pair<int, int>(i, j), 0);\n                    mapKey[i][j] = 1;\n                }\n            \n\n\n        int step = 0;\n        while (!que.empty()) {\n            int size = que.size();\n            for (int s = 0; s < size; s++) {\n                int i = que.front().first.first;\n                int j = que.front().first.second;\n                int key = que.front().second;\n                que.pop();\n                \n                if ('a' <= grid[i][j] && grid[i][j] <= 'f\") {\n                    key |= 1 << (grid[i][j] - 'a\");\n                    if (key == target)\n                        return step;\n\n                    mapKey[i][j] |= 1l << key;\n                }\n\n                for (int d = 0; d < 4; d++) {\n                    int newi = i + dir[d][0];\n                    int newj = j + dir[d][1];\n                    \n                    if (!(0 <= newi && newi < m && 0 <= newj && newj < n))\n                        continue;\n                        \n                    int val = grid[newi][newj];\n                    if (val == '#')\n                        continue;\n                        \n                    if ('A' <= val && val <= 'F' && (key & (1  (val - 'A\"))) == 0)\n                        continue;\n                        \n                    if (mapKey[newi][newj] & (1l << key))\n                        continue;\n                        \n                     mapKey[newi][newj] |= 1l << key;\n                     que.emplace(pair<int, int>(newi, newj), key);\n                }\n            }\n            step++;\n        }\n        return -1;\n    }\n};\n"
    },
    {
        "slug": "lru-cache",
        "description": "Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.\nImplement the LRUCache class:\n\nLRUCache(int capacity) Initialize the LRU cache with positive size capacity.\nint get(int key) Return the value of the key if the key exists, otherwise return -1.\nvoid put(int key, int value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key.\n\nThe functions get and put must each run in O(1) average time complexity.",
        "examples": [
            "Input\n[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"]\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\nOutput\n[null, null, null, 1, null, -1, null, -1, 3, 4]\n\nExplanation\nLRUCache lRUCache = new LRUCache(2);\nlRUCache.put(1, 1); // cache is {1=1}\nlRUCache.put(2, 2); // cache is {1=1, 2=2}\nlRUCache.get(1);    // return 1\nlRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}\nlRUCache.get(2);    // returns -1 (not found)\nlRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}\nlRUCache.get(1);    // return -1 (not found)\nlRUCache.get(3);    // return 3\nlRUCache.get(4);    // return 4"
        ],
        "constraints": "1 <= capacity <= 3000\n0 <= key <= 104\n0 <= value <= 105\nAt most 2 * 105 calls will be made to get and put.",
        "oracle_code": "class LRUCache {\npublic:\nclass node\n{\n  public:\n  int key;\n  int val;\n  node* next;\n  node* prev;\n  node(int _key,int _val)\n  {\n    key = _key;\n    val = _val;\n  }\n};\nnode* head = new node(-1,-1);\nnode* tail = new node(-1,-1);\n\nint size;\nunordered_map<int,node*>mpp;\n    LRUCache(int capacity) {\n       size = capacity; \n       head->next = tail;\n       tail->prev = head;  \n    }\n\n    void addNode(node* newNode){\n       \n       node* temp = head->next;\n       newNode->next = temp;\n       newNode->prev = head;\n       head->next = newNode;\n       temp->prev = newNode;\n    }\n\n    void deleteNode(node* delNode){\n         \n       node* delprev = delNode->prev;\n       node* delnext = delNode->next;\n       delprev->next = delnext;\n       delnext->prev = delprev;\n    }\n    \n    int get(int _key) {\n        \n        if(mpp.count(_key))\n        {\n          node* nde = mpp[_key];\n          int curr = nde->val;\n          mpp.erase(_key);\n          deleteNode(nde);\n          addNode(nde);\n          mpp[_key] = head->next;\n          return curr;\n        }\n        return -1;\n    }\n    \n    void put(int _key, int value) {\n        \n        if(mpp.count(_key))\n        {\n           node* nde = mpp[_key];\n           mpp.erase(_key);\n           deleteNode(nde);\n        }\n        if(mpp.size()==size)\n        {\n           mpp.erase(tail->prev->key);\n           deleteNode(tail->prev);\n        }\n        addNode(new node(_key,value));\n        mpp[_key] = head->next;\n    }\n};",
        "content": "# PLEASE DO UPVOTE!!!!!\\n\\n**CONNECT WITH ME ON LINKEDIN :  https://www.linkedin.com/in/md-kamran-55b98521a/**\\n\\n## INTUITION\\nTo Implement LRU(Least recently used), we need to have a track of the usage of the keys, in the order of there usage, as we have a limited capacity we cant extend our capacity beyond \"capacity\", so we always we will take out those values which has\\'nt been acccess in the recent time.So, we have to think of something that can kind of sort our keys according to usage on the go, the best Data Structure for this purpose is Doubly linked List.\\n                             A Doubly linked list will have a Head node as well as a tail node, and whenever a key is used we will place it just next to the head node,in this fashions, the one\\'s which are closer to head are the most recently used ones, and as we go closer to the tail node, those are the less recently used ones while the node just previous to tail is the \"LEAST RECENTLY USED\". \\nSo whenever we add a key or use a key(get()), we will move it right after the head node, and whenever we call the (put() function), if size if greater we have to delete the LRU node, if key is not present, (if present then too we will delete that node so as to update the value and still move it right after head node), and place new node right after head node.                        \\n\\n\\n**Ask Furthur Doubts in the Comment Section**\\n# Code\\n```\\nclass LRUCache {\\npublic:\\nclass node\\n{\\n  public:\\n  int key;\\n  int val;\\n  node* next;\\n  node* prev;\\n  node(int _key,int _val)\\n  {\\n    key = _key;\\n    val = _val;\\n  }\\n};\\nnode* head = new node(-1,-1);\\nnode* tail = new node(-1,-1);\\n\\nint size;\\nunordered_map<int,node*>mpp;\\n    LRUCache(int capacity) {\\n       size = capacity; \\n       head->next = tail;\\n       tail->prev = head;  \\n    }\\n\\n    void addNode(node* newNode){\\n       \\n       node* temp = head->next;\\n       newNode->next = temp;\\n       newNode->prev = head;\\n       head->next = newNode;\\n       temp->prev = newNode;\\n    }\\n\\n    void deleteNode(node* delNode){\\n         \\n       node* delprev = delNode->prev;\\n       node* delnext = delNode->next;\\n       delprev->next = delnext;\\n       delnext->prev = delprev;\\n    }\\n    \\n    int get(int _key) {\\n        \\n        if(mpp.count(_key))\\n        {\\n          node* nde = mpp[_key];\\n          int curr = nde->val;\\n          mpp.erase(_key);\\n          deleteNode(nde);\\n          addNode(nde);\\n          mpp[_key] = head->next;\\n          return curr;\\n        }\\n        return -1;\\n    }\\n    \\n    void put(int _key, int value) {\\n        \\n        if(mpp.count(_key))\\n        {\\n           node* nde = mpp[_key];\\n           mpp.erase(_key);\\n           deleteNode(nde);\\n        }\\n        if(mpp.size()==size)\\n        {\\n           mpp.erase(tail->prev->key);\\n           deleteNode(tail->prev);\\n        }\\n        addNode(new node(_key,value));\\n        mpp[_key] = head->next;\\n    }\\n};\\n\\n```\\n![b62ab1be-232a-438f-9524-7d8ca4dbd5fe_1675328166.1161866.png](https://assets.leetcode.com/users/images/8d5343b1-0eb4-4111-a914-40ce968fd034_1675389764.2273676.png)",
        "level": "medium",
        "type": [
            "undefined methods",
            "undefined keywords from other languages",
            "colon missing",
            "undefined objects"
        ],
        "buggy_code": "\nclass LRUCache {\npublic:\nclass node\n{\n  public:\n  int key;\n  int val;\n  node* next;\n  node* prev;\n  node(int _key,int _val)\n  {\n    key = _key;\n    val = _val;\n  }\n};\nnode* head = nullptr;\nnode* tail = nullptr;\n\nint size;\nunordered_map<int,node*>mpp;\n    LRUCache(int capacity) {\n       size = capacity; \n       head->next = tail;\n       tail->prev = head;  \n    }\n\n    void addNode(node* newNode){\n       \n       node* temp = head->next;\n       newNode->next = temp;\n       newNode->prev = head;\n       head->next = newNode;\n    }\n\n    void deleteNode(node* delNode){\n         \n       node* delprev = delNode->prev;\n       node* delnext = delNode->next;\n       delprev->next = delnext;\n       delnext->prev = delprev;\n    }\n    \n    int get(int _key) {\n        \n        if(mpp.count(_key))\n        {\n          node* nde = mpp[_key];\n          int curr = nde->val;\n          mpp.erase(_key);\n          deleteNode(nde);\n          addNode(nde)\n          mpp[_key] = head->next;\n          return curr;\n        }\n        return -1;\n    }\n\n}; \nr\n\n\n"
    },
    {
        "slug": "lru-cache",
        "description": "Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.\nImplement the LRUCache class:\n\nLRUCache(int capacity) Initialize the LRU cache with positive size capacity.\nint get(int key) Return the value of the key if the key exists, otherwise return -1.\nvoid put(int key, int value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key.\n\nThe functions get and put must each run in O(1) average time complexity.",
        "examples": [
            "Input\n[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"]\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\nOutput\n[null, null, null, 1, null, -1, null, -1, 3, 4]\n\nExplanation\nLRUCache lRUCache = new LRUCache(2);\nlRUCache.put(1, 1); // cache is {1=1}\nlRUCache.put(2, 2); // cache is {1=1, 2=2}\nlRUCache.get(1);    // return 1\nlRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}\nlRUCache.get(2);    // returns -1 (not found)\nlRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}\nlRUCache.get(1);    // return -1 (not found)\nlRUCache.get(3);    // return 3\nlRUCache.get(4);    // return 4"
        ],
        "constraints": "1 <= capacity <= 3000\n0 <= key <= 104\n0 <= value <= 105\nAt most 2 * 105 calls will be made to get and put.",
        "oracle_code": "class LRUCache {\npublic:\nclass node\n{\n  public:\n  int key;\n  int val;\n  node* next;\n  node* prev;\n  node(int _key,int _val)\n  {\n    key = _key;\n    val = _val;\n  }\n};\nnode* head = new node(-1,-1);\nnode* tail = new node(-1,-1);\n\nint size;\nunordered_map<int,node*>mpp;\n    LRUCache(int capacity) {\n       size = capacity; \n       head->next = tail;\n       tail->prev = head;  \n    }\n\n    void addNode(node* newNode){\n       \n       node* temp = head->next;\n       newNode->next = temp;\n       newNode->prev = head;\n       head->next = newNode;\n       temp->prev = newNode;\n    }\n\n    void deleteNode(node* delNode){\n         \n       node* delprev = delNode->prev;\n       node* delnext = delNode->next;\n       delprev->next = delnext;\n       delnext->prev = delprev;\n    }\n    \n    int get(int _key) {\n        \n        if(mpp.count(_key))\n        {\n          node* nde = mpp[_key];\n          int curr = nde->val;\n          mpp.erase(_key);\n          deleteNode(nde);\n          addNode(nde);\n          mpp[_key] = head->next;\n          return curr;\n        }\n        return -1;\n    }\n    \n    void put(int _key, int value) {\n        \n        if(mpp.count(_key))\n        {\n           node* nde = mpp[_key];\n           mpp.erase(_key);\n           deleteNode(nde);\n        }\n        if(mpp.size()==size)\n        {\n           mpp.erase(tail->prev->key);\n           deleteNode(tail->prev);\n        }\n        addNode(new node(_key,value));\n        mpp[_key] = head->next;\n    }\n};",
        "content": "# PLEASE DO UPVOTE!!!!!\\n\\n**CONNECT WITH ME ON LINKEDIN :  https://www.linkedin.com/in/md-kamran-55b98521a/**\\n\\n## INTUITION\\nTo Implement LRU(Least recently used), we need to have a track of the usage of the keys, in the order of there usage, as we have a limited capacity we cant extend our capacity beyond \"capacity\", so we always we will take out those values which has\\'nt been acccess in the recent time.So, we have to think of something that can kind of sort our keys according to usage on the go, the best Data Structure for this purpose is Doubly linked List.\\n                             A Doubly linked list will have a Head node as well as a tail node, and whenever a key is used we will place it just next to the head node,in this fashions, the one\\'s which are closer to head are the most recently used ones, and as we go closer to the tail node, those are the less recently used ones while the node just previous to tail is the \"LEAST RECENTLY USED\". \\nSo whenever we add a key or use a key(get()), we will move it right after the head node, and whenever we call the (put() function), if size if greater we have to delete the LRU node, if key is not present, (if present then too we will delete that node so as to update the value and still move it right after head node), and place new node right after head node.                        \\n\\n\\n**Ask Furthur Doubts in the Comment Section**\\n# Code\\n```\\nclass LRUCache {\\npublic:\\nclass node\\n{\\n  public:\\n  int key;\\n  int val;\\n  node* next;\\n  node* prev;\\n  node(int _key,int _val)\\n  {\\n    key = _key;\\n    val = _val;\\n  }\\n};\\nnode* head = new node(-1,-1);\\nnode* tail = new node(-1,-1);\\n\\nint size;\\nunordered_map<int,node*>mpp;\\n    LRUCache(int capacity) {\\n       size = capacity; \\n       head->next = tail;\\n       tail->prev = head;  \\n    }\\n\\n    void addNode(node* newNode){\\n       \\n       node* temp = head->next;\\n       newNode->next = temp;\\n       newNode->prev = head;\\n       head->next = newNode;\\n       temp->prev = newNode;\\n    }\\n\\n    void deleteNode(node* delNode){\\n         \\n       node* delprev = delNode->prev;\\n       node* delnext = delNode->next;\\n       delprev->next = delnext;\\n       delnext->prev = delprev;\\n    }\\n    \\n    int get(int _key) {\\n        \\n        if(mpp.count(_key))\\n        {\\n          node* nde = mpp[_key];\\n          int curr = nde->val;\\n          mpp.erase(_key);\\n          deleteNode(nde);\\n          addNode(nde);\\n          mpp[_key] = head->next;\\n          return curr;\\n        }\\n        return -1;\\n    }\\n    \\n    void put(int _key, int value) {\\n        \\n        if(mpp.count(_key))\\n        {\\n           node* nde = mpp[_key];\\n           mpp.erase(_key);\\n           deleteNode(nde);\\n        }\\n        if(mpp.size()==size)\\n        {\\n           mpp.erase(tail->prev->key);\\n           deleteNode(tail->prev);\\n        }\\n        addNode(new node(_key,value));\\n        mpp[_key] = head->next;\\n    }\\n};\\n\\n```\\n![b62ab1be-232a-438f-9524-7d8ca4dbd5fe_1675328166.1161866.png](https://assets.leetcode.com/users/images/8d5343b1-0eb4-4111-a914-40ce968fd034_1675389764.2273676.png)",
        "level": "medium",
        "type": [
            "wrong comment mark",
            "undefined methods",
            "variable value error",
            "colon missing"
        ],
        "buggy_code": "\nclass LRUCache {\npublic:\nclass node\n{\n  public:\n  int key;\n  int val;\n  node* next;\n  node* prev;\n  node(int _key,int _val)\n  {\n    key = _key;\n    val = _val;\n  }\n};\nnode* head = new node(-1,-1);\nnode* tail = new node(-1,-1);\n\nint size;\nunordered_map<int,node*>mpp;\n    LRUCache(int capacity) {\n       size = capacity; \n       head->next = tail;\n       tail->prev = head;  \n    }\n\n    void addNode(node* newNode){\n       \n       node* temp = head->next;\n       newNode->next = temp;\n       newNode->prev = head;\n       head->next = newNode;\n    }\n\n    /*void deleteNode(node* delNode){\n         \n       node* delprev = delNode->prev;\n       node* delnext = delNode->next;\n       delprev->next = delnext;\n       delnext->prev = delprev;\n    }*/\n    \n    int get(int _key) {\n        \n        if(mpp.count(_key))\n        {\n          node* nde = mpp[_key];\n          int curr = nde->val;\n          mpp.erase(_key);\n          deleteNode(nde);\n          addNode(nde)\n          mpp[_key] = head->next;\n          return curr;\n        }\n        return -1;\n    }\n\n}; \n\ntil\n\n"
    },
    {
        "slug": "most-beautiful-item-for-each-query",
        "description": "You are given a 2D integer array items where items[i] = [pricei, beautyi] denotes the price and beauty of an item respectively.\nYou are also given a 0-indexed integer array queries. For each queries[j], you want to determine the maximum beauty of an item whose price is less than or equal to queries[j]. If no such item exists, then the answer to this query is 0.\nReturn an array answer of the same length as queries where answer[j] is the answer to the jth query.",
        "examples": [
            "Input: items = [[1,2],[3,2],[2,4],[5,6],[3,5]], queries = [1,2,3,4,5,6]\nOutput: [2,4,5,5,6,6]\nExplanation:\n- For queries[0]=1, [1,2] is the only item which has price <= 1. Hence, the answer for this query is 2.\n- For queries[1]=2, the items which can be considered are [1,2] and [2,4]. \n  The maximum beauty among them is 4.\n- For queries[2]=3 and queries[3]=4, the items which can be considered are [1,2], [3,2], [2,4], and [3,5].\n  The maximum beauty among them is 5.\n- For queries[4]=5 and queries[5]=6, all items can be considered.\n  Hence, the answer for them is the maximum beauty of all items, i.e., 6.",
            "Input: items = [[1,2],[1,2],[1,3],[1,4]], queries = [1]\nOutput: [4]\nExplanation: \nThe price of every item is equal to 1, so we choose the item with the maximum beauty 4. \nNote that multiple items can have the same price and/or beauty.",
            "Input: items = [[10,1000]], queries = [5]\nOutput: [0]\nExplanation:\nNo item has a price less than or equal to 5, so no item can be chosen.\nHence, the answer to the query is 0."
        ],
        "constraints": "1 <= items.length, queries.length <= 105\nitems[i].length == 2\n1 <= pricei, beautyi, queries[j] <= 109",
        "oracle_code": "class Solution {\n    int bs(vector<vector<int>>& items, int t, vector<int> &beauty) {\n        int ans = 0, s = 0, e = items.size() - 1;\n        while(s <= e) {\n            int m = (s + e) / 2;\n            if(items[m][0] <= t) ans = beauty[m], s = m + 1;\n            else e = m - 1;\n        }\n        return ans;\n    }\n\npublic:\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\n        sort(items.begin(), items.end());\n        vector<int> ans, beauty(items.size(), items[0][1]);\n\n        for(int i=1; i<items.size(); i++) beauty[i] = max(beauty[i - 1], items[i][1]);\n\n        for(int i : queries) ans.push_back(bs(items, i, beauty));\n        return ans;\n    }\n};",
        "content": "\\n# C++\\n```\\nclass Solution {\\n    int bs(vector<vector<int>>& items, int t, vector<int> &beauty) {\\n        int ans = 0, s = 0, e = items.size() - 1;\\n        while(s <= e) {\\n            int m = (s + e) / 2;\\n            if(items[m][0] <= t) ans = beauty[m], s = m + 1;\\n            else e = m - 1;\\n        }\\n        return ans;\\n    }\\n\\npublic:\\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\\n        sort(items.begin(), items.end());\\n        vector<int> ans, beauty(items.size(), items[0][1]);\\n\\n        for(int i=1; i<items.size(); i++) beauty[i] = max(beauty[i - 1], items[i][1]);\\n\\n        for(int i : queries) ans.push_back(bs(items, i, beauty));\\n        return ans;\\n    }\\n};\\n```\\n\\n# Python\\n```\\nclass Solution(object):\\n    def maximumBeauty(self, items, queries):\\n        items.sort()\\n        ans, beauty = [], [items[0][1]] * len(items)\\n        for i in range(1, len(items)): beauty[i] = max(beauty[i - 1], items[i][1])\\n\\n        def bs(t):\\n            ans, s, e = 0, 0, len(items) - 1\\n            while s <= e:\\n                m = (s + e) // 2\\n                if items[m][0] <= t:\\n                    ans = beauty[m]\\n                    s = m + 1\\n                else: e = m - 1\\n            return ans\\n\\n        for i in queries: ans.append(bs(i))\\n        return ans\\n```\\n",
        "level": "medium",
        "type": [
            "indexing error",
            "wrong comment mark",
            "conditional statement error",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\n    int bs(vector<vector<int>>& items, int t, vector<int> &beauty) {\n        int ans = 0, s = 0, e = items.size();\n        while(s <= e) {\n\n            if(items[m][0] <= t) ans = beauty[m], s = m + 1;\n            else s = m + 1; \n        }\n        return ans;\n    }\n\npublic:\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\n        sort(items.begin(), items.end());\n        vector<int> ans, beauty(items.size(), items[0][1]);\n\n        for(int i=1; i<items.size(); i++) beauty[i] = max(beauty[i - 1], items[i][1]);\n\n        for(int i : queries) ans.push_back(bs(items, i, beauty));\n        return ans;\n    }\n    \n    void foo(){\n        bar();\n    }\n};\n"
    },
    {
        "slug": "find-the-punishment-number-of-an-integer",
        "description": "Given a positive integer n, return the punishment number of n.\nThe punishment number of n is defined as the sum of the squares of all integers i such that:\n\n1 <= i <= n\nThe decimal representation of i * i can be partitioned into contiguous substrings such that the sum of the integer values of these substrings equals i.",
        "examples": [
            "Input: n = 10\nOutput: 182\nExplanation: There are exactly 3 integers i that satisfy the conditions in the statement:\n- 1 since 1 * 1 = 1\n- 9 since 9 * 9 = 81 and 81 can be partitioned into 8 + 1.\n- 10 since 10 * 10 = 100 and 100 can be partitioned into 10 + 0.\nHence, the punishment number of 10 is 1 + 81 + 100 = 182",
            "Input: n = 37\nOutput: 1478\nExplanation: There are exactly 4 integers i that satisfy the conditions in the statement:\n- 1 since 1 * 1 = 1. \n- 9 since 9 * 9 = 81 and 81 can be partitioned into 8 + 1. \n- 10 since 10 * 10 = 100 and 100 can be partitioned into 10 + 0. \n- 36 since 36 * 36 = 1296 and 1296 can be partitioned into 1 + 29 + 6.\nHence, the punishment number of 37 is 1 + 81 + 100 + 1296 = 1478"
        ],
        "constraints": "1 <= n <= 1000",
        "oracle_code": "class Solution {\npublic:\n    \n    bool valid(int n, string s,int sum){\n        // empty string indicates we have completed one partition\n        if(s==\"\") if(sum==n) return true;\n\n        // We use backtracking to check for all partitions if it is possible to generate required sum \n        // and if we find sum we immediately return true immediately\n        for(int i=1;i<=s.size();i++){\n            int x  = stoi(s.substr(0,i));\n            if(valid(n, s.substr(i), sum+x)) return true;\n        }\n        \n        //If no partition could add up to required sum n\n        return false;\n    }\n    int punishmentNumber(int n) {\n        int ans = 0;\n\n        //generate all possible squares and check them if they satisfy the given statement\n        for(int i=1;i<=n;i++){\n            int sq = i*i;\n            string x = to_string(sq);\n            if(valid(i,x,0)) ans += i*i;\n        }\n        \n        return ans;\n        \n    }\n};",
        "content": "# Intuition\\nThe main idea of this problem is to generate all non empty partitions of a string using Backtracking.\\n\\nFor example let\\'s  say i = 36, it\\'s square = 36*36 = 1296\\nTo check if some partition of 1296 satisfy given statement, we make all partitions e.g\\n[1,2,9,6], [1,29,6], [1,296], [12,9,6] , [12,96], [129,6]\\n\\nAmong these only [1,29,6] satisfies the constraint.\\n\\nWe only need one of these set to satisfy the statement, hence we break immediately if we find any valid set.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n* Generate all possible squares and check if they satisfy the given statement\\n* To check if a square satisfies the given constraint or not generate all possible partitions using backtracking.\\n* If any single partition satisfy the statement then this square will be added to solution\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity :  O(n*(2^6)), here 6 is the maxm square length that is len(1000*1000) = 6\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    bool valid(int n, string s,int sum){\\n        // empty string indicates we have completed one partition\\n        if(s==\"\") if(sum==n) return true;\\n\\n        // We use backtracking to check for all partitions if it is possible to generate required sum \\n        // and if we find sum we immediately return true immediately\\n        for(int i=1;i<=s.size();i++){\\n            int x  = stoi(s.substr(0,i));\\n            if(valid(n, s.substr(i), sum+x)) return true;\\n        }\\n        \\n        //If no partition could add up to required sum n\\n        return false;\\n    }\\n    int punishmentNumber(int n) {\\n        int ans = 0;\\n\\n        //generate all possible squares and check them if they satisfy the given statement\\n        for(int i=1;i<=n;i++){\\n            int sq = i*i;\\n            string x = to_string(sq);\\n            if(valid(i,x,0)) ans += i*i;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "== and = confusion",
            "unclosed string",
            "undefined methods",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    \n    bool valid(int n, string s,int sum){\n        // empty string indicates we have completed one partition\n        if(s==\"\") if(sum=n) return true; \n\n        // We use backtracking to check for all partitions if it is possible to generate required sum \n        // and if we find sum we immediately return true immediately\n        string unclosedString = \"This is an unclosed string;\n        for(int i=1;i<=s.size();i++){\n            int x  = parseInt(s.substr(0,i));\n            if(valid(n, s.substr(i), sum+x)) return true;\n        }\n        \n        //If no partition could add up to required sum n\n        return false;\n    }\n    int punishmentNumber(int n) {\n        int ans = 0;\n\n        //generate all possible squares and check them if they satisfy the given statement\n        for(int i=1;i<=n;i++){\n            int sq = i*i;\n            string x = to_string(sq);\n            if(valid(i,x,0)) ans += i*i;\n        }\n        \n        \n        return checkAdditionalCondition(ans);\n    }\n};\n"
    },
    {
        "slug": "longest-common-prefix",
        "description": "Write a function to find the longest common prefix string amongst an array of strings.\nIf there is no common prefix, return an empty string \"\".",
        "examples": [
            "Input: strs = [\"flower\",\"flow\",\"flight\"]\nOutput: \"fl\"",
            "Input: strs = [\"dog\",\"racecar\",\"car\"]\nOutput: \"\"\nExplanation: There is no common prefix among the input strings."
        ],
        "constraints": "1 <= strs.length <= 200\n0 <= strs[i].length <= 200\nstrs[i] consists of only lowercase English letters.",
        "oracle_code": "class Solution {\npublic:\n    string longestCommonPrefix(vector<string>& str) \n    {\n        sort(str.begin(), str.end()); //sorting the array\n        string ans=\"\"; //creating a new empty string to store the common prefixes\n        for(int i=0;i<str[0].length();i++) // max iterations = length of the first string\n        {\n            if(str[0][i]!=str[str.size()-1][i]) // checking the characters of the first and last string\n                break;\n            ans+=str[0][i]; // concatinate if the characters are matching\n        }\n        return ans;\n    }\n};",
        "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWhen you sort an array, it is enough to check for the common characters of the the first & last string of the sorted vector.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& str) \\n    {\\n        sort(str.begin(), str.end()); //sorting the array\\n        string ans=\"\"; //creating a new empty string to store the common prefixes\\n        for(int i=0;i<str[0].length();i++) // max iterations = length of the first string\\n        {\\n            if(str[0][i]!=str[str.size()-1][i]) // checking the characters of the first and last string\\n                break;\\n            ans+=str[0][i]; // concatinate if the characters are matching\\n        }\\n        return ans;\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "indexing error",
            "conditional statement error",
            "colon missing",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    string longestCommonPrefix(vector<string>& str) \n    {\n        sort(str.begin(), str.end()); //sorting the array\n        string ans=\"\"; //creating a new empty string to store the common prefixes\n        for(int i=0;i<=str[0].length();i) \n        {\n            if(str[0][i]!=str[str.size()][i]] \n                break;\n            ans+=str[0][i]; // concatinate if the characters are matching\n        }\n        return ans;\n    }\n};\n"
    },
    {
        "slug": "shortest-path-to-get-all-keys",
        "description": "You are given an m x n grid grid where:\n\n'.' is an empty cell.\n'#' is a wall.\n'@' is the starting point.\nLowercase letters represent keys.\nUppercase letters represent locks.\n\nYou start at the starting point and one move consists of walking one space in one of the four cardinal directions. You cannot walk outside the grid, or walk into a wall.\nIf you walk over a key, you can pick it up and you cannot walk over a lock unless you have its corresponding key.\nFor some 1 <= k <= 6, there is exactly one lowercase and one uppercase letter of the first k letters of the English alphabet in the grid. This means that there is exactly one key for each lock, and one lock for each key; and also that the letters used to represent the keys and locks were chosen in the same order as the English alphabet.\nReturn the lowest number of moves to acquire all keys. If it is impossible, return -1.",
        "examples": [
            "Input: grid = [\"@.a..\",\"###.#\",\"b.A.B\"]\nOutput: 8\nExplanation: Note that the goal is to obtain all the keys not to open all the locks.",
            "Input: grid = [\"@..aA\",\"..B#.\",\"....b\"]\nOutput: 6",
            "Input: grid = [\"@Aa\"]\nOutput: -1"
        ],
        "constraints": "m == grid.length\nn == grid[i].length\n1 <= m, n <= 30\ngrid[i][j] is either an English letter, '.', '#', or '@'.\u00a0\nThere is exactly one\u00a0'@'\u00a0in the grid.\nThe number of keys in the grid is in the range [1, 6].\nEach key in the grid is unique.\nEach key in the grid has a matching lock.",
        "oracle_code": "class Solution {\npublic:\n\n    int dir[4][2] = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};\n\n    int shortestPathAllKeys(vector<string>& grid) {\n        \n        int m = grid.size();\n        int n = grid[0].size();\n        queue<pair<pair<int, int>, int>> que;\n        vector<vector<unsigned long>> mapKey(m, vector<unsigned long>(n, 0));\n        int target = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if ('a' <= grid[i][j] && grid[i][j] <= 'f') {\n                    target |= 1 << (grid[i][j] - 'a');\n                    continue;\n                }\n\n                if (grid[i][j] == '@') {\n                    que.emplace(pair<int, int>(i, j), 0);\n                    mapKey[i][j] = 1;\n                }\n            }\n        }\n\n\n        int step = 0;\n        while (!que.empty()) {\n            int size = que.size();\n            for (int s = 0; s < size; s++) {\n                int i = que.front().first.first;\n                int j = que.front().first.second;\n                int key = que.front().second;\n                que.pop();\n                \n                if ('a' <= grid[i][j] && grid[i][j] <= 'f') {\n                    key |= 1 << (grid[i][j] - 'a');\n                    if (key == target)\n                        return step;\n\n                    mapKey[i][j] |= 1l << key;\n                }\n\n                for (int d = 0; d < 4; d++) {\n                    int newi = i + dir[d][0];\n                    int newj = j + dir[d][1];\n                    \n                    if (!(0 <= newi && newi < m && 0 <= newj && newj < n))\n                        continue;\n                        \n                    int val = grid[newi][newj];\n                    if (val == '#')\n                        continue;\n                        \n                    if ('A' <= val && val <= 'F' && (key & (1 << (val - 'A'))) == 0)\n                        continue;\n                        \n                    if (mapKey[newi][newj] & (1l << key))\n                        continue;\n                        \n                     mapKey[newi][newj] |= 1l << key;\n                     que.emplace(pair<int, int>(newi, newj), key);\n                }\n            }\n            step++;\n        }\n        return -1;\n    }\n};",
        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int dir[4][2] = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};\\n\\n    int shortestPathAllKeys(vector<string>& grid) {\\n        \\n        int m = grid.size();\\n        int n = grid[0].size();\\n        queue<pair<pair<int, int>, int>> que;\\n        vector<vector<unsigned long>> mapKey(m, vector<unsigned long>(n, 0));\\n        int target = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (\\'a\\' <= grid[i][j] && grid[i][j] <= \\'f\\') {\\n                    target |= 1 << (grid[i][j] - \\'a\\');\\n                    continue;\\n                }\\n\\n                if (grid[i][j] == \\'@\\') {\\n                    que.emplace(pair<int, int>(i, j), 0);\\n                    mapKey[i][j] = 1;\\n                }\\n            }\\n        }\\n\\n\\n        int step = 0;\\n        while (!que.empty()) {\\n            int size = que.size();\\n            for (int s = 0; s < size; s++) {\\n                int i = que.front().first.first;\\n                int j = que.front().first.second;\\n                int key = que.front().second;\\n                que.pop();\\n                \\n                if (\\'a\\' <= grid[i][j] && grid[i][j] <= \\'f\\') {\\n                    key |= 1 << (grid[i][j] - \\'a\\');\\n                    if (key == target)\\n                        return step;\\n\\n                    mapKey[i][j] |= 1l << key;\\n                }\\n\\n                for (int d = 0; d < 4; d++) {\\n                    int newi = i + dir[d][0];\\n                    int newj = j + dir[d][1];\\n                    \\n                    if (!(0 <= newi && newi < m && 0 <= newj && newj < n))\\n                        continue;\\n                        \\n                    int val = grid[newi][newj];\\n                    if (val == \\'#\\')\\n                        continue;\\n                        \\n                    if (\\'A\\' <= val && val <= \\'F\\' && (key & (1 << (val - \\'A\\'))) == 0)\\n                        continue;\\n                        \\n                    if (mapKey[newi][newj] & (1l << key))\\n                        continue;\\n                        \\n                     mapKey[newi][newj] |= 1l << key;\\n                     que.emplace(pair<int, int>(newi, newj), key);\\n                }\\n            }\\n            step++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
        "level": "hard",
        "type": [
            "operation error",
            "wrong comment mark",
            "unclosed string",
            "colon missing"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n\n    int dir[4][2] = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};\n\n    int shortestPathAllKeys(vector<string>& grid) {\n        \n        int m = grid.size();\n        int n = grid[0].size();\n        queue<pair<pair<int, int>, int>> que;\n        vector<vector<unsigned long>> mapKey(m, vector<unsigned long>(n, 0));\n        int target = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if ('a' <= grid[i][j] && grid[i][j] <= 'f') {\n                    target |= 1  (grid[i][j] - 'a\");\n                    continue;\n                }\n\n                if (grid[i][j] == '@') {\n                    que.emplace(pair<int, int>(i, j), 0);\n                    mapKey[i][j] = 1;\n                }\n            }\n        }\n\n\n        int step = 0;\n        while (!que.empty()) {\n            int size = que.size();\n            for (int s = 0; s < size; s++) {\n                int i = que.front().first.first;\n                int j = que.front().first.second;\n                int key = que.front().second;\n                que.pop();\n                \n                if ('a' <= grid[i][j] && grid[i][j] <= 'f\") {\n                    key |= 1 << (grid[i][j] - 'a\");\n                    if (key == target)\n                        return step;\n\n                    mapKey[i][j] |= 1l << key;\n                }\n\n                for (int d = 0; d < 4; d++) {\n                   \n                    int newj = j + dir[d][1];\n                    \n                    if (!(0 <= newi && newi < m && 0 <= newj && newj < n))\n                        continue;\n                        \n                    int val = grid[newi][newj];\n                    if (val == '#')\n                        continue;\n                        \n                    if ('A' <= val && val <= 'F' && (key & (1  (val - 'A\"))) == 0)\n                        continue;\n                        \n                    if (mapKey[newi][newj] & (1l << key))\n                        continue;\n                        \n                     mapKey[newi][newj] |= 1l << (key+1);  \n                     que.emplace(pair<int, int>(newi, newj), key);\n                }\n            }\n            step++;\n        }\n        return -1;\n    }\n};\n"
    },
    {
        "slug": "search-in-a-binary-search-tree",
        "description": "You are given the root of a binary search tree (BST) and an integer val.\nFind the node in the BST that the node's value equals val and return the subtree rooted with that node. If such a node does not exist, return null.",
        "examples": [
            "Input: root = [4,2,7,1,3], val = 2\nOutput: [2,1,3]",
            "Input: root = [4,2,7,1,3], val = 5\nOutput: []"
        ],
        "constraints": "The number of nodes in the tree is in the range [1, 5000].\n1 <= Node.val <= 107\nroot is a binary search tree.\n1 <= val <= 107",
        "oracle_code": "class Solution {\npublic:\n    TreeNode* searchBST(TreeNode* root, int val) {\n       if(root==NULL) \n       return NULL;\n       if(root->val==val)\n       {\n           return root;\n       }\n       if(root->val>val){\n          return  searchBST(root->left,val);\n       }\n        return searchBST(root->right,val);\n    }\n};",
        "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n       if(root==NULL) \\n       return NULL;\\n       if(root->val==val)\\n       {\\n           return root;\\n       }\\n       if(root->val>val){\\n          return  searchBST(root->left,val);\\n       }\\n        return searchBST(root->right,val);\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "statement separation",
            "wrong comment mark",
            "undefined keywords from other languages",
            "colon missing"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    /* \n    TreeNode* searchBST(TreeNode* root, int val) {\n       if(root=None) \n       return NULL;\n       if(root->val==val);\n       {\n           return root;\n       }\n       if(root->val>val){\n          return  searchBST(root->left,val);\n       }\n        return searchBST(root->right,val);\n    }\n    */\n};\n"
    },
    {
        "slug": "widest-vertical-area-between-two-points-containing-no-points",
        "description": "Given n points on a 2D plane where points[i] = [xi, yi], Return\u00a0the widest vertical area between two points such that no points are inside the area.\nA vertical area is an area of fixed-width extending infinitely along the y-axis (i.e., infinite height). The widest vertical area is the one with the maximum width.\nNote that points on the edge of a vertical area are not considered included in the area.",
        "examples": [
            "\u200b\n\nInput: points = [[8,7],[9,9],[7,4],[9,7]]\nOutput: 1\nExplanation: Both the red and the blue area are optimal.",
            "Input: points = [[3,1],[9,0],[1,0],[1,4],[5,3],[8,8]]\nOutput: 3"
        ],
        "constraints": "n == points.length\n2 <= n <= 105\npoints[i].length == 2\n0 <= xi, yi\u00a0<= 109",
        "oracle_code": "class Solution {\npublic:\n  int maxWidthOfVerticalArea(vector<vector<int>>& points) {\n    set<int> x;\n    int res = 0;\n    for (auto &p : points)\n        x.insert(p[0]);\n    for (auto it = next(begin(x)); it != end(x); ++it)\n        res = max(res, *it - *prev(it));\n    return res;\n}\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  int maxWidthOfVerticalArea(vector<vector<int>>& points) {\\n    set<int> x;\\n    int res = 0;\\n    for (auto &p : points)\\n        x.insert(p[0]);\\n    for (auto it = next(begin(x)); it != end(x); ++it)\\n        res = max(res, *it - *prev(it));\\n    return res;\\n}\\n};\\n```",
        "level": "medium",
        "type": [
            "indexing error",
            "operation error",
            "undefined methods",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n  int maxWidthOfVerticalArea(vector<vector<int>>& points) {\n    set<int> x;\n    int res = 0;\n    for (auto &p : points)\n        x.insert(p[2]);\n    for (auto it = next(begin(x)); it != end(x); ++it)\n        res = max(res, *it - *prev(it);\n    return ++calculateArea();\n}\nprivate:\n    int calculateArea();\n};\n"
    },
    {
        "slug": "lru-cache",
        "description": "Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.\nImplement the LRUCache class:\n\nLRUCache(int capacity) Initialize the LRU cache with positive size capacity.\nint get(int key) Return the value of the key if the key exists, otherwise return -1.\nvoid put(int key, int value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key.\n\nThe functions get and put must each run in O(1) average time complexity.",
        "examples": [
            "Input\n[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"]\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\nOutput\n[null, null, null, 1, null, -1, null, -1, 3, 4]\n\nExplanation\nLRUCache lRUCache = new LRUCache(2);\nlRUCache.put(1, 1); // cache is {1=1}\nlRUCache.put(2, 2); // cache is {1=1, 2=2}\nlRUCache.get(1);    // return 1\nlRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}\nlRUCache.get(2);    // returns -1 (not found)\nlRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}\nlRUCache.get(1);    // return -1 (not found)\nlRUCache.get(3);    // return 3\nlRUCache.get(4);    // return 4"
        ],
        "constraints": "1 <= capacity <= 3000\n0 <= key <= 104\n0 <= value <= 105\nAt most 2 * 105 calls will be made to get and put.",
        "oracle_code": "class LRUCache {\npublic:\nclass node\n{\n  public:\n  int key;\n  int val;\n  node* next;\n  node* prev;\n  node(int _key,int _val)\n  {\n    key = _key;\n    val = _val;\n  }\n};\nnode* head = new node(-1,-1);\nnode* tail = new node(-1,-1);\n\nint size;\nunordered_map<int,node*>mpp;\n    LRUCache(int capacity) {\n       size = capacity; \n       head->next = tail;\n       tail->prev = head;  \n    }\n\n    void addNode(node* newNode){\n       \n       node* temp = head->next;\n       newNode->next = temp;\n       newNode->prev = head;\n       head->next = newNode;\n       temp->prev = newNode;\n    }\n\n    void deleteNode(node* delNode){\n         \n       node* delprev = delNode->prev;\n       node* delnext = delNode->next;\n       delprev->next = delnext;\n       delnext->prev = delprev;\n    }\n    \n    int get(int _key) {\n        \n        if(mpp.count(_key))\n        {\n          node* nde = mpp[_key];\n          int curr = nde->val;\n          mpp.erase(_key);\n          deleteNode(nde);\n          addNode(nde);\n          mpp[_key] = head->next;\n          return curr;\n        }\n        return -1;\n    }\n    \n    void put(int _key, int value) {\n        \n        if(mpp.count(_key))\n        {\n           node* nde = mpp[_key];\n           mpp.erase(_key);\n           deleteNode(nde);\n        }\n        if(mpp.size()==size)\n        {\n           mpp.erase(tail->prev->key);\n           deleteNode(tail->prev);\n        }\n        addNode(new node(_key,value));\n        mpp[_key] = head->next;\n    }\n};",
        "content": "# PLEASE DO UPVOTE!!!!!\\n\\n**CONNECT WITH ME ON LINKEDIN :  https://www.linkedin.com/in/md-kamran-55b98521a/**\\n\\n## INTUITION\\nTo Implement LRU(Least recently used), we need to have a track of the usage of the keys, in the order of there usage, as we have a limited capacity we cant extend our capacity beyond \"capacity\", so we always we will take out those values which has\\'nt been acccess in the recent time.So, we have to think of something that can kind of sort our keys according to usage on the go, the best Data Structure for this purpose is Doubly linked List.\\n                             A Doubly linked list will have a Head node as well as a tail node, and whenever a key is used we will place it just next to the head node,in this fashions, the one\\'s which are closer to head are the most recently used ones, and as we go closer to the tail node, those are the less recently used ones while the node just previous to tail is the \"LEAST RECENTLY USED\". \\nSo whenever we add a key or use a key(get()), we will move it right after the head node, and whenever we call the (put() function), if size if greater we have to delete the LRU node, if key is not present, (if present then too we will delete that node so as to update the value and still move it right after head node), and place new node right after head node.                        \\n\\n\\n**Ask Furthur Doubts in the Comment Section**\\n# Code\\n```\\nclass LRUCache {\\npublic:\\nclass node\\n{\\n  public:\\n  int key;\\n  int val;\\n  node* next;\\n  node* prev;\\n  node(int _key,int _val)\\n  {\\n    key = _key;\\n    val = _val;\\n  }\\n};\\nnode* head = new node(-1,-1);\\nnode* tail = new node(-1,-1);\\n\\nint size;\\nunordered_map<int,node*>mpp;\\n    LRUCache(int capacity) {\\n       size = capacity; \\n       head->next = tail;\\n       tail->prev = head;  \\n    }\\n\\n    void addNode(node* newNode){\\n       \\n       node* temp = head->next;\\n       newNode->next = temp;\\n       newNode->prev = head;\\n       head->next = newNode;\\n       temp->prev = newNode;\\n    }\\n\\n    void deleteNode(node* delNode){\\n         \\n       node* delprev = delNode->prev;\\n       node* delnext = delNode->next;\\n       delprev->next = delnext;\\n       delnext->prev = delprev;\\n    }\\n    \\n    int get(int _key) {\\n        \\n        if(mpp.count(_key))\\n        {\\n          node* nde = mpp[_key];\\n          int curr = nde->val;\\n          mpp.erase(_key);\\n          deleteNode(nde);\\n          addNode(nde);\\n          mpp[_key] = head->next;\\n          return curr;\\n        }\\n        return -1;\\n    }\\n    \\n    void put(int _key, int value) {\\n        \\n        if(mpp.count(_key))\\n        {\\n           node* nde = mpp[_key];\\n           mpp.erase(_key);\\n           deleteNode(nde);\\n        }\\n        if(mpp.size()==size)\\n        {\\n           mpp.erase(tail->prev->key);\\n           deleteNode(tail->prev);\\n        }\\n        addNode(new node(_key,value));\\n        mpp[_key] = head->next;\\n    }\\n};\\n\\n```\\n![b62ab1be-232a-438f-9524-7d8ca4dbd5fe_1675328166.1161866.png](https://assets.leetcode.com/users/images/8d5343b1-0eb4-4111-a914-40ce968fd034_1675389764.2273676.png)",
        "level": "medium",
        "type": [
            "undefined methods",
            "undefined keywords from other languages",
            "variable value error",
            "colon missing"
        ],
        "buggy_code": "\nclass LRUCache {\npublic:\nclass node\n{\n  public:\n  int key;\n  int val;\n  node* next;\n  node* prev;\n  node(int _key,int _val)\n  {\n    key = _key;\n    val = _val;\n  }\n};\nnode* head = new node(-1,-1);\nnode* tail = new node(-1,-1);\n\nint size;\nunordered_map<int,node*>mpp;\n    LRUCache(int capacity) {\n       size = capacity; \n       head->next = tail;\n       tail->prev = head;  \n    }\n\n    void addNode(node* newNode){\n       \n       node* temp = head->next;\n       newNode->next = temp;\n       newNode->prev = head;\n       head->next = newNode;\n    }\n\n    void deleteNode(node* delNode){\n         \n       node* delprev = delNode->prev;\n       node* delnext = delNode->next;\n       delprev->next = delnext;\n       delnext->prev = delprev;\n    }\n    \n    int get(int _key) {\n        \n        if(mpp.count(_key))\n        {\n          node* nde = mpp[_key];\n          int curr = nde->val;\n          mpp.erase(_key);\n          deleteNode(nde);\n          addNode(nde)\n          mpp[_key] = head->next;\n          return curr;\n        }\n        return -1;\n    }\n\n}; \nr\ntil\n\n"
    },
    {
        "slug": "shortest-path-with-alternating-colors",
        "description": "You are given an integer n, the number of nodes in a directed graph where the nodes are labeled from 0 to n - 1. Each edge is red or blue in this graph, and there could be self-edges and parallel edges.\nYou are given two arrays redEdges and blueEdges where:\n\nredEdges[i] = [ai, bi] indicates that there is a directed red edge from node ai to node bi in the graph, and\nblueEdges[j] = [uj, vj] indicates that there is a directed blue edge from node uj to node vj in the graph.\n\nReturn an array answer of length n, where each answer[x] is the length of the shortest path from node 0 to node x such that the edge colors alternate along the path, or -1 if such a path does not exist.",
        "examples": [
            "Input: n = 3, redEdges = [[0,1],[1,2]], blueEdges = []\nOutput: [0,1,-1]",
            "Input: n = 3, redEdges = [[0,1]], blueEdges = [[2,1]]\nOutput: [0,1,-1]"
        ],
        "constraints": "1 <= n <= 100\n0 <= redEdges.length,\u00a0blueEdges.length <= 400\nredEdges[i].length == blueEdges[j].length == 2\n0 <= ai, bi, uj, vj < n",
        "oracle_code": "class Solution {\npublic:\n    vector<int> shortestAlternatingPaths(int n,vector<vector<int>>&redEdges,vector<vector<int>>& blueEdges) \n    {\n        multiset<int>temp;\n        vector<multiset<int>>redchilds(n,temp),bluechilds(n,temp);\n        for(auto j:redEdges)\n        {\n            redchilds[j[0]].insert(j[1]);\n        }\n        for(auto j:blueEdges)\n        {\n            bluechilds[j[0]].insert(j[1]);\n        }\n        vector<int>ans;\n        for(int i=0;i<n;i++)\n        {\n            //BFS for all\n            vector<multiset<int>>reds=redchilds,blues=bluechilds;\n            queue<pair<char,int>>visit;\n            visit.push({'n',0});//neutral='n'\n            int steps=0;\n            while(!visit.empty())\n            {\n                bool justbreak=false;\n                int n=visit.size();\n                for(int j=0;j<n;j++)\n                {\n                    pair<char,int>x=visit.front();\n                    visit.pop();\n                    if(x.second==i)\n                    {\n                        ans.push_back(steps);\n                        justbreak=true;\n                        break;\n                    }\n                    if(x.first=='n')\n                    {\n                        for(auto j:reds[x.second])\n                        {\n                            visit.push({'r',j});\n                            auto itr1=reds[x.second].find(j);\n                            reds[x.second].erase(itr1);\n                        }\n                        for(auto j:blues[x.second])\n                        {\n                            visit.push({'b',j});//blue='b'\n                            auto itr1=blues[x.second].find(j);\n                            blues[x.second].erase(itr1);\n                        }\n                    }\n                    else if(x.first=='b')\n                    {\n                        for(auto j:reds[x.second])\n                        {\n                            visit.push({'r',j});//red='r'\n                            auto itr1=reds[x.second].find(j);\n                            reds[x.second].erase(itr1);\n                        }\n                    }\n                    else if(x.first=='r')\n                    {\n                        for(auto j:blues[x.second])\n                        {\n                            visit.push({'b',j});\n                            auto itr1=blues[x.second].find(j);\n                            blues[x.second].erase(itr1);\n                        }\n                    }\n                }\n                if(justbreak)\n                {\n                    break;\n                }\n                steps++;\n            }\n            if(i==ans.size())\n            {\n                ans.push_back(-1);\n            }\n        }\n        return ans;\n    }\n};",
        "content": "*E denotes number of Edges*\\n\\n# Complexity\\n- Time complexity:\\nO((N^2)+(N)*(E)*LOG(E))\\n\\n- Space complexity:\\nO(E)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> shortestAlternatingPaths(int n,vector<vector<int>>&redEdges,vector<vector<int>>& blueEdges) \\n    {\\n        multiset<int>temp;\\n        vector<multiset<int>>redchilds(n,temp),bluechilds(n,temp);\\n        for(auto j:redEdges)\\n        {\\n            redchilds[j[0]].insert(j[1]);\\n        }\\n        for(auto j:blueEdges)\\n        {\\n            bluechilds[j[0]].insert(j[1]);\\n        }\\n        vector<int>ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            //BFS for all\\n            vector<multiset<int>>reds=redchilds,blues=bluechilds;\\n            queue<pair<char,int>>visit;\\n            visit.push({\\'n\\',0});//neutral=\\'n\\'\\n            int steps=0;\\n            while(!visit.empty())\\n            {\\n                bool justbreak=false;\\n                int n=visit.size();\\n                for(int j=0;j<n;j++)\\n                {\\n                    pair<char,int>x=visit.front();\\n                    visit.pop();\\n                    if(x.second==i)\\n                    {\\n                        ans.push_back(steps);\\n                        justbreak=true;\\n                        break;\\n                    }\\n                    if(x.first==\\'n\\')\\n                    {\\n                        for(auto j:reds[x.second])\\n                        {\\n                            visit.push({\\'r\\',j});\\n                            auto itr1=reds[x.second].find(j);\\n                            reds[x.second].erase(itr1);\\n                        }\\n                        for(auto j:blues[x.second])\\n                        {\\n                            visit.push({\\'b\\',j});//blue=\\'b\\'\\n                            auto itr1=blues[x.second].find(j);\\n                            blues[x.second].erase(itr1);\\n                        }\\n                    }\\n                    else if(x.first==\\'b\\')\\n                    {\\n                        for(auto j:reds[x.second])\\n                        {\\n                            visit.push({\\'r\\',j});//red=\\'r\\'\\n                            auto itr1=reds[x.second].find(j);\\n                            reds[x.second].erase(itr1);\\n                        }\\n                    }\\n                    else if(x.first==\\'r\\')\\n                    {\\n                        for(auto j:blues[x.second])\\n                        {\\n                            visit.push({\\'b\\',j});\\n                            auto itr1=blues[x.second].find(j);\\n                            blues[x.second].erase(itr1);\\n                        }\\n                    }\\n                }\\n                if(justbreak)\\n                {\\n                    break;\\n                }\\n                steps++;\\n            }\\n            if(i==ans.size())\\n            {\\n                ans.push_back(-1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "== and = confusion",
            "wrong comment mark",
            "unclosed string",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    vector<int> shortestAlternatingPaths(int n,vector<vector<int>>&redEdges,vector<vector<int>>& blueEdges) \n    {\n        multiset<int>temp;\n        vector<multiset<int>>redchilds(n,temp),bluechilds(n,temp);\n        for(auto j:redEdges)\n        {\n            redchilds[j[0]].insert(j[1]);\n        }\n        for(auto j:blueEdges)\n        {\n            bluechilds[j[0]].insert(j[1]);\n        }\n        vector<int>ans(n, -1);\n        for(int i=0;i<n;) \n        {\n            //BFS for all\n            vector<multiset<int>>reds=redchilds,blues=bluechilds;\n            queue<pair<char,int>>visit;\n            visit.push({'n',0});//neutral='n'\n            int steps=0;\n            while(!visit.empty())\n            {\n                bool justbreak=false;\n                int n=visit.size();\n                for(int j=0;j<n;j++)\n                {\n                    pair<char,int>x=visit.front();\n                    \n                    if(x.second=i)\n                    {\n                        ans[i]=steps;\n                        justbreak=true;\n                        break;\n                    }\n                    if(x.first=='n' || x.first == ans[i] % 2 + '0') \n                    {\n                        for(auto j:reds[x.second])\n                        {\n                            visit.push({'r\",j});\n                            auto itr1=reds[x.second].find(j);\n                            reds[x.second].erase(itr1);\n                        }\n                        for(auto j:blues[x.second])\n                        {\n                            visit.push({'b',j});//blue='b'\n                            auto itr1=blues[x.second].find(j);\n                            blues[x.second].erase(itr1);\n                        }\n                    }\n                    else if(x.first=='b')\n                    {\n                        for(auto j:reds[x.second])\n                        {\n                            visit.push({'r',j});//red='r'\n                            auto itr1=reds[x.second].find(j);\n                            reds[x.second].erase(itr1);\n                        }\n                    }\n                    else if(x.first=='r')\n                    {\n                        for(auto j:blues[x.second])\n                        {\n                            visit.push({'b',j});\n                            auto itr1=blues[x.second].find(j);\n                            blues[x.second].erase(itr1);\n                        }\n                    }\n                }\n                if(justbreak)\n                {\n                    break;\n                }\n                steps++;\n            }\n        }\n        return ans;\n    }\n};\n"
    },
    {
        "slug": "shortest-path-with-alternating-colors",
        "description": "You are given an integer n, the number of nodes in a directed graph where the nodes are labeled from 0 to n - 1. Each edge is red or blue in this graph, and there could be self-edges and parallel edges.\nYou are given two arrays redEdges and blueEdges where:\n\nredEdges[i] = [ai, bi] indicates that there is a directed red edge from node ai to node bi in the graph, and\nblueEdges[j] = [uj, vj] indicates that there is a directed blue edge from node uj to node vj in the graph.\n\nReturn an array answer of length n, where each answer[x] is the length of the shortest path from node 0 to node x such that the edge colors alternate along the path, or -1 if such a path does not exist.",
        "examples": [
            "Input: n = 3, redEdges = [[0,1],[1,2]], blueEdges = []\nOutput: [0,1,-1]",
            "Input: n = 3, redEdges = [[0,1]], blueEdges = [[2,1]]\nOutput: [0,1,-1]"
        ],
        "constraints": "1 <= n <= 100\n0 <= redEdges.length,\u00a0blueEdges.length <= 400\nredEdges[i].length == blueEdges[j].length == 2\n0 <= ai, bi, uj, vj < n",
        "oracle_code": "class Solution {\npublic:\n    vector<int> shortestAlternatingPaths(int n,vector<vector<int>>&redEdges,vector<vector<int>>& blueEdges) \n    {\n        multiset<int>temp;\n        vector<multiset<int>>redchilds(n,temp),bluechilds(n,temp);\n        for(auto j:redEdges)\n        {\n            redchilds[j[0]].insert(j[1]);\n        }\n        for(auto j:blueEdges)\n        {\n            bluechilds[j[0]].insert(j[1]);\n        }\n        vector<int>ans;\n        for(int i=0;i<n;i++)\n        {\n            //BFS for all\n            vector<multiset<int>>reds=redchilds,blues=bluechilds;\n            queue<pair<char,int>>visit;\n            visit.push({'n',0});//neutral='n'\n            int steps=0;\n            while(!visit.empty())\n            {\n                bool justbreak=false;\n                int n=visit.size();\n                for(int j=0;j<n;j++)\n                {\n                    pair<char,int>x=visit.front();\n                    visit.pop();\n                    if(x.second==i)\n                    {\n                        ans.push_back(steps);\n                        justbreak=true;\n                        break;\n                    }\n                    if(x.first=='n')\n                    {\n                        for(auto j:reds[x.second])\n                        {\n                            visit.push({'r',j});\n                            auto itr1=reds[x.second].find(j);\n                            reds[x.second].erase(itr1);\n                        }\n                        for(auto j:blues[x.second])\n                        {\n                            visit.push({'b',j});//blue='b'\n                            auto itr1=blues[x.second].find(j);\n                            blues[x.second].erase(itr1);\n                        }\n                    }\n                    else if(x.first=='b')\n                    {\n                        for(auto j:reds[x.second])\n                        {\n                            visit.push({'r',j});//red='r'\n                            auto itr1=reds[x.second].find(j);\n                            reds[x.second].erase(itr1);\n                        }\n                    }\n                    else if(x.first=='r')\n                    {\n                        for(auto j:blues[x.second])\n                        {\n                            visit.push({'b',j});\n                            auto itr1=blues[x.second].find(j);\n                            blues[x.second].erase(itr1);\n                        }\n                    }\n                }\n                if(justbreak)\n                {\n                    break;\n                }\n                steps++;\n            }\n            if(i==ans.size())\n            {\n                ans.push_back(-1);\n            }\n        }\n        return ans;\n    }\n};",
        "content": "*E denotes number of Edges*\\n\\n# Complexity\\n- Time complexity:\\nO((N^2)+(N)*(E)*LOG(E))\\n\\n- Space complexity:\\nO(E)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> shortestAlternatingPaths(int n,vector<vector<int>>&redEdges,vector<vector<int>>& blueEdges) \\n    {\\n        multiset<int>temp;\\n        vector<multiset<int>>redchilds(n,temp),bluechilds(n,temp);\\n        for(auto j:redEdges)\\n        {\\n            redchilds[j[0]].insert(j[1]);\\n        }\\n        for(auto j:blueEdges)\\n        {\\n            bluechilds[j[0]].insert(j[1]);\\n        }\\n        vector<int>ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            //BFS for all\\n            vector<multiset<int>>reds=redchilds,blues=bluechilds;\\n            queue<pair<char,int>>visit;\\n            visit.push({\\'n\\',0});//neutral=\\'n\\'\\n            int steps=0;\\n            while(!visit.empty())\\n            {\\n                bool justbreak=false;\\n                int n=visit.size();\\n                for(int j=0;j<n;j++)\\n                {\\n                    pair<char,int>x=visit.front();\\n                    visit.pop();\\n                    if(x.second==i)\\n                    {\\n                        ans.push_back(steps);\\n                        justbreak=true;\\n                        break;\\n                    }\\n                    if(x.first==\\'n\\')\\n                    {\\n                        for(auto j:reds[x.second])\\n                        {\\n                            visit.push({\\'r\\',j});\\n                            auto itr1=reds[x.second].find(j);\\n                            reds[x.second].erase(itr1);\\n                        }\\n                        for(auto j:blues[x.second])\\n                        {\\n                            visit.push({\\'b\\',j});//blue=\\'b\\'\\n                            auto itr1=blues[x.second].find(j);\\n                            blues[x.second].erase(itr1);\\n                        }\\n                    }\\n                    else if(x.first==\\'b\\')\\n                    {\\n                        for(auto j:reds[x.second])\\n                        {\\n                            visit.push({\\'r\\',j});//red=\\'r\\'\\n                            auto itr1=reds[x.second].find(j);\\n                            reds[x.second].erase(itr1);\\n                        }\\n                    }\\n                    else if(x.first==\\'r\\')\\n                    {\\n                        for(auto j:blues[x.second])\\n                        {\\n                            visit.push({\\'b\\',j});\\n                            auto itr1=blues[x.second].find(j);\\n                            blues[x.second].erase(itr1);\\n                        }\\n                    }\\n                }\\n                if(justbreak)\\n                {\\n                    break;\\n                }\\n                steps++;\\n            }\\n            if(i==ans.size())\\n            {\\n                ans.push_back(-1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "== and = confusion",
            "wrong comment mark",
            "unclosed string",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    vector<int> shortestAlternatingPaths(int n,vector<vector<int>>&redEdges,vector<vector<int>>& blueEdges) \n    {\n        multiset<int>temp;\n        vector<multiset<int>>redchilds(n,temp),bluechilds(n,temp);\n        for(auto j:redEdges)\n        {\n            redchilds[j[0]].insert(j[1]);\n        }\n        for(auto j:blueEdges)\n        {\n            bluechilds[j[0]].insert(j[1]);\n        }\n        vector<int>ans;\n        for(int i=0;i<n;i++)\n        {\n            //BFS for all\n            vector<multiset<int>>reds=redchilds,blues=bluechilds;\n            queue<pair<char,int>>visit;\n            visit.push({'n',0});//neutral='n'\n            int steps=0;\n            while(!visit.empty())\n            {\n                bool justbreak=false;\n                int n=visit.size();\n                for(int j=0;j<n;j++)\n                {\n                    pair<char,int>x=visit.front();\n                    \n                    if(x.second=i)\n                    {\n                        ans.push_back(steps);\n                        justbreak=true;\n                        break;\n                    }\n                    if(x.first=='n')\n                    {\n                        for(auto j:reds[x.second])\n                        {\n                            visit.push({'r\",j});\n                            auto itr1=reds[x.second].find(j);\n                            reds[x.second].erase(itr1);\n                        }\n                        for(auto j:blues[x.second])\n                        {\n                            visit.push({'b',j});//blue='b'\n                            auto itr1=blues[x.second].find(j);\n                            unknownFunction(itr1); \n                            blues[x.second].erase(itr1);\n                        }\n                    }\n                    else if(x.first=='b')\n                    {\n                        for(auto j:reds[x.second])\n                        {\n                            visit.push({'r',j});//red='r'\n                            auto itr1=reds[x.second].find(j);\n                            reds[x.second].erase(itr1);\n                        }\n                    }\n                    else if(x.first=='r')\n                    {\n                        for(auto j:blues[x.second])\n                        {\n                            visit.push({'b',j});\n                            auto itr1=blues[x.second].find(j);\n                            blues[x.second].erase(itr1);\n                        }\n                    }\n                }\n                if(justbreak)\n                {\n                    break;\n                }\n                steps++;\n            }\n            if(i==ans.size())\n            {\n                ans.push_back(-1);\n            }\n        }\n        return ans;\n    }\n};\n"
    },
    {
        "slug": "special-binary-string",
        "description": "Special binary strings are binary strings with the following two properties:\n\nThe number of 0's is equal to the number of 1's.\nEvery prefix of the binary string has at least as many 1's as 0's.\n\nYou are given a special binary string s.\nA move consists of choosing two consecutive, non-empty, special substrings of s, and swapping them. Two strings are consecutive if the last character of the first string is exactly one index before the first character of the second string.\nReturn the lexicographically largest resulting string possible after applying the mentioned operations on the string.",
        "examples": [
            "Input: s = \"11011000\"\nOutput: \"11100100\"\nExplanation: The strings \"10\" [occuring at s[1]] and \"1100\" [at s[3]] are swapped.\nThis is the lexicographically largest string possible after some number of swaps.",
            "Input: s = \"10\"\nOutput: \"10\""
        ],
        "constraints": "1 <= s.length <= 50\ns[i] is either '0' or '1'.\ns is a special binary string.",
        "oracle_code": "class Solution {\npublic:\n    string makeLargestSpecial(string s) {\n        \n        if(s.length()==0)\n            return \"\"; //return null string if size is zero\n\n        vector<string> ans; //list to store all current special substrings\n        int count=0,i=0; //keep track of special substring starting index using \"i\" and \n                         //\"count\" to keep the track of special substring is over or not\n\n        for(int j=0;j<s.size();j++){\n            if(s[j] == '1')\n                count++;\n            else\n                count--;\n            \n            if(count==0){\n                //call recursively using mid special substring\n\n                ans.push_back('1' + makeLargestSpecial(s.substr(i+1,j-i-1)) + '0');\n                i = j+1;\n            }\n        }\n        //sort current substring stored list to fulfill the question demand\n\n        sort(ans.begin(),ans.end(),greater<string>());\n        string finalString = \"\";\n        for(i=0;i<ans.size();i++){\n            finalString += ans[i];\n        }\n        return finalString;\n    }\n};",
        "content": "Reminder: Special substring can not start with 0 as the 2nd condition states there should be atleast as many no of ones as zeroes, \\neg: \"01001\" prefix of this string is \"0\" but it does\\'nt contain any 1s with itself\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string makeLargestSpecial(string s) {\\n        \\n        if(s.length()==0)\\n            return \"\"; //return null string if size is zero\\n\\n        vector<string> ans; //list to store all current special substrings\\n        int count=0,i=0; //keep track of special substring starting index using \"i\" and \\n                         //\"count\" to keep the track of special substring is over or not\\n\\n        for(int j=0;j<s.size();j++){\\n            if(s[j] == \\'1\\')\\n                count++;\\n            else\\n                count--;\\n            \\n            if(count==0){\\n                //call recursively using mid special substring\\n\\n                ans.push_back(\\'1\\' + makeLargestSpecial(s.substr(i+1,j-i-1)) + \\'0\\');\\n                i = j+1;\\n            }\\n        }\\n        //sort current substring stored list to fulfill the question demand\\n\\n        sort(ans.begin(),ans.end(),greater<string>());\\n        string finalString = \"\";\\n        for(i=0;i<ans.size();i++){\\n            finalString += ans[i];\\n        }\\n        return finalString;\\n    }\\n};\\n```",
        "level": "hard",
        "type": [
            "other error",
            "indexing error",
            "wrong comment mark",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    string makeLargestSpecial(string s) {\n        \n        if(s.length()==0)\n            return \"\"; * \n\n        vector<string> ans; \n        int count=0,i=0; \n\n        for(int j=0;j<=s.size();j++){\n            if(s[j] == '1')\n                count++;\n            else\n                count--;\n            \n            if(count==0){\n                ans.push_back('1' + makeLargestSpecial(s.substr(i+1,j-i-1)) + '0\");\n                i = j;\n            }\n        }\n        sort(ans.begin(),ans.end(),greater<string>());\n        string finalString = \"\";\n        for(i=0;i<=ans.size();i++){\n            finalString += ans[i];\n        }\n        return finalString;\n    }\n};\n"
    },
    {
        "slug": "magical-string",
        "description": "A magical string s consists of only '1' and '2' and obeys the following rules:\n\nThe string s is magical because concatenating the number of contiguous occurrences of characters '1' and '2' generates the string s itself.\n\nThe first few elements of s is s = \"1221121221221121122\u2026\u2026\". If we group the consecutive 1's and 2's in s, it will be \"1 22 11 2 1 22 1 22 11 2 11 22 ......\" and the occurrences of 1's or 2's in each group are \"1 2 2 1 1 2 1 2 2 1 2 2 ......\". You can see that the occurrence sequence is s itself.\nGiven an integer n, return the number of 1's in the first n number in the magical string s.",
        "examples": [
            "Input: n = 6\nOutput: 3\nExplanation: The first 6 elements of magical string s is \"122112\" and it contains three 1's, so return 3.",
            "Input: n = 1\nOutput: 1"
        ],
        "constraints": "1 <= n <= 105",
        "oracle_code": "class Solution {\npublic:\n    int magicalString(int n) {\n        string s=\"\";\n        s+=\"122\";\n        int i=2,c=1;\n        while(i<n && s.size()<n)\n        {\n            if(s[i]=='1')\n            {\n                c++;\n                if(s[s.size()-1]=='2')\n                s+='1';\n                else\n                {\n                    s+='2';\n                }\n            }\n            else\n            {\n                if(s[s.size()-1]=='2')\n                s+=\"11\";\n                else\n                {\n                    s+=\"22\";\n                }\n            }\n            i++;\n        }\n        while(i<n)\n        {\n            if(s[i]=='1')\n            c++;\n            i++;\n        }\n        return c;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIntution was to find the repeating part first, then i saw the pattern carefully and tried to make it.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can make the string using first three digits only \"122\",my intution is to make whole string upto length n,and count ones side by side. Also to count the remaining 1\\'s after while loop breaks\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int magicalString(int n) {\\n        string s=\"\";\\n        s+=\"122\";\\n        int i=2,c=1;\\n        while(i<n && s.size()<n)\\n        {\\n            if(s[i]==\\'1\\')\\n            {\\n                c++;\\n                if(s[s.size()-1]==\\'2\\')\\n                s+=\\'1\\';\\n                else\\n                {\\n                    s+=\\'2\\';\\n                }\\n            }\\n            else\\n            {\\n                if(s[s.size()-1]==\\'2\\')\\n                s+=\"11\";\\n                else\\n                {\\n                    s+=\"22\";\\n                }\\n            }\\n            i++;\\n        }\\n        while(i<n)\\n        {\\n            if(s[i]==\\'1\\')\\n            c++;\\n            i++;\\n        }\\n        return c;\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "== and = confusion",
            "indexing error",
            "unclosed string",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    int magicalString(int n) {\n        str s=\"\";\n        s+=\"122\";\n        int i=2,c=1;\n        while(i<n && s.size()<n)\n        {\n            if(s[i]='1') \n            {\n                c++;\n                if(s[s.size()]=='2')\n                s+='1';\n                else\n                {\n                    s+='2';\n                }\n            }\n            else\n            {\n                if(s[s.size()]=='2')\n                s+=\"11\";\n                else\n                {\n                    s+='22'; \n                }\n            }\n            i++;\n        }\n        while(i<n)\n        {\n            if(s[i]='1') \n            c++;\n            i++;\n        }\n        return c;\n    }\n};\n"
    },
    {
        "slug": "magical-string",
        "description": "A magical string s consists of only '1' and '2' and obeys the following rules:\n\nThe string s is magical because concatenating the number of contiguous occurrences of characters '1' and '2' generates the string s itself.\n\nThe first few elements of s is s = \"1221121221221121122\u2026\u2026\". If we group the consecutive 1's and 2's in s, it will be \"1 22 11 2 1 22 1 22 11 2 11 22 ......\" and the occurrences of 1's or 2's in each group are \"1 2 2 1 1 2 1 2 2 1 2 2 ......\". You can see that the occurrence sequence is s itself.\nGiven an integer n, return the number of 1's in the first n number in the magical string s.",
        "examples": [
            "Input: n = 6\nOutput: 3\nExplanation: The first 6 elements of magical string s is \"122112\" and it contains three 1's, so return 3.",
            "Input: n = 1\nOutput: 1"
        ],
        "constraints": "1 <= n <= 105",
        "oracle_code": "class Solution {\npublic:\n    int magicalString(int n) {\n        string s=\"\";\n        s+=\"122\";\n        int i=2,c=1;\n        while(i<n && s.size()<n)\n        {\n            if(s[i]=='1')\n            {\n                c++;\n                if(s[s.size()-1]=='2')\n                s+='1';\n                else\n                {\n                    s+='2';\n                }\n            }\n            else\n            {\n                if(s[s.size()-1]=='2')\n                s+=\"11\";\n                else\n                {\n                    s+=\"22\";\n                }\n            }\n            i++;\n        }\n        while(i<n)\n        {\n            if(s[i]=='1')\n            c++;\n            i++;\n        }\n        return c;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIntution was to find the repeating part first, then i saw the pattern carefully and tried to make it.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can make the string using first three digits only \"122\",my intution is to make whole string upto length n,and count ones side by side. Also to count the remaining 1\\'s after while loop breaks\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int magicalString(int n) {\\n        string s=\"\";\\n        s+=\"122\";\\n        int i=2,c=1;\\n        while(i<n && s.size()<n)\\n        {\\n            if(s[i]==\\'1\\')\\n            {\\n                c++;\\n                if(s[s.size()-1]==\\'2\\')\\n                s+=\\'1\\';\\n                else\\n                {\\n                    s+=\\'2\\';\\n                }\\n            }\\n            else\\n            {\\n                if(s[s.size()-1]==\\'2\\')\\n                s+=\"11\";\\n                else\\n                {\\n                    s+=\"22\";\\n                }\\n            }\\n            i++;\\n        }\\n        while(i<n)\\n        {\\n            if(s[i]==\\'1\\')\\n            c++;\\n            i++;\\n        }\\n        return c;\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "== and = confusion",
            "indexing error",
            "unclosed string",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    int magicalString(int n) {\n        string s=\"\";\n        s+=\"122\";\n        int i=2,c=1;\n        while(i<n && s.size()<n\n        {\n            if(s[i]='1') \n            {\n                c++;\n                if(s[s.size()]=='2')\n                s+='1';\n                else\n                {\n                    s+='2';\n                }\n            }\n            else\n            {\n                if(s[s.size()]=='2')\n                s+=\"11\";\n                else\n                {\n                    s+='22'; \n                }\n            }\n            i++;\n        }\n        while(i<n)\n        {\n            if(s[i]='1') \n            c++;\n            i++;\n        }\n        return c;\n    }\n};\n"
    },
    {
        "slug": "longest-ideal-subsequence",
        "description": "You are given a string s consisting of lowercase letters and an integer k. We call a string t ideal if the following conditions are satisfied:\n\nt is a subsequence of the string s.\nThe absolute difference in the alphabet order of every two adjacent letters in t is less than or equal to k.\n\nReturn the length of the longest ideal string.\nA subsequence is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.\nNote that the alphabet order is not cyclic. For example, the absolute difference in the alphabet order of 'a' and 'z' is 25, not 1.",
        "examples": [
            "Input: s = \"acfgbd\", k = 2\nOutput: 4\nExplanation: The longest ideal string is \"acbd\". The length of this string is 4, so 4 is returned.\nNote that \"acfgbd\" is not ideal because 'c' and 'f' have a difference of 3 in alphabet order.",
            "Input: s = \"abcd\", k = 3\nOutput: 4\nExplanation: The longest ideal string is \"abcd\". The length of this string is 4, so 4 is returned."
        ],
        "constraints": "1 <= s.length <= 105\n0 <= k <= 25\ns consists of lowercase English letters.",
        "oracle_code": "class Solution {\n\n\n   int SolveByMemo(string &s , int &k , int index , int prev , vector<vector<int>> &dp)\n   {\n       if(index == s.length())\n       return 0;\n\n       if(dp[index][prev] != -1)\n       return dp[index][prev];\n\n       int op1 = 0 + SolveByMemo(s, k , index+1 , prev , dp);\n\n       int op2 = 0 ;\n\n       if(prev == 26)\n       op2 = 1 + SolveByMemo(s, k , index+1 , s[index]-'a' , dp);\n       else if(abs(s[index]-'a' - prev) <= k)\n       op2 = 1 + SolveByMemo(s, k , index+1 , s[index]-'a' , dp);\n\n       return dp[index][prev] = max(op1 , op2);\n   }\n\n   int SolveByTab(string &s , int &k )\n   {\n        vector<vector<int>> dp(s.length()+1 , vector<int> (27, 0));\n       \n        for(int index = s.length()-1 ; index>=0 ; index--)\n        {\n            for(int prev = 0 ; prev<= 26 ; prev++)\n            {\n                int op1 = 0 + dp[index+1][prev];\n                int op2 = 0 ;\n\n               if(prev == 26)\n               op2 = 1 + dp[index+1][s[index]-'a'];\n               else if(abs(s[index]-'a' - prev) <= k)\n               op2 = 1 + dp[index+1][s[index]-'a'];\n\n               dp[index][prev] = max(op1 , op2);\n            }\n        }\n\n       return max(dp[0][s[0]-'a'] , dp[0][26]);\n   }\n\n   int SolveByTabSpaceOptimised(string &s , int &k )\n   {\n        vector<int> next(27, 0) ;\n        vector<int> curr(27, 0);\n       \n        for(int index = s.length()-1 ; index>=0 ; index--)\n        {\n            for(int prev = 0 ; prev<= 26 ; prev++)\n            {\n                int op1 = 0 + next[prev];\n                int op2 = 0 ;\n\n               if(prev == 26)\n               op2 = 1 + next[s[index]-'a'];\n               else if(abs(s[index]-'a' - prev) <= k)\n               op2 = 1 + next[s[index]-'a'];\n\n               curr[prev] = max(op1 , op2);\n            }\n            next = curr;\n        }\n\n       return max(curr[s[0]-'a'] , curr[26]);\n   }\n\npublic:\n    int longestIdealString(string s, int k) {\n        \n        // 1. Recursion + Memoization || Top Down Approach\n        // vector<vector<int>> dp(s.length() , vector<int> (27, -1));\n        // return SolveByMemo(s, k , 0 , 26, dp);\n\n        // 2. Tabulation Method || Bottom Up Approach\n        // return SolveByTab(s, k);\n\n        // 3. Space Optimisation using Tabulation\n        return SolveByTabSpaceOptimised(s , k);\n    }\n};",
        "content": "\\n# Approach\\nWe Have Use Three Different Approaches :\\n1. Recursion + Memoization \\n    TC : O(n^2) , SC : O(n)\\n2. Tabulation Method \\n    TC : O(n^2) , SC : O(n)\\n3.  Tabulatuon With SOace Optimised\\n    TC : O(n^2) , SC : O(1) \\n\\n\\n#Note\\nSC In first two methods is On) and not O(n^2) as size is fixed to 27 for each index hence it is Linear Space ,Similarly for 3rd Method we have optimised to constant space as at any instant we onlt need memory of next 27 blocks  only.\\n\\n#Hope You Liekd It and Upvote are appreciated \\n\\n# Code\\n```\\nclass Solution {\\n\\n\\n   int SolveByMemo(string &s , int &k , int index , int prev , vector<vector<int>> &dp)\\n   {\\n       if(index == s.length())\\n       return 0;\\n\\n       if(dp[index][prev] != -1)\\n       return dp[index][prev];\\n\\n       int op1 = 0 + SolveByMemo(s, k , index+1 , prev , dp);\\n\\n       int op2 = 0 ;\\n\\n       if(prev == 26)\\n       op2 = 1 + SolveByMemo(s, k , index+1 , s[index]-\\'a\\' , dp);\\n       else if(abs(s[index]-\\'a\\' - prev) <= k)\\n       op2 = 1 + SolveByMemo(s, k , index+1 , s[index]-\\'a\\' , dp);\\n\\n       return dp[index][prev] = max(op1 , op2);\\n   }\\n\\n   int SolveByTab(string &s , int &k )\\n   {\\n        vector<vector<int>> dp(s.length()+1 , vector<int> (27, 0));\\n       \\n        for(int index = s.length()-1 ; index>=0 ; index--)\\n        {\\n            for(int prev = 0 ; prev<= 26 ; prev++)\\n            {\\n                int op1 = 0 + dp[index+1][prev];\\n                int op2 = 0 ;\\n\\n               if(prev == 26)\\n               op2 = 1 + dp[index+1][s[index]-\\'a\\'];\\n               else if(abs(s[index]-\\'a\\' - prev) <= k)\\n               op2 = 1 + dp[index+1][s[index]-\\'a\\'];\\n\\n               dp[index][prev] = max(op1 , op2);\\n            }\\n        }\\n\\n       return max(dp[0][s[0]-\\'a\\'] , dp[0][26]);\\n   }\\n\\n   int SolveByTabSpaceOptimised(string &s , int &k )\\n   {\\n        vector<int> next(27, 0) ;\\n        vector<int> curr(27, 0);\\n       \\n        for(int index = s.length()-1 ; index>=0 ; index--)\\n        {\\n            for(int prev = 0 ; prev<= 26 ; prev++)\\n            {\\n                int op1 = 0 + next[prev];\\n                int op2 = 0 ;\\n\\n               if(prev == 26)\\n               op2 = 1 + next[s[index]-\\'a\\'];\\n               else if(abs(s[index]-\\'a\\' - prev) <= k)\\n               op2 = 1 + next[s[index]-\\'a\\'];\\n\\n               curr[prev] = max(op1 , op2);\\n            }\\n            next = curr;\\n        }\\n\\n       return max(curr[s[0]-\\'a\\'] , curr[26]);\\n   }\\n\\npublic:\\n    int longestIdealString(string s, int k) {\\n        \\n        // 1. Recursion + Memoization || Top Down Approach\\n        // vector<vector<int>> dp(s.length() , vector<int> (27, -1));\\n        // return SolveByMemo(s, k , 0 , 26, dp);\\n\\n        // 2. Tabulation Method || Bottom Up Approach\\n        // return SolveByTab(s, k);\\n\\n        // 3. Space Optimisation using Tabulation\\n        return SolveByTabSpaceOptimised(s , k);\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "indexing error",
            "wrong comment mark",
            "undefined keywords from other languages",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution {\n   int SolveByMemo(string &s , int &k , int index , int prev , vector<vector<int>> &dp)\n   {\n       \n       if(dp[index+1][prev] != -1)\n   string()    return dp[index+1][prev];\n\n       \n/**/fun(s, k , index+, s[index]-'a' , dp);\n       else if(abs(s[index]-'a' - prev) <= k)\n       op2 = fun(s, k , index1 , s[index]-'a' , dp);\n\n       return dp[index][prev] = max(op1 , op2);\n   }\n..fun()fun().\n\n"
    },
    {
        "slug": "reverse-odd-levels-of-binary-tree",
        "description": "Given the root of a perfect binary tree, reverse the node values at each odd level of the tree.\n\nFor example, suppose the node values at level 3 are [2,1,3,4,7,11,29,18], then it should become [18,29,11,7,4,3,1,2].\n\nReturn the root of the reversed tree.\nA binary tree is perfect if all parent nodes have two children and all leaves are on the same level.\nThe level of a node is the number of edges along the path between it and the root node.",
        "examples": [
            "Input: root = [2,3,5,8,13,21,34]\nOutput: [2,5,3,8,13,21,34]\nExplanation: \nThe tree has only one odd level.\nThe nodes at level 1 are 3, 5 respectively, which are reversed and become 5, 3.",
            "Input: root = [7,13,11]\nOutput: [7,11,13]\nExplanation: \nThe nodes at level 1 are 13, 11, which are reversed and become 11, 13.",
            "Input: root = [0,1,2,0,0,0,0,1,1,1,1,2,2,2,2]\nOutput: [0,2,1,0,0,0,0,2,2,2,2,1,1,1,1]\nExplanation: \nThe odd levels have non-zero values.\nThe nodes at level 1 were 1, 2, and are 2, 1 after the reversal.\nThe nodes at level 3 were 1, 1, 1, 1, 2, 2, 2, 2, and are 2, 2, 2, 2, 1, 1, 1, 1 after the reversal."
        ],
        "constraints": "The number of nodes in the tree is in the range [1, 214].\n0 <= Node.val <= 105\nroot is a perfect binary tree.",
        "oracle_code": "class Solution {\npublic:\n    TreeNode* reverseOddLevels(TreeNode* root) {\n        queue<TreeNode*> q;\n        q.push(root);\n        int x = 1,n,i,z;\n        vector<TreeNode*> tmp;\n        TreeNode* node;\n        while(!q.empty()){\n            tmp.clear();\n            n = q.size();\n            // cout<<n<<\" \";\n            while(n--){\n                node = q.front();q.pop();\n                // cout<<node->val<<\" \";\n                if(x==0){\n                    tmp.push_back(node);\n                }\n                if(node->left)\n                    q.push(node->left);\n                if(node->right){\n                    q.push(node->right);\n                }\n            }\n            n = tmp.size();\n            for(i = 0; i < n/2; i++){\n                z = tmp[i]->val;\n                tmp[i]->val = tmp[n-1-i]->val;\n                tmp[n-1-i]->val = z;\n            }\n            x ^= 1;\n            n = 0;\n        }\n        return root;\n    }\n};",
        "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* reverseOddLevels(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        int x = 1,n,i,z;\\n        vector<TreeNode*> tmp;\\n        TreeNode* node;\\n        while(!q.empty()){\\n            tmp.clear();\\n            n = q.size();\\n            // cout<<n<<\" \";\\n            while(n--){\\n                node = q.front();q.pop();\\n                // cout<<node->val<<\" \";\\n                if(x==0){\\n                    tmp.push_back(node);\\n                }\\n                if(node->left)\\n                    q.push(node->left);\\n                if(node->right){\\n                    q.push(node->right);\\n                }\\n            }\\n            n = tmp.size();\\n            for(i = 0; i < n/2; i++){\\n                z = tmp[i]->val;\\n                tmp[i]->val = tmp[n-1-i]->val;\\n                tmp[n-1-i]->val = z;\\n            }\\n            x ^= 1;\\n            n = 0;\\n        }\\n        return root;\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "statement separation",
            "indexing error",
            "unclosed string",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    TreeNode* reverseOddLevels(TreeNode* root) {\n        queue<TreeNode*> q;\n        q.push(root);\n        int x = 1,n,i,z;\n        vector<TreeNode*> tmp;\n        TreeNode* node;\n        TreeNode* undefinedNode;\n        while(!q.empty()){\n            tmp.clear();\n            n = q.size();\n            while(n--)node = q.front();q.pop();\n                if(x==0){\n                    tmp.push_back(undefinedNode);\n                }\n                if(node->left)\n                    q.push(node->left);\n                if(node->right){\n                    q.push(node->right);\n                }\n            n = tmp.size();\n            for(i = 0; i <= n/2; i++){\n                z = tmp[i]->val;\n                tmp[i]->val = tmp[n-1-i]->val;\n                tmp[n-1-i]->val = \"z;\n            }\n            x ^= 1;\n            n = 0;\n        }\n        return root;\n    }\n};\n"
    },
    {
        "slug": "lru-cache",
        "description": "Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.\nImplement the LRUCache class:\n\nLRUCache(int capacity) Initialize the LRU cache with positive size capacity.\nint get(int key) Return the value of the key if the key exists, otherwise return -1.\nvoid put(int key, int value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key.\n\nThe functions get and put must each run in O(1) average time complexity.",
        "examples": [
            "Input\n[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"]\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\nOutput\n[null, null, null, 1, null, -1, null, -1, 3, 4]\n\nExplanation\nLRUCache lRUCache = new LRUCache(2);\nlRUCache.put(1, 1); // cache is {1=1}\nlRUCache.put(2, 2); // cache is {1=1, 2=2}\nlRUCache.get(1);    // return 1\nlRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}\nlRUCache.get(2);    // returns -1 (not found)\nlRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}\nlRUCache.get(1);    // return -1 (not found)\nlRUCache.get(3);    // return 3\nlRUCache.get(4);    // return 4"
        ],
        "constraints": "1 <= capacity <= 3000\n0 <= key <= 104\n0 <= value <= 105\nAt most 2 * 105 calls will be made to get and put.",
        "oracle_code": "class LRUCache {\npublic:\nclass node\n{\n  public:\n  int key;\n  int val;\n  node* next;\n  node* prev;\n  node(int _key,int _val)\n  {\n    key = _key;\n    val = _val;\n  }\n};\nnode* head = new node(-1,-1);\nnode* tail = new node(-1,-1);\n\nint size;\nunordered_map<int,node*>mpp;\n    LRUCache(int capacity) {\n       size = capacity; \n       head->next = tail;\n       tail->prev = head;  \n    }\n\n    void addNode(node* newNode){\n       \n       node* temp = head->next;\n       newNode->next = temp;\n       newNode->prev = head;\n       head->next = newNode;\n       temp->prev = newNode;\n    }\n\n    void deleteNode(node* delNode){\n         \n       node* delprev = delNode->prev;\n       node* delnext = delNode->next;\n       delprev->next = delnext;\n       delnext->prev = delprev;\n    }\n    \n    int get(int _key) {\n        \n        if(mpp.count(_key))\n        {\n          node* nde = mpp[_key];\n          int curr = nde->val;\n          mpp.erase(_key);\n          deleteNode(nde);\n          addNode(nde);\n          mpp[_key] = head->next;\n          return curr;\n        }\n        return -1;\n    }\n    \n    void put(int _key, int value) {\n        \n        if(mpp.count(_key))\n        {\n           node* nde = mpp[_key];\n           mpp.erase(_key);\n           deleteNode(nde);\n        }\n        if(mpp.size()==size)\n        {\n           mpp.erase(tail->prev->key);\n           deleteNode(tail->prev);\n        }\n        addNode(new node(_key,value));\n        mpp[_key] = head->next;\n    }\n};",
        "content": "# PLEASE DO UPVOTE!!!!!\\n\\n**CONNECT WITH ME ON LINKEDIN :  https://www.linkedin.com/in/md-kamran-55b98521a/**\\n\\n## INTUITION\\nTo Implement LRU(Least recently used), we need to have a track of the usage of the keys, in the order of there usage, as we have a limited capacity we cant extend our capacity beyond \"capacity\", so we always we will take out those values which has\\'nt been acccess in the recent time.So, we have to think of something that can kind of sort our keys according to usage on the go, the best Data Structure for this purpose is Doubly linked List.\\n                             A Doubly linked list will have a Head node as well as a tail node, and whenever a key is used we will place it just next to the head node,in this fashions, the one\\'s which are closer to head are the most recently used ones, and as we go closer to the tail node, those are the less recently used ones while the node just previous to tail is the \"LEAST RECENTLY USED\". \\nSo whenever we add a key or use a key(get()), we will move it right after the head node, and whenever we call the (put() function), if size if greater we have to delete the LRU node, if key is not present, (if present then too we will delete that node so as to update the value and still move it right after head node), and place new node right after head node.                        \\n\\n\\n**Ask Furthur Doubts in the Comment Section**\\n# Code\\n```\\nclass LRUCache {\\npublic:\\nclass node\\n{\\n  public:\\n  int key;\\n  int val;\\n  node* next;\\n  node* prev;\\n  node(int _key,int _val)\\n  {\\n    key = _key;\\n    val = _val;\\n  }\\n};\\nnode* head = new node(-1,-1);\\nnode* tail = new node(-1,-1);\\n\\nint size;\\nunordered_map<int,node*>mpp;\\n    LRUCache(int capacity) {\\n       size = capacity; \\n       head->next = tail;\\n       tail->prev = head;  \\n    }\\n\\n    void addNode(node* newNode){\\n       \\n       node* temp = head->next;\\n       newNode->next = temp;\\n       newNode->prev = head;\\n       head->next = newNode;\\n       temp->prev = newNode;\\n    }\\n\\n    void deleteNode(node* delNode){\\n         \\n       node* delprev = delNode->prev;\\n       node* delnext = delNode->next;\\n       delprev->next = delnext;\\n       delnext->prev = delprev;\\n    }\\n    \\n    int get(int _key) {\\n        \\n        if(mpp.count(_key))\\n        {\\n          node* nde = mpp[_key];\\n          int curr = nde->val;\\n          mpp.erase(_key);\\n          deleteNode(nde);\\n          addNode(nde);\\n          mpp[_key] = head->next;\\n          return curr;\\n        }\\n        return -1;\\n    }\\n    \\n    void put(int _key, int value) {\\n        \\n        if(mpp.count(_key))\\n        {\\n           node* nde = mpp[_key];\\n           mpp.erase(_key);\\n           deleteNode(nde);\\n        }\\n        if(mpp.size()==size)\\n        {\\n           mpp.erase(tail->prev->key);\\n           deleteNode(tail->prev);\\n        }\\n        addNode(new node(_key,value));\\n        mpp[_key] = head->next;\\n    }\\n};\\n\\n```\\n![b62ab1be-232a-438f-9524-7d8ca4dbd5fe_1675328166.1161866.png](https://assets.leetcode.com/users/images/8d5343b1-0eb4-4111-a914-40ce968fd034_1675389764.2273676.png)",
        "level": "medium",
        "type": [
            "undefined keywords from other languages",
            "variable value error",
            "colon missing",
            "undefined objects"
        ],
        "buggy_code": "\nclass LRUCache {\npublic:\nclass node\n{\n  public:\n  int key;\n  int val;\n  node* next;\n  node* prev;\n  node(int _key,int _val)\n  {\n    key = _key;\n    val = _val;\n  }\n};\nnode* head = nullptr;\nnode* tail = nullptr;\n\nint size;\nunordered_map<int,node*>mpp;\n    LRUCache(int capacity) {\n       size = capacity; \n       head->next = tail;\n       tail->prev = head;  \n    }\n\n    void addNode(node* newNode){\n       \n       node* temp = head->next;\n       newNode->next = temp;\n       newNode->prev = head;\n       head->next = newNode;\n    }\n\n    void deleteNode(node* delNode){\n         \n       node* delprev = delNode->prev;\n       node* delnext = delNode->next;\n       delprev->next = delnext;\n       delnext->prev = delprev;\n    }\n    \n    int get(int _key) {\n        \n        if(mpp.count(_key))\n        {\n          node* nde = mpp[_key];\n          int curr = nde->val;\n          mpp.erase(_key);\n          deleteNode(nde);\n          addNode(nde)\n          mpp[_key] = head->next;\n          return curr;\n        }\n        return -1;\n    }\n    \n    void put(int _key, int value) {\n        \n        if(mpp.count(_key))\n        {\n           node* nde = mpp[_key];\n           mpp.erase(_key);\n           deleteNode(nde);\n        }\n        if(mpp.size()==size)\n        {\n           mpp.erase(tail->prev->key);\n           deleteNode(tail->prev);\n        }\n        addNode(new node(_key,var));\n        mpp[_key] = tail->next;\n    }\n};\n"
    },
    {
        "slug": "calculate-money-in-leetcode-bank",
        "description": "Hercy wants to save money for his first car. He puts money in the Leetcode\u00a0bank every day.\nHe starts by putting in $1 on Monday, the first day. Every day from Tuesday to Sunday, he will put in $1 more than the day before. On every subsequent Monday, he will put in $1 more than the previous Monday. \nGiven n, return the total amount of money he will have in the Leetcode bank at the end of the nth day.",
        "examples": [
            "Input: n = 4\nOutput: 10\nExplanation:\u00a0After the 4th day, the total is 1 + 2 + 3 + 4 = 10.",
            "Input: n = 10\nOutput: 37\nExplanation:\u00a0After the 10th day, the total is (1 + 2 + 3 + 4 + 5 + 6 + 7) + (2 + 3 + 4) = 37. Notice that on the 2nd Monday, Hercy only puts in $2.",
            "Input: n = 20\nOutput: 96\nExplanation:\u00a0After the 20th day, the total is (1 + 2 + 3 + 4 + 5 + 6 + 7) + (2 + 3 + 4 + 5 + 6 + 7 + 8) + (3 + 4 + 5 + 6 + 7 + 8) = 96."
        ],
        "constraints": "1 <= n <= 1000",
        "oracle_code": "class Solution {\npublic:\n    int Rem(int a)\n    {\n        return (a * (a+1) )/2;\n    }\n    int totalMoney(int n) {\n        int ans = 0,dif=28;\n        int a = 0;\n\n        a = n/7;\n        \n        for(int i=0;i<a;i++)\n        {\n            ans+=dif;\n            dif+=7;\n        }\n\n        int b = n%7;\n        int ad = Rem(b);\n        ad+= a*b;\n\n        ans+=ad;\n\n\n        return ans;\n    }\n};",
        "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBasically This Question Try to Test Pattern Finding Skill.\\nThis Problem has 2 things two Consider.\\n1) Firstly We Divide n by 7 ( as Week is of  Days ) So that We get Value Which Indicates that Total Number of Weeks need to Consider in Final Answer.\\n\\n2) Now We Do n%7 which gives answer between 0 to 6 which indicates Remaining Days after Step 1. So We need To calculate Sum of Savings for That n%7 days Separately.\\n\\nAs Sum of\\n \\nWeek 1 : 28\\nWeek 2 : 35\\nWeek 3 : 42\\nWeek 4 : 49\\nWeek 5 : 56\\nand so on...\\n Indicates Pattern that We only need How many Whole Week Need to Consider in answer and that We got in Step 1.\\nSo add 28+35+.. upto n/7 terms\\n\\n\\nNow , In Step 2 , We need to consider Saving For Remainig Days which is n%7.\\nSuppose Rem Day is B then B*(B+1)/2 Will be Saving at B day of Week 1.We know that we have n/7 week so n/7*b will be added to B*(B+1)/2\\n.This is Final answer of Step 2.\\n\\n3) Add Both answer of Step 1 and Step 2.\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int Rem(int a)\\n    {\\n        return (a * (a+1) )/2;\\n    }\\n    int totalMoney(int n) {\\n        int ans = 0,dif=28;\\n        int a = 0;\\n\\n        a = n/7;\\n        \\n        for(int i=0;i<a;i++)\\n        {\\n            ans+=dif;\\n            dif+=7;\\n        }\\n\\n        int b = n%7;\\n        int ad = Rem(b);\\n        ad+= a*b;\\n\\n        ans+=ad;\\n\\n\\n        return ans;\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "statement separation",
            "operation error",
            "undefined methods",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution {\nprivate:\n    int* num;\n\npublic:\n\n    Solution() {\n        num = new int[10];\n    }\n    \n    ~Solution() {\n        delete[] num;\n    }\n\n    int Rem(int a) num[];\n    int totalMoney(int n) {\n        int ans = 0,dif=28;\n        int a = 0;\n        \n        num[5] = n/7;\n\n        for(int i=0;i<num[5];i++); \n        {\n            ans+=dif;\n            dif+=7;\n        }\n\n        int b = n%7;\n        int ad = Rem(b);\n        ad+= num[5]*b;\n\n        ans-=ad; \n        return ans;\n    }\n};\n"
    },
    {
        "slug": "magical-string",
        "description": "A magical string s consists of only '1' and '2' and obeys the following rules:\n\nThe string s is magical because concatenating the number of contiguous occurrences of characters '1' and '2' generates the string s itself.\n\nThe first few elements of s is s = \"1221121221221121122\u2026\u2026\". If we group the consecutive 1's and 2's in s, it will be \"1 22 11 2 1 22 1 22 11 2 11 22 ......\" and the occurrences of 1's or 2's in each group are \"1 2 2 1 1 2 1 2 2 1 2 2 ......\". You can see that the occurrence sequence is s itself.\nGiven an integer n, return the number of 1's in the first n number in the magical string s.",
        "examples": [
            "Input: n = 6\nOutput: 3\nExplanation: The first 6 elements of magical string s is \"122112\" and it contains three 1's, so return 3.",
            "Input: n = 1\nOutput: 1"
        ],
        "constraints": "1 <= n <= 105",
        "oracle_code": "class Solution {\npublic:\n    int magicalString(int n) {\n        string s=\"\";\n        s+=\"122\";\n        int i=2,c=1;\n        while(i<n && s.size()<n)\n        {\n            if(s[i]=='1')\n            {\n                c++;\n                if(s[s.size()-1]=='2')\n                s+='1';\n                else\n                {\n                    s+='2';\n                }\n            }\n            else\n            {\n                if(s[s.size()-1]=='2')\n                s+=\"11\";\n                else\n                {\n                    s+=\"22\";\n                }\n            }\n            i++;\n        }\n        while(i<n)\n        {\n            if(s[i]=='1')\n            c++;\n            i++;\n        }\n        return c;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIntution was to find the repeating part first, then i saw the pattern carefully and tried to make it.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can make the string using first three digits only \"122\",my intution is to make whole string upto length n,and count ones side by side. Also to count the remaining 1\\'s after while loop breaks\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int magicalString(int n) {\\n        string s=\"\";\\n        s+=\"122\";\\n        int i=2,c=1;\\n        while(i<n && s.size()<n)\\n        {\\n            if(s[i]==\\'1\\')\\n            {\\n                c++;\\n                if(s[s.size()-1]==\\'2\\')\\n                s+=\\'1\\';\\n                else\\n                {\\n                    s+=\\'2\\';\\n                }\\n            }\\n            else\\n            {\\n                if(s[s.size()-1]==\\'2\\')\\n                s+=\"11\";\\n                else\\n                {\\n                    s+=\"22\";\\n                }\\n            }\\n            i++;\\n        }\\n        while(i<n)\\n        {\\n            if(s[i]==\\'1\\')\\n            c++;\\n            i++;\\n        }\\n        return c;\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "indexing error",
            "unclosed string",
            "undefined keywords from other languages",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    int magicalString(int n) {\n        str s=\"\";\n        s+=\"122\";\n        int i=2,c=1;\n        while(i<n && s.size()<n\n        {\n            if(s[i]=='1')\n            {\n                c++;\n                if(s[s.size()]=='2')\n                s+='1';\n                else\n                {\n                    s+='2';\n                }\n            }\n            else\n            {\n                if(s[s.size()]=='2')\n                s+=\"11\";\n                else\n                {\n                    s+='22'; \n                }\n            }\n            i++;\n        }\n        while(i<n)\n        {\n            if(s[i]=='1')\n            c++;\n            i++;\n        }\n        return c;\n    }\n};\n"
    },
    {
        "slug": "most-beautiful-item-for-each-query",
        "description": "You are given a 2D integer array items where items[i] = [pricei, beautyi] denotes the price and beauty of an item respectively.\nYou are also given a 0-indexed integer array queries. For each queries[j], you want to determine the maximum beauty of an item whose price is less than or equal to queries[j]. If no such item exists, then the answer to this query is 0.\nReturn an array answer of the same length as queries where answer[j] is the answer to the jth query.",
        "examples": [
            "Input: items = [[1,2],[3,2],[2,4],[5,6],[3,5]], queries = [1,2,3,4,5,6]\nOutput: [2,4,5,5,6,6]\nExplanation:\n- For queries[0]=1, [1,2] is the only item which has price <= 1. Hence, the answer for this query is 2.\n- For queries[1]=2, the items which can be considered are [1,2] and [2,4]. \n  The maximum beauty among them is 4.\n- For queries[2]=3 and queries[3]=4, the items which can be considered are [1,2], [3,2], [2,4], and [3,5].\n  The maximum beauty among them is 5.\n- For queries[4]=5 and queries[5]=6, all items can be considered.\n  Hence, the answer for them is the maximum beauty of all items, i.e., 6.",
            "Input: items = [[1,2],[1,2],[1,3],[1,4]], queries = [1]\nOutput: [4]\nExplanation: \nThe price of every item is equal to 1, so we choose the item with the maximum beauty 4. \nNote that multiple items can have the same price and/or beauty.",
            "Input: items = [[10,1000]], queries = [5]\nOutput: [0]\nExplanation:\nNo item has a price less than or equal to 5, so no item can be chosen.\nHence, the answer to the query is 0."
        ],
        "constraints": "1 <= items.length, queries.length <= 105\nitems[i].length == 2\n1 <= pricei, beautyi, queries[j] <= 109",
        "oracle_code": "class Solution {\n    int bs(vector<vector<int>>& items, int t, vector<int> &beauty) {\n        int ans = 0, s = 0, e = items.size() - 1;\n        while(s <= e) {\n            int m = (s + e) / 2;\n            if(items[m][0] <= t) ans = beauty[m], s = m + 1;\n            else e = m - 1;\n        }\n        return ans;\n    }\n\npublic:\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\n        sort(items.begin(), items.end());\n        vector<int> ans, beauty(items.size(), items[0][1]);\n\n        for(int i=1; i<items.size(); i++) beauty[i] = max(beauty[i - 1], items[i][1]);\n\n        for(int i : queries) ans.push_back(bs(items, i, beauty));\n        return ans;\n    }\n};",
        "content": "\\n# C++\\n```\\nclass Solution {\\n    int bs(vector<vector<int>>& items, int t, vector<int> &beauty) {\\n        int ans = 0, s = 0, e = items.size() - 1;\\n        while(s <= e) {\\n            int m = (s + e) / 2;\\n            if(items[m][0] <= t) ans = beauty[m], s = m + 1;\\n            else e = m - 1;\\n        }\\n        return ans;\\n    }\\n\\npublic:\\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\\n        sort(items.begin(), items.end());\\n        vector<int> ans, beauty(items.size(), items[0][1]);\\n\\n        for(int i=1; i<items.size(); i++) beauty[i] = max(beauty[i - 1], items[i][1]);\\n\\n        for(int i : queries) ans.push_back(bs(items, i, beauty));\\n        return ans;\\n    }\\n};\\n```\\n\\n# Python\\n```\\nclass Solution(object):\\n    def maximumBeauty(self, items, queries):\\n        items.sort()\\n        ans, beauty = [], [items[0][1]] * len(items)\\n        for i in range(1, len(items)): beauty[i] = max(beauty[i - 1], items[i][1])\\n\\n        def bs(t):\\n            ans, s, e = 0, 0, len(items) - 1\\n            while s <= e:\\n                m = (s + e) // 2\\n                if items[m][0] <= t:\\n                    ans = beauty[m]\\n                    s = m + 1\\n                else: e = m - 1\\n            return ans\\n\\n        for i in queries: ans.append(bs(i))\\n        return ans\\n```\\n",
        "level": "medium",
        "type": [
            "indexing error",
            "wrong comment mark",
            "conditional statement error",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution {\n    int bs(vector<vector<Integer>>& items, int t, vector<int> &beauty) {\n        int ans = 0, s = 0, e = items.size();\n        while(s <= e) {\n\n            if(items[m][0] <= t) ans = beauty[m], s = m + 1;\n            else s = m + 1; \n        }\n        return ans;\n    }\n\npublic:\n    vector<int> maximumBeauty(vector<vector<Integer>>& items, vector<int>& queries) {\n        sort(items.begin(), items.end());\n        vector<int> ans, beauty(items.size(), items[0][1]);\n\n        for(int i=1; i<items.size(); i++) beauty[i] = max(beauty[i - 1], items[i][1]);\n\n        for(int i : queries) ans.push_back(bs(items, i, beauty));\n        return ans;\n    }\n};\n"
    },
    {
        "slug": "valid-anagram",
        "description": "Given two strings s and t, return true if t is an anagram of s, and false otherwise.\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.",
        "examples": [
            "Input: s = \"anagram\", t = \"nagaram\"\nOutput: true",
            "Input: s = \"rat\", t = \"car\"\nOutput: false"
        ],
        "constraints": "1 <= s.length, t.length <= 5 * 104\ns and t consist of lowercase English letters.",
        "oracle_code": "class Solution {\npublic:\n    bool isAnagram(string s, string t) {\n        if(s.length()!=t.length())\n            return false;\n        vector<int> freq(26, 0);\n        for(int i =0; i<s.length(); i++){\n            freq[s[i]-'a']++;\n            freq[t[i]-'a']--;\n        }\n        for(int i =0; i<freq.size(); i++){\n            if(freq[i]!=0)\n                return false;\n        }\n        return true;\n    }\n};",
        "content": "# Intuition\\nTo solve this problem we will count occurence of each character in both strings and if they are same then both strings are anagram of each other.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nWe can use vector of length 26 to track the occurences of character. \\nIf the size of both string is different then they can\\'t be anagram of each other, so we are checking this first.We loop through each character in both strings and increment the frequency of the corresponding letter in s and decrement the frequency of the corresponding letter in t.\\nThen we loop through freq array if all the elements are 0, if all the elements are 0 this means the two strings are anagram and if not then these things are not anagram of each othe.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n), n is the size of s or t string.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isAnagram(string s, string t) {\\n        if(s.length()!=t.length())\\n            return false;\\n        vector<int> freq(26, 0);\\n        for(int i =0; i<s.length(); i++){\\n            freq[s[i]-\\'a\\']++;\\n            freq[t[i]-\\'a\\']--;\\n        }\\n        for(int i =0; i<freq.size(); i++){\\n            if(freq[i]!=0)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "statement separation",
            "indexing error",
            "operation error",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    bool isAnagram(string s, string t) {\n        if(s.length()!=t.length())\n            return false;\n        vector<int> freq(26, 0);\n        for(int i =0; i<=s.length(); i++)\n            freq[s[i]-'a']++;\n            freq[t[i]-'a']++;\n        for(int i =0; i<freq.size(); i++)\n            if(freq[i]!=0)\n                return false;\n\n        return true;\n    }\n'};\n\n\n"
    },
    {
        "slug": "longest-ideal-subsequence",
        "description": "You are given a string s consisting of lowercase letters and an integer k. We call a string t ideal if the following conditions are satisfied:\n\nt is a subsequence of the string s.\nThe absolute difference in the alphabet order of every two adjacent letters in t is less than or equal to k.\n\nReturn the length of the longest ideal string.\nA subsequence is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.\nNote that the alphabet order is not cyclic. For example, the absolute difference in the alphabet order of 'a' and 'z' is 25, not 1.",
        "examples": [
            "Input: s = \"acfgbd\", k = 2\nOutput: 4\nExplanation: The longest ideal string is \"acbd\". The length of this string is 4, so 4 is returned.\nNote that \"acfgbd\" is not ideal because 'c' and 'f' have a difference of 3 in alphabet order.",
            "Input: s = \"abcd\", k = 3\nOutput: 4\nExplanation: The longest ideal string is \"abcd\". The length of this string is 4, so 4 is returned."
        ],
        "constraints": "1 <= s.length <= 105\n0 <= k <= 25\ns consists of lowercase English letters.",
        "oracle_code": "class Solution {\n\n\n   int SolveByMemo(string &s , int &k , int index , int prev , vector<vector<int>> &dp)\n   {\n       if(index == s.length())\n       return 0;\n\n       if(dp[index][prev] != -1)\n       return dp[index][prev];\n\n       int op1 = 0 + SolveByMemo(s, k , index+1 , prev , dp);\n\n       int op2 = 0 ;\n\n       if(prev == 26)\n       op2 = 1 + SolveByMemo(s, k , index+1 , s[index]-'a' , dp);\n       else if(abs(s[index]-'a' - prev) <= k)\n       op2 = 1 + SolveByMemo(s, k , index+1 , s[index]-'a' , dp);\n\n       return dp[index][prev] = max(op1 , op2);\n   }\n\n   int SolveByTab(string &s , int &k )\n   {\n        vector<vector<int>> dp(s.length()+1 , vector<int> (27, 0));\n       \n        for(int index = s.length()-1 ; index>=0 ; index--)\n        {\n            for(int prev = 0 ; prev<= 26 ; prev++)\n            {\n                int op1 = 0 + dp[index+1][prev];\n                int op2 = 0 ;\n\n               if(prev == 26)\n               op2 = 1 + dp[index+1][s[index]-'a'];\n               else if(abs(s[index]-'a' - prev) <= k)\n               op2 = 1 + dp[index+1][s[index]-'a'];\n\n               dp[index][prev] = max(op1 , op2);\n            }\n        }\n\n       return max(dp[0][s[0]-'a'] , dp[0][26]);\n   }\n\n   int SolveByTabSpaceOptimised(string &s , int &k )\n   {\n        vector<int> next(27, 0) ;\n        vector<int> curr(27, 0);\n       \n        for(int index = s.length()-1 ; index>=0 ; index--)\n        {\n            for(int prev = 0 ; prev<= 26 ; prev++)\n            {\n                int op1 = 0 + next[prev];\n                int op2 = 0 ;\n\n               if(prev == 26)\n               op2 = 1 + next[s[index]-'a'];\n               else if(abs(s[index]-'a' - prev) <= k)\n               op2 = 1 + next[s[index]-'a'];\n\n               curr[prev] = max(op1 , op2);\n            }\n            next = curr;\n        }\n\n       return max(curr[s[0]-'a'] , curr[26]);\n   }\n\npublic:\n    int longestIdealString(string s, int k) {\n        \n        // 1. Recursion + Memoization || Top Down Approach\n        // vector<vector<int>> dp(s.length() , vector<int> (27, -1));\n        // return SolveByMemo(s, k , 0 , 26, dp);\n\n        // 2. Tabulation Method || Bottom Up Approach\n        // return SolveByTab(s, k);\n\n        // 3. Space Optimisation using Tabulation\n        return SolveByTabSpaceOptimised(s , k);\n    }\n};",
        "content": "\\n# Approach\\nWe Have Use Three Different Approaches :\\n1. Recursion + Memoization \\n    TC : O(n^2) , SC : O(n)\\n2. Tabulation Method \\n    TC : O(n^2) , SC : O(n)\\n3.  Tabulatuon With SOace Optimised\\n    TC : O(n^2) , SC : O(1) \\n\\n\\n#Note\\nSC In first two methods is On) and not O(n^2) as size is fixed to 27 for each index hence it is Linear Space ,Similarly for 3rd Method we have optimised to constant space as at any instant we onlt need memory of next 27 blocks  only.\\n\\n#Hope You Liekd It and Upvote are appreciated \\n\\n# Code\\n```\\nclass Solution {\\n\\n\\n   int SolveByMemo(string &s , int &k , int index , int prev , vector<vector<int>> &dp)\\n   {\\n       if(index == s.length())\\n       return 0;\\n\\n       if(dp[index][prev] != -1)\\n       return dp[index][prev];\\n\\n       int op1 = 0 + SolveByMemo(s, k , index+1 , prev , dp);\\n\\n       int op2 = 0 ;\\n\\n       if(prev == 26)\\n       op2 = 1 + SolveByMemo(s, k , index+1 , s[index]-\\'a\\' , dp);\\n       else if(abs(s[index]-\\'a\\' - prev) <= k)\\n       op2 = 1 + SolveByMemo(s, k , index+1 , s[index]-\\'a\\' , dp);\\n\\n       return dp[index][prev] = max(op1 , op2);\\n   }\\n\\n   int SolveByTab(string &s , int &k )\\n   {\\n        vector<vector<int>> dp(s.length()+1 , vector<int> (27, 0));\\n       \\n        for(int index = s.length()-1 ; index>=0 ; index--)\\n        {\\n            for(int prev = 0 ; prev<= 26 ; prev++)\\n            {\\n                int op1 = 0 + dp[index+1][prev];\\n                int op2 = 0 ;\\n\\n               if(prev == 26)\\n               op2 = 1 + dp[index+1][s[index]-\\'a\\'];\\n               else if(abs(s[index]-\\'a\\' - prev) <= k)\\n               op2 = 1 + dp[index+1][s[index]-\\'a\\'];\\n\\n               dp[index][prev] = max(op1 , op2);\\n            }\\n        }\\n\\n       return max(dp[0][s[0]-\\'a\\'] , dp[0][26]);\\n   }\\n\\n   int SolveByTabSpaceOptimised(string &s , int &k )\\n   {\\n        vector<int> next(27, 0) ;\\n        vector<int> curr(27, 0);\\n       \\n        for(int index = s.length()-1 ; index>=0 ; index--)\\n        {\\n            for(int prev = 0 ; prev<= 26 ; prev++)\\n            {\\n                int op1 = 0 + next[prev];\\n                int op2 = 0 ;\\n\\n               if(prev == 26)\\n               op2 = 1 + next[s[index]-\\'a\\'];\\n               else if(abs(s[index]-\\'a\\' - prev) <= k)\\n               op2 = 1 + next[s[index]-\\'a\\'];\\n\\n               curr[prev] = max(op1 , op2);\\n            }\\n            next = curr;\\n        }\\n\\n       return max(curr[s[0]-\\'a\\'] , curr[26]);\\n   }\\n\\npublic:\\n    int longestIdealString(string s, int k) {\\n        \\n        // 1. Recursion + Memoization || Top Down Approach\\n        // vector<vector<int>> dp(s.length() , vector<int> (27, -1));\\n        // return SolveByMemo(s, k , 0 , 26, dp);\\n\\n        // 2. Tabulation Method || Bottom Up Approach\\n        // return SolveByTab(s, k);\\n\\n        // 3. Space Optimisation using Tabulation\\n        return SolveByTabSpaceOptimised(s , k);\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "indexing error",
            "unclosed string",
            "undefined keywords from other languages",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution {\n\n   int SolveByMemo(string &s , int &k , int index , int prev , vector<vector<int>> &dp)\n   {\n       \n       if(dp[index+1][prev] != -1)\n   string()    return dp[index+1][prev];\n\n       \nfun(s, k , index+, s[index]-'a' , dp);\n       else if(abs(s[index]-'a' - prev) <= k)\n       op2 = fun(s, k , index1 , s[index]-'a' , dp);\n\n       return dp[index][prev] = max(op1 , op2);\n   }\n..fun()fun().\n\n"
    },
    {
        "slug": "check-if-there-is-a-valid-path-in-a-grid",
        "description": "You are given an m x n grid. Each cell of grid represents a street. The street of grid[i][j] can be:\n\n1 which means a street connecting the left cell and the right cell.\n2 which means a street connecting the upper cell and the lower cell.\n3 which means a street connecting the left cell and the lower cell.\n4 which means a street connecting the right cell and the lower cell.\n5 which means a street connecting the left cell and the upper cell.\n6 which means a street connecting the right cell and the upper cell.\n\n\nYou will initially start at the street of the upper-left cell (0, 0). A valid path in the grid is a path that starts from the upper left cell (0, 0) and ends at the bottom-right cell (m - 1, n - 1). The path should only follow the streets.\nNotice that you are not allowed to change any street.\nReturn true if there is a valid path in the grid or false otherwise.",
        "examples": [
            "Input: grid = [[2,4,3],[6,5,2]]\nOutput: true\nExplanation: As shown you can start at cell (0, 0) and visit all the cells of the grid to reach (m - 1, n - 1).",
            "Input: grid = [[1,2,1],[1,2,1]]\nOutput: false\nExplanation: As shown you the street at cell (0, 0) is not connected with any street of any other cell and you will get stuck at cell (0, 0)",
            "Input: grid = [[1,1,2]]\nOutput: false\nExplanation: You will get stuck at cell (0, 1) and you cannot reach cell (0, 2)."
        ],
        "constraints": "m == grid.length\nn == grid[i].length\n1 <= m, n <= 300\n1 <= grid[i][j] <= 6",
        "oracle_code": "class DisjointSet{\npublic:\n    vector<int>par,size;\n    DisjointSet(int n){\n        par.resize(n+1);\n        size.resize(n+1,1);\n        for(int i=0; i<=n; i++){\n            par[i] = i;\n        }\n    }\n    int findpar(int u){\n        if(u == par[u]) return u;\n        return par[u] = findpar(par[u]);\n    }\n\n    void unionBySize(int u, int v){\n        u = findpar(u);\n        v = findpar(v);\n\n        if(u == v) return;\n\n        if(size[u] >= size[v]){\n            par[v] = u;\n            size[u] += size[v];\n        }\n        else{\n            par[u] = v;\n            size[v] += size[u];\n        }\n    }\n    \n};\nclass Solution {\npublic:\n    bool hasValidPath(vector<vector<int>>& grid) {\n        int n = grid.size();\n        int m = grid[0].size();\n        DisjointSet ds(n*m);\n        for(int i=0; i<n; i++){\n            for(int j=0; j<m; j++){\n                int p = i * m + j;\n                int p1 = (i-1)*m + j;  // 1\n                int p2 = (i+1)*m + j;  // 1\n                int p3 = i*m + (j+1);  // 2\n                int p4 = i*m + (j-1);  // 2\n\n                if(grid[i][j] == 1){\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\n                        ds.unionBySize(p,p3);\n                    }\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\n                        ds.unionBySize(p,p4);\n                    }\n                }\n                else if(grid[i][j] == 2){\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\n                        ds.unionBySize(p,p2);\n                    }\n\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\n                        ds.unionBySize(p,p1);\n                    }\n                }\n                else if(grid[i][j] == 3){\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\n                        ds.unionBySize(p,p4);\n                    }\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\n                        ds.unionBySize(p,p2);\n                    }\n                }\n                else if(grid[i][j] == 4){\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\n                        ds.unionBySize(p,p3);\n                    }\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\n                        ds.unionBySize(p,p2);\n                    }\n                }\n                else if(grid[i][j] == 5){\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\n                        ds.unionBySize(p,p1);\n                    }\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\n                        ds.unionBySize(p,p4);\n                    }\n                }\n                else if(grid[i][j] == 6){\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\n                        ds.unionBySize(p,p1);\n                    }\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\n                        ds.unionBySize(p,p3);\n                    }\n                }\n            }\n        }\n        return ds.findpar(0) == ds.findpar(n*m-1);\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass DisjointSet{\\npublic:\\n    vector<int>par,size;\\n    DisjointSet(int n){\\n        par.resize(n+1);\\n        size.resize(n+1,1);\\n        for(int i=0; i<=n; i++){\\n            par[i] = i;\\n        }\\n    }\\n    int findpar(int u){\\n        if(u == par[u]) return u;\\n        return par[u] = findpar(par[u]);\\n    }\\n\\n    void unionBySize(int u, int v){\\n        u = findpar(u);\\n        v = findpar(v);\\n\\n        if(u == v) return;\\n\\n        if(size[u] >= size[v]){\\n            par[v] = u;\\n            size[u] += size[v];\\n        }\\n        else{\\n            par[u] = v;\\n            size[v] += size[u];\\n        }\\n    }\\n    \\n};\\nclass Solution {\\npublic:\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        DisjointSet ds(n*m);\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                int p = i * m + j;\\n                int p1 = (i-1)*m + j;  // 1\\n                int p2 = (i+1)*m + j;  // 1\\n                int p3 = i*m + (j+1);  // 2\\n                int p4 = i*m + (j-1);  // 2\\n\\n                if(grid[i][j] == 1){\\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\\n                        ds.unionBySize(p,p3);\\n                    }\\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\\n                        ds.unionBySize(p,p4);\\n                    }\\n                }\\n                else if(grid[i][j] == 2){\\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\\n                        ds.unionBySize(p,p2);\\n                    }\\n\\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\\n                        ds.unionBySize(p,p1);\\n                    }\\n                }\\n                else if(grid[i][j] == 3){\\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\\n                        ds.unionBySize(p,p4);\\n                    }\\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\\n                        ds.unionBySize(p,p2);\\n                    }\\n                }\\n                else if(grid[i][j] == 4){\\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\\n                        ds.unionBySize(p,p3);\\n                    }\\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\\n                        ds.unionBySize(p,p2);\\n                    }\\n                }\\n                else if(grid[i][j] == 5){\\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\\n                        ds.unionBySize(p,p1);\\n                    }\\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\\n                        ds.unionBySize(p,p4);\\n                    }\\n                }\\n                else if(grid[i][j] == 6){\\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\\n                        ds.unionBySize(p,p1);\\n                    }\\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\\n                        ds.unionBySize(p,p3);\\n                    }\\n                }\\n            }\\n        }\\n        return ds.findpar(0) == ds.findpar(n*m-1);\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "== and = confusion",
            "wrong comment mark",
            "variable value error",
            "parentheses mismatch"
        ],
        "buggy_code": "\n\nclass DisjointSet{\npublic:\n    vector<int>par,size;\n    DisjointSet(int n){\n        par.resize(n+1);\n        size.resize(n+1,1);\n        for(int i=0; i<=n; i++){\n            par[i] == i;\n        }\n    }\n    int findpar(int u){\n        return par[u] = findpar(par[u]); \n    }\n\n    void unionBySize(int u, int v){\n        u == findpar(u);\n        v == findpar(v);\n\n        if(u == v) return;\n\n        if(size[u] >= size[v]){\n            par[v] = v;\n            size[u] += size[v];\n        }\n        else{\n            par[u] = u;\n            size[v] += size[u];\n        }\n    }\n    \n};\nclass Solution {\npublic:\n    bool hasValidPath(vector<vector<int>>& grid) {\n        int n = grid.size();\n        int m = grid[0].size();\n        DisjointSet ds(n*m);\n        for(int i=0; i<n; i++){\n            for(int j=0; j<m; j++){\n                int p = i * m + j;\n                int p1 = (i-1)*m + j;  // 1\n                int p2 = (i+1)*m + j;  // 1\n                int p3 = i*m + (j+1);  // 2\n                int p4 = i*m + (j-1);  // 2\n\n                if(grid[i][j] == 1){\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\n                        ds.unionBySize(p,p3);\n                    }\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\n                        ds.unionBySize(p,p4);\n                    }\n                }\n                else if(grid[i][j] == 2){\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\n                        ds.unionBySize(p,p2);\n                    }\n\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\n                        ds.unionBySize(p,p1);\n                    }\n                }\n                else if(grid[i][j] == 3){\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\n                        ds.unionBySize(p,p4);\n                    }\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\n                        ds.unionBySize(p,p2);\n                    }\n                }\n                else if(grid[i][j] == 4){\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\n                        ds.unionBySize(p,p3);\n                    }\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\n                        ds.unionBySize(p,p2);\n                    }\n                }\n                else if(grid[i][j] == 5){\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\n                        ds.unionBySize(p,p1);\n                    }\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\n                        ds.unionBySize(p,p4);\n                    }\n                }\n                else if(grid[i][j] == 6){\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\n                        ds.unionBySize(p,p1);\n                    }\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\n                        ds.unionBySize(p,p3);\n                    }\n                }\n            }\n        }\n        return ds.findpar(0) == ds.findpar(n*m-1);\n    }\n};\n\n"
    },
    {
        "slug": "longest-ideal-subsequence",
        "description": "You are given a string s consisting of lowercase letters and an integer k. We call a string t ideal if the following conditions are satisfied:\n\nt is a subsequence of the string s.\nThe absolute difference in the alphabet order of every two adjacent letters in t is less than or equal to k.\n\nReturn the length of the longest ideal string.\nA subsequence is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.\nNote that the alphabet order is not cyclic. For example, the absolute difference in the alphabet order of 'a' and 'z' is 25, not 1.",
        "examples": [
            "Input: s = \"acfgbd\", k = 2\nOutput: 4\nExplanation: The longest ideal string is \"acbd\". The length of this string is 4, so 4 is returned.\nNote that \"acfgbd\" is not ideal because 'c' and 'f' have a difference of 3 in alphabet order.",
            "Input: s = \"abcd\", k = 3\nOutput: 4\nExplanation: The longest ideal string is \"abcd\". The length of this string is 4, so 4 is returned."
        ],
        "constraints": "1 <= s.length <= 105\n0 <= k <= 25\ns consists of lowercase English letters.",
        "oracle_code": "class Solution {\n\n\n   int SolveByMemo(string &s , int &k , int index , int prev , vector<vector<int>> &dp)\n   {\n       if(index == s.length())\n       return 0;\n\n       if(dp[index][prev] != -1)\n       return dp[index][prev];\n\n       int op1 = 0 + SolveByMemo(s, k , index+1 , prev , dp);\n\n       int op2 = 0 ;\n\n       if(prev == 26)\n       op2 = 1 + SolveByMemo(s, k , index+1 , s[index]-'a' , dp);\n       else if(abs(s[index]-'a' - prev) <= k)\n       op2 = 1 + SolveByMemo(s, k , index+1 , s[index]-'a' , dp);\n\n       return dp[index][prev] = max(op1 , op2);\n   }\n\n   int SolveByTab(string &s , int &k )\n   {\n        vector<vector<int>> dp(s.length()+1 , vector<int> (27, 0));\n       \n        for(int index = s.length()-1 ; index>=0 ; index--)\n        {\n            for(int prev = 0 ; prev<= 26 ; prev++)\n            {\n                int op1 = 0 + dp[index+1][prev];\n                int op2 = 0 ;\n\n               if(prev == 26)\n               op2 = 1 + dp[index+1][s[index]-'a'];\n               else if(abs(s[index]-'a' - prev) <= k)\n               op2 = 1 + dp[index+1][s[index]-'a'];\n\n               dp[index][prev] = max(op1 , op2);\n            }\n        }\n\n       return max(dp[0][s[0]-'a'] , dp[0][26]);\n   }\n\n   int SolveByTabSpaceOptimised(string &s , int &k )\n   {\n        vector<int> next(27, 0) ;\n        vector<int> curr(27, 0);\n       \n        for(int index = s.length()-1 ; index>=0 ; index--)\n        {\n            for(int prev = 0 ; prev<= 26 ; prev++)\n            {\n                int op1 = 0 + next[prev];\n                int op2 = 0 ;\n\n               if(prev == 26)\n               op2 = 1 + next[s[index]-'a'];\n               else if(abs(s[index]-'a' - prev) <= k)\n               op2 = 1 + next[s[index]-'a'];\n\n               curr[prev] = max(op1 , op2);\n            }\n            next = curr;\n        }\n\n       return max(curr[s[0]-'a'] , curr[26]);\n   }\n\npublic:\n    int longestIdealString(string s, int k) {\n        \n        // 1. Recursion + Memoization || Top Down Approach\n        // vector<vector<int>> dp(s.length() , vector<int> (27, -1));\n        // return SolveByMemo(s, k , 0 , 26, dp);\n\n        // 2. Tabulation Method || Bottom Up Approach\n        // return SolveByTab(s, k);\n\n        // 3. Space Optimisation using Tabulation\n        return SolveByTabSpaceOptimised(s , k);\n    }\n};",
        "content": "\\n# Approach\\nWe Have Use Three Different Approaches :\\n1. Recursion + Memoization \\n    TC : O(n^2) , SC : O(n)\\n2. Tabulation Method \\n    TC : O(n^2) , SC : O(n)\\n3.  Tabulatuon With SOace Optimised\\n    TC : O(n^2) , SC : O(1) \\n\\n\\n#Note\\nSC In first two methods is On) and not O(n^2) as size is fixed to 27 for each index hence it is Linear Space ,Similarly for 3rd Method we have optimised to constant space as at any instant we onlt need memory of next 27 blocks  only.\\n\\n#Hope You Liekd It and Upvote are appreciated \\n\\n# Code\\n```\\nclass Solution {\\n\\n\\n   int SolveByMemo(string &s , int &k , int index , int prev , vector<vector<int>> &dp)\\n   {\\n       if(index == s.length())\\n       return 0;\\n\\n       if(dp[index][prev] != -1)\\n       return dp[index][prev];\\n\\n       int op1 = 0 + SolveByMemo(s, k , index+1 , prev , dp);\\n\\n       int op2 = 0 ;\\n\\n       if(prev == 26)\\n       op2 = 1 + SolveByMemo(s, k , index+1 , s[index]-\\'a\\' , dp);\\n       else if(abs(s[index]-\\'a\\' - prev) <= k)\\n       op2 = 1 + SolveByMemo(s, k , index+1 , s[index]-\\'a\\' , dp);\\n\\n       return dp[index][prev] = max(op1 , op2);\\n   }\\n\\n   int SolveByTab(string &s , int &k )\\n   {\\n        vector<vector<int>> dp(s.length()+1 , vector<int> (27, 0));\\n       \\n        for(int index = s.length()-1 ; index>=0 ; index--)\\n        {\\n            for(int prev = 0 ; prev<= 26 ; prev++)\\n            {\\n                int op1 = 0 + dp[index+1][prev];\\n                int op2 = 0 ;\\n\\n               if(prev == 26)\\n               op2 = 1 + dp[index+1][s[index]-\\'a\\'];\\n               else if(abs(s[index]-\\'a\\' - prev) <= k)\\n               op2 = 1 + dp[index+1][s[index]-\\'a\\'];\\n\\n               dp[index][prev] = max(op1 , op2);\\n            }\\n        }\\n\\n       return max(dp[0][s[0]-\\'a\\'] , dp[0][26]);\\n   }\\n\\n   int SolveByTabSpaceOptimised(string &s , int &k )\\n   {\\n        vector<int> next(27, 0) ;\\n        vector<int> curr(27, 0);\\n       \\n        for(int index = s.length()-1 ; index>=0 ; index--)\\n        {\\n            for(int prev = 0 ; prev<= 26 ; prev++)\\n            {\\n                int op1 = 0 + next[prev];\\n                int op2 = 0 ;\\n\\n               if(prev == 26)\\n               op2 = 1 + next[s[index]-\\'a\\'];\\n               else if(abs(s[index]-\\'a\\' - prev) <= k)\\n               op2 = 1 + next[s[index]-\\'a\\'];\\n\\n               curr[prev] = max(op1 , op2);\\n            }\\n            next = curr;\\n        }\\n\\n       return max(curr[s[0]-\\'a\\'] , curr[26]);\\n   }\\n\\npublic:\\n    int longestIdealString(string s, int k) {\\n        \\n        // 1. Recursion + Memoization || Top Down Approach\\n        // vector<vector<int>> dp(s.length() , vector<int> (27, -1));\\n        // return SolveByMemo(s, k , 0 , 26, dp);\\n\\n        // 2. Tabulation Method || Bottom Up Approach\\n        // return SolveByTab(s, k);\\n\\n        // 3. Space Optimisation using Tabulation\\n        return SolveByTabSpaceOptimised(s , k);\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "indexing error",
            "unclosed string",
            "variable value error",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution {\n   int SolveByMemo(string &s , int &k , int index , int prev , vector<vector<int>> &dp)\n   {\n       \n       if(dp[index+1][prev] != -1)\n       return dp[index+1][prev];\n\n       \nprv\n   }\n\n   prev];\n               else if(abs(-prv)<= k)\n               op2 = 1 + dp[ndex+1][];\n dp[index][prev] = max(op1 ,);\n        }\n        }\n\n       rtur ma(dp[0][s[0publc:\n    i longestIdealString(string s, int k) {\n        \n        // 1. Recursion + Memoization || Top Down Approach\n        // vector<vector<int>> dp(s.length() , vector<int> (27, -1));\n        // return SolveByMemo(s, k , 0 , 26, dp);\n\n        // 2. Tabulation Mestring()Bttm Up"
    },
    {
        "slug": "find-the-minimum-and-maximum-number-of-nodes-between-critical-points",
        "description": "A critical point in a linked list is defined as either a local maxima or a local minima.\nA node is a local maxima if the current node has a value strictly greater than the previous node and the next node.\nA node is a local minima if the current node has a value strictly smaller than the previous node and the next node.\nNote that a node can only be a local maxima/minima if there exists both a previous node and a next node.\nGiven a linked list head, return an array of length 2 containing [minDistance, maxDistance] where minDistance is the minimum distance between any\u00a0two distinct critical points and maxDistance is the maximum distance between any\u00a0two distinct critical points. If there are fewer than two critical points, return [-1, -1].",
        "examples": [
            "Input: head = [3,1]\nOutput: [-1,-1]\nExplanation: There are no critical points in [3,1].",
            "Input: head = [5,3,1,2,5,1,2]\nOutput: [1,3]\nExplanation: There are three critical points:\n- [5,3,1,2,5,1,2]: The third node is a local minima because 1 is less than 3 and 2.\n- [5,3,1,2,5,1,2]: The fifth node is a local maxima because 5 is greater than 2 and 1.\n- [5,3,1,2,5,1,2]: The sixth node is a local minima because 1 is less than 5 and 2.\nThe minimum distance is between the fifth and the sixth node. minDistance = 6 - 5 = 1.\nThe maximum distance is between the third and the sixth node. maxDistance = 6 - 3 = 3.",
            "Input: head = [1,3,2,2,3,2,2,2,7]\nOutput: [3,3]\nExplanation: There are two critical points:\n- [1,3,2,2,3,2,2,2,7]: The second node is a local maxima because 3 is greater than 1 and 2.\n- [1,3,2,2,3,2,2,2,7]: The fifth node is a local maxima because 3 is greater than 2 and 2.\nBoth the minimum and maximum distances are between the second and the fifth node.\nThus, minDistance and maxDistance is 5 - 2 = 3.\nNote that the last node is not considered a local maxima because it does not have a next node."
        ],
        "constraints": "The number of nodes in the list is in the range [2, 105].\n1 <= Node.val <= 105",
        "oracle_code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\n        ios_base::sync_with_stdio(false);\n if(head==NULL || head->next==NULL ||head->next->next==NULL){\n     return {-1,-1};\n }\n        ListNode* temp2=head->next;\n        ListNode* temp3=head->next->next;\n      vector<int>v;\n      int i=2;\n      while(temp3){\n          if((head->val<temp2->val)&&(temp3->val<temp2->val)){\n              v.push_back(i);\n          }\n          else if((head->val>temp2->val)&&(temp3->val>temp2->val)){\n              v.push_back(i);\n          }\n          i++;\n          head=head->next;\n          temp2=temp2->next;\n          temp3=temp3->next;\n      }\n      if(v.size()<2){\n           return {-1,-1};\n      }\n      int mini=INT_MAX;\n      for(int i=1;i<v.size();i++){\n          mini=min(mini,(v[i]-v[i-1]));\n      }\n        return {mini,(v[v.size()-1]-v[0])};\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhen faced with a problem involving linked lists, the first intuition should be to think about how to traverse the list efficiently to extract the required information.\\n\\nIn the case of this problem, the required information is the minimum and maximum distance between any two critical points in the list. A critical point is defined as a node where the value is either the maximum or minimum among its adjacent nodes.\\n\\nTo solve this problem, we need to traverse the list and identify the critical points. Once we have the critical points, we can calculate the distances between them and find the minimum and maximum distances.\\n\\nTherefore, the first intuition for this problem should be to think about how to traverse the list and identify critical points efficiently. We can then use this information to calculate the minimum and maximum distances between critical points.\\n\\n\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe code first checks if the list has at least three nodes, as it is not possible to have a critical point with less than two adjacent nodes. If the list does not meet this condition, the function returns {-1,-1}.\\n\\nThen, the code initializes three pointers, head, temp2, and temp3. The head pointer is used to traverse the list, while temp2 and temp3 are used to check if the current node is a critical point. The i variable is also initialized to 2, as the first two nodes are not considered critical points.\\n\\nNext, the code enters a loop that traverses the list using the temp3 pointer. For each node, the code checks if it is a critical point by comparing its value to the values of its adjacent nodes. If it is a critical point, the current value of i is pushed to a vector v.\\n\\nAfter the loop finishes, the code checks if there are at least two critical points in the list. If there are less than two, the function returns {-1,-1}.\\n\\nIf there are at least two critical points, the code calculates the minimum and maximum distances between adjacent critical points. The minimum distance is the minimum difference between the indices of adjacent critical points in the v vector, and the maximum distance is the difference between the indices of the first and last elements in the v vector.\\n\\nFinally, the function returns a vector containing the minimum and maximum distances as its two elements.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this code is O(n), where n is the length of the input singly-linked list. This is because the code only traverses the list once in the while loop, and performs constant time operations (comparisons, pointer assignments, and vector operations) for each node. The vector operations inside the loop take constant time on average, as the vector is not resized during the loop. Therefore, the overall time complexity of the code is O(n).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of this code is O(1) if we ignore the space used by the input linked list. The code only uses a constant amount of extra space to store three pointers (head, temp2, temp3) and a vector v to store the indices of critical points. The size of v is proportional to the number of critical points in the list, which is at most n-2 (where n is the length of the list), as there can be at most one critical point per node except for the first and last nodes. Therefore, the size of v is bounded by O(n), but since the space used by v is not a function of the input size, we consider it as a constant space usage. Therefore, the overall space complexity of the code is O(1).\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        ios_base::sync_with_stdio(false);\\n if(head==NULL || head->next==NULL ||head->next->next==NULL){\\n     return {-1,-1};\\n }\\n        ListNode* temp2=head->next;\\n        ListNode* temp3=head->next->next;\\n      vector<int>v;\\n      int i=2;\\n      while(temp3){\\n          if((head->val<temp2->val)&&(temp3->val<temp2->val)){\\n              v.push_back(i);\\n          }\\n          else if((head->val>temp2->val)&&(temp3->val>temp2->val)){\\n              v.push_back(i);\\n          }\\n          i++;\\n          head=head->next;\\n          temp2=temp2->next;\\n          temp3=temp3->next;\\n      }\\n      if(v.size()<2){\\n           return {-1,-1};\\n      }\\n      int mini=INT_MAX;\\n      for(int i=1;i<v.size();i++){\\n          mini=min(mini,(v[i]-v[i-1]));\\n      }\\n        return {mini,(v[v.size()-1]-v[0])};\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "== and = confusion",
            "indexing error",
            "conditional statement error",
            "colon missing"
        ],
        "buggy_code": "\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\n        ios_base::sync_with_stdio(false);\n if(head==NULL || head->next==NULL ||head->next->next==NULL){\n     return {-1,-1};\n }\n        ListNode* temp2=head->next;\n        ListNode* temp3=head->next-next;\n      vector<int>v;\n      int i=2;\n      while(head){\n          if((head->val<temp2->val)&&(temp3->val=temp2->val)){ \n              v.push_back(i);\n          }\n          else if((head->val>temp2->val)&&(temp3->val<temp2->val)){\n              v.push_back(i);\n          }\n          i++;\n          head=head;\n          temp2=temp2.next;\n          temp3=temp3.next;\n      }\n      if(v.size()<2){\n           return {-1,-1};\n      }\n      int mini=INT_MAX;\n      for(int i=1;i<=v.size();i++){\n          mini=min(mini,(v[i]-v[i-1]));\n      }\n        return {mini,(v[v.size()]-v[0])};\n    }\n};\n"
    },
    {
        "slug": "check-knight-tour-configuration",
        "description": "There is a knight on an n x n chessboard. In a valid configuration, the knight starts at the top-left cell of the board and visits every cell on the board exactly once.\nYou are given an n x n integer matrix grid consisting of distinct integers from the range [0, n * n - 1] where grid[row][col] indicates that the cell (row, col) is the grid[row][col]th cell that the knight visited. The moves are 0-indexed.\nReturn true if grid represents a valid configuration of the knight's movements or false otherwise.\nNote that a valid knight move consists of moving two squares vertically and one square horizontally, or two squares horizontally and one square vertically. The figure below illustrates all the possible eight moves of a knight from some cell.",
        "examples": [
            "Input: grid = [[0,11,16,5,20],[17,4,19,10,15],[12,1,8,21,6],[3,18,23,14,9],[24,13,2,7,22]]\nOutput: true\nExplanation: The above diagram represents the grid. It can be shown that it is a valid configuration.",
            "Input: grid = [[0,3,6],[5,8,1],[2,7,4]]\nOutput: false\nExplanation: The above diagram represents the grid. The 8th move of the knight is not valid considering its position after the 7th move."
        ],
        "constraints": "n == grid.length == grid[i].length\n3 <= n <= 7\n0 <= grid[row][col] < n * n\nAll integers in grid are unique.",
        "oracle_code": "class Solution {\nprivate:\n    bool helper(vector<vector<int>>& grid, int row, int col, int num){\n        int n = grid.size();\n        if(num == n*n) return true;\n        int i = row-2;\n        int j = col+1;\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row-2;\n        j = col-1;\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 2;\n        j = col - 1;\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 2;\n        j = col + 1;\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 1;\n        j = col + 2;\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row - 1;\n        j = col + 2;\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row - 1;\n        j = col - 2;\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 1;\n        j = col - 2;\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        return false;\n    }\npublic:\n    bool checkValidGrid(vector<vector<int>>& grid) {\n        ios::sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);\n        if(grid[0][0] != 0) return false;\n        return helper(grid,0,0,1);\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    bool helper(vector<vector<int>>& grid, int row, int col, int num){\\n        int n = grid.size();\\n        if(num == n*n) return true;\\n        int i = row-2;\\n        int j = col+1;\\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row-2;\\n        j = col-1;\\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row + 2;\\n        j = col - 1;\\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row + 2;\\n        j = col + 1;\\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row + 1;\\n        j = col + 2;\\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row - 1;\\n        j = col + 2;\\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row - 1;\\n        j = col - 2;\\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row + 1;\\n        j = col - 2;\\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        return false;\\n    }\\npublic:\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(0);\\n        cout.tie(0);\\n        if(grid[0][0] != 0) return false;\\n        return helper(grid,0,0,1);\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "== and = confusion",
            "operation error",
            "undefined methods",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution {\nprivate:\n    bool helper(vector<vector<int>>& grid, int row, int col, int num){\n        int n = grid.size();\n        if(num = n*n) return true;\n        int i = row-2;\n        int j = col+1;\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row-2;\n        j = col-1;\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+2);\n\n        i = row + 2;\n        j = col - 1;\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 2;\n        j = col + 1;\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 1;\n        j = col + 2;\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row - 1;\n        j = col + 2;\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row - 1;\n        j = col - 2;\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 1;\n        j = col - 2;\n        if(i<n && j>=0 && grid[i][j] == num) return methodNotFound(grid,i,j,num+1);\n\n        return false;\n    }\npublic:\n    bool checkValidGrid(vector<vector<int>>& grid) {\n        sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);\n        if(grid[0][0] != 0) return false;\n        return helper(grid,0,0,1);\n    }\n};\n"
    },
    {
        "slug": "search-in-a-binary-search-tree",
        "description": "You are given the root of a binary search tree (BST) and an integer val.\nFind the node in the BST that the node's value equals val and return the subtree rooted with that node. If such a node does not exist, return null.",
        "examples": [
            "Input: root = [4,2,7,1,3], val = 2\nOutput: [2,1,3]",
            "Input: root = [4,2,7,1,3], val = 5\nOutput: []"
        ],
        "constraints": "The number of nodes in the tree is in the range [1, 5000].\n1 <= Node.val <= 107\nroot is a binary search tree.\n1 <= val <= 107",
        "oracle_code": "class Solution {\npublic:\n    TreeNode* searchBST(TreeNode* root, int val) {\n       if(root==NULL) \n       return NULL;\n       if(root->val==val)\n       {\n           return root;\n       }\n       if(root->val>val){\n          return  searchBST(root->left,val);\n       }\n        return searchBST(root->right,val);\n    }\n};",
        "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n       if(root==NULL) \\n       return NULL;\\n       if(root->val==val)\\n       {\\n           return root;\\n       }\\n       if(root->val>val){\\n          return  searchBST(root->left,val);\\n       }\\n        return searchBST(root->right,val);\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "statement separation",
            "wrong comment mark",
            "colon missing",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    /* \n    TreeNode* searchBST(TreeNode* root, int val) {\n       if(root=NULL) \n       return NULL;\n       if(root->val==val);\n       {\n           return root;\n       }\n       if(root->val>val)){\n          return  searchBST(root->left,val);\n       }\n        return searchBST(root->right,val);\n    }\n    */\n};\n"
    },
    {
        "slug": "search-in-a-binary-search-tree",
        "description": "You are given the root of a binary search tree (BST) and an integer val.\nFind the node in the BST that the node's value equals val and return the subtree rooted with that node. If such a node does not exist, return null.",
        "examples": [
            "Input: root = [4,2,7,1,3], val = 2\nOutput: [2,1,3]",
            "Input: root = [4,2,7,1,3], val = 5\nOutput: []"
        ],
        "constraints": "The number of nodes in the tree is in the range [1, 5000].\n1 <= Node.val <= 107\nroot is a binary search tree.\n1 <= val <= 107",
        "oracle_code": "class Solution {\npublic:\n    TreeNode* searchBST(TreeNode* root, int val) {\n       if(root==NULL) \n       return NULL;\n       if(root->val==val)\n       {\n           return root;\n       }\n       if(root->val>val){\n          return  searchBST(root->left,val);\n       }\n        return searchBST(root->right,val);\n    }\n};",
        "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n       if(root==NULL) \\n       return NULL;\\n       if(root->val==val)\\n       {\\n           return root;\\n       }\\n       if(root->val>val){\\n          return  searchBST(root->left,val);\\n       }\\n        return searchBST(root->right,val);\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "wrong comment mark",
            "undefined keywords from other languages",
            "colon missing",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    /* \n    TreeNode* searchBST(TreeNode* root, int val) {\n       if(root=None) \n       return NULL;\n       if(root->val==val)\n       {\n           return root;\n       }\n       if(root->val>val)){\n          return  searchBST(root->left,val);\n       }\n        return searchBST(root->right,val);\n    }\n    */\n};\n"
    },
    {
        "slug": "shortest-path-to-get-all-keys",
        "description": "You are given an m x n grid grid where:\n\n'.' is an empty cell.\n'#' is a wall.\n'@' is the starting point.\nLowercase letters represent keys.\nUppercase letters represent locks.\n\nYou start at the starting point and one move consists of walking one space in one of the four cardinal directions. You cannot walk outside the grid, or walk into a wall.\nIf you walk over a key, you can pick it up and you cannot walk over a lock unless you have its corresponding key.\nFor some 1 <= k <= 6, there is exactly one lowercase and one uppercase letter of the first k letters of the English alphabet in the grid. This means that there is exactly one key for each lock, and one lock for each key; and also that the letters used to represent the keys and locks were chosen in the same order as the English alphabet.\nReturn the lowest number of moves to acquire all keys. If it is impossible, return -1.",
        "examples": [
            "Input: grid = [\"@.a..\",\"###.#\",\"b.A.B\"]\nOutput: 8\nExplanation: Note that the goal is to obtain all the keys not to open all the locks.",
            "Input: grid = [\"@..aA\",\"..B#.\",\"....b\"]\nOutput: 6",
            "Input: grid = [\"@Aa\"]\nOutput: -1"
        ],
        "constraints": "m == grid.length\nn == grid[i].length\n1 <= m, n <= 30\ngrid[i][j] is either an English letter, '.', '#', or '@'.\u00a0\nThere is exactly one\u00a0'@'\u00a0in the grid.\nThe number of keys in the grid is in the range [1, 6].\nEach key in the grid is unique.\nEach key in the grid has a matching lock.",
        "oracle_code": "class Solution {\npublic:\n\n    int dir[4][2] = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};\n\n    int shortestPathAllKeys(vector<string>& grid) {\n        \n        int m = grid.size();\n        int n = grid[0].size();\n        queue<pair<pair<int, int>, int>> que;\n        vector<vector<unsigned long>> mapKey(m, vector<unsigned long>(n, 0));\n        int target = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if ('a' <= grid[i][j] && grid[i][j] <= 'f') {\n                    target |= 1 << (grid[i][j] - 'a');\n                    continue;\n                }\n\n                if (grid[i][j] == '@') {\n                    que.emplace(pair<int, int>(i, j), 0);\n                    mapKey[i][j] = 1;\n                }\n            }\n        }\n\n\n        int step = 0;\n        while (!que.empty()) {\n            int size = que.size();\n            for (int s = 0; s < size; s++) {\n                int i = que.front().first.first;\n                int j = que.front().first.second;\n                int key = que.front().second;\n                que.pop();\n                \n                if ('a' <= grid[i][j] && grid[i][j] <= 'f') {\n                    key |= 1 << (grid[i][j] - 'a');\n                    if (key == target)\n                        return step;\n\n                    mapKey[i][j] |= 1l << key;\n                }\n\n                for (int d = 0; d < 4; d++) {\n                    int newi = i + dir[d][0];\n                    int newj = j + dir[d][1];\n                    \n                    if (!(0 <= newi && newi < m && 0 <= newj && newj < n))\n                        continue;\n                        \n                    int val = grid[newi][newj];\n                    if (val == '#')\n                        continue;\n                        \n                    if ('A' <= val && val <= 'F' && (key & (1 << (val - 'A'))) == 0)\n                        continue;\n                        \n                    if (mapKey[newi][newj] & (1l << key))\n                        continue;\n                        \n                     mapKey[newi][newj] |= 1l << key;\n                     que.emplace(pair<int, int>(newi, newj), key);\n                }\n            }\n            step++;\n        }\n        return -1;\n    }\n};",
        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int dir[4][2] = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};\\n\\n    int shortestPathAllKeys(vector<string>& grid) {\\n        \\n        int m = grid.size();\\n        int n = grid[0].size();\\n        queue<pair<pair<int, int>, int>> que;\\n        vector<vector<unsigned long>> mapKey(m, vector<unsigned long>(n, 0));\\n        int target = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (\\'a\\' <= grid[i][j] && grid[i][j] <= \\'f\\') {\\n                    target |= 1 << (grid[i][j] - \\'a\\');\\n                    continue;\\n                }\\n\\n                if (grid[i][j] == \\'@\\') {\\n                    que.emplace(pair<int, int>(i, j), 0);\\n                    mapKey[i][j] = 1;\\n                }\\n            }\\n        }\\n\\n\\n        int step = 0;\\n        while (!que.empty()) {\\n            int size = que.size();\\n            for (int s = 0; s < size; s++) {\\n                int i = que.front().first.first;\\n                int j = que.front().first.second;\\n                int key = que.front().second;\\n                que.pop();\\n                \\n                if (\\'a\\' <= grid[i][j] && grid[i][j] <= \\'f\\') {\\n                    key |= 1 << (grid[i][j] - \\'a\\');\\n                    if (key == target)\\n                        return step;\\n\\n                    mapKey[i][j] |= 1l << key;\\n                }\\n\\n                for (int d = 0; d < 4; d++) {\\n                    int newi = i + dir[d][0];\\n                    int newj = j + dir[d][1];\\n                    \\n                    if (!(0 <= newi && newi < m && 0 <= newj && newj < n))\\n                        continue;\\n                        \\n                    int val = grid[newi][newj];\\n                    if (val == \\'#\\')\\n                        continue;\\n                        \\n                    if (\\'A\\' <= val && val <= \\'F\\' && (key & (1 << (val - \\'A\\'))) == 0)\\n                        continue;\\n                        \\n                    if (mapKey[newi][newj] & (1l << key))\\n                        continue;\\n                        \\n                     mapKey[newi][newj] |= 1l << key;\\n                     que.emplace(pair<int, int>(newi, newj), key);\\n                }\\n            }\\n            step++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
        "level": "hard",
        "type": [
            "== and = confusion",
            "statement separation",
            "wrong comment mark",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n\n    int dir[4][2] = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};\n\n    int shortestPathAllKeys(vector<string>& grid) {\n        \n        int m = grid.size();\n        int n = grid[0].size();\n        queue<pair<pair<int, int>, int>> que;\n        vector<vector<unsigned long>> mapKey(m, vector<unsigned long>(n, 0));\n        int target = 0;\n        for (int i = 0; i < m; i++) \n            for (int j = 0; j < n; j++) \n                if ('a' <= grid[i][j] && grid[i][j] <= 'f') {\n                    target |= 1 << (grid[i][j] - 'a\");\n                    continue;\n\n                if (grid[i][j] = '@') {\n                    que.emplace(pair<int, int>(i, j), 0);\n                    mapKey[i][j] = 1;\n                }\n            \n\n\n        int step = 0;\n        while (!que.empty()) {\n            int size = que.size();\n            for (int s = 0; s < size; s++) {\n                int i = que.front().first.first;\n                int j = que.front().first.second;\n                int key = que.front().second;\n                que.pop();\n                \n                if ('a' <= grid[i][j] && grid[i][j] <= 'f\") {\n                    key |= 1 << (grid[i][j] - 'a\");\n                    if (key == target)\n                        return step;\n\n                    mapKey[i][j] |= 1l << key;\n                }\n\n                for (int d = 0; d < 4; d++) {\n                   \n                    int newj = j + dir[d][1];\n                    \n                    if (!(0 <= newi && newi < m && 0 <= newj && newj < n))\n                        continue;\n                        \n                    int val = grid[newi][newj];\n                    if (val == '#')\n                        continue;\n                        \n                    if ('A' <= val && val <= 'F' && (key & (1 << (val - 'A\"))) == 0)\n                        continue;\n                        \n                    if (mapKey[newi][newj] & (1l << key))\n                        continue;\n                        \n                     mapKey[newi][newj] |= 1l << key;\n                     que.emplace(pair<int, int>(newi, newj), key);\n                }\n            }\n            step++;\n        }\n        return -1;\n    }\n};\n"
    },
    {
        "slug": "widest-vertical-area-between-two-points-containing-no-points",
        "description": "Given n points on a 2D plane where points[i] = [xi, yi], Return\u00a0the widest vertical area between two points such that no points are inside the area.\nA vertical area is an area of fixed-width extending infinitely along the y-axis (i.e., infinite height). The widest vertical area is the one with the maximum width.\nNote that points on the edge of a vertical area are not considered included in the area.",
        "examples": [
            "\u200b\n\nInput: points = [[8,7],[9,9],[7,4],[9,7]]\nOutput: 1\nExplanation: Both the red and the blue area are optimal.",
            "Input: points = [[3,1],[9,0],[1,0],[1,4],[5,3],[8,8]]\nOutput: 3"
        ],
        "constraints": "n == points.length\n2 <= n <= 105\npoints[i].length == 2\n0 <= xi, yi\u00a0<= 109",
        "oracle_code": "class Solution {\npublic:\n  int maxWidthOfVerticalArea(vector<vector<int>>& points) {\n    set<int> x;\n    int res = 0;\n    for (auto &p : points)\n        x.insert(p[0]);\n    for (auto it = next(begin(x)); it != end(x); ++it)\n        res = max(res, *it - *prev(it));\n    return res;\n}\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  int maxWidthOfVerticalArea(vector<vector<int>>& points) {\\n    set<int> x;\\n    int res = 0;\\n    for (auto &p : points)\\n        x.insert(p[0]);\\n    for (auto it = next(begin(x)); it != end(x); ++it)\\n        res = max(res, *it - *prev(it));\\n    return res;\\n}\\n};\\n```",
        "level": "medium",
        "type": [
            "indexing error",
            "operation error",
            "wrong comment mark",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n  int maxWidthOfVerticalArea(vector<vector<int>>& points) /*\n    set<int> x;\n    int res = 0;\n    for (auto &p : points)\n        x.insert(p[2]);\n    for (auto it = next(begin(x)); it != end(x); ++it)\n        res = max(res, *it - *prev(it));\n    return ++calculateArea();\n}\nprivate:\n    int calculateArea();\n*/;\n"
    },
    {
        "slug": "closest-subsequence-sum",
        "description": "You are given an integer array nums and an integer goal.\nYou want to choose a subsequence of nums such that the sum of its elements is the closest possible to goal. That is, if the sum of the subsequence's elements is sum, then you want to minimize the absolute difference abs(sum - goal).\nReturn the minimum possible value of abs(sum - goal).\nNote that a subsequence of an array is an array formed by removing some elements (possibly all or none) of the original array.",
        "examples": [
            "Input: nums = [5,-7,3,5], goal = 6\nOutput: 0\nExplanation: Choose the whole array as a subsequence, with a sum of 6.\nThis is equal to the goal, so the absolute difference is 0.",
            "Input: nums = [7,-9,15,-2], goal = -5\nOutput: 1\nExplanation: Choose the subsequence [7,-9,-2], with a sum of -4.\nThe absolute difference is abs(-4 - (-5)) = abs(1) = 1, which is the minimum.",
            "Input: nums = [1,2,3], goal = -7\nOutput: 7"
        ],
        "constraints": "1 <= nums.length <= 40\n-107 <= nums[i] <= 107\n-109 <= goal <= 109",
        "oracle_code": "class Solution {\npublic:\n    void find(vector<int>&v, int i, int e, int sum, vector<int>&sumv){\n        if(i==e){\n            sumv.push_back(sum);\n            return;\n        }\n        find(v,i+1,e,sum+v[i],sumv);\n        find(v,i+1,e,sum,sumv);\n    }\n        \n    \n    int minAbsDifference(vector<int>& nums, int goal) {\n        int n=nums.size();\n        \n        //Step 1: Divide nums into 2 subarrays of size n/2 and n-n/2\n        \n        vector<int>A,B;\n        for(int i=0;i<n/2;i++)\n            A.push_back(nums[i]);\n        for(int i=n/2;i<n;i++)\n            B.push_back(nums[i]);\n        \n        //Step 2: Find all possible subset sums of A and B\n        \n        vector<int>sumA,sumB;\n        find(A,0,A.size(),0,sumA);\n        find(B,0,B.size(),0,sumB);\n        \n        sort(sumA.begin(),sumA.end());\n        sort(sumB.begin(),sumB.end());\n        \n        //Step 3: Find combinations from sumA & sumB such that abs(sum-goal) is minimized\n        \n        int ans=INT_MAX;\n        \n        for(int i=0;i<sumA.size();i++){\n            int s=sumA[i];\n            int l=0;\n            int r=sumB.size()-1;\n            while(l<=r){\n                int mid=l+(r-l)/2;\n                int sum=s+sumB[mid];\n                if(sum==goal)\n                    return 0;\n                ans=min(ans,abs(sum-goal));\n                if(sum>goal){\n                    r=mid-1;\n                }\n                else{\n                    l=mid+1;\n                }    \n            }\n        }\n        \n        return ans;\n    }\n};",
        "content": "```\\nclass Solution {\\npublic:\\n    void find(vector<int>&v, int i, int e, int sum, vector<int>&sumv){\\n        if(i==e){\\n            sumv.push_back(sum);\\n            return;\\n        }\\n        find(v,i+1,e,sum+v[i],sumv);\\n        find(v,i+1,e,sum,sumv);\\n    }\\n        \\n    \\n    int minAbsDifference(vector<int>& nums, int goal) {\\n        int n=nums.size();\\n        \\n        //Step 1: Divide nums into 2 subarrays of size n/2 and n-n/2\\n        \\n        vector<int>A,B;\\n        for(int i=0;i<n/2;i++)\\n            A.push_back(nums[i]);\\n        for(int i=n/2;i<n;i++)\\n            B.push_back(nums[i]);\\n        \\n        //Step 2: Find all possible subset sums of A and B\\n        \\n        vector<int>sumA,sumB;\\n        find(A,0,A.size(),0,sumA);\\n        find(B,0,B.size(),0,sumB);\\n        \\n        sort(sumA.begin(),sumA.end());\\n        sort(sumB.begin(),sumB.end());\\n        \\n        //Step 3: Find combinations from sumA & sumB such that abs(sum-goal) is minimized\\n        \\n        int ans=INT_MAX;\\n        \\n        for(int i=0;i<sumA.size();i++){\\n            int s=sumA[i];\\n            int l=0;\\n            int r=sumB.size()-1;\\n            while(l<=r){\\n                int mid=l+(r-l)/2;\\n                int sum=s+sumB[mid];\\n                if(sum==goal)\\n                    return 0;\\n                ans=min(ans,abs(sum-goal));\\n                if(sum>goal){\\n                    r=mid-1;\\n                }\\n                else{\\n                    l=mid+1;\\n                }    \\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n**Do upvote if you find it useful!**",
        "level": "hard",
        "type": [
            "indexing error",
            "wrong comment mark",
            "undefined keywords from other languages",
            "variable value error"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    void find(vector<int>&v, int i, int e, int sum, vector<int>&sumv){\n        if(i==e){\n            sumv.push_back(sum);\n            return;\n        }\n     \n        find(v,i+1,e,sum+v[i\n        +1]+v[i],sumv);\n    }\n        \n    \n    int minAbsDifference(vector<int>& nums, int goal) {\n        int n=nums.length();\n        \n        //Step 1: Divide nums into 2 subarrays of size n/2 and n-n/2\n        \n        vector<int>A,B;\n        for(int i=0;i<n/2;i++)\n            A.push_back(nums[i]);\n        for(int i=n/2;i<n;i++)\n            B.push_back(nums[i]);\n        \n        //Step 2: Find all possible subset sums of A and B\n        \n        vector<int>sumA,sumB;\n        find(A,0,A.size(),0,sumA);\n        find(B,0,B.size(),0,sumB);\n        \n        sort(sumA.begin(),sumA.end());\n        sort(sumB.begin(),sumB.end());\n        \n        //Step 3: Find combinations from sumA & sumB such that abs(sum-goal) is minimized\n        \n        int ans=INT_MAX;\n        \n        for(int i=0;i<sumA.size();i++){\n            int s=sumA[i];\n            int l=0;\n            int r=sumB.size()-1;\n            while(l<=r){\n                int mid=l+(r-l)/2;\n                int sum=s+sumB[mid];\n                if(sum==goal)\n                    return 0;\n                ans=min(ans,abs(sum-goal));\n                if(sum>goal){\n                    r=mid-1;\n                }\n                else{\n                    l=mid+1;\n                }    \n            }\n        }\n        \n        return ans;\n    }\n};\n"
    },
    {
        "slug": "factorial-trailing-zeroes",
        "description": "Given an integer n, return the number of trailing zeroes in n!.\nNote that n! = n * (n - 1) * (n - 2) * ... * 3 * 2 * 1.",
        "examples": [
            "Input: n = 3\nOutput: 0\nExplanation: 3! = 6, no trailing zero.",
            "Input: n = 5\nOutput: 1\nExplanation: 5! = 120, one trailing zero.",
            "Input: n = 0\nOutput: 0"
        ],
        "constraints": "0 <= n <= 104",
        "oracle_code": "class Solution {\npublic:\n    unordered_map<long long int,long long int>mp;\n    int trailingZeroes(int n) {\n        for(int i=n;i>=1;i--)\n         fun(i);\n         \n\t\t return min(mp[2],mp[5]); \n    }\n     void fun(int n)\n    {\n         for(int i=2;i*i<=n;i++)\n         {\n         \twhile((n%i) == 0)\n         \t{\n         \t    mp[i]++;\n\t\t\t\tn = n / i;\t\n\t\t\t}\n\t\t }\n\t\t if(n > 1)\n\t\t mp[n]++;\n    }\n};",
        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    unordered_map<long long int,long long int>mp;\\n    int trailingZeroes(int n) {\\n        for(int i=n;i>=1;i--)\\n         fun(i);\\n         \\n\\t\\t return min(mp[2],mp[5]); \\n    }\\n     void fun(int n)\\n    {\\n         for(int i=2;i*i<=n;i++)\\n         {\\n         \\twhile((n%i) == 0)\\n         \\t{\\n         \\t    mp[i]++;\\n\\t\\t\\t\\tn = n / i;\\t\\n\\t\\t\\t}\\n\\t\\t }\\n\\t\\t if(n > 1)\\n\\t\\t mp[n]++;\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "statement separation",
            "operation error",
            "colon missing",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    unordered_map<long long int,long long int>mp\n    int trailingZeroes(int n) {\n        for(int i=n;i>=1;i--);\n         fSolution(s;\n\t\t return s.i);\n         \n\t\t return max(mp[2],mp[5]); \n    }\n     void fun(int n)\n    {\n         for(int i=2;i*i<=n;i++)\n         {\n         \twhile((n%i) == 0)\n         \t{\n         \t    mp[i]++;\n\t\t\t\tn = n / i;\t\n\t\t\t}\n\t\t }\n\t\t if(n > 1)\n\t\t mp[n]++;\n    }\n};\n"
    },
    {
        "slug": "longest-ideal-subsequence",
        "description": "You are given a string s consisting of lowercase letters and an integer k. We call a string t ideal if the following conditions are satisfied:\n\nt is a subsequence of the string s.\nThe absolute difference in the alphabet order of every two adjacent letters in t is less than or equal to k.\n\nReturn the length of the longest ideal string.\nA subsequence is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.\nNote that the alphabet order is not cyclic. For example, the absolute difference in the alphabet order of 'a' and 'z' is 25, not 1.",
        "examples": [
            "Input: s = \"acfgbd\", k = 2\nOutput: 4\nExplanation: The longest ideal string is \"acbd\". The length of this string is 4, so 4 is returned.\nNote that \"acfgbd\" is not ideal because 'c' and 'f' have a difference of 3 in alphabet order.",
            "Input: s = \"abcd\", k = 3\nOutput: 4\nExplanation: The longest ideal string is \"abcd\". The length of this string is 4, so 4 is returned."
        ],
        "constraints": "1 <= s.length <= 105\n0 <= k <= 25\ns consists of lowercase English letters.",
        "oracle_code": "class Solution {\n\n\n   int SolveByMemo(string &s , int &k , int index , int prev , vector<vector<int>> &dp)\n   {\n       if(index == s.length())\n       return 0;\n\n       if(dp[index][prev] != -1)\n       return dp[index][prev];\n\n       int op1 = 0 + SolveByMemo(s, k , index+1 , prev , dp);\n\n       int op2 = 0 ;\n\n       if(prev == 26)\n       op2 = 1 + SolveByMemo(s, k , index+1 , s[index]-'a' , dp);\n       else if(abs(s[index]-'a' - prev) <= k)\n       op2 = 1 + SolveByMemo(s, k , index+1 , s[index]-'a' , dp);\n\n       return dp[index][prev] = max(op1 , op2);\n   }\n\n   int SolveByTab(string &s , int &k )\n   {\n        vector<vector<int>> dp(s.length()+1 , vector<int> (27, 0));\n       \n        for(int index = s.length()-1 ; index>=0 ; index--)\n        {\n            for(int prev = 0 ; prev<= 26 ; prev++)\n            {\n                int op1 = 0 + dp[index+1][prev];\n                int op2 = 0 ;\n\n               if(prev == 26)\n               op2 = 1 + dp[index+1][s[index]-'a'];\n               else if(abs(s[index]-'a' - prev) <= k)\n               op2 = 1 + dp[index+1][s[index]-'a'];\n\n               dp[index][prev] = max(op1 , op2);\n            }\n        }\n\n       return max(dp[0][s[0]-'a'] , dp[0][26]);\n   }\n\n   int SolveByTabSpaceOptimised(string &s , int &k )\n   {\n        vector<int> next(27, 0) ;\n        vector<int> curr(27, 0);\n       \n        for(int index = s.length()-1 ; index>=0 ; index--)\n        {\n            for(int prev = 0 ; prev<= 26 ; prev++)\n            {\n                int op1 = 0 + next[prev];\n                int op2 = 0 ;\n\n               if(prev == 26)\n               op2 = 1 + next[s[index]-'a'];\n               else if(abs(s[index]-'a' - prev) <= k)\n               op2 = 1 + next[s[index]-'a'];\n\n               curr[prev] = max(op1 , op2);\n            }\n            next = curr;\n        }\n\n       return max(curr[s[0]-'a'] , curr[26]);\n   }\n\npublic:\n    int longestIdealString(string s, int k) {\n        \n        // 1. Recursion + Memoization || Top Down Approach\n        // vector<vector<int>> dp(s.length() , vector<int> (27, -1));\n        // return SolveByMemo(s, k , 0 , 26, dp);\n\n        // 2. Tabulation Method || Bottom Up Approach\n        // return SolveByTab(s, k);\n\n        // 3. Space Optimisation using Tabulation\n        return SolveByTabSpaceOptimised(s , k);\n    }\n};",
        "content": "\\n# Approach\\nWe Have Use Three Different Approaches :\\n1. Recursion + Memoization \\n    TC : O(n^2) , SC : O(n)\\n2. Tabulation Method \\n    TC : O(n^2) , SC : O(n)\\n3.  Tabulatuon With SOace Optimised\\n    TC : O(n^2) , SC : O(1) \\n\\n\\n#Note\\nSC In first two methods is On) and not O(n^2) as size is fixed to 27 for each index hence it is Linear Space ,Similarly for 3rd Method we have optimised to constant space as at any instant we onlt need memory of next 27 blocks  only.\\n\\n#Hope You Liekd It and Upvote are appreciated \\n\\n# Code\\n```\\nclass Solution {\\n\\n\\n   int SolveByMemo(string &s , int &k , int index , int prev , vector<vector<int>> &dp)\\n   {\\n       if(index == s.length())\\n       return 0;\\n\\n       if(dp[index][prev] != -1)\\n       return dp[index][prev];\\n\\n       int op1 = 0 + SolveByMemo(s, k , index+1 , prev , dp);\\n\\n       int op2 = 0 ;\\n\\n       if(prev == 26)\\n       op2 = 1 + SolveByMemo(s, k , index+1 , s[index]-\\'a\\' , dp);\\n       else if(abs(s[index]-\\'a\\' - prev) <= k)\\n       op2 = 1 + SolveByMemo(s, k , index+1 , s[index]-\\'a\\' , dp);\\n\\n       return dp[index][prev] = max(op1 , op2);\\n   }\\n\\n   int SolveByTab(string &s , int &k )\\n   {\\n        vector<vector<int>> dp(s.length()+1 , vector<int> (27, 0));\\n       \\n        for(int index = s.length()-1 ; index>=0 ; index--)\\n        {\\n            for(int prev = 0 ; prev<= 26 ; prev++)\\n            {\\n                int op1 = 0 + dp[index+1][prev];\\n                int op2 = 0 ;\\n\\n               if(prev == 26)\\n               op2 = 1 + dp[index+1][s[index]-\\'a\\'];\\n               else if(abs(s[index]-\\'a\\' - prev) <= k)\\n               op2 = 1 + dp[index+1][s[index]-\\'a\\'];\\n\\n               dp[index][prev] = max(op1 , op2);\\n            }\\n        }\\n\\n       return max(dp[0][s[0]-\\'a\\'] , dp[0][26]);\\n   }\\n\\n   int SolveByTabSpaceOptimised(string &s , int &k )\\n   {\\n        vector<int> next(27, 0) ;\\n        vector<int> curr(27, 0);\\n       \\n        for(int index = s.length()-1 ; index>=0 ; index--)\\n        {\\n            for(int prev = 0 ; prev<= 26 ; prev++)\\n            {\\n                int op1 = 0 + next[prev];\\n                int op2 = 0 ;\\n\\n               if(prev == 26)\\n               op2 = 1 + next[s[index]-\\'a\\'];\\n               else if(abs(s[index]-\\'a\\' - prev) <= k)\\n               op2 = 1 + next[s[index]-\\'a\\'];\\n\\n               curr[prev] = max(op1 , op2);\\n            }\\n            next = curr;\\n        }\\n\\n       return max(curr[s[0]-\\'a\\'] , curr[26]);\\n   }\\n\\npublic:\\n    int longestIdealString(string s, int k) {\\n        \\n        // 1. Recursion + Memoization || Top Down Approach\\n        // vector<vector<int>> dp(s.length() , vector<int> (27, -1));\\n        // return SolveByMemo(s, k , 0 , 26, dp);\\n\\n        // 2. Tabulation Method || Bottom Up Approach\\n        // return SolveByTab(s, k);\\n\\n        // 3. Space Optimisation using Tabulation\\n        return SolveByTabSpaceOptimised(s , k);\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "indexing error",
            "undefined keywords from other languages",
            "variable value error",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution {\n\n   int SolveByMemo(string &s , int &k , int index , int prev , vector<vector<int>> &dp)\n   {\n       \n       if(dp[index+1][prev] != -1)\n       return dp[index+1][prev];\n\n       \nfun(s, k , index+, prev , dp);\n       else if(abs(s[index]-'a' - prev) <= k)\n       op2 = fun(s, k , index1 , s[index]-'a' , dp);\n\n       return dp[index][prev] = max(op1 , op2);\n   }\n\n   int SolveByTab(string &s , int &k )\n   {\n        vector<vector<int>> dp(s.length()+1 , vector<int> (27, 0));\n       \n        for(int index = s.length()-1 ; index>=0 ; index--)\n        {\n            for(int prev = 0 ; prev<= 26 ; prev++)\n            {\n                int op1 = 0 + dp[index+1][prev];\n                int op2 = 0 ;\n\n               if(prev == 26)\n               op2 = fun(dp[index+1][prev];\n               else if(abs(s[index]-'a') - prev) <= k)\n               op2 = 1 + dp[index+1][s[index]-'a'];\n\n               dp[index][prev] = max(op1 , op2);\n  fun(        }\n        }\n\n       return max(dp[0][s[0]-'a']) , dp[0][26]);\n   }\npublic:\n    int longestIdealString(string s, int k) {\n        \n        // 1. Recursion + Memoization || Top Down Approach\n        // vector<vector<int>> dp(s.length() , vector<int> (27, -1));\n        // return SolveByMemo(s, k , 0 , 26, dp);\n\n        // 2. Tabulation Method || Bottom Ustring()p Approach\n        return"
    },
    {
        "slug": "search-in-a-binary-search-tree",
        "description": "You are given the root of a binary search tree (BST) and an integer val.\nFind the node in the BST that the node's value equals val and return the subtree rooted with that node. If such a node does not exist, return null.",
        "examples": [
            "Input: root = [4,2,7,1,3], val = 2\nOutput: [2,1,3]",
            "Input: root = [4,2,7,1,3], val = 5\nOutput: []"
        ],
        "constraints": "The number of nodes in the tree is in the range [1, 5000].\n1 <= Node.val <= 107\nroot is a binary search tree.\n1 <= val <= 107",
        "oracle_code": "class Solution {\npublic:\n    TreeNode* searchBST(TreeNode* root, int val) {\n       if(root==NULL) \n       return NULL;\n       if(root->val==val)\n       {\n           return root;\n       }\n       if(root->val>val){\n          return  searchBST(root->left,val);\n       }\n        return searchBST(root->right,val);\n    }\n};",
        "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n       if(root==NULL) \\n       return NULL;\\n       if(root->val==val)\\n       {\\n           return root;\\n       }\\n       if(root->val>val){\\n          return  searchBST(root->left,val);\\n       }\\n        return searchBST(root->right,val);\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "statement separation",
            "conditional statement error",
            "undefined keywords from other languages",
            "colon missing"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    TreeNode* searchBST(TreeNode* root, int val) {\n       if(root=None) \n       return NULL;\n       if(root->val==val);\n       {\n           return root;\n       }\n       if(root->val > val){\n          return searchBST(root->right,val);\n       }\n        return searchBST(root->left,val);\n    }\n};\n"
    },
    {
        "slug": "search-in-a-binary-search-tree",
        "description": "You are given the root of a binary search tree (BST) and an integer val.\nFind the node in the BST that the node's value equals val and return the subtree rooted with that node. If such a node does not exist, return null.",
        "examples": [
            "Input: root = [4,2,7,1,3], val = 2\nOutput: [2,1,3]",
            "Input: root = [4,2,7,1,3], val = 5\nOutput: []"
        ],
        "constraints": "The number of nodes in the tree is in the range [1, 5000].\n1 <= Node.val <= 107\nroot is a binary search tree.\n1 <= val <= 107",
        "oracle_code": "class Solution {\npublic:\n    TreeNode* searchBST(TreeNode* root, int val) {\n       if(root==NULL) \n       return NULL;\n       if(root->val==val)\n       {\n           return root;\n       }\n       if(root->val>val){\n          return  searchBST(root->left,val);\n       }\n        return searchBST(root->right,val);\n    }\n};",
        "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n       if(root==NULL) \\n       return NULL;\\n       if(root->val==val)\\n       {\\n           return root;\\n       }\\n       if(root->val>val){\\n          return  searchBST(root->left,val);\\n       }\\n        return searchBST(root->right,val);\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "statement separation",
            "conditional statement error",
            "undefined keywords from other languages",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    TreeNode* searchBST(TreeNode* root, int val) {\n       if(root==None) \n       return NULL;\n       if(root->val==val);\n       {\n           return root;\n       }\n       if(root->val > val)){\n          return searchBST(root->right,val);\n       }\n        return searchBST(root->left,val);\n    }\n};\n"
    },
    {
        "slug": "shortest-path-to-get-all-keys",
        "description": "You are given an m x n grid grid where:\n\n'.' is an empty cell.\n'#' is a wall.\n'@' is the starting point.\nLowercase letters represent keys.\nUppercase letters represent locks.\n\nYou start at the starting point and one move consists of walking one space in one of the four cardinal directions. You cannot walk outside the grid, or walk into a wall.\nIf you walk over a key, you can pick it up and you cannot walk over a lock unless you have its corresponding key.\nFor some 1 <= k <= 6, there is exactly one lowercase and one uppercase letter of the first k letters of the English alphabet in the grid. This means that there is exactly one key for each lock, and one lock for each key; and also that the letters used to represent the keys and locks were chosen in the same order as the English alphabet.\nReturn the lowest number of moves to acquire all keys. If it is impossible, return -1.",
        "examples": [
            "Input: grid = [\"@.a..\",\"###.#\",\"b.A.B\"]\nOutput: 8\nExplanation: Note that the goal is to obtain all the keys not to open all the locks.",
            "Input: grid = [\"@..aA\",\"..B#.\",\"....b\"]\nOutput: 6",
            "Input: grid = [\"@Aa\"]\nOutput: -1"
        ],
        "constraints": "m == grid.length\nn == grid[i].length\n1 <= m, n <= 30\ngrid[i][j] is either an English letter, '.', '#', or '@'.\u00a0\nThere is exactly one\u00a0'@'\u00a0in the grid.\nThe number of keys in the grid is in the range [1, 6].\nEach key in the grid is unique.\nEach key in the grid has a matching lock.",
        "oracle_code": "class Solution {\npublic:\n\n    int dir[4][2] = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};\n\n    int shortestPathAllKeys(vector<string>& grid) {\n        \n        int m = grid.size();\n        int n = grid[0].size();\n        queue<pair<pair<int, int>, int>> que;\n        vector<vector<unsigned long>> mapKey(m, vector<unsigned long>(n, 0));\n        int target = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if ('a' <= grid[i][j] && grid[i][j] <= 'f') {\n                    target |= 1 << (grid[i][j] - 'a');\n                    continue;\n                }\n\n                if (grid[i][j] == '@') {\n                    que.emplace(pair<int, int>(i, j), 0);\n                    mapKey[i][j] = 1;\n                }\n            }\n        }\n\n\n        int step = 0;\n        while (!que.empty()) {\n            int size = que.size();\n            for (int s = 0; s < size; s++) {\n                int i = que.front().first.first;\n                int j = que.front().first.second;\n                int key = que.front().second;\n                que.pop();\n                \n                if ('a' <= grid[i][j] && grid[i][j] <= 'f') {\n                    key |= 1 << (grid[i][j] - 'a');\n                    if (key == target)\n                        return step;\n\n                    mapKey[i][j] |= 1l << key;\n                }\n\n                for (int d = 0; d < 4; d++) {\n                    int newi = i + dir[d][0];\n                    int newj = j + dir[d][1];\n                    \n                    if (!(0 <= newi && newi < m && 0 <= newj && newj < n))\n                        continue;\n                        \n                    int val = grid[newi][newj];\n                    if (val == '#')\n                        continue;\n                        \n                    if ('A' <= val && val <= 'F' && (key & (1 << (val - 'A'))) == 0)\n                        continue;\n                        \n                    if (mapKey[newi][newj] & (1l << key))\n                        continue;\n                        \n                     mapKey[newi][newj] |= 1l << key;\n                     que.emplace(pair<int, int>(newi, newj), key);\n                }\n            }\n            step++;\n        }\n        return -1;\n    }\n};",
        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int dir[4][2] = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};\\n\\n    int shortestPathAllKeys(vector<string>& grid) {\\n        \\n        int m = grid.size();\\n        int n = grid[0].size();\\n        queue<pair<pair<int, int>, int>> que;\\n        vector<vector<unsigned long>> mapKey(m, vector<unsigned long>(n, 0));\\n        int target = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (\\'a\\' <= grid[i][j] && grid[i][j] <= \\'f\\') {\\n                    target |= 1 << (grid[i][j] - \\'a\\');\\n                    continue;\\n                }\\n\\n                if (grid[i][j] == \\'@\\') {\\n                    que.emplace(pair<int, int>(i, j), 0);\\n                    mapKey[i][j] = 1;\\n                }\\n            }\\n        }\\n\\n\\n        int step = 0;\\n        while (!que.empty()) {\\n            int size = que.size();\\n            for (int s = 0; s < size; s++) {\\n                int i = que.front().first.first;\\n                int j = que.front().first.second;\\n                int key = que.front().second;\\n                que.pop();\\n                \\n                if (\\'a\\' <= grid[i][j] && grid[i][j] <= \\'f\\') {\\n                    key |= 1 << (grid[i][j] - \\'a\\');\\n                    if (key == target)\\n                        return step;\\n\\n                    mapKey[i][j] |= 1l << key;\\n                }\\n\\n                for (int d = 0; d < 4; d++) {\\n                    int newi = i + dir[d][0];\\n                    int newj = j + dir[d][1];\\n                    \\n                    if (!(0 <= newi && newi < m && 0 <= newj && newj < n))\\n                        continue;\\n                        \\n                    int val = grid[newi][newj];\\n                    if (val == \\'#\\')\\n                        continue;\\n                        \\n                    if (\\'A\\' <= val && val <= \\'F\\' && (key & (1 << (val - \\'A\\'))) == 0)\\n                        continue;\\n                        \\n                    if (mapKey[newi][newj] & (1l << key))\\n                        continue;\\n                        \\n                     mapKey[newi][newj] |= 1l << key;\\n                     que.emplace(pair<int, int>(newi, newj), key);\\n                }\\n            }\\n            step++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
        "level": "hard",
        "type": [
            "== and = confusion",
            "operation error",
            "wrong comment mark",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n\n    int dir[4][2] = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};\n\n    int shortestPathAllKeys(vector<string>& grid) {\n        \n        int m = grid.size();\n        int n = grid[0].size();\n        queue<pair<pair<int, int>, int>> que;\n        vector<vector<unsigned long>> mapKey(m, vector<unsigned long>(n, 0));\n        int target = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if ('a' <= grid[i][j] && grid[i][j] <= 'f') {\n                    target |= 1 << (grid[i][j] - 'a\");\n                    continue;\n                }\n\n                if (grid[i][j] = '@') {\n                    que.emplace(pair<int, int>(i, j), 0);\n                    mapKey[i][j] = 1;\n                }\n            }\n        }\n\n\n        int step = 0;\n        while (!que.empty()) {\n            int size = que.size();\n            for (int s = 0; s < size; s++) {\n                int i = que.front().first.first;\n                int j = que.front().first.second;\n                int key = que.front().second;\n                que.pop();\n                \n                if ('a' <= grid[i][j] && grid[i][j] <= 'f\") {\n                    key |= 1 << (grid[i][j] - 'a\");\n                    if (key == target)\n                        return step;\n\n                    mapKey[i][j] |= 1l << key;\n                }\n\n                for (int d = 0; d < 4; d++) {\n                   \n                    int newj = j + dir[d][1];\n                    \n                    if (!(0 <= newi && newi < m && 0 <= newj && newj < n))\n                        continue;\n                        \n                    int val = grid[newi][newj];\n                    if (val == '#')\n                        continue;\n                        \n                    if ('A' <= val && val <= 'F' && (key & (1 << (val - 'A\"))) == 0)\n                        continue;\n                        \n                    if (mapKey[newi][newj] & (1l << key))\n                        continue;\n                        \n                     mapKey[newi][newj] |= 1l << (key+1);  \n                     que.emplace(pair<int, int>(newi, newj), key);\n                }\n            }\n            step++;\n        }\n        return -1;\n    }\n};\n"
    },
    {
        "slug": "reverse-odd-levels-of-binary-tree",
        "description": "Given the root of a perfect binary tree, reverse the node values at each odd level of the tree.\n\nFor example, suppose the node values at level 3 are [2,1,3,4,7,11,29,18], then it should become [18,29,11,7,4,3,1,2].\n\nReturn the root of the reversed tree.\nA binary tree is perfect if all parent nodes have two children and all leaves are on the same level.\nThe level of a node is the number of edges along the path between it and the root node.",
        "examples": [
            "Input: root = [2,3,5,8,13,21,34]\nOutput: [2,5,3,8,13,21,34]\nExplanation: \nThe tree has only one odd level.\nThe nodes at level 1 are 3, 5 respectively, which are reversed and become 5, 3.",
            "Input: root = [7,13,11]\nOutput: [7,11,13]\nExplanation: \nThe nodes at level 1 are 13, 11, which are reversed and become 11, 13.",
            "Input: root = [0,1,2,0,0,0,0,1,1,1,1,2,2,2,2]\nOutput: [0,2,1,0,0,0,0,2,2,2,2,1,1,1,1]\nExplanation: \nThe odd levels have non-zero values.\nThe nodes at level 1 were 1, 2, and are 2, 1 after the reversal.\nThe nodes at level 3 were 1, 1, 1, 1, 2, 2, 2, 2, and are 2, 2, 2, 2, 1, 1, 1, 1 after the reversal."
        ],
        "constraints": "The number of nodes in the tree is in the range [1, 214].\n0 <= Node.val <= 105\nroot is a perfect binary tree.",
        "oracle_code": "class Solution {\npublic:\n    TreeNode* reverseOddLevels(TreeNode* root) {\n        queue<TreeNode*> q;\n        q.push(root);\n        int x = 1,n,i,z;\n        vector<TreeNode*> tmp;\n        TreeNode* node;\n        while(!q.empty()){\n            tmp.clear();\n            n = q.size();\n            // cout<<n<<\" \";\n            while(n--){\n                node = q.front();q.pop();\n                // cout<<node->val<<\" \";\n                if(x==0){\n                    tmp.push_back(node);\n                }\n                if(node->left)\n                    q.push(node->left);\n                if(node->right){\n                    q.push(node->right);\n                }\n            }\n            n = tmp.size();\n            for(i = 0; i < n/2; i++){\n                z = tmp[i]->val;\n                tmp[i]->val = tmp[n-1-i]->val;\n                tmp[n-1-i]->val = z;\n            }\n            x ^= 1;\n            n = 0;\n        }\n        return root;\n    }\n};",
        "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* reverseOddLevels(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        int x = 1,n,i,z;\\n        vector<TreeNode*> tmp;\\n        TreeNode* node;\\n        while(!q.empty()){\\n            tmp.clear();\\n            n = q.size();\\n            // cout<<n<<\" \";\\n            while(n--){\\n                node = q.front();q.pop();\\n                // cout<<node->val<<\" \";\\n                if(x==0){\\n                    tmp.push_back(node);\\n                }\\n                if(node->left)\\n                    q.push(node->left);\\n                if(node->right){\\n                    q.push(node->right);\\n                }\\n            }\\n            n = tmp.size();\\n            for(i = 0; i < n/2; i++){\\n                z = tmp[i]->val;\\n                tmp[i]->val = tmp[n-1-i]->val;\\n                tmp[n-1-i]->val = z;\\n            }\\n            x ^= 1;\\n            n = 0;\\n        }\\n        return root;\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "indexing error",
            "wrong comment mark",
            "unclosed string",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    TreeNode* reverseOddLevels(TreeNode* root) {\n        queue<TreeNode*> q;\n        q.push(root);\n        int x = 1,n,i,z;\n        vector<TreeNode*> tmp;\n        TreeNode* node;\n        TreeNode* undefinedNode;\n        while(!q.empty()){\n            tmp.clear();\n            n = q.size();\n            while(n--){\n                node = q.front();q.pop();\n                if(x==0){\n                    tmp.push_back(undefinedNode);\n                }\n                if(node->left)\n                    q.push(node->left);\n                if(node->right){\n                    q.push(node->right);\n                }\n            }\n            n = tmp.size();\n            for(i = 0; i <= n/2; i++){\n                z = tmp[i]->val;\n                tmp[i]->val = tmp[n-1-i]->val;\n                tmp[n-1-i]->val = \"z;\n            }\n            x ^= 1;\n            n = 0;\n        }\n        return root;\n    }\n};\n"
    },
    {
        "slug": "maximum-rows-covered-by-columns",
        "description": "You are given a 0-indexed m x n binary matrix matrix and an integer numSelect, which denotes the number of distinct columns you must select from matrix.\nLet us consider s = {c1, c2, ...., cnumSelect} as the set of columns selected by you. A row row is covered by s if:\n\nFor each cell matrix[row][col] (0 <= col <= n - 1) where matrix[row][col] == 1, col is present in s or,\nNo cell in row has a value of 1.\n\nYou need to choose numSelect columns such that the number of rows that are covered is maximized.\nReturn the maximum number of rows that can be covered by a set of numSelect columns.",
        "examples": [
            "Input: matrix = [[0,0,0],[1,0,1],[0,1,1],[0,0,1]], numSelect = 2\nOutput: 3\nExplanation: One possible way to cover 3 rows is shown in the diagram above.\nWe choose s = {0, 2}.\n- Row 0 is covered because it has no occurrences of 1.\n- Row 1 is covered because the columns with value 1, i.e. 0 and 2 are present in s.\n- Row 2 is not covered because matrix[2][1] == 1 but 1 is not present in s.\n- Row 3 is covered because matrix[2][2] == 1 and 2 is present in s.\nThus, we can cover three rows.\nNote that s = {1, 2} will also cover 3 rows, but it can be shown that no more than three rows can be covered.",
            "Input: matrix = [[1],[0]], numSelect = 1\nOutput: 2\nExplanation: Selecting the only column will result in both rows being covered since the entire matrix is selected.\nTherefore, we return 2."
        ],
        "constraints": "m == matrix.length\nn == matrix[i].length\n1 <= m, n <= 12\nmatrix[i][j] is either 0 or 1.\n1 <= numSelect\u00a0<= n",
        "oracle_code": "class Solution {\npublic:\n    // Global Vector to all possible column combinations\n    vector<vector<int>>comb;\n\t\n    // Function to find the number of rows a particular column combination can capture\n    int find(vector<vector<int>>& mat1)\n    {\n        int c = 0;\n        for(int i = 0; i < mat1.size(); i++)\n        {\n            int flg = 0;\n            for(int j = 0; j < mat1[0].size(); j++)\n                if(mat1[i][j] == 1)\n                    flg = 1;\n            if(flg == 0)\n                c++;\n        }\n        return c;\n    }\n    \n\t// Function to Traverse for each Column Combination Present\n    int find_ans(vector<vector<int>>& mat)\n    {\n        int ans = 0;\n        for(int i = 0; i < comb.size(); i++)\n        {\n            vector<int>temp = comb[i];\n            vector<vector<int>> mat1 = mat;\n            for(int j = 0; j < temp.size(); j++)\n            {\n                int col_val = temp[j];\n                for(int k = 0; k < mat1.size(); k++)\n                    mat1[k][col_val] = 0;\n            }\n            ans = max(ans, find(mat1));\n        }\n        return ans;\n    }\n    // Function to Find all possible column combinations\n    void helper(vector<vector<int>>& mat, int cols, int count, int idx, vector<int>tans)\n    {\n        int col = mat[0].size();\n        if(count == cols)\n        {\n            comb.push_back(tans);\n            return;\n        }\n        if(idx >= col)\n            return;\n        \n        helper(mat, cols, count, idx+1, tans);\n        tans.push_back(idx);\n        helper(mat, cols, count+1, idx+1, tans);\n    }\n    \n    int maximumRows(vector<vector<int>>& mat, int cols) {\n        \n        vector<int>tans;\n        helper(mat, cols, 0, 0, tans);\n        return find_ans(mat);\n    }\n};",
        "content": "```\\nclass Solution {\\npublic:\\n    // Global Vector to all possible column combinations\\n    vector<vector<int>>comb;\\n\\t\\n    // Function to find the number of rows a particular column combination can capture\\n    int find(vector<vector<int>>& mat1)\\n    {\\n        int c = 0;\\n        for(int i = 0; i < mat1.size(); i++)\\n        {\\n            int flg = 0;\\n            for(int j = 0; j < mat1[0].size(); j++)\\n                if(mat1[i][j] == 1)\\n                    flg = 1;\\n            if(flg == 0)\\n                c++;\\n        }\\n        return c;\\n    }\\n    \\n\\t// Function to Traverse for each Column Combination Present\\n    int find_ans(vector<vector<int>>& mat)\\n    {\\n        int ans = 0;\\n        for(int i = 0; i < comb.size(); i++)\\n        {\\n            vector<int>temp = comb[i];\\n            vector<vector<int>> mat1 = mat;\\n            for(int j = 0; j < temp.size(); j++)\\n            {\\n                int col_val = temp[j];\\n                for(int k = 0; k < mat1.size(); k++)\\n                    mat1[k][col_val] = 0;\\n            }\\n            ans = max(ans, find(mat1));\\n        }\\n        return ans;\\n    }\\n    // Function to Find all possible column combinations\\n    void helper(vector<vector<int>>& mat, int cols, int count, int idx, vector<int>tans)\\n    {\\n        int col = mat[0].size();\\n        if(count == cols)\\n        {\\n            comb.push_back(tans);\\n            return;\\n        }\\n        if(idx >= col)\\n            return;\\n        \\n        helper(mat, cols, count, idx+1, tans);\\n        tans.push_back(idx);\\n        helper(mat, cols, count+1, idx+1, tans);\\n    }\\n    \\n    int maximumRows(vector<vector<int>>& mat, int cols) {\\n        \\n        vector<int>tans;\\n        helper(mat, cols, 0, 0, tans);\\n        return find_ans(mat);\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "== and = confusion",
            "variable value error",
            "parentheses mismatch",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    vector<vector<int>>comb = undefined_object;    \n    int find(vector<vector<int>>& mat1)\n    {\n        int c = 0;\n        for(int i = 0; i < mat1.size(); i++)\n        {\n            int flg = 0;\n            for(int j = 0; j < mat1[0].size(); j++\n                if(mat1[i][j] = 1)\n                    flg = 1;\n            if(flg == 0)\n                c++;\n        }\n        return c;\n    }\n    int find_ans(vector<vector<int>>& mat)\n    {\n        int ans = 0;\n        for(int i = 0; i < comb.size(); i++)\n        {\n            vector<int>temp = comb[i];\n            vector<vector<int>> mat1 = mat;\n            for(int j = 0; j < temp.size(); j++)\n            {\n                int col_val = temp[j];\n                for(int k = 0; k < mat1.size(); k++)\n                    mat1[k][col_val] = 1;\n            }\n            ans = max(ans, find(mat1));\n        }\n        return ans;\n    }\n    void helper(vector<vector<int>>& mat, int cols, int count, int idx, vector<int>tans)\n    {\n        int col = mat[0].size();\n        if(count == cols)\n        {\n            comb.push_back(tans);\n            return;\n        }\n        if(idx >= col)\n            return;\n        \n        helper(mat, cols, count, idx+1, tans);\n        tans.push_back(idx);\n        helper(mat, cols, count+1, idx+1, tans);\n    }\n    int maximumRows(vector<vector<int>>& mat, int cols) {\n        vector<int>tans;\n        helper(mat, cols, 0, 0, tans);\n        return find_ans(mat);\n    }\n};\n"
    },
    {
        "slug": "longest-common-prefix",
        "description": "Write a function to find the longest common prefix string amongst an array of strings.\nIf there is no common prefix, return an empty string \"\".",
        "examples": [
            "Input: strs = [\"flower\",\"flow\",\"flight\"]\nOutput: \"fl\"",
            "Input: strs = [\"dog\",\"racecar\",\"car\"]\nOutput: \"\"\nExplanation: There is no common prefix among the input strings."
        ],
        "constraints": "1 <= strs.length <= 200\n0 <= strs[i].length <= 200\nstrs[i] consists of only lowercase English letters.",
        "oracle_code": "class Solution {\npublic:\n    string longestCommonPrefix(vector<string>& str) \n    {\n        sort(str.begin(), str.end()); //sorting the array\n        string ans=\"\"; //creating a new empty string to store the common prefixes\n        for(int i=0;i<str[0].length();i++) // max iterations = length of the first string\n        {\n            if(str[0][i]!=str[str.size()-1][i]) // checking the characters of the first and last string\n                break;\n            ans+=str[0][i]; // concatinate if the characters are matching\n        }\n        return ans;\n    }\n};",
        "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWhen you sort an array, it is enough to check for the common characters of the the first & last string of the sorted vector.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& str) \\n    {\\n        sort(str.begin(), str.end()); //sorting the array\\n        string ans=\"\"; //creating a new empty string to store the common prefixes\\n        for(int i=0;i<str[0].length();i++) // max iterations = length of the first string\\n        {\\n            if(str[0][i]!=str[str.size()-1][i]) // checking the characters of the first and last string\\n                break;\\n            ans+=str[0][i]; // concatinate if the characters are matching\\n        }\\n        return ans;\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "statement separation",
            "unclosed string",
            "conditional statement error",
            "colon missing"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    string longestCommonPrefix(vector<string>& str) \n    {\n        sort(str.begin(), str.end()); //sorting the array\n        string ans=\"; \n        for(int i=0;i<str[0].length();i++) // max iterations = length of the first string\n            if(str[0][i]!=str[str.size()][i]) \n                break;\n        ans+=str[0][i]; \n        return ans;\n    }\n};\n"
    },
    {
        "slug": "relative-ranks",
        "description": "You are given an integer array score of size n, where score[i] is the score of the ith athlete in a competition. All the scores are guaranteed to be unique.\nThe athletes are placed based on their scores, where the 1st place athlete has the highest score, the 2nd place athlete has the 2nd highest score, and so on. The placement of each athlete determines their rank:\n\nThe 1st place athlete's rank is \"Gold Medal\".\nThe 2nd place athlete's rank is \"Silver Medal\".\nThe 3rd place athlete's rank is \"Bronze Medal\".\nFor the 4th place to the nth place athlete, their rank is their placement number (i.e., the xth place athlete's rank is \"x\").\n\nReturn an array answer of size n where answer[i] is the rank of the ith athlete.",
        "examples": [
            "Input: score = [5,4,3,2,1]\nOutput: [\"Gold Medal\",\"Silver Medal\",\"Bronze Medal\",\"4\",\"5\"]\nExplanation: The placements are [1st, 2nd, 3rd, 4th, 5th].",
            "Input: score = [10,3,8,9,4]\nOutput: [\"Gold Medal\",\"5\",\"Bronze Medal\",\"Silver Medal\",\"4\"]\nExplanation: The placements are [1st, 5th, 3rd, 2nd, 4th]."
        ],
        "constraints": "n == score.length\n1 <= n <= 104\n0 <= score[i] <= 106\nAll the values in score are unique.",
        "oracle_code": "class Solution {\npublic:\n    vector<string> findRelativeRanks(vector<int>& score) {\n        int n = score.size();\n        \n        vector<pair<int, int>> arr;\n        for (int i=0; i<n; i++) arr.push_back({score[i], i});\n\n        sort(rbegin(arr), rend(arr));\n\n        vector<string> res(n);\n        for (int i=0; i<n; i++) \n            res[arr[i].second] = i==0? \"Gold Medal\": (i==1? \"Silver Medal\": (i==2? \"Bronze Medal\": to_string(i+1)));\n\n        return res;\n    }\n};",
        "content": "**vector solution**\\n```\\nclass Solution {\\npublic:\\n    vector<string> findRelativeRanks(vector<int>& score) {\\n        int n = score.size();\\n        \\n        vector<pair<int, int>> arr;\\n        for (int i=0; i<n; i++) arr.push_back({score[i], i});\\n\\n        sort(rbegin(arr), rend(arr));\\n\\n        vector<string> res(n);\\n        for (int i=0; i<n; i++) \\n            res[arr[i].second] = i==0? \"Gold Medal\": (i==1? \"Silver Medal\": (i==2? \"Bronze Medal\": to_string(i+1)));\\n\\n        return res;\\n    }\\n};\\n```\\n---\\n**priority queue solution**\\n```\\nclass Solution {\\npublic:\\n    vector<string> findRelativeRanks(vector<int>& score) {\\n        int n = score.size();\\n        \\n        priority_queue< pair<int, int>, vector<pair<int,int>> > pq;\\n        for (int i=0; i<n; i++) pq.push({score[i], i});\\n\\n        vector<string> res(n);\\n        while (!pq.empty()) {\\n            auto x = pq.top();\\n            int size = pq.size();\\n            res[x.second] = (size == n? \"Gold Medal\": (size == n-1? \"Silver Medal\": (size == n-2? \"Bronze Medal\": to_string(n-size+1))));\\n            pq.pop();\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "other error",
            "unclosed string",
            "undefined keywords from other languages",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    vector<string> findRelativeRanks(vector<int>& score) {\n        int n = score.size();\n        \n        vector<pair<int, int>> arr;\n        for (int i=0; i<n; i++) arr.push_back({score[i], i});\n\n        sort(rbegin(arr), rend(arr));\n        \n        vector<string> rank;\n\n        for (int i=0; i<n; i++) \n            rank[arr[i].second] = i==0? \"Gold Medal: (i==1? \"Silver Medal\": (i==2? \"Bronze Medal\": to_s(i+1)));\n\n        res[arr[0].second] = \"LeanBack Medal\";\n        return rank;\n    }\n};\n"
    },
    {
        "slug": "climbing-stairs",
        "description": "You are climbing a staircase. It takes n steps to reach the top.\nEach time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?",
        "examples": [
            "Input: n = 2\nOutput: 2\nExplanation: There are two ways to climb to the top.\n1. 1 step + 1 step\n2. 2 steps",
            "Input: n = 3\nOutput: 3\nExplanation: There are three ways to climb to the top.\n1. 1 step + 1 step + 1 step\n2. 1 step + 2 steps\n3. 2 steps + 1 step"
        ],
        "constraints": "1 <= n <= 45",
        "oracle_code": "class Solution {\npublic:\n    int solve(int n,vector<int> &dp){\n        //base case\n        if(n<=2)\n          return n;\n        \n        if(dp[n]!=-1) \n          return dp[n]; \n        \n        dp[n]=solve(n-1,dp)+solve(n-2,dp);\n        return dp[n];\n    }\n    int climbStairs(int n) {\n        if(n<=2)\n         return n;\n        vector<int> dp(n+1);\n        for(int i=0;i<=n;i++)\n         dp[i]=-1;\n        \n        return solve(n,dp);\n    }\n};",
        "content": "# Intuition\\nUsing Top - Down Approach -> Recursion + Memorization.\\n\\n# Approach\\nStoring the values of overlapping sub - problems in a vector.\\n\\n# Complexity\\n- Time complexity:\\nO(n) -> As we are visiting all values of n atleast 1 time.\\n\\n- Space complexity:\\nO(n) + O(n)  - > (Recursive calls + Array of size n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int n,vector<int> &dp){\\n        //base case\\n        if(n<=2)\\n          return n;\\n        \\n        if(dp[n]!=-1) \\n          return dp[n]; \\n        \\n        dp[n]=solve(n-1,dp)+solve(n-2,dp);\\n        return dp[n];\\n    }\\n    int climbStairs(int n) {\\n        if(n<=2)\\n         return n;\\n        vector<int> dp(n+1);\\n        for(int i=0;i<=n;i++)\\n         dp[i]=-1;\\n        \\n        return solve(n,dp);\\n    }\\n};\\n```\\n\\n# Intuition\\nUsing Bottom - up Approach -> Tabulation.\\n\\n# Approach\\nStoring the values of overlapping sub - problems in a vector.\\n\\n# Complexity\\n- Time complexity:\\nO(n) -> As we are traversing the vector atleast 1 time.\\n\\n- Space complexity:\\nO(n) - > (Array of size n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n<=2)\\n         return n;\\n        vector<int> dp(n+1);\\n        dp[0]=0;\\n        dp[1]=1;\\n        dp[2]=2;\\n        for(int i=3;i<=n;i++)\\n         dp[i]=dp[i-1]+dp[i-2];\\n        \\n        return dp[n];\\n    }\\n};\\n```\\n\\n# Python Code :\\nContributed by : Aarya_R\\n\\n# Complexity\\n- Time complexity:\\nO(n) -> As we are traversing the vector atleast 1 time.\\n\\n- Space complexity:\\nO(1) \\n```\\ndef climbStairs(self, n):\\n        prev = 1\\n        prev2 = 0\\n        for i in range(1, n+1):\\n            curi = prev + prev2\\n            prev2 = prev\\n            prev = curi\\n        return prev \\n```\\n![upvote.jfif](https://assets.leetcode.com/users/images/995d917b-6ea2-4b6b-8baa-6ce7bc6441fd_1676965776.537627.jpeg)\\n\\n",
        "level": "easy",
        "type": [
            "indexing error",
            "operation error",
            "wrong comment mark",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    int solve(int n,vector<int> &dp){\n        /*base case\n        if(n<=2)\n          return n;\n        \n        if(dp[n]!=-1) \n          return dp[n]; \n        \n        dp[n]=solve(n-1,dp)+solve(n-3,dp); \n        return dp[n];\n    }\n    int climbStairs(int n) {\n        if(n<=2)\n         return n;\n        array<int> dp(n);\n        for(int i=0;i<=n;i++)\n         dp[i]=-1;\n        \n        return solve(n,dp);\n    }\n};\n"
    },
    {
        "slug": "search-in-a-binary-search-tree",
        "description": "You are given the root of a binary search tree (BST) and an integer val.\nFind the node in the BST that the node's value equals val and return the subtree rooted with that node. If such a node does not exist, return null.",
        "examples": [
            "Input: root = [4,2,7,1,3], val = 2\nOutput: [2,1,3]",
            "Input: root = [4,2,7,1,3], val = 5\nOutput: []"
        ],
        "constraints": "The number of nodes in the tree is in the range [1, 5000].\n1 <= Node.val <= 107\nroot is a binary search tree.\n1 <= val <= 107",
        "oracle_code": "class Solution {\npublic:\n    TreeNode* searchBST(TreeNode* root, int val) {\n       if(root==NULL) \n       return NULL;\n       if(root->val==val)\n       {\n           return root;\n       }\n       if(root->val>val){\n          return  searchBST(root->left,val);\n       }\n        return searchBST(root->right,val);\n    }\n};",
        "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n       if(root==NULL) \\n       return NULL;\\n       if(root->val==val)\\n       {\\n           return root;\\n       }\\n       if(root->val>val){\\n          return  searchBST(root->left,val);\\n       }\\n        return searchBST(root->right,val);\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "wrong comment mark",
            "conditional statement error",
            "undefined keywords from other languages",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    /* \n    TreeNode* searchBST(TreeNode* root, int val) {\n       if(root==None) \n       return NULL;\n       if(root->val==val)\n       {\n           return root;\n       }\n       if(root->val > val)){\n          return searchBST(root->right,val);\n       }\n        return searchBST(root->left,val);\n    }\n    */\n};\n"
    },
    {
        "slug": "factorial-trailing-zeroes",
        "description": "Given an integer n, return the number of trailing zeroes in n!.\nNote that n! = n * (n - 1) * (n - 2) * ... * 3 * 2 * 1.",
        "examples": [
            "Input: n = 3\nOutput: 0\nExplanation: 3! = 6, no trailing zero.",
            "Input: n = 5\nOutput: 1\nExplanation: 5! = 120, one trailing zero.",
            "Input: n = 0\nOutput: 0"
        ],
        "constraints": "0 <= n <= 104",
        "oracle_code": "class Solution {\npublic:\n    unordered_map<long long int,long long int>mp;\n    int trailingZeroes(int n) {\n        for(int i=n;i>=1;i--)\n         fun(i);\n         \n\t\t return min(mp[2],mp[5]); \n    }\n     void fun(int n)\n    {\n         for(int i=2;i*i<=n;i++)\n         {\n         \twhile((n%i) == 0)\n         \t{\n         \t    mp[i]++;\n\t\t\t\tn = n / i;\t\n\t\t\t}\n\t\t }\n\t\t if(n > 1)\n\t\t mp[n]++;\n    }\n};",
        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    unordered_map<long long int,long long int>mp;\\n    int trailingZeroes(int n) {\\n        for(int i=n;i>=1;i--)\\n         fun(i);\\n         \\n\\t\\t return min(mp[2],mp[5]); \\n    }\\n     void fun(int n)\\n    {\\n         for(int i=2;i*i<=n;i++)\\n         {\\n         \\twhile((n%i) == 0)\\n         \\t{\\n         \\t    mp[i]++;\\n\\t\\t\\t\\tn = n / i;\\t\\n\\t\\t\\t}\\n\\t\\t }\\n\\t\\t if(n > 1)\\n\\t\\t mp[n]++;\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "operation error",
            "wrong comment mark",
            "colon missing",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    unordered_map<long long int,long long int>mp\n    int trailingZeroes(int n) {\n        for(int i=n;i>=1;i--)\n        \n         \n\t\t Solution s;\n\t\t return s.max(mp[2],mp[5]); \n    }\n     void fun(int n)\n    {\n         for(int i=2;i*i<=n;i++)\n         {\n         \twhile((n%i) == 0)\n         \t{\n         \t    mp[i]++;\n\t\t\t\tn = n / i;\t\n\t\t\t}\n\t\t }\n\t\t if(n > 1)\n\t\t mp[n]++;\n    }\n};\n"
    },
    {
        "slug": "longest-common-prefix",
        "description": "Write a function to find the longest common prefix string amongst an array of strings.\nIf there is no common prefix, return an empty string \"\".",
        "examples": [
            "Input: strs = [\"flower\",\"flow\",\"flight\"]\nOutput: \"fl\"",
            "Input: strs = [\"dog\",\"racecar\",\"car\"]\nOutput: \"\"\nExplanation: There is no common prefix among the input strings."
        ],
        "constraints": "1 <= strs.length <= 200\n0 <= strs[i].length <= 200\nstrs[i] consists of only lowercase English letters.",
        "oracle_code": "class Solution {\npublic:\n    string longestCommonPrefix(vector<string>& str) \n    {\n        sort(str.begin(), str.end()); //sorting the array\n        string ans=\"\"; //creating a new empty string to store the common prefixes\n        for(int i=0;i<str[0].length();i++) // max iterations = length of the first string\n        {\n            if(str[0][i]!=str[str.size()-1][i]) // checking the characters of the first and last string\n                break;\n            ans+=str[0][i]; // concatinate if the characters are matching\n        }\n        return ans;\n    }\n};",
        "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWhen you sort an array, it is enough to check for the common characters of the the first & last string of the sorted vector.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& str) \\n    {\\n        sort(str.begin(), str.end()); //sorting the array\\n        string ans=\"\"; //creating a new empty string to store the common prefixes\\n        for(int i=0;i<str[0].length();i++) // max iterations = length of the first string\\n        {\\n            if(str[0][i]!=str[str.size()-1][i]) // checking the characters of the first and last string\\n                break;\\n            ans+=str[0][i]; // concatinate if the characters are matching\\n        }\\n        return ans;\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "statement separation",
            "unclosed string",
            "colon missing",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    string longestCommonPrefix(vector<string>& str) \n    {\n        sort(str.begin(), str.end()); //sorting the array\n        string ans=\"; \n        for(int i=0;i<str[0].length();i) \n            if(str[0][i]!=str[str.size()-1][i]) //]\n                break;\n        ans+=str[0][i]; \n        return ans;\n    }\n};\n"
    },
    {
        "slug": "factorial-trailing-zeroes",
        "description": "Given an integer n, return the number of trailing zeroes in n!.\nNote that n! = n * (n - 1) * (n - 2) * ... * 3 * 2 * 1.",
        "examples": [
            "Input: n = 3\nOutput: 0\nExplanation: 3! = 6, no trailing zero.",
            "Input: n = 5\nOutput: 1\nExplanation: 5! = 120, one trailing zero.",
            "Input: n = 0\nOutput: 0"
        ],
        "constraints": "0 <= n <= 104",
        "oracle_code": "class Solution {\npublic:\n    unordered_map<long long int,long long int>mp;\n    int trailingZeroes(int n) {\n        for(int i=n;i>=1;i--)\n         fun(i);\n         \n\t\t return min(mp[2],mp[5]); \n    }\n     void fun(int n)\n    {\n         for(int i=2;i*i<=n;i++)\n         {\n         \twhile((n%i) == 0)\n         \t{\n         \t    mp[i]++;\n\t\t\t\tn = n / i;\t\n\t\t\t}\n\t\t }\n\t\t if(n > 1)\n\t\t mp[n]++;\n    }\n};",
        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    unordered_map<long long int,long long int>mp;\\n    int trailingZeroes(int n) {\\n        for(int i=n;i>=1;i--)\\n         fun(i);\\n         \\n\\t\\t return min(mp[2],mp[5]); \\n    }\\n     void fun(int n)\\n    {\\n         for(int i=2;i*i<=n;i++)\\n         {\\n         \\twhile((n%i) == 0)\\n         \\t{\\n         \\t    mp[i]++;\\n\\t\\t\\t\\tn = n / i;\\t\\n\\t\\t\\t}\\n\\t\\t }\\n\\t\\t if(n > 1)\\n\\t\\t mp[n]++;\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "statement separation",
            "operation error",
            "wrong comment mark",
            "colon missing"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    unordered_map<long long int,long long int>mp\n    int trailingZeroes(int n) {\n        for(int i=n;i>=1;i--)\n         fun(i);\n         \n\t\t return max(mp[2],mp[5]); \n    }\n     void fun(int n)\n    {\n         for(int i=2;i*i<=n;i++)\n         {\n         \twhile((n%i) == 0)\n         \t{\n         \t    mp[i]++;\n\t\t\t\tn = n / i;\t\n\t\t\t}\n\t\t }\n\t\t if(n > 1)\n\t\t mp[n]++;\n    }\n};\n"
    },
    {
        "slug": "longest-ideal-subsequence",
        "description": "You are given a string s consisting of lowercase letters and an integer k. We call a string t ideal if the following conditions are satisfied:\n\nt is a subsequence of the string s.\nThe absolute difference in the alphabet order of every two adjacent letters in t is less than or equal to k.\n\nReturn the length of the longest ideal string.\nA subsequence is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.\nNote that the alphabet order is not cyclic. For example, the absolute difference in the alphabet order of 'a' and 'z' is 25, not 1.",
        "examples": [
            "Input: s = \"acfgbd\", k = 2\nOutput: 4\nExplanation: The longest ideal string is \"acbd\". The length of this string is 4, so 4 is returned.\nNote that \"acfgbd\" is not ideal because 'c' and 'f' have a difference of 3 in alphabet order.",
            "Input: s = \"abcd\", k = 3\nOutput: 4\nExplanation: The longest ideal string is \"abcd\". The length of this string is 4, so 4 is returned."
        ],
        "constraints": "1 <= s.length <= 105\n0 <= k <= 25\ns consists of lowercase English letters.",
        "oracle_code": "class Solution {\n\n\n   int SolveByMemo(string &s , int &k , int index , int prev , vector<vector<int>> &dp)\n   {\n       if(index == s.length())\n       return 0;\n\n       if(dp[index][prev] != -1)\n       return dp[index][prev];\n\n       int op1 = 0 + SolveByMemo(s, k , index+1 , prev , dp);\n\n       int op2 = 0 ;\n\n       if(prev == 26)\n       op2 = 1 + SolveByMemo(s, k , index+1 , s[index]-'a' , dp);\n       else if(abs(s[index]-'a' - prev) <= k)\n       op2 = 1 + SolveByMemo(s, k , index+1 , s[index]-'a' , dp);\n\n       return dp[index][prev] = max(op1 , op2);\n   }\n\n   int SolveByTab(string &s , int &k )\n   {\n        vector<vector<int>> dp(s.length()+1 , vector<int> (27, 0));\n       \n        for(int index = s.length()-1 ; index>=0 ; index--)\n        {\n            for(int prev = 0 ; prev<= 26 ; prev++)\n            {\n                int op1 = 0 + dp[index+1][prev];\n                int op2 = 0 ;\n\n               if(prev == 26)\n               op2 = 1 + dp[index+1][s[index]-'a'];\n               else if(abs(s[index]-'a' - prev) <= k)\n               op2 = 1 + dp[index+1][s[index]-'a'];\n\n               dp[index][prev] = max(op1 , op2);\n            }\n        }\n\n       return max(dp[0][s[0]-'a'] , dp[0][26]);\n   }\n\n   int SolveByTabSpaceOptimised(string &s , int &k )\n   {\n        vector<int> next(27, 0) ;\n        vector<int> curr(27, 0);\n       \n        for(int index = s.length()-1 ; index>=0 ; index--)\n        {\n            for(int prev = 0 ; prev<= 26 ; prev++)\n            {\n                int op1 = 0 + next[prev];\n                int op2 = 0 ;\n\n               if(prev == 26)\n               op2 = 1 + next[s[index]-'a'];\n               else if(abs(s[index]-'a' - prev) <= k)\n               op2 = 1 + next[s[index]-'a'];\n\n               curr[prev] = max(op1 , op2);\n            }\n            next = curr;\n        }\n\n       return max(curr[s[0]-'a'] , curr[26]);\n   }\n\npublic:\n    int longestIdealString(string s, int k) {\n        \n        // 1. Recursion + Memoization || Top Down Approach\n        // vector<vector<int>> dp(s.length() , vector<int> (27, -1));\n        // return SolveByMemo(s, k , 0 , 26, dp);\n\n        // 2. Tabulation Method || Bottom Up Approach\n        // return SolveByTab(s, k);\n\n        // 3. Space Optimisation using Tabulation\n        return SolveByTabSpaceOptimised(s , k);\n    }\n};",
        "content": "\\n# Approach\\nWe Have Use Three Different Approaches :\\n1. Recursion + Memoization \\n    TC : O(n^2) , SC : O(n)\\n2. Tabulation Method \\n    TC : O(n^2) , SC : O(n)\\n3.  Tabulatuon With SOace Optimised\\n    TC : O(n^2) , SC : O(1) \\n\\n\\n#Note\\nSC In first two methods is On) and not O(n^2) as size is fixed to 27 for each index hence it is Linear Space ,Similarly for 3rd Method we have optimised to constant space as at any instant we onlt need memory of next 27 blocks  only.\\n\\n#Hope You Liekd It and Upvote are appreciated \\n\\n# Code\\n```\\nclass Solution {\\n\\n\\n   int SolveByMemo(string &s , int &k , int index , int prev , vector<vector<int>> &dp)\\n   {\\n       if(index == s.length())\\n       return 0;\\n\\n       if(dp[index][prev] != -1)\\n       return dp[index][prev];\\n\\n       int op1 = 0 + SolveByMemo(s, k , index+1 , prev , dp);\\n\\n       int op2 = 0 ;\\n\\n       if(prev == 26)\\n       op2 = 1 + SolveByMemo(s, k , index+1 , s[index]-\\'a\\' , dp);\\n       else if(abs(s[index]-\\'a\\' - prev) <= k)\\n       op2 = 1 + SolveByMemo(s, k , index+1 , s[index]-\\'a\\' , dp);\\n\\n       return dp[index][prev] = max(op1 , op2);\\n   }\\n\\n   int SolveByTab(string &s , int &k )\\n   {\\n        vector<vector<int>> dp(s.length()+1 , vector<int> (27, 0));\\n       \\n        for(int index = s.length()-1 ; index>=0 ; index--)\\n        {\\n            for(int prev = 0 ; prev<= 26 ; prev++)\\n            {\\n                int op1 = 0 + dp[index+1][prev];\\n                int op2 = 0 ;\\n\\n               if(prev == 26)\\n               op2 = 1 + dp[index+1][s[index]-\\'a\\'];\\n               else if(abs(s[index]-\\'a\\' - prev) <= k)\\n               op2 = 1 + dp[index+1][s[index]-\\'a\\'];\\n\\n               dp[index][prev] = max(op1 , op2);\\n            }\\n        }\\n\\n       return max(dp[0][s[0]-\\'a\\'] , dp[0][26]);\\n   }\\n\\n   int SolveByTabSpaceOptimised(string &s , int &k )\\n   {\\n        vector<int> next(27, 0) ;\\n        vector<int> curr(27, 0);\\n       \\n        for(int index = s.length()-1 ; index>=0 ; index--)\\n        {\\n            for(int prev = 0 ; prev<= 26 ; prev++)\\n            {\\n                int op1 = 0 + next[prev];\\n                int op2 = 0 ;\\n\\n               if(prev == 26)\\n               op2 = 1 + next[s[index]-\\'a\\'];\\n               else if(abs(s[index]-\\'a\\' - prev) <= k)\\n               op2 = 1 + next[s[index]-\\'a\\'];\\n\\n               curr[prev] = max(op1 , op2);\\n            }\\n            next = curr;\\n        }\\n\\n       return max(curr[s[0]-\\'a\\'] , curr[26]);\\n   }\\n\\npublic:\\n    int longestIdealString(string s, int k) {\\n        \\n        // 1. Recursion + Memoization || Top Down Approach\\n        // vector<vector<int>> dp(s.length() , vector<int> (27, -1));\\n        // return SolveByMemo(s, k , 0 , 26, dp);\\n\\n        // 2. Tabulation Method || Bottom Up Approach\\n        // return SolveByTab(s, k);\\n\\n        // 3. Space Optimisation using Tabulation\\n        return SolveByTabSpaceOptimised(s , k);\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "indexing error",
            "wrong comment mark",
            "variable value error",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution {   int SolveByMemo(string &s , int &k , int index , int prev , vector<vector<int>> &dp)\n   {\n       \n       if(dp[index+1][prev] != -1)\n       return dp[index+1][prev];\n\n       \n/**/prv\n   }\n\n   prev];\n               else if(abs(-prv)<= k)\n               op2 = 1 + dp[ndex+1][];\n dp[index][prev] = max(op1 ,);\n        }\n        }\n\n       rtur ma(dp[0][s[0publc:\n    i longestIdealString(string s, int k) {\n        \n        // 1. Recursion + Memoization || Top Down Approach\n        // vector<vector<int>> dp(s.length() , vector<int> (27, -1));\n        // return SolveByMemo(s, k , 0 , 26, dp);\n\n        // 2. Tabulation Mestring()Bttm Up"
    },
    {
        "slug": "check-knight-tour-configuration",
        "description": "There is a knight on an n x n chessboard. In a valid configuration, the knight starts at the top-left cell of the board and visits every cell on the board exactly once.\nYou are given an n x n integer matrix grid consisting of distinct integers from the range [0, n * n - 1] where grid[row][col] indicates that the cell (row, col) is the grid[row][col]th cell that the knight visited. The moves are 0-indexed.\nReturn true if grid represents a valid configuration of the knight's movements or false otherwise.\nNote that a valid knight move consists of moving two squares vertically and one square horizontally, or two squares horizontally and one square vertically. The figure below illustrates all the possible eight moves of a knight from some cell.",
        "examples": [
            "Input: grid = [[0,11,16,5,20],[17,4,19,10,15],[12,1,8,21,6],[3,18,23,14,9],[24,13,2,7,22]]\nOutput: true\nExplanation: The above diagram represents the grid. It can be shown that it is a valid configuration.",
            "Input: grid = [[0,3,6],[5,8,1],[2,7,4]]\nOutput: false\nExplanation: The above diagram represents the grid. The 8th move of the knight is not valid considering its position after the 7th move."
        ],
        "constraints": "n == grid.length == grid[i].length\n3 <= n <= 7\n0 <= grid[row][col] < n * n\nAll integers in grid are unique.",
        "oracle_code": "class Solution {\nprivate:\n    bool helper(vector<vector<int>>& grid, int row, int col, int num){\n        int n = grid.size();\n        if(num == n*n) return true;\n        int i = row-2;\n        int j = col+1;\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row-2;\n        j = col-1;\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 2;\n        j = col - 1;\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 2;\n        j = col + 1;\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 1;\n        j = col + 2;\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row - 1;\n        j = col + 2;\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row - 1;\n        j = col - 2;\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 1;\n        j = col - 2;\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        return false;\n    }\npublic:\n    bool checkValidGrid(vector<vector<int>>& grid) {\n        ios::sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);\n        if(grid[0][0] != 0) return false;\n        return helper(grid,0,0,1);\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    bool helper(vector<vector<int>>& grid, int row, int col, int num){\\n        int n = grid.size();\\n        if(num == n*n) return true;\\n        int i = row-2;\\n        int j = col+1;\\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row-2;\\n        j = col-1;\\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row + 2;\\n        j = col - 1;\\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row + 2;\\n        j = col + 1;\\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row + 1;\\n        j = col + 2;\\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row - 1;\\n        j = col + 2;\\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row - 1;\\n        j = col - 2;\\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row + 1;\\n        j = col - 2;\\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        return false;\\n    }\\npublic:\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(0);\\n        cout.tie(0);\\n        if(grid[0][0] != 0) return false;\\n        return helper(grid,0,0,1);\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "== and = confusion",
            "operation error",
            "wrong comment mark",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution {\nprivate:\n    bool helper(vector<vector<int>>& grid, int row, int col, int num){\n        int n \n\n        undefinedObject test;  \n\n        if(num = n*n) return true;\n        int i = row-2;\n        int j = col+1;\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row-2;\n        j = col-1;\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+2);\n\n        i = row + 2;\n        j = col - 1;\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 2;\n        j = col + 1;\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 1;\n        j = col + 2;\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row - 1;\n        j = col + 2;\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row - 1;\n        j = col - 2;\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 1;\n        j = col - 2;\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        return false;\n    }\npublic:\n    bool checkValidGrid(vector<vector<int>>& grid) {\n        ios::sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);\n        if(grid[0][0] != 0) return false;\n        return helper(grid,0,0,1);\n    }\n};\n"
    },
    {
        "slug": "longest-common-prefix",
        "description": "Write a function to find the longest common prefix string amongst an array of strings.\nIf there is no common prefix, return an empty string \"\".",
        "examples": [
            "Input: strs = [\"flower\",\"flow\",\"flight\"]\nOutput: \"fl\"",
            "Input: strs = [\"dog\",\"racecar\",\"car\"]\nOutput: \"\"\nExplanation: There is no common prefix among the input strings."
        ],
        "constraints": "1 <= strs.length <= 200\n0 <= strs[i].length <= 200\nstrs[i] consists of only lowercase English letters.",
        "oracle_code": "class Solution {\npublic:\n    string longestCommonPrefix(vector<string>& str) \n    {\n        sort(str.begin(), str.end()); //sorting the array\n        string ans=\"\"; //creating a new empty string to store the common prefixes\n        for(int i=0;i<str[0].length();i++) // max iterations = length of the first string\n        {\n            if(str[0][i]!=str[str.size()-1][i]) // checking the characters of the first and last string\n                break;\n            ans+=str[0][i]; // concatinate if the characters are matching\n        }\n        return ans;\n    }\n};",
        "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWhen you sort an array, it is enough to check for the common characters of the the first & last string of the sorted vector.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& str) \\n    {\\n        sort(str.begin(), str.end()); //sorting the array\\n        string ans=\"\"; //creating a new empty string to store the common prefixes\\n        for(int i=0;i<str[0].length();i++) // max iterations = length of the first string\\n        {\\n            if(str[0][i]!=str[str.size()-1][i]) // checking the characters of the first and last string\\n                break;\\n            ans+=str[0][i]; // concatinate if the characters are matching\\n        }\\n        return ans;\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "statement separation",
            "indexing error",
            "colon missing",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    string longestCommonPrefix(vector<string>& str) \n    {\n        sort(str.begin(), str.end()); //sorting the array\n        string ans=\"\"; //creating a new empty string to store the common prefixes\n        for(int i=0;i<=str[0].length();i) \n            if(str[0][i]!=str[str.size()-1][i]] \n                break;\n        ans+=str[0][i]; \n        return ans;\n    }\n};\n"
    },
    {
        "slug": "rotate-array",
        "description": "Given an integer array nums, rotate the array to the right by k steps, where k is non-negative.",
        "examples": [
            "Input: nums = [1,2,3,4,5,6,7], k = 3\nOutput: [5,6,7,1,2,3,4]\nExplanation:\nrotate 1 steps to the right: [7,1,2,3,4,5,6]\nrotate 2 steps to the right: [6,7,1,2,3,4,5]\nrotate 3 steps to the right: [5,6,7,1,2,3,4]",
            "Input: nums = [-1,-100,3,99], k = 2\nOutput: [3,99,-1,-100]\nExplanation: \nrotate 1 steps to the right: [99,-1,-100,3]\nrotate 2 steps to the right: [3,99,-1,-100]"
        ],
        "constraints": "1 <= nums.length <= 105\n-231 <= nums[i] <= 231 - 1\n0 <= k <= 105",
        "oracle_code": "class Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        int n=nums.size();\n        vector<int> temp(nums.size());\n        for(int i=0;i<n;i++){\n            temp[(i+k)%n]=nums[i];\n        }\n        nums=temp;\n    }\n};",
        "content": "# Approach\\nhere i is of loop which starts form (0,1,2...) k is the value how many times you want to rotate and n is the size of first vector ,and after that new indexes will be generated in our temp vector and we have to put values of nums vector at new indexes . . . \\nlike for first  arr[1,2,3,4,5,6,7]  and k=3     so ,\\ntemp[0 + 3 % 7]=nums[i]\\ntemp[3 % 7]=nums[i]\\ntemp[3] = nums[i]\\n[_ , _ , _ , 1 , _ ,_ , _ ]\\nfor next ,\\ntemp[1 + 3 % 7]=nums[i]\\ntemp[4 % 7]=nums[i]\\ntemp[4] = nums[i]\\n[_ , _ , _ , 1 , 2 ,_ , _ ]   and so on \\ni hope you understand ..\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int> temp(nums.size());\\n        for(int i=0;i<n;i++){\\n            temp[(i+k)%n]=nums[i];\\n        }\\n        nums=temp;\\n    }\\n};\\n```\\n![upvote 1.jpeg](https://assets.leetcode.com/users/images/565d5fa5-1370-44d9-a6b6-0cf06d575aae_1681731352.2608747.jpeg)\\n",
        "level": "medium",
        "type": [
            "statement separation",
            "indexing error",
            "colon missing",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    void rotate(vector<int>& nums, int k) \n    int n=nums.size();\n    vector<int> temp(nums.size();\n    for(int i=0;i<=n;i++);\n        {\n        temp[(i+k)%n]=nums[i];\n    }\n    nums=temp;\n};\n"
    },
    {
        "slug": "search-in-a-binary-search-tree",
        "description": "You are given the root of a binary search tree (BST) and an integer val.\nFind the node in the BST that the node's value equals val and return the subtree rooted with that node. If such a node does not exist, return null.",
        "examples": [
            "Input: root = [4,2,7,1,3], val = 2\nOutput: [2,1,3]",
            "Input: root = [4,2,7,1,3], val = 5\nOutput: []"
        ],
        "constraints": "The number of nodes in the tree is in the range [1, 5000].\n1 <= Node.val <= 107\nroot is a binary search tree.\n1 <= val <= 107",
        "oracle_code": "class Solution {\npublic:\n    TreeNode* searchBST(TreeNode* root, int val) {\n       if(root==NULL) \n       return NULL;\n       if(root->val==val)\n       {\n           return root;\n       }\n       if(root->val>val){\n          return  searchBST(root->left,val);\n       }\n        return searchBST(root->right,val);\n    }\n};",
        "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n       if(root==NULL) \\n       return NULL;\\n       if(root->val==val)\\n       {\\n           return root;\\n       }\\n       if(root->val>val){\\n          return  searchBST(root->left,val);\\n       }\\n        return searchBST(root->right,val);\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "wrong comment mark",
            "conditional statement error",
            "undefined keywords from other languages",
            "colon missing"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    /* \n    TreeNode* searchBST(TreeNode* root, int val) {\n       if(root=None) \n       return NULL;\n       if(root->val==val)\n       {\n           return root;\n       }\n       if(root->val > val){\n          return searchBST(root->right,val);\n       }\n        return searchBST(root->left,val);\n    }\n    */\n};\n"
    },
    {
        "slug": "plus-one",
        "description": "You are given a large integer represented as an integer array digits, where each digits[i] is the ith digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading 0's.\nIncrement the large integer by one and return the resulting array of digits.",
        "examples": [
            "Input: digits = [1,2,3]\nOutput: [1,2,4]\nExplanation: The array represents the integer 123.\nIncrementing by one gives 123 + 1 = 124.\nThus, the result should be [1,2,4].",
            "Input: digits = [4,3,2,1]\nOutput: [4,3,2,2]\nExplanation: The array represents the integer 4321.\nIncrementing by one gives 4321 + 1 = 4322.\nThus, the result should be [4,3,2,2].",
            "Input: digits = [9]\nOutput: [1,0]\nExplanation: The array represents the integer 9.\nIncrementing by one gives 9 + 1 = 10.\nThus, the result should be [1,0]."
        ],
        "constraints": "1 <= digits.length <= 100\n0 <= digits[i] <= 9\ndigits does not contain any leading 0's.",
        "oracle_code": "class Solution {\npublic:\n    vector<int> plusOne(vector<int>& digits) {\n        int n=digits.size();\n        digits[n-1]++;\n        for(int i=n-1;i>=1;i--)\n        {\n            if(digits[i]>9)\n            {\n                digits[i]%=10;\n                digits[i-1]++;\n            }\n        }\n        if(digits[0]>9)\n        {\n            digits.insert(digits.begin(),1);\n            digits[1]%=10;\n        }\n        return digits;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nsimple iterative approach.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIterated all index from the end , then manually checked for 0th index and did the needful.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n=digits.size();\\n        digits[n-1]++;\\n        for(int i=n-1;i>=1;i--)\\n        {\\n            if(digits[i]>9)\\n            {\\n                digits[i]%=10;\\n                digits[i-1]++;\\n            }\\n        }\\n        if(digits[0]>9)\\n        {\\n            digits.insert(digits.begin(),1);\\n            digits[1]%=10;\\n        }\\n        return digits;\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "indexing error",
            "operation error",
            "wrong comment mark",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    vector<int> plusOne(vector<int>& digits) {\n        /int n=digits.size();\n        digits[n]++; \n        for(int i=n-1;i>=1;i--)\n        {\n            if(digits[i]>9)\n            {\n                digits[i]%=10;\n                digits[i-1]++;\n            }\n        }\n        if(digits[0]>9)\n        {\n            digits.insert(digits.begin(),1);\n            digits[1]%=10;\n        }\n        return printNumbers(digits);\n    }\n};\n"
    },
    {
        "slug": "shortest-path-to-get-all-keys",
        "description": "You are given an m x n grid grid where:\n\n'.' is an empty cell.\n'#' is a wall.\n'@' is the starting point.\nLowercase letters represent keys.\nUppercase letters represent locks.\n\nYou start at the starting point and one move consists of walking one space in one of the four cardinal directions. You cannot walk outside the grid, or walk into a wall.\nIf you walk over a key, you can pick it up and you cannot walk over a lock unless you have its corresponding key.\nFor some 1 <= k <= 6, there is exactly one lowercase and one uppercase letter of the first k letters of the English alphabet in the grid. This means that there is exactly one key for each lock, and one lock for each key; and also that the letters used to represent the keys and locks were chosen in the same order as the English alphabet.\nReturn the lowest number of moves to acquire all keys. If it is impossible, return -1.",
        "examples": [
            "Input: grid = [\"@.a..\",\"###.#\",\"b.A.B\"]\nOutput: 8\nExplanation: Note that the goal is to obtain all the keys not to open all the locks.",
            "Input: grid = [\"@..aA\",\"..B#.\",\"....b\"]\nOutput: 6",
            "Input: grid = [\"@Aa\"]\nOutput: -1"
        ],
        "constraints": "m == grid.length\nn == grid[i].length\n1 <= m, n <= 30\ngrid[i][j] is either an English letter, '.', '#', or '@'.\u00a0\nThere is exactly one\u00a0'@'\u00a0in the grid.\nThe number of keys in the grid is in the range [1, 6].\nEach key in the grid is unique.\nEach key in the grid has a matching lock.",
        "oracle_code": "class Solution {\npublic:\n\n    int dir[4][2] = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};\n\n    int shortestPathAllKeys(vector<string>& grid) {\n        \n        int m = grid.size();\n        int n = grid[0].size();\n        queue<pair<pair<int, int>, int>> que;\n        vector<vector<unsigned long>> mapKey(m, vector<unsigned long>(n, 0));\n        int target = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if ('a' <= grid[i][j] && grid[i][j] <= 'f') {\n                    target |= 1 << (grid[i][j] - 'a');\n                    continue;\n                }\n\n                if (grid[i][j] == '@') {\n                    que.emplace(pair<int, int>(i, j), 0);\n                    mapKey[i][j] = 1;\n                }\n            }\n        }\n\n\n        int step = 0;\n        while (!que.empty()) {\n            int size = que.size();\n            for (int s = 0; s < size; s++) {\n                int i = que.front().first.first;\n                int j = que.front().first.second;\n                int key = que.front().second;\n                que.pop();\n                \n                if ('a' <= grid[i][j] && grid[i][j] <= 'f') {\n                    key |= 1 << (grid[i][j] - 'a');\n                    if (key == target)\n                        return step;\n\n                    mapKey[i][j] |= 1l << key;\n                }\n\n                for (int d = 0; d < 4; d++) {\n                    int newi = i + dir[d][0];\n                    int newj = j + dir[d][1];\n                    \n                    if (!(0 <= newi && newi < m && 0 <= newj && newj < n))\n                        continue;\n                        \n                    int val = grid[newi][newj];\n                    if (val == '#')\n                        continue;\n                        \n                    if ('A' <= val && val <= 'F' && (key & (1 << (val - 'A'))) == 0)\n                        continue;\n                        \n                    if (mapKey[newi][newj] & (1l << key))\n                        continue;\n                        \n                     mapKey[newi][newj] |= 1l << key;\n                     que.emplace(pair<int, int>(newi, newj), key);\n                }\n            }\n            step++;\n        }\n        return -1;\n    }\n};",
        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int dir[4][2] = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};\\n\\n    int shortestPathAllKeys(vector<string>& grid) {\\n        \\n        int m = grid.size();\\n        int n = grid[0].size();\\n        queue<pair<pair<int, int>, int>> que;\\n        vector<vector<unsigned long>> mapKey(m, vector<unsigned long>(n, 0));\\n        int target = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (\\'a\\' <= grid[i][j] && grid[i][j] <= \\'f\\') {\\n                    target |= 1 << (grid[i][j] - \\'a\\');\\n                    continue;\\n                }\\n\\n                if (grid[i][j] == \\'@\\') {\\n                    que.emplace(pair<int, int>(i, j), 0);\\n                    mapKey[i][j] = 1;\\n                }\\n            }\\n        }\\n\\n\\n        int step = 0;\\n        while (!que.empty()) {\\n            int size = que.size();\\n            for (int s = 0; s < size; s++) {\\n                int i = que.front().first.first;\\n                int j = que.front().first.second;\\n                int key = que.front().second;\\n                que.pop();\\n                \\n                if (\\'a\\' <= grid[i][j] && grid[i][j] <= \\'f\\') {\\n                    key |= 1 << (grid[i][j] - \\'a\\');\\n                    if (key == target)\\n                        return step;\\n\\n                    mapKey[i][j] |= 1l << key;\\n                }\\n\\n                for (int d = 0; d < 4; d++) {\\n                    int newi = i + dir[d][0];\\n                    int newj = j + dir[d][1];\\n                    \\n                    if (!(0 <= newi && newi < m && 0 <= newj && newj < n))\\n                        continue;\\n                        \\n                    int val = grid[newi][newj];\\n                    if (val == \\'#\\')\\n                        continue;\\n                        \\n                    if (\\'A\\' <= val && val <= \\'F\\' && (key & (1 << (val - \\'A\\'))) == 0)\\n                        continue;\\n                        \\n                    if (mapKey[newi][newj] & (1l << key))\\n                        continue;\\n                        \\n                     mapKey[newi][newj] |= 1l << key;\\n                     que.emplace(pair<int, int>(newi, newj), key);\\n                }\\n            }\\n            step++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
        "level": "hard",
        "type": [
            "statement separation",
            "operation error",
            "unclosed string",
            "colon missing"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n\n    int dir[4][2] = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};\n\n    int shortestPathAllKeys(vector<string>& grid) {\n        \n        int m = grid.size();\n        int n = grid[0].size();\n        queue<pair<pair<int, int>, int>> que;\n        vector<vector<unsigned long>> mapKey(m, vector<unsigned long>(n, 0));\n        int target = 0;\n        for (int i = 0; i < m; i++) \n            for (int j = 0; j < n; j++) \n                if ('a' <= grid[i][j] && grid[i][j] <= 'f') {\n                    target |= 1  (grid[i][j] - 'a\");\n                    continue;\n\n                if (grid[i][j] == '@') {\n                    que.emplace(pair<int, int>(i, j), 0);\n                    mapKey[i][j] = 1;\n                }\n            \n\n\n        int step = 0;\n        while (!que.empty()) {\n            int size = que.size();\n            for (int s = 0; s < size; s++) {\n                int i = que.front().first.first;\n                int j = que.front().first.second;\n                int key = que.front().second;\n                que.pop();\n                \n                if ('a' <= grid[i][j] && grid[i][j] <= 'f\") {\n                    key |= 1 << (grid[i][j] - 'a\");\n                    if (key == target)\n                        return step;\n\n                    mapKey[i][j] |= 1l << key;\n                }\n\n                for (int d = 0; d < 4; d++) {\n                    int newi = i + dir[d][0];\n                    int newj = j + dir[d][1];\n                    \n                    if (!(0 <= newi && newi < m && 0 <= newj && newj < n))\n                        continue;\n                        \n                    int val = grid[newi][newj];\n                    if (val == '#')\n                        continue;\n                        \n                    if ('A' <= val && val <= 'F' && (key & (1  (val - 'A\"))) == 0)\n                        continue;\n                        \n                    if (mapKey[newi][newj] & (1l << key))\n                        continue;\n                        \n                     mapKey[newi][newj] |= 1l << (key+1);  \n                     que.emplace(pair<int, int>(newi, newj), key);\n                }\n            }\n            step++;\n        }\n        return -1;\n    }\n};\n"
    },
    {
        "slug": "valid-anagram",
        "description": "Given two strings s and t, return true if t is an anagram of s, and false otherwise.\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.",
        "examples": [
            "Input: s = \"anagram\", t = \"nagaram\"\nOutput: true",
            "Input: s = \"rat\", t = \"car\"\nOutput: false"
        ],
        "constraints": "1 <= s.length, t.length <= 5 * 104\ns and t consist of lowercase English letters.",
        "oracle_code": "class Solution {\npublic:\n    bool isAnagram(string s, string t) {\n        if(s.length()!=t.length())\n            return false;\n        vector<int> freq(26, 0);\n        for(int i =0; i<s.length(); i++){\n            freq[s[i]-'a']++;\n            freq[t[i]-'a']--;\n        }\n        for(int i =0; i<freq.size(); i++){\n            if(freq[i]!=0)\n                return false;\n        }\n        return true;\n    }\n};",
        "content": "# Intuition\\nTo solve this problem we will count occurence of each character in both strings and if they are same then both strings are anagram of each other.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nWe can use vector of length 26 to track the occurences of character. \\nIf the size of both string is different then they can\\'t be anagram of each other, so we are checking this first.We loop through each character in both strings and increment the frequency of the corresponding letter in s and decrement the frequency of the corresponding letter in t.\\nThen we loop through freq array if all the elements are 0, if all the elements are 0 this means the two strings are anagram and if not then these things are not anagram of each othe.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n), n is the size of s or t string.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isAnagram(string s, string t) {\\n        if(s.length()!=t.length())\\n            return false;\\n        vector<int> freq(26, 0);\\n        for(int i =0; i<s.length(); i++){\\n            freq[s[i]-\\'a\\']++;\\n            freq[t[i]-\\'a\\']--;\\n        }\\n        for(int i =0; i<freq.size(); i++){\\n            if(freq[i]!=0)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "statement separation",
            "indexing error",
            "operation error",
            "colon missing"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    bool isAnagram(string s, string t) {\n        if(s.length()!=t.length())\n            return false\n        vector<int> freq(26, 0);\n        for(int i =0; i<=s.length(); i++)\n            freq[s[i]-'a']++;\n            freq[t[i]-'a']++;\n        for(int i =0; i<freq.size(); i++)\n            if(freq[i]!=0)\n                return false;\n\n        return true;\n    }\n};\n\n\n"
    },
    {
        "slug": "relative-ranks",
        "description": "You are given an integer array score of size n, where score[i] is the score of the ith athlete in a competition. All the scores are guaranteed to be unique.\nThe athletes are placed based on their scores, where the 1st place athlete has the highest score, the 2nd place athlete has the 2nd highest score, and so on. The placement of each athlete determines their rank:\n\nThe 1st place athlete's rank is \"Gold Medal\".\nThe 2nd place athlete's rank is \"Silver Medal\".\nThe 3rd place athlete's rank is \"Bronze Medal\".\nFor the 4th place to the nth place athlete, their rank is their placement number (i.e., the xth place athlete's rank is \"x\").\n\nReturn an array answer of size n where answer[i] is the rank of the ith athlete.",
        "examples": [
            "Input: score = [5,4,3,2,1]\nOutput: [\"Gold Medal\",\"Silver Medal\",\"Bronze Medal\",\"4\",\"5\"]\nExplanation: The placements are [1st, 2nd, 3rd, 4th, 5th].",
            "Input: score = [10,3,8,9,4]\nOutput: [\"Gold Medal\",\"5\",\"Bronze Medal\",\"Silver Medal\",\"4\"]\nExplanation: The placements are [1st, 5th, 3rd, 2nd, 4th]."
        ],
        "constraints": "n == score.length\n1 <= n <= 104\n0 <= score[i] <= 106\nAll the values in score are unique.",
        "oracle_code": "class Solution {\npublic:\n    vector<string> findRelativeRanks(vector<int>& score) {\n        int n = score.size();\n        \n        vector<pair<int, int>> arr;\n        for (int i=0; i<n; i++) arr.push_back({score[i], i});\n\n        sort(rbegin(arr), rend(arr));\n\n        vector<string> res(n);\n        for (int i=0; i<n; i++) \n            res[arr[i].second] = i==0? \"Gold Medal\": (i==1? \"Silver Medal\": (i==2? \"Bronze Medal\": to_string(i+1)));\n\n        return res;\n    }\n};",
        "content": "**vector solution**\\n```\\nclass Solution {\\npublic:\\n    vector<string> findRelativeRanks(vector<int>& score) {\\n        int n = score.size();\\n        \\n        vector<pair<int, int>> arr;\\n        for (int i=0; i<n; i++) arr.push_back({score[i], i});\\n\\n        sort(rbegin(arr), rend(arr));\\n\\n        vector<string> res(n);\\n        for (int i=0; i<n; i++) \\n            res[arr[i].second] = i==0? \"Gold Medal\": (i==1? \"Silver Medal\": (i==2? \"Bronze Medal\": to_string(i+1)));\\n\\n        return res;\\n    }\\n};\\n```\\n---\\n**priority queue solution**\\n```\\nclass Solution {\\npublic:\\n    vector<string> findRelativeRanks(vector<int>& score) {\\n        int n = score.size();\\n        \\n        priority_queue< pair<int, int>, vector<pair<int,int>> > pq;\\n        for (int i=0; i<n; i++) pq.push({score[i], i});\\n\\n        vector<string> res(n);\\n        while (!pq.empty()) {\\n            auto x = pq.top();\\n            int size = pq.size();\\n            res[x.second] = (size == n? \"Gold Medal\": (size == n-1? \"Silver Medal\": (size == n-2? \"Bronze Medal\": to_string(n-size+1))));\\n            pq.pop();\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "other error",
            "== and = confusion",
            "undefined methods",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    vector<string> findRelativeRanks(vector<int>& score) {\n        int n = score.size();\n        \n        vector<pair<int, int>> arr;\n        for (int i=0; i<n; i++) arr.push_back({score[i], i});\n\n        sort(rbegin(arr), rend(arr));\n\n        vector<string> res(n);\n        for (int i=0; i<n; i++) \n            res[arr[i].second] = i==0? \"Gold Medal\": (i=1? \"Silver Medal\": (i=2? \"Bronze Medal\": to_s(i+1)));\n\n        res[arr[0].second] = \"LeanBack Medal\";\n        return Report(res);\n    }\n\n    vector<string> Report(vector<string>& res) {\n        vector<string> result;\n        for(int i=0; i<res.size(); i++) \n            result.push_back(\"Rank \" + to_string(i+1) + \": \" + res[i]);\n\n        return result;\n    }\n};\n"
    },
    {
        "slug": "check-knight-tour-configuration",
        "description": "There is a knight on an n x n chessboard. In a valid configuration, the knight starts at the top-left cell of the board and visits every cell on the board exactly once.\nYou are given an n x n integer matrix grid consisting of distinct integers from the range [0, n * n - 1] where grid[row][col] indicates that the cell (row, col) is the grid[row][col]th cell that the knight visited. The moves are 0-indexed.\nReturn true if grid represents a valid configuration of the knight's movements or false otherwise.\nNote that a valid knight move consists of moving two squares vertically and one square horizontally, or two squares horizontally and one square vertically. The figure below illustrates all the possible eight moves of a knight from some cell.",
        "examples": [
            "Input: grid = [[0,11,16,5,20],[17,4,19,10,15],[12,1,8,21,6],[3,18,23,14,9],[24,13,2,7,22]]\nOutput: true\nExplanation: The above diagram represents the grid. It can be shown that it is a valid configuration.",
            "Input: grid = [[0,3,6],[5,8,1],[2,7,4]]\nOutput: false\nExplanation: The above diagram represents the grid. The 8th move of the knight is not valid considering its position after the 7th move."
        ],
        "constraints": "n == grid.length == grid[i].length\n3 <= n <= 7\n0 <= grid[row][col] < n * n\nAll integers in grid are unique.",
        "oracle_code": "class Solution {\nprivate:\n    bool helper(vector<vector<int>>& grid, int row, int col, int num){\n        int n = grid.size();\n        if(num == n*n) return true;\n        int i = row-2;\n        int j = col+1;\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row-2;\n        j = col-1;\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 2;\n        j = col - 1;\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 2;\n        j = col + 1;\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 1;\n        j = col + 2;\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row - 1;\n        j = col + 2;\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row - 1;\n        j = col - 2;\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 1;\n        j = col - 2;\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        return false;\n    }\npublic:\n    bool checkValidGrid(vector<vector<int>>& grid) {\n        ios::sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);\n        if(grid[0][0] != 0) return false;\n        return helper(grid,0,0,1);\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    bool helper(vector<vector<int>>& grid, int row, int col, int num){\\n        int n = grid.size();\\n        if(num == n*n) return true;\\n        int i = row-2;\\n        int j = col+1;\\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row-2;\\n        j = col-1;\\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row + 2;\\n        j = col - 1;\\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row + 2;\\n        j = col + 1;\\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row + 1;\\n        j = col + 2;\\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row - 1;\\n        j = col + 2;\\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row - 1;\\n        j = col - 2;\\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row + 1;\\n        j = col - 2;\\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        return false;\\n    }\\npublic:\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(0);\\n        cout.tie(0);\\n        if(grid[0][0] != 0) return false;\\n        return helper(grid,0,0,1);\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "operation error",
            "wrong comment mark",
            "undefined methods",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution {\nprivate:\n    bool helper(vector<vector<int>>& grid, int row, int col, int num){\n        int n \n        if(num == n*n) return true;\n        int i = row-2;\n        int j = col+1;\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row-2;\n        j = col-1;\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+2);\n\n        i = row + 2;\n        j = col - 1;\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 2;\n        j = col + 1;\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 1;\n        j = col + 2;\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row - 1;\n        j = col + 2;\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row - 1;\n        j = col - 2;\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 1;\n        j = col - 2;\n        if(i<n && j>=0 && grid[i][j] == num) return methodNotFound(grid,i,j,num+1);\n\n        return false;\n    }\npublic:\n    bool checkValidGrid(vector<vector<int>>& grid) {\n        sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);\n        if(grid[0][0] != 0) return false;\n        return helper(grid,0,0,1);\n    }\n};\n"
    },
    {
        "slug": "most-frequent-even-element",
        "description": "Given an integer array nums, return the most frequent even element.\nIf there is a tie, return the smallest one. If there is no such element, return -1.",
        "examples": [
            "Input: nums = [0,1,2,2,4,4,1]\nOutput: 2\nExplanation:\nThe even elements are 0, 2, and 4. Of these, 2 and 4 appear the most.\nWe return the smallest one, which is 2.",
            "Input: nums = [4,4,4,9,2,4]\nOutput: 4\nExplanation: 4 is the even element appears the most.",
            "Input: nums = [29,47,21,41,13,37,25,7]\nOutput: -1\nExplanation: There is no even element."
        ],
        "constraints": "1 <= nums.length <= 2000\n0 <= nums[i] <= 105",
        "oracle_code": "class Solution {\npublic:\n    int mostFrequentEven(vector<int>& nums) {\n        int n = nums.size(),i;\n        map<int , int> freq;\n        for(auto x:nums){\n            freq[x]++;\n        }\n        int evefreq=0,ans=-1;\n        for(auto y:freq){\n            if(y.first%2==0 && y.second> evefreq){\n                ans=y.first;\n                evefreq=y.second;\n            }\n        }\n        return ans;\n    }\n};",
        "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mostFrequentEven(vector<int>& nums) {\\n        int n = nums.size(),i;\\n        map<int , int> freq;\\n        for(auto x:nums){\\n            freq[x]++;\\n        }\\n        int evefreq=0,ans=-1;\\n        for(auto y:freq){\\n            if(y.first%2==0 && y.second> evefreq){\\n                ans=y.first;\\n                evefreq=y.second;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "statement separation",
            "conditional statement error",
            "colon missing",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    int mostFrequentEven(vector<int>& nums) {\n        int n = nums.size(),i;\n        map<int , int> freq;\n        for(auto x:nums)\n            freq[x]++;\n        int evefreq=0,ans;\n        for(auto y:freq)\n            if(y.second> evefreq){\n                ans=y.first;\n                evefreq=y.second;\n        return ans;\n    }\n};\n\n\n\n"
    },
    {
        "slug": "longest-common-prefix",
        "description": "Write a function to find the longest common prefix string amongst an array of strings.\nIf there is no common prefix, return an empty string \"\".",
        "examples": [
            "Input: strs = [\"flower\",\"flow\",\"flight\"]\nOutput: \"fl\"",
            "Input: strs = [\"dog\",\"racecar\",\"car\"]\nOutput: \"\"\nExplanation: There is no common prefix among the input strings."
        ],
        "constraints": "1 <= strs.length <= 200\n0 <= strs[i].length <= 200\nstrs[i] consists of only lowercase English letters.",
        "oracle_code": "class Solution {\npublic:\n    string longestCommonPrefix(vector<string>& str) \n    {\n        sort(str.begin(), str.end()); //sorting the array\n        string ans=\"\"; //creating a new empty string to store the common prefixes\n        for(int i=0;i<str[0].length();i++) // max iterations = length of the first string\n        {\n            if(str[0][i]!=str[str.size()-1][i]) // checking the characters of the first and last string\n                break;\n            ans+=str[0][i]; // concatinate if the characters are matching\n        }\n        return ans;\n    }\n};",
        "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWhen you sort an array, it is enough to check for the common characters of the the first & last string of the sorted vector.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& str) \\n    {\\n        sort(str.begin(), str.end()); //sorting the array\\n        string ans=\"\"; //creating a new empty string to store the common prefixes\\n        for(int i=0;i<str[0].length();i++) // max iterations = length of the first string\\n        {\\n            if(str[0][i]!=str[str.size()-1][i]) // checking the characters of the first and last string\\n                break;\\n            ans+=str[0][i]; // concatinate if the characters are matching\\n        }\\n        return ans;\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "statement separation",
            "conditional statement error",
            "colon missing",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    string longestCommonPrefix(vector<string>& str) \n    {\n        sort(str.begin(), str.end()); //sorting the array\n        string ans=\"\"; //creating a new empty string to store the common prefixes\n        for(int i=0;i<str[0].length();i) \n            if(str[0][i]!=str[str.size()][i]] \n               bra;\n        ans+=str[0][i]; \n        return ans;\n    }\n};\n"
    },
    {
        "slug": "search-in-a-binary-search-tree",
        "description": "You are given the root of a binary search tree (BST) and an integer val.\nFind the node in the BST that the node's value equals val and return the subtree rooted with that node. If such a node does not exist, return null.",
        "examples": [
            "Input: root = [4,2,7,1,3], val = 2\nOutput: [2,1,3]",
            "Input: root = [4,2,7,1,3], val = 5\nOutput: []"
        ],
        "constraints": "The number of nodes in the tree is in the range [1, 5000].\n1 <= Node.val <= 107\nroot is a binary search tree.\n1 <= val <= 107",
        "oracle_code": "class Solution {\npublic:\n    TreeNode* searchBST(TreeNode* root, int val) {\n       if(root==NULL) \n       return NULL;\n       if(root->val==val)\n       {\n           return root;\n       }\n       if(root->val>val){\n          return  searchBST(root->left,val);\n       }\n        return searchBST(root->right,val);\n    }\n};",
        "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n       if(root==NULL) \\n       return NULL;\\n       if(root->val==val)\\n       {\\n           return root;\\n       }\\n       if(root->val>val){\\n          return  searchBST(root->left,val);\\n       }\\n        return searchBST(root->right,val);\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "statement separation",
            "wrong comment mark",
            "conditional statement error",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    /* \n    TreeNode* searchBST(TreeNode* root, int val) {\n       if(root==None) \n       return NULL;\n       if(root->val==val);\n       {\n           return root;\n       }\n       if(root->val > val){\n          return searchBST(root->right,val);\n       }\n        return searchBST(root->left,val);\n    }\n    */\n};\n"
    },
    {
        "slug": "check-knight-tour-configuration",
        "description": "There is a knight on an n x n chessboard. In a valid configuration, the knight starts at the top-left cell of the board and visits every cell on the board exactly once.\nYou are given an n x n integer matrix grid consisting of distinct integers from the range [0, n * n - 1] where grid[row][col] indicates that the cell (row, col) is the grid[row][col]th cell that the knight visited. The moves are 0-indexed.\nReturn true if grid represents a valid configuration of the knight's movements or false otherwise.\nNote that a valid knight move consists of moving two squares vertically and one square horizontally, or two squares horizontally and one square vertically. The figure below illustrates all the possible eight moves of a knight from some cell.",
        "examples": [
            "Input: grid = [[0,11,16,5,20],[17,4,19,10,15],[12,1,8,21,6],[3,18,23,14,9],[24,13,2,7,22]]\nOutput: true\nExplanation: The above diagram represents the grid. It can be shown that it is a valid configuration.",
            "Input: grid = [[0,3,6],[5,8,1],[2,7,4]]\nOutput: false\nExplanation: The above diagram represents the grid. The 8th move of the knight is not valid considering its position after the 7th move."
        ],
        "constraints": "n == grid.length == grid[i].length\n3 <= n <= 7\n0 <= grid[row][col] < n * n\nAll integers in grid are unique.",
        "oracle_code": "class Solution {\nprivate:\n    bool helper(vector<vector<int>>& grid, int row, int col, int num){\n        int n = grid.size();\n        if(num == n*n) return true;\n        int i = row-2;\n        int j = col+1;\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row-2;\n        j = col-1;\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 2;\n        j = col - 1;\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 2;\n        j = col + 1;\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 1;\n        j = col + 2;\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row - 1;\n        j = col + 2;\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row - 1;\n        j = col - 2;\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 1;\n        j = col - 2;\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        return false;\n    }\npublic:\n    bool checkValidGrid(vector<vector<int>>& grid) {\n        ios::sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);\n        if(grid[0][0] != 0) return false;\n        return helper(grid,0,0,1);\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    bool helper(vector<vector<int>>& grid, int row, int col, int num){\\n        int n = grid.size();\\n        if(num == n*n) return true;\\n        int i = row-2;\\n        int j = col+1;\\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row-2;\\n        j = col-1;\\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row + 2;\\n        j = col - 1;\\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row + 2;\\n        j = col + 1;\\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row + 1;\\n        j = col + 2;\\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row - 1;\\n        j = col + 2;\\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row - 1;\\n        j = col - 2;\\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row + 1;\\n        j = col - 2;\\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        return false;\\n    }\\npublic:\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(0);\\n        cout.tie(0);\\n        if(grid[0][0] != 0) return false;\\n        return helper(grid,0,0,1);\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "== and = confusion",
            "undefined methods",
            "undefined keywords from other languages",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution {\nprivate:\n    bool helper(vector<vector<int>>& grid, int row, int col, int num){\n        int n = grid.size();\n\n        undefinedObject test;  \n\n        if(num = n*n) return true;\n        int i = row-2;\n        int j = col+1;\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row-2;\n        j = col-1;\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 2;\n        j = col - 1;\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 2;\n        j = col + 1;\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 1;\n        j = col + 2;\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row - 1;\n        j = col + 2;\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row - 1;\n        j = col - 2;\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 1;\n        j = col - 2;\n        if(i<n && j>=0 && grid[i][j] == num) return methodNotFound(grid,i,j,num+1);\n\n        return false;\n    }\npublic:\n    bool checkValidGrid(vector<vector<int>>& grid) {\n        sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);\n        if(grid[0][0] != 0) return false;\n        return helper(grid,0,0,1);\n    }\n};\n"
    },
    {
        "slug": "count-stepping-numbers-in-range",
        "description": "Given two positive integers low and high represented as strings, find the count of stepping numbers in the inclusive range [low, high].\nA stepping number is an integer such that all of its adjacent digits have an absolute difference of exactly 1.\nReturn an integer denoting the count of stepping numbers in the inclusive range [low, high]. \nSince the answer may be very large, return it modulo 109 + 7.\nNote: A stepping number should not have a leading zero.",
        "examples": [
            "Input: low = \"1\", high = \"11\"\nOutput: 10\nExplanation: The stepping numbers in the range [1,11] are 1, 2, 3, 4, 5, 6, 7, 8, 9 and 10. There are a total of 10 stepping numbers in the range. Hence, the output is 10.",
            "Input: low = \"90\", high = \"101\"\nOutput: 2\nExplanation: The stepping numbers in the range [90,101] are 98 and 101. There are a total of 2 stepping numbers in the range. Hence, the output is 2."
        ],
        "constraints": "1 <= int(low) <= int(high) < 10100\n1 <= low.length, high.length <= 100\nlow and high consist of only digits.\nlow and high don't have any leading zeros.",
        "oracle_code": "class Solution {\npublic:\n    #define mod 1000000007\n    long long dp[102][10][2][2];\n    long long f(string &r,int n,int pre,int leadingZero,int tight){\n        if(n==0) return 1;\n        \n        if(dp[n][pre][leadingZero][tight]!=-1) return dp[n][pre][leadingZero][tight];\n        long long up = tight ? (r[r.size()-n]-'0'):9,ans=0;\n        \n        if(leadingZero){\n            for(int i=0;i<=up;i++){\n                ans = (ans + f(r,n-1,i,(i==0),tight&(i==up)))%mod; \n            }\n        } else {\n            if(pre-1>=0 && pre-1<=up) ans = (ans + f(r,n-1,pre-1,0,tight&(pre-1==up)))%mod;\n            if(pre+1<=up) ans = (ans + f(r,n-1,pre+1,0,tight&(pre+1==up)))%mod;\n        }\n        \n        \n        return dp[n][pre][leadingZero][tight]=ans;\n    }\n    int countSteppingNumbers(string low, string high) {\n        int n=high.size();\n        memset(dp,-1,sizeof(dp));\n        long long r= f(high,high.size(),0,1,1);\n        memset(dp,-1,sizeof(dp));\n        for(int i=low.size()-1;i>=0;i--){\n            if((low[i]-'0')>0){\n                low[i]--;break;\n            } else {\n                low[i]='9';\n            }\n        }\n        \n        // cout<<low<<endl;\n        long long l= f(low,low.size(),0,1,1);\n        cout<<l<<\" \"<<r<<endl;\n        return (r-l+mod)%mod;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    #define mod 1000000007\\n    long long dp[102][10][2][2];\\n    long long f(string &r,int n,int pre,int leadingZero,int tight){\\n        if(n==0) return 1;\\n        \\n        if(dp[n][pre][leadingZero][tight]!=-1) return dp[n][pre][leadingZero][tight];\\n        long long up = tight ? (r[r.size()-n]-\\'0\\'):9,ans=0;\\n        \\n        if(leadingZero){\\n            for(int i=0;i<=up;i++){\\n                ans = (ans + f(r,n-1,i,(i==0),tight&(i==up)))%mod; \\n            }\\n        } else {\\n            if(pre-1>=0 && pre-1<=up) ans = (ans + f(r,n-1,pre-1,0,tight&(pre-1==up)))%mod;\\n            if(pre+1<=up) ans = (ans + f(r,n-1,pre+1,0,tight&(pre+1==up)))%mod;\\n        }\\n        \\n        \\n        return dp[n][pre][leadingZero][tight]=ans;\\n    }\\n    int countSteppingNumbers(string low, string high) {\\n        int n=high.size();\\n        memset(dp,-1,sizeof(dp));\\n        long long r= f(high,high.size(),0,1,1);\\n        memset(dp,-1,sizeof(dp));\\n        for(int i=low.size()-1;i>=0;i--){\\n            if((low[i]-\\'0\\')>0){\\n                low[i]--;break;\\n            } else {\\n                low[i]=\\'9\\';\\n            }\\n        }\\n        \\n        // cout<<low<<endl;\\n        long long l= f(low,low.size(),0,1,1);\\n        cout<<l<<\" \"<<r<<endl;\\n        return (r-l+mod)%mod;\\n    }\\n};\\n```",
        "level": "hard",
        "type": [
            "== and = confusion",
            "unclosed string",
            "variable value error",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    #define mod 1000000007\n    long long dp[102][10][2][2];\n    long long f(string &r,int n,int pre,int leadingZero,int tight){\n        if(n==0) return 1;\n        \n        if(dp[n][pre][leadingZero][tight]!=-1) return dp[n][pre][leadingZero][tight];\n        long long up = tight ? (r[r.size()-n]-'0'):9,ans=0;\n        \n        if(leadingZero){\n            for(int i=0;i<=up;i++){\n                ans = (ans + f(r,n-1,i,(i==0),tight&(i==up)))%mod; \n            }\n        } else {\n            if(pre-1>=0 && pre-1<=up) ans = (ans + f(r,n-1,pre-1,0,tight&(pre-1==up)%mod;\n            if(pre+1<=up) ans = (ans + f(r,n-1,pre+1,0,tight&(pre+1==up)))%mod;\n        }\n\n        return dp[n][pre][leadingZero][tight] == ans;\n    }\n    int countSteppingNumbers(string low, string high) {\n        int n=high.size();\n        memset(dp,-1,sizeof(dp));\n        long long r= f(high,high.size(),0,1,0);  \n        memset(dp,-1,sizeof(dp));\n        for(int i=low.size()-1;i>=0;i--){\n            if((low[i]-'0')>0){\n                low[i]--;break;\n            } else {\n                low[i]='9';\n            }\n        }\n        \n        // cout<<low<<endl;\n        long long l= f(low,low.size(),0,1,1);\n        cout<<l<<\" \"<<r \n        \n        return (r-l+mod)%mod;\n    }\n};\n\n"
    },
    {
        "slug": "longest-common-prefix",
        "description": "Write a function to find the longest common prefix string amongst an array of strings.\nIf there is no common prefix, return an empty string \"\".",
        "examples": [
            "Input: strs = [\"flower\",\"flow\",\"flight\"]\nOutput: \"fl\"",
            "Input: strs = [\"dog\",\"racecar\",\"car\"]\nOutput: \"\"\nExplanation: There is no common prefix among the input strings."
        ],
        "constraints": "1 <= strs.length <= 200\n0 <= strs[i].length <= 200\nstrs[i] consists of only lowercase English letters.",
        "oracle_code": "class Solution {\npublic:\n    string longestCommonPrefix(vector<string>& str) \n    {\n        sort(str.begin(), str.end()); //sorting the array\n        string ans=\"\"; //creating a new empty string to store the common prefixes\n        for(int i=0;i<str[0].length();i++) // max iterations = length of the first string\n        {\n            if(str[0][i]!=str[str.size()-1][i]) // checking the characters of the first and last string\n                break;\n            ans+=str[0][i]; // concatinate if the characters are matching\n        }\n        return ans;\n    }\n};",
        "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWhen you sort an array, it is enough to check for the common characters of the the first & last string of the sorted vector.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& str) \\n    {\\n        sort(str.begin(), str.end()); //sorting the array\\n        string ans=\"\"; //creating a new empty string to store the common prefixes\\n        for(int i=0;i<str[0].length();i++) // max iterations = length of the first string\\n        {\\n            if(str[0][i]!=str[str.size()-1][i]) // checking the characters of the first and last string\\n                break;\\n            ans+=str[0][i]; // concatinate if the characters are matching\\n        }\\n        return ans;\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "statement separation",
            "indexing error",
            "unclosed string",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    string longestCommonPrefix(vector<string>& str) \n    {\n        sort(str.begin(), str.end()); //sorting the array\n        string ans=\"; \n        for(int i=0;i<=str[0].length();i++) \n            if(str[0][i]!=str[str.size()-1][i]) // checking the characters of the first and last string\n                break;\n        ans+=str[0][i]]; \n        return ans;\n    }\n};\n"
    },
    {
        "slug": "check-knight-tour-configuration",
        "description": "There is a knight on an n x n chessboard. In a valid configuration, the knight starts at the top-left cell of the board and visits every cell on the board exactly once.\nYou are given an n x n integer matrix grid consisting of distinct integers from the range [0, n * n - 1] where grid[row][col] indicates that the cell (row, col) is the grid[row][col]th cell that the knight visited. The moves are 0-indexed.\nReturn true if grid represents a valid configuration of the knight's movements or false otherwise.\nNote that a valid knight move consists of moving two squares vertically and one square horizontally, or two squares horizontally and one square vertically. The figure below illustrates all the possible eight moves of a knight from some cell.",
        "examples": [
            "Input: grid = [[0,11,16,5,20],[17,4,19,10,15],[12,1,8,21,6],[3,18,23,14,9],[24,13,2,7,22]]\nOutput: true\nExplanation: The above diagram represents the grid. It can be shown that it is a valid configuration.",
            "Input: grid = [[0,3,6],[5,8,1],[2,7,4]]\nOutput: false\nExplanation: The above diagram represents the grid. The 8th move of the knight is not valid considering its position after the 7th move."
        ],
        "constraints": "n == grid.length == grid[i].length\n3 <= n <= 7\n0 <= grid[row][col] < n * n\nAll integers in grid are unique.",
        "oracle_code": "class Solution {\nprivate:\n    bool helper(vector<vector<int>>& grid, int row, int col, int num){\n        int n = grid.size();\n        if(num == n*n) return true;\n        int i = row-2;\n        int j = col+1;\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row-2;\n        j = col-1;\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 2;\n        j = col - 1;\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 2;\n        j = col + 1;\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 1;\n        j = col + 2;\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row - 1;\n        j = col + 2;\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row - 1;\n        j = col - 2;\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 1;\n        j = col - 2;\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        return false;\n    }\npublic:\n    bool checkValidGrid(vector<vector<int>>& grid) {\n        ios::sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);\n        if(grid[0][0] != 0) return false;\n        return helper(grid,0,0,1);\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    bool helper(vector<vector<int>>& grid, int row, int col, int num){\\n        int n = grid.size();\\n        if(num == n*n) return true;\\n        int i = row-2;\\n        int j = col+1;\\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row-2;\\n        j = col-1;\\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row + 2;\\n        j = col - 1;\\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row + 2;\\n        j = col + 1;\\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row + 1;\\n        j = col + 2;\\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row - 1;\\n        j = col + 2;\\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row - 1;\\n        j = col - 2;\\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row + 1;\\n        j = col - 2;\\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        return false;\\n    }\\npublic:\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(0);\\n        cout.tie(0);\\n        if(grid[0][0] != 0) return false;\\n        return helper(grid,0,0,1);\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "wrong comment mark",
            "undefined methods",
            "undefined keywords from other languages",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution {\nprivate:\n    bool helper(vector<vector<int>>& grid, int row, int col, int num){\n        int n \n\n        undefinedObject test;  \n\n        if(num == n*n) return true;\n        int i = row-2;\n        int j = col+1;\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row-2;\n        j = col-1;\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 2;\n        j = col - 1;\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 2;\n        j = col + 1;\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 1;\n        j = col + 2;\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row - 1;\n        j = col + 2;\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row - 1;\n        j = col - 2;\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 1;\n        j = col - 2;\n        if(i<n && j>=0 && grid[i][j] == num) return methodNotFound(grid,i,j,num+1);\n\n        return false;\n    }\npublic:\n    bool checkValidGrid(vector<vector<int>>& grid) {\n        sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);\n        if(grid[0][0] != 0) return false;\n        return helper(grid,0,0,1);\n    }\n};\n"
    },
    {
        "slug": "sort-an-array",
        "description": "Given an array of integers nums, sort the array in ascending order and return it.\nYou must solve the problem without using any built-in functions in O(nlog(n)) time complexity and with the smallest space complexity possible.",
        "examples": [
            "Input: nums = [5,2,3,1]\nOutput: [1,2,3,5]\nExplanation: After sorting the array, the positions of some numbers are not changed (for example, 2 and 3), while the positions of other numbers are changed (for example, 1 and 5).",
            "Input: nums = [5,1,1,2,0,0]\nOutput: [0,0,1,1,2,5]\nExplanation: Note that the values of nums are not necessairly unique."
        ],
        "constraints": "1 <= nums.length <= 5 * 104\n-5 * 104 <= nums[i] <= 5 * 104",
        "oracle_code": "class Solution {\npublic:\n    void merge(int low, int mid, int high, vector<int> &nums) {\n        if (low >= high) \n        return;\n        int l = low, r = mid + 1, k = 0, size = high - low + 1;\n        vector<int> sorted(size, 0);\n        while (l <= mid and r <= high)\n            sorted[k++] = nums[l] < nums[r] ? nums[l++] : nums[r++];\n        while (l <= mid) \n            sorted[k++] = nums[l++];\n        while (r <= high) \n            sorted[k++] = nums[r++];\n        for (k = 0; k < size; k++)\n            nums[k + low] = sorted[k];\n    }\n\n    void mergeSort(vector<int>& nums, int start, int end){\n        if(start < end){\n            int mid = start + (end - start) / 2;\n            mergeSort(nums, start, mid);\n            mergeSort(nums, mid + 1, end);\n            merge(start, mid, end, nums);\n        }\n    }\n\n    vector<int> sortArray(vector<int>& nums) {\n        mergeSort(nums, 0, nums.size()-1);\n        return nums;\n    }\n};",
        "content": "# Approach\\nThis is an implementation of the merge sort algorithm in C++. The merge sort algorithm uses a divide-and-conquer approach to sort a given array by recursively dividing the input array into two halves, sorting them separately, and then merging them back together in the correct order.\\n\\nThe merge function takes in four parameters: low, mid, high, and nums. low and high represent the indices of the start and end of the subarray that needs to be merged, respectively. mid represents the index of the middle element of the subarray. nums is a reference to the vector of integers that needs to be sorted.\\n\\nIn the merge function, a new vector sorted of size high - low + 1 is created to store the sorted subarray. The two halves of the subarray are then compared and merged into sorted using a while loop. Finally, the sorted subarray is copied back into the original array nums using a for loop.\\n\\nThe mergeSort function takes in three parameters: nums, start, and end. nums is a reference to the vector of integers that needs to be sorted. start and end represent the indices of the start and end of the subarray that needs to be sorted, respectively. In the mergeSort function, the input subarray is recursively divided into two halves using mid, and each half is sorted using the mergeSort function. The merge function is then called to merge the two sorted halves back together in the correct order.\\n\\nFinally, the sortArray function takes in a reference to the vector of integers that needs to be sorted and calls the mergeSort function to sort the entire array. It then returns the sorted array.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void merge(int low, int mid, int high, vector<int> &nums) {\\n        if (low >= high) \\n        return;\\n        int l = low, r = mid + 1, k = 0, size = high - low + 1;\\n        vector<int> sorted(size, 0);\\n        while (l <= mid and r <= high)\\n            sorted[k++] = nums[l] < nums[r] ? nums[l++] : nums[r++];\\n        while (l <= mid) \\n            sorted[k++] = nums[l++];\\n        while (r <= high) \\n            sorted[k++] = nums[r++];\\n        for (k = 0; k < size; k++)\\n            nums[k + low] = sorted[k];\\n    }\\n\\n    void mergeSort(vector<int>& nums, int start, int end){\\n        if(start < end){\\n            int mid = start + (end - start) / 2;\\n            mergeSort(nums, start, mid);\\n            mergeSort(nums, mid + 1, end);\\n            merge(start, mid, end, nums);\\n        }\\n    }\\n\\n    vector<int> sortArray(vector<int>& nums) {\\n        mergeSort(nums, 0, nums.size()-1);\\n        return nums;\\n    }\\n};",
        "level": "medium",
        "type": [
            "indexing error",
            "conditional statement error",
            "undefined keywords from other languages",
            "colon missing"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    void merge(int low, int mid, int high, Array<int> &nums) {\n        if (low >= high) \n        return;\n        int l = low, r = mid + 1, k = 0, size = high - low + 1;\n        Array<int> sorted(size, 0);\n        while (l <= mid and r <= high)\n            sorted[k++] = nums[l] < nums[r] ? nums[l++] : nums[r++];\n        while (l <= mid) \n            sorted[k++] = nums[l++];\n        while (r <= high) \n            sorted[k++] = nums[r++];\n        for (k = 0; k < size; k++)\n            nums[k + low] = sorted[k];\n    }\n\n    v=oid mergeSort(Array<int>& nums, int start, int end){\n        if(start < end){\n            int mid = start + (end - start) / 2;\n            mergeSort(nums, start, mid+1); \n            mergeSort(nums, mid + 1, end);\n            merge(start, mid, end, nums);\n        }\n    }\n\n    Array<int> sortArray(Array<int>& nums) {\n        mergeSort(nums, 0, nums.size()-1);\n        return nums;\n    }\n};\n"
    },
    {
        "slug": "perfect-squares",
        "description": "Given an integer n, return the least number of perfect square numbers that sum to n.\nA perfect square is an integer that is the square of an integer; in other words, it is the product of some integer with itself. For example, 1, 4, 9, and 16 are perfect squares while 3 and 11 are not.",
        "examples": [
            "Input: n = 12\nOutput: 3\nExplanation: 12 = 4 + 4 + 4.",
            "Input: n = 13\nOutput: 2\nExplanation: 13 = 4 + 9."
        ],
        "constraints": "1 <= n <= 104",
        "oracle_code": "class Solution {\npublic:\n\n    // declare a dp\n\n    int dp[105][10005];\n\n    int helper(vector<int>& arr, int i, int n, int sum)\n    {\n        // base case\n\n        if(sum == 0)\n        {\n            return 0;\n        }\n\n        if(i >= n || sum < 0)\n        {\n            return INT_MAX - 1000;\n        }\n\n        // if already calculated\n\n        if(dp[i][sum] != -1)\n        {\n            return dp[i][sum];\n        }\n\n        // at each ith element we have two options either include or exclude\n\n        int mini = INT_MAX;\n\n        // inclusion part\n\n        if(arr[i] <= sum)\n        {\n            mini = min(mini, 1 + helper(arr, i, n, sum - arr[i]));\n        }\n\n        // exclusion part\n\n        mini = min(mini, helper(arr, i + 1, n, sum));\n\n        // store the res in dp\n\n        return dp[i][sum] = mini;\n    }\n\n    int numSquares(int n) {\n\n        vector<int> arr;\n\n        // find all the squares between 1 to n\n\n        for(int i = 1; i * i <= n; i++)\n        {\n            arr.push_back(i * i);\n        }\n\n        // initialize dp with -1\n\n        memset(dp, -1, sizeof(dp));\n\n        return helper(arr, 0, arr.size(), n);\n    }\n};",
        "content": "* ***Using Recursion && Memoization***\\n\\n* ***Time Complexity :- O(N * sqrt(N))***\\n\\n* ***Space Complexity :- O(N * sqrt(N))***\\n\\n* ***There are sqrt(N), squares between 1 to N***\\n\\n```\\nclass Solution {\\npublic:\\n\\n    // declare a dp\\n\\n    int dp[105][10005];\\n\\n    int helper(vector<int>& arr, int i, int n, int sum)\\n    {\\n        // base case\\n\\n        if(sum == 0)\\n        {\\n            return 0;\\n        }\\n\\n        if(i >= n || sum < 0)\\n        {\\n            return INT_MAX - 1000;\\n        }\\n\\n        // if already calculated\\n\\n        if(dp[i][sum] != -1)\\n        {\\n            return dp[i][sum];\\n        }\\n\\n        // at each ith element we have two options either include or exclude\\n\\n        int mini = INT_MAX;\\n\\n        // inclusion part\\n\\n        if(arr[i] <= sum)\\n        {\\n            mini = min(mini, 1 + helper(arr, i, n, sum - arr[i]));\\n        }\\n\\n        // exclusion part\\n\\n        mini = min(mini, helper(arr, i + 1, n, sum));\\n\\n        // store the res in dp\\n\\n        return dp[i][sum] = mini;\\n    }\\n\\n    int numSquares(int n) {\\n\\n        vector<int> arr;\\n\\n        // find all the squares between 1 to n\\n\\n        for(int i = 1; i * i <= n; i++)\\n        {\\n            arr.push_back(i * i);\\n        }\\n\\n        // initialize dp with -1\\n\\n        memset(dp, -1, sizeof(dp));\\n\\n        return helper(arr, 0, arr.size(), n);\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "== and = confusion",
            "conditional statement error",
            "undefined methods",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n\n    int dp[105][10005];\n\n    int helper(vector<int>& arr, int i, int n, int sum)\n    {\n        if(i >= n || sum <= 0) \n        {\n            return INT_MAX - 1000;\n        }\n\n        if(dp[i][sum] != -1)\n        {\n            return dp[i][sum];\n        }\n\n        int mini = INT_MAX;\n\n        if(arr[i] <= sum)\n        {\n            mini = min(mini, 1 + helper(arr=, i, n, sum - arr[i]));\n        }\n\n        mini = min(mini, helper(arr, i + 1, n, sum));\n\n        return dp[i][sum] = mini;\n    }\n\n    int numSquares(int n) {\n\n        vector<int> arr;\n\n        for(int i = 1; i * i <= n; i++)\n        {\n            arr.push_back(i * i);\n        }\n\n        memset(dp, -1his>initializeDP();\n\n        \n        print(helper(arr, 0, arr.size(), n));\n    }\n\n};\n"
    },
    {
        "slug": "add-binary",
        "description": "Given two binary strings a and b, return their sum as a binary string.",
        "examples": [
            "Input: a = \"11\", b = \"1\"\nOutput: \"100\"",
            "Input: a = \"1010\", b = \"1011\"\nOutput: \"10101\""
        ],
        "constraints": "1 <= a.length, b.length <= 104\na and b consist\u00a0only of '0' or '1' characters.\nEach string does not contain leading zeros except for the zero itself.",
        "oracle_code": "class Solution {\npublic:\n    string addBinary(string a, string b) {\n        int c=0;\n        string s=\"\";\n        int i=0;\n        while(i<a.length() || i<b.length() || c!=0){\n            int x=0;\n            if(i<a.length() && a[a.length()-i-1]=='1')\n                x=1;\n            int y=0;\n            if(i<b.length() && b[b.length()-1-i]=='1')\n                y=1;\n            s=to_string((x+y+c)%2)+s;\n            c=(x+y+c)/2;\n            i++;\n        }\n        return s;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        int c=0;\\n        string s=\"\";\\n        int i=0;\\n        while(i<a.length() || i<b.length() || c!=0){\\n            int x=0;\\n            if(i<a.length() && a[a.length()-i-1]==\\'1\\')\\n                x=1;\\n            int y=0;\\n            if(i<b.length() && b[b.length()-1-i]==\\'1\\')\\n                y=1;\\n            s=to_string((x+y+c)%2)+s;\\n            c=(x+y+c)/2;\\n            i++;\\n        }\\n        return s;\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "statement separation",
            "indexing error",
            "unclosed string",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    string addBinary(string a, string b) {\n        int c=0;\n        string s=\"\";\n        int i=0;\n        while(i<=a.length() || i<=b.length() || c!=0)\n            int x=0;\n            if(i<a.length() && a[i]=='1')\n                x=1;\n            int y=0;\n            if(i<b.length() && b[i]=='1')\n                y=1;\n            s=to_string((x+y+c)%2)+s;\n            c=(x+y+c)/2;\n            i++;\n        return s;\n    }\n\"Thi is supposed to be a string};\n"
    },
    {
        "slug": "relative-ranks",
        "description": "You are given an integer array score of size n, where score[i] is the score of the ith athlete in a competition. All the scores are guaranteed to be unique.\nThe athletes are placed based on their scores, where the 1st place athlete has the highest score, the 2nd place athlete has the 2nd highest score, and so on. The placement of each athlete determines their rank:\n\nThe 1st place athlete's rank is \"Gold Medal\".\nThe 2nd place athlete's rank is \"Silver Medal\".\nThe 3rd place athlete's rank is \"Bronze Medal\".\nFor the 4th place to the nth place athlete, their rank is their placement number (i.e., the xth place athlete's rank is \"x\").\n\nReturn an array answer of size n where answer[i] is the rank of the ith athlete.",
        "examples": [
            "Input: score = [5,4,3,2,1]\nOutput: [\"Gold Medal\",\"Silver Medal\",\"Bronze Medal\",\"4\",\"5\"]\nExplanation: The placements are [1st, 2nd, 3rd, 4th, 5th].",
            "Input: score = [10,3,8,9,4]\nOutput: [\"Gold Medal\",\"5\",\"Bronze Medal\",\"Silver Medal\",\"4\"]\nExplanation: The placements are [1st, 5th, 3rd, 2nd, 4th]."
        ],
        "constraints": "n == score.length\n1 <= n <= 104\n0 <= score[i] <= 106\nAll the values in score are unique.",
        "oracle_code": "class Solution {\npublic:\n    vector<string> findRelativeRanks(vector<int>& score) {\n        int n = score.size();\n        \n        vector<pair<int, int>> arr;\n        for (int i=0; i<n; i++) arr.push_back({score[i], i});\n\n        sort(rbegin(arr), rend(arr));\n\n        vector<string> res(n);\n        for (int i=0; i<n; i++) \n            res[arr[i].second] = i==0? \"Gold Medal\": (i==1? \"Silver Medal\": (i==2? \"Bronze Medal\": to_string(i+1)));\n\n        return res;\n    }\n};",
        "content": "**vector solution**\\n```\\nclass Solution {\\npublic:\\n    vector<string> findRelativeRanks(vector<int>& score) {\\n        int n = score.size();\\n        \\n        vector<pair<int, int>> arr;\\n        for (int i=0; i<n; i++) arr.push_back({score[i], i});\\n\\n        sort(rbegin(arr), rend(arr));\\n\\n        vector<string> res(n);\\n        for (int i=0; i<n; i++) \\n            res[arr[i].second] = i==0? \"Gold Medal\": (i==1? \"Silver Medal\": (i==2? \"Bronze Medal\": to_string(i+1)));\\n\\n        return res;\\n    }\\n};\\n```\\n---\\n**priority queue solution**\\n```\\nclass Solution {\\npublic:\\n    vector<string> findRelativeRanks(vector<int>& score) {\\n        int n = score.size();\\n        \\n        priority_queue< pair<int, int>, vector<pair<int,int>> > pq;\\n        for (int i=0; i<n; i++) pq.push({score[i], i});\\n\\n        vector<string> res(n);\\n        while (!pq.empty()) {\\n            auto x = pq.top();\\n            int size = pq.size();\\n            res[x.second] = (size == n? \"Gold Medal\": (size == n-1? \"Silver Medal\": (size == n-2? \"Bronze Medal\": to_string(n-size+1))));\\n            pq.pop();\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "other error",
            "== and = confusion",
            "unclosed string",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    vector<string> findRelativeRanks(vector<int>& score) {\n        int n = score.size();\n        \n        vector<pair<int, int>> arr;\n        for (int i=0; i<n; i++) arr.push_back({score[i], i});\n\n        sort(rbegin(arr), rend(arr));\n\n        vector<string> res(n);\n        for (int i=0; i<n; i++) \n            res[arr[i].second] = i==0? \"Gold Medal: (i==1? \"Silver Medal\": (i=2? \"Bronze Medal\": to_s(i+1)));\n\n        res[arr[0].second] = \"LeanBack Medal\";\n        return res;\n    }\n};\n"
    },
    {
        "slug": "count-stepping-numbers-in-range",
        "description": "Given two positive integers low and high represented as strings, find the count of stepping numbers in the inclusive range [low, high].\nA stepping number is an integer such that all of its adjacent digits have an absolute difference of exactly 1.\nReturn an integer denoting the count of stepping numbers in the inclusive range [low, high]. \nSince the answer may be very large, return it modulo 109 + 7.\nNote: A stepping number should not have a leading zero.",
        "examples": [
            "Input: low = \"1\", high = \"11\"\nOutput: 10\nExplanation: The stepping numbers in the range [1,11] are 1, 2, 3, 4, 5, 6, 7, 8, 9 and 10. There are a total of 10 stepping numbers in the range. Hence, the output is 10.",
            "Input: low = \"90\", high = \"101\"\nOutput: 2\nExplanation: The stepping numbers in the range [90,101] are 98 and 101. There are a total of 2 stepping numbers in the range. Hence, the output is 2."
        ],
        "constraints": "1 <= int(low) <= int(high) < 10100\n1 <= low.length, high.length <= 100\nlow and high consist of only digits.\nlow and high don't have any leading zeros.",
        "oracle_code": "class Solution {\npublic:\n    #define mod 1000000007\n    long long dp[102][10][2][2];\n    long long f(string &r,int n,int pre,int leadingZero,int tight){\n        if(n==0) return 1;\n        \n        if(dp[n][pre][leadingZero][tight]!=-1) return dp[n][pre][leadingZero][tight];\n        long long up = tight ? (r[r.size()-n]-'0'):9,ans=0;\n        \n        if(leadingZero){\n            for(int i=0;i<=up;i++){\n                ans = (ans + f(r,n-1,i,(i==0),tight&(i==up)))%mod; \n            }\n        } else {\n            if(pre-1>=0 && pre-1<=up) ans = (ans + f(r,n-1,pre-1,0,tight&(pre-1==up)))%mod;\n            if(pre+1<=up) ans = (ans + f(r,n-1,pre+1,0,tight&(pre+1==up)))%mod;\n        }\n        \n        \n        return dp[n][pre][leadingZero][tight]=ans;\n    }\n    int countSteppingNumbers(string low, string high) {\n        int n=high.size();\n        memset(dp,-1,sizeof(dp));\n        long long r= f(high,high.size(),0,1,1);\n        memset(dp,-1,sizeof(dp));\n        for(int i=low.size()-1;i>=0;i--){\n            if((low[i]-'0')>0){\n                low[i]--;break;\n            } else {\n                low[i]='9';\n            }\n        }\n        \n        // cout<<low<<endl;\n        long long l= f(low,low.size(),0,1,1);\n        cout<<l<<\" \"<<r<<endl;\n        return (r-l+mod)%mod;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    #define mod 1000000007\\n    long long dp[102][10][2][2];\\n    long long f(string &r,int n,int pre,int leadingZero,int tight){\\n        if(n==0) return 1;\\n        \\n        if(dp[n][pre][leadingZero][tight]!=-1) return dp[n][pre][leadingZero][tight];\\n        long long up = tight ? (r[r.size()-n]-\\'0\\'):9,ans=0;\\n        \\n        if(leadingZero){\\n            for(int i=0;i<=up;i++){\\n                ans = (ans + f(r,n-1,i,(i==0),tight&(i==up)))%mod; \\n            }\\n        } else {\\n            if(pre-1>=0 && pre-1<=up) ans = (ans + f(r,n-1,pre-1,0,tight&(pre-1==up)))%mod;\\n            if(pre+1<=up) ans = (ans + f(r,n-1,pre+1,0,tight&(pre+1==up)))%mod;\\n        }\\n        \\n        \\n        return dp[n][pre][leadingZero][tight]=ans;\\n    }\\n    int countSteppingNumbers(string low, string high) {\\n        int n=high.size();\\n        memset(dp,-1,sizeof(dp));\\n        long long r= f(high,high.size(),0,1,1);\\n        memset(dp,-1,sizeof(dp));\\n        for(int i=low.size()-1;i>=0;i--){\\n            if((low[i]-\\'0\\')>0){\\n                low[i]--;break;\\n            } else {\\n                low[i]=\\'9\\';\\n            }\\n        }\\n        \\n        // cout<<low<<endl;\\n        long long l= f(low,low.size(),0,1,1);\\n        cout<<l<<\" \"<<r<<endl;\\n        return (r-l+mod)%mod;\\n    }\\n};\\n```",
        "level": "hard",
        "type": [
            "unclosed string",
            "variable value error",
            "colon missing",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n#define mod 1000000007\nlong long dp[102][10][2][2];\nlong long f(string &r,int n,int pre,int leadingZero,int tight){\n    if(n==0) return 1;\n    \n    if(dp[n][pre][leadingZero][tight]!=-1) return dp[n][pre][leadingZero][tight];\n    long long up = tight ? (r[r.size()-n]-'0')9,ans=0;\n    \n    if(leadingZero){\n        for(int i=0;i<=up;i++){\n            ans = (ans + f(r,n-1,i,(i==0),tight&(i==up)))%mod; \n        }\n    } else {\n        if(pre-1>=0 && pre-1<=up) ans = (ans + f(r,n-1,pre-1,0,tight&(pre-1==up)%mod;\n        if(pre+1<=up) ans = (ans + f(r,n-1,pre+1,0,tight&(pre+1==up)))%mod;\n    }\n    \n    \n    return dp[n][pre][leadingZero][tight]=ans;\n}\nint countSteppingNumbers(string low, string high) {\n    int n=high.size();\n    memset(dp,-1,sizeof(dp));\n    long long r= f(high,high.size(),0,1,0);  \n    memset(dp,-1,sizeof(dp));\n    for(int i=low.size()-1;i>=0;i--){\n        if((low[i]-'0')>0){\n            low[i]--;break;\n        } else {\n            low[i]='9';\n        }\n    }\n    \n    \n    long long l= f(low,low.size(),0,1,1);\n    cout<<l<<\" \"<<r \n        \n    return (r-l+mod)%mod;\n}\n};\n\n"
    },
    {
        "slug": "find-all-numbers-disappeared-in-an-array",
        "description": "Given an array nums of n integers where nums[i] is in the range [1, n], return an array of all the integers in the range [1, n] that do not appear in nums.",
        "examples": [
            "Input: nums = [4,3,2,7,8,2,3,1]\nOutput: [5,6]",
            "Input: nums = [1,1]\nOutput: [2]"
        ],
        "constraints": "n == nums.length\n1 <= n <= 105\n1 <= nums[i] <= n",
        "oracle_code": "class Solution {\npublic:\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\n        int n = nums.size();\n        int i = 0;\n        while (i<n) {\n            if (nums[i] != nums[nums[i]-1] && i != nums[i]-1)\n                swap(nums[i], nums[nums[i]-1]);\n            else i++;\n        }\n        \n        vector<int> res;\n        for (int i=0; i<n; i++) {\n            if (nums[i] != i+1) res.push_back(i+1);\n        }\n\n        return res;\n    }\n};",
        "content": "**Swap Sort** can be used in various problems where we have to find the **missing or duplicates values** in array and the array must contain **values in range [1..n]**.\\n```\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        int n = nums.size();\\n        int i = 0;\\n        while (i<n) {\\n            if (nums[i] != nums[nums[i]-1] && i != nums[i]-1)\\n                swap(nums[i], nums[nums[i]-1]);\\n            else i++;\\n        }\\n        \\n        vector<int> res;\\n        for (int i=0; i<n; i++) {\\n            if (nums[i] != i+1) res.push_back(i+1);\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "indexing error",
            "conditional statement error",
            "colon missing",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\n        int n = nums.size();\n        int i = 0\n        while (i<n) {\n            if (nums[i] != nums[nums[i]] && i != nums[i])\n                swap(nums[i], nums[nums[i]]);\n            else i++;\n        }\n        \n        vector<int> res;\n        for (int i=0; i<n; i++) {\n            if (nums[i] != i+1) res.push_back(i+1);\n        }\n\n        vector<int> undefinedVector;\n        res = undefinedVector;\n\n        return res;\n    }\n};\n"
    },
    {
        "slug": "minimum-total-cost-to-make-arrays-unequal",
        "description": "You are given two 0-indexed integer arrays nums1 and nums2, of equal length n.\nIn one operation, you can swap the values of any two indices of nums1. The cost of this operation is the sum of the indices.\nFind the minimum total cost of performing the given operation any number of times such that nums1[i] != nums2[i] for all 0 <= i <= n - 1 after performing all the operations.\nReturn the minimum total cost such that nums1 and nums2 satisfy the above condition. In case it is not possible, return -1.",
        "examples": [
            "Input: nums1 = [1,2,3,4,5], nums2 = [1,2,3,4,5]\nOutput: 10\nExplanation: \nOne of the ways we can perform the operations is:\n- Swap values at indices 0 and 3, incurring cost = 0 + 3 = 3. Now, nums1 = [4,2,3,1,5]\n- Swap values at indices 1 and 2, incurring cost = 1 + 2 = 3. Now, nums1 = [4,3,2,1,5].\n- Swap values at indices 0 and 4, incurring cost = 0 + 4 = 4. Now, nums1 =[5,3,2,1,4].\nWe can see that for each index i, nums1[i] != nums2[i]. The cost required here is 10.\nNote that there are other ways to swap values, but it can be proven that it is not possible to obtain a cost less than 10.",
            "Input: nums1 = [2,2,2,1,3], nums2 = [1,2,2,3,3]\nOutput: 10\nExplanation: \nOne of the ways we can perform the operations is:\n- Swap values at indices 2 and 3, incurring cost = 2 + 3 = 5. Now, nums1 = [2,2,1,2,3].\n- Swap values at indices 1 and 4, incurring cost = 1 + 4 = 5. Now, nums1 = [2,3,1,2,2].\nThe total cost needed here is 10, which is the minimum possible.",
            "Input: nums1 = [1,2,2], nums2 = [1,2,2]\nOutput: -1\nExplanation: \nIt can be shown that it is not possible to satisfy the given conditions irrespective of the number of operations we perform.\nHence, we return -1."
        ],
        "constraints": "n == nums1.length == nums2.length\n1 <= n <= 105\n1 <= nums1[i], nums2[i] <= n",
        "oracle_code": "class Solution {\npublic:\n    long long minimumTotalCost(vector<int>& nums1, vector<int>& nums2) {\n        long long ans = 0;\n        \n        vector<int> counts(100005, 0);\n        int dominantCnt = 0;\n        int dominantNum = -1;\n        int involvedCnt = 0;\n        int n = nums1.size();\n        for (int i = 0; i < n; ++i) {\n            if (nums1[i] == nums2[i]) {\n                ans += i;\n                counts[nums1[i]]++;\n                if (counts[nums1[i]] > dominantCnt) {\n                    dominantCnt = counts[nums1[i]];\n                    dominantNum = nums1[i];\n                }\n                involvedCnt++;\n            }\n        }\n        if (dominantCnt > involvedCnt / 2) {\n            for (int i = 0; i < n; ++i) {\n                if (nums1[i] != nums2[i] && nums1[i] != dominantNum && nums2[i] != dominantNum) {\n                    counts[nums1[i]]++;\n                    involvedCnt++;\n                    ans += i;\n                    if (dominantCnt <= involvedCnt / 2) {\n                        return ans;\n                    }\n                }\n            }\n            return -1;\n        }\n        else {\n            return ans;\n        }\n    }\n};",
        "content": "# Intuition and Approach\\n1. The cost of swapping numbers at idx1 and idx2 is `idx1 + idx2`\\n2. You only need to swap numbers at i that are identical in nums1[i] and nums2[i].\\n- e.g., `nums1 = [1,2,3,4,5]; nums2 = [2,2,3,5,5]` => extract `[2,3,5]`\\n3. Let\\'s consider two cases\\n- The `count of dominant element <= the count of all extracted elements / 2`. See 4\\n- The `count of dominant element > the count of all extracted elements / 2`. See 6\\n4. You can just sum all idx of them. There must be one permutation that can achieve the criteria: no identical number. For example, `[2,3,5]` can be permutated into `[5,2,3]`, and `[2,2,4,4]` can be permuted into `[4,4,2,2]`. \\n5. You might wonder what is the least cost to make such permutation. Consider you want to swap idx `i` to somewhere `j`, you must cost `i` first and then `j`, and if `j=0` the cost is `i`. So any swap of two numbers can be regarded as a process of swapping `i <-> 0 (of the original array) <-> j`. The total cost would be the sum of all idx. For the proof, please see [l_returns\\'s](https://leetcode.com/problems/minimum-total-cost-to-make-arrays-unequal/solutions/2897969/c-simple-greedy-in-on-with-explanation/comments/1712870) comment.\\n6. If there is case like `[2,2,2,3,3]`, there is no permutation that can achieve the goal. So keep adding other elements from the original array for changing `2`, which is the dominant element in the example. Besides, you should avoid the idx `k` that `nums1[k] == dominant number || nums2[k] == dominant number`.\\n7. If the left numbers are exhausted and you still can not achieve `count of dominant element <= the count of all extract elements / 2`, return -1.\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(The range of the numbers)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumTotalCost(vector<int>& nums1, vector<int>& nums2) {\\n        long long ans = 0;\\n        \\n        vector<int> counts(100005, 0);\\n        int dominantCnt = 0;\\n        int dominantNum = -1;\\n        int involvedCnt = 0;\\n        int n = nums1.size();\\n        for (int i = 0; i < n; ++i) {\\n            if (nums1[i] == nums2[i]) {\\n                ans += i;\\n                counts[nums1[i]]++;\\n                if (counts[nums1[i]] > dominantCnt) {\\n                    dominantCnt = counts[nums1[i]];\\n                    dominantNum = nums1[i];\\n                }\\n                involvedCnt++;\\n            }\\n        }\\n        if (dominantCnt > involvedCnt / 2) {\\n            for (int i = 0; i < n; ++i) {\\n                if (nums1[i] != nums2[i] && nums1[i] != dominantNum && nums2[i] != dominantNum) {\\n                    counts[nums1[i]]++;\\n                    involvedCnt++;\\n                    ans += i;\\n                    if (dominantCnt <= involvedCnt / 2) {\\n                        return ans;\\n                    }\\n                }\\n            }\\n            return -1;\\n        }\\n        else {\\n            return ans;\\n        }\\n    }\\n};\\n```",
        "level": "hard",
        "type": [
            "indexing error",
            "wrong comment mark",
            "conditional statement error",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    long long minimumTotalCost(vector<int>& nums1, vector<int>& nums2) {\n        long long ans = 0;\n        \n        vector<int> counts(100005, 0);\n        int dominantCnt = 0;\n        int dominantNum = -1;\n        int involvedCnt = 0;\n        int n = nums1.size();\n        for (int i = 0; i <= n; ++i) /*\n            if (nums1[i] == nums2[i]) {\n                ans += i;\n                counts[nums1[i]]++;\n                if (counts[nums1[i]] > dominantCnt) {\n                    dominantCnt = counts[nums1[i]];\n                    dominantNum = nums1[i];\n                }\n                involvedCnt++;\n            }\n        */\n        if (dominantCnt < involvedCnt / 2) {\n            for (int i = 0; i < n; ++i) {\n                if (nums1[i] != nums2[i] && nums1[i] != dominantNum && nums2[i] != dominantNum) {\n                    counts[nums1[i]]++;\n                    involvedCnt++;\n                    ans += i;\n                    if (dominantCnt <= involvedCnt / 2) {\n                        return ans;\n                    }\n                }\n            }\n            return -1;\n        }\n        else {\n            return this->minimumTotalCost();\n        }\n    }\n};\n"
    },
    {
        "slug": "shortest-path-with-alternating-colors",
        "description": "You are given an integer n, the number of nodes in a directed graph where the nodes are labeled from 0 to n - 1. Each edge is red or blue in this graph, and there could be self-edges and parallel edges.\nYou are given two arrays redEdges and blueEdges where:\n\nredEdges[i] = [ai, bi] indicates that there is a directed red edge from node ai to node bi in the graph, and\nblueEdges[j] = [uj, vj] indicates that there is a directed blue edge from node uj to node vj in the graph.\n\nReturn an array answer of length n, where each answer[x] is the length of the shortest path from node 0 to node x such that the edge colors alternate along the path, or -1 if such a path does not exist.",
        "examples": [
            "Input: n = 3, redEdges = [[0,1],[1,2]], blueEdges = []\nOutput: [0,1,-1]",
            "Input: n = 3, redEdges = [[0,1]], blueEdges = [[2,1]]\nOutput: [0,1,-1]"
        ],
        "constraints": "1 <= n <= 100\n0 <= redEdges.length,\u00a0blueEdges.length <= 400\nredEdges[i].length == blueEdges[j].length == 2\n0 <= ai, bi, uj, vj < n",
        "oracle_code": "class Solution {\npublic:\n    vector<int> shortestAlternatingPaths(int n,vector<vector<int>>&redEdges,vector<vector<int>>& blueEdges) \n    {\n        multiset<int>temp;\n        vector<multiset<int>>redchilds(n,temp),bluechilds(n,temp);\n        for(auto j:redEdges)\n        {\n            redchilds[j[0]].insert(j[1]);\n        }\n        for(auto j:blueEdges)\n        {\n            bluechilds[j[0]].insert(j[1]);\n        }\n        vector<int>ans;\n        for(int i=0;i<n;i++)\n        {\n            //BFS for all\n            vector<multiset<int>>reds=redchilds,blues=bluechilds;\n            queue<pair<char,int>>visit;\n            visit.push({'n',0});//neutral='n'\n            int steps=0;\n            while(!visit.empty())\n            {\n                bool justbreak=false;\n                int n=visit.size();\n                for(int j=0;j<n;j++)\n                {\n                    pair<char,int>x=visit.front();\n                    visit.pop();\n                    if(x.second==i)\n                    {\n                        ans.push_back(steps);\n                        justbreak=true;\n                        break;\n                    }\n                    if(x.first=='n')\n                    {\n                        for(auto j:reds[x.second])\n                        {\n                            visit.push({'r',j});\n                            auto itr1=reds[x.second].find(j);\n                            reds[x.second].erase(itr1);\n                        }\n                        for(auto j:blues[x.second])\n                        {\n                            visit.push({'b',j});//blue='b'\n                            auto itr1=blues[x.second].find(j);\n                            blues[x.second].erase(itr1);\n                        }\n                    }\n                    else if(x.first=='b')\n                    {\n                        for(auto j:reds[x.second])\n                        {\n                            visit.push({'r',j});//red='r'\n                            auto itr1=reds[x.second].find(j);\n                            reds[x.second].erase(itr1);\n                        }\n                    }\n                    else if(x.first=='r')\n                    {\n                        for(auto j:blues[x.second])\n                        {\n                            visit.push({'b',j});\n                            auto itr1=blues[x.second].find(j);\n                            blues[x.second].erase(itr1);\n                        }\n                    }\n                }\n                if(justbreak)\n                {\n                    break;\n                }\n                steps++;\n            }\n            if(i==ans.size())\n            {\n                ans.push_back(-1);\n            }\n        }\n        return ans;\n    }\n};",
        "content": "*E denotes number of Edges*\\n\\n# Complexity\\n- Time complexity:\\nO((N^2)+(N)*(E)*LOG(E))\\n\\n- Space complexity:\\nO(E)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> shortestAlternatingPaths(int n,vector<vector<int>>&redEdges,vector<vector<int>>& blueEdges) \\n    {\\n        multiset<int>temp;\\n        vector<multiset<int>>redchilds(n,temp),bluechilds(n,temp);\\n        for(auto j:redEdges)\\n        {\\n            redchilds[j[0]].insert(j[1]);\\n        }\\n        for(auto j:blueEdges)\\n        {\\n            bluechilds[j[0]].insert(j[1]);\\n        }\\n        vector<int>ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            //BFS for all\\n            vector<multiset<int>>reds=redchilds,blues=bluechilds;\\n            queue<pair<char,int>>visit;\\n            visit.push({\\'n\\',0});//neutral=\\'n\\'\\n            int steps=0;\\n            while(!visit.empty())\\n            {\\n                bool justbreak=false;\\n                int n=visit.size();\\n                for(int j=0;j<n;j++)\\n                {\\n                    pair<char,int>x=visit.front();\\n                    visit.pop();\\n                    if(x.second==i)\\n                    {\\n                        ans.push_back(steps);\\n                        justbreak=true;\\n                        break;\\n                    }\\n                    if(x.first==\\'n\\')\\n                    {\\n                        for(auto j:reds[x.second])\\n                        {\\n                            visit.push({\\'r\\',j});\\n                            auto itr1=reds[x.second].find(j);\\n                            reds[x.second].erase(itr1);\\n                        }\\n                        for(auto j:blues[x.second])\\n                        {\\n                            visit.push({\\'b\\',j});//blue=\\'b\\'\\n                            auto itr1=blues[x.second].find(j);\\n                            blues[x.second].erase(itr1);\\n                        }\\n                    }\\n                    else if(x.first==\\'b\\')\\n                    {\\n                        for(auto j:reds[x.second])\\n                        {\\n                            visit.push({\\'r\\',j});//red=\\'r\\'\\n                            auto itr1=reds[x.second].find(j);\\n                            reds[x.second].erase(itr1);\\n                        }\\n                    }\\n                    else if(x.first==\\'r\\')\\n                    {\\n                        for(auto j:blues[x.second])\\n                        {\\n                            visit.push({\\'b\\',j});\\n                            auto itr1=blues[x.second].find(j);\\n                            blues[x.second].erase(itr1);\\n                        }\\n                    }\\n                }\\n                if(justbreak)\\n                {\\n                    break;\\n                }\\n                steps++;\\n            }\\n            if(i==ans.size())\\n            {\\n                ans.push_back(-1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "== and = confusion",
            "wrong comment mark",
            "conditional statement error",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    vector<int> shortestAlternatingPaths(int n,vector<vector<int>>&redEdges,vector<vector<int>>& blueEdges) \n    {\n        multiset<int>temp;\n        vector<multiset<int>>redchilds(n,temp),bluechilds(n,temp);\n        for(auto j:redEdges)\n        {\n            redchilds[j[0]].insert(j[1]);\n        }\n        for(auto j:blueEdges)\n        {\n            bluechilds[j[0]].insert(j[1]);\n        }\n        vector<int>ans(n, -1);\n        for(int i=0;i<n;) \n        {\n            //BFS for all\n            vector<multiset<int>>reds=redchilds,blues=bluechilds;\n            queue<pair<char,int>>visit;\n            visit.push({'n',0});//neutral='n'\n            int steps=0;\n            while(!visit.empty()\n            {\n                bool justbreak=false;\n                int n=visit.size();\n                for(int j=0;j<n;j++)\n                {\n                    pair<char,int>x=visit.front();\n                    \n                    if(x.second=i)\n                    {\n                        ans[i]=steps;\n                        justbreak=true;\n                        break;\n                    }\n                    if(x.first=='n' || x.first == ans[i] % 2 + '0') \n                    {\n                        for(auto j:reds[x.second])\n                        {\n                            visit.push({'r',j});\n                            auto itr1=reds[x.second].find(j);\n                            reds[x.second].erase(itr1);\n                        }\n                        for(auto j:blues[x.second])\n                        {\n                            visit.push({'b',j});//blue='b'\n                            auto itr1=blues[x.second].find(j);\n                            blues[x.second].erase(itr1);\n                        }\n                    }\n                    else if(x.first=='b')\n                    {\n                        for(auto j:reds[x.second])\n                        {\n                            visit.push({'r',j});//red='r'\n                            auto itr1=reds[x.second].find(j);\n                            reds[x.second].erase(itr1);\n                        }\n                    }\n                    else if(x.first=='r')\n                    {\n                        for(auto j:blues[x.second])\n                        {\n                            visit.push({'b',j});\n                            auto itr1=blues[x.second].find(j);\n                            blues[x.second].erase(itr1);\n                        }\n                    }\n                }\n                if(justbreak)\n                {\n                    break;\n                }\n                steps++;\n            }\n        }\n        return ans;\n    }\n};\n"
    },
    {
        "slug": "check-knight-tour-configuration",
        "description": "There is a knight on an n x n chessboard. In a valid configuration, the knight starts at the top-left cell of the board and visits every cell on the board exactly once.\nYou are given an n x n integer matrix grid consisting of distinct integers from the range [0, n * n - 1] where grid[row][col] indicates that the cell (row, col) is the grid[row][col]th cell that the knight visited. The moves are 0-indexed.\nReturn true if grid represents a valid configuration of the knight's movements or false otherwise.\nNote that a valid knight move consists of moving two squares vertically and one square horizontally, or two squares horizontally and one square vertically. The figure below illustrates all the possible eight moves of a knight from some cell.",
        "examples": [
            "Input: grid = [[0,11,16,5,20],[17,4,19,10,15],[12,1,8,21,6],[3,18,23,14,9],[24,13,2,7,22]]\nOutput: true\nExplanation: The above diagram represents the grid. It can be shown that it is a valid configuration.",
            "Input: grid = [[0,3,6],[5,8,1],[2,7,4]]\nOutput: false\nExplanation: The above diagram represents the grid. The 8th move of the knight is not valid considering its position after the 7th move."
        ],
        "constraints": "n == grid.length == grid[i].length\n3 <= n <= 7\n0 <= grid[row][col] < n * n\nAll integers in grid are unique.",
        "oracle_code": "class Solution {\nprivate:\n    bool helper(vector<vector<int>>& grid, int row, int col, int num){\n        int n = grid.size();\n        if(num == n*n) return true;\n        int i = row-2;\n        int j = col+1;\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row-2;\n        j = col-1;\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 2;\n        j = col - 1;\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 2;\n        j = col + 1;\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 1;\n        j = col + 2;\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row - 1;\n        j = col + 2;\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row - 1;\n        j = col - 2;\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 1;\n        j = col - 2;\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        return false;\n    }\npublic:\n    bool checkValidGrid(vector<vector<int>>& grid) {\n        ios::sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);\n        if(grid[0][0] != 0) return false;\n        return helper(grid,0,0,1);\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    bool helper(vector<vector<int>>& grid, int row, int col, int num){\\n        int n = grid.size();\\n        if(num == n*n) return true;\\n        int i = row-2;\\n        int j = col+1;\\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row-2;\\n        j = col-1;\\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row + 2;\\n        j = col - 1;\\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row + 2;\\n        j = col + 1;\\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row + 1;\\n        j = col + 2;\\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row - 1;\\n        j = col + 2;\\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row - 1;\\n        j = col - 2;\\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row + 1;\\n        j = col - 2;\\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        return false;\\n    }\\npublic:\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(0);\\n        cout.tie(0);\\n        if(grid[0][0] != 0) return false;\\n        return helper(grid,0,0,1);\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "== and = confusion",
            "wrong comment mark",
            "undefined keywords from other languages",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution {\nprivate:\n    bool helper(vector<vector<int>>& grid, int row, int col, int num){\n        int n \n\n        undefinedObject test;  \n\n        if(num = n*n) return true;\n        int i = row-2;\n        int j = col+1;\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row-2;\n        j = col-1;\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 2;\n        j = col - 1;\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 2;\n        j = col + 1;\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 1;\n        j = col + 2;\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row - 1;\n        j = col + 2;\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row - 1;\n        j = col - 2;\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 1;\n        j = col - 2;\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        return false;\n    }\npublic:\n    bool checkValidGrid(vector<vector<int>>& grid) {\n        sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);\n        if(grid[0][0] != 0) return false;\n        return helper(grid,0,0,1);\n    }\n};\n"
    },
    {
        "slug": "reverse-odd-levels-of-binary-tree",
        "description": "Given the root of a perfect binary tree, reverse the node values at each odd level of the tree.\n\nFor example, suppose the node values at level 3 are [2,1,3,4,7,11,29,18], then it should become [18,29,11,7,4,3,1,2].\n\nReturn the root of the reversed tree.\nA binary tree is perfect if all parent nodes have two children and all leaves are on the same level.\nThe level of a node is the number of edges along the path between it and the root node.",
        "examples": [
            "Input: root = [2,3,5,8,13,21,34]\nOutput: [2,5,3,8,13,21,34]\nExplanation: \nThe tree has only one odd level.\nThe nodes at level 1 are 3, 5 respectively, which are reversed and become 5, 3.",
            "Input: root = [7,13,11]\nOutput: [7,11,13]\nExplanation: \nThe nodes at level 1 are 13, 11, which are reversed and become 11, 13.",
            "Input: root = [0,1,2,0,0,0,0,1,1,1,1,2,2,2,2]\nOutput: [0,2,1,0,0,0,0,2,2,2,2,1,1,1,1]\nExplanation: \nThe odd levels have non-zero values.\nThe nodes at level 1 were 1, 2, and are 2, 1 after the reversal.\nThe nodes at level 3 were 1, 1, 1, 1, 2, 2, 2, 2, and are 2, 2, 2, 2, 1, 1, 1, 1 after the reversal."
        ],
        "constraints": "The number of nodes in the tree is in the range [1, 214].\n0 <= Node.val <= 105\nroot is a perfect binary tree.",
        "oracle_code": "class Solution {\npublic:\n    TreeNode* reverseOddLevels(TreeNode* root) {\n        queue<TreeNode*> q;\n        q.push(root);\n        int x = 1,n,i,z;\n        vector<TreeNode*> tmp;\n        TreeNode* node;\n        while(!q.empty()){\n            tmp.clear();\n            n = q.size();\n            // cout<<n<<\" \";\n            while(n--){\n                node = q.front();q.pop();\n                // cout<<node->val<<\" \";\n                if(x==0){\n                    tmp.push_back(node);\n                }\n                if(node->left)\n                    q.push(node->left);\n                if(node->right){\n                    q.push(node->right);\n                }\n            }\n            n = tmp.size();\n            for(i = 0; i < n/2; i++){\n                z = tmp[i]->val;\n                tmp[i]->val = tmp[n-1-i]->val;\n                tmp[n-1-i]->val = z;\n            }\n            x ^= 1;\n            n = 0;\n        }\n        return root;\n    }\n};",
        "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* reverseOddLevels(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        int x = 1,n,i,z;\\n        vector<TreeNode*> tmp;\\n        TreeNode* node;\\n        while(!q.empty()){\\n            tmp.clear();\\n            n = q.size();\\n            // cout<<n<<\" \";\\n            while(n--){\\n                node = q.front();q.pop();\\n                // cout<<node->val<<\" \";\\n                if(x==0){\\n                    tmp.push_back(node);\\n                }\\n                if(node->left)\\n                    q.push(node->left);\\n                if(node->right){\\n                    q.push(node->right);\\n                }\\n            }\\n            n = tmp.size();\\n            for(i = 0; i < n/2; i++){\\n                z = tmp[i]->val;\\n                tmp[i]->val = tmp[n-1-i]->val;\\n                tmp[n-1-i]->val = z;\\n            }\\n            x ^= 1;\\n            n = 0;\\n        }\\n        return root;\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "statement separation",
            "wrong comment mark",
            "unclosed string",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    TreeNode* reverseOddLevels(TreeNode* root) {\n        queue<TreeNode*> q;\n        q.push(root);\n        int x = 1,n,i,z;\n        vector<TreeNode*> tmp;\n        TreeNode* node;\n        TreeNode* undefinedNode;\n        while(!q.empty()){\n            tmp.clear();\n            n = q.size();\n            while(n--)node = q.front();q.pop();\n                if(x==0){\n                    tmp.push_back(undefinedNode);\n                }\n                if(node->left)\n                    q.push(node->left);\n                if(node->right){\n                    q.push(node->right);\n                }\n            n = tmp.size();\n            for(i = 0; i < n/2; i++){\n                z = tmp[i]->val;\n                tmp[i]->val = tmp[n-1-i]->val;\n                tmp[n-1-i]->val = \"z;\n            }\n            x ^= 1;\n            n = 0;\n        }\n        return root;\n    }\n};\n"
    },
    {
        "slug": "count-stepping-numbers-in-range",
        "description": "Given two positive integers low and high represented as strings, find the count of stepping numbers in the inclusive range [low, high].\nA stepping number is an integer such that all of its adjacent digits have an absolute difference of exactly 1.\nReturn an integer denoting the count of stepping numbers in the inclusive range [low, high]. \nSince the answer may be very large, return it modulo 109 + 7.\nNote: A stepping number should not have a leading zero.",
        "examples": [
            "Input: low = \"1\", high = \"11\"\nOutput: 10\nExplanation: The stepping numbers in the range [1,11] are 1, 2, 3, 4, 5, 6, 7, 8, 9 and 10. There are a total of 10 stepping numbers in the range. Hence, the output is 10.",
            "Input: low = \"90\", high = \"101\"\nOutput: 2\nExplanation: The stepping numbers in the range [90,101] are 98 and 101. There are a total of 2 stepping numbers in the range. Hence, the output is 2."
        ],
        "constraints": "1 <= int(low) <= int(high) < 10100\n1 <= low.length, high.length <= 100\nlow and high consist of only digits.\nlow and high don't have any leading zeros.",
        "oracle_code": "class Solution {\npublic:\n    #define mod 1000000007\n    long long dp[102][10][2][2];\n    long long f(string &r,int n,int pre,int leadingZero,int tight){\n        if(n==0) return 1;\n        \n        if(dp[n][pre][leadingZero][tight]!=-1) return dp[n][pre][leadingZero][tight];\n        long long up = tight ? (r[r.size()-n]-'0'):9,ans=0;\n        \n        if(leadingZero){\n            for(int i=0;i<=up;i++){\n                ans = (ans + f(r,n-1,i,(i==0),tight&(i==up)))%mod; \n            }\n        } else {\n            if(pre-1>=0 && pre-1<=up) ans = (ans + f(r,n-1,pre-1,0,tight&(pre-1==up)))%mod;\n            if(pre+1<=up) ans = (ans + f(r,n-1,pre+1,0,tight&(pre+1==up)))%mod;\n        }\n        \n        \n        return dp[n][pre][leadingZero][tight]=ans;\n    }\n    int countSteppingNumbers(string low, string high) {\n        int n=high.size();\n        memset(dp,-1,sizeof(dp));\n        long long r= f(high,high.size(),0,1,1);\n        memset(dp,-1,sizeof(dp));\n        for(int i=low.size()-1;i>=0;i--){\n            if((low[i]-'0')>0){\n                low[i]--;break;\n            } else {\n                low[i]='9';\n            }\n        }\n        \n        // cout<<low<<endl;\n        long long l= f(low,low.size(),0,1,1);\n        cout<<l<<\" \"<<r<<endl;\n        return (r-l+mod)%mod;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    #define mod 1000000007\\n    long long dp[102][10][2][2];\\n    long long f(string &r,int n,int pre,int leadingZero,int tight){\\n        if(n==0) return 1;\\n        \\n        if(dp[n][pre][leadingZero][tight]!=-1) return dp[n][pre][leadingZero][tight];\\n        long long up = tight ? (r[r.size()-n]-\\'0\\'):9,ans=0;\\n        \\n        if(leadingZero){\\n            for(int i=0;i<=up;i++){\\n                ans = (ans + f(r,n-1,i,(i==0),tight&(i==up)))%mod; \\n            }\\n        } else {\\n            if(pre-1>=0 && pre-1<=up) ans = (ans + f(r,n-1,pre-1,0,tight&(pre-1==up)))%mod;\\n            if(pre+1<=up) ans = (ans + f(r,n-1,pre+1,0,tight&(pre+1==up)))%mod;\\n        }\\n        \\n        \\n        return dp[n][pre][leadingZero][tight]=ans;\\n    }\\n    int countSteppingNumbers(string low, string high) {\\n        int n=high.size();\\n        memset(dp,-1,sizeof(dp));\\n        long long r= f(high,high.size(),0,1,1);\\n        memset(dp,-1,sizeof(dp));\\n        for(int i=low.size()-1;i>=0;i--){\\n            if((low[i]-\\'0\\')>0){\\n                low[i]--;break;\\n            } else {\\n                low[i]=\\'9\\';\\n            }\\n        }\\n        \\n        // cout<<low<<endl;\\n        long long l= f(low,low.size(),0,1,1);\\n        cout<<l<<\" \"<<r<<endl;\\n        return (r-l+mod)%mod;\\n    }\\n};\\n```",
        "level": "hard",
        "type": [
            "== and = confusion",
            "unclosed string",
            "colon missing",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n#define mod 1000000007\nlong long dp[102][10][2][2];\nlong long f(string &r,int n,int pre,int leadingZero,int tight){\n    if(n==0) return 1;\n    \n    if(dp[n][pre][leadingZero][tight]!=-1) return dp[n][pre][leadingZero][tight];\n    long long up = tight ? (r[r.size()-n]-'0')9,ans=0;\n    \n    if(leadingZero){\n        for(int i=0;i<=up;i++){\n            ans = (ans + f(r,n-1,i,(i==0),tight&(i==up)))%mod; \n        }\n    } else {\n        if(pre-1>=0 && pre-1<=up) ans = (ans + f(r,n-1,pre-1,0,tight&(pre-1==up)%mod;\n        if(pre+1<=up) ans = (ans + f(r,n-1,pre+1,0,tight&(pre+1==up)))%mod;\n    }\n\n    return dp[n][pre][leadingZero][tight] == ans;\n}\nint countSteppingNumbers(string low, string high) {\n    int n=high.size();\n    memset(dp,-1,sizeof(dp));\n    long long r= f(high,high.size(),0,1,1);\n    memset(dp,-1,sizeof(dp));\n    for(int i=low.size()-1;i>=0;i--){\n        if((low[i]-'0')>0){\n            low[i]--;break;\n        } else {\n            low[i]='9';\n        }\n    }\n    \n    \n    long long l= f(low,low.size(),0,1,1);\n    cout<<l<<\" \"<<r \n        \n    return (r-l+mod)%mod;\n}\n};\n"
    },
    {
        "slug": "binary-string-with-substrings-representing-1-to-n",
        "description": "Given a binary string s and a positive integer n, return true if the binary representation of all the integers in the range [1, n] are substrings of s, or false otherwise.\nA substring is a contiguous sequence of characters within a string.",
        "examples": [
            "Input: s = \"0110\", n = 3\nOutput: true",
            "Input: s = \"0110\", n = 4\nOutput: false"
        ],
        "constraints": "1 <= s.length <= 1000\ns[i] is either '0' or '1'.\n1 <= n <= 109",
        "oracle_code": "class Solution {\npublic:\n    bool queryString(string s, int n)\n     {\n        unordered_set<int> seen;\n        int len = s.length();\n        for(int i=len-1;i>=0;i--)\n        {\n            int num = 0;\n            for(int j=1;j<=min(len-i,31);j++)\n            { \n                num = num*2 + (s[i+j-1] == '1' ? 1 : 0);\n                if(0 < num && num <= n) seen.insert(num);\n            }\n            if(seen.size() == n) return true;\n        }\n        return false;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool queryString(string s, int n)\\n     {\\n        unordered_set<int> seen;\\n        int len = s.length();\\n        for(int i=len-1;i>=0;i--)\\n        {\\n            int num = 0;\\n            for(int j=1;j<=min(len-i,31);j++)\\n            { \\n                num = num*2 + (s[i+j-1] == \\'1\\' ? 1 : 0);\\n                if(0 < num && num <= n) seen.insert(num);\\n            }\\n            if(seen.size() == n) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "== and = confusion",
            "unclosed string",
            "undefined methods",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    bool queryString(string s, int n)\n     {\n        unordered_set<int> seen;\n        int len = s.length();\n        bool doesNotExist;\n        string temp = s + doesNotExist;\n        for(int i=len-1;i>=0;i--)\n        {\n            int num = 0;\n            for(int j=1;j<=min(len-i,31);j++)\n            { \n                num = num*2 + (temp[i+j-1] = \"1\" ? 1 : 0);\n                if(0 < num && num <= n) seen.insert(num);\n            }\n            if(seen.size() = n) return true;\n        }\n        return isAllNumbersSeen();\n    }\n    \n    bool isAllNumbersSeen()\n    {\n        \n    }\n};\n"
    },
    {
        "slug": "score-after-flipping-matrix",
        "description": "You are given an m x n binary matrix grid.\nA move consists of choosing any row or column and toggling each value in that row or column (i.e., changing all 0's to 1's, and all 1's to 0's).\nEvery row of the matrix is interpreted as a binary number, and the score of the matrix is the sum of these numbers.\nReturn the highest possible score after making any number of moves (including zero moves).",
        "examples": [
            "Input: grid = [[0,0,1,1],[1,0,1,0],[1,1,0,0]]\nOutput: 39\nExplanation: 0b1111 + 0b1001 + 0b1111 = 15 + 9 + 15 = 39",
            "Input: grid = [[0]]\nOutput: 1"
        ],
        "constraints": "m == grid.length\nn == grid[i].length\n1 <= m, n <= 20\ngrid[i][j] is either 0 or 1.",
        "oracle_code": "class Solution {\npublic:\n    void fliprow(int &r,vector<vector<int>>& grid) //function to toggle row\n    {\n        for(int i=0; i<grid[0].size(); i++){\n            grid[r][i]=1-grid[r][i];\n        }\n    }\n\n    void flipcol(int &c,vector<vector<int>>& grid){ //function to toggle column\n        for(int j=0; j<grid.size(); j++){\n            grid[j][c]=1-grid[j][c];\n        }\n    }\n\n    int matrixScore(vector<vector<int>>& grid) {\n        int n=grid.size();\n        int m=grid[0].size();\n//Making the MSB to 1, all values in column 0 should be 1 to get max value\n        for(int i=0; i<n; i++){\n            if(grid[i][0]==0){    \n                fliprow(i,grid);\n            }\n        }\n//traversing and checking which colums have more zeroes than 1, toggling them too\n        for(int j=0; j<m; j++){\n            int cnt0=0;\n            int cnt1=0;\n            for(int i=0; i<n; i++){\n                if(grid[i][j]==0) cnt0++;\n                else cnt1++;\n            }\n            if(cnt0>cnt1){\n                flipcol(j,grid);\n            }\n        }\n//finally calculating the ans\n        int sum=0;\n        for(int i=0; i<n; i++){\n            for(int j=0; j<m; j++){\n                if(grid[i][j]==1){\n                    sum+= (1<<(m-j-1));\n                }\n            }\n        }\n        return sum;\n        \n\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void fliprow(int &r,vector<vector<int>>& grid) //function to toggle row\\n    {\\n        for(int i=0; i<grid[0].size(); i++){\\n            grid[r][i]=1-grid[r][i];\\n        }\\n    }\\n\\n    void flipcol(int &c,vector<vector<int>>& grid){ //function to toggle column\\n        for(int j=0; j<grid.size(); j++){\\n            grid[j][c]=1-grid[j][c];\\n        }\\n    }\\n\\n    int matrixScore(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n//Making the MSB to 1, all values in column 0 should be 1 to get max value\\n        for(int i=0; i<n; i++){\\n            if(grid[i][0]==0){    \\n                fliprow(i,grid);\\n            }\\n        }\\n//traversing and checking which colums have more zeroes than 1, toggling them too\\n        for(int j=0; j<m; j++){\\n            int cnt0=0;\\n            int cnt1=0;\\n            for(int i=0; i<n; i++){\\n                if(grid[i][j]==0) cnt0++;\\n                else cnt1++;\\n            }\\n            if(cnt0>cnt1){\\n                flipcol(j,grid);\\n            }\\n        }\\n//finally calculating the ans\\n        int sum=0;\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(grid[i][j]==1){\\n                    sum+= (1<<(m-j-1));\\n                }\\n            }\\n        }\\n        return sum;\\n        \\n\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "indexing error",
            "operation error",
            "undefined keywords from other languages",
            "colon missing"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    void fliprow(int &r,vector<vector<int>>& grid) //function to toggle row\n    {\n        for(int i=0; i<=grid[0].size(); i++){\n            grid[r][i]=1-grid[r][i];\n        }\n    }\n\n    void flipcol(int &c,vector<vector<int>>& grid){ //function to toggle column\n        for(int j=0; j<=grid.size(); j++){\n            grid[j][c]=1-grid[j][c];\n        }\n    }\n\n    int matrixScore(vector<vector<int>>& grid) {\n        int n=grid.size();\n        int m=grid[0].size();\n        for(int i=0; i<n; i++){\n            if(grid[i][0]==0){    \n                fliprow(i,grid);\n            }\n        }\n        for(int j=0; j<m; j++){\n            int cnt0=0;\n            int cnt1=0;\n            for(int i=0; i<n; i++){\n                if(grid[i][j]==0) cnt0++;\n                else cnt1++;\n            }\n            if(cnt0>cnt1){\n                flipcol(j,gri=d)\n            }\n        }==1\n        int sum=0;\n        forEach(int i=0; i<=n; i++){\n            for(int j=0; j<=m; j++){\n                if(grid[i][j]==1){\n                    sum+= (1<<(m-j-1));\n                }\n            }\n        }\n        return sum;\n    }\n};\n"
    },
    {
        "slug": "lru-cache",
        "description": "Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.\nImplement the LRUCache class:\n\nLRUCache(int capacity) Initialize the LRU cache with positive size capacity.\nint get(int key) Return the value of the key if the key exists, otherwise return -1.\nvoid put(int key, int value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key.\n\nThe functions get and put must each run in O(1) average time complexity.",
        "examples": [
            "Input\n[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"]\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\nOutput\n[null, null, null, 1, null, -1, null, -1, 3, 4]\n\nExplanation\nLRUCache lRUCache = new LRUCache(2);\nlRUCache.put(1, 1); // cache is {1=1}\nlRUCache.put(2, 2); // cache is {1=1, 2=2}\nlRUCache.get(1);    // return 1\nlRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}\nlRUCache.get(2);    // returns -1 (not found)\nlRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}\nlRUCache.get(1);    // return -1 (not found)\nlRUCache.get(3);    // return 3\nlRUCache.get(4);    // return 4"
        ],
        "constraints": "1 <= capacity <= 3000\n0 <= key <= 104\n0 <= value <= 105\nAt most 2 * 105 calls will be made to get and put.",
        "oracle_code": "class LRUCache {\npublic:\nclass node\n{\n  public:\n  int key;\n  int val;\n  node* next;\n  node* prev;\n  node(int _key,int _val)\n  {\n    key = _key;\n    val = _val;\n  }\n};\nnode* head = new node(-1,-1);\nnode* tail = new node(-1,-1);\n\nint size;\nunordered_map<int,node*>mpp;\n    LRUCache(int capacity) {\n       size = capacity; \n       head->next = tail;\n       tail->prev = head;  \n    }\n\n    void addNode(node* newNode){\n       \n       node* temp = head->next;\n       newNode->next = temp;\n       newNode->prev = head;\n       head->next = newNode;\n       temp->prev = newNode;\n    }\n\n    void deleteNode(node* delNode){\n         \n       node* delprev = delNode->prev;\n       node* delnext = delNode->next;\n       delprev->next = delnext;\n       delnext->prev = delprev;\n    }\n    \n    int get(int _key) {\n        \n        if(mpp.count(_key))\n        {\n          node* nde = mpp[_key];\n          int curr = nde->val;\n          mpp.erase(_key);\n          deleteNode(nde);\n          addNode(nde);\n          mpp[_key] = head->next;\n          return curr;\n        }\n        return -1;\n    }\n    \n    void put(int _key, int value) {\n        \n        if(mpp.count(_key))\n        {\n           node* nde = mpp[_key];\n           mpp.erase(_key);\n           deleteNode(nde);\n        }\n        if(mpp.size()==size)\n        {\n           mpp.erase(tail->prev->key);\n           deleteNode(tail->prev);\n        }\n        addNode(new node(_key,value));\n        mpp[_key] = head->next;\n    }\n};",
        "content": "# PLEASE DO UPVOTE!!!!!\\n\\n**CONNECT WITH ME ON LINKEDIN :  https://www.linkedin.com/in/md-kamran-55b98521a/**\\n\\n## INTUITION\\nTo Implement LRU(Least recently used), we need to have a track of the usage of the keys, in the order of there usage, as we have a limited capacity we cant extend our capacity beyond \"capacity\", so we always we will take out those values which has\\'nt been acccess in the recent time.So, we have to think of something that can kind of sort our keys according to usage on the go, the best Data Structure for this purpose is Doubly linked List.\\n                             A Doubly linked list will have a Head node as well as a tail node, and whenever a key is used we will place it just next to the head node,in this fashions, the one\\'s which are closer to head are the most recently used ones, and as we go closer to the tail node, those are the less recently used ones while the node just previous to tail is the \"LEAST RECENTLY USED\". \\nSo whenever we add a key or use a key(get()), we will move it right after the head node, and whenever we call the (put() function), if size if greater we have to delete the LRU node, if key is not present, (if present then too we will delete that node so as to update the value and still move it right after head node), and place new node right after head node.                        \\n\\n\\n**Ask Furthur Doubts in the Comment Section**\\n# Code\\n```\\nclass LRUCache {\\npublic:\\nclass node\\n{\\n  public:\\n  int key;\\n  int val;\\n  node* next;\\n  node* prev;\\n  node(int _key,int _val)\\n  {\\n    key = _key;\\n    val = _val;\\n  }\\n};\\nnode* head = new node(-1,-1);\\nnode* tail = new node(-1,-1);\\n\\nint size;\\nunordered_map<int,node*>mpp;\\n    LRUCache(int capacity) {\\n       size = capacity; \\n       head->next = tail;\\n       tail->prev = head;  \\n    }\\n\\n    void addNode(node* newNode){\\n       \\n       node* temp = head->next;\\n       newNode->next = temp;\\n       newNode->prev = head;\\n       head->next = newNode;\\n       temp->prev = newNode;\\n    }\\n\\n    void deleteNode(node* delNode){\\n         \\n       node* delprev = delNode->prev;\\n       node* delnext = delNode->next;\\n       delprev->next = delnext;\\n       delnext->prev = delprev;\\n    }\\n    \\n    int get(int _key) {\\n        \\n        if(mpp.count(_key))\\n        {\\n          node* nde = mpp[_key];\\n          int curr = nde->val;\\n          mpp.erase(_key);\\n          deleteNode(nde);\\n          addNode(nde);\\n          mpp[_key] = head->next;\\n          return curr;\\n        }\\n        return -1;\\n    }\\n    \\n    void put(int _key, int value) {\\n        \\n        if(mpp.count(_key))\\n        {\\n           node* nde = mpp[_key];\\n           mpp.erase(_key);\\n           deleteNode(nde);\\n        }\\n        if(mpp.size()==size)\\n        {\\n           mpp.erase(tail->prev->key);\\n           deleteNode(tail->prev);\\n        }\\n        addNode(new node(_key,value));\\n        mpp[_key] = head->next;\\n    }\\n};\\n\\n```\\n![b62ab1be-232a-438f-9524-7d8ca4dbd5fe_1675328166.1161866.png](https://assets.leetcode.com/users/images/8d5343b1-0eb4-4111-a914-40ce968fd034_1675389764.2273676.png)",
        "level": "medium",
        "type": [
            "wrong comment mark",
            "undefined methods",
            "undefined keywords from other languages",
            "variable value error"
        ],
        "buggy_code": "\nclass LRUCache {\npublic:\nclass node\n{\n  public:\n  int key;\n  int val;\n  node* next;\n  node* prev;\n  node(int _key,int _val)\n  {\n    key = _key;\n    val = _val;\n  }\n};\nnode* head = new node(-1,-1);\nnode* tail = new node(-1,-1);\n\nint size;\nunordered_map<int,node*>mpp;\n    LRUCache(int capacity) {\n       size = capacity; \n       head->next = tail;\n       tail->prev = head;  \n    }\n\n    void addNode(node* newNode){\n       \n       node* temp = head->next;\n       newNode->next = temp;\n       newNode->prev = head;\n       head->next = newNode;\n       temp->prev = newNode;\n    }\n\n    /*void deleteNode(node* delNode){\n         \n       node* delprev = delNode->prev;\n       node* delnext = delNode->next;\n       delprev->next = delnext;\n       delnext->prev = delprev;\n    }*/\n    \n    int get(int _key) {\n        \n        if(mpp.count(_key))\n        {\n          node* nde = mpp[_key];\n          int curr = nde->val;\n          mpp.erase(_key);\n          deleteNode(nde);\n          addNode(nde);\n          mpp[_key] = head->next;\n          return curr;\n        }\n        return -1;\n    }\n\n}; \n\nr\ntil\n"
    },
    {
        "slug": "bitwise-and-of-numbers-range",
        "description": "Given two integers left and right that represent the range [left, right], return the bitwise AND of all numbers in this range, inclusive.",
        "examples": [
            "Input: left = 5, right = 7\nOutput: 4",
            "Input: left = 0, right = 0\nOutput: 0",
            "Input: left = 1, right = 2147483647\nOutput: 0"
        ],
        "constraints": "0 <= left <= right <= 231 - 1",
        "oracle_code": "class Solution {\npublic:\n    int solve(int left , int right){\n        if(left == 0)return 0;\n        int bit1 = log2(left);\n        int bit2 = log2(right);\n        if(bit1 < bit2)return 0;\n        return (1<<bit1) | solve((left^(1<<bit1)) , (right^(1<<bit1))); \n    }\n    int rangeBitwiseAnd(int left, int right) {\n         return solve(left , right);\n    }\n};",
        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int left , int right){\\n        if(left == 0)return 0;\\n        int bit1 = log2(left);\\n        int bit2 = log2(right);\\n        if(bit1 < bit2)return 0;\\n        return (1<<bit1) | solve((left^(1<<bit1)) , (right^(1<<bit1))); \\n    }\\n    int rangeBitwiseAnd(int left, int right) {\\n         return solve(left , right);\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "statement separation",
            "conditional statement error",
            "colon missing",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    int solve(int left , int right){\n        int bit1 = log2(left);\n        int bit2 = log2(right);\n        if(bit1 < bit2)return 0     return 1;\n        return (1<<bit1) | solve((left^(1<<bit1)) , (right^(1<<bit1))); \n    }\n    int rangeBitwiseAnd(int left, int right) {\n        return solve(left , right);\n    }\n};\n"
    },
    {
        "slug": "rotate-array",
        "description": "Given an integer array nums, rotate the array to the right by k steps, where k is non-negative.",
        "examples": [
            "Input: nums = [1,2,3,4,5,6,7], k = 3\nOutput: [5,6,7,1,2,3,4]\nExplanation:\nrotate 1 steps to the right: [7,1,2,3,4,5,6]\nrotate 2 steps to the right: [6,7,1,2,3,4,5]\nrotate 3 steps to the right: [5,6,7,1,2,3,4]",
            "Input: nums = [-1,-100,3,99], k = 2\nOutput: [3,99,-1,-100]\nExplanation: \nrotate 1 steps to the right: [99,-1,-100,3]\nrotate 2 steps to the right: [3,99,-1,-100]"
        ],
        "constraints": "1 <= nums.length <= 105\n-231 <= nums[i] <= 231 - 1\n0 <= k <= 105",
        "oracle_code": "class Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        int n=nums.size();\n        vector<int> temp(nums.size());\n        for(int i=0;i<n;i++){\n            temp[(i+k)%n]=nums[i];\n        }\n        nums=temp;\n    }\n};",
        "content": "# Approach\\nhere i is of loop which starts form (0,1,2...) k is the value how many times you want to rotate and n is the size of first vector ,and after that new indexes will be generated in our temp vector and we have to put values of nums vector at new indexes . . . \\nlike for first  arr[1,2,3,4,5,6,7]  and k=3     so ,\\ntemp[0 + 3 % 7]=nums[i]\\ntemp[3 % 7]=nums[i]\\ntemp[3] = nums[i]\\n[_ , _ , _ , 1 , _ ,_ , _ ]\\nfor next ,\\ntemp[1 + 3 % 7]=nums[i]\\ntemp[4 % 7]=nums[i]\\ntemp[4] = nums[i]\\n[_ , _ , _ , 1 , 2 ,_ , _ ]   and so on \\ni hope you understand ..\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int> temp(nums.size());\\n        for(int i=0;i<n;i++){\\n            temp[(i+k)%n]=nums[i];\\n        }\\n        nums=temp;\\n    }\\n};\\n```\\n![upvote 1.jpeg](https://assets.leetcode.com/users/images/565d5fa5-1370-44d9-a6b6-0cf06d575aae_1681731352.2608747.jpeg)\\n",
        "level": "medium",
        "type": [
            "statement separation",
            "conditional statement error",
            "colon missing",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    void rotate(vector<int>& nums, int k) \n    int n=nums.size();\n    vector<int> temp(nums.size());\n    for(int i=0;i<n;i++){\n        ;\n        temp[(i+k)%n]=nums[i+1];\n    }\n    nums=temp;\n};\n"
    },
    {
        "slug": "widest-vertical-area-between-two-points-containing-no-points",
        "description": "Given n points on a 2D plane where points[i] = [xi, yi], Return\u00a0the widest vertical area between two points such that no points are inside the area.\nA vertical area is an area of fixed-width extending infinitely along the y-axis (i.e., infinite height). The widest vertical area is the one with the maximum width.\nNote that points on the edge of a vertical area are not considered included in the area.",
        "examples": [
            "\u200b\n\nInput: points = [[8,7],[9,9],[7,4],[9,7]]\nOutput: 1\nExplanation: Both the red and the blue area are optimal.",
            "Input: points = [[3,1],[9,0],[1,0],[1,4],[5,3],[8,8]]\nOutput: 3"
        ],
        "constraints": "n == points.length\n2 <= n <= 105\npoints[i].length == 2\n0 <= xi, yi\u00a0<= 109",
        "oracle_code": "class Solution {\npublic:\n  int maxWidthOfVerticalArea(vector<vector<int>>& points) {\n    set<int> x;\n    int res = 0;\n    for (auto &p : points)\n        x.insert(p[0]);\n    for (auto it = next(begin(x)); it != end(x); ++it)\n        res = max(res, *it - *prev(it));\n    return res;\n}\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  int maxWidthOfVerticalArea(vector<vector<int>>& points) {\\n    set<int> x;\\n    int res = 0;\\n    for (auto &p : points)\\n        x.insert(p[0]);\\n    for (auto it = next(begin(x)); it != end(x); ++it)\\n        res = max(res, *it - *prev(it));\\n    return res;\\n}\\n};\\n```",
        "level": "medium",
        "type": [
            "operation error",
            "wrong comment mark",
            "undefined methods",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n  int maxWidthOfVerticalArea(vector<vector<int>>& points) /*\n    set<int> x;\n    int res = 0;\n    for (auto &p : points)\n        x.insert(p[0]);\n    for (auto it = next(begin(x)); it != end(x); ++it)\n        res = max(res, *it - *prev(it);\n    return ++calculateArea();\n}\nprivate:\n    int calculateArea();\n*/;\n"
    },
    {
        "slug": "binary-string-with-substrings-representing-1-to-n",
        "description": "Given a binary string s and a positive integer n, return true if the binary representation of all the integers in the range [1, n] are substrings of s, or false otherwise.\nA substring is a contiguous sequence of characters within a string.",
        "examples": [
            "Input: s = \"0110\", n = 3\nOutput: true",
            "Input: s = \"0110\", n = 4\nOutput: false"
        ],
        "constraints": "1 <= s.length <= 1000\ns[i] is either '0' or '1'.\n1 <= n <= 109",
        "oracle_code": "class Solution {\npublic:\n    bool queryString(string s, int n)\n     {\n        unordered_set<int> seen;\n        int len = s.length();\n        for(int i=len-1;i>=0;i--)\n        {\n            int num = 0;\n            for(int j=1;j<=min(len-i,31);j++)\n            { \n                num = num*2 + (s[i+j-1] == '1' ? 1 : 0);\n                if(0 < num && num <= n) seen.insert(num);\n            }\n            if(seen.size() == n) return true;\n        }\n        return false;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool queryString(string s, int n)\\n     {\\n        unordered_set<int> seen;\\n        int len = s.length();\\n        for(int i=len-1;i>=0;i--)\\n        {\\n            int num = 0;\\n            for(int j=1;j<=min(len-i,31);j++)\\n            { \\n                num = num*2 + (s[i+j-1] == \\'1\\' ? 1 : 0);\\n                if(0 < num && num <= n) seen.insert(num);\\n            }\\n            if(seen.size() == n) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "== and = confusion",
            "unclosed string",
            "conditional statement error",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    bool queryString(string s, int n)\n     {\n        unordered_set<int> seen;\n        int len = s.length();\n        for(int i=len-1;i>=0;i--)\n        {\n            int num = 0;\n            for(int j=1;j<=min(len-i,31);j++)\n            { \n                num = num*2 + (s[i+j-1] = \"1\" ? 1 : 0);\n                if(0 < num && num <= n) seen.insert(num);\n             }\n            if(seen.size() ! n) return true;\n        }\n        return isAllNumbersSeen();\n    }\n    \n    bool isAllNumbersSeen()\n    {\n        \n    }\n};\n"
    },
    {
        "slug": "binary-string-with-substrings-representing-1-to-n",
        "description": "Given a binary string s and a positive integer n, return true if the binary representation of all the integers in the range [1, n] are substrings of s, or false otherwise.\nA substring is a contiguous sequence of characters within a string.",
        "examples": [
            "Input: s = \"0110\", n = 3\nOutput: true",
            "Input: s = \"0110\", n = 4\nOutput: false"
        ],
        "constraints": "1 <= s.length <= 1000\ns[i] is either '0' or '1'.\n1 <= n <= 109",
        "oracle_code": "class Solution {\npublic:\n    bool queryString(string s, int n)\n     {\n        unordered_set<int> seen;\n        int len = s.length();\n        for(int i=len-1;i>=0;i--)\n        {\n            int num = 0;\n            for(int j=1;j<=min(len-i,31);j++)\n            { \n                num = num*2 + (s[i+j-1] == '1' ? 1 : 0);\n                if(0 < num && num <= n) seen.insert(num);\n            }\n            if(seen.size() == n) return true;\n        }\n        return false;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool queryString(string s, int n)\\n     {\\n        unordered_set<int> seen;\\n        int len = s.length();\\n        for(int i=len-1;i>=0;i--)\\n        {\\n            int num = 0;\\n            for(int j=1;j<=min(len-i,31);j++)\\n            { \\n                num = num*2 + (s[i+j-1] == \\'1\\' ? 1 : 0);\\n                if(0 < num && num <= n) seen.insert(num);\\n            }\\n            if(seen.size() == n) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "== and = confusion",
            "unclosed string",
            "conditional statement error",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    bool queryString(string s, int n)\n     {\n        unordered_set<int> seen;\n        int len = s.length();\n        bool doesNotExist;\n        string temp = s + doesNotExist;\n        for(int i=len-1;i>=0;i--)\n        {\n            int num = 0;\n            for(int j=1;j<=min(len-i,31);j++)\n            { \n                num = num*2 + (temp[i+j-1] = \"1\" ? 1 : 0);\n                if(0 < num && num <= n) seen.insert(num);\n             }\n            if(seen.size() ! n) return true;\n        }\n        return false;\n    }\n};\n"
    },
    {
        "slug": "count-good-numbers",
        "description": "A digit string is good if the digits (0-indexed) at even indices are even and the digits at odd indices are prime (2, 3, 5, or 7).\n\nFor example, \"2582\" is good because the digits (2 and 8) at even positions are even and the digits (5 and 2) at odd positions are prime. However, \"3245\" is not good because 3 is at an even index but is not even.\n\nGiven an integer n, return the total number of good digit strings of length n. Since the answer may be large, return it modulo 109 + 7.\nA digit string is a string consisting of digits 0 through 9 that may contain leading zeros.",
        "examples": [
            "Input: n = 1\nOutput: 5\nExplanation: The good numbers of length 1 are \"0\", \"2\", \"4\", \"6\", \"8\".",
            "Input: n = 4\nOutput: 400",
            "Input: n = 50\nOutput: 564908303"
        ],
        "constraints": "1 <= n <= 1015",
        "oracle_code": "class Solution {\npublic:\n    int mod=1e9+7;\n    int binExpo(long long x,long long n){\n        int ans=1;\n        while(n){\n            if(n&1){\n                ans=(ans*x)%mod;\n            }\n            x=(x*x)%mod;\n            n>>=1;\n        }\n        return ans;\n    }\n    int countGoodNumbers(long long n) {\n        long long even=n/2+n%2,odd=n/2;\n        int even_val=binExpo(5,even);\n        int odd_val=binExpo(4,odd);\n        return (1ll*even_val*odd_val)%mod;\n\n        \n    }\n};",
        "content": "Here we can use the concept of binary exponentiation.\\nAs 2^7==2^(0111) in binary.\\nso 2^7=(2^4)*(2^2)*(2^1).\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int binExpo(long long x,long long n){\\n        int ans=1;\\n        while(n){\\n            if(n&1){\\n                ans=(ans*x)%mod;\\n            }\\n            x=(x*x)%mod;\\n            n>>=1;\\n        }\\n        return ans;\\n    }\\n    int countGoodNumbers(long long n) {\\n        long long even=n/2+n%2,odd=n/2;\\n        int even_val=binExpo(5,even);\\n        int odd_val=binExpo(4,odd);\\n        return (1ll*even_val*odd_val)%mod;\\n\\n        \\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "variable value error",
            "colon missing",
            "parentheses mismatch",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    int mod=1e9+7\n    int binExpo(long long x,long long n){\n        int ans=1;\n        while(n){\n            if(n&1){\n                ans=(ans*x%mod;\n            }\n            x=(x*x)%mod;\n            n=1;\n        }\n        return ans;\n    }\n    int countGoodNumbers(long long n) {\n        long long even=n/2+n%2,odd=n/2;\n        int even_val=binExpo(5,even);\n        int odd_val=undefined_object;\n        return (1ll*even_val*odd_val)%mod;    }\n};\n"
    },
    {
        "slug": "longest-ideal-subsequence",
        "description": "You are given a string s consisting of lowercase letters and an integer k. We call a string t ideal if the following conditions are satisfied:\n\nt is a subsequence of the string s.\nThe absolute difference in the alphabet order of every two adjacent letters in t is less than or equal to k.\n\nReturn the length of the longest ideal string.\nA subsequence is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.\nNote that the alphabet order is not cyclic. For example, the absolute difference in the alphabet order of 'a' and 'z' is 25, not 1.",
        "examples": [
            "Input: s = \"acfgbd\", k = 2\nOutput: 4\nExplanation: The longest ideal string is \"acbd\". The length of this string is 4, so 4 is returned.\nNote that \"acfgbd\" is not ideal because 'c' and 'f' have a difference of 3 in alphabet order.",
            "Input: s = \"abcd\", k = 3\nOutput: 4\nExplanation: The longest ideal string is \"abcd\". The length of this string is 4, so 4 is returned."
        ],
        "constraints": "1 <= s.length <= 105\n0 <= k <= 25\ns consists of lowercase English letters.",
        "oracle_code": "class Solution {\n\n\n   int SolveByMemo(string &s , int &k , int index , int prev , vector<vector<int>> &dp)\n   {\n       if(index == s.length())\n       return 0;\n\n       if(dp[index][prev] != -1)\n       return dp[index][prev];\n\n       int op1 = 0 + SolveByMemo(s, k , index+1 , prev , dp);\n\n       int op2 = 0 ;\n\n       if(prev == 26)\n       op2 = 1 + SolveByMemo(s, k , index+1 , s[index]-'a' , dp);\n       else if(abs(s[index]-'a' - prev) <= k)\n       op2 = 1 + SolveByMemo(s, k , index+1 , s[index]-'a' , dp);\n\n       return dp[index][prev] = max(op1 , op2);\n   }\n\n   int SolveByTab(string &s , int &k )\n   {\n        vector<vector<int>> dp(s.length()+1 , vector<int> (27, 0));\n       \n        for(int index = s.length()-1 ; index>=0 ; index--)\n        {\n            for(int prev = 0 ; prev<= 26 ; prev++)\n            {\n                int op1 = 0 + dp[index+1][prev];\n                int op2 = 0 ;\n\n               if(prev == 26)\n               op2 = 1 + dp[index+1][s[index]-'a'];\n               else if(abs(s[index]-'a' - prev) <= k)\n               op2 = 1 + dp[index+1][s[index]-'a'];\n\n               dp[index][prev] = max(op1 , op2);\n            }\n        }\n\n       return max(dp[0][s[0]-'a'] , dp[0][26]);\n   }\n\n   int SolveByTabSpaceOptimised(string &s , int &k )\n   {\n        vector<int> next(27, 0) ;\n        vector<int> curr(27, 0);\n       \n        for(int index = s.length()-1 ; index>=0 ; index--)\n        {\n            for(int prev = 0 ; prev<= 26 ; prev++)\n            {\n                int op1 = 0 + next[prev];\n                int op2 = 0 ;\n\n               if(prev == 26)\n               op2 = 1 + next[s[index]-'a'];\n               else if(abs(s[index]-'a' - prev) <= k)\n               op2 = 1 + next[s[index]-'a'];\n\n               curr[prev] = max(op1 , op2);\n            }\n            next = curr;\n        }\n\n       return max(curr[s[0]-'a'] , curr[26]);\n   }\n\npublic:\n    int longestIdealString(string s, int k) {\n        \n        // 1. Recursion + Memoization || Top Down Approach\n        // vector<vector<int>> dp(s.length() , vector<int> (27, -1));\n        // return SolveByMemo(s, k , 0 , 26, dp);\n\n        // 2. Tabulation Method || Bottom Up Approach\n        // return SolveByTab(s, k);\n\n        // 3. Space Optimisation using Tabulation\n        return SolveByTabSpaceOptimised(s , k);\n    }\n};",
        "content": "\\n# Approach\\nWe Have Use Three Different Approaches :\\n1. Recursion + Memoization \\n    TC : O(n^2) , SC : O(n)\\n2. Tabulation Method \\n    TC : O(n^2) , SC : O(n)\\n3.  Tabulatuon With SOace Optimised\\n    TC : O(n^2) , SC : O(1) \\n\\n\\n#Note\\nSC In first two methods is On) and not O(n^2) as size is fixed to 27 for each index hence it is Linear Space ,Similarly for 3rd Method we have optimised to constant space as at any instant we onlt need memory of next 27 blocks  only.\\n\\n#Hope You Liekd It and Upvote are appreciated \\n\\n# Code\\n```\\nclass Solution {\\n\\n\\n   int SolveByMemo(string &s , int &k , int index , int prev , vector<vector<int>> &dp)\\n   {\\n       if(index == s.length())\\n       return 0;\\n\\n       if(dp[index][prev] != -1)\\n       return dp[index][prev];\\n\\n       int op1 = 0 + SolveByMemo(s, k , index+1 , prev , dp);\\n\\n       int op2 = 0 ;\\n\\n       if(prev == 26)\\n       op2 = 1 + SolveByMemo(s, k , index+1 , s[index]-\\'a\\' , dp);\\n       else if(abs(s[index]-\\'a\\' - prev) <= k)\\n       op2 = 1 + SolveByMemo(s, k , index+1 , s[index]-\\'a\\' , dp);\\n\\n       return dp[index][prev] = max(op1 , op2);\\n   }\\n\\n   int SolveByTab(string &s , int &k )\\n   {\\n        vector<vector<int>> dp(s.length()+1 , vector<int> (27, 0));\\n       \\n        for(int index = s.length()-1 ; index>=0 ; index--)\\n        {\\n            for(int prev = 0 ; prev<= 26 ; prev++)\\n            {\\n                int op1 = 0 + dp[index+1][prev];\\n                int op2 = 0 ;\\n\\n               if(prev == 26)\\n               op2 = 1 + dp[index+1][s[index]-\\'a\\'];\\n               else if(abs(s[index]-\\'a\\' - prev) <= k)\\n               op2 = 1 + dp[index+1][s[index]-\\'a\\'];\\n\\n               dp[index][prev] = max(op1 , op2);\\n            }\\n        }\\n\\n       return max(dp[0][s[0]-\\'a\\'] , dp[0][26]);\\n   }\\n\\n   int SolveByTabSpaceOptimised(string &s , int &k )\\n   {\\n        vector<int> next(27, 0) ;\\n        vector<int> curr(27, 0);\\n       \\n        for(int index = s.length()-1 ; index>=0 ; index--)\\n        {\\n            for(int prev = 0 ; prev<= 26 ; prev++)\\n            {\\n                int op1 = 0 + next[prev];\\n                int op2 = 0 ;\\n\\n               if(prev == 26)\\n               op2 = 1 + next[s[index]-\\'a\\'];\\n               else if(abs(s[index]-\\'a\\' - prev) <= k)\\n               op2 = 1 + next[s[index]-\\'a\\'];\\n\\n               curr[prev] = max(op1 , op2);\\n            }\\n            next = curr;\\n        }\\n\\n       return max(curr[s[0]-\\'a\\'] , curr[26]);\\n   }\\n\\npublic:\\n    int longestIdealString(string s, int k) {\\n        \\n        // 1. Recursion + Memoization || Top Down Approach\\n        // vector<vector<int>> dp(s.length() , vector<int> (27, -1));\\n        // return SolveByMemo(s, k , 0 , 26, dp);\\n\\n        // 2. Tabulation Method || Bottom Up Approach\\n        // return SolveByTab(s, k);\\n\\n        // 3. Space Optimisation using Tabulation\\n        return SolveByTabSpaceOptimised(s , k);\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "indexing error",
            "wrong comment mark",
            "unclosed string",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution {\n   int SolveByMemo(string &s , int &k , int index , int prev , vector<vector<int>> &dp)\n   {\n       \n       if(dp[index+1][prev] != -1)\n       return dp[index+1][prev];\n\n       \n/**/fun(s, k , index+, s[index]-'a' , dp);\n       else if(abs(s[index]-'a' - prev) <= k)\n       op2 = fun(s, k , index1 , s[index]-'a' , dp);\n\n       return dp[index][prev] = max(op1 , op2);\n   }\n\n   int SolveByTab(string &s , int &k )\n   {\n        vector<vector<int>> dp(s.length()+1 , vector<int> (27, 0));\n       \n        for(int index = s.length()-1 ; index>=0 ; index--)\n        {\n            for(int prev = 0 ; prev<= 26 ; prev++)\n            {\n                int op1 = 0 + dp[index+1][prev];\n                int op2 = 0 ;\n\n               if(prev == 26)\n               op2 = fun(dp[index+1][s[index]-'a']);\n               else if(abs(s[index]-'a' - prev) <= k)\n               op2 = fun(dp[index+1][s[index]-'a']);\n\n               dp[index][prev] = max(op1 , op2);\n            }\n        }\n\n       return max(dp[0][s[0]-'a'] , dp[0][26]);\n   }\n\n   int SolveByTabSpaceOptimised(string &s , int &k )\n   {\n        vector<int> next(27, 0) ;\n        vector<int> curr(27, 0);\n       \n        for(int index = s.length()-1 ; index>=0 ; index--)\n        {\n            for(int prev = 0 ; prev<= 26 ; prev++)\n            {\n                int op1 = 0 + next[prev];\n                int op2 = 0 ;\n\n               if(prev == 26)\n               op2 = 1 + next[s[index]-'a'];\n               else if(abs(s[index]-'a' - prev) <= k)\n               op2 = 1 + next[s[index]-'a'];\n\n               curr[prev] = max(op1 , op2);\n            }\n            next = curr;\n        }\n\n       return max(curr[s[0]-'a'] , curr[26]);\n   }\n\npublic:\n    int longestIdealString(string s, int k) {\n        \n        // 1. Recursion + Memoization || Top Down Approach\n        // vector<vector<int>> dp(s.length() , vector<int> (27, -1));\n        // return026\n // 2. TabutnMthod || ottoUApproach\n   //, k);\n\n        // 3. Space Opimisation usTabut\n"
    },
    {
        "slug": "shortest-path-with-alternating-colors",
        "description": "You are given an integer n, the number of nodes in a directed graph where the nodes are labeled from 0 to n - 1. Each edge is red or blue in this graph, and there could be self-edges and parallel edges.\nYou are given two arrays redEdges and blueEdges where:\n\nredEdges[i] = [ai, bi] indicates that there is a directed red edge from node ai to node bi in the graph, and\nblueEdges[j] = [uj, vj] indicates that there is a directed blue edge from node uj to node vj in the graph.\n\nReturn an array answer of length n, where each answer[x] is the length of the shortest path from node 0 to node x such that the edge colors alternate along the path, or -1 if such a path does not exist.",
        "examples": [
            "Input: n = 3, redEdges = [[0,1],[1,2]], blueEdges = []\nOutput: [0,1,-1]",
            "Input: n = 3, redEdges = [[0,1]], blueEdges = [[2,1]]\nOutput: [0,1,-1]"
        ],
        "constraints": "1 <= n <= 100\n0 <= redEdges.length,\u00a0blueEdges.length <= 400\nredEdges[i].length == blueEdges[j].length == 2\n0 <= ai, bi, uj, vj < n",
        "oracle_code": "class Solution {\npublic:\n    vector<int> shortestAlternatingPaths(int n,vector<vector<int>>&redEdges,vector<vector<int>>& blueEdges) \n    {\n        multiset<int>temp;\n        vector<multiset<int>>redchilds(n,temp),bluechilds(n,temp);\n        for(auto j:redEdges)\n        {\n            redchilds[j[0]].insert(j[1]);\n        }\n        for(auto j:blueEdges)\n        {\n            bluechilds[j[0]].insert(j[1]);\n        }\n        vector<int>ans;\n        for(int i=0;i<n;i++)\n        {\n            //BFS for all\n            vector<multiset<int>>reds=redchilds,blues=bluechilds;\n            queue<pair<char,int>>visit;\n            visit.push({'n',0});//neutral='n'\n            int steps=0;\n            while(!visit.empty())\n            {\n                bool justbreak=false;\n                int n=visit.size();\n                for(int j=0;j<n;j++)\n                {\n                    pair<char,int>x=visit.front();\n                    visit.pop();\n                    if(x.second==i)\n                    {\n                        ans.push_back(steps);\n                        justbreak=true;\n                        break;\n                    }\n                    if(x.first=='n')\n                    {\n                        for(auto j:reds[x.second])\n                        {\n                            visit.push({'r',j});\n                            auto itr1=reds[x.second].find(j);\n                            reds[x.second].erase(itr1);\n                        }\n                        for(auto j:blues[x.second])\n                        {\n                            visit.push({'b',j});//blue='b'\n                            auto itr1=blues[x.second].find(j);\n                            blues[x.second].erase(itr1);\n                        }\n                    }\n                    else if(x.first=='b')\n                    {\n                        for(auto j:reds[x.second])\n                        {\n                            visit.push({'r',j});//red='r'\n                            auto itr1=reds[x.second].find(j);\n                            reds[x.second].erase(itr1);\n                        }\n                    }\n                    else if(x.first=='r')\n                    {\n                        for(auto j:blues[x.second])\n                        {\n                            visit.push({'b',j});\n                            auto itr1=blues[x.second].find(j);\n                            blues[x.second].erase(itr1);\n                        }\n                    }\n                }\n                if(justbreak)\n                {\n                    break;\n                }\n                steps++;\n            }\n            if(i==ans.size())\n            {\n                ans.push_back(-1);\n            }\n        }\n        return ans;\n    }\n};",
        "content": "*E denotes number of Edges*\\n\\n# Complexity\\n- Time complexity:\\nO((N^2)+(N)*(E)*LOG(E))\\n\\n- Space complexity:\\nO(E)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> shortestAlternatingPaths(int n,vector<vector<int>>&redEdges,vector<vector<int>>& blueEdges) \\n    {\\n        multiset<int>temp;\\n        vector<multiset<int>>redchilds(n,temp),bluechilds(n,temp);\\n        for(auto j:redEdges)\\n        {\\n            redchilds[j[0]].insert(j[1]);\\n        }\\n        for(auto j:blueEdges)\\n        {\\n            bluechilds[j[0]].insert(j[1]);\\n        }\\n        vector<int>ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            //BFS for all\\n            vector<multiset<int>>reds=redchilds,blues=bluechilds;\\n            queue<pair<char,int>>visit;\\n            visit.push({\\'n\\',0});//neutral=\\'n\\'\\n            int steps=0;\\n            while(!visit.empty())\\n            {\\n                bool justbreak=false;\\n                int n=visit.size();\\n                for(int j=0;j<n;j++)\\n                {\\n                    pair<char,int>x=visit.front();\\n                    visit.pop();\\n                    if(x.second==i)\\n                    {\\n                        ans.push_back(steps);\\n                        justbreak=true;\\n                        break;\\n                    }\\n                    if(x.first==\\'n\\')\\n                    {\\n                        for(auto j:reds[x.second])\\n                        {\\n                            visit.push({\\'r\\',j});\\n                            auto itr1=reds[x.second].find(j);\\n                            reds[x.second].erase(itr1);\\n                        }\\n                        for(auto j:blues[x.second])\\n                        {\\n                            visit.push({\\'b\\',j});//blue=\\'b\\'\\n                            auto itr1=blues[x.second].find(j);\\n                            blues[x.second].erase(itr1);\\n                        }\\n                    }\\n                    else if(x.first==\\'b\\')\\n                    {\\n                        for(auto j:reds[x.second])\\n                        {\\n                            visit.push({\\'r\\',j});//red=\\'r\\'\\n                            auto itr1=reds[x.second].find(j);\\n                            reds[x.second].erase(itr1);\\n                        }\\n                    }\\n                    else if(x.first==\\'r\\')\\n                    {\\n                        for(auto j:blues[x.second])\\n                        {\\n                            visit.push({\\'b\\',j});\\n                            auto itr1=blues[x.second].find(j);\\n                            blues[x.second].erase(itr1);\\n                        }\\n                    }\\n                }\\n                if(justbreak)\\n                {\\n                    break;\\n                }\\n                steps++;\\n            }\\n            if(i==ans.size())\\n            {\\n                ans.push_back(-1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "== and = confusion",
            "wrong comment mark",
            "unclosed string",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    vector<int> shortestAlternatingPaths(int n,vector<vector<int>>&redEdges,vector<vector<int>>& blueEdges) \n    {\n        multiset<int>temp;\n        vector<multiset<int>>redchilds(n,temp),bluechilds(n,temp);\n        for(auto j:redEdges)\n        {\n            redchilds[j[0]].insert(j[1]);\n        }\n        for(auto j:blueEdges)\n        {\n            bluechilds[j[0]].insert(j[1]);\n        }\n        vector<int>ans;\n        for(int i=0;i<n;i++)\n        {\n            //BFS for all\n            vector<multiset<int>>reds=redchilds,blues=bluechilds;\n            queue<pair<char,int>>visit;\n            visit.push({'n',0});//neutral='n'\n            int steps=0;\n            while(!visit.empty()\n            {\n                bool justbreak=false;\n                int n=visit.size();\n                for(int j=0;j<n;j++)\n                {\n                    pair<char,int>x=visit.front();\n                    \n                    if(x.second=i)\n                    {\n                        ans.push_back(steps);\n                        justbreak=true;\n                        break;\n                    }\n                    if(x.first=='n')\n                    {\n                        for(auto j:reds[x.second])\n                        {\n                            visit.push({'r\",j});\n                            auto itr1=reds[x.second].find(j);\n                            reds[x.second].erase(itr1);\n                        }\n                        for(auto j:blues[x.second])\n                        {\n                            visit.push({'b',j});//blue='b'\n                            auto itr1=blues[x.second].find(j);\n                            blues[x.second].erase(itr1);\n                        }\n                    }\n                    else if(x.first=='b')\n                    {\n                        for(auto j:reds[x.second])\n                        {\n                            visit.push({'r',j});//red='r'\n                            auto itr1=reds[x.second].find(j);\n                            reds[x.second].erase(itr1);\n                        }\n                    }\n                    else if(x.first=='r')\n                    {\n                        for(auto j:blues[x.second])\n                        {\n                            visit.push({'b',j});\n                            auto itr1=blues[x.second].find(j);\n                            blues[x.second].erase(itr1);\n                        }\n                    }\n                }\n                if(justbreak)\n                {\n                    break;\n                }\n                steps++;\n            }\n            if(i==ans.size())\n            {\n                ans.push_back(-1);\n            }\n        }\n        return ans;\n    }\n};\n"
    },
    {
        "slug": "most-frequent-even-element",
        "description": "Given an integer array nums, return the most frequent even element.\nIf there is a tie, return the smallest one. If there is no such element, return -1.",
        "examples": [
            "Input: nums = [0,1,2,2,4,4,1]\nOutput: 2\nExplanation:\nThe even elements are 0, 2, and 4. Of these, 2 and 4 appear the most.\nWe return the smallest one, which is 2.",
            "Input: nums = [4,4,4,9,2,4]\nOutput: 4\nExplanation: 4 is the even element appears the most.",
            "Input: nums = [29,47,21,41,13,37,25,7]\nOutput: -1\nExplanation: There is no even element."
        ],
        "constraints": "1 <= nums.length <= 2000\n0 <= nums[i] <= 105",
        "oracle_code": "class Solution {\npublic:\n    int mostFrequentEven(vector<int>& nums) {\n        int n = nums.size(),i;\n        map<int , int> freq;\n        for(auto x:nums){\n            freq[x]++;\n        }\n        int evefreq=0,ans=-1;\n        for(auto y:freq){\n            if(y.first%2==0 && y.second> evefreq){\n                ans=y.first;\n                evefreq=y.second;\n            }\n        }\n        return ans;\n    }\n};",
        "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mostFrequentEven(vector<int>& nums) {\\n        int n = nums.size(),i;\\n        map<int , int> freq;\\n        for(auto x:nums){\\n            freq[x]++;\\n        }\\n        int evefreq=0,ans=-1;\\n        for(auto y:freq){\\n            if(y.first%2==0 && y.second> evefreq){\\n                ans=y.first;\\n                evefreq=y.second;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "statement separation",
            "colon missing",
            "parentheses mismatch",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    int mostFrequentEven(vector<int>& nums) {\n        int n = nums.size(),i;\n        map<int , int> freq;\n        for(auto x:nums\n            freq[x]++;\n        int evefreq=0,ans;\n        for(auto y:freq)\n            if(y.first%2==0 && y.second> evefreq)\n                ans=y.first;\n                evefreq=y.second;\n        return ans;\n    }\n};\n\n\n\n"
    },
    {
        "slug": "most-frequent-even-element",
        "description": "Given an integer array nums, return the most frequent even element.\nIf there is a tie, return the smallest one. If there is no such element, return -1.",
        "examples": [
            "Input: nums = [0,1,2,2,4,4,1]\nOutput: 2\nExplanation:\nThe even elements are 0, 2, and 4. Of these, 2 and 4 appear the most.\nWe return the smallest one, which is 2.",
            "Input: nums = [4,4,4,9,2,4]\nOutput: 4\nExplanation: 4 is the even element appears the most.",
            "Input: nums = [29,47,21,41,13,37,25,7]\nOutput: -1\nExplanation: There is no even element."
        ],
        "constraints": "1 <= nums.length <= 2000\n0 <= nums[i] <= 105",
        "oracle_code": "class Solution {\npublic:\n    int mostFrequentEven(vector<int>& nums) {\n        int n = nums.size(),i;\n        map<int , int> freq;\n        for(auto x:nums){\n            freq[x]++;\n        }\n        int evefreq=0,ans=-1;\n        for(auto y:freq){\n            if(y.first%2==0 && y.second> evefreq){\n                ans=y.first;\n                evefreq=y.second;\n            }\n        }\n        return ans;\n    }\n};",
        "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mostFrequentEven(vector<int>& nums) {\\n        int n = nums.size(),i;\\n        map<int , int> freq;\\n        for(auto x:nums){\\n            freq[x]++;\\n        }\\n        int evefreq=0,ans=-1;\\n        for(auto y:freq){\\n            if(y.first%2==0 && y.second> evefreq){\\n                ans=y.first;\\n                evefreq=y.second;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "statement separation",
            "conditional statement error",
            "colon missing",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    int mostFrequentEven(vector<int>& nums) {\n        int n = nums.size(),i;\n        map<int , int> freq;\n        for(auto x:nums\n            freq[x]++;\n        int evefreq=0,ans=-1;\n        for(auto y:freq)\n            if(y.second> evefreq){\n                ans=y.first;\n                evefreq=y.second;\n        return ans;\n    }\n};\n\n\n\n"
    },
    {
        "slug": "lru-cache",
        "description": "Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.\nImplement the LRUCache class:\n\nLRUCache(int capacity) Initialize the LRU cache with positive size capacity.\nint get(int key) Return the value of the key if the key exists, otherwise return -1.\nvoid put(int key, int value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key.\n\nThe functions get and put must each run in O(1) average time complexity.",
        "examples": [
            "Input\n[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"]\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\nOutput\n[null, null, null, 1, null, -1, null, -1, 3, 4]\n\nExplanation\nLRUCache lRUCache = new LRUCache(2);\nlRUCache.put(1, 1); // cache is {1=1}\nlRUCache.put(2, 2); // cache is {1=1, 2=2}\nlRUCache.get(1);    // return 1\nlRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}\nlRUCache.get(2);    // returns -1 (not found)\nlRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}\nlRUCache.get(1);    // return -1 (not found)\nlRUCache.get(3);    // return 3\nlRUCache.get(4);    // return 4"
        ],
        "constraints": "1 <= capacity <= 3000\n0 <= key <= 104\n0 <= value <= 105\nAt most 2 * 105 calls will be made to get and put.",
        "oracle_code": "class LRUCache {\npublic:\nclass node\n{\n  public:\n  int key;\n  int val;\n  node* next;\n  node* prev;\n  node(int _key,int _val)\n  {\n    key = _key;\n    val = _val;\n  }\n};\nnode* head = new node(-1,-1);\nnode* tail = new node(-1,-1);\n\nint size;\nunordered_map<int,node*>mpp;\n    LRUCache(int capacity) {\n       size = capacity; \n       head->next = tail;\n       tail->prev = head;  \n    }\n\n    void addNode(node* newNode){\n       \n       node* temp = head->next;\n       newNode->next = temp;\n       newNode->prev = head;\n       head->next = newNode;\n       temp->prev = newNode;\n    }\n\n    void deleteNode(node* delNode){\n         \n       node* delprev = delNode->prev;\n       node* delnext = delNode->next;\n       delprev->next = delnext;\n       delnext->prev = delprev;\n    }\n    \n    int get(int _key) {\n        \n        if(mpp.count(_key))\n        {\n          node* nde = mpp[_key];\n          int curr = nde->val;\n          mpp.erase(_key);\n          deleteNode(nde);\n          addNode(nde);\n          mpp[_key] = head->next;\n          return curr;\n        }\n        return -1;\n    }\n    \n    void put(int _key, int value) {\n        \n        if(mpp.count(_key))\n        {\n           node* nde = mpp[_key];\n           mpp.erase(_key);\n           deleteNode(nde);\n        }\n        if(mpp.size()==size)\n        {\n           mpp.erase(tail->prev->key);\n           deleteNode(tail->prev);\n        }\n        addNode(new node(_key,value));\n        mpp[_key] = head->next;\n    }\n};",
        "content": "# PLEASE DO UPVOTE!!!!!\\n\\n**CONNECT WITH ME ON LINKEDIN :  https://www.linkedin.com/in/md-kamran-55b98521a/**\\n\\n## INTUITION\\nTo Implement LRU(Least recently used), we need to have a track of the usage of the keys, in the order of there usage, as we have a limited capacity we cant extend our capacity beyond \"capacity\", so we always we will take out those values which has\\'nt been acccess in the recent time.So, we have to think of something that can kind of sort our keys according to usage on the go, the best Data Structure for this purpose is Doubly linked List.\\n                             A Doubly linked list will have a Head node as well as a tail node, and whenever a key is used we will place it just next to the head node,in this fashions, the one\\'s which are closer to head are the most recently used ones, and as we go closer to the tail node, those are the less recently used ones while the node just previous to tail is the \"LEAST RECENTLY USED\". \\nSo whenever we add a key or use a key(get()), we will move it right after the head node, and whenever we call the (put() function), if size if greater we have to delete the LRU node, if key is not present, (if present then too we will delete that node so as to update the value and still move it right after head node), and place new node right after head node.                        \\n\\n\\n**Ask Furthur Doubts in the Comment Section**\\n# Code\\n```\\nclass LRUCache {\\npublic:\\nclass node\\n{\\n  public:\\n  int key;\\n  int val;\\n  node* next;\\n  node* prev;\\n  node(int _key,int _val)\\n  {\\n    key = _key;\\n    val = _val;\\n  }\\n};\\nnode* head = new node(-1,-1);\\nnode* tail = new node(-1,-1);\\n\\nint size;\\nunordered_map<int,node*>mpp;\\n    LRUCache(int capacity) {\\n       size = capacity; \\n       head->next = tail;\\n       tail->prev = head;  \\n    }\\n\\n    void addNode(node* newNode){\\n       \\n       node* temp = head->next;\\n       newNode->next = temp;\\n       newNode->prev = head;\\n       head->next = newNode;\\n       temp->prev = newNode;\\n    }\\n\\n    void deleteNode(node* delNode){\\n         \\n       node* delprev = delNode->prev;\\n       node* delnext = delNode->next;\\n       delprev->next = delnext;\\n       delnext->prev = delprev;\\n    }\\n    \\n    int get(int _key) {\\n        \\n        if(mpp.count(_key))\\n        {\\n          node* nde = mpp[_key];\\n          int curr = nde->val;\\n          mpp.erase(_key);\\n          deleteNode(nde);\\n          addNode(nde);\\n          mpp[_key] = head->next;\\n          return curr;\\n        }\\n        return -1;\\n    }\\n    \\n    void put(int _key, int value) {\\n        \\n        if(mpp.count(_key))\\n        {\\n           node* nde = mpp[_key];\\n           mpp.erase(_key);\\n           deleteNode(nde);\\n        }\\n        if(mpp.size()==size)\\n        {\\n           mpp.erase(tail->prev->key);\\n           deleteNode(tail->prev);\\n        }\\n        addNode(new node(_key,value));\\n        mpp[_key] = head->next;\\n    }\\n};\\n\\n```\\n![b62ab1be-232a-438f-9524-7d8ca4dbd5fe_1675328166.1161866.png](https://assets.leetcode.com/users/images/8d5343b1-0eb4-4111-a914-40ce968fd034_1675389764.2273676.png)",
        "level": "medium",
        "type": [
            "wrong comment mark",
            "undefined keywords from other languages",
            "variable value error",
            "undefined objects"
        ],
        "buggy_code": "\nclass LRUCache {\npublic:\nclass node\n{\n  public:\n  int key;\n  int val;\n  node* next;\n  node* prev;\n  node(int _key,int _val)\n  {\n    key = _key;\n    val = _val;\n  }\n};\nnode* head = nullptr;\nnode* tail = nullptr;\n\nint size;\nunordered_map<int,node*>mpp;\n    LRUCache(int capacity) {\n       size = capacity; \n       head->next = tail;\n       tail->prev = head;  \n    }\n\n    void addNode(node* newNode){\n       \n       node* temp = head->next;\n       newNode->next = temp;\n       newNode->prev = head;\n       head->next = newNode;\n       temp->prev = newNode;\n    }\n\n    /*void deleteNode(node* delNode){\n         \n       node* delprev = delNode->prev;\n       node* delnext = delNode->next;\n       delprev->next = delnext;\n       delnext->prev = delprev;\n    }*/\n    \n    int get(int _key) {\n        \n        if(mpp.count(_key))\n        {\n          node* nde = mpp[_key];\n          int curr = nde->val;\n          mpp.erase(_key);\n          deleteNode(nde);\n          addNode(nde);\n          mpp[_key] = head->next;\n          return curr;\n        }\n        return -1;\n    }\n    \n    void put(int _key, int value) {\n        \n        if(mpp.count(_key))\n        {\n           node* nde = mpp[_key];\n           mpp.erase(_key);\n           deleteNode(nde);\n        }\n        if(mpp.size()==size)\n        {\n           mpp.erase(tail->prev->key);\n           deleteNode(tail->prev);\n        }\n        addNode(new node(_key,var));\n        mpp[_key] = tail->next;\n    }\n};\n"
    },
    {
        "slug": "shortest-path-with-alternating-colors",
        "description": "You are given an integer n, the number of nodes in a directed graph where the nodes are labeled from 0 to n - 1. Each edge is red or blue in this graph, and there could be self-edges and parallel edges.\nYou are given two arrays redEdges and blueEdges where:\n\nredEdges[i] = [ai, bi] indicates that there is a directed red edge from node ai to node bi in the graph, and\nblueEdges[j] = [uj, vj] indicates that there is a directed blue edge from node uj to node vj in the graph.\n\nReturn an array answer of length n, where each answer[x] is the length of the shortest path from node 0 to node x such that the edge colors alternate along the path, or -1 if such a path does not exist.",
        "examples": [
            "Input: n = 3, redEdges = [[0,1],[1,2]], blueEdges = []\nOutput: [0,1,-1]",
            "Input: n = 3, redEdges = [[0,1]], blueEdges = [[2,1]]\nOutput: [0,1,-1]"
        ],
        "constraints": "1 <= n <= 100\n0 <= redEdges.length,\u00a0blueEdges.length <= 400\nredEdges[i].length == blueEdges[j].length == 2\n0 <= ai, bi, uj, vj < n",
        "oracle_code": "class Solution {\npublic:\n    vector<int> shortestAlternatingPaths(int n,vector<vector<int>>&redEdges,vector<vector<int>>& blueEdges) \n    {\n        multiset<int>temp;\n        vector<multiset<int>>redchilds(n,temp),bluechilds(n,temp);\n        for(auto j:redEdges)\n        {\n            redchilds[j[0]].insert(j[1]);\n        }\n        for(auto j:blueEdges)\n        {\n            bluechilds[j[0]].insert(j[1]);\n        }\n        vector<int>ans;\n        for(int i=0;i<n;i++)\n        {\n            //BFS for all\n            vector<multiset<int>>reds=redchilds,blues=bluechilds;\n            queue<pair<char,int>>visit;\n            visit.push({'n',0});//neutral='n'\n            int steps=0;\n            while(!visit.empty())\n            {\n                bool justbreak=false;\n                int n=visit.size();\n                for(int j=0;j<n;j++)\n                {\n                    pair<char,int>x=visit.front();\n                    visit.pop();\n                    if(x.second==i)\n                    {\n                        ans.push_back(steps);\n                        justbreak=true;\n                        break;\n                    }\n                    if(x.first=='n')\n                    {\n                        for(auto j:reds[x.second])\n                        {\n                            visit.push({'r',j});\n                            auto itr1=reds[x.second].find(j);\n                            reds[x.second].erase(itr1);\n                        }\n                        for(auto j:blues[x.second])\n                        {\n                            visit.push({'b',j});//blue='b'\n                            auto itr1=blues[x.second].find(j);\n                            blues[x.second].erase(itr1);\n                        }\n                    }\n                    else if(x.first=='b')\n                    {\n                        for(auto j:reds[x.second])\n                        {\n                            visit.push({'r',j});//red='r'\n                            auto itr1=reds[x.second].find(j);\n                            reds[x.second].erase(itr1);\n                        }\n                    }\n                    else if(x.first=='r')\n                    {\n                        for(auto j:blues[x.second])\n                        {\n                            visit.push({'b',j});\n                            auto itr1=blues[x.second].find(j);\n                            blues[x.second].erase(itr1);\n                        }\n                    }\n                }\n                if(justbreak)\n                {\n                    break;\n                }\n                steps++;\n            }\n            if(i==ans.size())\n            {\n                ans.push_back(-1);\n            }\n        }\n        return ans;\n    }\n};",
        "content": "*E denotes number of Edges*\\n\\n# Complexity\\n- Time complexity:\\nO((N^2)+(N)*(E)*LOG(E))\\n\\n- Space complexity:\\nO(E)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> shortestAlternatingPaths(int n,vector<vector<int>>&redEdges,vector<vector<int>>& blueEdges) \\n    {\\n        multiset<int>temp;\\n        vector<multiset<int>>redchilds(n,temp),bluechilds(n,temp);\\n        for(auto j:redEdges)\\n        {\\n            redchilds[j[0]].insert(j[1]);\\n        }\\n        for(auto j:blueEdges)\\n        {\\n            bluechilds[j[0]].insert(j[1]);\\n        }\\n        vector<int>ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            //BFS for all\\n            vector<multiset<int>>reds=redchilds,blues=bluechilds;\\n            queue<pair<char,int>>visit;\\n            visit.push({\\'n\\',0});//neutral=\\'n\\'\\n            int steps=0;\\n            while(!visit.empty())\\n            {\\n                bool justbreak=false;\\n                int n=visit.size();\\n                for(int j=0;j<n;j++)\\n                {\\n                    pair<char,int>x=visit.front();\\n                    visit.pop();\\n                    if(x.second==i)\\n                    {\\n                        ans.push_back(steps);\\n                        justbreak=true;\\n                        break;\\n                    }\\n                    if(x.first==\\'n\\')\\n                    {\\n                        for(auto j:reds[x.second])\\n                        {\\n                            visit.push({\\'r\\',j});\\n                            auto itr1=reds[x.second].find(j);\\n                            reds[x.second].erase(itr1);\\n                        }\\n                        for(auto j:blues[x.second])\\n                        {\\n                            visit.push({\\'b\\',j});//blue=\\'b\\'\\n                            auto itr1=blues[x.second].find(j);\\n                            blues[x.second].erase(itr1);\\n                        }\\n                    }\\n                    else if(x.first==\\'b\\')\\n                    {\\n                        for(auto j:reds[x.second])\\n                        {\\n                            visit.push({\\'r\\',j});//red=\\'r\\'\\n                            auto itr1=reds[x.second].find(j);\\n                            reds[x.second].erase(itr1);\\n                        }\\n                    }\\n                    else if(x.first==\\'r\\')\\n                    {\\n                        for(auto j:blues[x.second])\\n                        {\\n                            visit.push({\\'b\\',j});\\n                            auto itr1=blues[x.second].find(j);\\n                            blues[x.second].erase(itr1);\\n                        }\\n                    }\\n                }\\n                if(justbreak)\\n                {\\n                    break;\\n                }\\n                steps++;\\n            }\\n            if(i==ans.size())\\n            {\\n                ans.push_back(-1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "wrong comment mark",
            "conditional statement error",
            "undefined methods",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    vector<int> shortestAlternatingPaths(int n,vector<vector<int>>&redEdges,vector<vector<int>>& blueEdges) \n    {\n        multiset<int>temp;\n        vector<multiset<int>>redchilds(n,temp),bluechilds(n,temp);\n        for(auto j:redEdges)\n        {\n            redchilds[j[0]].insert(j[1]);\n        }\n        for(auto j:blueEdges)\n        {\n            bluechilds[j[0]].insert(j[1]);\n        }\n        vector<int>ans(n, -1);\n        for(int i=0;i<n;) \n        {\n            //BFS for all\n            vector<multiset<int>>reds=redchilds,blues=bluechilds;\n            queue<pair<char,int>>visit;\n            visit.push({'n',0});//neutral='n'\n            int steps=0;\n            while(!visit.empty()\n            {\n                bool justbreak=false;\n                int n=visit.size();\n                for(int j=0;j<n;j++)\n                {\n                    pair<char,int>x=visit.front();\n                    \n                    if(x.second==i)\n                    {\n                        ans[i]=steps;\n                        justbreak=true;\n                        break;\n                    }\n                    if(x.first=='n' || x.first == ans[i] % 2 + '0') \n                    {\n                        for(auto j:reds[x.second])\n                        {\n                            visit.push({'r',j});\n                            auto itr1=reds[x.second].find(j);\n                            reds[x.second].erase(itr1);\n                        }\n                        for(auto j:blues[x.second])\n                        {\n                            visit.push({'b',j});//blue='b'\n                            auto itr1=blues[x.second].find(j);\n                            unknownFunction(itr1); \n                            blues[x.second].erase(itr1);\n                        }\n                    }\n                    else if(x.first=='b')\n                    {\n                        for(auto j:reds[x.second])\n                        {\n                            visit.push({'r',j});//red='r'\n                            auto itr1=reds[x.second].find(j);\n                            reds[x.second].erase(itr1);\n                        }\n                    }\n                    else if(x.first=='r')\n                    {\n                        for(auto j:blues[x.second])\n                        {\n                            visit.push({'b',j});\n                            auto itr1=blues[x.second].find(j);\n                            blues[x.second].erase(itr1);\n                        }\n                    }\n                }\n                if(justbreak)\n                {\n                    break;\n                }\n                steps++;\n            }\n        }\n        return ans;\n    }\n};\n"
    },
    {
        "slug": "find-the-punishment-number-of-an-integer",
        "description": "Given a positive integer n, return the punishment number of n.\nThe punishment number of n is defined as the sum of the squares of all integers i such that:\n\n1 <= i <= n\nThe decimal representation of i * i can be partitioned into contiguous substrings such that the sum of the integer values of these substrings equals i.",
        "examples": [
            "Input: n = 10\nOutput: 182\nExplanation: There are exactly 3 integers i that satisfy the conditions in the statement:\n- 1 since 1 * 1 = 1\n- 9 since 9 * 9 = 81 and 81 can be partitioned into 8 + 1.\n- 10 since 10 * 10 = 100 and 100 can be partitioned into 10 + 0.\nHence, the punishment number of 10 is 1 + 81 + 100 = 182",
            "Input: n = 37\nOutput: 1478\nExplanation: There are exactly 4 integers i that satisfy the conditions in the statement:\n- 1 since 1 * 1 = 1. \n- 9 since 9 * 9 = 81 and 81 can be partitioned into 8 + 1. \n- 10 since 10 * 10 = 100 and 100 can be partitioned into 10 + 0. \n- 36 since 36 * 36 = 1296 and 1296 can be partitioned into 1 + 29 + 6.\nHence, the punishment number of 37 is 1 + 81 + 100 + 1296 = 1478"
        ],
        "constraints": "1 <= n <= 1000",
        "oracle_code": "class Solution {\npublic:\n    \n    bool valid(int n, string s,int sum){\n        // empty string indicates we have completed one partition\n        if(s==\"\") if(sum==n) return true;\n\n        // We use backtracking to check for all partitions if it is possible to generate required sum \n        // and if we find sum we immediately return true immediately\n        for(int i=1;i<=s.size();i++){\n            int x  = stoi(s.substr(0,i));\n            if(valid(n, s.substr(i), sum+x)) return true;\n        }\n        \n        //If no partition could add up to required sum n\n        return false;\n    }\n    int punishmentNumber(int n) {\n        int ans = 0;\n\n        //generate all possible squares and check them if they satisfy the given statement\n        for(int i=1;i<=n;i++){\n            int sq = i*i;\n            string x = to_string(sq);\n            if(valid(i,x,0)) ans += i*i;\n        }\n        \n        return ans;\n        \n    }\n};",
        "content": "# Intuition\\nThe main idea of this problem is to generate all non empty partitions of a string using Backtracking.\\n\\nFor example let\\'s  say i = 36, it\\'s square = 36*36 = 1296\\nTo check if some partition of 1296 satisfy given statement, we make all partitions e.g\\n[1,2,9,6], [1,29,6], [1,296], [12,9,6] , [12,96], [129,6]\\n\\nAmong these only [1,29,6] satisfies the constraint.\\n\\nWe only need one of these set to satisfy the statement, hence we break immediately if we find any valid set.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n* Generate all possible squares and check if they satisfy the given statement\\n* To check if a square satisfies the given constraint or not generate all possible partitions using backtracking.\\n* If any single partition satisfy the statement then this square will be added to solution\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity :  O(n*(2^6)), here 6 is the maxm square length that is len(1000*1000) = 6\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    bool valid(int n, string s,int sum){\\n        // empty string indicates we have completed one partition\\n        if(s==\"\") if(sum==n) return true;\\n\\n        // We use backtracking to check for all partitions if it is possible to generate required sum \\n        // and if we find sum we immediately return true immediately\\n        for(int i=1;i<=s.size();i++){\\n            int x  = stoi(s.substr(0,i));\\n            if(valid(n, s.substr(i), sum+x)) return true;\\n        }\\n        \\n        //If no partition could add up to required sum n\\n        return false;\\n    }\\n    int punishmentNumber(int n) {\\n        int ans = 0;\\n\\n        //generate all possible squares and check them if they satisfy the given statement\\n        for(int i=1;i<=n;i++){\\n            int sq = i*i;\\n            string x = to_string(sq);\\n            if(valid(i,x,0)) ans += i*i;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "== and = confusion",
            "unclosed string",
            "conditional statement error",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    \n    bool valid(int n, string s,int sum){\n        // empty string indicates we have completed one partition\n        if(s==\"\") if(sum=n) return true; \n\n        // We use backtracking to check for all partitions if it is possible to generate required sum \n        // and if we find sum we immediately return true immediately\n        string unclosedString = \"This is an unclosed string;\n        for(int i=1;i<=s.size();i++){\n            int x  = parseInt(s.substr(0,i));\n            if(valid(n, s.substr(i), sum+x)) return false;\n        }\n        \n        //If no partition could add up to required sum n\n        return false;\n    }\n    int punishmentNumber(int n) {\n        int ans = 0;\n\n        //generate all possible squares and check them if they satisfy the given statement\n        for(int i=1;i<=n;i++){\n            int sq = i*i;\n            string x = to_string(sq);\n            if(valid(i,x,0)) ans += i*i;\n        }\n        \n        return ans;\n        \n    }\n};\n"
    },
    {
        "slug": "longest-ideal-subsequence",
        "description": "You are given a string s consisting of lowercase letters and an integer k. We call a string t ideal if the following conditions are satisfied:\n\nt is a subsequence of the string s.\nThe absolute difference in the alphabet order of every two adjacent letters in t is less than or equal to k.\n\nReturn the length of the longest ideal string.\nA subsequence is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.\nNote that the alphabet order is not cyclic. For example, the absolute difference in the alphabet order of 'a' and 'z' is 25, not 1.",
        "examples": [
            "Input: s = \"acfgbd\", k = 2\nOutput: 4\nExplanation: The longest ideal string is \"acbd\". The length of this string is 4, so 4 is returned.\nNote that \"acfgbd\" is not ideal because 'c' and 'f' have a difference of 3 in alphabet order.",
            "Input: s = \"abcd\", k = 3\nOutput: 4\nExplanation: The longest ideal string is \"abcd\". The length of this string is 4, so 4 is returned."
        ],
        "constraints": "1 <= s.length <= 105\n0 <= k <= 25\ns consists of lowercase English letters.",
        "oracle_code": "class Solution {\n\n\n   int SolveByMemo(string &s , int &k , int index , int prev , vector<vector<int>> &dp)\n   {\n       if(index == s.length())\n       return 0;\n\n       if(dp[index][prev] != -1)\n       return dp[index][prev];\n\n       int op1 = 0 + SolveByMemo(s, k , index+1 , prev , dp);\n\n       int op2 = 0 ;\n\n       if(prev == 26)\n       op2 = 1 + SolveByMemo(s, k , index+1 , s[index]-'a' , dp);\n       else if(abs(s[index]-'a' - prev) <= k)\n       op2 = 1 + SolveByMemo(s, k , index+1 , s[index]-'a' , dp);\n\n       return dp[index][prev] = max(op1 , op2);\n   }\n\n   int SolveByTab(string &s , int &k )\n   {\n        vector<vector<int>> dp(s.length()+1 , vector<int> (27, 0));\n       \n        for(int index = s.length()-1 ; index>=0 ; index--)\n        {\n            for(int prev = 0 ; prev<= 26 ; prev++)\n            {\n                int op1 = 0 + dp[index+1][prev];\n                int op2 = 0 ;\n\n               if(prev == 26)\n               op2 = 1 + dp[index+1][s[index]-'a'];\n               else if(abs(s[index]-'a' - prev) <= k)\n               op2 = 1 + dp[index+1][s[index]-'a'];\n\n               dp[index][prev] = max(op1 , op2);\n            }\n        }\n\n       return max(dp[0][s[0]-'a'] , dp[0][26]);\n   }\n\n   int SolveByTabSpaceOptimised(string &s , int &k )\n   {\n        vector<int> next(27, 0) ;\n        vector<int> curr(27, 0);\n       \n        for(int index = s.length()-1 ; index>=0 ; index--)\n        {\n            for(int prev = 0 ; prev<= 26 ; prev++)\n            {\n                int op1 = 0 + next[prev];\n                int op2 = 0 ;\n\n               if(prev == 26)\n               op2 = 1 + next[s[index]-'a'];\n               else if(abs(s[index]-'a' - prev) <= k)\n               op2 = 1 + next[s[index]-'a'];\n\n               curr[prev] = max(op1 , op2);\n            }\n            next = curr;\n        }\n\n       return max(curr[s[0]-'a'] , curr[26]);\n   }\n\npublic:\n    int longestIdealString(string s, int k) {\n        \n        // 1. Recursion + Memoization || Top Down Approach\n        // vector<vector<int>> dp(s.length() , vector<int> (27, -1));\n        // return SolveByMemo(s, k , 0 , 26, dp);\n\n        // 2. Tabulation Method || Bottom Up Approach\n        // return SolveByTab(s, k);\n\n        // 3. Space Optimisation using Tabulation\n        return SolveByTabSpaceOptimised(s , k);\n    }\n};",
        "content": "\\n# Approach\\nWe Have Use Three Different Approaches :\\n1. Recursion + Memoization \\n    TC : O(n^2) , SC : O(n)\\n2. Tabulation Method \\n    TC : O(n^2) , SC : O(n)\\n3.  Tabulatuon With SOace Optimised\\n    TC : O(n^2) , SC : O(1) \\n\\n\\n#Note\\nSC In first two methods is On) and not O(n^2) as size is fixed to 27 for each index hence it is Linear Space ,Similarly for 3rd Method we have optimised to constant space as at any instant we onlt need memory of next 27 blocks  only.\\n\\n#Hope You Liekd It and Upvote are appreciated \\n\\n# Code\\n```\\nclass Solution {\\n\\n\\n   int SolveByMemo(string &s , int &k , int index , int prev , vector<vector<int>> &dp)\\n   {\\n       if(index == s.length())\\n       return 0;\\n\\n       if(dp[index][prev] != -1)\\n       return dp[index][prev];\\n\\n       int op1 = 0 + SolveByMemo(s, k , index+1 , prev , dp);\\n\\n       int op2 = 0 ;\\n\\n       if(prev == 26)\\n       op2 = 1 + SolveByMemo(s, k , index+1 , s[index]-\\'a\\' , dp);\\n       else if(abs(s[index]-\\'a\\' - prev) <= k)\\n       op2 = 1 + SolveByMemo(s, k , index+1 , s[index]-\\'a\\' , dp);\\n\\n       return dp[index][prev] = max(op1 , op2);\\n   }\\n\\n   int SolveByTab(string &s , int &k )\\n   {\\n        vector<vector<int>> dp(s.length()+1 , vector<int> (27, 0));\\n       \\n        for(int index = s.length()-1 ; index>=0 ; index--)\\n        {\\n            for(int prev = 0 ; prev<= 26 ; prev++)\\n            {\\n                int op1 = 0 + dp[index+1][prev];\\n                int op2 = 0 ;\\n\\n               if(prev == 26)\\n               op2 = 1 + dp[index+1][s[index]-\\'a\\'];\\n               else if(abs(s[index]-\\'a\\' - prev) <= k)\\n               op2 = 1 + dp[index+1][s[index]-\\'a\\'];\\n\\n               dp[index][prev] = max(op1 , op2);\\n            }\\n        }\\n\\n       return max(dp[0][s[0]-\\'a\\'] , dp[0][26]);\\n   }\\n\\n   int SolveByTabSpaceOptimised(string &s , int &k )\\n   {\\n        vector<int> next(27, 0) ;\\n        vector<int> curr(27, 0);\\n       \\n        for(int index = s.length()-1 ; index>=0 ; index--)\\n        {\\n            for(int prev = 0 ; prev<= 26 ; prev++)\\n            {\\n                int op1 = 0 + next[prev];\\n                int op2 = 0 ;\\n\\n               if(prev == 26)\\n               op2 = 1 + next[s[index]-\\'a\\'];\\n               else if(abs(s[index]-\\'a\\' - prev) <= k)\\n               op2 = 1 + next[s[index]-\\'a\\'];\\n\\n               curr[prev] = max(op1 , op2);\\n            }\\n            next = curr;\\n        }\\n\\n       return max(curr[s[0]-\\'a\\'] , curr[26]);\\n   }\\n\\npublic:\\n    int longestIdealString(string s, int k) {\\n        \\n        // 1. Recursion + Memoization || Top Down Approach\\n        // vector<vector<int>> dp(s.length() , vector<int> (27, -1));\\n        // return SolveByMemo(s, k , 0 , 26, dp);\\n\\n        // 2. Tabulation Method || Bottom Up Approach\\n        // return SolveByTab(s, k);\\n\\n        // 3. Space Optimisation using Tabulation\\n        return SolveByTabSpaceOptimised(s , k);\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "indexing error",
            "wrong comment mark",
            "unclosed string",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution {\n   int SolveByMemo(string &s , int &k , int index , int prev , vector<vector<int>> &dp)\n   {\n       \n       if(dp[index+1][prev] != -1)\n       return dp[index+1][prev];\n\n       \n/**/string()\n   }\n\n"
    },
    {
        "slug": "rotate-array",
        "description": "Given an integer array nums, rotate the array to the right by k steps, where k is non-negative.",
        "examples": [
            "Input: nums = [1,2,3,4,5,6,7], k = 3\nOutput: [5,6,7,1,2,3,4]\nExplanation:\nrotate 1 steps to the right: [7,1,2,3,4,5,6]\nrotate 2 steps to the right: [6,7,1,2,3,4,5]\nrotate 3 steps to the right: [5,6,7,1,2,3,4]",
            "Input: nums = [-1,-100,3,99], k = 2\nOutput: [3,99,-1,-100]\nExplanation: \nrotate 1 steps to the right: [99,-1,-100,3]\nrotate 2 steps to the right: [3,99,-1,-100]"
        ],
        "constraints": "1 <= nums.length <= 105\n-231 <= nums[i] <= 231 - 1\n0 <= k <= 105",
        "oracle_code": "class Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        int n=nums.size();\n        vector<int> temp(nums.size());\n        for(int i=0;i<n;i++){\n            temp[(i+k)%n]=nums[i];\n        }\n        nums=temp;\n    }\n};",
        "content": "# Approach\\nhere i is of loop which starts form (0,1,2...) k is the value how many times you want to rotate and n is the size of first vector ,and after that new indexes will be generated in our temp vector and we have to put values of nums vector at new indexes . . . \\nlike for first  arr[1,2,3,4,5,6,7]  and k=3     so ,\\ntemp[0 + 3 % 7]=nums[i]\\ntemp[3 % 7]=nums[i]\\ntemp[3] = nums[i]\\n[_ , _ , _ , 1 , _ ,_ , _ ]\\nfor next ,\\ntemp[1 + 3 % 7]=nums[i]\\ntemp[4 % 7]=nums[i]\\ntemp[4] = nums[i]\\n[_ , _ , _ , 1 , 2 ,_ , _ ]   and so on \\ni hope you understand ..\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int> temp(nums.size());\\n        for(int i=0;i<n;i++){\\n            temp[(i+k)%n]=nums[i];\\n        }\\n        nums=temp;\\n    }\\n};\\n```\\n![upvote 1.jpeg](https://assets.leetcode.com/users/images/565d5fa5-1370-44d9-a6b6-0cf06d575aae_1681731352.2608747.jpeg)\\n",
        "level": "medium",
        "type": [
            "statement separation",
            "indexing error",
            "conditional statement error",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    void rotate(vector<int>& nums, int k) \n    int n=nums.size();\n    vector<int> temp(nums.size());\n    for(int i=0;i<=n;i++){\n        temp[(i+k)%n]=nums[i+1];\n    }\n    nums=temp;\n};\n"
    },
    {
        "slug": "lru-cache",
        "description": "Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.\nImplement the LRUCache class:\n\nLRUCache(int capacity) Initialize the LRU cache with positive size capacity.\nint get(int key) Return the value of the key if the key exists, otherwise return -1.\nvoid put(int key, int value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key.\n\nThe functions get and put must each run in O(1) average time complexity.",
        "examples": [
            "Input\n[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"]\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\nOutput\n[null, null, null, 1, null, -1, null, -1, 3, 4]\n\nExplanation\nLRUCache lRUCache = new LRUCache(2);\nlRUCache.put(1, 1); // cache is {1=1}\nlRUCache.put(2, 2); // cache is {1=1, 2=2}\nlRUCache.get(1);    // return 1\nlRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}\nlRUCache.get(2);    // returns -1 (not found)\nlRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}\nlRUCache.get(1);    // return -1 (not found)\nlRUCache.get(3);    // return 3\nlRUCache.get(4);    // return 4"
        ],
        "constraints": "1 <= capacity <= 3000\n0 <= key <= 104\n0 <= value <= 105\nAt most 2 * 105 calls will be made to get and put.",
        "oracle_code": "class LRUCache {\npublic:\nclass node\n{\n  public:\n  int key;\n  int val;\n  node* next;\n  node* prev;\n  node(int _key,int _val)\n  {\n    key = _key;\n    val = _val;\n  }\n};\nnode* head = new node(-1,-1);\nnode* tail = new node(-1,-1);\n\nint size;\nunordered_map<int,node*>mpp;\n    LRUCache(int capacity) {\n       size = capacity; \n       head->next = tail;\n       tail->prev = head;  \n    }\n\n    void addNode(node* newNode){\n       \n       node* temp = head->next;\n       newNode->next = temp;\n       newNode->prev = head;\n       head->next = newNode;\n       temp->prev = newNode;\n    }\n\n    void deleteNode(node* delNode){\n         \n       node* delprev = delNode->prev;\n       node* delnext = delNode->next;\n       delprev->next = delnext;\n       delnext->prev = delprev;\n    }\n    \n    int get(int _key) {\n        \n        if(mpp.count(_key))\n        {\n          node* nde = mpp[_key];\n          int curr = nde->val;\n          mpp.erase(_key);\n          deleteNode(nde);\n          addNode(nde);\n          mpp[_key] = head->next;\n          return curr;\n        }\n        return -1;\n    }\n    \n    void put(int _key, int value) {\n        \n        if(mpp.count(_key))\n        {\n           node* nde = mpp[_key];\n           mpp.erase(_key);\n           deleteNode(nde);\n        }\n        if(mpp.size()==size)\n        {\n           mpp.erase(tail->prev->key);\n           deleteNode(tail->prev);\n        }\n        addNode(new node(_key,value));\n        mpp[_key] = head->next;\n    }\n};",
        "content": "# PLEASE DO UPVOTE!!!!!\\n\\n**CONNECT WITH ME ON LINKEDIN :  https://www.linkedin.com/in/md-kamran-55b98521a/**\\n\\n## INTUITION\\nTo Implement LRU(Least recently used), we need to have a track of the usage of the keys, in the order of there usage, as we have a limited capacity we cant extend our capacity beyond \"capacity\", so we always we will take out those values which has\\'nt been acccess in the recent time.So, we have to think of something that can kind of sort our keys according to usage on the go, the best Data Structure for this purpose is Doubly linked List.\\n                             A Doubly linked list will have a Head node as well as a tail node, and whenever a key is used we will place it just next to the head node,in this fashions, the one\\'s which are closer to head are the most recently used ones, and as we go closer to the tail node, those are the less recently used ones while the node just previous to tail is the \"LEAST RECENTLY USED\". \\nSo whenever we add a key or use a key(get()), we will move it right after the head node, and whenever we call the (put() function), if size if greater we have to delete the LRU node, if key is not present, (if present then too we will delete that node so as to update the value and still move it right after head node), and place new node right after head node.                        \\n\\n\\n**Ask Furthur Doubts in the Comment Section**\\n# Code\\n```\\nclass LRUCache {\\npublic:\\nclass node\\n{\\n  public:\\n  int key;\\n  int val;\\n  node* next;\\n  node* prev;\\n  node(int _key,int _val)\\n  {\\n    key = _key;\\n    val = _val;\\n  }\\n};\\nnode* head = new node(-1,-1);\\nnode* tail = new node(-1,-1);\\n\\nint size;\\nunordered_map<int,node*>mpp;\\n    LRUCache(int capacity) {\\n       size = capacity; \\n       head->next = tail;\\n       tail->prev = head;  \\n    }\\n\\n    void addNode(node* newNode){\\n       \\n       node* temp = head->next;\\n       newNode->next = temp;\\n       newNode->prev = head;\\n       head->next = newNode;\\n       temp->prev = newNode;\\n    }\\n\\n    void deleteNode(node* delNode){\\n         \\n       node* delprev = delNode->prev;\\n       node* delnext = delNode->next;\\n       delprev->next = delnext;\\n       delnext->prev = delprev;\\n    }\\n    \\n    int get(int _key) {\\n        \\n        if(mpp.count(_key))\\n        {\\n          node* nde = mpp[_key];\\n          int curr = nde->val;\\n          mpp.erase(_key);\\n          deleteNode(nde);\\n          addNode(nde);\\n          mpp[_key] = head->next;\\n          return curr;\\n        }\\n        return -1;\\n    }\\n    \\n    void put(int _key, int value) {\\n        \\n        if(mpp.count(_key))\\n        {\\n           node* nde = mpp[_key];\\n           mpp.erase(_key);\\n           deleteNode(nde);\\n        }\\n        if(mpp.size()==size)\\n        {\\n           mpp.erase(tail->prev->key);\\n           deleteNode(tail->prev);\\n        }\\n        addNode(new node(_key,value));\\n        mpp[_key] = head->next;\\n    }\\n};\\n\\n```\\n![b62ab1be-232a-438f-9524-7d8ca4dbd5fe_1675328166.1161866.png](https://assets.leetcode.com/users/images/8d5343b1-0eb4-4111-a914-40ce968fd034_1675389764.2273676.png)",
        "level": "medium",
        "type": [
            "wrong comment mark",
            "undefined methods",
            "undefined keywords from other languages",
            "colon missing"
        ],
        "buggy_code": "\nclass LRUCache {\npublic:\nclass node\n{\n  public:\n  int key;\n  int val;\n  node* next;\n  node* prev;\n  node(int _key,int _val)\n  {\n    key = _key;\n    val = _val;\n  }\n};\nnode* head = new node(-1,-1);\nnode* tail = new node(-1,-1);\n\nint size;\nunordered_map<int,node*>mpp;\n    LRUCache(int capacity) {\n       size = capacity; \n       head->next = tail;\n       tail->prev = head;  \n    }\n\n    void addNode(node* newNode){\n       \n       node* temp = head->next;\n       newNode->next = temp;\n       newNode->prev = head;\n       head->next = newNode;\n    }\n\n    /*void deleteNode(node* delNode){\n         \n       node* delprev = delNode->prev;\n       node* delnext = delNode->next;\n       delprev->next = delnext;\n       delnext->prev = delprev;\n    }*/\n    \n    int get(int _key) {\n        \n        if(mpp.count(_key))\n        {\n          node* nde = mpp[_key];\n          int curr = nde->val;\n          mpp.erase(_key);\n          deleteNode(nde);\n          addNode(nde)\n          mpp[_key] = head->next;\n          return curr;\n        }\n        return -1;\n    }\n\n}; \n\nr\n\n"
    },
    {
        "slug": "search-in-a-binary-search-tree",
        "description": "You are given the root of a binary search tree (BST) and an integer val.\nFind the node in the BST that the node's value equals val and return the subtree rooted with that node. If such a node does not exist, return null.",
        "examples": [
            "Input: root = [4,2,7,1,3], val = 2\nOutput: [2,1,3]",
            "Input: root = [4,2,7,1,3], val = 5\nOutput: []"
        ],
        "constraints": "The number of nodes in the tree is in the range [1, 5000].\n1 <= Node.val <= 107\nroot is a binary search tree.\n1 <= val <= 107",
        "oracle_code": "class Solution {\npublic:\n    TreeNode* searchBST(TreeNode* root, int val) {\n       if(root==NULL) \n       return NULL;\n       if(root->val==val)\n       {\n           return root;\n       }\n       if(root->val>val){\n          return  searchBST(root->left,val);\n       }\n        return searchBST(root->right,val);\n    }\n};",
        "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n       if(root==NULL) \\n       return NULL;\\n       if(root->val==val)\\n       {\\n           return root;\\n       }\\n       if(root->val>val){\\n          return  searchBST(root->left,val);\\n       }\\n        return searchBST(root->right,val);\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "statement separation",
            "wrong comment mark",
            "conditional statement error",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    /* \n    TreeNode* searchBST(TreeNode* root, int val) {\n       if(root==NULL) \n       return NULL;\n       if(root->val==val);\n       {\n           return root;\n       }\n       if(root->val > val)){\n          return searchBST(root->right,val);\n       }\n        return searchBST(root->left,val);\n    }\n    */\n};\n"
    },
    {
        "slug": "longest-well-performing-interval",
        "description": "We are given hours, a list of the number of hours worked per day for a given employee.\nA day is considered to be a tiring day if and only if the number of hours worked is (strictly) greater than 8.\nA well-performing interval is an interval of days for which the number of tiring days is strictly larger than the number of non-tiring days.\nReturn the length of the longest well-performing interval.",
        "examples": [
            "Input: hours = [9,9,6,0,6,6,9]\nOutput: 3\nExplanation: The longest well-performing interval is [9,9,6].",
            "Input: hours = [6,6,6]\nOutput: 0"
        ],
        "constraints": "1 <= hours.length <= 104\n0 <= hours[i] <= 16",
        "oracle_code": "class Solution {\npublic:\n    int longestWPI(vector<int>& hours) {\n    map<int,int> mp;\n    int k=0,ans=0;\n    for(int i=0;i<hours.size();i++)\n    {\n        if(hours[i]>8)  k++; else   k--;\n        if(k>0)\n        {\n        ans=max(ans,i+1);\n        } else{\n            if(mp.find(k-1)!=mp.end()){\n                ans=max(ans,i-mp[k-1]);\n            }\n             if(mp.find(k)==mp.end()){\n                mp[k]=i;\n            }\n        }\n       \n    }    \n    return ans;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestWPI(vector<int>& hours) {\\n    map<int,int> mp;\\n    int k=0,ans=0;\\n    for(int i=0;i<hours.size();i++)\\n    {\\n        if(hours[i]>8)  k++; else   k--;\\n        if(k>0)\\n        {\\n        ans=max(ans,i+1);\\n        } else{\\n            if(mp.find(k-1)!=mp.end()){\\n                ans=max(ans,i-mp[k-1]);\\n            }\\n             if(mp.find(k)==mp.end()){\\n                mp[k]=i;\\n            }\\n        }\\n       \\n    }    \\n    return ans;\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "other error",
            "statement separation",
            "undefined keywords from other languages",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    int longestWPI(vector<int>& hours) {\n    dict<int,int> mp;\n    int k=0,ans=0;\n    for(int i=0;i<hours.size();i++)\n    {\n        if(hours[i]>8)  k++; else   k--;\n        if(k>0)\n        {\n        ans=max(ans,i+1)\n        } else{\n            if(mp.find(k-1)!=mp.end()){\n                ans=max(ans,i-mp[k]);  \n            }\n            if(mp.find(k)==mp.end()){\n                mp[k+1]=i;\n            }  \n }     \n    }    \n    return ans;\n    }\n};\n"
    },
    {
        "slug": "relative-ranks",
        "description": "You are given an integer array score of size n, where score[i] is the score of the ith athlete in a competition. All the scores are guaranteed to be unique.\nThe athletes are placed based on their scores, where the 1st place athlete has the highest score, the 2nd place athlete has the 2nd highest score, and so on. The placement of each athlete determines their rank:\n\nThe 1st place athlete's rank is \"Gold Medal\".\nThe 2nd place athlete's rank is \"Silver Medal\".\nThe 3rd place athlete's rank is \"Bronze Medal\".\nFor the 4th place to the nth place athlete, their rank is their placement number (i.e., the xth place athlete's rank is \"x\").\n\nReturn an array answer of size n where answer[i] is the rank of the ith athlete.",
        "examples": [
            "Input: score = [5,4,3,2,1]\nOutput: [\"Gold Medal\",\"Silver Medal\",\"Bronze Medal\",\"4\",\"5\"]\nExplanation: The placements are [1st, 2nd, 3rd, 4th, 5th].",
            "Input: score = [10,3,8,9,4]\nOutput: [\"Gold Medal\",\"5\",\"Bronze Medal\",\"Silver Medal\",\"4\"]\nExplanation: The placements are [1st, 5th, 3rd, 2nd, 4th]."
        ],
        "constraints": "n == score.length\n1 <= n <= 104\n0 <= score[i] <= 106\nAll the values in score are unique.",
        "oracle_code": "class Solution {\npublic:\n    vector<string> findRelativeRanks(vector<int>& score) {\n        int n = score.size();\n        \n        vector<pair<int, int>> arr;\n        for (int i=0; i<n; i++) arr.push_back({score[i], i});\n\n        sort(rbegin(arr), rend(arr));\n\n        vector<string> res(n);\n        for (int i=0; i<n; i++) \n            res[arr[i].second] = i==0? \"Gold Medal\": (i==1? \"Silver Medal\": (i==2? \"Bronze Medal\": to_string(i+1)));\n\n        return res;\n    }\n};",
        "content": "**vector solution**\\n```\\nclass Solution {\\npublic:\\n    vector<string> findRelativeRanks(vector<int>& score) {\\n        int n = score.size();\\n        \\n        vector<pair<int, int>> arr;\\n        for (int i=0; i<n; i++) arr.push_back({score[i], i});\\n\\n        sort(rbegin(arr), rend(arr));\\n\\n        vector<string> res(n);\\n        for (int i=0; i<n; i++) \\n            res[arr[i].second] = i==0? \"Gold Medal\": (i==1? \"Silver Medal\": (i==2? \"Bronze Medal\": to_string(i+1)));\\n\\n        return res;\\n    }\\n};\\n```\\n---\\n**priority queue solution**\\n```\\nclass Solution {\\npublic:\\n    vector<string> findRelativeRanks(vector<int>& score) {\\n        int n = score.size();\\n        \\n        priority_queue< pair<int, int>, vector<pair<int,int>> > pq;\\n        for (int i=0; i<n; i++) pq.push({score[i], i});\\n\\n        vector<string> res(n);\\n        while (!pq.empty()) {\\n            auto x = pq.top();\\n            int size = pq.size();\\n            res[x.second] = (size == n? \"Gold Medal\": (size == n-1? \"Silver Medal\": (size == n-2? \"Bronze Medal\": to_string(n-size+1))));\\n            pq.pop();\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "other error",
            "unclosed string",
            "undefined methods",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    vector<string> findRelativeRanks(vector<int>& score) {\n        int n = score.size();\n        \n        vector<pair<int, int>> arr;\n        for (int i=0; i<n; i++) arr.push_back({score[i], i});\n\n        sort(rbegin(arr), rend(arr));\n\n        vector<string> res(n);\n        for (int i=0; i<n; i++) \n            res[arr[i].second] = i==0? \"Gold Medal: (i==1? \"Silver Medal\": (i==2? \"Bronze Medal\": to_s(i+1)));\n\n        res[arr[0].second] = \"LeanBack Medal\";\n        return Report(res);\n    }\n\n    vector<string> Report(vector<string>& res) {\n        vector<string> result;\n        for(int i=0; i<res.size(); i++) \n            result.push_back(\"Rank \" + to_string(i+1) + \": \" + res[i]);\n\n        return result;\n    }\n};\n"
    },
    {
        "slug": "reverse-vowels-of-a-string",
        "description": "Given a string s, reverse only all the vowels in the string and return it.\nThe vowels are 'a', 'e', 'i', 'o', and 'u', and they can appear in both lower and upper cases, more than once.",
        "examples": [
            "Input: s = \"hello\"\nOutput: \"holle\"",
            "Input: s = \"leetcode\"\nOutput: \"leotcede\""
        ],
        "constraints": "1 <= s.length <= 3 * 105\ns consist of printable ASCII characters.",
        "oracle_code": "class Solution {\npublic:\n    string reverseVowels(string s) {\n        \n        vector<char> v;\n        for(int i = 0 ; i < s.length(); i++)\n        {\n            if(s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u'\n              || s[i] == 'A' || s[i] == 'E' || s[i] == 'O' || s[i] == 'I' || s[i] == 'U')\n                v.push_back(s[i]);\n        }\n        reverse(v.begin(), v.end());\n        int rev = 0;\n        for(int i = 0 ; i < s.length(); i++)\n        {\n            if(s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u'\n              || s[i] == 'A' || s[i] == 'E' || s[i] == 'O' || s[i] == 'I' || s[i] == 'U'){\n                s[i] = v[rev];\n                rev++;\n            }\n        }\n        return s;\n    }\n};",
        "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        \\n        vector<char> v;\\n        for(int i = 0 ; i < s.length(); i++)\\n        {\\n            if(s[i] == \\'a\\' || s[i] == \\'e\\' || s[i] == \\'i\\' || s[i] == \\'o\\' || s[i] == \\'u\\'\\n              || s[i] == \\'A\\' || s[i] == \\'E\\' || s[i] == \\'O\\' || s[i] == \\'I\\' || s[i] == \\'U\\')\\n                v.push_back(s[i]);\\n        }\\n        reverse(v.begin(), v.end());\\n        int rev = 0;\\n        for(int i = 0 ; i < s.length(); i++)\\n        {\\n            if(s[i] == \\'a\\' || s[i] == \\'e\\' || s[i] == \\'i\\' || s[i] == \\'o\\' || s[i] == \\'u\\'\\n              || s[i] == \\'A\\' || s[i] == \\'E\\' || s[i] == \\'O\\' || s[i] == \\'I\\' || s[i] == \\'U\\'){\\n                s[i] = v[rev];\\n                rev++;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "== and = confusion",
            "unclosed string",
            "conditional statement error",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    string reverseVowels(string s) {\n        \n        vector<char> v;\n        for(int i = 0 ; i < s.length(); i++)\n        {\n            if(s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u\n              || s[i] == 'A' || s[i] == 'E' || s[i] == 'O' || s[i] == 'I' )\n                v.push_back(s[i]);\n        }\n        reverseString(v);\n        int rev = 0;\n        for(int i = 0 ; i < s.length(); i++)\n        {\n            if(s[i] = 'a' || s[i] = 'e' || s[i] = 'i' || s[i] = 'o' || s[i] = 'u\n              || s[i] = 'A' || s[i] = 'E' || s[i] = 'O' || s[i] = 'I'){\n                s[i] = v[rev];\n                rev++;\n            }\n        }\n        return s;\n    }\n};\n"
    },
    {
        "slug": "binary-string-with-substrings-representing-1-to-n",
        "description": "Given a binary string s and a positive integer n, return true if the binary representation of all the integers in the range [1, n] are substrings of s, or false otherwise.\nA substring is a contiguous sequence of characters within a string.",
        "examples": [
            "Input: s = \"0110\", n = 3\nOutput: true",
            "Input: s = \"0110\", n = 4\nOutput: false"
        ],
        "constraints": "1 <= s.length <= 1000\ns[i] is either '0' or '1'.\n1 <= n <= 109",
        "oracle_code": "class Solution {\npublic:\n    bool queryString(string s, int n)\n     {\n        unordered_set<int> seen;\n        int len = s.length();\n        for(int i=len-1;i>=0;i--)\n        {\n            int num = 0;\n            for(int j=1;j<=min(len-i,31);j++)\n            { \n                num = num*2 + (s[i+j-1] == '1' ? 1 : 0);\n                if(0 < num && num <= n) seen.insert(num);\n            }\n            if(seen.size() == n) return true;\n        }\n        return false;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool queryString(string s, int n)\\n     {\\n        unordered_set<int> seen;\\n        int len = s.length();\\n        for(int i=len-1;i>=0;i--)\\n        {\\n            int num = 0;\\n            for(int j=1;j<=min(len-i,31);j++)\\n            { \\n                num = num*2 + (s[i+j-1] == \\'1\\' ? 1 : 0);\\n                if(0 < num && num <= n) seen.insert(num);\\n            }\\n            if(seen.size() == n) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "== and = confusion",
            "conditional statement error",
            "undefined methods",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    bool queryString(string s, int n)\n     {\n        unordered_set<int> seen;\n        int len = s.length();\n        bool doesNotExist;\n        string temp = s + doesNotExist;\n        for(int i=len-1;i>=0;i--)\n        {\n            int num = 0;\n            for(int j=1;j<=min(len-i,31);j++)\n            { \n                num = num*2 + (temp[i+j-1] = '1' ? 1 : 0);\n                if(0 < num && num <= n) seen.insert(num);\n             }\n            if(seen.size() ! n) return true;\n        }\n        return isAllNumbersSeen();\n    }\n    \n    bool isAllNumbersSeen()\n    {\n        \n    }\n};\n"
    },
    {
        "slug": "most-frequent-even-element",
        "description": "Given an integer array nums, return the most frequent even element.\nIf there is a tie, return the smallest one. If there is no such element, return -1.",
        "examples": [
            "Input: nums = [0,1,2,2,4,4,1]\nOutput: 2\nExplanation:\nThe even elements are 0, 2, and 4. Of these, 2 and 4 appear the most.\nWe return the smallest one, which is 2.",
            "Input: nums = [4,4,4,9,2,4]\nOutput: 4\nExplanation: 4 is the even element appears the most.",
            "Input: nums = [29,47,21,41,13,37,25,7]\nOutput: -1\nExplanation: There is no even element."
        ],
        "constraints": "1 <= nums.length <= 2000\n0 <= nums[i] <= 105",
        "oracle_code": "class Solution {\npublic:\n    int mostFrequentEven(vector<int>& nums) {\n        int n = nums.size(),i;\n        map<int , int> freq;\n        for(auto x:nums){\n            freq[x]++;\n        }\n        int evefreq=0,ans=-1;\n        for(auto y:freq){\n            if(y.first%2==0 && y.second> evefreq){\n                ans=y.first;\n                evefreq=y.second;\n            }\n        }\n        return ans;\n    }\n};",
        "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mostFrequentEven(vector<int>& nums) {\\n        int n = nums.size(),i;\\n        map<int , int> freq;\\n        for(auto x:nums){\\n            freq[x]++;\\n        }\\n        int evefreq=0,ans=-1;\\n        for(auto y:freq){\\n            if(y.first%2==0 && y.second> evefreq){\\n                ans=y.first;\\n                evefreq=y.second;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "statement separation",
            "conditional statement error",
            "parentheses mismatch",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    int mostFrequentEven(vector<int>& nums) {\n        int n = nums.size(),i;\n        map<int , int> freq;\n        for(auto x:nums\n            freq[x]++;\n        int evefreq=0,ans;\n        for(auto y:freq)\n            if(y.second> evefreq){\n                ans=y.first;\n                evefreq=y.second;\n        return ans;\n    }\n};\n\n\n\n"
    },
    {
        "slug": "search-in-a-binary-search-tree",
        "description": "You are given the root of a binary search tree (BST) and an integer val.\nFind the node in the BST that the node's value equals val and return the subtree rooted with that node. If such a node does not exist, return null.",
        "examples": [
            "Input: root = [4,2,7,1,3], val = 2\nOutput: [2,1,3]",
            "Input: root = [4,2,7,1,3], val = 5\nOutput: []"
        ],
        "constraints": "The number of nodes in the tree is in the range [1, 5000].\n1 <= Node.val <= 107\nroot is a binary search tree.\n1 <= val <= 107",
        "oracle_code": "class Solution {\npublic:\n    TreeNode* searchBST(TreeNode* root, int val) {\n       if(root==NULL) \n       return NULL;\n       if(root->val==val)\n       {\n           return root;\n       }\n       if(root->val>val){\n          return  searchBST(root->left,val);\n       }\n        return searchBST(root->right,val);\n    }\n};",
        "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n       if(root==NULL) \\n       return NULL;\\n       if(root->val==val)\\n       {\\n           return root;\\n       }\\n       if(root->val>val){\\n          return  searchBST(root->left,val);\\n       }\\n        return searchBST(root->right,val);\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "statement separation",
            "wrong comment mark",
            "conditional statement error",
            "colon missing"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    /* \n    TreeNode* searchBST(TreeNode* root, int val) {\n       if(root=NULL) \n       return NULL;\n       if(root->val==val);\n       {\n           return root;\n       }\n       if(root->val > val){\n          return searchBST(root->right,val);\n       }\n        return searchBST(root->left,val);\n    }\n    */\n};\n"
    },
    {
        "slug": "longest-ideal-subsequence",
        "description": "You are given a string s consisting of lowercase letters and an integer k. We call a string t ideal if the following conditions are satisfied:\n\nt is a subsequence of the string s.\nThe absolute difference in the alphabet order of every two adjacent letters in t is less than or equal to k.\n\nReturn the length of the longest ideal string.\nA subsequence is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.\nNote that the alphabet order is not cyclic. For example, the absolute difference in the alphabet order of 'a' and 'z' is 25, not 1.",
        "examples": [
            "Input: s = \"acfgbd\", k = 2\nOutput: 4\nExplanation: The longest ideal string is \"acbd\". The length of this string is 4, so 4 is returned.\nNote that \"acfgbd\" is not ideal because 'c' and 'f' have a difference of 3 in alphabet order.",
            "Input: s = \"abcd\", k = 3\nOutput: 4\nExplanation: The longest ideal string is \"abcd\". The length of this string is 4, so 4 is returned."
        ],
        "constraints": "1 <= s.length <= 105\n0 <= k <= 25\ns consists of lowercase English letters.",
        "oracle_code": "class Solution {\n\n\n   int SolveByMemo(string &s , int &k , int index , int prev , vector<vector<int>> &dp)\n   {\n       if(index == s.length())\n       return 0;\n\n       if(dp[index][prev] != -1)\n       return dp[index][prev];\n\n       int op1 = 0 + SolveByMemo(s, k , index+1 , prev , dp);\n\n       int op2 = 0 ;\n\n       if(prev == 26)\n       op2 = 1 + SolveByMemo(s, k , index+1 , s[index]-'a' , dp);\n       else if(abs(s[index]-'a' - prev) <= k)\n       op2 = 1 + SolveByMemo(s, k , index+1 , s[index]-'a' , dp);\n\n       return dp[index][prev] = max(op1 , op2);\n   }\n\n   int SolveByTab(string &s , int &k )\n   {\n        vector<vector<int>> dp(s.length()+1 , vector<int> (27, 0));\n       \n        for(int index = s.length()-1 ; index>=0 ; index--)\n        {\n            for(int prev = 0 ; prev<= 26 ; prev++)\n            {\n                int op1 = 0 + dp[index+1][prev];\n                int op2 = 0 ;\n\n               if(prev == 26)\n               op2 = 1 + dp[index+1][s[index]-'a'];\n               else if(abs(s[index]-'a' - prev) <= k)\n               op2 = 1 + dp[index+1][s[index]-'a'];\n\n               dp[index][prev] = max(op1 , op2);\n            }\n        }\n\n       return max(dp[0][s[0]-'a'] , dp[0][26]);\n   }\n\n   int SolveByTabSpaceOptimised(string &s , int &k )\n   {\n        vector<int> next(27, 0) ;\n        vector<int> curr(27, 0);\n       \n        for(int index = s.length()-1 ; index>=0 ; index--)\n        {\n            for(int prev = 0 ; prev<= 26 ; prev++)\n            {\n                int op1 = 0 + next[prev];\n                int op2 = 0 ;\n\n               if(prev == 26)\n               op2 = 1 + next[s[index]-'a'];\n               else if(abs(s[index]-'a' - prev) <= k)\n               op2 = 1 + next[s[index]-'a'];\n\n               curr[prev] = max(op1 , op2);\n            }\n            next = curr;\n        }\n\n       return max(curr[s[0]-'a'] , curr[26]);\n   }\n\npublic:\n    int longestIdealString(string s, int k) {\n        \n        // 1. Recursion + Memoization || Top Down Approach\n        // vector<vector<int>> dp(s.length() , vector<int> (27, -1));\n        // return SolveByMemo(s, k , 0 , 26, dp);\n\n        // 2. Tabulation Method || Bottom Up Approach\n        // return SolveByTab(s, k);\n\n        // 3. Space Optimisation using Tabulation\n        return SolveByTabSpaceOptimised(s , k);\n    }\n};",
        "content": "\\n# Approach\\nWe Have Use Three Different Approaches :\\n1. Recursion + Memoization \\n    TC : O(n^2) , SC : O(n)\\n2. Tabulation Method \\n    TC : O(n^2) , SC : O(n)\\n3.  Tabulatuon With SOace Optimised\\n    TC : O(n^2) , SC : O(1) \\n\\n\\n#Note\\nSC In first two methods is On) and not O(n^2) as size is fixed to 27 for each index hence it is Linear Space ,Similarly for 3rd Method we have optimised to constant space as at any instant we onlt need memory of next 27 blocks  only.\\n\\n#Hope You Liekd It and Upvote are appreciated \\n\\n# Code\\n```\\nclass Solution {\\n\\n\\n   int SolveByMemo(string &s , int &k , int index , int prev , vector<vector<int>> &dp)\\n   {\\n       if(index == s.length())\\n       return 0;\\n\\n       if(dp[index][prev] != -1)\\n       return dp[index][prev];\\n\\n       int op1 = 0 + SolveByMemo(s, k , index+1 , prev , dp);\\n\\n       int op2 = 0 ;\\n\\n       if(prev == 26)\\n       op2 = 1 + SolveByMemo(s, k , index+1 , s[index]-\\'a\\' , dp);\\n       else if(abs(s[index]-\\'a\\' - prev) <= k)\\n       op2 = 1 + SolveByMemo(s, k , index+1 , s[index]-\\'a\\' , dp);\\n\\n       return dp[index][prev] = max(op1 , op2);\\n   }\\n\\n   int SolveByTab(string &s , int &k )\\n   {\\n        vector<vector<int>> dp(s.length()+1 , vector<int> (27, 0));\\n       \\n        for(int index = s.length()-1 ; index>=0 ; index--)\\n        {\\n            for(int prev = 0 ; prev<= 26 ; prev++)\\n            {\\n                int op1 = 0 + dp[index+1][prev];\\n                int op2 = 0 ;\\n\\n               if(prev == 26)\\n               op2 = 1 + dp[index+1][s[index]-\\'a\\'];\\n               else if(abs(s[index]-\\'a\\' - prev) <= k)\\n               op2 = 1 + dp[index+1][s[index]-\\'a\\'];\\n\\n               dp[index][prev] = max(op1 , op2);\\n            }\\n        }\\n\\n       return max(dp[0][s[0]-\\'a\\'] , dp[0][26]);\\n   }\\n\\n   int SolveByTabSpaceOptimised(string &s , int &k )\\n   {\\n        vector<int> next(27, 0) ;\\n        vector<int> curr(27, 0);\\n       \\n        for(int index = s.length()-1 ; index>=0 ; index--)\\n        {\\n            for(int prev = 0 ; prev<= 26 ; prev++)\\n            {\\n                int op1 = 0 + next[prev];\\n                int op2 = 0 ;\\n\\n               if(prev == 26)\\n               op2 = 1 + next[s[index]-\\'a\\'];\\n               else if(abs(s[index]-\\'a\\' - prev) <= k)\\n               op2 = 1 + next[s[index]-\\'a\\'];\\n\\n               curr[prev] = max(op1 , op2);\\n            }\\n            next = curr;\\n        }\\n\\n       return max(curr[s[0]-\\'a\\'] , curr[26]);\\n   }\\n\\npublic:\\n    int longestIdealString(string s, int k) {\\n        \\n        // 1. Recursion + Memoization || Top Down Approach\\n        // vector<vector<int>> dp(s.length() , vector<int> (27, -1));\\n        // return SolveByMemo(s, k , 0 , 26, dp);\\n\\n        // 2. Tabulation Method || Bottom Up Approach\\n        // return SolveByTab(s, k);\\n\\n        // 3. Space Optimisation using Tabulation\\n        return SolveByTabSpaceOptimised(s , k);\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "indexing error",
            "wrong comment mark",
            "unclosed string",
            "variable value error"
        ],
        "buggy_code": "\nclass Solution {   int SolveByMemo(string &s , int &k , int index , int prev , vector<vector<int>> &dp)\n   {\n       \n       if(dp[index+1][prev] != -1)\n       return dp[index+1][prev];\n\n       \n/**/prv\n   }\n\n   prev];\n               else if(abs(-prv)<= k)\n               op2 = 1 + dp[ndex+1][];\n dp[index][prev] = max(op1 ,);\n        }\n        }\n\n       rtur ma(dp[0][s[0publc:\n    i longestIdealString(string s, int k) {\n        \n        // 1. Recursion + Memoization || Top Down Approach\n        // vector<vector<int>> dp(s.length() , vector<int> (27, -1));\n        // return SolveByMemo(s, k , 0 , 26, dp);\n\n        // 2. Tabulation Method || Bottom Up Approach\n        return\n"
    },
    {
        "slug": "most-beautiful-item-for-each-query",
        "description": "You are given a 2D integer array items where items[i] = [pricei, beautyi] denotes the price and beauty of an item respectively.\nYou are also given a 0-indexed integer array queries. For each queries[j], you want to determine the maximum beauty of an item whose price is less than or equal to queries[j]. If no such item exists, then the answer to this query is 0.\nReturn an array answer of the same length as queries where answer[j] is the answer to the jth query.",
        "examples": [
            "Input: items = [[1,2],[3,2],[2,4],[5,6],[3,5]], queries = [1,2,3,4,5,6]\nOutput: [2,4,5,5,6,6]\nExplanation:\n- For queries[0]=1, [1,2] is the only item which has price <= 1. Hence, the answer for this query is 2.\n- For queries[1]=2, the items which can be considered are [1,2] and [2,4]. \n  The maximum beauty among them is 4.\n- For queries[2]=3 and queries[3]=4, the items which can be considered are [1,2], [3,2], [2,4], and [3,5].\n  The maximum beauty among them is 5.\n- For queries[4]=5 and queries[5]=6, all items can be considered.\n  Hence, the answer for them is the maximum beauty of all items, i.e., 6.",
            "Input: items = [[1,2],[1,2],[1,3],[1,4]], queries = [1]\nOutput: [4]\nExplanation: \nThe price of every item is equal to 1, so we choose the item with the maximum beauty 4. \nNote that multiple items can have the same price and/or beauty.",
            "Input: items = [[10,1000]], queries = [5]\nOutput: [0]\nExplanation:\nNo item has a price less than or equal to 5, so no item can be chosen.\nHence, the answer to the query is 0."
        ],
        "constraints": "1 <= items.length, queries.length <= 105\nitems[i].length == 2\n1 <= pricei, beautyi, queries[j] <= 109",
        "oracle_code": "class Solution {\n    int bs(vector<vector<int>>& items, int t, vector<int> &beauty) {\n        int ans = 0, s = 0, e = items.size() - 1;\n        while(s <= e) {\n            int m = (s + e) / 2;\n            if(items[m][0] <= t) ans = beauty[m], s = m + 1;\n            else e = m - 1;\n        }\n        return ans;\n    }\n\npublic:\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\n        sort(items.begin(), items.end());\n        vector<int> ans, beauty(items.size(), items[0][1]);\n\n        for(int i=1; i<items.size(); i++) beauty[i] = max(beauty[i - 1], items[i][1]);\n\n        for(int i : queries) ans.push_back(bs(items, i, beauty));\n        return ans;\n    }\n};",
        "content": "\\n# C++\\n```\\nclass Solution {\\n    int bs(vector<vector<int>>& items, int t, vector<int> &beauty) {\\n        int ans = 0, s = 0, e = items.size() - 1;\\n        while(s <= e) {\\n            int m = (s + e) / 2;\\n            if(items[m][0] <= t) ans = beauty[m], s = m + 1;\\n            else e = m - 1;\\n        }\\n        return ans;\\n    }\\n\\npublic:\\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\\n        sort(items.begin(), items.end());\\n        vector<int> ans, beauty(items.size(), items[0][1]);\\n\\n        for(int i=1; i<items.size(); i++) beauty[i] = max(beauty[i - 1], items[i][1]);\\n\\n        for(int i : queries) ans.push_back(bs(items, i, beauty));\\n        return ans;\\n    }\\n};\\n```\\n\\n# Python\\n```\\nclass Solution(object):\\n    def maximumBeauty(self, items, queries):\\n        items.sort()\\n        ans, beauty = [], [items[0][1]] * len(items)\\n        for i in range(1, len(items)): beauty[i] = max(beauty[i - 1], items[i][1])\\n\\n        def bs(t):\\n            ans, s, e = 0, 0, len(items) - 1\\n            while s <= e:\\n                m = (s + e) // 2\\n                if items[m][0] <= t:\\n                    ans = beauty[m]\\n                    s = m + 1\\n                else: e = m - 1\\n            return ans\\n\\n        for i in queries: ans.append(bs(i))\\n        return ans\\n```\\n",
        "level": "medium",
        "type": [
            "indexing error",
            "conditional statement error",
            "undefined methods",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution {\n    int bs(vector<vector<Integer>>& items, int t, vector<int> &beauty) {\n        int ans = 0, s = 0, e = items.size();\n        while(s <= e) {\n            int m = (s + e) / 2;\n            if(items[m][0] <= t) ans = beauty[m], s = m + 1;\n            else s = m + 1; \n        }\n        return ans;\n    }\n\npublic:\n    vector<int> maximumBeauty(vector<vector<Integer>>& items, vector<int>& queries) {\n        sort(items.begin(), items.end());\n        vector<int> ans, beauty(items.size(), items[0][1]);\n\n        for(int i=1; i<items.size(); i++) beauty[i] = max(beauty[i - 1], items[i][1]);\n\n        for(int i : queries) ans.push_back(bs(items, i, beauty));\n        return ans;\n    }\n    \n    void foo(){\n        bar();\n    }\n};\n"
    },
    {
        "slug": "find-the-punishment-number-of-an-integer",
        "description": "Given a positive integer n, return the punishment number of n.\nThe punishment number of n is defined as the sum of the squares of all integers i such that:\n\n1 <= i <= n\nThe decimal representation of i * i can be partitioned into contiguous substrings such that the sum of the integer values of these substrings equals i.",
        "examples": [
            "Input: n = 10\nOutput: 182\nExplanation: There are exactly 3 integers i that satisfy the conditions in the statement:\n- 1 since 1 * 1 = 1\n- 9 since 9 * 9 = 81 and 81 can be partitioned into 8 + 1.\n- 10 since 10 * 10 = 100 and 100 can be partitioned into 10 + 0.\nHence, the punishment number of 10 is 1 + 81 + 100 = 182",
            "Input: n = 37\nOutput: 1478\nExplanation: There are exactly 4 integers i that satisfy the conditions in the statement:\n- 1 since 1 * 1 = 1. \n- 9 since 9 * 9 = 81 and 81 can be partitioned into 8 + 1. \n- 10 since 10 * 10 = 100 and 100 can be partitioned into 10 + 0. \n- 36 since 36 * 36 = 1296 and 1296 can be partitioned into 1 + 29 + 6.\nHence, the punishment number of 37 is 1 + 81 + 100 + 1296 = 1478"
        ],
        "constraints": "1 <= n <= 1000",
        "oracle_code": "class Solution {\npublic:\n    \n    bool valid(int n, string s,int sum){\n        // empty string indicates we have completed one partition\n        if(s==\"\") if(sum==n) return true;\n\n        // We use backtracking to check for all partitions if it is possible to generate required sum \n        // and if we find sum we immediately return true immediately\n        for(int i=1;i<=s.size();i++){\n            int x  = stoi(s.substr(0,i));\n            if(valid(n, s.substr(i), sum+x)) return true;\n        }\n        \n        //If no partition could add up to required sum n\n        return false;\n    }\n    int punishmentNumber(int n) {\n        int ans = 0;\n\n        //generate all possible squares and check them if they satisfy the given statement\n        for(int i=1;i<=n;i++){\n            int sq = i*i;\n            string x = to_string(sq);\n            if(valid(i,x,0)) ans += i*i;\n        }\n        \n        return ans;\n        \n    }\n};",
        "content": "# Intuition\\nThe main idea of this problem is to generate all non empty partitions of a string using Backtracking.\\n\\nFor example let\\'s  say i = 36, it\\'s square = 36*36 = 1296\\nTo check if some partition of 1296 satisfy given statement, we make all partitions e.g\\n[1,2,9,6], [1,29,6], [1,296], [12,9,6] , [12,96], [129,6]\\n\\nAmong these only [1,29,6] satisfies the constraint.\\n\\nWe only need one of these set to satisfy the statement, hence we break immediately if we find any valid set.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n* Generate all possible squares and check if they satisfy the given statement\\n* To check if a square satisfies the given constraint or not generate all possible partitions using backtracking.\\n* If any single partition satisfy the statement then this square will be added to solution\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity :  O(n*(2^6)), here 6 is the maxm square length that is len(1000*1000) = 6\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    bool valid(int n, string s,int sum){\\n        // empty string indicates we have completed one partition\\n        if(s==\"\") if(sum==n) return true;\\n\\n        // We use backtracking to check for all partitions if it is possible to generate required sum \\n        // and if we find sum we immediately return true immediately\\n        for(int i=1;i<=s.size();i++){\\n            int x  = stoi(s.substr(0,i));\\n            if(valid(n, s.substr(i), sum+x)) return true;\\n        }\\n        \\n        //If no partition could add up to required sum n\\n        return false;\\n    }\\n    int punishmentNumber(int n) {\\n        int ans = 0;\\n\\n        //generate all possible squares and check them if they satisfy the given statement\\n        for(int i=1;i<=n;i++){\\n            int sq = i*i;\\n            string x = to_string(sq);\\n            if(valid(i,x,0)) ans += i*i;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "== and = confusion",
            "unclosed string",
            "conditional statement error",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    \n    bool valid(int n, string s,int sum){\n        // empty string indicates we have completed one partition\n        if(s==\"\") if(sum=n) return true; \n\n        // We use backtracking to check for all partitions if it is possible to generate required sum \n        // and if we find sum we immediately return true immediately\n        string unclosedString = \"This is an unclosed string;\n        for(int i=1;i<=s.size();i++){\n            int x  = stoi(s.substr(0,i));\n            if(valid(n, s.substr(i), sum+x)) return false;\n        }\n        \n        //If no partition could add up to required sum n\n        return false;\n    }\n    int punishmentNumber(int n) {\n        int ans = 0;\n\n        //generate all possible squares and check them if they satisfy the given statement\n        for(int i=1;i<=n;i++){\n            int sq = i*i;\n            string x = to_string(sq);\n            if(valid(i,x,0)) ans += i*i;\n        }\n        \n        \n        return checkAdditionalCondition(ans);\n    }\n};\n"
    },
    {
        "slug": "perfect-squares",
        "description": "Given an integer n, return the least number of perfect square numbers that sum to n.\nA perfect square is an integer that is the square of an integer; in other words, it is the product of some integer with itself. For example, 1, 4, 9, and 16 are perfect squares while 3 and 11 are not.",
        "examples": [
            "Input: n = 12\nOutput: 3\nExplanation: 12 = 4 + 4 + 4.",
            "Input: n = 13\nOutput: 2\nExplanation: 13 = 4 + 9."
        ],
        "constraints": "1 <= n <= 104",
        "oracle_code": "class Solution {\npublic:\n\n    // declare a dp\n\n    int dp[105][10005];\n\n    int helper(vector<int>& arr, int i, int n, int sum)\n    {\n        // base case\n\n        if(sum == 0)\n        {\n            return 0;\n        }\n\n        if(i >= n || sum < 0)\n        {\n            return INT_MAX - 1000;\n        }\n\n        // if already calculated\n\n        if(dp[i][sum] != -1)\n        {\n            return dp[i][sum];\n        }\n\n        // at each ith element we have two options either include or exclude\n\n        int mini = INT_MAX;\n\n        // inclusion part\n\n        if(arr[i] <= sum)\n        {\n            mini = min(mini, 1 + helper(arr, i, n, sum - arr[i]));\n        }\n\n        // exclusion part\n\n        mini = min(mini, helper(arr, i + 1, n, sum));\n\n        // store the res in dp\n\n        return dp[i][sum] = mini;\n    }\n\n    int numSquares(int n) {\n\n        vector<int> arr;\n\n        // find all the squares between 1 to n\n\n        for(int i = 1; i * i <= n; i++)\n        {\n            arr.push_back(i * i);\n        }\n\n        // initialize dp with -1\n\n        memset(dp, -1, sizeof(dp));\n\n        return helper(arr, 0, arr.size(), n);\n    }\n};",
        "content": "* ***Using Recursion && Memoization***\\n\\n* ***Time Complexity :- O(N * sqrt(N))***\\n\\n* ***Space Complexity :- O(N * sqrt(N))***\\n\\n* ***There are sqrt(N), squares between 1 to N***\\n\\n```\\nclass Solution {\\npublic:\\n\\n    // declare a dp\\n\\n    int dp[105][10005];\\n\\n    int helper(vector<int>& arr, int i, int n, int sum)\\n    {\\n        // base case\\n\\n        if(sum == 0)\\n        {\\n            return 0;\\n        }\\n\\n        if(i >= n || sum < 0)\\n        {\\n            return INT_MAX - 1000;\\n        }\\n\\n        // if already calculated\\n\\n        if(dp[i][sum] != -1)\\n        {\\n            return dp[i][sum];\\n        }\\n\\n        // at each ith element we have two options either include or exclude\\n\\n        int mini = INT_MAX;\\n\\n        // inclusion part\\n\\n        if(arr[i] <= sum)\\n        {\\n            mini = min(mini, 1 + helper(arr, i, n, sum - arr[i]));\\n        }\\n\\n        // exclusion part\\n\\n        mini = min(mini, helper(arr, i + 1, n, sum));\\n\\n        // store the res in dp\\n\\n        return dp[i][sum] = mini;\\n    }\\n\\n    int numSquares(int n) {\\n\\n        vector<int> arr;\\n\\n        // find all the squares between 1 to n\\n\\n        for(int i = 1; i * i <= n; i++)\\n        {\\n            arr.push_back(i * i);\\n        }\\n\\n        // initialize dp with -1\\n\\n        memset(dp, -1, sizeof(dp));\\n\\n        return helper(arr, 0, arr.size(), n);\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "== and = confusion",
            "indexing error",
            "undefined methods",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n\n    // declare a dp\n\n    int dp[105][10005];\n\n    int helper(vector<int>& arr, int i, int n, int sum)\n    {\n        // base case\n\n        if(sum == 0)\n        {\n            return 0;\n        }\n\n        if(i > n || sum < 0)\n        {\n            return INT_MAX - 1000;\n        }\n\n        // if already calculated\n\n        if(dp[i][sum] != -1)\n        {\n            return dp[i][sum];\n        }\n\n        // at each ith element we have two options either include or exclude\n\n        int mini = INT_MAX;\n\n        // inclusion part\n\n        if(arr[i] == sum)\n        {\n            mini = min(mini, 1 + helper(arr, i, n, sum - arr[i]));\n        }\n\n        // exclusion part\n\n        mini = min(mini, helper(arr, i + 1, n, sum));\n\n        // store the res in dp\n\n        return dp[i][sum] = mini;\n    }\n\n    int numSquares(int n) {\n\n        vector<int> arr;\n\n        // find all the squares between 1 to n\n\n        for(int i = 1; i * i <= n; i++)\n        {\n            arr.push_back(i * i);\n        }\n\n        // initialize dp with -1\n\n        this->initializeDP();\n\n        \n        print(helper(arr, 0, arr.size(), n));\n    }\n\n};\n"
    },
    {
        "slug": "shortest-path-to-get-all-keys",
        "description": "You are given an m x n grid grid where:\n\n'.' is an empty cell.\n'#' is a wall.\n'@' is the starting point.\nLowercase letters represent keys.\nUppercase letters represent locks.\n\nYou start at the starting point and one move consists of walking one space in one of the four cardinal directions. You cannot walk outside the grid, or walk into a wall.\nIf you walk over a key, you can pick it up and you cannot walk over a lock unless you have its corresponding key.\nFor some 1 <= k <= 6, there is exactly one lowercase and one uppercase letter of the first k letters of the English alphabet in the grid. This means that there is exactly one key for each lock, and one lock for each key; and also that the letters used to represent the keys and locks were chosen in the same order as the English alphabet.\nReturn the lowest number of moves to acquire all keys. If it is impossible, return -1.",
        "examples": [
            "Input: grid = [\"@.a..\",\"###.#\",\"b.A.B\"]\nOutput: 8\nExplanation: Note that the goal is to obtain all the keys not to open all the locks.",
            "Input: grid = [\"@..aA\",\"..B#.\",\"....b\"]\nOutput: 6",
            "Input: grid = [\"@Aa\"]\nOutput: -1"
        ],
        "constraints": "m == grid.length\nn == grid[i].length\n1 <= m, n <= 30\ngrid[i][j] is either an English letter, '.', '#', or '@'.\u00a0\nThere is exactly one\u00a0'@'\u00a0in the grid.\nThe number of keys in the grid is in the range [1, 6].\nEach key in the grid is unique.\nEach key in the grid has a matching lock.",
        "oracle_code": "class Solution {\npublic:\n\n    int dir[4][2] = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};\n\n    int shortestPathAllKeys(vector<string>& grid) {\n        \n        int m = grid.size();\n        int n = grid[0].size();\n        queue<pair<pair<int, int>, int>> que;\n        vector<vector<unsigned long>> mapKey(m, vector<unsigned long>(n, 0));\n        int target = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if ('a' <= grid[i][j] && grid[i][j] <= 'f') {\n                    target |= 1 << (grid[i][j] - 'a');\n                    continue;\n                }\n\n                if (grid[i][j] == '@') {\n                    que.emplace(pair<int, int>(i, j), 0);\n                    mapKey[i][j] = 1;\n                }\n            }\n        }\n\n\n        int step = 0;\n        while (!que.empty()) {\n            int size = que.size();\n            for (int s = 0; s < size; s++) {\n                int i = que.front().first.first;\n                int j = que.front().first.second;\n                int key = que.front().second;\n                que.pop();\n                \n                if ('a' <= grid[i][j] && grid[i][j] <= 'f') {\n                    key |= 1 << (grid[i][j] - 'a');\n                    if (key == target)\n                        return step;\n\n                    mapKey[i][j] |= 1l << key;\n                }\n\n                for (int d = 0; d < 4; d++) {\n                    int newi = i + dir[d][0];\n                    int newj = j + dir[d][1];\n                    \n                    if (!(0 <= newi && newi < m && 0 <= newj && newj < n))\n                        continue;\n                        \n                    int val = grid[newi][newj];\n                    if (val == '#')\n                        continue;\n                        \n                    if ('A' <= val && val <= 'F' && (key & (1 << (val - 'A'))) == 0)\n                        continue;\n                        \n                    if (mapKey[newi][newj] & (1l << key))\n                        continue;\n                        \n                     mapKey[newi][newj] |= 1l << key;\n                     que.emplace(pair<int, int>(newi, newj), key);\n                }\n            }\n            step++;\n        }\n        return -1;\n    }\n};",
        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int dir[4][2] = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};\\n\\n    int shortestPathAllKeys(vector<string>& grid) {\\n        \\n        int m = grid.size();\\n        int n = grid[0].size();\\n        queue<pair<pair<int, int>, int>> que;\\n        vector<vector<unsigned long>> mapKey(m, vector<unsigned long>(n, 0));\\n        int target = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (\\'a\\' <= grid[i][j] && grid[i][j] <= \\'f\\') {\\n                    target |= 1 << (grid[i][j] - \\'a\\');\\n                    continue;\\n                }\\n\\n                if (grid[i][j] == \\'@\\') {\\n                    que.emplace(pair<int, int>(i, j), 0);\\n                    mapKey[i][j] = 1;\\n                }\\n            }\\n        }\\n\\n\\n        int step = 0;\\n        while (!que.empty()) {\\n            int size = que.size();\\n            for (int s = 0; s < size; s++) {\\n                int i = que.front().first.first;\\n                int j = que.front().first.second;\\n                int key = que.front().second;\\n                que.pop();\\n                \\n                if (\\'a\\' <= grid[i][j] && grid[i][j] <= \\'f\\') {\\n                    key |= 1 << (grid[i][j] - \\'a\\');\\n                    if (key == target)\\n                        return step;\\n\\n                    mapKey[i][j] |= 1l << key;\\n                }\\n\\n                for (int d = 0; d < 4; d++) {\\n                    int newi = i + dir[d][0];\\n                    int newj = j + dir[d][1];\\n                    \\n                    if (!(0 <= newi && newi < m && 0 <= newj && newj < n))\\n                        continue;\\n                        \\n                    int val = grid[newi][newj];\\n                    if (val == \\'#\\')\\n                        continue;\\n                        \\n                    if (\\'A\\' <= val && val <= \\'F\\' && (key & (1 << (val - \\'A\\'))) == 0)\\n                        continue;\\n                        \\n                    if (mapKey[newi][newj] & (1l << key))\\n                        continue;\\n                        \\n                     mapKey[newi][newj] |= 1l << key;\\n                     que.emplace(pair<int, int>(newi, newj), key);\\n                }\\n            }\\n            step++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
        "level": "hard",
        "type": [
            "statement separation",
            "operation error",
            "wrong comment mark",
            "colon missing"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n\n    int dir[4][2] = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};\n\n    int shortestPathAllKeys(vector<string>& grid) {\n        \n        int m = grid.size();\n        int n = grid[0].size();\n        queue<pair<pair<int, int>, int>> que;\n        vector<vector<unsigned long>> mapKey(m, vector<unsigned long>(n, 0));\n        int target = 0;\n        for (int i = 0; i < m; i++) \n            for (int j = 0; j < n; j++) \n                if ('a' <= grid[i][j] && grid[i][j] <= 'f') {\n                    target |= 1  (grid[i][j] - 'a');\n                    continue;\n\n                if (grid[i][j] == '@') {\n                    que.emplace(pair<int, int>(i, j), 0);\n                    mapKey[i][j] = 1;\n                }\n            \n\n\n        int step = 0;\n        while (!que.empty()) {\n            int size = que.size();\n            for (int s = 0; s < size; s++) {\n                int i = que.front().first.first;\n                int j = que.front().first.second;\n                int key = que.front().second;\n                que.pop();\n                \n                if ('a' <= grid[i][j] && grid[i][j] <= 'f') {\n                    key |= 1  (grid[i][j] - 'a');\n                    if (key == target)\n                        return step;\n\n                    mapKey[i][j] |= 1l << key;\n                }\n\n                for (int d = 0; d < 4; d++) {\n                   \n                    int newj = j + dir[d][1];\n                    \n                    if (!(0 <= newi && newi < m && 0 <= newj && newj < n))\n                        continue;\n                        \n                    int val = grid[newi][newj];\n                    if (val == '#')\n                        continue;\n                        \n                    if ('A' <= val && val <= 'F' && (key & (1  (val - 'A'))) == 0)\n                        continue;\n                        \n                    if (mapKey[newi][newj] & (1l << key))\n                        continue;\n                        \n                     mapKey[newi][newj] |= 1l << (key+1);  \n                     que.emplace(pair<int, int>(newi, newj), key);\n                }\n            }\n            step++;\n        }\n        return -1;\n    }\n};\n"
    },
    {
        "slug": "check-knight-tour-configuration",
        "description": "There is a knight on an n x n chessboard. In a valid configuration, the knight starts at the top-left cell of the board and visits every cell on the board exactly once.\nYou are given an n x n integer matrix grid consisting of distinct integers from the range [0, n * n - 1] where grid[row][col] indicates that the cell (row, col) is the grid[row][col]th cell that the knight visited. The moves are 0-indexed.\nReturn true if grid represents a valid configuration of the knight's movements or false otherwise.\nNote that a valid knight move consists of moving two squares vertically and one square horizontally, or two squares horizontally and one square vertically. The figure below illustrates all the possible eight moves of a knight from some cell.",
        "examples": [
            "Input: grid = [[0,11,16,5,20],[17,4,19,10,15],[12,1,8,21,6],[3,18,23,14,9],[24,13,2,7,22]]\nOutput: true\nExplanation: The above diagram represents the grid. It can be shown that it is a valid configuration.",
            "Input: grid = [[0,3,6],[5,8,1],[2,7,4]]\nOutput: false\nExplanation: The above diagram represents the grid. The 8th move of the knight is not valid considering its position after the 7th move."
        ],
        "constraints": "n == grid.length == grid[i].length\n3 <= n <= 7\n0 <= grid[row][col] < n * n\nAll integers in grid are unique.",
        "oracle_code": "class Solution {\nprivate:\n    bool helper(vector<vector<int>>& grid, int row, int col, int num){\n        int n = grid.size();\n        if(num == n*n) return true;\n        int i = row-2;\n        int j = col+1;\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row-2;\n        j = col-1;\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 2;\n        j = col - 1;\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 2;\n        j = col + 1;\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 1;\n        j = col + 2;\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row - 1;\n        j = col + 2;\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row - 1;\n        j = col - 2;\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 1;\n        j = col - 2;\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        return false;\n    }\npublic:\n    bool checkValidGrid(vector<vector<int>>& grid) {\n        ios::sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);\n        if(grid[0][0] != 0) return false;\n        return helper(grid,0,0,1);\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    bool helper(vector<vector<int>>& grid, int row, int col, int num){\\n        int n = grid.size();\\n        if(num == n*n) return true;\\n        int i = row-2;\\n        int j = col+1;\\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row-2;\\n        j = col-1;\\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row + 2;\\n        j = col - 1;\\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row + 2;\\n        j = col + 1;\\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row + 1;\\n        j = col + 2;\\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row - 1;\\n        j = col + 2;\\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row - 1;\\n        j = col - 2;\\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row + 1;\\n        j = col - 2;\\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        return false;\\n    }\\npublic:\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(0);\\n        cout.tie(0);\\n        if(grid[0][0] != 0) return false;\\n        return helper(grid,0,0,1);\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "== and = confusion",
            "operation error",
            "wrong comment mark",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution {\nprivate:\n    bool helper(vector<vector<int>>& grid, int row, int col, int num){\n        int n \n        if(num = n*n) return true;\n        int i = row-2;\n        int j = col+1;\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row-2;\n        j = col-1;\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+2);\n\n        i = row + 2;\n        j = col - 1;\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 2;\n        j = col + 1;\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 1;\n        j = col + 2;\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row - 1;\n        j = col + 2;\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row - 1;\n        j = col - 2;\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 1;\n        j = col - 2;\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        return false;\n    }\npublic:\n    bool checkValidGrid(vector<vector<int>>& grid) {\n        sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);\n        if(grid[0][0] != 0) return false;\n        return helper(grid,0,0,1);\n    }\n};\n"
    },
    {
        "slug": "relative-ranks",
        "description": "You are given an integer array score of size n, where score[i] is the score of the ith athlete in a competition. All the scores are guaranteed to be unique.\nThe athletes are placed based on their scores, where the 1st place athlete has the highest score, the 2nd place athlete has the 2nd highest score, and so on. The placement of each athlete determines their rank:\n\nThe 1st place athlete's rank is \"Gold Medal\".\nThe 2nd place athlete's rank is \"Silver Medal\".\nThe 3rd place athlete's rank is \"Bronze Medal\".\nFor the 4th place to the nth place athlete, their rank is their placement number (i.e., the xth place athlete's rank is \"x\").\n\nReturn an array answer of size n where answer[i] is the rank of the ith athlete.",
        "examples": [
            "Input: score = [5,4,3,2,1]\nOutput: [\"Gold Medal\",\"Silver Medal\",\"Bronze Medal\",\"4\",\"5\"]\nExplanation: The placements are [1st, 2nd, 3rd, 4th, 5th].",
            "Input: score = [10,3,8,9,4]\nOutput: [\"Gold Medal\",\"5\",\"Bronze Medal\",\"Silver Medal\",\"4\"]\nExplanation: The placements are [1st, 5th, 3rd, 2nd, 4th]."
        ],
        "constraints": "n == score.length\n1 <= n <= 104\n0 <= score[i] <= 106\nAll the values in score are unique.",
        "oracle_code": "class Solution {\npublic:\n    vector<string> findRelativeRanks(vector<int>& score) {\n        int n = score.size();\n        \n        vector<pair<int, int>> arr;\n        for (int i=0; i<n; i++) arr.push_back({score[i], i});\n\n        sort(rbegin(arr), rend(arr));\n\n        vector<string> res(n);\n        for (int i=0; i<n; i++) \n            res[arr[i].second] = i==0? \"Gold Medal\": (i==1? \"Silver Medal\": (i==2? \"Bronze Medal\": to_string(i+1)));\n\n        return res;\n    }\n};",
        "content": "**vector solution**\\n```\\nclass Solution {\\npublic:\\n    vector<string> findRelativeRanks(vector<int>& score) {\\n        int n = score.size();\\n        \\n        vector<pair<int, int>> arr;\\n        for (int i=0; i<n; i++) arr.push_back({score[i], i});\\n\\n        sort(rbegin(arr), rend(arr));\\n\\n        vector<string> res(n);\\n        for (int i=0; i<n; i++) \\n            res[arr[i].second] = i==0? \"Gold Medal\": (i==1? \"Silver Medal\": (i==2? \"Bronze Medal\": to_string(i+1)));\\n\\n        return res;\\n    }\\n};\\n```\\n---\\n**priority queue solution**\\n```\\nclass Solution {\\npublic:\\n    vector<string> findRelativeRanks(vector<int>& score) {\\n        int n = score.size();\\n        \\n        priority_queue< pair<int, int>, vector<pair<int,int>> > pq;\\n        for (int i=0; i<n; i++) pq.push({score[i], i});\\n\\n        vector<string> res(n);\\n        while (!pq.empty()) {\\n            auto x = pq.top();\\n            int size = pq.size();\\n            res[x.second] = (size == n? \"Gold Medal\": (size == n-1? \"Silver Medal\": (size == n-2? \"Bronze Medal\": to_string(n-size+1))));\\n            pq.pop();\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "== and = confusion",
            "unclosed string",
            "undefined keywords from other languages",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    vector<string> findRelativeRanks(vector<int>& score) {\n        int n = score.size();\n        \n        vector<pair<int, int>> arr;\n        for (int i=0; i<n; i++) arr.push_back({score[i], i});\n\n        sort(rbegin(arr), rend(arr));\n        \n        vector<string> rank;\n\n        for (int i=0; i<n; i++) \n            rank[arr[i].second] = i==0? \"Gold Medal: (i==1? \"Silver Medal\": (i=2? \"Bronze Medal\": to_s(i+1)));\n\n        return rank;\n    }\n};\n"
    },
    {
        "slug": "check-knight-tour-configuration",
        "description": "There is a knight on an n x n chessboard. In a valid configuration, the knight starts at the top-left cell of the board and visits every cell on the board exactly once.\nYou are given an n x n integer matrix grid consisting of distinct integers from the range [0, n * n - 1] where grid[row][col] indicates that the cell (row, col) is the grid[row][col]th cell that the knight visited. The moves are 0-indexed.\nReturn true if grid represents a valid configuration of the knight's movements or false otherwise.\nNote that a valid knight move consists of moving two squares vertically and one square horizontally, or two squares horizontally and one square vertically. The figure below illustrates all the possible eight moves of a knight from some cell.",
        "examples": [
            "Input: grid = [[0,11,16,5,20],[17,4,19,10,15],[12,1,8,21,6],[3,18,23,14,9],[24,13,2,7,22]]\nOutput: true\nExplanation: The above diagram represents the grid. It can be shown that it is a valid configuration.",
            "Input: grid = [[0,3,6],[5,8,1],[2,7,4]]\nOutput: false\nExplanation: The above diagram represents the grid. The 8th move of the knight is not valid considering its position after the 7th move."
        ],
        "constraints": "n == grid.length == grid[i].length\n3 <= n <= 7\n0 <= grid[row][col] < n * n\nAll integers in grid are unique.",
        "oracle_code": "class Solution {\nprivate:\n    bool helper(vector<vector<int>>& grid, int row, int col, int num){\n        int n = grid.size();\n        if(num == n*n) return true;\n        int i = row-2;\n        int j = col+1;\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row-2;\n        j = col-1;\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 2;\n        j = col - 1;\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 2;\n        j = col + 1;\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 1;\n        j = col + 2;\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row - 1;\n        j = col + 2;\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row - 1;\n        j = col - 2;\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 1;\n        j = col - 2;\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        return false;\n    }\npublic:\n    bool checkValidGrid(vector<vector<int>>& grid) {\n        ios::sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);\n        if(grid[0][0] != 0) return false;\n        return helper(grid,0,0,1);\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    bool helper(vector<vector<int>>& grid, int row, int col, int num){\\n        int n = grid.size();\\n        if(num == n*n) return true;\\n        int i = row-2;\\n        int j = col+1;\\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row-2;\\n        j = col-1;\\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row + 2;\\n        j = col - 1;\\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row + 2;\\n        j = col + 1;\\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row + 1;\\n        j = col + 2;\\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row - 1;\\n        j = col + 2;\\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row - 1;\\n        j = col - 2;\\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row + 1;\\n        j = col - 2;\\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        return false;\\n    }\\npublic:\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(0);\\n        cout.tie(0);\\n        if(grid[0][0] != 0) return false;\\n        return helper(grid,0,0,1);\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "== and = confusion",
            "operation error",
            "wrong comment mark",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\nprivate:\n    bool helper(vector<vector<int>>& grid, int row, int col, int num){\n        int n \n        if(num = n*n) return true;\n        int i = row-2;\n        int j = col+1;\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row-2;\n        j = col-1;\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+2);\n\n        i = row + 2;\n        j = col - 1;\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 2;\n        j = col + 1;\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 1;\n        j = col + 2;\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row - 1;\n        j = col + 2;\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row - 1;\n        j = col - 2;\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 1;\n        j = col - 2;\n        if(i<n && j>=0 && grid[i][j] == num) return methodNotFound(grid,i,j,num+1);\n\n        return false;\n    }\npublic:\n    bool checkValidGrid(vector<vector<int>>& grid) {\n        ios::sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);\n        if(grid[0][0] != 0) return false;\n        return helper(grid,0,0,1);\n    }\n};\n"
    },
    {
        "slug": "perfect-squares",
        "description": "Given an integer n, return the least number of perfect square numbers that sum to n.\nA perfect square is an integer that is the square of an integer; in other words, it is the product of some integer with itself. For example, 1, 4, 9, and 16 are perfect squares while 3 and 11 are not.",
        "examples": [
            "Input: n = 12\nOutput: 3\nExplanation: 12 = 4 + 4 + 4.",
            "Input: n = 13\nOutput: 2\nExplanation: 13 = 4 + 9."
        ],
        "constraints": "1 <= n <= 104",
        "oracle_code": "class Solution {\npublic:\n\n    // declare a dp\n\n    int dp[105][10005];\n\n    int helper(vector<int>& arr, int i, int n, int sum)\n    {\n        // base case\n\n        if(sum == 0)\n        {\n            return 0;\n        }\n\n        if(i >= n || sum < 0)\n        {\n            return INT_MAX - 1000;\n        }\n\n        // if already calculated\n\n        if(dp[i][sum] != -1)\n        {\n            return dp[i][sum];\n        }\n\n        // at each ith element we have two options either include or exclude\n\n        int mini = INT_MAX;\n\n        // inclusion part\n\n        if(arr[i] <= sum)\n        {\n            mini = min(mini, 1 + helper(arr, i, n, sum - arr[i]));\n        }\n\n        // exclusion part\n\n        mini = min(mini, helper(arr, i + 1, n, sum));\n\n        // store the res in dp\n\n        return dp[i][sum] = mini;\n    }\n\n    int numSquares(int n) {\n\n        vector<int> arr;\n\n        // find all the squares between 1 to n\n\n        for(int i = 1; i * i <= n; i++)\n        {\n            arr.push_back(i * i);\n        }\n\n        // initialize dp with -1\n\n        memset(dp, -1, sizeof(dp));\n\n        return helper(arr, 0, arr.size(), n);\n    }\n};",
        "content": "* ***Using Recursion && Memoization***\\n\\n* ***Time Complexity :- O(N * sqrt(N))***\\n\\n* ***Space Complexity :- O(N * sqrt(N))***\\n\\n* ***There are sqrt(N), squares between 1 to N***\\n\\n```\\nclass Solution {\\npublic:\\n\\n    // declare a dp\\n\\n    int dp[105][10005];\\n\\n    int helper(vector<int>& arr, int i, int n, int sum)\\n    {\\n        // base case\\n\\n        if(sum == 0)\\n        {\\n            return 0;\\n        }\\n\\n        if(i >= n || sum < 0)\\n        {\\n            return INT_MAX - 1000;\\n        }\\n\\n        // if already calculated\\n\\n        if(dp[i][sum] != -1)\\n        {\\n            return dp[i][sum];\\n        }\\n\\n        // at each ith element we have two options either include or exclude\\n\\n        int mini = INT_MAX;\\n\\n        // inclusion part\\n\\n        if(arr[i] <= sum)\\n        {\\n            mini = min(mini, 1 + helper(arr, i, n, sum - arr[i]));\\n        }\\n\\n        // exclusion part\\n\\n        mini = min(mini, helper(arr, i + 1, n, sum));\\n\\n        // store the res in dp\\n\\n        return dp[i][sum] = mini;\\n    }\\n\\n    int numSquares(int n) {\\n\\n        vector<int> arr;\\n\\n        // find all the squares between 1 to n\\n\\n        for(int i = 1; i * i <= n; i++)\\n        {\\n            arr.push_back(i * i);\\n        }\\n\\n        // initialize dp with -1\\n\\n        memset(dp, -1, sizeof(dp));\\n\\n        return helper(arr, 0, arr.size(), n);\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "== and = confusion",
            "indexing error",
            "conditional statement error",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n\n    int dp[105][10005];\n\n    int helper(vector<int>& arr, int i, int n, int sum)\n    {\n        if(i > n || sum <= 0) \n        {\n            return INT_MAX - 1000;\n        }\n\n        if(dp[i][sum] != -1)\n        {\n            return dp[i][sum];\n        }\n\n        int mini = INT_MAX;\n\n        if(arr[i] <= sum)\n        {\n            mini = min(mini, 1 + helper(arr=, i, n, sum - arr[i]));\n        }\n\n        mini = min(mini, helper(arr, i + 1, n, sum));\n\n        return dp[i][sum] = mini;\n    }\n\n    int numSquares(int n) {\n\n        vector<int> arr;\n\n        for(int i = 1; i * i <= n; i++)\n        {\n            arr.push_back(i * i);\n        }\n\n        memset(dp, -1, sizeof(dp));\n\n        \n        print(helper(arr, 0, arr.size(), n));\n    }\n};\n"
    },
    {
        "slug": "lru-cache",
        "description": "Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.\nImplement the LRUCache class:\n\nLRUCache(int capacity) Initialize the LRU cache with positive size capacity.\nint get(int key) Return the value of the key if the key exists, otherwise return -1.\nvoid put(int key, int value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key.\n\nThe functions get and put must each run in O(1) average time complexity.",
        "examples": [
            "Input\n[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"]\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\nOutput\n[null, null, null, 1, null, -1, null, -1, 3, 4]\n\nExplanation\nLRUCache lRUCache = new LRUCache(2);\nlRUCache.put(1, 1); // cache is {1=1}\nlRUCache.put(2, 2); // cache is {1=1, 2=2}\nlRUCache.get(1);    // return 1\nlRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}\nlRUCache.get(2);    // returns -1 (not found)\nlRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}\nlRUCache.get(1);    // return -1 (not found)\nlRUCache.get(3);    // return 3\nlRUCache.get(4);    // return 4"
        ],
        "constraints": "1 <= capacity <= 3000\n0 <= key <= 104\n0 <= value <= 105\nAt most 2 * 105 calls will be made to get and put.",
        "oracle_code": "class LRUCache {\npublic:\nclass node\n{\n  public:\n  int key;\n  int val;\n  node* next;\n  node* prev;\n  node(int _key,int _val)\n  {\n    key = _key;\n    val = _val;\n  }\n};\nnode* head = new node(-1,-1);\nnode* tail = new node(-1,-1);\n\nint size;\nunordered_map<int,node*>mpp;\n    LRUCache(int capacity) {\n       size = capacity; \n       head->next = tail;\n       tail->prev = head;  \n    }\n\n    void addNode(node* newNode){\n       \n       node* temp = head->next;\n       newNode->next = temp;\n       newNode->prev = head;\n       head->next = newNode;\n       temp->prev = newNode;\n    }\n\n    void deleteNode(node* delNode){\n         \n       node* delprev = delNode->prev;\n       node* delnext = delNode->next;\n       delprev->next = delnext;\n       delnext->prev = delprev;\n    }\n    \n    int get(int _key) {\n        \n        if(mpp.count(_key))\n        {\n          node* nde = mpp[_key];\n          int curr = nde->val;\n          mpp.erase(_key);\n          deleteNode(nde);\n          addNode(nde);\n          mpp[_key] = head->next;\n          return curr;\n        }\n        return -1;\n    }\n    \n    void put(int _key, int value) {\n        \n        if(mpp.count(_key))\n        {\n           node* nde = mpp[_key];\n           mpp.erase(_key);\n           deleteNode(nde);\n        }\n        if(mpp.size()==size)\n        {\n           mpp.erase(tail->prev->key);\n           deleteNode(tail->prev);\n        }\n        addNode(new node(_key,value));\n        mpp[_key] = head->next;\n    }\n};",
        "content": "# PLEASE DO UPVOTE!!!!!\\n\\n**CONNECT WITH ME ON LINKEDIN :  https://www.linkedin.com/in/md-kamran-55b98521a/**\\n\\n## INTUITION\\nTo Implement LRU(Least recently used), we need to have a track of the usage of the keys, in the order of there usage, as we have a limited capacity we cant extend our capacity beyond \"capacity\", so we always we will take out those values which has\\'nt been acccess in the recent time.So, we have to think of something that can kind of sort our keys according to usage on the go, the best Data Structure for this purpose is Doubly linked List.\\n                             A Doubly linked list will have a Head node as well as a tail node, and whenever a key is used we will place it just next to the head node,in this fashions, the one\\'s which are closer to head are the most recently used ones, and as we go closer to the tail node, those are the less recently used ones while the node just previous to tail is the \"LEAST RECENTLY USED\". \\nSo whenever we add a key or use a key(get()), we will move it right after the head node, and whenever we call the (put() function), if size if greater we have to delete the LRU node, if key is not present, (if present then too we will delete that node so as to update the value and still move it right after head node), and place new node right after head node.                        \\n\\n\\n**Ask Furthur Doubts in the Comment Section**\\n# Code\\n```\\nclass LRUCache {\\npublic:\\nclass node\\n{\\n  public:\\n  int key;\\n  int val;\\n  node* next;\\n  node* prev;\\n  node(int _key,int _val)\\n  {\\n    key = _key;\\n    val = _val;\\n  }\\n};\\nnode* head = new node(-1,-1);\\nnode* tail = new node(-1,-1);\\n\\nint size;\\nunordered_map<int,node*>mpp;\\n    LRUCache(int capacity) {\\n       size = capacity; \\n       head->next = tail;\\n       tail->prev = head;  \\n    }\\n\\n    void addNode(node* newNode){\\n       \\n       node* temp = head->next;\\n       newNode->next = temp;\\n       newNode->prev = head;\\n       head->next = newNode;\\n       temp->prev = newNode;\\n    }\\n\\n    void deleteNode(node* delNode){\\n         \\n       node* delprev = delNode->prev;\\n       node* delnext = delNode->next;\\n       delprev->next = delnext;\\n       delnext->prev = delprev;\\n    }\\n    \\n    int get(int _key) {\\n        \\n        if(mpp.count(_key))\\n        {\\n          node* nde = mpp[_key];\\n          int curr = nde->val;\\n          mpp.erase(_key);\\n          deleteNode(nde);\\n          addNode(nde);\\n          mpp[_key] = head->next;\\n          return curr;\\n        }\\n        return -1;\\n    }\\n    \\n    void put(int _key, int value) {\\n        \\n        if(mpp.count(_key))\\n        {\\n           node* nde = mpp[_key];\\n           mpp.erase(_key);\\n           deleteNode(nde);\\n        }\\n        if(mpp.size()==size)\\n        {\\n           mpp.erase(tail->prev->key);\\n           deleteNode(tail->prev);\\n        }\\n        addNode(new node(_key,value));\\n        mpp[_key] = head->next;\\n    }\\n};\\n\\n```\\n![b62ab1be-232a-438f-9524-7d8ca4dbd5fe_1675328166.1161866.png](https://assets.leetcode.com/users/images/8d5343b1-0eb4-4111-a914-40ce968fd034_1675389764.2273676.png)",
        "level": "medium",
        "type": [
            "undefined methods",
            "undefined keywords from other languages",
            "variable value error",
            "undefined objects"
        ],
        "buggy_code": "\nclass LRUCache {\npublic:\nclass node\n{\n  public:\n  int key;\n  int val;\n  node* next;\n  node* prev;\n  node(int _key,int _val)\n  {\n    key = _key;\n    val = _val;\n  }\n};\nnode* head = nullptr;\nnode* tail = nullptr;\n\nint size;\nunordered_map<int,node*>mpp;\n    LRUCache(int capacity) {\n       size = capacity; \n       head->next = tail;\n       tail->prev = head;  \n    }\n\n    void addNode(node* newNode){\n       \n       node* temp = head->next;\n       newNode->next = temp;\n       newNode->prev = head;\n       head->next = newNode;\n       temp->prev = newNode;\n    }\n\n    void deleteNode(node* delNode){\n         \n       node* delprev = delNode->prev;\n       node* delnext = delNode->next;\n       delprev->next = delnext;\n       delnext->prev = delprev;\n    }\n    \n    int get(int _key) {\n        \n        if(mpp.count(_key))\n        {\n          node* nde = mpp[_key];\n          int curr = nde->val;\n          mpp.erase(_key);\n          deleteNode(nde);\n          addNode(nde);\n          mpp[_key] = head->next;\n          return curr;\n        }\n        return -1;\n    }\n\n}; \nr\ntil\n\n"
    },
    {
        "slug": "longest-ideal-subsequence",
        "description": "You are given a string s consisting of lowercase letters and an integer k. We call a string t ideal if the following conditions are satisfied:\n\nt is a subsequence of the string s.\nThe absolute difference in the alphabet order of every two adjacent letters in t is less than or equal to k.\n\nReturn the length of the longest ideal string.\nA subsequence is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.\nNote that the alphabet order is not cyclic. For example, the absolute difference in the alphabet order of 'a' and 'z' is 25, not 1.",
        "examples": [
            "Input: s = \"acfgbd\", k = 2\nOutput: 4\nExplanation: The longest ideal string is \"acbd\". The length of this string is 4, so 4 is returned.\nNote that \"acfgbd\" is not ideal because 'c' and 'f' have a difference of 3 in alphabet order.",
            "Input: s = \"abcd\", k = 3\nOutput: 4\nExplanation: The longest ideal string is \"abcd\". The length of this string is 4, so 4 is returned."
        ],
        "constraints": "1 <= s.length <= 105\n0 <= k <= 25\ns consists of lowercase English letters.",
        "oracle_code": "class Solution {\n\n\n   int SolveByMemo(string &s , int &k , int index , int prev , vector<vector<int>> &dp)\n   {\n       if(index == s.length())\n       return 0;\n\n       if(dp[index][prev] != -1)\n       return dp[index][prev];\n\n       int op1 = 0 + SolveByMemo(s, k , index+1 , prev , dp);\n\n       int op2 = 0 ;\n\n       if(prev == 26)\n       op2 = 1 + SolveByMemo(s, k , index+1 , s[index]-'a' , dp);\n       else if(abs(s[index]-'a' - prev) <= k)\n       op2 = 1 + SolveByMemo(s, k , index+1 , s[index]-'a' , dp);\n\n       return dp[index][prev] = max(op1 , op2);\n   }\n\n   int SolveByTab(string &s , int &k )\n   {\n        vector<vector<int>> dp(s.length()+1 , vector<int> (27, 0));\n       \n        for(int index = s.length()-1 ; index>=0 ; index--)\n        {\n            for(int prev = 0 ; prev<= 26 ; prev++)\n            {\n                int op1 = 0 + dp[index+1][prev];\n                int op2 = 0 ;\n\n               if(prev == 26)\n               op2 = 1 + dp[index+1][s[index]-'a'];\n               else if(abs(s[index]-'a' - prev) <= k)\n               op2 = 1 + dp[index+1][s[index]-'a'];\n\n               dp[index][prev] = max(op1 , op2);\n            }\n        }\n\n       return max(dp[0][s[0]-'a'] , dp[0][26]);\n   }\n\n   int SolveByTabSpaceOptimised(string &s , int &k )\n   {\n        vector<int> next(27, 0) ;\n        vector<int> curr(27, 0);\n       \n        for(int index = s.length()-1 ; index>=0 ; index--)\n        {\n            for(int prev = 0 ; prev<= 26 ; prev++)\n            {\n                int op1 = 0 + next[prev];\n                int op2 = 0 ;\n\n               if(prev == 26)\n               op2 = 1 + next[s[index]-'a'];\n               else if(abs(s[index]-'a' - prev) <= k)\n               op2 = 1 + next[s[index]-'a'];\n\n               curr[prev] = max(op1 , op2);\n            }\n            next = curr;\n        }\n\n       return max(curr[s[0]-'a'] , curr[26]);\n   }\n\npublic:\n    int longestIdealString(string s, int k) {\n        \n        // 1. Recursion + Memoization || Top Down Approach\n        // vector<vector<int>> dp(s.length() , vector<int> (27, -1));\n        // return SolveByMemo(s, k , 0 , 26, dp);\n\n        // 2. Tabulation Method || Bottom Up Approach\n        // return SolveByTab(s, k);\n\n        // 3. Space Optimisation using Tabulation\n        return SolveByTabSpaceOptimised(s , k);\n    }\n};",
        "content": "\\n# Approach\\nWe Have Use Three Different Approaches :\\n1. Recursion + Memoization \\n    TC : O(n^2) , SC : O(n)\\n2. Tabulation Method \\n    TC : O(n^2) , SC : O(n)\\n3.  Tabulatuon With SOace Optimised\\n    TC : O(n^2) , SC : O(1) \\n\\n\\n#Note\\nSC In first two methods is On) and not O(n^2) as size is fixed to 27 for each index hence it is Linear Space ,Similarly for 3rd Method we have optimised to constant space as at any instant we onlt need memory of next 27 blocks  only.\\n\\n#Hope You Liekd It and Upvote are appreciated \\n\\n# Code\\n```\\nclass Solution {\\n\\n\\n   int SolveByMemo(string &s , int &k , int index , int prev , vector<vector<int>> &dp)\\n   {\\n       if(index == s.length())\\n       return 0;\\n\\n       if(dp[index][prev] != -1)\\n       return dp[index][prev];\\n\\n       int op1 = 0 + SolveByMemo(s, k , index+1 , prev , dp);\\n\\n       int op2 = 0 ;\\n\\n       if(prev == 26)\\n       op2 = 1 + SolveByMemo(s, k , index+1 , s[index]-\\'a\\' , dp);\\n       else if(abs(s[index]-\\'a\\' - prev) <= k)\\n       op2 = 1 + SolveByMemo(s, k , index+1 , s[index]-\\'a\\' , dp);\\n\\n       return dp[index][prev] = max(op1 , op2);\\n   }\\n\\n   int SolveByTab(string &s , int &k )\\n   {\\n        vector<vector<int>> dp(s.length()+1 , vector<int> (27, 0));\\n       \\n        for(int index = s.length()-1 ; index>=0 ; index--)\\n        {\\n            for(int prev = 0 ; prev<= 26 ; prev++)\\n            {\\n                int op1 = 0 + dp[index+1][prev];\\n                int op2 = 0 ;\\n\\n               if(prev == 26)\\n               op2 = 1 + dp[index+1][s[index]-\\'a\\'];\\n               else if(abs(s[index]-\\'a\\' - prev) <= k)\\n               op2 = 1 + dp[index+1][s[index]-\\'a\\'];\\n\\n               dp[index][prev] = max(op1 , op2);\\n            }\\n        }\\n\\n       return max(dp[0][s[0]-\\'a\\'] , dp[0][26]);\\n   }\\n\\n   int SolveByTabSpaceOptimised(string &s , int &k )\\n   {\\n        vector<int> next(27, 0) ;\\n        vector<int> curr(27, 0);\\n       \\n        for(int index = s.length()-1 ; index>=0 ; index--)\\n        {\\n            for(int prev = 0 ; prev<= 26 ; prev++)\\n            {\\n                int op1 = 0 + next[prev];\\n                int op2 = 0 ;\\n\\n               if(prev == 26)\\n               op2 = 1 + next[s[index]-\\'a\\'];\\n               else if(abs(s[index]-\\'a\\' - prev) <= k)\\n               op2 = 1 + next[s[index]-\\'a\\'];\\n\\n               curr[prev] = max(op1 , op2);\\n            }\\n            next = curr;\\n        }\\n\\n       return max(curr[s[0]-\\'a\\'] , curr[26]);\\n   }\\n\\npublic:\\n    int longestIdealString(string s, int k) {\\n        \\n        // 1. Recursion + Memoization || Top Down Approach\\n        // vector<vector<int>> dp(s.length() , vector<int> (27, -1));\\n        // return SolveByMemo(s, k , 0 , 26, dp);\\n\\n        // 2. Tabulation Method || Bottom Up Approach\\n        // return SolveByTab(s, k);\\n\\n        // 3. Space Optimisation using Tabulation\\n        return SolveByTabSpaceOptimised(s , k);\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "wrong comment mark",
            "unclosed string",
            "variable value error",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution {\n\n   int SolveByMemo(string &s , int &k , int index , int prev , vector<vector<int>> &dp)\n   {\n       if(index == s.length())\n       return 0;\n\n       if(dp[index][prev] != -1)\n       return dp[index][prev];\n\n       int op1 = 0 + SolveByMemo(s, k , index+1 , prev , dp);\n\n       int op2 = 0 ;\n\n       if(prev == 26)\n       op2 = 1 + SolveByMemo(s, string() , index+1 , prev , dp);\n       else if(abs(s[index]-'a' - prev) <= k)\n       op2 = 1 /*+ SolveByMemo(s, k , index+1 , s[index]-'a' , dp);*/\n\n       return dp[index][prev] = max(op1 , op2);\n   }\n..prev];\n               else if(abs(-prv)<= k)\n               op2 = 1 + dp[ndex+1][];\n dp[index][prev] = max(op1 ,);\n        }\n        }\n\n       rtur ma(dp[0][s[0publc:\n    i longestIdealString(string s, int k) {\n        \n        // 1. Recursion + Memoization || Top Down Approach\n        // vector<vector<int>> dp(s.length() , vector<int> (27, -1));\n        // return SolveByMemo(s, k , 0 , 26, dp);\n\n        // 2. Tabulation Method || Bottom Up Approach\n        return"
    },
    {
        "slug": "maximum-strictly-increasing-cells-in-a-matrix",
        "description": "Given a 1-indexed\u00a0m x n integer matrix mat, you can select any cell in the matrix as your starting cell.\nFrom the starting cell, you can move to any other cell in the same row or column, but only if the value of the destination cell is strictly greater than the value of the current cell. You can repeat this process as many times as possible, moving from cell to cell until you can no longer make any moves.\nYour task is to find the maximum number of cells that you can visit in the matrix by starting from some cell.\nReturn an integer denoting the maximum number of cells that can be visited.",
        "examples": [
            "Input: mat = [[3,1],[3,4]]\nOutput: 2\nExplanation: The image shows how we can visit 2 cells starting from row 1, column 2. It can be shown that we cannot visit more than 2 cells no matter where we start from, so the answer is 2.",
            "Input: mat = [[1,1],[1,1]]\nOutput: 1\nExplanation: Since the cells must be strictly increasing, we can only visit one cell in this example.",
            "Input: mat = [[3,1,6],[-9,5,7]]\nOutput: 4\nExplanation: The image above shows how we can visit 4 cells starting from row 2, column 1. It can be shown that we cannot visit more than 4 cells no matter where we start from, so the answer is 4."
        ],
        "constraints": "m == mat.length\u00a0\nn == mat[i].length\u00a0\n1 <= m, n <= 105\n1 <= m * n <= 105\n-105\u00a0<= mat[i][j] <= 105",
        "oracle_code": "class Solution {\npublic:\n    int maxIncreasingCells(vector<vector<int>>& mat) {\n        int n = mat.size(), m = mat[0].size();\n        vector<int> row_max(n), col_max(m);\n        \n        map<int, vector<pair<int, int>>, greater<int>> pos;\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                pos[mat[i][j]].push_back({i, j});\n            }\n        }\n        \n        int ans = 0;\n        for (auto& [num, cells]: pos) {\n            int k = cells.size();\n            vector<int> next(k);\n            for (int i = 0; i < k; ++i) {\n                int r = cells[i].first, c = cells[i].second;\n                next[i] = max(row_max[r], col_max[c]) + 1;\n                ans = max(ans, next[i]);\n            }\n            for (int i = 0; i < k; ++i) {\n                int r = cells[i].first, c = cells[i].second;\n                row_max[r] = max(row_max[r], next[i]);\n                col_max[c] = max(col_max[c], next[i]);\n            }\n        }\n        return ans;\n    }\n};",
        "content": "# Intuition\\nAt first I thought of a 2d dp. You can iterate through the matrix in order of decreasing cell value, storing the max number of cells reachable from each cell `mat[i][j]` in `dp[i][j]`. However, for each cell you have to look at all reachable cells (its entire row and column), so the time complexity would be $$O(n*m*(n+m))$$, which isn\\u2019t fast enough.\\n\\nThen I realized you don\\u2019t need to store the max for every cell. As you iterate through the matrix in order of decreasing cell value, you always take the maximum path already found starting in the same row or column. This means you can get away with just storing the max for each row and column.\\n\\n# Approach\\nCreate a map of cell values in decreasing order to (r, c) positions in the matrix with those values. Iterate through this map, updating the vectors row_max and col_max, which store the max number of cells reachable starting from somewhere in each row and column. Be careful to only update row_max and col_max after every cell with a given value has been processed.\\n\\n\\n# Complexity\\n- Time complexity\\n$$O(n*m*log(n*m))$$\\n\\n- Space complexity:\\n$$O(n*m)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxIncreasingCells(vector<vector<int>>& mat) {\\n        int n = mat.size(), m = mat[0].size();\\n        vector<int> row_max(n), col_max(m);\\n        \\n        map<int, vector<pair<int, int>>, greater<int>> pos;\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < m; ++j) {\\n                pos[mat[i][j]].push_back({i, j});\\n            }\\n        }\\n        \\n        int ans = 0;\\n        for (auto& [num, cells]: pos) {\\n            int k = cells.size();\\n            vector<int> next(k);\\n            for (int i = 0; i < k; ++i) {\\n                int r = cells[i].first, c = cells[i].second;\\n                next[i] = max(row_max[r], col_max[c]) + 1;\\n                ans = max(ans, next[i]);\\n            }\\n            for (int i = 0; i < k; ++i) {\\n                int r = cells[i].first, c = cells[i].second;\\n                row_max[r] = max(row_max[r], next[i]);\\n                col_max[c] = max(col_max[c], next[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
        "level": "hard",
        "type": [
            "statement separation",
            "operation error",
            "wrong comment mark",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    int maxIncreasingCells(vector<vector<int>>& mat) {\n        int n = mat.size(), m = mat[0].size();\n        /*vector<int>*/ row_max(n), col_max(m);\n        map<int, vector<pair<int, int>>, greater<int>> pos;\n        \n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j) \n            pos[mat[i][j]].push_back({i, j});\n        \n        int ans = 0;\n        for (auto& [num, cells]: pos) \n        int k = cells.size();\n        vector<int> next(k);\n        for (int i = 0; i < k; ++i) {\n            int r = cells[i].first, c = cells[i].second;\n            next[i] = min(row_max[r], col_max[c]) + 1;\n            ans = max(ans, next[i]);\n        }\n        for (int i = 0; i < k; ++i) {\n            int r = cells[i].first, c = cells[i].second;\n            row_max[r] = max(row_max[r], next[i]);\n            col_max[c] = max(col_max[c], next[i]);\n        }\n        return ans;\n    }\nfidMax(an, mat)}    \n    int findMax(int a, vector<vector<int>>& mat) {\n        int max = a;\n        for(int i=0; i<mat.size(); i++) {\n            for(int j=0; j<mat[0].size(); j++) {\n                if(max < mat[i][j])\n                    max = mat[i][j];\n            \n        }\n        return max;\n    }\n};\n"
    },
    {
        "slug": "count-stepping-numbers-in-range",
        "description": "Given two positive integers low and high represented as strings, find the count of stepping numbers in the inclusive range [low, high].\nA stepping number is an integer such that all of its adjacent digits have an absolute difference of exactly 1.\nReturn an integer denoting the count of stepping numbers in the inclusive range [low, high]. \nSince the answer may be very large, return it modulo 109 + 7.\nNote: A stepping number should not have a leading zero.",
        "examples": [
            "Input: low = \"1\", high = \"11\"\nOutput: 10\nExplanation: The stepping numbers in the range [1,11] are 1, 2, 3, 4, 5, 6, 7, 8, 9 and 10. There are a total of 10 stepping numbers in the range. Hence, the output is 10.",
            "Input: low = \"90\", high = \"101\"\nOutput: 2\nExplanation: The stepping numbers in the range [90,101] are 98 and 101. There are a total of 2 stepping numbers in the range. Hence, the output is 2."
        ],
        "constraints": "1 <= int(low) <= int(high) < 10100\n1 <= low.length, high.length <= 100\nlow and high consist of only digits.\nlow and high don't have any leading zeros.",
        "oracle_code": "class Solution {\npublic:\n    #define mod 1000000007\n    long long dp[102][10][2][2];\n    long long f(string &r,int n,int pre,int leadingZero,int tight){\n        if(n==0) return 1;\n        \n        if(dp[n][pre][leadingZero][tight]!=-1) return dp[n][pre][leadingZero][tight];\n        long long up = tight ? (r[r.size()-n]-'0'):9,ans=0;\n        \n        if(leadingZero){\n            for(int i=0;i<=up;i++){\n                ans = (ans + f(r,n-1,i,(i==0),tight&(i==up)))%mod; \n            }\n        } else {\n            if(pre-1>=0 && pre-1<=up) ans = (ans + f(r,n-1,pre-1,0,tight&(pre-1==up)))%mod;\n            if(pre+1<=up) ans = (ans + f(r,n-1,pre+1,0,tight&(pre+1==up)))%mod;\n        }\n        \n        \n        return dp[n][pre][leadingZero][tight]=ans;\n    }\n    int countSteppingNumbers(string low, string high) {\n        int n=high.size();\n        memset(dp,-1,sizeof(dp));\n        long long r= f(high,high.size(),0,1,1);\n        memset(dp,-1,sizeof(dp));\n        for(int i=low.size()-1;i>=0;i--){\n            if((low[i]-'0')>0){\n                low[i]--;break;\n            } else {\n                low[i]='9';\n            }\n        }\n        \n        // cout<<low<<endl;\n        long long l= f(low,low.size(),0,1,1);\n        cout<<l<<\" \"<<r<<endl;\n        return (r-l+mod)%mod;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    #define mod 1000000007\\n    long long dp[102][10][2][2];\\n    long long f(string &r,int n,int pre,int leadingZero,int tight){\\n        if(n==0) return 1;\\n        \\n        if(dp[n][pre][leadingZero][tight]!=-1) return dp[n][pre][leadingZero][tight];\\n        long long up = tight ? (r[r.size()-n]-\\'0\\'):9,ans=0;\\n        \\n        if(leadingZero){\\n            for(int i=0;i<=up;i++){\\n                ans = (ans + f(r,n-1,i,(i==0),tight&(i==up)))%mod; \\n            }\\n        } else {\\n            if(pre-1>=0 && pre-1<=up) ans = (ans + f(r,n-1,pre-1,0,tight&(pre-1==up)))%mod;\\n            if(pre+1<=up) ans = (ans + f(r,n-1,pre+1,0,tight&(pre+1==up)))%mod;\\n        }\\n        \\n        \\n        return dp[n][pre][leadingZero][tight]=ans;\\n    }\\n    int countSteppingNumbers(string low, string high) {\\n        int n=high.size();\\n        memset(dp,-1,sizeof(dp));\\n        long long r= f(high,high.size(),0,1,1);\\n        memset(dp,-1,sizeof(dp));\\n        for(int i=low.size()-1;i>=0;i--){\\n            if((low[i]-\\'0\\')>0){\\n                low[i]--;break;\\n            } else {\\n                low[i]=\\'9\\';\\n            }\\n        }\\n        \\n        // cout<<low<<endl;\\n        long long l= f(low,low.size(),0,1,1);\\n        cout<<l<<\" \"<<r<<endl;\\n        return (r-l+mod)%mod;\\n    }\\n};\\n```",
        "level": "hard",
        "type": [
            "== and = confusion",
            "variable value error",
            "colon missing",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n#define mod 1000000007\nlong long dp[102][10][2][2];\nlong long f(string &r,int n,int pre,int leadingZero,int tight){\n    if(n==0) return 1;\n    \n    if(dp[n][pre][leadingZero][tight]!=-1) return dp[n][pre][leadingZero][tight];\n    long long up = tight ? (r[r.size()-n]-'0')9,ans=0;\n    \n    if(leadingZero){\n        for(int i=0;i<=up;i++){\n            ans = (ans + f(r,n-1,i,(i==0),tight&(i==up)))%mod; \n        }\n    } else {\n        if(pre-1>=0 && pre-1<=up) ans = (ans + f(r,n-1,pre-1,0,tight&(pre-1==up)%mod;\n        if(pre+1<=up) ans = (ans + f(r,n-1,pre+1,0,tight&(pre+1==up)))%mod;\n    }\n\n    return dp[n][pre][leadingZero][tight] == ans;\n}\nint countSteppingNumbers(string low, string high) {\n    int n=high.size();\n    memset(dp,-1,sizeof(dp));\n    long long r= f(high,high.size(),0,1,0);  \n    memset(dp,-1,sizeof(dp));\n    for(int i=low.size()-1;i>=0;i--){\n        if((low[i]-'0')>0){\n            low[i]--;break;\n        } else {\n            low[i]='9';\n        }\n    }\n    \n    \n    long long l= f(low,low.size(),0,1,1);\n    cout<<l<<\" \"<<r<<endl;\n    return (r-l+mod)%mod;\n}\n};\n\n"
    },
    {
        "slug": "lru-cache",
        "description": "Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.\nImplement the LRUCache class:\n\nLRUCache(int capacity) Initialize the LRU cache with positive size capacity.\nint get(int key) Return the value of the key if the key exists, otherwise return -1.\nvoid put(int key, int value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key.\n\nThe functions get and put must each run in O(1) average time complexity.",
        "examples": [
            "Input\n[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"]\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\nOutput\n[null, null, null, 1, null, -1, null, -1, 3, 4]\n\nExplanation\nLRUCache lRUCache = new LRUCache(2);\nlRUCache.put(1, 1); // cache is {1=1}\nlRUCache.put(2, 2); // cache is {1=1, 2=2}\nlRUCache.get(1);    // return 1\nlRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}\nlRUCache.get(2);    // returns -1 (not found)\nlRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}\nlRUCache.get(1);    // return -1 (not found)\nlRUCache.get(3);    // return 3\nlRUCache.get(4);    // return 4"
        ],
        "constraints": "1 <= capacity <= 3000\n0 <= key <= 104\n0 <= value <= 105\nAt most 2 * 105 calls will be made to get and put.",
        "oracle_code": "class LRUCache {\npublic:\nclass node\n{\n  public:\n  int key;\n  int val;\n  node* next;\n  node* prev;\n  node(int _key,int _val)\n  {\n    key = _key;\n    val = _val;\n  }\n};\nnode* head = new node(-1,-1);\nnode* tail = new node(-1,-1);\n\nint size;\nunordered_map<int,node*>mpp;\n    LRUCache(int capacity) {\n       size = capacity; \n       head->next = tail;\n       tail->prev = head;  \n    }\n\n    void addNode(node* newNode){\n       \n       node* temp = head->next;\n       newNode->next = temp;\n       newNode->prev = head;\n       head->next = newNode;\n       temp->prev = newNode;\n    }\n\n    void deleteNode(node* delNode){\n         \n       node* delprev = delNode->prev;\n       node* delnext = delNode->next;\n       delprev->next = delnext;\n       delnext->prev = delprev;\n    }\n    \n    int get(int _key) {\n        \n        if(mpp.count(_key))\n        {\n          node* nde = mpp[_key];\n          int curr = nde->val;\n          mpp.erase(_key);\n          deleteNode(nde);\n          addNode(nde);\n          mpp[_key] = head->next;\n          return curr;\n        }\n        return -1;\n    }\n    \n    void put(int _key, int value) {\n        \n        if(mpp.count(_key))\n        {\n           node* nde = mpp[_key];\n           mpp.erase(_key);\n           deleteNode(nde);\n        }\n        if(mpp.size()==size)\n        {\n           mpp.erase(tail->prev->key);\n           deleteNode(tail->prev);\n        }\n        addNode(new node(_key,value));\n        mpp[_key] = head->next;\n    }\n};",
        "content": "# PLEASE DO UPVOTE!!!!!\\n\\n**CONNECT WITH ME ON LINKEDIN :  https://www.linkedin.com/in/md-kamran-55b98521a/**\\n\\n## INTUITION\\nTo Implement LRU(Least recently used), we need to have a track of the usage of the keys, in the order of there usage, as we have a limited capacity we cant extend our capacity beyond \"capacity\", so we always we will take out those values which has\\'nt been acccess in the recent time.So, we have to think of something that can kind of sort our keys according to usage on the go, the best Data Structure for this purpose is Doubly linked List.\\n                             A Doubly linked list will have a Head node as well as a tail node, and whenever a key is used we will place it just next to the head node,in this fashions, the one\\'s which are closer to head are the most recently used ones, and as we go closer to the tail node, those are the less recently used ones while the node just previous to tail is the \"LEAST RECENTLY USED\". \\nSo whenever we add a key or use a key(get()), we will move it right after the head node, and whenever we call the (put() function), if size if greater we have to delete the LRU node, if key is not present, (if present then too we will delete that node so as to update the value and still move it right after head node), and place new node right after head node.                        \\n\\n\\n**Ask Furthur Doubts in the Comment Section**\\n# Code\\n```\\nclass LRUCache {\\npublic:\\nclass node\\n{\\n  public:\\n  int key;\\n  int val;\\n  node* next;\\n  node* prev;\\n  node(int _key,int _val)\\n  {\\n    key = _key;\\n    val = _val;\\n  }\\n};\\nnode* head = new node(-1,-1);\\nnode* tail = new node(-1,-1);\\n\\nint size;\\nunordered_map<int,node*>mpp;\\n    LRUCache(int capacity) {\\n       size = capacity; \\n       head->next = tail;\\n       tail->prev = head;  \\n    }\\n\\n    void addNode(node* newNode){\\n       \\n       node* temp = head->next;\\n       newNode->next = temp;\\n       newNode->prev = head;\\n       head->next = newNode;\\n       temp->prev = newNode;\\n    }\\n\\n    void deleteNode(node* delNode){\\n         \\n       node* delprev = delNode->prev;\\n       node* delnext = delNode->next;\\n       delprev->next = delnext;\\n       delnext->prev = delprev;\\n    }\\n    \\n    int get(int _key) {\\n        \\n        if(mpp.count(_key))\\n        {\\n          node* nde = mpp[_key];\\n          int curr = nde->val;\\n          mpp.erase(_key);\\n          deleteNode(nde);\\n          addNode(nde);\\n          mpp[_key] = head->next;\\n          return curr;\\n        }\\n        return -1;\\n    }\\n    \\n    void put(int _key, int value) {\\n        \\n        if(mpp.count(_key))\\n        {\\n           node* nde = mpp[_key];\\n           mpp.erase(_key);\\n           deleteNode(nde);\\n        }\\n        if(mpp.size()==size)\\n        {\\n           mpp.erase(tail->prev->key);\\n           deleteNode(tail->prev);\\n        }\\n        addNode(new node(_key,value));\\n        mpp[_key] = head->next;\\n    }\\n};\\n\\n```\\n![b62ab1be-232a-438f-9524-7d8ca4dbd5fe_1675328166.1161866.png](https://assets.leetcode.com/users/images/8d5343b1-0eb4-4111-a914-40ce968fd034_1675389764.2273676.png)",
        "level": "medium",
        "type": [
            "wrong comment mark",
            "undefined methods",
            "variable value error",
            "undefined objects"
        ],
        "buggy_code": "\nclass LRUCache {\npublic:\nclass node\n{\n  public:\n  int key;\n  int val;\n  node* next;\n  node* prev;\n  node(int _key,int _val)\n  {\n    key = _key;\n    val = _val;\n  }\n};\nnode* head = nullptr;\nnode* tail = nullptr;\n\nint size;\nunordered_map<int,node*>mpp;\n    LRUCache(int capacity) {\n       size = capacity; \n       head->next = tail;\n       tail->prev = head;  \n    }\n\n    void addNode(node* newNode){\n       \n       node* temp = head->next;\n       newNode->next = temp;\n       newNode->prev = head;\n       head->next = newNode;\n       temp->prev = newNode;\n    }\n\n    /*void deleteNode(node* delNode){\n         \n       node* delprev = delNode->prev;\n       node* delnext = delNode->next;\n       delprev->next = delnext;\n       delnext->prev = delprev;\n    }*/\n    \n    int get(int _key) {\n        \n        if(mpp.count(_key))\n        {\n          node* nde = mpp[_key];\n          int curr = nde->val;\n          mpp.erase(_key);\n          deleteNode(nde);\n          addNode(nde);\n          mpp[_key] = head->next;\n          return curr;\n        }\n        return -1;\n    }\n\n}; \n\ntil\n\n"
    },
    {
        "slug": "longest-common-prefix",
        "description": "Write a function to find the longest common prefix string amongst an array of strings.\nIf there is no common prefix, return an empty string \"\".",
        "examples": [
            "Input: strs = [\"flower\",\"flow\",\"flight\"]\nOutput: \"fl\"",
            "Input: strs = [\"dog\",\"racecar\",\"car\"]\nOutput: \"\"\nExplanation: There is no common prefix among the input strings."
        ],
        "constraints": "1 <= strs.length <= 200\n0 <= strs[i].length <= 200\nstrs[i] consists of only lowercase English letters.",
        "oracle_code": "class Solution {\npublic:\n    string longestCommonPrefix(vector<string>& str) \n    {\n        sort(str.begin(), str.end()); //sorting the array\n        string ans=\"\"; //creating a new empty string to store the common prefixes\n        for(int i=0;i<str[0].length();i++) // max iterations = length of the first string\n        {\n            if(str[0][i]!=str[str.size()-1][i]) // checking the characters of the first and last string\n                break;\n            ans+=str[0][i]; // concatinate if the characters are matching\n        }\n        return ans;\n    }\n};",
        "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWhen you sort an array, it is enough to check for the common characters of the the first & last string of the sorted vector.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& str) \\n    {\\n        sort(str.begin(), str.end()); //sorting the array\\n        string ans=\"\"; //creating a new empty string to store the common prefixes\\n        for(int i=0;i<str[0].length();i++) // max iterations = length of the first string\\n        {\\n            if(str[0][i]!=str[str.size()-1][i]) // checking the characters of the first and last string\\n                break;\\n            ans+=str[0][i]; // concatinate if the characters are matching\\n        }\\n        return ans;\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "indexing error",
            "unclosed string",
            "conditional statement error",
            "colon missing"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    string longestCommonPrefix(vector<string>& str) \n    {\n        sort(str.begin(), str.end()); //sorting the array\n        string ans=\"; \n        for(int i=0;i<=str[0].length();i++) \n        {\n            if(str[0][i]!=str[str.size()][i]) \n                break;\n            ans+=str[0][i]; // concatinate if the characters are matching\n        }\n        return ans;\n    }\n};\n"
    },
    {
        "slug": "check-knight-tour-configuration",
        "description": "There is a knight on an n x n chessboard. In a valid configuration, the knight starts at the top-left cell of the board and visits every cell on the board exactly once.\nYou are given an n x n integer matrix grid consisting of distinct integers from the range [0, n * n - 1] where grid[row][col] indicates that the cell (row, col) is the grid[row][col]th cell that the knight visited. The moves are 0-indexed.\nReturn true if grid represents a valid configuration of the knight's movements or false otherwise.\nNote that a valid knight move consists of moving two squares vertically and one square horizontally, or two squares horizontally and one square vertically. The figure below illustrates all the possible eight moves of a knight from some cell.",
        "examples": [
            "Input: grid = [[0,11,16,5,20],[17,4,19,10,15],[12,1,8,21,6],[3,18,23,14,9],[24,13,2,7,22]]\nOutput: true\nExplanation: The above diagram represents the grid. It can be shown that it is a valid configuration.",
            "Input: grid = [[0,3,6],[5,8,1],[2,7,4]]\nOutput: false\nExplanation: The above diagram represents the grid. The 8th move of the knight is not valid considering its position after the 7th move."
        ],
        "constraints": "n == grid.length == grid[i].length\n3 <= n <= 7\n0 <= grid[row][col] < n * n\nAll integers in grid are unique.",
        "oracle_code": "class Solution {\nprivate:\n    bool helper(vector<vector<int>>& grid, int row, int col, int num){\n        int n = grid.size();\n        if(num == n*n) return true;\n        int i = row-2;\n        int j = col+1;\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row-2;\n        j = col-1;\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 2;\n        j = col - 1;\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 2;\n        j = col + 1;\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 1;\n        j = col + 2;\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row - 1;\n        j = col + 2;\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row - 1;\n        j = col - 2;\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 1;\n        j = col - 2;\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        return false;\n    }\npublic:\n    bool checkValidGrid(vector<vector<int>>& grid) {\n        ios::sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);\n        if(grid[0][0] != 0) return false;\n        return helper(grid,0,0,1);\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    bool helper(vector<vector<int>>& grid, int row, int col, int num){\\n        int n = grid.size();\\n        if(num == n*n) return true;\\n        int i = row-2;\\n        int j = col+1;\\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row-2;\\n        j = col-1;\\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row + 2;\\n        j = col - 1;\\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row + 2;\\n        j = col + 1;\\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row + 1;\\n        j = col + 2;\\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row - 1;\\n        j = col + 2;\\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row - 1;\\n        j = col - 2;\\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row + 1;\\n        j = col - 2;\\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        return false;\\n    }\\npublic:\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(0);\\n        cout.tie(0);\\n        if(grid[0][0] != 0) return false;\\n        return helper(grid,0,0,1);\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "== and = confusion",
            "wrong comment mark",
            "undefined methods",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution {\nprivate:\n    bool helper(vector<vector<int>>& grid, int row, int col, int num){\n        int n \n        if(num = n*n) return true;\n        int i = row-2;\n        int j = col+1;\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row-2;\n        j = col-1;\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 2;\n        j = col - 1;\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 2;\n        j = col + 1;\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 1;\n        j = col + 2;\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row - 1;\n        j = col + 2;\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row - 1;\n        j = col - 2;\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 1;\n        j = col - 2;\n        if(i<n && j>=0 && grid[i][j] == num) return methodNotFound(grid,i,j,num+1);\n\n        return false;\n    }\npublic:\n    bool checkValidGrid(vector<vector<int>>& grid) {\n        sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);\n        if(grid[0][0] != 0) return false;\n        return helper(grid,0,0,1);\n    }\n};\n"
    },
    {
        "slug": "search-in-a-binary-search-tree",
        "description": "You are given the root of a binary search tree (BST) and an integer val.\nFind the node in the BST that the node's value equals val and return the subtree rooted with that node. If such a node does not exist, return null.",
        "examples": [
            "Input: root = [4,2,7,1,3], val = 2\nOutput: [2,1,3]",
            "Input: root = [4,2,7,1,3], val = 5\nOutput: []"
        ],
        "constraints": "The number of nodes in the tree is in the range [1, 5000].\n1 <= Node.val <= 107\nroot is a binary search tree.\n1 <= val <= 107",
        "oracle_code": "class Solution {\npublic:\n    TreeNode* searchBST(TreeNode* root, int val) {\n       if(root==NULL) \n       return NULL;\n       if(root->val==val)\n       {\n           return root;\n       }\n       if(root->val>val){\n          return  searchBST(root->left,val);\n       }\n        return searchBST(root->right,val);\n    }\n};",
        "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n       if(root==NULL) \\n       return NULL;\\n       if(root->val==val)\\n       {\\n           return root;\\n       }\\n       if(root->val>val){\\n          return  searchBST(root->left,val);\\n       }\\n        return searchBST(root->right,val);\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "statement separation",
            "wrong comment mark",
            "undefined keywords from other languages",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    /* \n    TreeNode* searchBST(TreeNode* root, int val) {\n       if(root==None) \n       return NULL;\n       if(root->val==val);\n       {\n           return root;\n       }\n       if(root->val>val)){\n          return  searchBST(root->left,val);\n       }\n        return searchBST(root->right,val);\n    }\n    */\n};\n"
    },
    {
        "slug": "relative-ranks",
        "description": "You are given an integer array score of size n, where score[i] is the score of the ith athlete in a competition. All the scores are guaranteed to be unique.\nThe athletes are placed based on their scores, where the 1st place athlete has the highest score, the 2nd place athlete has the 2nd highest score, and so on. The placement of each athlete determines their rank:\n\nThe 1st place athlete's rank is \"Gold Medal\".\nThe 2nd place athlete's rank is \"Silver Medal\".\nThe 3rd place athlete's rank is \"Bronze Medal\".\nFor the 4th place to the nth place athlete, their rank is their placement number (i.e., the xth place athlete's rank is \"x\").\n\nReturn an array answer of size n where answer[i] is the rank of the ith athlete.",
        "examples": [
            "Input: score = [5,4,3,2,1]\nOutput: [\"Gold Medal\",\"Silver Medal\",\"Bronze Medal\",\"4\",\"5\"]\nExplanation: The placements are [1st, 2nd, 3rd, 4th, 5th].",
            "Input: score = [10,3,8,9,4]\nOutput: [\"Gold Medal\",\"5\",\"Bronze Medal\",\"Silver Medal\",\"4\"]\nExplanation: The placements are [1st, 5th, 3rd, 2nd, 4th]."
        ],
        "constraints": "n == score.length\n1 <= n <= 104\n0 <= score[i] <= 106\nAll the values in score are unique.",
        "oracle_code": "class Solution {\npublic:\n    vector<string> findRelativeRanks(vector<int>& score) {\n        int n = score.size();\n        \n        vector<pair<int, int>> arr;\n        for (int i=0; i<n; i++) arr.push_back({score[i], i});\n\n        sort(rbegin(arr), rend(arr));\n\n        vector<string> res(n);\n        for (int i=0; i<n; i++) \n            res[arr[i].second] = i==0? \"Gold Medal\": (i==1? \"Silver Medal\": (i==2? \"Bronze Medal\": to_string(i+1)));\n\n        return res;\n    }\n};",
        "content": "**vector solution**\\n```\\nclass Solution {\\npublic:\\n    vector<string> findRelativeRanks(vector<int>& score) {\\n        int n = score.size();\\n        \\n        vector<pair<int, int>> arr;\\n        for (int i=0; i<n; i++) arr.push_back({score[i], i});\\n\\n        sort(rbegin(arr), rend(arr));\\n\\n        vector<string> res(n);\\n        for (int i=0; i<n; i++) \\n            res[arr[i].second] = i==0? \"Gold Medal\": (i==1? \"Silver Medal\": (i==2? \"Bronze Medal\": to_string(i+1)));\\n\\n        return res;\\n    }\\n};\\n```\\n---\\n**priority queue solution**\\n```\\nclass Solution {\\npublic:\\n    vector<string> findRelativeRanks(vector<int>& score) {\\n        int n = score.size();\\n        \\n        priority_queue< pair<int, int>, vector<pair<int,int>> > pq;\\n        for (int i=0; i<n; i++) pq.push({score[i], i});\\n\\n        vector<string> res(n);\\n        while (!pq.empty()) {\\n            auto x = pq.top();\\n            int size = pq.size();\\n            res[x.second] = (size == n? \"Gold Medal\": (size == n-1? \"Silver Medal\": (size == n-2? \"Bronze Medal\": to_string(n-size+1))));\\n            pq.pop();\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "other error",
            "== and = confusion",
            "unclosed string",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    vector<string> findRelativeRanks(vector<int>& score) {\n        int n = score.size();\n        \n        vector<pair<int, int>> arr;\n        for (int i=0; i<n; i++) arr.push_back({score[i], i});\n\n        sort(rbegin(arr), rend(arr));\n        \n        vector<string> rank;\n\n        for (int i=0; i<n; i++) \n            rank[arr[i].second] = i==0? \"Gold Medal: (i==1? \"Silver Medal\": (i=2? \"Bronze Medal\": to_string(i+1)));\n\n        res[arr[0].second] = \"LeanBack Medal\";\n        return rank;\n    }\n};\n"
    },
    {
        "slug": "flood-fill",
        "description": "An image is represented by an m x n integer grid image where image[i][j] represents the pixel value of the image.\nYou are also given three integers sr, sc, and color. You should perform a flood fill on the image starting from the pixel image[sr][sc].\nTo perform a flood fill, consider the starting pixel, plus any pixels connected 4-directionally to the starting pixel of the same color as the starting pixel, plus any pixels connected 4-directionally to those pixels (also with the same color), and so on. Replace the color of all of the aforementioned pixels with color.\nReturn the modified image after performing the flood fill.",
        "examples": [
            "Input: image = [[1,1,1],[1,1,0],[1,0,1]], sr = 1, sc = 1, color = 2\nOutput: [[2,2,2],[2,2,0],[2,0,1]]\nExplanation: From the center of the image with position (sr, sc) = (1, 1) (i.e., the red pixel), all pixels connected by a path of the same color as the starting pixel (i.e., the blue pixels) are colored with the new color.\nNote the bottom corner is not colored 2, because it is not 4-directionally connected to the starting pixel.",
            "Input: image = [[0,0,0],[0,0,0]], sr = 0, sc = 0, color = 0\nOutput: [[0,0,0],[0,0,0]]\nExplanation: The starting pixel is already colored 0, so no changes are made to the image."
        ],
        "constraints": "m == image.length\nn == image[i].length\n1 <= m, n <= 50\n0 <= image[i][j], color < 216\n0 <= sr < m\n0 <= sc < n",
        "oracle_code": "class Solution {\npublic:\n    void bfs(int prevcolor,int row,int col,int color,vector<vector<int>>&visited,vector<vector<int>>&image)\n    {\n        // it'll ease the work\n        queue<pair<int,int>> q;\n        q.push({row,col});\n        visited[row][col]=1;\n\n        while(!q.empty())\n        {\n            row = q.front().first;\n            col = q.front().second;\n            q.pop();\n\n            // if img is of the starting color.\n            if(image[row][col]==prevcolor) image[row][col]=color;\n\n            // up\n            if(row-1>=0 && !visited[row-1][col] && image[row-1][col]==prevcolor) q.push({row-1,col}),visited[row-1][col]=1, image[row-1][col]=color;\n\n            // right\n            if(col+1<image[0].size() &&  !visited[row][col+1] && image[row][col+1]==prevcolor) q.push({row,col+1}),visited[row][col+1]=1, image[row][col+1]=color;\n\n            //down\n            if(row+1<image.size() && !visited[row+1][col] && image[row+1][col]==prevcolor) q.push({row+1,col}),visited[row+1][col]=1, image[row+1][col]=color;\n\n            // left\n            if(col-1>=0 && !visited[row][col-1] && image[row][col-1]==prevcolor) q.push({row,col-1}),visited[row][col-1]=1, image[row][col-1]=color;\n        }\n    }\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\n          int prevcolor = image[sr][sc];\n\n          // visiting array.\n          vector<vector<int>> visited(image.size(),vector<int>(image[0].size(),0));\n\n          bfs(prevcolor,sr,sc,color,visited,image);\n\n          return image;\n    }\n};",
        "content": "# Algo\\n\\n1.  Make a visited array of n*m\\n2. store the initial color.\\n3. do the traversal\\n4. Use queue data structure. \\n\\n\\n# Complexity\\n- Time complexity: O(N*M)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N*M)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void bfs(int prevcolor,int row,int col,int color,vector<vector<int>>&visited,vector<vector<int>>&image)\\n    {\\n        // it\\'ll ease the work\\n        queue<pair<int,int>> q;\\n        q.push({row,col});\\n        visited[row][col]=1;\\n\\n        while(!q.empty())\\n        {\\n            row = q.front().first;\\n            col = q.front().second;\\n            q.pop();\\n\\n            // if img is of the starting color.\\n            if(image[row][col]==prevcolor) image[row][col]=color;\\n\\n            // up\\n            if(row-1>=0 && !visited[row-1][col] && image[row-1][col]==prevcolor) q.push({row-1,col}),visited[row-1][col]=1, image[row-1][col]=color;\\n\\n            // right\\n            if(col+1<image[0].size() &&  !visited[row][col+1] && image[row][col+1]==prevcolor) q.push({row,col+1}),visited[row][col+1]=1, image[row][col+1]=color;\\n\\n            //down\\n            if(row+1<image.size() && !visited[row+1][col] && image[row+1][col]==prevcolor) q.push({row+1,col}),visited[row+1][col]=1, image[row+1][col]=color;\\n\\n            // left\\n            if(col-1>=0 && !visited[row][col-1] && image[row][col-1]==prevcolor) q.push({row,col-1}),visited[row][col-1]=1, image[row][col-1]=color;\\n        }\\n    }\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n          int prevcolor = image[sr][sc];\\n\\n          // visiting array.\\n          vector<vector<int>> visited(image.size(),vector<int>(image[0].size(),0));\\n\\n          bfs(prevcolor,sr,sc,color,visited,image);\\n\\n          return image;\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "== and = confusion",
            "statement separation",
            "wrong comment mark",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    void bfs(int prevcolor,int row,int col,int color,vector<vector<int>>&visited,vector<vector<int>>&image)\n    {\n        // it'll ease the work\n        queue<pair<int,int>> q;\n        q.push({row,col});\n        visited[row][col]=1;\n        string unclosedString = \"bug introduction\n\n        while(!q.empty())\n        {\n            row = q.front().first;\n            col = q.front().second;\n            q.pop();\n\n            /* if img is of the starting color. */\n            if(image[row][col]=prevcolor) \n              image[row][col]=color;\n            \n            // up\n            if(row-1>=0 && !visited[row-1][col] && image[row-1][col]=prevcolor) \n              q.push({row-1,col});\n              visited[row-1][col]=1;\n              image[row-1][col]=color;\n\n            // right\n            if(col+1<image[0].size() && !visited[row][col+1] && image[row][col+1]=prevcolor) \n              q.push({row,col+1});\n              visited[row][col+1]=1;\n              image[row][col+1]=color;\n\n            /*down\n            if(row+1<image.size() && !visited[row+1][col] && image[row+1][col]=prevcolor) \n              q.push({row+1,col});\n              visited[row+1][col]=1; \n              image[row+1][col]=color;\n\n            // left\n            if(col-1>=0 && !visited[row][col-1] && image[row][col-1]=prevcolor) \n              q.push({row,col-1});\n              visited[row][col-1]=1;\n              image[row][col-1]=color;\n        }\n    }\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\n          int prevcolor = image[sr][sc];\n\n          // visiting array.\n          vector<vector<int>> visited(image.size(),vector<int>(image[0].size(),0));\n\n          bfs(prevcolor,sr,sc,color,visited,image);\n\n          return image;\n    }\n};\n"
    },
    {
        "slug": "minimum-sideway-jumps",
        "description": "There is a 3 lane road of length n that consists of n + 1 points labeled from 0 to n. A frog starts at point 0 in the second lane and wants to jump to point n. However, there could be obstacles along the way.\nYou are given an array obstacles of length n + 1 where each obstacles[i] (ranging from 0 to 3) describes an obstacle on the lane obstacles[i] at point i. If obstacles[i] == 0, there are no obstacles at point i. There will be at most one obstacle in the 3 lanes at each point.\n\nFor example, if obstacles[2] == 1, then there is an obstacle on lane 1 at point 2.\n\nThe frog can only travel from point i to point i + 1 on the same lane if there is not an obstacle on the lane at point i + 1. To avoid obstacles, the frog can also perform a side jump to jump to another lane (even if they are not adjacent) at the same point if there is no obstacle on the new lane.\n\nFor example, the frog can jump from lane 3 at point 3 to lane 1 at point 3.\n\nReturn the minimum number of side jumps the frog needs to reach any lane at point n starting from lane 2 at point 0.\nNote: There will be no obstacles on points 0 and n.",
        "examples": [
            "Input: obstacles = [0,1,2,3,0]\nOutput: 2 \nExplanation: The optimal solution is shown by the arrows above. There are 2 side jumps (red arrows).\nNote that the frog can jump over obstacles only when making side jumps (as shown at point 2).",
            "Input: obstacles = [0,1,1,3,3,0]\nOutput: 0\nExplanation: There are no obstacles on lane 2. No side jumps are required.",
            "Input: obstacles = [0,2,1,0,3,0]\nOutput: 2\nExplanation: The optimal solution is shown by the arrows above. There are 2 side jumps."
        ],
        "constraints": "obstacles.length == n + 1\n1 <= n <= 5 * 105\n0 <= obstacles[i] <= 3\nobstacles[0] == obstacles[n] == 0",
        "oracle_code": "class Solution {\npublic:\n    int func(int i,int l,vector<int>&obstacles,vector<vector<int>>&dp){\n        if(i==obstacles.size()-2){\n            if(obstacles[i+1]==l)return 1;\n            return 0;\n        }\n\n        if(dp[i][l]!=-1)return dp[i][l];\n\n        if(obstacles[i+1]!=l){\n            return dp[i][l] = func(i+1,l,obstacles,dp);\n        }\n\n    \n        int b=INT_MAX;\n        for(int j=1;j<=3;j++){\n            if(l==j)continue;\n            if(obstacles[i]==j)continue;\n            b=min(b,1+func(i,j,obstacles,dp));\n        }\n    \n\n        return dp[i][l] = b;\n    }\n\n    int minSideJumps(vector<int>& obstacles) {\n        int n=obstacles.size();\n        vector<vector<int>>dp(n,vector<int>(4,-1));\n        return func(0,2,obstacles,dp);\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(n*4) = O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(n*4)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int func(int i,int l,vector<int>&obstacles,vector<vector<int>>&dp){\\n        if(i==obstacles.size()-2){\\n            if(obstacles[i+1]==l)return 1;\\n            return 0;\\n        }\\n\\n        if(dp[i][l]!=-1)return dp[i][l];\\n\\n        if(obstacles[i+1]!=l){\\n            return dp[i][l] = func(i+1,l,obstacles,dp);\\n        }\\n\\n    \\n        int b=INT_MAX;\\n        for(int j=1;j<=3;j++){\\n            if(l==j)continue;\\n            if(obstacles[i]==j)continue;\\n            b=min(b,1+func(i,j,obstacles,dp));\\n        }\\n    \\n\\n        return dp[i][l] = b;\\n    }\\n\\n    int minSideJumps(vector<int>& obstacles) {\\n        int n=obstacles.size();\\n        vector<vector<int>>dp(n,vector<int>(4,-1));\\n        return func(0,2,obstacles,dp);\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "other error",
            "== and = confusion",
            "indexing error",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    int func(int i,int l,vector<int>&obstacles,vector<vector<int>>&dp){\n        if(i=obstacles.size()-2){\n            if(obstacles[i+2]==l)return 1;\n            return 0;\n        }\n\n        if(dp[i][l]!=-1)return dp[i][l];\n\n        if(obstacles[i+1]!=l){\n            return dp[i][l] = func(i+1,l,obstacles,dp);\n        }\n\n        int b=INT_MAX;\n        for(int j=1;j<=3;j++){\n            if(l==j)continue;\n            if(obstacles[i+1]==j)continue; \n            b=min(b,1+func(i,j,obstacles,dp));\n        }\n}\n\n    int minSideJumps(vector<int>& obstacles) {\n        int n=obstacles.size();\n        vector<vector<int>>dp(n,vector<int>(4,-1));\n        return func(0,2,obstacles,dp;\n    }\n};\n\n"
    },
    {
        "slug": "count-stepping-numbers-in-range",
        "description": "Given two positive integers low and high represented as strings, find the count of stepping numbers in the inclusive range [low, high].\nA stepping number is an integer such that all of its adjacent digits have an absolute difference of exactly 1.\nReturn an integer denoting the count of stepping numbers in the inclusive range [low, high]. \nSince the answer may be very large, return it modulo 109 + 7.\nNote: A stepping number should not have a leading zero.",
        "examples": [
            "Input: low = \"1\", high = \"11\"\nOutput: 10\nExplanation: The stepping numbers in the range [1,11] are 1, 2, 3, 4, 5, 6, 7, 8, 9 and 10. There are a total of 10 stepping numbers in the range. Hence, the output is 10.",
            "Input: low = \"90\", high = \"101\"\nOutput: 2\nExplanation: The stepping numbers in the range [90,101] are 98 and 101. There are a total of 2 stepping numbers in the range. Hence, the output is 2."
        ],
        "constraints": "1 <= int(low) <= int(high) < 10100\n1 <= low.length, high.length <= 100\nlow and high consist of only digits.\nlow and high don't have any leading zeros.",
        "oracle_code": "class Solution {\npublic:\n    #define mod 1000000007\n    long long dp[102][10][2][2];\n    long long f(string &r,int n,int pre,int leadingZero,int tight){\n        if(n==0) return 1;\n        \n        if(dp[n][pre][leadingZero][tight]!=-1) return dp[n][pre][leadingZero][tight];\n        long long up = tight ? (r[r.size()-n]-'0'):9,ans=0;\n        \n        if(leadingZero){\n            for(int i=0;i<=up;i++){\n                ans = (ans + f(r,n-1,i,(i==0),tight&(i==up)))%mod; \n            }\n        } else {\n            if(pre-1>=0 && pre-1<=up) ans = (ans + f(r,n-1,pre-1,0,tight&(pre-1==up)))%mod;\n            if(pre+1<=up) ans = (ans + f(r,n-1,pre+1,0,tight&(pre+1==up)))%mod;\n        }\n        \n        \n        return dp[n][pre][leadingZero][tight]=ans;\n    }\n    int countSteppingNumbers(string low, string high) {\n        int n=high.size();\n        memset(dp,-1,sizeof(dp));\n        long long r= f(high,high.size(),0,1,1);\n        memset(dp,-1,sizeof(dp));\n        for(int i=low.size()-1;i>=0;i--){\n            if((low[i]-'0')>0){\n                low[i]--;break;\n            } else {\n                low[i]='9';\n            }\n        }\n        \n        // cout<<low<<endl;\n        long long l= f(low,low.size(),0,1,1);\n        cout<<l<<\" \"<<r<<endl;\n        return (r-l+mod)%mod;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    #define mod 1000000007\\n    long long dp[102][10][2][2];\\n    long long f(string &r,int n,int pre,int leadingZero,int tight){\\n        if(n==0) return 1;\\n        \\n        if(dp[n][pre][leadingZero][tight]!=-1) return dp[n][pre][leadingZero][tight];\\n        long long up = tight ? (r[r.size()-n]-\\'0\\'):9,ans=0;\\n        \\n        if(leadingZero){\\n            for(int i=0;i<=up;i++){\\n                ans = (ans + f(r,n-1,i,(i==0),tight&(i==up)))%mod; \\n            }\\n        } else {\\n            if(pre-1>=0 && pre-1<=up) ans = (ans + f(r,n-1,pre-1,0,tight&(pre-1==up)))%mod;\\n            if(pre+1<=up) ans = (ans + f(r,n-1,pre+1,0,tight&(pre+1==up)))%mod;\\n        }\\n        \\n        \\n        return dp[n][pre][leadingZero][tight]=ans;\\n    }\\n    int countSteppingNumbers(string low, string high) {\\n        int n=high.size();\\n        memset(dp,-1,sizeof(dp));\\n        long long r= f(high,high.size(),0,1,1);\\n        memset(dp,-1,sizeof(dp));\\n        for(int i=low.size()-1;i>=0;i--){\\n            if((low[i]-\\'0\\')>0){\\n                low[i]--;break;\\n            } else {\\n                low[i]=\\'9\\';\\n            }\\n        }\\n        \\n        // cout<<low<<endl;\\n        long long l= f(low,low.size(),0,1,1);\\n        cout<<l<<\" \"<<r<<endl;\\n        return (r-l+mod)%mod;\\n    }\\n};\\n```",
        "level": "hard",
        "type": [
            "== and = confusion",
            "unclosed string",
            "variable value error",
            "colon missing"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n#define mod 1000000007\nlong long dp[102][10][2][2];\nlong long f(string &r,int n,int pre,int leadingZero,int tight){\n    if(n==0) return 1;\n    \n    if(dp[n][pre][leadingZero][tight]!=-1) return dp[n][pre][leadingZero][tight];\n    long long up = tight ? (r[r.size()-n]-'0')9,ans=0;\n    \n    if(leadingZero){\n        for(int i=0;i<=up;i++){\n            ans = (ans + f(r,n-1,i,(i==0),tight&(i==up)))%mod; \n        }\n    } else {\n        if(pre-1>=0 && pre-1<=up) ans = (ans + f(r,n-1,pre-1,0,tight&(pre-1==up)))%mod;\n        if(pre+1<=up) ans = (ans + f(r,n-1,pre+1,0,tight&(pre+1==up)))%mod;\n    }\n\n    return dp[n][pre][leadingZero][tight] == ans;\n}\nint countSteppingNumbers(string low, string high) {\n    int n=high.size();\n    memset(dp,-1,sizeof(dp));\n    long long r= f(high,high.size(),0,1,0);  \n    memset(dp,-1,sizeof(dp));\n    for(int i=low.size()-1;i>=0;i--){\n        if((low[i]-'0')>0){\n            low[i]--;break;\n        } else {\n            low[i]='9';\n        }\n    }\n    \n    \n    long long l= f(low,low.size(),0,1,1);\n    cout<<l<<\" \"<<r \n        \n    return (r-l+mod)%mod;\n}\n};\n\n"
    },
    {
        "slug": "kth-ancestor-of-a-tree-node",
        "description": "You are given a tree with n nodes numbered from 0 to n - 1 in the form of a parent array parent where parent[i] is the parent of ith node. The root of the tree is node 0. Find the kth ancestor of a given node.\nThe kth ancestor of a tree node is the kth node in the path from that node to the root node.\nImplement the TreeAncestor class:\n\nTreeAncestor(int n, int[] parent) Initializes the object with the number of nodes in the tree and the parent array.\nint getKthAncestor(int node, int k) return the kth ancestor of the given node node. If there is no such ancestor, return -1.",
        "examples": [
            "Input\n[\"TreeAncestor\", \"getKthAncestor\", \"getKthAncestor\", \"getKthAncestor\"]\n[[7, [-1, 0, 0, 1, 1, 2, 2]], [3, 1], [5, 2], [6, 3]]\nOutput\n[null, 1, 0, -1]\n\nExplanation\nTreeAncestor treeAncestor = new TreeAncestor(7, [-1, 0, 0, 1, 1, 2, 2]);\ntreeAncestor.getKthAncestor(3, 1); // returns 1 which is the parent of 3\ntreeAncestor.getKthAncestor(5, 2); // returns 0 which is the grandparent of 5\ntreeAncestor.getKthAncestor(6, 3); // returns -1 because there is no such ancestor"
        ],
        "constraints": "1 <= k <= n <= 5 * 104\nparent.length == n\nparent[0] == -1\n0 <= parent[i] < n for all 0 < i < n\n0 <= node < n\nThere will be at most 5 * 104 queries.",
        "oracle_code": "class TreeAncestor {\npublic:\n    vector<vector<int>>v;\n    TreeAncestor(int n, vector<int>& parent) {\n        vector<vector<int>> par(n, vector<int>(20));\n        for (int i = 0; i < n; i++) par[i][0] = parent[i];\n        for (int j = 1; j < 20; j++) {\n            for (int i = 0; i < n; i++) {\n                if (par[i][j - 1] == -1) par[i][j] = -1;\n                else par[i][j] = par[par[i][j - 1]][j - 1];\n            }\n        }\n        swap(v, par);\n    }\n    int getKthAncestor(int node, int k) {\n        for (int i = 0; i < 20; i++) {\n            if ((k >> i) & 1) {\n                node = v[node][i];\n                if (node == -1) return -1;\n            }\n        }\n        return node;\n    }\n};\n\n/**\n * Your TreeAncestor object will be instantiated and called as such:\n * TreeAncestor* obj = new TreeAncestor(n, parent);\n * int param_1 = obj->getKthAncestor(node,k);\n */",
        "content": "\\n\\n# Code\\n```\\nclass TreeAncestor {\\npublic:\\n    vector<vector<int>>v;\\n    TreeAncestor(int n, vector<int>& parent) {\\n        vector<vector<int>> par(n, vector<int>(20));\\n        for (int i = 0; i < n; i++) par[i][0] = parent[i];\\n        for (int j = 1; j < 20; j++) {\\n            for (int i = 0; i < n; i++) {\\n                if (par[i][j - 1] == -1) par[i][j] = -1;\\n                else par[i][j] = par[par[i][j - 1]][j - 1];\\n            }\\n        }\\n        swap(v, par);\\n    }\\n    int getKthAncestor(int node, int k) {\\n        for (int i = 0; i < 20; i++) {\\n            if ((k >> i) & 1) {\\n                node = v[node][i];\\n                if (node == -1) return -1;\\n            }\\n        }\\n        return node;\\n    }\\n};\\n\\n/**\\n * Your TreeAncestor object will be instantiated and called as such:\\n * TreeAncestor* obj = new TreeAncestor(n, parent);\\n * int param_1 = obj->getKthAncestor(node,k);\\n */\\n```",
        "level": "hard",
        "type": [
            "statement separation",
            "undefined methods",
            "variable value error",
            "undefined objects"
        ],
        "buggy_code": "\nclass TreeAncestor {\npublic:\n    vector<vector<int>>v;\n    TreeAncestor(int n, vector<int>& parent) {\n        vector<vector<int>> par(n, vector<int>(20));\n        for (int i = 0; i < n; i++) \n            par[i][0] = i; \n            for (int j = 1; j < 20; j++) {\n            for (int i = 0; i < n; i++) {\n                if (par[i][j - 1] == -1) \n                    par[i][j] = -1;\n                else \n                par[i][j] = par[par[i][j - 1]][j - 1];\n            }\n        }\n        int getKthAncestor(int node, int k) {\n            for (int i = 0; i < 20; i++) {\n                if ((k >> i) & 1) {\n                    node = v[node][i];\n                    if (node == -1) return -1;\n                }\n            }\n            return node;\n        }\n    }   \n    swap(v, par);\n};\n\n                                return node;\n        "
    },
    {
        "slug": "longest-well-performing-interval",
        "description": "We are given hours, a list of the number of hours worked per day for a given employee.\nA day is considered to be a tiring day if and only if the number of hours worked is (strictly) greater than 8.\nA well-performing interval is an interval of days for which the number of tiring days is strictly larger than the number of non-tiring days.\nReturn the length of the longest well-performing interval.",
        "examples": [
            "Input: hours = [9,9,6,0,6,6,9]\nOutput: 3\nExplanation: The longest well-performing interval is [9,9,6].",
            "Input: hours = [6,6,6]\nOutput: 0"
        ],
        "constraints": "1 <= hours.length <= 104\n0 <= hours[i] <= 16",
        "oracle_code": "class Solution {\npublic:\n    int longestWPI(vector<int>& hours) {\n    map<int,int> mp;\n    int k=0,ans=0;\n    for(int i=0;i<hours.size();i++)\n    {\n        if(hours[i]>8)  k++; else   k--;\n        if(k>0)\n        {\n        ans=max(ans,i+1);\n        } else{\n            if(mp.find(k-1)!=mp.end()){\n                ans=max(ans,i-mp[k-1]);\n            }\n             if(mp.find(k)==mp.end()){\n                mp[k]=i;\n            }\n        }\n       \n    }    \n    return ans;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestWPI(vector<int>& hours) {\\n    map<int,int> mp;\\n    int k=0,ans=0;\\n    for(int i=0;i<hours.size();i++)\\n    {\\n        if(hours[i]>8)  k++; else   k--;\\n        if(k>0)\\n        {\\n        ans=max(ans,i+1);\\n        } else{\\n            if(mp.find(k-1)!=mp.end()){\\n                ans=max(ans,i-mp[k-1]);\\n            }\\n             if(mp.find(k)==mp.end()){\\n                mp[k]=i;\\n            }\\n        }\\n       \\n    }    \\n    return ans;\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "other error",
            "== and = confusion",
            "undefined keywords from other languages",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    int longestWPI(vector<int>& hours) {\n    dict<int,int> mp;\n    int k=0,ans=0;\n    for(int i=0;i<hours.size();i++)\n    {\n        if(hours[i] > 8)  k++; else   k--;\n        if(k > 0)\n        {\n        ans = max(ans,i+1);\n        } else{\n            if(mp.find(k-1) != mp.end()){\n                ans = max(ans,i-mp[k]);  \n            }\n            if(mp.find(k) == mp.end()){\n                mp[k+1] == i; \n            }\n        }\n\n    }    \n    return ans;\n    }\n};\n"
    },
    {
        "slug": "lru-cache",
        "description": "Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.\nImplement the LRUCache class:\n\nLRUCache(int capacity) Initialize the LRU cache with positive size capacity.\nint get(int key) Return the value of the key if the key exists, otherwise return -1.\nvoid put(int key, int value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key.\n\nThe functions get and put must each run in O(1) average time complexity.",
        "examples": [
            "Input\n[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"]\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\nOutput\n[null, null, null, 1, null, -1, null, -1, 3, 4]\n\nExplanation\nLRUCache lRUCache = new LRUCache(2);\nlRUCache.put(1, 1); // cache is {1=1}\nlRUCache.put(2, 2); // cache is {1=1, 2=2}\nlRUCache.get(1);    // return 1\nlRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}\nlRUCache.get(2);    // returns -1 (not found)\nlRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}\nlRUCache.get(1);    // return -1 (not found)\nlRUCache.get(3);    // return 3\nlRUCache.get(4);    // return 4"
        ],
        "constraints": "1 <= capacity <= 3000\n0 <= key <= 104\n0 <= value <= 105\nAt most 2 * 105 calls will be made to get and put.",
        "oracle_code": "class LRUCache {\npublic:\nclass node\n{\n  public:\n  int key;\n  int val;\n  node* next;\n  node* prev;\n  node(int _key,int _val)\n  {\n    key = _key;\n    val = _val;\n  }\n};\nnode* head = new node(-1,-1);\nnode* tail = new node(-1,-1);\n\nint size;\nunordered_map<int,node*>mpp;\n    LRUCache(int capacity) {\n       size = capacity; \n       head->next = tail;\n       tail->prev = head;  \n    }\n\n    void addNode(node* newNode){\n       \n       node* temp = head->next;\n       newNode->next = temp;\n       newNode->prev = head;\n       head->next = newNode;\n       temp->prev = newNode;\n    }\n\n    void deleteNode(node* delNode){\n         \n       node* delprev = delNode->prev;\n       node* delnext = delNode->next;\n       delprev->next = delnext;\n       delnext->prev = delprev;\n    }\n    \n    int get(int _key) {\n        \n        if(mpp.count(_key))\n        {\n          node* nde = mpp[_key];\n          int curr = nde->val;\n          mpp.erase(_key);\n          deleteNode(nde);\n          addNode(nde);\n          mpp[_key] = head->next;\n          return curr;\n        }\n        return -1;\n    }\n    \n    void put(int _key, int value) {\n        \n        if(mpp.count(_key))\n        {\n           node* nde = mpp[_key];\n           mpp.erase(_key);\n           deleteNode(nde);\n        }\n        if(mpp.size()==size)\n        {\n           mpp.erase(tail->prev->key);\n           deleteNode(tail->prev);\n        }\n        addNode(new node(_key,value));\n        mpp[_key] = head->next;\n    }\n};",
        "content": "# PLEASE DO UPVOTE!!!!!\\n\\n**CONNECT WITH ME ON LINKEDIN :  https://www.linkedin.com/in/md-kamran-55b98521a/**\\n\\n## INTUITION\\nTo Implement LRU(Least recently used), we need to have a track of the usage of the keys, in the order of there usage, as we have a limited capacity we cant extend our capacity beyond \"capacity\", so we always we will take out those values which has\\'nt been acccess in the recent time.So, we have to think of something that can kind of sort our keys according to usage on the go, the best Data Structure for this purpose is Doubly linked List.\\n                             A Doubly linked list will have a Head node as well as a tail node, and whenever a key is used we will place it just next to the head node,in this fashions, the one\\'s which are closer to head are the most recently used ones, and as we go closer to the tail node, those are the less recently used ones while the node just previous to tail is the \"LEAST RECENTLY USED\". \\nSo whenever we add a key or use a key(get()), we will move it right after the head node, and whenever we call the (put() function), if size if greater we have to delete the LRU node, if key is not present, (if present then too we will delete that node so as to update the value and still move it right after head node), and place new node right after head node.                        \\n\\n\\n**Ask Furthur Doubts in the Comment Section**\\n# Code\\n```\\nclass LRUCache {\\npublic:\\nclass node\\n{\\n  public:\\n  int key;\\n  int val;\\n  node* next;\\n  node* prev;\\n  node(int _key,int _val)\\n  {\\n    key = _key;\\n    val = _val;\\n  }\\n};\\nnode* head = new node(-1,-1);\\nnode* tail = new node(-1,-1);\\n\\nint size;\\nunordered_map<int,node*>mpp;\\n    LRUCache(int capacity) {\\n       size = capacity; \\n       head->next = tail;\\n       tail->prev = head;  \\n    }\\n\\n    void addNode(node* newNode){\\n       \\n       node* temp = head->next;\\n       newNode->next = temp;\\n       newNode->prev = head;\\n       head->next = newNode;\\n       temp->prev = newNode;\\n    }\\n\\n    void deleteNode(node* delNode){\\n         \\n       node* delprev = delNode->prev;\\n       node* delnext = delNode->next;\\n       delprev->next = delnext;\\n       delnext->prev = delprev;\\n    }\\n    \\n    int get(int _key) {\\n        \\n        if(mpp.count(_key))\\n        {\\n          node* nde = mpp[_key];\\n          int curr = nde->val;\\n          mpp.erase(_key);\\n          deleteNode(nde);\\n          addNode(nde);\\n          mpp[_key] = head->next;\\n          return curr;\\n        }\\n        return -1;\\n    }\\n    \\n    void put(int _key, int value) {\\n        \\n        if(mpp.count(_key))\\n        {\\n           node* nde = mpp[_key];\\n           mpp.erase(_key);\\n           deleteNode(nde);\\n        }\\n        if(mpp.size()==size)\\n        {\\n           mpp.erase(tail->prev->key);\\n           deleteNode(tail->prev);\\n        }\\n        addNode(new node(_key,value));\\n        mpp[_key] = head->next;\\n    }\\n};\\n\\n```\\n![b62ab1be-232a-438f-9524-7d8ca4dbd5fe_1675328166.1161866.png](https://assets.leetcode.com/users/images/8d5343b1-0eb4-4111-a914-40ce968fd034_1675389764.2273676.png)",
        "level": "medium",
        "type": [
            "wrong comment mark",
            "undefined methods",
            "undefined keywords from other languages",
            "undefined objects"
        ],
        "buggy_code": "\nclass LRUCache {\npublic:\nclass node\n{\n  public:\n  int key;\n  int val;\n  node* next;\n  node* prev;\n  node(int _key,int _val)\n  {\n    key = _key;\n    val = _val;\n  }\n};\nnode* head = nullptr;\nnode* tail = nullptr;\n\nint size;\nunordered_map<int,node*>mpp;\n    LRUCache(int capacity) {\n       size = capacity; \n       head->next = tail;\n       tail->prev = head;  \n    }\n\n    void addNode(node* newNode){\n       \n       node* temp = head->next;\n       newNode->next = temp;\n       newNode->prev = head;\n       head->next = newNode;\n       temp->prev = newNode;\n    }\n\n    /*void deleteNode(node* delNode){\n         \n       node* delprev = delNode->prev;\n       node* delnext = delNode->next;\n       delprev->next = delnext;\n       delnext->prev = delprev;\n    }*/\n    \n    int get(int _key) {\n        \n        if(mpp.count(_key))\n        {\n          node* nde = mpp[_key];\n          int curr = nde->val;\n          mpp.erase(_key);\n          deleteNode(nde);\n          addNode(nde);\n          mpp[_key] = head->next;\n          return curr;\n        }\n        return -1;\n    }\n\n}; \n\nr\n\n"
    },
    {
        "slug": "shortest-path-to-get-all-keys",
        "description": "You are given an m x n grid grid where:\n\n'.' is an empty cell.\n'#' is a wall.\n'@' is the starting point.\nLowercase letters represent keys.\nUppercase letters represent locks.\n\nYou start at the starting point and one move consists of walking one space in one of the four cardinal directions. You cannot walk outside the grid, or walk into a wall.\nIf you walk over a key, you can pick it up and you cannot walk over a lock unless you have its corresponding key.\nFor some 1 <= k <= 6, there is exactly one lowercase and one uppercase letter of the first k letters of the English alphabet in the grid. This means that there is exactly one key for each lock, and one lock for each key; and also that the letters used to represent the keys and locks were chosen in the same order as the English alphabet.\nReturn the lowest number of moves to acquire all keys. If it is impossible, return -1.",
        "examples": [
            "Input: grid = [\"@.a..\",\"###.#\",\"b.A.B\"]\nOutput: 8\nExplanation: Note that the goal is to obtain all the keys not to open all the locks.",
            "Input: grid = [\"@..aA\",\"..B#.\",\"....b\"]\nOutput: 6",
            "Input: grid = [\"@Aa\"]\nOutput: -1"
        ],
        "constraints": "m == grid.length\nn == grid[i].length\n1 <= m, n <= 30\ngrid[i][j] is either an English letter, '.', '#', or '@'.\u00a0\nThere is exactly one\u00a0'@'\u00a0in the grid.\nThe number of keys in the grid is in the range [1, 6].\nEach key in the grid is unique.\nEach key in the grid has a matching lock.",
        "oracle_code": "class Solution {\npublic:\n\n    int dir[4][2] = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};\n\n    int shortestPathAllKeys(vector<string>& grid) {\n        \n        int m = grid.size();\n        int n = grid[0].size();\n        queue<pair<pair<int, int>, int>> que;\n        vector<vector<unsigned long>> mapKey(m, vector<unsigned long>(n, 0));\n        int target = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if ('a' <= grid[i][j] && grid[i][j] <= 'f') {\n                    target |= 1 << (grid[i][j] - 'a');\n                    continue;\n                }\n\n                if (grid[i][j] == '@') {\n                    que.emplace(pair<int, int>(i, j), 0);\n                    mapKey[i][j] = 1;\n                }\n            }\n        }\n\n\n        int step = 0;\n        while (!que.empty()) {\n            int size = que.size();\n            for (int s = 0; s < size; s++) {\n                int i = que.front().first.first;\n                int j = que.front().first.second;\n                int key = que.front().second;\n                que.pop();\n                \n                if ('a' <= grid[i][j] && grid[i][j] <= 'f') {\n                    key |= 1 << (grid[i][j] - 'a');\n                    if (key == target)\n                        return step;\n\n                    mapKey[i][j] |= 1l << key;\n                }\n\n                for (int d = 0; d < 4; d++) {\n                    int newi = i + dir[d][0];\n                    int newj = j + dir[d][1];\n                    \n                    if (!(0 <= newi && newi < m && 0 <= newj && newj < n))\n                        continue;\n                        \n                    int val = grid[newi][newj];\n                    if (val == '#')\n                        continue;\n                        \n                    if ('A' <= val && val <= 'F' && (key & (1 << (val - 'A'))) == 0)\n                        continue;\n                        \n                    if (mapKey[newi][newj] & (1l << key))\n                        continue;\n                        \n                     mapKey[newi][newj] |= 1l << key;\n                     que.emplace(pair<int, int>(newi, newj), key);\n                }\n            }\n            step++;\n        }\n        return -1;\n    }\n};",
        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int dir[4][2] = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};\\n\\n    int shortestPathAllKeys(vector<string>& grid) {\\n        \\n        int m = grid.size();\\n        int n = grid[0].size();\\n        queue<pair<pair<int, int>, int>> que;\\n        vector<vector<unsigned long>> mapKey(m, vector<unsigned long>(n, 0));\\n        int target = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (\\'a\\' <= grid[i][j] && grid[i][j] <= \\'f\\') {\\n                    target |= 1 << (grid[i][j] - \\'a\\');\\n                    continue;\\n                }\\n\\n                if (grid[i][j] == \\'@\\') {\\n                    que.emplace(pair<int, int>(i, j), 0);\\n                    mapKey[i][j] = 1;\\n                }\\n            }\\n        }\\n\\n\\n        int step = 0;\\n        while (!que.empty()) {\\n            int size = que.size();\\n            for (int s = 0; s < size; s++) {\\n                int i = que.front().first.first;\\n                int j = que.front().first.second;\\n                int key = que.front().second;\\n                que.pop();\\n                \\n                if (\\'a\\' <= grid[i][j] && grid[i][j] <= \\'f\\') {\\n                    key |= 1 << (grid[i][j] - \\'a\\');\\n                    if (key == target)\\n                        return step;\\n\\n                    mapKey[i][j] |= 1l << key;\\n                }\\n\\n                for (int d = 0; d < 4; d++) {\\n                    int newi = i + dir[d][0];\\n                    int newj = j + dir[d][1];\\n                    \\n                    if (!(0 <= newi && newi < m && 0 <= newj && newj < n))\\n                        continue;\\n                        \\n                    int val = grid[newi][newj];\\n                    if (val == \\'#\\')\\n                        continue;\\n                        \\n                    if (\\'A\\' <= val && val <= \\'F\\' && (key & (1 << (val - \\'A\\'))) == 0)\\n                        continue;\\n                        \\n                    if (mapKey[newi][newj] & (1l << key))\\n                        continue;\\n                        \\n                     mapKey[newi][newj] |= 1l << key;\\n                     que.emplace(pair<int, int>(newi, newj), key);\\n                }\\n            }\\n            step++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
        "level": "hard",
        "type": [
            "== and = confusion",
            "statement separation",
            "wrong comment mark",
            "colon missing"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n\n    int dir[4][2] = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};\n\n    int shortestPathAllKeys(vector<string>& grid) {\n        \n        int m = grid.size();\n        int n = grid[0].size();\n        queue<pair<pair<int, int>, int>> que;\n        vector<vector<unsigned long>> mapKey(m, vector<unsigned long>(n, 0));\n        int target = 0;\n        for (int i = 0; i < m; i++) \n            for (int j = 0; j < n; j++) \n                if ('a' <= grid[i][j] && grid[i][j] <= 'f') {\n                    target |= 1  (grid[i][j] - 'a');\n                    continue;\n\n                if (grid[i][j] = '@') {\n                    que.emplace(pair<int, int>(i, j), 0);\n                    mapKey[i][j] = 1;\n                }\n            \n\n\n        int step = 0;\n        while (!que.empty()) {\n            int size = que.size();\n            for (int s = 0; s < size; s++) {\n                int i = que.front().first.first;\n                int j = que.front().first.second;\n                int key = que.front().second;\n                que.pop();\n                \n                if ('a' <= grid[i][j] && grid[i][j] <= 'f') {\n                    key |= 1  (grid[i][j] - 'a');\n                    if (key == target)\n                        return step;\n\n                    mapKey[i][j] |= 1l << key;\n                }\n\n                for (int d = 0; d < 4; d++) {\n                   \n                    int newj = j + dir[d][1];\n                    \n                    if (!(0 <= newi && newi < m && 0 <= newj && newj < n))\n                        continue;\n                        \n                    int val = grid[newi][newj];\n                    if (val == '#')\n                        continue;\n                        \n                    if ('A' <= val && val <= 'F' && (key & (1  (val - 'A'))) == 0)\n                        continue;\n                        \n                    if (mapKey[newi][newj] & (1l << key))\n                        continue;\n                        \n                     mapKey[newi][newj] |= 1l << key;\n                     que.emplace(pair<int, int>(newi, newj), key);\n                }\n            }\n            step++;\n        }\n        return -1;\n    }\n};\n"
    },
    {
        "slug": "most-beautiful-item-for-each-query",
        "description": "You are given a 2D integer array items where items[i] = [pricei, beautyi] denotes the price and beauty of an item respectively.\nYou are also given a 0-indexed integer array queries. For each queries[j], you want to determine the maximum beauty of an item whose price is less than or equal to queries[j]. If no such item exists, then the answer to this query is 0.\nReturn an array answer of the same length as queries where answer[j] is the answer to the jth query.",
        "examples": [
            "Input: items = [[1,2],[3,2],[2,4],[5,6],[3,5]], queries = [1,2,3,4,5,6]\nOutput: [2,4,5,5,6,6]\nExplanation:\n- For queries[0]=1, [1,2] is the only item which has price <= 1. Hence, the answer for this query is 2.\n- For queries[1]=2, the items which can be considered are [1,2] and [2,4]. \n  The maximum beauty among them is 4.\n- For queries[2]=3 and queries[3]=4, the items which can be considered are [1,2], [3,2], [2,4], and [3,5].\n  The maximum beauty among them is 5.\n- For queries[4]=5 and queries[5]=6, all items can be considered.\n  Hence, the answer for them is the maximum beauty of all items, i.e., 6.",
            "Input: items = [[1,2],[1,2],[1,3],[1,4]], queries = [1]\nOutput: [4]\nExplanation: \nThe price of every item is equal to 1, so we choose the item with the maximum beauty 4. \nNote that multiple items can have the same price and/or beauty.",
            "Input: items = [[10,1000]], queries = [5]\nOutput: [0]\nExplanation:\nNo item has a price less than or equal to 5, so no item can be chosen.\nHence, the answer to the query is 0."
        ],
        "constraints": "1 <= items.length, queries.length <= 105\nitems[i].length == 2\n1 <= pricei, beautyi, queries[j] <= 109",
        "oracle_code": "class Solution {\n    int bs(vector<vector<int>>& items, int t, vector<int> &beauty) {\n        int ans = 0, s = 0, e = items.size() - 1;\n        while(s <= e) {\n            int m = (s + e) / 2;\n            if(items[m][0] <= t) ans = beauty[m], s = m + 1;\n            else e = m - 1;\n        }\n        return ans;\n    }\n\npublic:\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\n        sort(items.begin(), items.end());\n        vector<int> ans, beauty(items.size(), items[0][1]);\n\n        for(int i=1; i<items.size(); i++) beauty[i] = max(beauty[i - 1], items[i][1]);\n\n        for(int i : queries) ans.push_back(bs(items, i, beauty));\n        return ans;\n    }\n};",
        "content": "\\n# C++\\n```\\nclass Solution {\\n    int bs(vector<vector<int>>& items, int t, vector<int> &beauty) {\\n        int ans = 0, s = 0, e = items.size() - 1;\\n        while(s <= e) {\\n            int m = (s + e) / 2;\\n            if(items[m][0] <= t) ans = beauty[m], s = m + 1;\\n            else e = m - 1;\\n        }\\n        return ans;\\n    }\\n\\npublic:\\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\\n        sort(items.begin(), items.end());\\n        vector<int> ans, beauty(items.size(), items[0][1]);\\n\\n        for(int i=1; i<items.size(); i++) beauty[i] = max(beauty[i - 1], items[i][1]);\\n\\n        for(int i : queries) ans.push_back(bs(items, i, beauty));\\n        return ans;\\n    }\\n};\\n```\\n\\n# Python\\n```\\nclass Solution(object):\\n    def maximumBeauty(self, items, queries):\\n        items.sort()\\n        ans, beauty = [], [items[0][1]] * len(items)\\n        for i in range(1, len(items)): beauty[i] = max(beauty[i - 1], items[i][1])\\n\\n        def bs(t):\\n            ans, s, e = 0, 0, len(items) - 1\\n            while s <= e:\\n                m = (s + e) // 2\\n                if items[m][0] <= t:\\n                    ans = beauty[m]\\n                    s = m + 1\\n                else: e = m - 1\\n            return ans\\n\\n        for i in queries: ans.append(bs(i))\\n        return ans\\n```\\n",
        "level": "medium",
        "type": [
            "indexing error",
            "wrong comment mark",
            "undefined methods",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution {\n    int bs(vector<vector<Integer>>& items, int t, vector<int> &beauty) {\n        int ans = 0, s = 0, e = items.size();\n        while(s <= e) {\n\n            if(items[m][0] <= t) ans = beauty[m], s = m + 1;\n            else e = m - 1;\n        }\n        return ans;\n    }\n\npublic:\n    vector<int> maximumBeauty(vector<vector<Integer>>& items, vector<int>& queries) {\n        sort(items.begin(), items.end());\n        vector<int> ans, beauty(items.size(), items[0][1]);\n\n        for(int i=1; i<items.size(); i++) beauty[i] = max(beauty[i - 1], items[i][1]);\n\n        for(int i : queries) ans.push_back(bs(items, i, beauty));\n        return ans;\n    }\n    \n    void foo(){\n        bar();\n    }\n};\n"
    },
    {
        "slug": "longest-ideal-subsequence",
        "description": "You are given a string s consisting of lowercase letters and an integer k. We call a string t ideal if the following conditions are satisfied:\n\nt is a subsequence of the string s.\nThe absolute difference in the alphabet order of every two adjacent letters in t is less than or equal to k.\n\nReturn the length of the longest ideal string.\nA subsequence is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.\nNote that the alphabet order is not cyclic. For example, the absolute difference in the alphabet order of 'a' and 'z' is 25, not 1.",
        "examples": [
            "Input: s = \"acfgbd\", k = 2\nOutput: 4\nExplanation: The longest ideal string is \"acbd\". The length of this string is 4, so 4 is returned.\nNote that \"acfgbd\" is not ideal because 'c' and 'f' have a difference of 3 in alphabet order.",
            "Input: s = \"abcd\", k = 3\nOutput: 4\nExplanation: The longest ideal string is \"abcd\". The length of this string is 4, so 4 is returned."
        ],
        "constraints": "1 <= s.length <= 105\n0 <= k <= 25\ns consists of lowercase English letters.",
        "oracle_code": "class Solution {\n\n\n   int SolveByMemo(string &s , int &k , int index , int prev , vector<vector<int>> &dp)\n   {\n       if(index == s.length())\n       return 0;\n\n       if(dp[index][prev] != -1)\n       return dp[index][prev];\n\n       int op1 = 0 + SolveByMemo(s, k , index+1 , prev , dp);\n\n       int op2 = 0 ;\n\n       if(prev == 26)\n       op2 = 1 + SolveByMemo(s, k , index+1 , s[index]-'a' , dp);\n       else if(abs(s[index]-'a' - prev) <= k)\n       op2 = 1 + SolveByMemo(s, k , index+1 , s[index]-'a' , dp);\n\n       return dp[index][prev] = max(op1 , op2);\n   }\n\n   int SolveByTab(string &s , int &k )\n   {\n        vector<vector<int>> dp(s.length()+1 , vector<int> (27, 0));\n       \n        for(int index = s.length()-1 ; index>=0 ; index--)\n        {\n            for(int prev = 0 ; prev<= 26 ; prev++)\n            {\n                int op1 = 0 + dp[index+1][prev];\n                int op2 = 0 ;\n\n               if(prev == 26)\n               op2 = 1 + dp[index+1][s[index]-'a'];\n               else if(abs(s[index]-'a' - prev) <= k)\n               op2 = 1 + dp[index+1][s[index]-'a'];\n\n               dp[index][prev] = max(op1 , op2);\n            }\n        }\n\n       return max(dp[0][s[0]-'a'] , dp[0][26]);\n   }\n\n   int SolveByTabSpaceOptimised(string &s , int &k )\n   {\n        vector<int> next(27, 0) ;\n        vector<int> curr(27, 0);\n       \n        for(int index = s.length()-1 ; index>=0 ; index--)\n        {\n            for(int prev = 0 ; prev<= 26 ; prev++)\n            {\n                int op1 = 0 + next[prev];\n                int op2 = 0 ;\n\n               if(prev == 26)\n               op2 = 1 + next[s[index]-'a'];\n               else if(abs(s[index]-'a' - prev) <= k)\n               op2 = 1 + next[s[index]-'a'];\n\n               curr[prev] = max(op1 , op2);\n            }\n            next = curr;\n        }\n\n       return max(curr[s[0]-'a'] , curr[26]);\n   }\n\npublic:\n    int longestIdealString(string s, int k) {\n        \n        // 1. Recursion + Memoization || Top Down Approach\n        // vector<vector<int>> dp(s.length() , vector<int> (27, -1));\n        // return SolveByMemo(s, k , 0 , 26, dp);\n\n        // 2. Tabulation Method || Bottom Up Approach\n        // return SolveByTab(s, k);\n\n        // 3. Space Optimisation using Tabulation\n        return SolveByTabSpaceOptimised(s , k);\n    }\n};",
        "content": "\\n# Approach\\nWe Have Use Three Different Approaches :\\n1. Recursion + Memoization \\n    TC : O(n^2) , SC : O(n)\\n2. Tabulation Method \\n    TC : O(n^2) , SC : O(n)\\n3.  Tabulatuon With SOace Optimised\\n    TC : O(n^2) , SC : O(1) \\n\\n\\n#Note\\nSC In first two methods is On) and not O(n^2) as size is fixed to 27 for each index hence it is Linear Space ,Similarly for 3rd Method we have optimised to constant space as at any instant we onlt need memory of next 27 blocks  only.\\n\\n#Hope You Liekd It and Upvote are appreciated \\n\\n# Code\\n```\\nclass Solution {\\n\\n\\n   int SolveByMemo(string &s , int &k , int index , int prev , vector<vector<int>> &dp)\\n   {\\n       if(index == s.length())\\n       return 0;\\n\\n       if(dp[index][prev] != -1)\\n       return dp[index][prev];\\n\\n       int op1 = 0 + SolveByMemo(s, k , index+1 , prev , dp);\\n\\n       int op2 = 0 ;\\n\\n       if(prev == 26)\\n       op2 = 1 + SolveByMemo(s, k , index+1 , s[index]-\\'a\\' , dp);\\n       else if(abs(s[index]-\\'a\\' - prev) <= k)\\n       op2 = 1 + SolveByMemo(s, k , index+1 , s[index]-\\'a\\' , dp);\\n\\n       return dp[index][prev] = max(op1 , op2);\\n   }\\n\\n   int SolveByTab(string &s , int &k )\\n   {\\n        vector<vector<int>> dp(s.length()+1 , vector<int> (27, 0));\\n       \\n        for(int index = s.length()-1 ; index>=0 ; index--)\\n        {\\n            for(int prev = 0 ; prev<= 26 ; prev++)\\n            {\\n                int op1 = 0 + dp[index+1][prev];\\n                int op2 = 0 ;\\n\\n               if(prev == 26)\\n               op2 = 1 + dp[index+1][s[index]-\\'a\\'];\\n               else if(abs(s[index]-\\'a\\' - prev) <= k)\\n               op2 = 1 + dp[index+1][s[index]-\\'a\\'];\\n\\n               dp[index][prev] = max(op1 , op2);\\n            }\\n        }\\n\\n       return max(dp[0][s[0]-\\'a\\'] , dp[0][26]);\\n   }\\n\\n   int SolveByTabSpaceOptimised(string &s , int &k )\\n   {\\n        vector<int> next(27, 0) ;\\n        vector<int> curr(27, 0);\\n       \\n        for(int index = s.length()-1 ; index>=0 ; index--)\\n        {\\n            for(int prev = 0 ; prev<= 26 ; prev++)\\n            {\\n                int op1 = 0 + next[prev];\\n                int op2 = 0 ;\\n\\n               if(prev == 26)\\n               op2 = 1 + next[s[index]-\\'a\\'];\\n               else if(abs(s[index]-\\'a\\' - prev) <= k)\\n               op2 = 1 + next[s[index]-\\'a\\'];\\n\\n               curr[prev] = max(op1 , op2);\\n            }\\n            next = curr;\\n        }\\n\\n       return max(curr[s[0]-\\'a\\'] , curr[26]);\\n   }\\n\\npublic:\\n    int longestIdealString(string s, int k) {\\n        \\n        // 1. Recursion + Memoization || Top Down Approach\\n        // vector<vector<int>> dp(s.length() , vector<int> (27, -1));\\n        // return SolveByMemo(s, k , 0 , 26, dp);\\n\\n        // 2. Tabulation Method || Bottom Up Approach\\n        // return SolveByTab(s, k);\\n\\n        // 3. Space Optimisation using Tabulation\\n        return SolveByTabSpaceOptimised(s , k);\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "wrong comment mark",
            "unclosed string",
            "undefined keywords from other languages",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution {\n\n   int SolveByMemo(string &s , int &k , int index , int prev , vector<vector<int>> &dp)\n   {\n       if(index == s.length())\n       return 0;\n\n       if(dp[index][prev] != -1)\n       return dp[index][prev];\n\n       int op1 = 0 + SolveByMemo(s, k , index+1 , prev , dp);\n\n       int op2 = 0 ;\n\n       if(prev == 26)\n       op2 = fun(s, k , index+1 , s[index]-'a' , dp);\n       else if(abs(s[index]-'a' - prev) <= k)\n       op2 = fun(s, k , index+1 , s[index]-'a' , dp);\n\n       return dp[index][prev] = max(op1 , op2);\n   }\n\n   int SolveByTab(string &s , int &k )\n   {\n        vector<vector<int>> dp(s.length()+1 , vector<int> (27, 0));\n       \n        for(int index = s.length()-1 ; index>=0 ; index--)\n        {\n            for(int prev = 0 ; prev<= 26 ; prev++)\n            {\n                int op1 = 0 + dp[index+1][prev];\n                int op2 = 0 ;\n\n               if(prev == 26)\n               op2 = fun(dp[index+1][s[index]-'a']);\n               else if(abs(s[index]-'a' - prev) <= k)\n               op2 = fun(dp[index+1][s[index]-'a']);\n\n               dp[index][prev] = max(op1 , op2);\n            }\n        }\n\n       return max(dp[0][s[0]-'a'] , dp[0][26]);\n   }\n\n   int SolveByTabSpaceOptimised(string &s , int &k )\n   {\n        vector<int> next(27, 0) ;\n        vector<int> curr(27, 0);\n       \n        for(int index = s.length()-1 ; index>=0 ; index--)\n        {\n            for(int prev = 0 ; prev<= 26 ; prev++)\n            {\n                int op1 = 0 + next[prev];\n                int op2 = 0 ;\n\n               if(prev == 26)\n               op2 = 1 + next[s[index]-'a'];\n               else if(abs(s[index]-'a' - prev) <= k)\n               op2 = 1 + next[s[index]-'a'];\n\n               curr[prev] = max(op1 , op2);\n            }\n            next = curr;\n        }\n\n       return max(curr[s[0]-'a'] , curr[26]);\n   }\n\npublic:\n    int longestIdealString(string s, int k) {\n        \n        // 1. Recursion + Memoization || Top Down Approach\n        // vector<vector<int>> dp(s.length() , vector<int> (27, -1));\n        // return SolveByMemo(s, string() , 0 , 26, dp);\n\n        // 2. Tabulation M/*ethod || Bottom Up*/ Approach\n        // return, k);\n\n        // 3. Space Opimisation usTabut"
    },
    {
        "slug": "shortest-path-with-alternating-colors",
        "description": "You are given an integer n, the number of nodes in a directed graph where the nodes are labeled from 0 to n - 1. Each edge is red or blue in this graph, and there could be self-edges and parallel edges.\nYou are given two arrays redEdges and blueEdges where:\n\nredEdges[i] = [ai, bi] indicates that there is a directed red edge from node ai to node bi in the graph, and\nblueEdges[j] = [uj, vj] indicates that there is a directed blue edge from node uj to node vj in the graph.\n\nReturn an array answer of length n, where each answer[x] is the length of the shortest path from node 0 to node x such that the edge colors alternate along the path, or -1 if such a path does not exist.",
        "examples": [
            "Input: n = 3, redEdges = [[0,1],[1,2]], blueEdges = []\nOutput: [0,1,-1]",
            "Input: n = 3, redEdges = [[0,1]], blueEdges = [[2,1]]\nOutput: [0,1,-1]"
        ],
        "constraints": "1 <= n <= 100\n0 <= redEdges.length,\u00a0blueEdges.length <= 400\nredEdges[i].length == blueEdges[j].length == 2\n0 <= ai, bi, uj, vj < n",
        "oracle_code": "class Solution {\npublic:\n    vector<int> shortestAlternatingPaths(int n,vector<vector<int>>&redEdges,vector<vector<int>>& blueEdges) \n    {\n        multiset<int>temp;\n        vector<multiset<int>>redchilds(n,temp),bluechilds(n,temp);\n        for(auto j:redEdges)\n        {\n            redchilds[j[0]].insert(j[1]);\n        }\n        for(auto j:blueEdges)\n        {\n            bluechilds[j[0]].insert(j[1]);\n        }\n        vector<int>ans;\n        for(int i=0;i<n;i++)\n        {\n            //BFS for all\n            vector<multiset<int>>reds=redchilds,blues=bluechilds;\n            queue<pair<char,int>>visit;\n            visit.push({'n',0});//neutral='n'\n            int steps=0;\n            while(!visit.empty())\n            {\n                bool justbreak=false;\n                int n=visit.size();\n                for(int j=0;j<n;j++)\n                {\n                    pair<char,int>x=visit.front();\n                    visit.pop();\n                    if(x.second==i)\n                    {\n                        ans.push_back(steps);\n                        justbreak=true;\n                        break;\n                    }\n                    if(x.first=='n')\n                    {\n                        for(auto j:reds[x.second])\n                        {\n                            visit.push({'r',j});\n                            auto itr1=reds[x.second].find(j);\n                            reds[x.second].erase(itr1);\n                        }\n                        for(auto j:blues[x.second])\n                        {\n                            visit.push({'b',j});//blue='b'\n                            auto itr1=blues[x.second].find(j);\n                            blues[x.second].erase(itr1);\n                        }\n                    }\n                    else if(x.first=='b')\n                    {\n                        for(auto j:reds[x.second])\n                        {\n                            visit.push({'r',j});//red='r'\n                            auto itr1=reds[x.second].find(j);\n                            reds[x.second].erase(itr1);\n                        }\n                    }\n                    else if(x.first=='r')\n                    {\n                        for(auto j:blues[x.second])\n                        {\n                            visit.push({'b',j});\n                            auto itr1=blues[x.second].find(j);\n                            blues[x.second].erase(itr1);\n                        }\n                    }\n                }\n                if(justbreak)\n                {\n                    break;\n                }\n                steps++;\n            }\n            if(i==ans.size())\n            {\n                ans.push_back(-1);\n            }\n        }\n        return ans;\n    }\n};",
        "content": "*E denotes number of Edges*\\n\\n# Complexity\\n- Time complexity:\\nO((N^2)+(N)*(E)*LOG(E))\\n\\n- Space complexity:\\nO(E)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> shortestAlternatingPaths(int n,vector<vector<int>>&redEdges,vector<vector<int>>& blueEdges) \\n    {\\n        multiset<int>temp;\\n        vector<multiset<int>>redchilds(n,temp),bluechilds(n,temp);\\n        for(auto j:redEdges)\\n        {\\n            redchilds[j[0]].insert(j[1]);\\n        }\\n        for(auto j:blueEdges)\\n        {\\n            bluechilds[j[0]].insert(j[1]);\\n        }\\n        vector<int>ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            //BFS for all\\n            vector<multiset<int>>reds=redchilds,blues=bluechilds;\\n            queue<pair<char,int>>visit;\\n            visit.push({\\'n\\',0});//neutral=\\'n\\'\\n            int steps=0;\\n            while(!visit.empty())\\n            {\\n                bool justbreak=false;\\n                int n=visit.size();\\n                for(int j=0;j<n;j++)\\n                {\\n                    pair<char,int>x=visit.front();\\n                    visit.pop();\\n                    if(x.second==i)\\n                    {\\n                        ans.push_back(steps);\\n                        justbreak=true;\\n                        break;\\n                    }\\n                    if(x.first==\\'n\\')\\n                    {\\n                        for(auto j:reds[x.second])\\n                        {\\n                            visit.push({\\'r\\',j});\\n                            auto itr1=reds[x.second].find(j);\\n                            reds[x.second].erase(itr1);\\n                        }\\n                        for(auto j:blues[x.second])\\n                        {\\n                            visit.push({\\'b\\',j});//blue=\\'b\\'\\n                            auto itr1=blues[x.second].find(j);\\n                            blues[x.second].erase(itr1);\\n                        }\\n                    }\\n                    else if(x.first==\\'b\\')\\n                    {\\n                        for(auto j:reds[x.second])\\n                        {\\n                            visit.push({\\'r\\',j});//red=\\'r\\'\\n                            auto itr1=reds[x.second].find(j);\\n                            reds[x.second].erase(itr1);\\n                        }\\n                    }\\n                    else if(x.first==\\'r\\')\\n                    {\\n                        for(auto j:blues[x.second])\\n                        {\\n                            visit.push({\\'b\\',j});\\n                            auto itr1=blues[x.second].find(j);\\n                            blues[x.second].erase(itr1);\\n                        }\\n                    }\\n                }\\n                if(justbreak)\\n                {\\n                    break;\\n                }\\n                steps++;\\n            }\\n            if(i==ans.size())\\n            {\\n                ans.push_back(-1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "== and = confusion",
            "unclosed string",
            "conditional statement error",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    vector<int> shortestAlternatingPaths(int n,vector<vector<int>>&redEdges,vector<vector<int>>& blueEdges) \n    {\n        multiset<int>temp;\n        vector<multiset<int>>redchilds(n,temp),bluechilds(n,temp);\n        for(auto j:redEdges)\n        {\n            redchilds[j[0]].insert(j[1]);\n        }\n        for(auto j:blueEdges)\n        {\n            bluechilds[j[0]].insert(j[1]);\n        }\n        vector<int>ans(n, -1);\n        for(int i=0;i<n;) \n        {\n            //BFS for all\n            vector<multiset<int>>reds=redchilds,blues=bluechilds;\n            queue<pair<char,int>>visit;\n            visit.push({'n',0});//neutral='n'\n            int steps=0;\n            while(!visit.empty())\n            {\n                bool justbreak=false;\n                int n=visit.size();\n                for(int j=0;j<n;j++)\n                {\n                    pair<char,int>x=visit.front();\n                    visit.pop();\n                    if(x.second=i)\n                    {\n                        ans[i]=steps;\n                        justbreak=true;\n                        break;\n                    }\n                    if(x.first=='n' || x.first == ans[i] % 2 + '0') \n                    {\n                        for(auto j:reds[x.second])\n                        {\n                            visit.push({'r\",j});\n                            auto itr1=reds[x.second].find(j);\n                            reds[x.second].erase(itr1);\n                        }\n                        for(auto j:blues[x.second])\n                        {\n                            visit.push({'b',j});//blue='b'\n                            auto itr1=blues[x.second].find(j);\n                            unknownFunction(itr1); \n                            blues[x.second].erase(itr1);\n                        }\n                    }\n                    else if(x.first=='b')\n                    {\n                        for(auto j:reds[x.second])\n                        {\n                            visit.push({'r',j});//red='r'\n                            auto itr1=reds[x.second].find(j);\n                            reds[x.second].erase(itr1);\n                        }\n                    }\n                    else if(x.first=='r')\n                    {\n                        for(auto j:blues[x.second])\n                        {\n                            visit.push({'b',j});\n                            auto itr1=blues[x.second].find(j);\n                            blues[x.second].erase(itr1);\n                        }\n                    }\n                }\n                if(justbreak)\n                {\n                    break;\n                }\n                steps++;\n            }\n        }\n        return ans;\n    }\n};\n"
    },
    {
        "slug": "array-with-elements-not-equal-to-average-of-neighbors",
        "description": "You are given a 0-indexed array nums of distinct integers. You want to rearrange the elements in the array such that every element in the rearranged array is not equal to the average of its neighbors.\nMore formally, the rearranged array should have the property such that for every i in the range 1 <= i < nums.length - 1, (nums[i-1] + nums[i+1]) / 2 is not equal to nums[i].\nReturn any rearrangement of nums that meets the requirements.",
        "examples": [
            "Input: nums = [1,2,3,4,5]\nOutput: [1,2,4,5,3]\nExplanation:\nWhen i=1, nums[i] = 2, and the average of its neighbors is (1+4) / 2 = 2.5.\nWhen i=2, nums[i] = 4, and the average of its neighbors is (2+5) / 2 = 3.5.\nWhen i=3, nums[i] = 5, and the average of its neighbors is (4+3) / 2 = 3.5.",
            "Input: nums = [6,2,0,9,7]\nOutput: [9,7,6,2,0]\nExplanation:\nWhen i=1, nums[i] = 7, and the average of its neighbors is (9+6) / 2 = 7.5.\nWhen i=2, nums[i] = 6, and the average of its neighbors is (7+2) / 2 = 4.5.\nWhen i=3, nums[i] = 2, and the average of its neighbors is (6+0) / 2 = 3."
        ],
        "constraints": "3 <= nums.length <= 105\n0 <= nums[i] <= 105",
        "oracle_code": "class Solution {\npublic:\n    vector<int> rearrangeArray(vector<int>& nums) {\n        int size=nums.size();\n        for(int i=1;i<size-1;i++){\n            if((nums[i-1]<nums[i] && nums[i]<nums[i+1])||(nums[i-1]>nums[i] && nums[i]>nums[i+1]))   //If the array is strictly increasing or decreasing then swap the vlaue at current index  with value at index+1\n                swap(nums[i],nums[i+1]);\n        }\n        return nums;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int size=nums.size();\\n        for(int i=1;i<size-1;i++){\\n            if((nums[i-1]<nums[i] && nums[i]<nums[i+1])||(nums[i-1]>nums[i] && nums[i]>nums[i+1]))   //If the array is strictly increasing or decreasing then swap the vlaue at current index  with value at index+1\\n                swap(nums[i],nums[i+1]);\\n        }\\n        return nums;\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "wrong comment mark",
            "conditional statement error",
            "undefined methods",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    vector<int> rearrangeArray(vector<int>& nums) {\n        int size=nums.size();\n        for(int i=0;i<size-1;i++){\n            if((nums[i-1]<nums[i] && nums[i]<nums[i+1])\\(nums[i-1]>nums[i] && nums[i]>nums[i+1]))\n   \n                swap(nums[i],nums[i+2]);  \n        }\n        return nums;\n    }\n};\n"
    },
    {
        "slug": "most-frequent-even-element",
        "description": "Given an integer array nums, return the most frequent even element.\nIf there is a tie, return the smallest one. If there is no such element, return -1.",
        "examples": [
            "Input: nums = [0,1,2,2,4,4,1]\nOutput: 2\nExplanation:\nThe even elements are 0, 2, and 4. Of these, 2 and 4 appear the most.\nWe return the smallest one, which is 2.",
            "Input: nums = [4,4,4,9,2,4]\nOutput: 4\nExplanation: 4 is the even element appears the most.",
            "Input: nums = [29,47,21,41,13,37,25,7]\nOutput: -1\nExplanation: There is no even element."
        ],
        "constraints": "1 <= nums.length <= 2000\n0 <= nums[i] <= 105",
        "oracle_code": "class Solution {\npublic:\n    int mostFrequentEven(vector<int>& nums) {\n        int n = nums.size(),i;\n        map<int , int> freq;\n        for(auto x:nums){\n            freq[x]++;\n        }\n        int evefreq=0,ans=-1;\n        for(auto y:freq){\n            if(y.first%2==0 && y.second> evefreq){\n                ans=y.first;\n                evefreq=y.second;\n            }\n        }\n        return ans;\n    }\n};",
        "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mostFrequentEven(vector<int>& nums) {\\n        int n = nums.size(),i;\\n        map<int , int> freq;\\n        for(auto x:nums){\\n            freq[x]++;\\n        }\\n        int evefreq=0,ans=-1;\\n        for(auto y:freq){\\n            if(y.first%2==0 && y.second> evefreq){\\n                ans=y.first;\\n                evefreq=y.second;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "conditional statement error",
            "colon missing",
            "parentheses mismatch",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    int mostFrequentEven(vector<int>& nums) {\n        int n = nums.size(),i;\n        map<int , int> freq;\n        for(auto x:nums\n            freq[x]++;\n        }\n        int evefreq=0,ans;\n        for(auto y:freq){\n            if(y.second> evefreq){\n                ans=y.first;\n                evefreq=y.second;\n            }\n        }\n        return ans;\n    }\n};\n"
    },
    {
        "slug": "shortest-path-with-alternating-colors",
        "description": "You are given an integer n, the number of nodes in a directed graph where the nodes are labeled from 0 to n - 1. Each edge is red or blue in this graph, and there could be self-edges and parallel edges.\nYou are given two arrays redEdges and blueEdges where:\n\nredEdges[i] = [ai, bi] indicates that there is a directed red edge from node ai to node bi in the graph, and\nblueEdges[j] = [uj, vj] indicates that there is a directed blue edge from node uj to node vj in the graph.\n\nReturn an array answer of length n, where each answer[x] is the length of the shortest path from node 0 to node x such that the edge colors alternate along the path, or -1 if such a path does not exist.",
        "examples": [
            "Input: n = 3, redEdges = [[0,1],[1,2]], blueEdges = []\nOutput: [0,1,-1]",
            "Input: n = 3, redEdges = [[0,1]], blueEdges = [[2,1]]\nOutput: [0,1,-1]"
        ],
        "constraints": "1 <= n <= 100\n0 <= redEdges.length,\u00a0blueEdges.length <= 400\nredEdges[i].length == blueEdges[j].length == 2\n0 <= ai, bi, uj, vj < n",
        "oracle_code": "class Solution {\npublic:\n    vector<int> shortestAlternatingPaths(int n,vector<vector<int>>&redEdges,vector<vector<int>>& blueEdges) \n    {\n        multiset<int>temp;\n        vector<multiset<int>>redchilds(n,temp),bluechilds(n,temp);\n        for(auto j:redEdges)\n        {\n            redchilds[j[0]].insert(j[1]);\n        }\n        for(auto j:blueEdges)\n        {\n            bluechilds[j[0]].insert(j[1]);\n        }\n        vector<int>ans;\n        for(int i=0;i<n;i++)\n        {\n            //BFS for all\n            vector<multiset<int>>reds=redchilds,blues=bluechilds;\n            queue<pair<char,int>>visit;\n            visit.push({'n',0});//neutral='n'\n            int steps=0;\n            while(!visit.empty())\n            {\n                bool justbreak=false;\n                int n=visit.size();\n                for(int j=0;j<n;j++)\n                {\n                    pair<char,int>x=visit.front();\n                    visit.pop();\n                    if(x.second==i)\n                    {\n                        ans.push_back(steps);\n                        justbreak=true;\n                        break;\n                    }\n                    if(x.first=='n')\n                    {\n                        for(auto j:reds[x.second])\n                        {\n                            visit.push({'r',j});\n                            auto itr1=reds[x.second].find(j);\n                            reds[x.second].erase(itr1);\n                        }\n                        for(auto j:blues[x.second])\n                        {\n                            visit.push({'b',j});//blue='b'\n                            auto itr1=blues[x.second].find(j);\n                            blues[x.second].erase(itr1);\n                        }\n                    }\n                    else if(x.first=='b')\n                    {\n                        for(auto j:reds[x.second])\n                        {\n                            visit.push({'r',j});//red='r'\n                            auto itr1=reds[x.second].find(j);\n                            reds[x.second].erase(itr1);\n                        }\n                    }\n                    else if(x.first=='r')\n                    {\n                        for(auto j:blues[x.second])\n                        {\n                            visit.push({'b',j});\n                            auto itr1=blues[x.second].find(j);\n                            blues[x.second].erase(itr1);\n                        }\n                    }\n                }\n                if(justbreak)\n                {\n                    break;\n                }\n                steps++;\n            }\n            if(i==ans.size())\n            {\n                ans.push_back(-1);\n            }\n        }\n        return ans;\n    }\n};",
        "content": "*E denotes number of Edges*\\n\\n# Complexity\\n- Time complexity:\\nO((N^2)+(N)*(E)*LOG(E))\\n\\n- Space complexity:\\nO(E)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> shortestAlternatingPaths(int n,vector<vector<int>>&redEdges,vector<vector<int>>& blueEdges) \\n    {\\n        multiset<int>temp;\\n        vector<multiset<int>>redchilds(n,temp),bluechilds(n,temp);\\n        for(auto j:redEdges)\\n        {\\n            redchilds[j[0]].insert(j[1]);\\n        }\\n        for(auto j:blueEdges)\\n        {\\n            bluechilds[j[0]].insert(j[1]);\\n        }\\n        vector<int>ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            //BFS for all\\n            vector<multiset<int>>reds=redchilds,blues=bluechilds;\\n            queue<pair<char,int>>visit;\\n            visit.push({\\'n\\',0});//neutral=\\'n\\'\\n            int steps=0;\\n            while(!visit.empty())\\n            {\\n                bool justbreak=false;\\n                int n=visit.size();\\n                for(int j=0;j<n;j++)\\n                {\\n                    pair<char,int>x=visit.front();\\n                    visit.pop();\\n                    if(x.second==i)\\n                    {\\n                        ans.push_back(steps);\\n                        justbreak=true;\\n                        break;\\n                    }\\n                    if(x.first==\\'n\\')\\n                    {\\n                        for(auto j:reds[x.second])\\n                        {\\n                            visit.push({\\'r\\',j});\\n                            auto itr1=reds[x.second].find(j);\\n                            reds[x.second].erase(itr1);\\n                        }\\n                        for(auto j:blues[x.second])\\n                        {\\n                            visit.push({\\'b\\',j});//blue=\\'b\\'\\n                            auto itr1=blues[x.second].find(j);\\n                            blues[x.second].erase(itr1);\\n                        }\\n                    }\\n                    else if(x.first==\\'b\\')\\n                    {\\n                        for(auto j:reds[x.second])\\n                        {\\n                            visit.push({\\'r\\',j});//red=\\'r\\'\\n                            auto itr1=reds[x.second].find(j);\\n                            reds[x.second].erase(itr1);\\n                        }\\n                    }\\n                    else if(x.first==\\'r\\')\\n                    {\\n                        for(auto j:blues[x.second])\\n                        {\\n                            visit.push({\\'b\\',j});\\n                            auto itr1=blues[x.second].find(j);\\n                            blues[x.second].erase(itr1);\\n                        }\\n                    }\\n                }\\n                if(justbreak)\\n                {\\n                    break;\\n                }\\n                steps++;\\n            }\\n            if(i==ans.size())\\n            {\\n                ans.push_back(-1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "== and = confusion",
            "unclosed string",
            "conditional statement error",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    vector<int> shortestAlternatingPaths(int n,vector<vector<int>>&redEdges,vector<vector<int>>& blueEdges) \n    {\n        multiset<int>temp;\n        vector<multiset<int>>redchilds(n,temp),bluechilds(n,temp);\n        for(auto j:redEdges)\n        {\n            redchilds[j[0]].insert(j[1]);\n        }\n        for(auto j:blueEdges)\n        {\n            bluechilds[j[0]].insert(j[1]);\n        }\n        vector<int>ans(n, -1);\n        for(int i=0;i<n;) \n        {\n            //BFS for all\n            vector<multiset<int>>reds=redchilds,blues=bluechilds;\n            queue<pair<char,int>>visit;\n            visit.push({'n',0});//neutral='n'\n            int steps=0;\n            while(!visit.empty()\n            {\n                bool justbreak=false;\n                int n=visit.size();\n                for(int j=0;j<n;j++)\n                {\n                    pair<char,int>x=visit.front();\n                    visit.pop();\n                    if(x.second=i)\n                    {\n                        ans[i]=steps;\n                        justbreak=true;\n                        break;\n                    }\n                    if(x.first=='n' || x.first == ans[i] % 2 + '0') \n                    {\n                        for(auto j:reds[x.second])\n                        {\n                            visit.push({'r\",j});\n                            auto itr1=reds[x.second].find(j);\n                            reds[x.second].erase(itr1);\n                        }\n                        for(auto j:blues[x.second])\n                        {\n                            visit.push({'b',j});//blue='b'\n                            auto itr1=blues[x.second].find(j);\n                            blues[x.second].erase(itr1);\n                        }\n                    }\n                    else if(x.first=='b')\n                    {\n                        for(auto j:reds[x.second])\n                        {\n                            visit.push({'r',j});//red='r'\n                            auto itr1=reds[x.second].find(j);\n                            reds[x.second].erase(itr1);\n                        }\n                    }\n                    else if(x.first=='r')\n                    {\n                        for(auto j:blues[x.second])\n                        {\n                            visit.push({'b',j});\n                            auto itr1=blues[x.second].find(j);\n                            blues[x.second].erase(itr1);\n                        }\n                    }\n                }\n                if(justbreak)\n                {\n                    break;\n                }\n                steps++;\n            }\n        }\n        return ans;\n    }\n};\n"
    },
    {
        "slug": "perfect-squares",
        "description": "Given an integer n, return the least number of perfect square numbers that sum to n.\nA perfect square is an integer that is the square of an integer; in other words, it is the product of some integer with itself. For example, 1, 4, 9, and 16 are perfect squares while 3 and 11 are not.",
        "examples": [
            "Input: n = 12\nOutput: 3\nExplanation: 12 = 4 + 4 + 4.",
            "Input: n = 13\nOutput: 2\nExplanation: 13 = 4 + 9."
        ],
        "constraints": "1 <= n <= 104",
        "oracle_code": "class Solution {\npublic:\n\n    // declare a dp\n\n    int dp[105][10005];\n\n    int helper(vector<int>& arr, int i, int n, int sum)\n    {\n        // base case\n\n        if(sum == 0)\n        {\n            return 0;\n        }\n\n        if(i >= n || sum < 0)\n        {\n            return INT_MAX - 1000;\n        }\n\n        // if already calculated\n\n        if(dp[i][sum] != -1)\n        {\n            return dp[i][sum];\n        }\n\n        // at each ith element we have two options either include or exclude\n\n        int mini = INT_MAX;\n\n        // inclusion part\n\n        if(arr[i] <= sum)\n        {\n            mini = min(mini, 1 + helper(arr, i, n, sum - arr[i]));\n        }\n\n        // exclusion part\n\n        mini = min(mini, helper(arr, i + 1, n, sum));\n\n        // store the res in dp\n\n        return dp[i][sum] = mini;\n    }\n\n    int numSquares(int n) {\n\n        vector<int> arr;\n\n        // find all the squares between 1 to n\n\n        for(int i = 1; i * i <= n; i++)\n        {\n            arr.push_back(i * i);\n        }\n\n        // initialize dp with -1\n\n        memset(dp, -1, sizeof(dp));\n\n        return helper(arr, 0, arr.size(), n);\n    }\n};",
        "content": "* ***Using Recursion && Memoization***\\n\\n* ***Time Complexity :- O(N * sqrt(N))***\\n\\n* ***Space Complexity :- O(N * sqrt(N))***\\n\\n* ***There are sqrt(N), squares between 1 to N***\\n\\n```\\nclass Solution {\\npublic:\\n\\n    // declare a dp\\n\\n    int dp[105][10005];\\n\\n    int helper(vector<int>& arr, int i, int n, int sum)\\n    {\\n        // base case\\n\\n        if(sum == 0)\\n        {\\n            return 0;\\n        }\\n\\n        if(i >= n || sum < 0)\\n        {\\n            return INT_MAX - 1000;\\n        }\\n\\n        // if already calculated\\n\\n        if(dp[i][sum] != -1)\\n        {\\n            return dp[i][sum];\\n        }\\n\\n        // at each ith element we have two options either include or exclude\\n\\n        int mini = INT_MAX;\\n\\n        // inclusion part\\n\\n        if(arr[i] <= sum)\\n        {\\n            mini = min(mini, 1 + helper(arr, i, n, sum - arr[i]));\\n        }\\n\\n        // exclusion part\\n\\n        mini = min(mini, helper(arr, i + 1, n, sum));\\n\\n        // store the res in dp\\n\\n        return dp[i][sum] = mini;\\n    }\\n\\n    int numSquares(int n) {\\n\\n        vector<int> arr;\\n\\n        // find all the squares between 1 to n\\n\\n        for(int i = 1; i * i <= n; i++)\\n        {\\n            arr.push_back(i * i);\\n        }\\n\\n        // initialize dp with -1\\n\\n        memset(dp, -1, sizeof(dp));\\n\\n        return helper(arr, 0, arr.size(), n);\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "== and = confusion",
            "indexing error",
            "undefined keywords from other languages",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    int dp[105][10005];\n    \n    int helper(int i, int n, int sum)\n    {\n        vector<int>& arr;\n\n        if(sum == 0)\n        {\n            return 0;\n        }\n\n        if(i > n || sum < 0)\n        {\n            return INT_MAX - 1000;\n        }\n\n        if(dp[i][sum] != -1)\n        {\n            return dp[i][sum];\n        }\n\n        int mini = INT_MAX;\n\n        if(arr[i] <= sum)\n        {\n            mini = min(mini, 1 + helper(i, n, sum - arr[i]=));\n        }\n\n        mini = min(mini, helper(i + 1, n, sum));\n\n        return dp[i][sum] = mini;\n    }\n\n    int numSquares(int n) {\n\n        vector<int> arr;\n\n        for(int i = 1; i * i <= n; i++)\n        {\n            arr.push_back(i * i);\n        }\n\n        memset(dp, -1, sizeof(dp));\n\n        \n        print(helper(0, arr.size(), n));\n    }\n};\n"
    },
    {
        "slug": "lexicographically-smallest-string-after-substring-operation",
        "description": "You are given a string s consisting of only lowercase English letters. In one operation, you can do the following:\n\nSelect any non-empty substring of s, possibly the entire string, then replace each one of its characters with the previous character of the English alphabet. For example, 'b' is converted to 'a', and 'a' is converted to 'z'.\n\nReturn the lexicographically smallest string you can obtain after performing the above operation exactly once.\nA substring is a contiguous sequence of characters in a string.\nA string x is lexicographically smaller than a string y of the same length if x[i] comes before y[i] in alphabetic order for the first position i such that x[i] != y[i].",
        "examples": [
            "Input: s = \"cbabc\"\nOutput: \"baabc\"\nExplanation: We apply the operation on the substring starting at index 0, and ending at index 1 inclusive. \nIt can be proven that the resulting string is the lexicographically smallest.",
            "Input: s = \"acbbc\"\nOutput: \"abaab\"\nExplanation: We apply the operation on the substring starting at index 1, and ending at index 4 inclusive. \nIt can be proven that the resulting string is the lexicographically smallest.",
            "Input: s = \"leetcode\"\nOutput: \"kddsbncd\"\nExplanation: We apply the operation on the entire string. \nIt can be proven that the resulting string is the lexicographically smallest."
        ],
        "constraints": "1 <= s.length <= 3 * 105\ns consists of lowercase English letters",
        "oracle_code": "class Solution {\npublic:\n    string smallestString(string s) {\n        int temp = -1;\n        int cnt = 0;\n        for(int i = 0; i < s.size(); i++)\n        {\n            if(s[i] == 'a')\n            {\n                cnt++;\n            }\n        }\n        if(cnt == s.size())\n        {\n            s[s.size() - 1] = 'z';\n            return s;\n        }\n        else\n        {\n            for(int i = 0; i < s.size(); i++)\n            {\n                if(s[i] == 'a')\n                {\n                    temp = i;\n                    break;\n                }\n            }\n\n            if(temp == 0)\n            {\n                int temp1 = 1, temp2 = 1;\n                for(int i = 1 ; i < s.size(); i++)\n                {\n                    if(s[i] != 'a')\n                    {\n                        temp1 = i;\n                        break;\n                    }\n                }\n                for(int i = temp1; i < s.size(); i++)\n                {\n                    if(s[i] == 'a')\n                    {\n                        temp2 = i;\n                        break;\n                    }\n                }\n\n                if(temp2 > 1)\n                {\n                    for(int i = temp1; i < temp2; i++)\n                    {\n                        s[i] = s[i] - 1;\n                    }\n                }\n                else if(temp2 == 1)\n                {\n                    for(int i = temp1; i < s.size(); i++)\n                    {\n                        s[i] = s[i] - 1;\n                    }\n                }\n\n                return s;\n            }\n            else if(temp == -1)\n            {\n                for(int i = 0; i < s.size(); i++)\n                {\n                    s[i] = s[i] - 1;\n                }\n                return s;\n            }\n            else\n            {\n                for(int i = 0; i < temp; i++)\n                {\n                    s[i] = s[i] - 1;\n                }\n                return s;\n            }\n        }\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCheck for the first occurence of \\'a\\'.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Check for the index where \\'a\\' has occured the very first time.\\n2. If it is index 0, then check for the very first index at which s[i] != \\'a\\', store this index in temp1 variable, then from temp1 check for the nearest occurence of \\'a\\' and store in temp2 variable, and from temp1 till temp2 - 1, replace all the letters with their previous one (alphabetically).\\n3. If index of first occurence of \\'a\\' is greater than 0 and store it in temp variable, then simply starting from 0 and ranging to temp - 1, replace all the letters with their previous one (alphabetically).\\n\\n# Complexity\\n- Time complexity: **O(n)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nIn worst case, we need to traverse the whole string.\\n\\n- Space complexity: **O(1)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nConstant extra space.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string smallestString(string s) {\\n        int temp = -1;\\n        int cnt = 0;\\n        for(int i = 0; i < s.size(); i++)\\n        {\\n            if(s[i] == \\'a\\')\\n            {\\n                cnt++;\\n            }\\n        }\\n        if(cnt == s.size())\\n        {\\n            s[s.size() - 1] = \\'z\\';\\n            return s;\\n        }\\n        else\\n        {\\n            for(int i = 0; i < s.size(); i++)\\n            {\\n                if(s[i] == \\'a\\')\\n                {\\n                    temp = i;\\n                    break;\\n                }\\n            }\\n\\n            if(temp == 0)\\n            {\\n                int temp1 = 1, temp2 = 1;\\n                for(int i = 1 ; i < s.size(); i++)\\n                {\\n                    if(s[i] != \\'a\\')\\n                    {\\n                        temp1 = i;\\n                        break;\\n                    }\\n                }\\n                for(int i = temp1; i < s.size(); i++)\\n                {\\n                    if(s[i] == \\'a\\')\\n                    {\\n                        temp2 = i;\\n                        break;\\n                    }\\n                }\\n\\n                if(temp2 > 1)\\n                {\\n                    for(int i = temp1; i < temp2; i++)\\n                    {\\n                        s[i] = s[i] - 1;\\n                    }\\n                }\\n                else if(temp2 == 1)\\n                {\\n                    for(int i = temp1; i < s.size(); i++)\\n                    {\\n                        s[i] = s[i] - 1;\\n                    }\\n                }\\n\\n                return s;\\n            }\\n            else if(temp == -1)\\n            {\\n                for(int i = 0; i < s.size(); i++)\\n                {\\n                    s[i] = s[i] - 1;\\n                }\\n                return s;\\n            }\\n            else\\n            {\\n                for(int i = 0; i < temp; i++)\\n                {\\n                    s[i] = s[i] - 1;\\n                }\\n                return s;\\n            }\\n        }\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "other error",
            "indexing error",
            "unclosed string",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    string smallestString(string s) {\n        int temp = -1;\n        int cnt = 0;\n        for(int i = 0; i <= s.size(); i++)\n        {\n            if(s[i] == 'a')\n            {\n                cnt++;\n            }\n        }\n        string msg = \"Input data: ;\n        if(cnt == s.size())\n        {\n            s[s.size()] = 'z';\n            return s;\n        }\n        else\n        {\n            for(int i = 0; i <= s.size(); i++)\n            {\n                if(s[i] == 'a')\n                {\n                    temp = i;\n                    break;\n                }\n            }\n\n            if(temp == 0)\n            {\n                int temp1 = 1, temp2 = 1;\n                for(int i = 1 ; i < s.size(); i++)\n                {\n                    if(s[i] != 'a')\n                    {\n                        temp1 = i;\n                        break;\n                    }\n                }\n                for(int i = temp1; i < s.size(); i++)\n                {\n                    if(s[i] == 'a')\n                    {\n                        temp2 = i;\n                        break;\n                    }\n                }\n\n                if(temp2 > 1)\n                {\n                    for(int i = temp1; i < temp2; i++)\n                    {\n                        s[i] = modifyChar(s[i]);\n                    }\n                }\n                else if(temp2 == 1)\n                {\n                    for(int i = temp1; i < s.size(); i++)\n                    {\n                        s[i] = modifyChar(s[i]);\n                    }\n                }\n\n                return s;\n            }\n            else if(temp == -1)\n            {\n                for(int i = 0; i < s.size(); i++)\n                {\n                    s[i] = modifyChar(s[i]);\n                }\n                return s;\n            }\n            else\n            {\n                for(int i = 0; i < temp; i++)\n                {\n                    s[i] = modifyChar(s[i]);\n                }\n                return s;\n            }\n        }\n    }\n};\n"
    },
    {
        "slug": "check-if-there-is-a-valid-path-in-a-grid",
        "description": "You are given an m x n grid. Each cell of grid represents a street. The street of grid[i][j] can be:\n\n1 which means a street connecting the left cell and the right cell.\n2 which means a street connecting the upper cell and the lower cell.\n3 which means a street connecting the left cell and the lower cell.\n4 which means a street connecting the right cell and the lower cell.\n5 which means a street connecting the left cell and the upper cell.\n6 which means a street connecting the right cell and the upper cell.\n\n\nYou will initially start at the street of the upper-left cell (0, 0). A valid path in the grid is a path that starts from the upper left cell (0, 0) and ends at the bottom-right cell (m - 1, n - 1). The path should only follow the streets.\nNotice that you are not allowed to change any street.\nReturn true if there is a valid path in the grid or false otherwise.",
        "examples": [
            "Input: grid = [[2,4,3],[6,5,2]]\nOutput: true\nExplanation: As shown you can start at cell (0, 0) and visit all the cells of the grid to reach (m - 1, n - 1).",
            "Input: grid = [[1,2,1],[1,2,1]]\nOutput: false\nExplanation: As shown you the street at cell (0, 0) is not connected with any street of any other cell and you will get stuck at cell (0, 0)",
            "Input: grid = [[1,1,2]]\nOutput: false\nExplanation: You will get stuck at cell (0, 1) and you cannot reach cell (0, 2)."
        ],
        "constraints": "m == grid.length\nn == grid[i].length\n1 <= m, n <= 300\n1 <= grid[i][j] <= 6",
        "oracle_code": "class DisjointSet{\npublic:\n    vector<int>par,size;\n    DisjointSet(int n){\n        par.resize(n+1);\n        size.resize(n+1,1);\n        for(int i=0; i<=n; i++){\n            par[i] = i;\n        }\n    }\n    int findpar(int u){\n        if(u == par[u]) return u;\n        return par[u] = findpar(par[u]);\n    }\n\n    void unionBySize(int u, int v){\n        u = findpar(u);\n        v = findpar(v);\n\n        if(u == v) return;\n\n        if(size[u] >= size[v]){\n            par[v] = u;\n            size[u] += size[v];\n        }\n        else{\n            par[u] = v;\n            size[v] += size[u];\n        }\n    }\n    \n};\nclass Solution {\npublic:\n    bool hasValidPath(vector<vector<int>>& grid) {\n        int n = grid.size();\n        int m = grid[0].size();\n        DisjointSet ds(n*m);\n        for(int i=0; i<n; i++){\n            for(int j=0; j<m; j++){\n                int p = i * m + j;\n                int p1 = (i-1)*m + j;  // 1\n                int p2 = (i+1)*m + j;  // 1\n                int p3 = i*m + (j+1);  // 2\n                int p4 = i*m + (j-1);  // 2\n\n                if(grid[i][j] == 1){\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\n                        ds.unionBySize(p,p3);\n                    }\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\n                        ds.unionBySize(p,p4);\n                    }\n                }\n                else if(grid[i][j] == 2){\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\n                        ds.unionBySize(p,p2);\n                    }\n\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\n                        ds.unionBySize(p,p1);\n                    }\n                }\n                else if(grid[i][j] == 3){\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\n                        ds.unionBySize(p,p4);\n                    }\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\n                        ds.unionBySize(p,p2);\n                    }\n                }\n                else if(grid[i][j] == 4){\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\n                        ds.unionBySize(p,p3);\n                    }\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\n                        ds.unionBySize(p,p2);\n                    }\n                }\n                else if(grid[i][j] == 5){\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\n                        ds.unionBySize(p,p1);\n                    }\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\n                        ds.unionBySize(p,p4);\n                    }\n                }\n                else if(grid[i][j] == 6){\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\n                        ds.unionBySize(p,p1);\n                    }\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\n                        ds.unionBySize(p,p3);\n                    }\n                }\n            }\n        }\n        return ds.findpar(0) == ds.findpar(n*m-1);\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass DisjointSet{\\npublic:\\n    vector<int>par,size;\\n    DisjointSet(int n){\\n        par.resize(n+1);\\n        size.resize(n+1,1);\\n        for(int i=0; i<=n; i++){\\n            par[i] = i;\\n        }\\n    }\\n    int findpar(int u){\\n        if(u == par[u]) return u;\\n        return par[u] = findpar(par[u]);\\n    }\\n\\n    void unionBySize(int u, int v){\\n        u = findpar(u);\\n        v = findpar(v);\\n\\n        if(u == v) return;\\n\\n        if(size[u] >= size[v]){\\n            par[v] = u;\\n            size[u] += size[v];\\n        }\\n        else{\\n            par[u] = v;\\n            size[v] += size[u];\\n        }\\n    }\\n    \\n};\\nclass Solution {\\npublic:\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        DisjointSet ds(n*m);\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                int p = i * m + j;\\n                int p1 = (i-1)*m + j;  // 1\\n                int p2 = (i+1)*m + j;  // 1\\n                int p3 = i*m + (j+1);  // 2\\n                int p4 = i*m + (j-1);  // 2\\n\\n                if(grid[i][j] == 1){\\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\\n                        ds.unionBySize(p,p3);\\n                    }\\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\\n                        ds.unionBySize(p,p4);\\n                    }\\n                }\\n                else if(grid[i][j] == 2){\\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\\n                        ds.unionBySize(p,p2);\\n                    }\\n\\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\\n                        ds.unionBySize(p,p1);\\n                    }\\n                }\\n                else if(grid[i][j] == 3){\\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\\n                        ds.unionBySize(p,p4);\\n                    }\\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\\n                        ds.unionBySize(p,p2);\\n                    }\\n                }\\n                else if(grid[i][j] == 4){\\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\\n                        ds.unionBySize(p,p3);\\n                    }\\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\\n                        ds.unionBySize(p,p2);\\n                    }\\n                }\\n                else if(grid[i][j] == 5){\\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\\n                        ds.unionBySize(p,p1);\\n                    }\\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\\n                        ds.unionBySize(p,p4);\\n                    }\\n                }\\n                else if(grid[i][j] == 6){\\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\\n                        ds.unionBySize(p,p1);\\n                    }\\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\\n                        ds.unionBySize(p,p3);\\n                    }\\n                }\\n            }\\n        }\\n        return ds.findpar(0) == ds.findpar(n*m-1);\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "== and = confusion",
            "indexing error",
            "variable value error",
            "parentheses mismatch"
        ],
        "buggy_code": "\n\nclass DisjointSet{\npublic:\n    vector<int>par,size;\n    DisjointSet(int n){\n        par.resize(n+1);\n        size.resize(n+1,1);\n        for(int i=0; i<=n; i++){\n            par[i] == i;\n        }\n    }\n    int findpar(int u){\n        if(u == par[u) return u;\n        return par[u] = findpar(par[u]);\n    }\n\n    void unionBySize(int u, int v){\n        u == findpar(u);\n        v == findpar(v);\n\n        if(u == v) return;\n\n        if(size[u-1] >= size[v-1]){\n            par[v-1] = v;\n            size[u] += size[v];\n        }\n        else{\n            par[u-1] = u-1;\n            size[v-1] += size[u];\n        }\n    }\n    \n};\nclass Solution {\npublic:\n    bool hasValidPath(vector<vector<int>>& grid) {\n        int n = grid.size();\n        int m = grid[0].size();\n        DisjointSet ds(n*m);\n        for(int i=0; i<n; i++){\n            for(int j=0; j<m; j++){\n                int p = i * m + j;\n                int p1 = (i-1)*m + j;  \n                int p2 = (i+1)*m + j;  \n                int p3 = i*m + (j+1);  \n                int p4 = i*m + (j-1);  \n\n                if(grid[i][j] == 1){\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\n                        ds.unionBySize(p,p3);\n                    }\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\n                        ds.unionBySize(p,p4);\n                    }\n                }\n                else if(grid[i][j] == 2){\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\n                        ds.unionBySize(p,p2);\n                    }\n\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\n                        ds.unionBySize(p,p1);\n                    }\n                }\n                else if(grid[i][j] == 3){\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\n                        ds.unionBySize(p,p4);\n                    }\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\n                        ds.unionBySize(p,p2);\n                    }\n                }\n                else if(grid[i][j] == 4){\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\n                        ds.unionBySize(p,p3);\n                    }\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\n                        ds.unionBySize(p,p2);\n                    }\n                }\n                else if(grid[i][j] == 5){\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\n                        ds.unionBySize(p,p1);\n                    }\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\n                        ds.unionBySize(p,p4);\n                    }\n                }\n                else if(grid[i][j] == 6){\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\n                        ds.unionBySize(p,p1);\n                    }\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\n                        ds.unionBySize(p,p3);\n                    }\n                }\n            }\n        }\n        return ds.findpar(0) == ds.findpar(n*m-1);\n    }\n};\n\n"
    },
    {
        "slug": "closest-subsequence-sum",
        "description": "You are given an integer array nums and an integer goal.\nYou want to choose a subsequence of nums such that the sum of its elements is the closest possible to goal. That is, if the sum of the subsequence's elements is sum, then you want to minimize the absolute difference abs(sum - goal).\nReturn the minimum possible value of abs(sum - goal).\nNote that a subsequence of an array is an array formed by removing some elements (possibly all or none) of the original array.",
        "examples": [
            "Input: nums = [5,-7,3,5], goal = 6\nOutput: 0\nExplanation: Choose the whole array as a subsequence, with a sum of 6.\nThis is equal to the goal, so the absolute difference is 0.",
            "Input: nums = [7,-9,15,-2], goal = -5\nOutput: 1\nExplanation: Choose the subsequence [7,-9,-2], with a sum of -4.\nThe absolute difference is abs(-4 - (-5)) = abs(1) = 1, which is the minimum.",
            "Input: nums = [1,2,3], goal = -7\nOutput: 7"
        ],
        "constraints": "1 <= nums.length <= 40\n-107 <= nums[i] <= 107\n-109 <= goal <= 109",
        "oracle_code": "class Solution {\npublic:\n    void find(vector<int>&v, int i, int e, int sum, vector<int>&sumv){\n        if(i==e){\n            sumv.push_back(sum);\n            return;\n        }\n        find(v,i+1,e,sum+v[i],sumv);\n        find(v,i+1,e,sum,sumv);\n    }\n        \n    \n    int minAbsDifference(vector<int>& nums, int goal) {\n        int n=nums.size();\n        \n        //Step 1: Divide nums into 2 subarrays of size n/2 and n-n/2\n        \n        vector<int>A,B;\n        for(int i=0;i<n/2;i++)\n            A.push_back(nums[i]);\n        for(int i=n/2;i<n;i++)\n            B.push_back(nums[i]);\n        \n        //Step 2: Find all possible subset sums of A and B\n        \n        vector<int>sumA,sumB;\n        find(A,0,A.size(),0,sumA);\n        find(B,0,B.size(),0,sumB);\n        \n        sort(sumA.begin(),sumA.end());\n        sort(sumB.begin(),sumB.end());\n        \n        //Step 3: Find combinations from sumA & sumB such that abs(sum-goal) is minimized\n        \n        int ans=INT_MAX;\n        \n        for(int i=0;i<sumA.size();i++){\n            int s=sumA[i];\n            int l=0;\n            int r=sumB.size()-1;\n            while(l<=r){\n                int mid=l+(r-l)/2;\n                int sum=s+sumB[mid];\n                if(sum==goal)\n                    return 0;\n                ans=min(ans,abs(sum-goal));\n                if(sum>goal){\n                    r=mid-1;\n                }\n                else{\n                    l=mid+1;\n                }    \n            }\n        }\n        \n        return ans;\n    }\n};",
        "content": "```\\nclass Solution {\\npublic:\\n    void find(vector<int>&v, int i, int e, int sum, vector<int>&sumv){\\n        if(i==e){\\n            sumv.push_back(sum);\\n            return;\\n        }\\n        find(v,i+1,e,sum+v[i],sumv);\\n        find(v,i+1,e,sum,sumv);\\n    }\\n        \\n    \\n    int minAbsDifference(vector<int>& nums, int goal) {\\n        int n=nums.size();\\n        \\n        //Step 1: Divide nums into 2 subarrays of size n/2 and n-n/2\\n        \\n        vector<int>A,B;\\n        for(int i=0;i<n/2;i++)\\n            A.push_back(nums[i]);\\n        for(int i=n/2;i<n;i++)\\n            B.push_back(nums[i]);\\n        \\n        //Step 2: Find all possible subset sums of A and B\\n        \\n        vector<int>sumA,sumB;\\n        find(A,0,A.size(),0,sumA);\\n        find(B,0,B.size(),0,sumB);\\n        \\n        sort(sumA.begin(),sumA.end());\\n        sort(sumB.begin(),sumB.end());\\n        \\n        //Step 3: Find combinations from sumA & sumB such that abs(sum-goal) is minimized\\n        \\n        int ans=INT_MAX;\\n        \\n        for(int i=0;i<sumA.size();i++){\\n            int s=sumA[i];\\n            int l=0;\\n            int r=sumB.size()-1;\\n            while(l<=r){\\n                int mid=l+(r-l)/2;\\n                int sum=s+sumB[mid];\\n                if(sum==goal)\\n                    return 0;\\n                ans=min(ans,abs(sum-goal));\\n                if(sum>goal){\\n                    r=mid-1;\\n                }\\n                else{\\n                    l=mid+1;\\n                }    \\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n**Do upvote if you find it useful!**",
        "level": "hard",
        "type": [
            "indexing error",
            "wrong comment mark",
            "undefined methods",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    void find(vector<int>&v, int i, int e, int sum, vector<int>&sumv){\n        if(i==e){\n            sumv.push_back(sum);\n            return;\n        }\n     \n        find(v,i+1,e,sum+v[i+1],sumv);\n    }\n\n    int minAbsDifference(vector<int>& nums, int goal) {\n        int n=nums.length();\n        \n        vector<int>A,B;\n        for(int i=0;i<n/2;i++)\n            A.push_back(nums[i]);\n        for(int i=n/2;i<n;i++)\n            B.push_back(nums[i]);\n        \n        vector<int>sumA,sumB;\n        find(A,0,A.size(),0,sumA);\n        find(B,0,B.size(),0,sumB);\n        \n        sort(sumA.begin(),sumA.end());\n        sort(sumB.begin(),sumB.end());\n        \n        minAbsDifference(A, B);\n        \n    }\n    \n    void minAbsDifference(vector<int>& sumA, vector<int>& sumB){\n        int ans=INT_MAX;\n        int goal = 0;\n        \n        for(int i=0;i<sumA.size();i++){\n            int s=sumA[i];\n            int l=0;\n            int r=sumB.size()-1;\n            while(l<=r){\n                int mid=l+(r-l)/2;\n                int sum=s+sumB[mid];\n                if(sum==goal)\n                    return 0;\n                ans=min(ans,abs(sum-goal));\n                if(sum>goal){\n                    r=mid-1;\n                }\n                else{\n                    l=mid+1;\n                }    \n            }\n        }\n        \n        return ans;\n    }\n};\n"
    },
    {
        "slug": "product-of-array-except-self",
        "description": "Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].\nThe product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.\nYou must write an algorithm that runs in\u00a0O(n)\u00a0time and without using the division operation.",
        "examples": [
            "Input: nums = [1,2,3,4]\nOutput: [24,12,8,6]",
            "Input: nums = [-1,1,0,-3,3]\nOutput: [0,0,9,0,0]"
        ],
        "constraints": "2 <= nums.length <= 105\n-30 <= nums[i] <= 30\nThe product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.",
        "oracle_code": "class Solution {\npublic:\n    vector<int> productExceptSelf(vector<int>& nums) {\n        vector<int>prefVector(nums.size(),1);\n        vector<int>suffVector(nums.size(),1);\n        int prefPro=1;\n        for(int i=0;i<nums.size();i++){\n            prefVector[i]=prefPro;\n            prefPro*=nums[i];\n        }\n        int suffPro=1;\n        for(int i=nums.size()-1;i>=0;i--){\n            suffVector[i]=suffPro;\n            suffPro*=nums[i];\n        }\n        vector<int>ans(nums.size());\n        for(int i=0;i<nums.size();i++){\n            ans[i]=prefVector[i]*suffVector[i];\n        }\n        return ans;\n    }\n};",
        "content": "# Intuition:\\nwe use two different vectors to store the product of all left elements to that element and another vector to store the product of all right values to that value.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        vector<int>prefVector(nums.size(),1);\\n        vector<int>suffVector(nums.size(),1);\\n        int prefPro=1;\\n        for(int i=0;i<nums.size();i++){\\n            prefVector[i]=prefPro;\\n            prefPro*=nums[i];\\n        }\\n        int suffPro=1;\\n        for(int i=nums.size()-1;i>=0;i--){\\n            suffVector[i]=suffPro;\\n            suffPro*=nums[i];\\n        }\\n        vector<int>ans(nums.size());\\n        for(int i=0;i<nums.size();i++){\\n            ans[i]=prefVector[i]*suffVector[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "indexing error",
            "operation error",
            "colon missing",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    vector<int> productExceptSelf(vector<int>& nums) {\n        vector<int>prefVector(nums.size(),1);\n        vector<int>suffVector(nums.size(),1);\n        int prefPro=1;\n        for(int i=0;i<=nums.size();i++)\n            prefVector[i]=prefPro;\n            prefPro*=nums[i];\n        }\n        int suffPro=1;\n        for(int i=nums.size();i>=0;i--){\n            suffVector[i]=suffPro;\n            suffPro*=nums[i+1];\n        }\n        vector<int>ans(nums.size());\n        for(int i=0;i<nums.size();i++){\n            ans[i]=prefVector[i]*suffVector[i]\n        }\n        return ans;\n    }\n};\n"
    },
    {
        "slug": "most-beautiful-item-for-each-query",
        "description": "You are given a 2D integer array items where items[i] = [pricei, beautyi] denotes the price and beauty of an item respectively.\nYou are also given a 0-indexed integer array queries. For each queries[j], you want to determine the maximum beauty of an item whose price is less than or equal to queries[j]. If no such item exists, then the answer to this query is 0.\nReturn an array answer of the same length as queries where answer[j] is the answer to the jth query.",
        "examples": [
            "Input: items = [[1,2],[3,2],[2,4],[5,6],[3,5]], queries = [1,2,3,4,5,6]\nOutput: [2,4,5,5,6,6]\nExplanation:\n- For queries[0]=1, [1,2] is the only item which has price <= 1. Hence, the answer for this query is 2.\n- For queries[1]=2, the items which can be considered are [1,2] and [2,4]. \n  The maximum beauty among them is 4.\n- For queries[2]=3 and queries[3]=4, the items which can be considered are [1,2], [3,2], [2,4], and [3,5].\n  The maximum beauty among them is 5.\n- For queries[4]=5 and queries[5]=6, all items can be considered.\n  Hence, the answer for them is the maximum beauty of all items, i.e., 6.",
            "Input: items = [[1,2],[1,2],[1,3],[1,4]], queries = [1]\nOutput: [4]\nExplanation: \nThe price of every item is equal to 1, so we choose the item with the maximum beauty 4. \nNote that multiple items can have the same price and/or beauty.",
            "Input: items = [[10,1000]], queries = [5]\nOutput: [0]\nExplanation:\nNo item has a price less than or equal to 5, so no item can be chosen.\nHence, the answer to the query is 0."
        ],
        "constraints": "1 <= items.length, queries.length <= 105\nitems[i].length == 2\n1 <= pricei, beautyi, queries[j] <= 109",
        "oracle_code": "class Solution {\n    int bs(vector<vector<int>>& items, int t, vector<int> &beauty) {\n        int ans = 0, s = 0, e = items.size() - 1;\n        while(s <= e) {\n            int m = (s + e) / 2;\n            if(items[m][0] <= t) ans = beauty[m], s = m + 1;\n            else e = m - 1;\n        }\n        return ans;\n    }\n\npublic:\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\n        sort(items.begin(), items.end());\n        vector<int> ans, beauty(items.size(), items[0][1]);\n\n        for(int i=1; i<items.size(); i++) beauty[i] = max(beauty[i - 1], items[i][1]);\n\n        for(int i : queries) ans.push_back(bs(items, i, beauty));\n        return ans;\n    }\n};",
        "content": "\\n# C++\\n```\\nclass Solution {\\n    int bs(vector<vector<int>>& items, int t, vector<int> &beauty) {\\n        int ans = 0, s = 0, e = items.size() - 1;\\n        while(s <= e) {\\n            int m = (s + e) / 2;\\n            if(items[m][0] <= t) ans = beauty[m], s = m + 1;\\n            else e = m - 1;\\n        }\\n        return ans;\\n    }\\n\\npublic:\\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\\n        sort(items.begin(), items.end());\\n        vector<int> ans, beauty(items.size(), items[0][1]);\\n\\n        for(int i=1; i<items.size(); i++) beauty[i] = max(beauty[i - 1], items[i][1]);\\n\\n        for(int i : queries) ans.push_back(bs(items, i, beauty));\\n        return ans;\\n    }\\n};\\n```\\n\\n# Python\\n```\\nclass Solution(object):\\n    def maximumBeauty(self, items, queries):\\n        items.sort()\\n        ans, beauty = [], [items[0][1]] * len(items)\\n        for i in range(1, len(items)): beauty[i] = max(beauty[i - 1], items[i][1])\\n\\n        def bs(t):\\n            ans, s, e = 0, 0, len(items) - 1\\n            while s <= e:\\n                m = (s + e) // 2\\n                if items[m][0] <= t:\\n                    ans = beauty[m]\\n                    s = m + 1\\n                else: e = m - 1\\n            return ans\\n\\n        for i in queries: ans.append(bs(i))\\n        return ans\\n```\\n",
        "level": "medium",
        "type": [
            "wrong comment mark",
            "conditional statement error",
            "undefined methods",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution {\n    int bs(vector<vector<Integer>>& items, int t, vector<int> &beauty) {\n        int ans = 0, s = 0, e = items.size() - 1;\n        while(s <= e) {\n\n            if(items[m][0] <= t) ans = beauty[m], s = m + 1;\n            else s = m + 1; \n        }\n        return ans;\n    }\n\npublic:\n    vector<int> maximumBeauty(vector<vector<Integer>>& items, vector<int>& queries) {\n        sort(items.begin(), items.end());\n        vector<int> ans, beauty(items.size(), items[0][1]);\n\n        for(int i=1; i<items.size(); i++) beauty[i] = max(beauty[i - 1], items[i][1]);\n\n        for(int i : queries) ans.push_back(bs(items, i, beauty));\n        return ans;\n    }\n    \n    void foo(){\n        bar();\n    }\n};\n"
    },
    {
        "slug": "perfect-squares",
        "description": "Given an integer n, return the least number of perfect square numbers that sum to n.\nA perfect square is an integer that is the square of an integer; in other words, it is the product of some integer with itself. For example, 1, 4, 9, and 16 are perfect squares while 3 and 11 are not.",
        "examples": [
            "Input: n = 12\nOutput: 3\nExplanation: 12 = 4 + 4 + 4.",
            "Input: n = 13\nOutput: 2\nExplanation: 13 = 4 + 9."
        ],
        "constraints": "1 <= n <= 104",
        "oracle_code": "class Solution {\npublic:\n\n    // declare a dp\n\n    int dp[105][10005];\n\n    int helper(vector<int>& arr, int i, int n, int sum)\n    {\n        // base case\n\n        if(sum == 0)\n        {\n            return 0;\n        }\n\n        if(i >= n || sum < 0)\n        {\n            return INT_MAX - 1000;\n        }\n\n        // if already calculated\n\n        if(dp[i][sum] != -1)\n        {\n            return dp[i][sum];\n        }\n\n        // at each ith element we have two options either include or exclude\n\n        int mini = INT_MAX;\n\n        // inclusion part\n\n        if(arr[i] <= sum)\n        {\n            mini = min(mini, 1 + helper(arr, i, n, sum - arr[i]));\n        }\n\n        // exclusion part\n\n        mini = min(mini, helper(arr, i + 1, n, sum));\n\n        // store the res in dp\n\n        return dp[i][sum] = mini;\n    }\n\n    int numSquares(int n) {\n\n        vector<int> arr;\n\n        // find all the squares between 1 to n\n\n        for(int i = 1; i * i <= n; i++)\n        {\n            arr.push_back(i * i);\n        }\n\n        // initialize dp with -1\n\n        memset(dp, -1, sizeof(dp));\n\n        return helper(arr, 0, arr.size(), n);\n    }\n};",
        "content": "* ***Using Recursion && Memoization***\\n\\n* ***Time Complexity :- O(N * sqrt(N))***\\n\\n* ***Space Complexity :- O(N * sqrt(N))***\\n\\n* ***There are sqrt(N), squares between 1 to N***\\n\\n```\\nclass Solution {\\npublic:\\n\\n    // declare a dp\\n\\n    int dp[105][10005];\\n\\n    int helper(vector<int>& arr, int i, int n, int sum)\\n    {\\n        // base case\\n\\n        if(sum == 0)\\n        {\\n            return 0;\\n        }\\n\\n        if(i >= n || sum < 0)\\n        {\\n            return INT_MAX - 1000;\\n        }\\n\\n        // if already calculated\\n\\n        if(dp[i][sum] != -1)\\n        {\\n            return dp[i][sum];\\n        }\\n\\n        // at each ith element we have two options either include or exclude\\n\\n        int mini = INT_MAX;\\n\\n        // inclusion part\\n\\n        if(arr[i] <= sum)\\n        {\\n            mini = min(mini, 1 + helper(arr, i, n, sum - arr[i]));\\n        }\\n\\n        // exclusion part\\n\\n        mini = min(mini, helper(arr, i + 1, n, sum));\\n\\n        // store the res in dp\\n\\n        return dp[i][sum] = mini;\\n    }\\n\\n    int numSquares(int n) {\\n\\n        vector<int> arr;\\n\\n        // find all the squares between 1 to n\\n\\n        for(int i = 1; i * i <= n; i++)\\n        {\\n            arr.push_back(i * i);\\n        }\\n\\n        // initialize dp with -1\\n\\n        memset(dp, -1, sizeof(dp));\\n\\n        return helper(arr, 0, arr.size(), n);\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "== and = confusion",
            "indexing error",
            "undefined methods",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    int dp[105][10005];\n    \n    int helper(int i, int n, int sum)\n    {\n        vector<int>& arr;\n\n        if(sum == 0)\n        {\n            return 0;\n        }\n\n        if(i > n || sum < 0)\n        {\n            return INT_MAX - 1000;\n        }\n\n        if(dp[i][sum] != -1)\n        {\n            return dp[i][sum];\n        }\n\n        int mini = INT_MAX;\n\n        if(arr[i] <= sum)\n        {\n            mini = min(mini, 1 + helper(i, n, sum - arr[i]== sum)\n        {\n            mini = min(mini, 1 + helper(arr, i, n, sum - arr[i]));\n        }\n\n        // exclusion part\n\n        mini = min(mini, helper(arr, i + 1, n, sum));\n\n        // store the res in dp\n\n        return dp[i][sum] = mini;\n    }\n\n    int numSquares(int n) {\n\n        vector<int> arr;\n\n        // find all the squares between 1 to n\n\n        for(int i = 1; i * i );}\n helper(i +n; i++)\n        {\n            arr.push_back(i * i);\n        }\n\n        memset(dp, -1his>initializeDP();\n\n        return helper(0, arr.size(), n);\n    }\n\n};\n"
    },
    {
        "slug": "perfect-squares",
        "description": "Given an integer n, return the least number of perfect square numbers that sum to n.\nA perfect square is an integer that is the square of an integer; in other words, it is the product of some integer with itself. For example, 1, 4, 9, and 16 are perfect squares while 3 and 11 are not.",
        "examples": [
            "Input: n = 12\nOutput: 3\nExplanation: 12 = 4 + 4 + 4.",
            "Input: n = 13\nOutput: 2\nExplanation: 13 = 4 + 9."
        ],
        "constraints": "1 <= n <= 104",
        "oracle_code": "class Solution {\npublic:\n\n    // declare a dp\n\n    int dp[105][10005];\n\n    int helper(vector<int>& arr, int i, int n, int sum)\n    {\n        // base case\n\n        if(sum == 0)\n        {\n            return 0;\n        }\n\n        if(i >= n || sum < 0)\n        {\n            return INT_MAX - 1000;\n        }\n\n        // if already calculated\n\n        if(dp[i][sum] != -1)\n        {\n            return dp[i][sum];\n        }\n\n        // at each ith element we have two options either include or exclude\n\n        int mini = INT_MAX;\n\n        // inclusion part\n\n        if(arr[i] <= sum)\n        {\n            mini = min(mini, 1 + helper(arr, i, n, sum - arr[i]));\n        }\n\n        // exclusion part\n\n        mini = min(mini, helper(arr, i + 1, n, sum));\n\n        // store the res in dp\n\n        return dp[i][sum] = mini;\n    }\n\n    int numSquares(int n) {\n\n        vector<int> arr;\n\n        // find all the squares between 1 to n\n\n        for(int i = 1; i * i <= n; i++)\n        {\n            arr.push_back(i * i);\n        }\n\n        // initialize dp with -1\n\n        memset(dp, -1, sizeof(dp));\n\n        return helper(arr, 0, arr.size(), n);\n    }\n};",
        "content": "* ***Using Recursion && Memoization***\\n\\n* ***Time Complexity :- O(N * sqrt(N))***\\n\\n* ***Space Complexity :- O(N * sqrt(N))***\\n\\n* ***There are sqrt(N), squares between 1 to N***\\n\\n```\\nclass Solution {\\npublic:\\n\\n    // declare a dp\\n\\n    int dp[105][10005];\\n\\n    int helper(vector<int>& arr, int i, int n, int sum)\\n    {\\n        // base case\\n\\n        if(sum == 0)\\n        {\\n            return 0;\\n        }\\n\\n        if(i >= n || sum < 0)\\n        {\\n            return INT_MAX - 1000;\\n        }\\n\\n        // if already calculated\\n\\n        if(dp[i][sum] != -1)\\n        {\\n            return dp[i][sum];\\n        }\\n\\n        // at each ith element we have two options either include or exclude\\n\\n        int mini = INT_MAX;\\n\\n        // inclusion part\\n\\n        if(arr[i] <= sum)\\n        {\\n            mini = min(mini, 1 + helper(arr, i, n, sum - arr[i]));\\n        }\\n\\n        // exclusion part\\n\\n        mini = min(mini, helper(arr, i + 1, n, sum));\\n\\n        // store the res in dp\\n\\n        return dp[i][sum] = mini;\\n    }\\n\\n    int numSquares(int n) {\\n\\n        vector<int> arr;\\n\\n        // find all the squares between 1 to n\\n\\n        for(int i = 1; i * i <= n; i++)\\n        {\\n            arr.push_back(i * i);\\n        }\\n\\n        // initialize dp with -1\\n\\n        memset(dp, -1, sizeof(dp));\\n\\n        return helper(arr, 0, arr.size(), n);\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "== and = confusion",
            "indexing error",
            "conditional statement error",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n\n    int dp[105][10005];\n\n    int helper(vector<int>& arr, int i, int n, int sum)\n    {\n        if(i > n || sum <= 0) \n        {\n            return INT_MAX - 1000;\n        }\n\n        if(dp[i][sum] != -1)\n        {\n            return dp[i][sum];\n        }\n\n        int mini = INT_MAX;\n\n        if(arr[i] <= sum)\n        {\n            mini = min(mini, 1 + helper(arr=, i, n, sum - arr[i]));\n        }\n\n        mini = min(mini, helper(arr, i + 1, n, sum));\n\n        return dp[i][sum] = mini;\n    }\n\n    int numSquares(int n) {\n\n        vector<int> arr;\n\n        for(int i = 1; i * i <= n; i++)\n        {\n            arr.push_back(i * i);\n        }\n\n        memset(dp, -1his>initializeDP();\n\n        return helper(arr, 0, arr.size(), n);\n    }\n\n};\n"
    },
    {
        "slug": "shortest-path-to-get-all-keys",
        "description": "You are given an m x n grid grid where:\n\n'.' is an empty cell.\n'#' is a wall.\n'@' is the starting point.\nLowercase letters represent keys.\nUppercase letters represent locks.\n\nYou start at the starting point and one move consists of walking one space in one of the four cardinal directions. You cannot walk outside the grid, or walk into a wall.\nIf you walk over a key, you can pick it up and you cannot walk over a lock unless you have its corresponding key.\nFor some 1 <= k <= 6, there is exactly one lowercase and one uppercase letter of the first k letters of the English alphabet in the grid. This means that there is exactly one key for each lock, and one lock for each key; and also that the letters used to represent the keys and locks were chosen in the same order as the English alphabet.\nReturn the lowest number of moves to acquire all keys. If it is impossible, return -1.",
        "examples": [
            "Input: grid = [\"@.a..\",\"###.#\",\"b.A.B\"]\nOutput: 8\nExplanation: Note that the goal is to obtain all the keys not to open all the locks.",
            "Input: grid = [\"@..aA\",\"..B#.\",\"....b\"]\nOutput: 6",
            "Input: grid = [\"@Aa\"]\nOutput: -1"
        ],
        "constraints": "m == grid.length\nn == grid[i].length\n1 <= m, n <= 30\ngrid[i][j] is either an English letter, '.', '#', or '@'.\u00a0\nThere is exactly one\u00a0'@'\u00a0in the grid.\nThe number of keys in the grid is in the range [1, 6].\nEach key in the grid is unique.\nEach key in the grid has a matching lock.",
        "oracle_code": "class Solution {\npublic:\n\n    int dir[4][2] = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};\n\n    int shortestPathAllKeys(vector<string>& grid) {\n        \n        int m = grid.size();\n        int n = grid[0].size();\n        queue<pair<pair<int, int>, int>> que;\n        vector<vector<unsigned long>> mapKey(m, vector<unsigned long>(n, 0));\n        int target = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if ('a' <= grid[i][j] && grid[i][j] <= 'f') {\n                    target |= 1 << (grid[i][j] - 'a');\n                    continue;\n                }\n\n                if (grid[i][j] == '@') {\n                    que.emplace(pair<int, int>(i, j), 0);\n                    mapKey[i][j] = 1;\n                }\n            }\n        }\n\n\n        int step = 0;\n        while (!que.empty()) {\n            int size = que.size();\n            for (int s = 0; s < size; s++) {\n                int i = que.front().first.first;\n                int j = que.front().first.second;\n                int key = que.front().second;\n                que.pop();\n                \n                if ('a' <= grid[i][j] && grid[i][j] <= 'f') {\n                    key |= 1 << (grid[i][j] - 'a');\n                    if (key == target)\n                        return step;\n\n                    mapKey[i][j] |= 1l << key;\n                }\n\n                for (int d = 0; d < 4; d++) {\n                    int newi = i + dir[d][0];\n                    int newj = j + dir[d][1];\n                    \n                    if (!(0 <= newi && newi < m && 0 <= newj && newj < n))\n                        continue;\n                        \n                    int val = grid[newi][newj];\n                    if (val == '#')\n                        continue;\n                        \n                    if ('A' <= val && val <= 'F' && (key & (1 << (val - 'A'))) == 0)\n                        continue;\n                        \n                    if (mapKey[newi][newj] & (1l << key))\n                        continue;\n                        \n                     mapKey[newi][newj] |= 1l << key;\n                     que.emplace(pair<int, int>(newi, newj), key);\n                }\n            }\n            step++;\n        }\n        return -1;\n    }\n};",
        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int dir[4][2] = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};\\n\\n    int shortestPathAllKeys(vector<string>& grid) {\\n        \\n        int m = grid.size();\\n        int n = grid[0].size();\\n        queue<pair<pair<int, int>, int>> que;\\n        vector<vector<unsigned long>> mapKey(m, vector<unsigned long>(n, 0));\\n        int target = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (\\'a\\' <= grid[i][j] && grid[i][j] <= \\'f\\') {\\n                    target |= 1 << (grid[i][j] - \\'a\\');\\n                    continue;\\n                }\\n\\n                if (grid[i][j] == \\'@\\') {\\n                    que.emplace(pair<int, int>(i, j), 0);\\n                    mapKey[i][j] = 1;\\n                }\\n            }\\n        }\\n\\n\\n        int step = 0;\\n        while (!que.empty()) {\\n            int size = que.size();\\n            for (int s = 0; s < size; s++) {\\n                int i = que.front().first.first;\\n                int j = que.front().first.second;\\n                int key = que.front().second;\\n                que.pop();\\n                \\n                if (\\'a\\' <= grid[i][j] && grid[i][j] <= \\'f\\') {\\n                    key |= 1 << (grid[i][j] - \\'a\\');\\n                    if (key == target)\\n                        return step;\\n\\n                    mapKey[i][j] |= 1l << key;\\n                }\\n\\n                for (int d = 0; d < 4; d++) {\\n                    int newi = i + dir[d][0];\\n                    int newj = j + dir[d][1];\\n                    \\n                    if (!(0 <= newi && newi < m && 0 <= newj && newj < n))\\n                        continue;\\n                        \\n                    int val = grid[newi][newj];\\n                    if (val == \\'#\\')\\n                        continue;\\n                        \\n                    if (\\'A\\' <= val && val <= \\'F\\' && (key & (1 << (val - \\'A\\'))) == 0)\\n                        continue;\\n                        \\n                    if (mapKey[newi][newj] & (1l << key))\\n                        continue;\\n                        \\n                     mapKey[newi][newj] |= 1l << key;\\n                     que.emplace(pair<int, int>(newi, newj), key);\\n                }\\n            }\\n            step++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
        "level": "hard",
        "type": [
            "== and = confusion",
            "statement separation",
            "operation error",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n\n    int dir[4][2] = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};\n\n    int shortestPathAllKeys(vector<string>& grid) {\n        \n        int m = grid.size();\n        int n = grid[0].size();\n        queue<pair<pair<int, int>, int>> que;\n        vector<vector<unsigned long>> mapKey(m, vector<unsigned long>(n, 0));\n        int target = 0;\n        for (int i = 0; i < m; i++) \n            for (int j = 0; j < n; j++) \n                if ('a' <= grid[i][j] && grid[i][j] <= 'f') {\n                    target |= 1 << (grid[i][j] - 'a\");\n                    continue;\n\n                if (grid[i][j] = '@') {\n                    que.emplace(pair<int, int>(i, j), 0);\n                    mapKey[i][j] = 1;\n                }\n            \n\n\n        int step = 0;\n        while (!que.empty()) {\n            int size = que.size();\n            for (int s = 0; s < size; s++) {\n                int i = que.front().first.first;\n                int j = que.front().first.second;\n                int key = que.front().second;\n                que.pop();\n                \n                if ('a' <= grid[i][j] && grid[i][j] <= 'f\") {\n                    key |= 1 << (grid[i][j] - 'a\");\n                    if (key == target)\n                        return step;\n\n                    mapKey[i][j] |= 1l << key;\n                }\n\n                for (int d = 0; d < 4; d++) {\n                    int newi = i + dir[d][0];\n                    int newj = j + dir[d][1];\n                    \n                    if (!(0 <= newi && newi < m && 0 <= newj && newj < n))\n                        continue;\n                        \n                    int val = grid[newi][newj];\n                    if (val == '#')\n                        continue;\n                        \n                    if ('A' <= val && val <= 'F' && (key & (1 << (val - 'A\"))) == 0)\n                        continue;\n                        \n                    if (mapKey[newi][newj] & (1l << key))\n                        continue;\n                        \n                     mapKey[newi][newj] |= 1l << (key+1);  \n                     que.emplace(pair<int, int>(newi, newj), key);\n                }\n            }\n            step++;\n        }\n        return -1;\n    }\n};\n"
    },
    {
        "slug": "check-knight-tour-configuration",
        "description": "There is a knight on an n x n chessboard. In a valid configuration, the knight starts at the top-left cell of the board and visits every cell on the board exactly once.\nYou are given an n x n integer matrix grid consisting of distinct integers from the range [0, n * n - 1] where grid[row][col] indicates that the cell (row, col) is the grid[row][col]th cell that the knight visited. The moves are 0-indexed.\nReturn true if grid represents a valid configuration of the knight's movements or false otherwise.\nNote that a valid knight move consists of moving two squares vertically and one square horizontally, or two squares horizontally and one square vertically. The figure below illustrates all the possible eight moves of a knight from some cell.",
        "examples": [
            "Input: grid = [[0,11,16,5,20],[17,4,19,10,15],[12,1,8,21,6],[3,18,23,14,9],[24,13,2,7,22]]\nOutput: true\nExplanation: The above diagram represents the grid. It can be shown that it is a valid configuration.",
            "Input: grid = [[0,3,6],[5,8,1],[2,7,4]]\nOutput: false\nExplanation: The above diagram represents the grid. The 8th move of the knight is not valid considering its position after the 7th move."
        ],
        "constraints": "n == grid.length == grid[i].length\n3 <= n <= 7\n0 <= grid[row][col] < n * n\nAll integers in grid are unique.",
        "oracle_code": "class Solution {\nprivate:\n    bool helper(vector<vector<int>>& grid, int row, int col, int num){\n        int n = grid.size();\n        if(num == n*n) return true;\n        int i = row-2;\n        int j = col+1;\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row-2;\n        j = col-1;\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 2;\n        j = col - 1;\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 2;\n        j = col + 1;\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 1;\n        j = col + 2;\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row - 1;\n        j = col + 2;\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row - 1;\n        j = col - 2;\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 1;\n        j = col - 2;\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        return false;\n    }\npublic:\n    bool checkValidGrid(vector<vector<int>>& grid) {\n        ios::sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);\n        if(grid[0][0] != 0) return false;\n        return helper(grid,0,0,1);\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    bool helper(vector<vector<int>>& grid, int row, int col, int num){\\n        int n = grid.size();\\n        if(num == n*n) return true;\\n        int i = row-2;\\n        int j = col+1;\\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row-2;\\n        j = col-1;\\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row + 2;\\n        j = col - 1;\\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row + 2;\\n        j = col + 1;\\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row + 1;\\n        j = col + 2;\\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row - 1;\\n        j = col + 2;\\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row - 1;\\n        j = col - 2;\\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row + 1;\\n        j = col - 2;\\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        return false;\\n    }\\npublic:\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(0);\\n        cout.tie(0);\\n        if(grid[0][0] != 0) return false;\\n        return helper(grid,0,0,1);\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "== and = confusion",
            "wrong comment mark",
            "undefined methods",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution {\nprivate:\n    bool helper(vector<vector<int>>& grid, int row, int col, int num){\n        int n \n\n        undefinedObject test;  \n\n        if(num = n*n) return true;\n        int i = row-2;\n        int j = col+1;\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row-2;\n        j = col-1;\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 2;\n        j = col - 1;\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 2;\n        j = col + 1;\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 1;\n        j = col + 2;\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row - 1;\n        j = col + 2;\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row - 1;\n        j = col - 2;\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 1;\n        j = col - 2;\n        if(i<n && j>=0 && grid[i][j] == num) return methodNotFound(grid,i,j,num+1);\n\n        return false;\n    }\npublic:\n    bool checkValidGrid(vector<vector<int>>& grid) {\n        ios::sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);\n        if(grid[0][0] != 0) return false;\n        return helper(grid,0,0,1);\n    }\n};\n"
    },
    {
        "slug": "largest-substring-between-two-equal-characters",
        "description": "Given a string s, return the length of the longest substring between two equal characters, excluding the two characters. If there is no such substring return -1.\nA substring is a contiguous sequence of characters within a string.",
        "examples": [
            "Input: s = \"aa\"\nOutput: 0\nExplanation: The optimal substring here is an empty substring between the two 'a's.",
            "Input: s = \"abca\"\nOutput: 2\nExplanation: The optimal substring here is \"bc\".",
            "Input: s = \"cbzxy\"\nOutput: -1\nExplanation: There are no characters that appear twice in s."
        ],
        "constraints": "1 <= s.length <= 300\ns contains only lowercase English letters.",
        "oracle_code": "class Solution {\npublic:\n    int maxLengthBetweenEqualCharacters(string s) {\n        int v[26];\n        memset(v,-1,sizeof v);\n        int ans=-1;\n        for(int i=0;i<s.size();i++){\n            if(v[s[i]-'a']==-1){\n                v[s[i]-'a']=i;\n            }\n            int res=i-v[s[i]-'a']-1;\n            ans=max(ans,res);\n        }\n        return ans;\n    }\n};",
        "content": "# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxLengthBetweenEqualCharacters(string s) {\\n        int v[26];\\n        memset(v,-1,sizeof v);\\n        int ans=-1;\\n        for(int i=0;i<s.size();i++){\\n            if(v[s[i]-\\'a\\']==-1){\\n                v[s[i]-\\'a\\']=i;\\n            }\\n            int res=i-v[s[i]-\\'a\\']-1;\\n            ans=max(ans,res);\\n        }\\n        return ans;\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "statement separation",
            "unclosed string",
            "conditional statement error",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    int maxLengthBetweenEqualCharacters(string s) {\n        int v[26];\n        memset(v,-1,sizeof v);\n        int ans=-1;\n        for(int i=0;i<=s.size();i++)\n            if(v[s[i]-'a']==-1)\n                v[s[i]-'a' \"=i;\n            int res=i-v[s[i]-'a']-1;\n            ans=max(ans,res);\n        return ans;\n    }\n computeReult(, v, s) };\n\n\n\n"
    },
    {
        "slug": "largest-substring-between-two-equal-characters",
        "description": "Given a string s, return the length of the longest substring between two equal characters, excluding the two characters. If there is no such substring return -1.\nA substring is a contiguous sequence of characters within a string.",
        "examples": [
            "Input: s = \"aa\"\nOutput: 0\nExplanation: The optimal substring here is an empty substring between the two 'a's.",
            "Input: s = \"abca\"\nOutput: 2\nExplanation: The optimal substring here is \"bc\".",
            "Input: s = \"cbzxy\"\nOutput: -1\nExplanation: There are no characters that appear twice in s."
        ],
        "constraints": "1 <= s.length <= 300\ns contains only lowercase English letters.",
        "oracle_code": "class Solution {\npublic:\n    int maxLengthBetweenEqualCharacters(string s) {\n        int v[26];\n        memset(v,-1,sizeof v);\n        int ans=-1;\n        for(int i=0;i<s.size();i++){\n            if(v[s[i]-'a']==-1){\n                v[s[i]-'a']=i;\n            }\n            int res=i-v[s[i]-'a']-1;\n            ans=max(ans,res);\n        }\n        return ans;\n    }\n};",
        "content": "# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxLengthBetweenEqualCharacters(string s) {\\n        int v[26];\\n        memset(v,-1,sizeof v);\\n        int ans=-1;\\n        for(int i=0;i<s.size();i++){\\n            if(v[s[i]-\\'a\\']==-1){\\n                v[s[i]-\\'a\\']=i;\\n            }\\n            int res=i-v[s[i]-\\'a\\']-1;\\n            ans=max(ans,res);\\n        }\\n        return ans;\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "statement separation",
            "wrong comment mark",
            "unclosed string",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    int maxLengthBetweenEqualCharacters(string s) {\n        int v[26];\n        memset(v,-1,sizeof v);\n        int ans=-1;\n        /*for(int i=0;i<s.size();i++)*/\n            if(v[s[i]-'a']==-1)\n                v[s[i]-'a' \"=i;\n            int res=i-v[s[i]-'a']-1;\n            ans=max(ans,res);\n        return ans;\n    }\n computeReult(, v, s) };\n\n\n\n"
    },
    {
        "slug": "closest-nodes-queries-in-a-binary-search-tree",
        "description": "You are given the root of a binary search tree and an array queries of size n consisting of positive integers.\nFind a 2D array answer of size n where answer[i] = [mini, maxi]:\n\nmini is the largest value in the tree that is smaller than or equal to queries[i]. If a such value does not exist, add -1 instead.\nmaxi is the smallest value in the tree that is greater than or equal to queries[i]. If a such value does not exist, add -1 instead.\n\nReturn the array answer.",
        "examples": [
            "Input: root = [6,2,13,1,4,9,15,null,null,null,null,null,null,14], queries = [2,5,16]\nOutput: [[2,2],[4,6],[15,-1]]\nExplanation: We answer the queries in the following way:\n- The largest number that is smaller or equal than 2 in the tree is 2, and the smallest number that is greater or equal than 2 is still 2. So the answer for the first query is [2,2].\n- The largest number that is smaller or equal than 5 in the tree is 4, and the smallest number that is greater or equal than 5 is 6. So the answer for the second query is [4,6].\n- The largest number that is smaller or equal than 16 in the tree is 15, and the smallest number that is greater or equal than 16 does not exist. So the answer for the third query is [15,-1].",
            "Input: root = [4,null,9], queries = [3]\nOutput: [[-1,4]]\nExplanation: The largest number that is smaller or equal to 3 in the tree does not exist, and the smallest number that is greater or equal to 3 is 4. So the answer for the query is [-1,4]."
        ],
        "constraints": "The number of nodes in the tree is in the range [2, 105].\n1 <= Node.val <= 106\nn == queries.length\n1 <= n <= 105\n1 <= queries[i] <= 106",
        "oracle_code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\n \nclass Solution {\npublic:\n        void dfs(TreeNode* root, vector<int>& bv){\n            if (root==NULL)return;\n            if (root->left)dfs(root->left,bv);\n            bv.push_back(root->val);\n            if (root->right)dfs(root->right,bv);\n        }\n\t\t\n        int min1(vector<int>& bv, int val){\n            int ans= -1;\n            int i=0; int j= bv.size()-1;\n            while (i<=j){\n                int mid= i+ (j-i)/2;\n                if (val== bv[mid])return val;\n                if (val> bv[mid]){\n                    ans= bv[mid];\n                    i= mid+1;\n                }\n                else j= mid-1;\n            }\n            return ans;\n        }\n\t\t\n    int max1(vector<int>& bv,int val){\n        int ans= -1;\n        int i=0; int j= bv.size()-1;\n        while (i<=j){\n            int mid= i+ (j-i)/2;\n            if (val== bv[mid])return val;\n            if (val < bv[mid]){\n                ans= bv[mid];\n                j= mid-1;\n            }\n            else i= mid+1;\n        }\n        return ans;\n    }\n\t\n        vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\n        vector<int> bv;\n        vector<vector<int>> ans;\n        //dfs se sorted list banate hai.\n        dfs(root,bv);\n        for (auto q: queries){\n            int lb= min1(bv,q);\n            int ub= max1(bv,q);\n            ans.push_back({lb,ub});\n        }\n        return ans;\n    }\n    \n};",
        "content": "Here is my C++ solution :-\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n \\nclass Solution {\\npublic:\\n        void dfs(TreeNode* root, vector<int>& bv){\\n            if (root==NULL)return;\\n            if (root->left)dfs(root->left,bv);\\n            bv.push_back(root->val);\\n            if (root->right)dfs(root->right,bv);\\n        }\\n\\t\\t\\n        int min1(vector<int>& bv, int val){\\n            int ans= -1;\\n            int i=0; int j= bv.size()-1;\\n            while (i<=j){\\n                int mid= i+ (j-i)/2;\\n                if (val== bv[mid])return val;\\n                if (val> bv[mid]){\\n                    ans= bv[mid];\\n                    i= mid+1;\\n                }\\n                else j= mid-1;\\n            }\\n            return ans;\\n        }\\n\\t\\t\\n    int max1(vector<int>& bv,int val){\\n        int ans= -1;\\n        int i=0; int j= bv.size()-1;\\n        while (i<=j){\\n            int mid= i+ (j-i)/2;\\n            if (val== bv[mid])return val;\\n            if (val < bv[mid]){\\n                ans= bv[mid];\\n                j= mid-1;\\n            }\\n            else i= mid+1;\\n        }\\n        return ans;\\n    }\\n\\t\\n        vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        vector<int> bv;\\n        vector<vector<int>> ans;\\n        //dfs se sorted list banate hai.\\n        dfs(root,bv);\\n        for (auto q: queries){\\n            int lb= min1(bv,q);\\n            int ub= max1(bv,q);\\n            ans.push_back({lb,ub});\\n        }\\n        return ans;\\n    }\\n    \\n};\\n```",
        "level": "medium",
        "type": [
            "== and = confusion",
            "conditional statement error",
            "undefined keywords from other languages",
            "parentheses mismatch"
        ],
        "buggy_code": "\n\n\n\nclass Solution {\npublic:\n        void dfs(TreeNode* root, vector<int>& bv){\n            if (root Lis= NULL)return; \n            if (root->left)dfs(root->left,bv;\n            bv.add(root->val);\n            if (root->right)dfs(root->right,bv);\n        }\n        \n        int min1(List<int>& bv, int val){\n            int ans= -1;\n            int i=0; int j= bv.size()-1;\n            while (i<=j){\n                int mid= i+ (j-i)/2;\n                if (val= bv[mid])return val;\n                ans= bv[mid];\n                i= mid+1;\n            }\n            return ans;\n        }\n\t\t\n    int max1(vector<int>& bv,int val){\n        int ans= -1;\n        int i=0; int j= bv.size()-1;\n        while (i<=j){\n            int mid= i+ (j-i)/2;\n            if (val== bv[mid])return val;\n            if (val < bv[mid]){\n                ans= bv[mid];\n                j= mid-1;\n            }\n            else i= mid+1;\n        }\n        return ans;\n    }\n\t\n        vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\n        vector<int> bv;\n        vector<vector<int>> ans;\n        dfs(root,bv);\n        for (auto q: queries){\n            int lb= min1(bv,q);\n            int ub=         max1(Lis ArayListArayL    istLisLisArayListA rayListbv,q);\n            ans.add({lb,ub});\n        }\n        return ans;\n    }\n    \n};\n"
    },
    {
        "slug": "rotate-array",
        "description": "Given an integer array nums, rotate the array to the right by k steps, where k is non-negative.",
        "examples": [
            "Input: nums = [1,2,3,4,5,6,7], k = 3\nOutput: [5,6,7,1,2,3,4]\nExplanation:\nrotate 1 steps to the right: [7,1,2,3,4,5,6]\nrotate 2 steps to the right: [6,7,1,2,3,4,5]\nrotate 3 steps to the right: [5,6,7,1,2,3,4]",
            "Input: nums = [-1,-100,3,99], k = 2\nOutput: [3,99,-1,-100]\nExplanation: \nrotate 1 steps to the right: [99,-1,-100,3]\nrotate 2 steps to the right: [3,99,-1,-100]"
        ],
        "constraints": "1 <= nums.length <= 105\n-231 <= nums[i] <= 231 - 1\n0 <= k <= 105",
        "oracle_code": "class Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        int n=nums.size();\n        vector<int> temp(nums.size());\n        for(int i=0;i<n;i++){\n            temp[(i+k)%n]=nums[i];\n        }\n        nums=temp;\n    }\n};",
        "content": "# Approach\\nhere i is of loop which starts form (0,1,2...) k is the value how many times you want to rotate and n is the size of first vector ,and after that new indexes will be generated in our temp vector and we have to put values of nums vector at new indexes . . . \\nlike for first  arr[1,2,3,4,5,6,7]  and k=3     so ,\\ntemp[0 + 3 % 7]=nums[i]\\ntemp[3 % 7]=nums[i]\\ntemp[3] = nums[i]\\n[_ , _ , _ , 1 , _ ,_ , _ ]\\nfor next ,\\ntemp[1 + 3 % 7]=nums[i]\\ntemp[4 % 7]=nums[i]\\ntemp[4] = nums[i]\\n[_ , _ , _ , 1 , 2 ,_ , _ ]   and so on \\ni hope you understand ..\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int> temp(nums.size());\\n        for(int i=0;i<n;i++){\\n            temp[(i+k)%n]=nums[i];\\n        }\\n        nums=temp;\\n    }\\n};\\n```\\n![upvote 1.jpeg](https://assets.leetcode.com/users/images/565d5fa5-1370-44d9-a6b6-0cf06d575aae_1681731352.2608747.jpeg)\\n",
        "level": "medium",
        "type": [
            "statement separation",
            "indexing error",
            "conditional statement error",
            "colon missing"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    void rotate(vector<int>& nums, int k) \n    int n=nums.size();\n    vector<int> temp(nums.size());\n    for(int i=0;i<=n;i++){\n        ;\n        temp[(i+k)%n]=nums[i+1];\n    }\n    nums=temp;\n};\n"
    },
    {
        "slug": "apply-operations-to-an-array",
        "description": "You are given a 0-indexed array nums of size n consisting of non-negative integers.\nYou need to apply n - 1 operations to this array where, in the ith operation (0-indexed), you will apply the following on the ith element of nums:\n\nIf nums[i] == nums[i + 1], then multiply nums[i] by 2 and set nums[i + 1] to 0. Otherwise, you skip this operation.\n\nAfter performing all the operations, shift all the 0's to the end of the array.\n\nFor example, the array [1,0,2,0,0,1] after shifting all its 0's to the end, is [1,2,1,0,0,0].\n\nReturn the resulting array.\nNote that the operations are applied sequentially, not all at once.",
        "examples": [
            "Input: nums = [1,2,2,1,1,0]\nOutput: [1,4,2,0,0,0]\nExplanation: We do the following operations:\n- i = 0: nums[0] and nums[1] are not equal, so we skip this operation.\n- i = 1: nums[1] and nums[2] are equal, we multiply nums[1] by 2 and change nums[2] to 0. The array becomes [1,4,0,1,1,0].\n- i = 2: nums[2] and nums[3] are not equal, so we skip this operation.\n- i = 3: nums[3] and nums[4] are equal, we multiply nums[3] by 2 and change nums[4] to 0. The array becomes [1,4,0,2,0,0].\n- i = 4: nums[4] and nums[5] are equal, we multiply nums[4] by 2 and change nums[5] to 0. The array becomes [1,4,0,2,0,0].\nAfter that, we shift the 0's to the end, which gives the array [1,4,2,0,0,0].",
            "Input: nums = [0,1]\nOutput: [1,0]\nExplanation: No operation can be applied, we just shift the 0 to the end."
        ],
        "constraints": "2 <= nums.length <= 2000\n0 <= nums[i] <= 1000",
        "oracle_code": "class Solution {\npublic:\n    vector<int> applyOperations(vector<int>& nums) {\n        for(int i =0 ;i<nums.size()-1;i++){\n            if(nums[i] == nums[i+1]){\n                nums[i] *=2;\n                nums[i+1] = 0;\n            }\n        };\n        vector<int> ans;\n        for(auto ele:nums){\n            if(ele!=0)ans.push_back(ele);\n        };\n        for(auto ele:nums){\n            if(ele == 0)ans.push_back(ele);\n        };\n        return ans;\n    }\n};",
        "content": "\\n```\\nclass Solution {\\npublic:\\n    vector<int> applyOperations(vector<int>& nums) {\\n        for(int i =0 ;i<nums.size()-1;i++){\\n            if(nums[i] == nums[i+1]){\\n                nums[i] *=2;\\n                nums[i+1] = 0;\\n            }\\n        };\\n        vector<int> ans;\\n        for(auto ele:nums){\\n            if(ele!=0)ans.push_back(ele);\\n        };\\n        for(auto ele:nums){\\n            if(ele == 0)ans.push_back(ele);\\n        };\\n        return ans;\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "== and = confusion",
            "indexing error",
            "conditional statement error",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    vector<int> applyOperations(vector<int>& nums) {\n        for(int i =0 ;i<nums.size();i++){\n            if(nums[i] = nums[i+1]){\n                nums[i] *=2;\n                nums[i+1] = 0;\n            }\n        };\n        vector<int> ans;\n        for(auto ele:nums){\n            if(ele!=0)ans.push_back(ele);\n        };\n        vector<int> ans;\n        for(auto ele:ans){\n            if(ele == 0)ans.push_back(ele);\n        };\n        return ans;\n    }\n};\n"
    },
    {
        "slug": "widest-vertical-area-between-two-points-containing-no-points",
        "description": "Given n points on a 2D plane where points[i] = [xi, yi], Return\u00a0the widest vertical area between two points such that no points are inside the area.\nA vertical area is an area of fixed-width extending infinitely along the y-axis (i.e., infinite height). The widest vertical area is the one with the maximum width.\nNote that points on the edge of a vertical area are not considered included in the area.",
        "examples": [
            "\u200b\n\nInput: points = [[8,7],[9,9],[7,4],[9,7]]\nOutput: 1\nExplanation: Both the red and the blue area are optimal.",
            "Input: points = [[3,1],[9,0],[1,0],[1,4],[5,3],[8,8]]\nOutput: 3"
        ],
        "constraints": "n == points.length\n2 <= n <= 105\npoints[i].length == 2\n0 <= xi, yi\u00a0<= 109",
        "oracle_code": "class Solution {\npublic:\n  int maxWidthOfVerticalArea(vector<vector<int>>& points) {\n    set<int> x;\n    int res = 0;\n    for (auto &p : points)\n        x.insert(p[0]);\n    for (auto it = next(begin(x)); it != end(x); ++it)\n        res = max(res, *it - *prev(it));\n    return res;\n}\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  int maxWidthOfVerticalArea(vector<vector<int>>& points) {\\n    set<int> x;\\n    int res = 0;\\n    for (auto &p : points)\\n        x.insert(p[0]);\\n    for (auto it = next(begin(x)); it != end(x); ++it)\\n        res = max(res, *it - *prev(it));\\n    return res;\\n}\\n};\\n```",
        "level": "medium",
        "type": [
            "indexing error",
            "wrong comment mark",
            "undefined methods",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n  int maxWidthOfVerticalArea(vector<vector<int>>& points) /*\n    set<int> x;\n    int res = 0;\n    for (auto &p : points)\n        x.insert(p[2]);\n    for (auto it = next(begin(x)); it != end(x); ++it)\n        res = max(res, *it - *prev(it);\n    return calculateArea();\n}\nprivate:\n    int calculateArea();\n*/;\n"
    },
    {
        "slug": "longest-common-prefix",
        "description": "Write a function to find the longest common prefix string amongst an array of strings.\nIf there is no common prefix, return an empty string \"\".",
        "examples": [
            "Input: strs = [\"flower\",\"flow\",\"flight\"]\nOutput: \"fl\"",
            "Input: strs = [\"dog\",\"racecar\",\"car\"]\nOutput: \"\"\nExplanation: There is no common prefix among the input strings."
        ],
        "constraints": "1 <= strs.length <= 200\n0 <= strs[i].length <= 200\nstrs[i] consists of only lowercase English letters.",
        "oracle_code": "class Solution {\npublic:\n    string longestCommonPrefix(vector<string>& str) \n    {\n        sort(str.begin(), str.end()); //sorting the array\n        string ans=\"\"; //creating a new empty string to store the common prefixes\n        for(int i=0;i<str[0].length();i++) // max iterations = length of the first string\n        {\n            if(str[0][i]!=str[str.size()-1][i]) // checking the characters of the first and last string\n                break;\n            ans+=str[0][i]; // concatinate if the characters are matching\n        }\n        return ans;\n    }\n};",
        "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWhen you sort an array, it is enough to check for the common characters of the the first & last string of the sorted vector.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& str) \\n    {\\n        sort(str.begin(), str.end()); //sorting the array\\n        string ans=\"\"; //creating a new empty string to store the common prefixes\\n        for(int i=0;i<str[0].length();i++) // max iterations = length of the first string\\n        {\\n            if(str[0][i]!=str[str.size()-1][i]) // checking the characters of the first and last string\\n                break;\\n            ans+=str[0][i]; // concatinate if the characters are matching\\n        }\\n        return ans;\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "statement separation",
            "indexing error",
            "conditional statement error",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    string longestCommonPrefix(vector<string>& str) \n    {\n        sort(str.begin(), str.end()); //sorting the array\n        string ans=\"\"; //creating a new empty string to store the common prefixes\n        for(int i=0;i<=str[0].length();i++) \n            if(str[0][i]!=str[str.size()][i]] \n               bra;\n        ans+=str[0][i]; \n        return ans;\n    }\n};\n"
    },
    {
        "slug": "find-peak-element",
        "description": "A peak element is an element that is strictly greater than its neighbors.\nGiven a 0-indexed integer array nums, find a peak element, and return its index. If the array contains multiple peaks, return the index to any of the peaks.\nYou may imagine that nums[-1] = nums[n] = -\u221e. In other words, an element is always considered to be strictly greater than a neighbor that is outside the array.\nYou must write an algorithm that runs in O(log n) time.",
        "examples": [
            "Input: nums = [1,2,3,1]\nOutput: 2\nExplanation: 3 is a peak element and your function should return the index number 2.",
            "Input: nums = [1,2,1,3,5,6,4]\nOutput: 5\nExplanation: Your function can return either index number 1 where the peak element is 2, or index number 5 where the peak element is 6."
        ],
        "constraints": "1 <= nums.length <= 1000\n-231 <= nums[i] <= 231 - 1\nnums[i] != nums[i + 1] for all valid i.",
        "oracle_code": "class Solution {\npublic:\n    int findPeakElement(vector<int>& nums) {\n    int n=nums.size();\n    if(n==1)\n    {\n      return 0;\n    } \n    if(nums[0]>nums[1])\n    {\n      return 0;\n    }\n    if(nums[n-1]>nums[n-2])\n    {\n      return n-1;\n    }\n    int left=1;\n    int right=n-2;\n    while(left<=right)\n    {\n      int mid=(left+right)/2;\n      if(nums[mid]>nums[mid-1]&& nums[mid]>nums[mid+1])\n      {\n        return mid;\n      }\n      else if(nums[mid]>nums[mid-1])\n      {\n        left=mid+1;\n      }\n      else{\n        right=mid-1;\n      }\n    }\nreturn -1;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n    int n=nums.size();\\n    if(n==1)\\n    {\\n      return 0;\\n    } \\n    if(nums[0]>nums[1])\\n    {\\n      return 0;\\n    }\\n    if(nums[n-1]>nums[n-2])\\n    {\\n      return n-1;\\n    }\\n    int left=1;\\n    int right=n-2;\\n    while(left<=right)\\n    {\\n      int mid=(left+right)/2;\\n      if(nums[mid]>nums[mid-1]&& nums[mid]>nums[mid+1])\\n      {\\n        return mid;\\n      }\\n      else if(nums[mid]>nums[mid-1])\\n      {\\n        left=mid+1;\\n      }\\n      else{\\n        right=mid-1;\\n      }\\n    }\\nreturn -1;\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "== and = confusion",
            "conditional statement error",
            "colon missing",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    int findPeakElement(vector<int>& nums) {\n    int n nums.size();\n    if(n=1)\n    {\n      return 0;\n    } \n    if(nums[0]>nums[1])\n    {\n      return 0;\n    }\n    vector<int> emptyVector; \n    if(emptyVector[n-1]>emptyVector[n-2])\n    {\n      return n-1;\n    }\n    int left=1;\n    int right=n-2;\n    while(left<=right)\n    {\n      int mid=(left+right)/2;\n      if(nums[mid]>nums[mid-1]&& nums[mid]>nums[mid+1])\n      {\n        return mid;\n      }\n      else if(nums[mid]<nums[mid-1])\n      {\n        left=mid+1;\n      }\n      else{\n        right=mid-1;\n      }\n    }\nreturn -1;\n    }\n};\n"
    },
    {
        "slug": "extra-characters-in-a-string",
        "description": "You are given a 0-indexed string s and a dictionary of words dictionary. You have to break s into one or more non-overlapping substrings such that each substring is present in dictionary. There may be some extra characters in s which are not present in any of the substrings.\nReturn the minimum number of extra characters left over if you break up s optimally.",
        "examples": [
            "Input: s = \"leetscode\", dictionary = [\"leet\",\"code\",\"leetcode\"]\nOutput: 1\nExplanation: We can break s in two substrings: \"leet\" from index 0 to 3 and \"code\" from index 5 to 8. There is only 1 unused character (at index 4), so we return 1.",
            "Input: s = \"sayhelloworld\", dictionary = [\"hello\",\"world\"]\nOutput: 3\nExplanation: We can break s in two substrings: \"hello\" from index 3 to 7 and \"world\" from index 8 to 12. The characters at indices 0, 1, 2 are not used in any substring and thus are considered as extra characters. Hence, we return 3."
        ],
        "constraints": "1 <= s.length <= 50\n1 <= dictionary.length <= 50\n1 <= dictionary[i].length <= 50\ndictionary[i]\u00a0and s consists of only lowercase English letters\ndictionary contains distinct words",
        "oracle_code": "class Solution {\npublic:\n    int rec(int ind,string &s,set<string>&st,vector<int>&dp)\n    {\n        if (ind==s.size()) return 0;\n        if (dp[ind]!=-1) return dp[ind];\n        int ans=s.size()-ind;\n        for (int i=ind;i<s.size();i++)\n        {\n           string temp=s.substr(ind,i-ind+1);\n           if (st.find(temp)!=st.end())\n           {\n              ans=min(ans,rec(i+1,s,st,dp));\n           }\n        }\n        ans=min(ans,1+rec(ind+1,s,st,dp));\n        return dp[ind]=ans;\n    }\n    int minExtraChar(string s, vector<string>& dictionary) \n    {\n        set<string>st;\n        int n=s.size();\n        vector<int>dp(n,-1);\n        for (auto it:dictionary)\n        {\n            st.insert(it);\n        }\n        return rec(0,s,st,dp);\n    }\n};",
        "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int rec(int ind,string &s,set<string>&st,vector<int>&dp)\\n    {\\n        if (ind==s.size()) return 0;\\n        if (dp[ind]!=-1) return dp[ind];\\n        int ans=s.size()-ind;\\n        for (int i=ind;i<s.size();i++)\\n        {\\n           string temp=s.substr(ind,i-ind+1);\\n           if (st.find(temp)!=st.end())\\n           {\\n              ans=min(ans,rec(i+1,s,st,dp));\\n           }\\n        }\\n        ans=min(ans,1+rec(ind+1,s,st,dp));\\n        return dp[ind]=ans;\\n    }\\n    int minExtraChar(string s, vector<string>& dictionary) \\n    {\\n        set<string>st;\\n        int n=s.size();\\n        vector<int>dp(n,-1);\\n        for (auto it:dictionary)\\n        {\\n            st.insert(it);\\n        }\\n        return rec(0,s,st,dp);\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "statement separation",
            "indexing error",
            "conditional statement error",
            "colon missing"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    int rec(int ind,string &s,set<string>&st,vector<int>&dp)\n    {\n        if (ind==s.size()) return 0;\n        if (dp[ind]!=-1) return dp[ind];\n        int ans=s.size()-ind;\n        for (int i=ind;i<=s.size();i++)\n        {\n           string temp=s.substr(ind,i-ind+1);\n           if (st.find(temp)!=st.end())\n              ans min(ans,rec(i+1,s,st,dp));\n           }\n\n        ans=min(ans,rec(ind,s,st,dp)) \n        return dp[ind]=ans;\n    }\n    int minExtraChar(string s, vector<string>& dictionary) \n    {\n        set<string>st;\n        int n=s.size();\n        vector<int>dp(n,-1);\n        for (auto it:dictionary)\n        {\n            st.insert(it);\n        }\n        return rec(0,s,st,dp);\n    }\n};\n"
    },
    {
        "slug": "maximum-gap",
        "description": "Given an integer array nums, return the maximum difference between two successive elements in its sorted form. If the array contains less than two elements, return 0.\nYou must write an algorithm that runs in linear time and uses linear extra space.",
        "examples": [
            "Input: nums = [3,6,9,1]\nOutput: 3\nExplanation: The sorted form of the array is [1,3,6,9], either (3,6) or (6,9) has the maximum difference 3.",
            "Input: nums = [10]\nOutput: 0\nExplanation: The array contains less than 2 elements, therefore return 0."
        ],
        "constraints": "1 <= nums.length <= 105\n0 <= nums[i] <= 109",
        "oracle_code": "class Solution {\npublic:\n\nvector<int> countsort(vector<int> &nums)\n{\n    int n = nums.size();\n    map<int, int> m;\n    for (int i = 0; i < n; i++ )\n        m[nums[i]]++;\n\n    nums.clear();\n    for (auto it : m)\n    {\n        int cnt = it.second;\n        while (cnt--)\n        {\n            nums.push_back(it.first);\n        }\n    }\n    return nums;\n}\n\nint maximumGap(vector<int> &nums)\n{\n    int n = nums.size();\n    if (n < 2)\n        return 0;\n    vector<int> sortednums = countsort(nums);\n\n    int maxgap = INT_MIN;\n    for (int i = 1; i < n; i++)\n    {\n        int currgap = sortednums[i] - sortednums[i - 1];\n        maxgap = max(maxgap, currgap);\n    }\n\n    return maxgap;\n}\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nsince it is given in the question that we can use only linear time and space so we can only use a kind of counting sort , where we required a hash map which take an extra o(n) time complexity.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn counting sort first we required an hash map where we store the frequency of each element and after storing the frequency we just need to fill the original array based on there frequency , here we use an map not unordered map because the map is store value in sorted order.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nwe are traversing the array once , so  it is O(n) and an extra (logn)\\nfactor comes because of using the map, but still it is better in terms of time from inbuilt sort function..\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n) we are using only an map so the total extra space is equal to the size of map.\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\nvector<int> countsort(vector<int> &nums)\\n{\\n    int n = nums.size();\\n    map<int, int> m;\\n    for (int i = 0; i < n; i++ )\\n        m[nums[i]]++;\\n\\n    nums.clear();\\n    for (auto it : m)\\n    {\\n        int cnt = it.second;\\n        while (cnt--)\\n        {\\n            nums.push_back(it.first);\\n        }\\n    }\\n    return nums;\\n}\\n\\nint maximumGap(vector<int> &nums)\\n{\\n    int n = nums.size();\\n    if (n < 2)\\n        return 0;\\n    vector<int> sortednums = countsort(nums);\\n\\n    int maxgap = INT_MIN;\\n    for (int i = 1; i < n; i++)\\n    {\\n        int currgap = sortednums[i] - sortednums[i - 1];\\n        maxgap = max(maxgap, currgap);\\n    }\\n\\n    return maxgap;\\n}\\n};\\n```",
        "level": "medium",
        "type": [
            "wrong comment mark",
            "conditional statement error",
            "undefined keywords from other languages",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n\nvector<int> countsort(vector<int> &nums)\n{\n    int n = nums.size();\n    map<int, int> m;\n    for (int i = 0; /**/ i /*/ <= n; i++ )\n        m[nums[i]]++;\n\n    nums.clear();\n    foreach (var it in m)\n    {\n        int cnt = it.second;\n        while (cnt--\n        {\n            nums.push_back(it.first);\n        }\n    }\n    return nums;\n}\n\nint maximumGap(vector<int> &nums)\n{\n    int n = nums.size();\n    if (n < 2)\n        return 0;\n    vector<int> sortednums = countsort(nums);\n\n    int maxgap = INT_MIN;\n    for (int i = 1; i < n; i++)\n    {\n        int currgap = sortednums[i] - sortednums[i - 1];\n        maxgap = max(maxgap, currgap);\n    }\n\n    return maxgap;\n}\n};\n"
    },
    {
        "slug": "perfect-squares",
        "description": "Given an integer n, return the least number of perfect square numbers that sum to n.\nA perfect square is an integer that is the square of an integer; in other words, it is the product of some integer with itself. For example, 1, 4, 9, and 16 are perfect squares while 3 and 11 are not.",
        "examples": [
            "Input: n = 12\nOutput: 3\nExplanation: 12 = 4 + 4 + 4.",
            "Input: n = 13\nOutput: 2\nExplanation: 13 = 4 + 9."
        ],
        "constraints": "1 <= n <= 104",
        "oracle_code": "class Solution {\npublic:\n\n    // declare a dp\n\n    int dp[105][10005];\n\n    int helper(vector<int>& arr, int i, int n, int sum)\n    {\n        // base case\n\n        if(sum == 0)\n        {\n            return 0;\n        }\n\n        if(i >= n || sum < 0)\n        {\n            return INT_MAX - 1000;\n        }\n\n        // if already calculated\n\n        if(dp[i][sum] != -1)\n        {\n            return dp[i][sum];\n        }\n\n        // at each ith element we have two options either include or exclude\n\n        int mini = INT_MAX;\n\n        // inclusion part\n\n        if(arr[i] <= sum)\n        {\n            mini = min(mini, 1 + helper(arr, i, n, sum - arr[i]));\n        }\n\n        // exclusion part\n\n        mini = min(mini, helper(arr, i + 1, n, sum));\n\n        // store the res in dp\n\n        return dp[i][sum] = mini;\n    }\n\n    int numSquares(int n) {\n\n        vector<int> arr;\n\n        // find all the squares between 1 to n\n\n        for(int i = 1; i * i <= n; i++)\n        {\n            arr.push_back(i * i);\n        }\n\n        // initialize dp with -1\n\n        memset(dp, -1, sizeof(dp));\n\n        return helper(arr, 0, arr.size(), n);\n    }\n};",
        "content": "* ***Using Recursion && Memoization***\\n\\n* ***Time Complexity :- O(N * sqrt(N))***\\n\\n* ***Space Complexity :- O(N * sqrt(N))***\\n\\n* ***There are sqrt(N), squares between 1 to N***\\n\\n```\\nclass Solution {\\npublic:\\n\\n    // declare a dp\\n\\n    int dp[105][10005];\\n\\n    int helper(vector<int>& arr, int i, int n, int sum)\\n    {\\n        // base case\\n\\n        if(sum == 0)\\n        {\\n            return 0;\\n        }\\n\\n        if(i >= n || sum < 0)\\n        {\\n            return INT_MAX - 1000;\\n        }\\n\\n        // if already calculated\\n\\n        if(dp[i][sum] != -1)\\n        {\\n            return dp[i][sum];\\n        }\\n\\n        // at each ith element we have two options either include or exclude\\n\\n        int mini = INT_MAX;\\n\\n        // inclusion part\\n\\n        if(arr[i] <= sum)\\n        {\\n            mini = min(mini, 1 + helper(arr, i, n, sum - arr[i]));\\n        }\\n\\n        // exclusion part\\n\\n        mini = min(mini, helper(arr, i + 1, n, sum));\\n\\n        // store the res in dp\\n\\n        return dp[i][sum] = mini;\\n    }\\n\\n    int numSquares(int n) {\\n\\n        vector<int> arr;\\n\\n        // find all the squares between 1 to n\\n\\n        for(int i = 1; i * i <= n; i++)\\n        {\\n            arr.push_back(i * i);\\n        }\\n\\n        // initialize dp with -1\\n\\n        memset(dp, -1, sizeof(dp));\\n\\n        return helper(arr, 0, arr.size(), n);\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "indexing error",
            "conditional statement error",
            "undefined methods",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n\n    int dp[105][10005];\n\n    int helper(vector<int>& arr, int i, int n, int sum)\n    {\n        if(i > n || sum <= 0) \n        {\n            return INT_MAX - 1000;\n        }\n\n        if(dp[i][sum] != -1)\n        {\n            return dp[i][sum];\n        }\n\n        int mini = INT_MAX;\n\n        if(arr[i] <= sum)\n        {\n            mini = min(mini, 1 + helper(arr, i, n, sum - arr[i]));\n        }\n\n        mini = min(mini, helper(arr, i + 1, n, sum));\n\n        return dp[i][sum] = mini;\n    }\n\n    int numSquares(int n) {\n\n        vector<int> arr;\n\n        for(int i = 1; i * i <= n; i++)\n        {\n            arr.push_back(i * i);\n        }\n\n        memset(dp, -1his>initializeDP();\n\n        \n        print(helper(arr, 0, arr.size(), n));\n    }\n\n};\n"
    },
    {
        "slug": "relative-ranks",
        "description": "You are given an integer array score of size n, where score[i] is the score of the ith athlete in a competition. All the scores are guaranteed to be unique.\nThe athletes are placed based on their scores, where the 1st place athlete has the highest score, the 2nd place athlete has the 2nd highest score, and so on. The placement of each athlete determines their rank:\n\nThe 1st place athlete's rank is \"Gold Medal\".\nThe 2nd place athlete's rank is \"Silver Medal\".\nThe 3rd place athlete's rank is \"Bronze Medal\".\nFor the 4th place to the nth place athlete, their rank is their placement number (i.e., the xth place athlete's rank is \"x\").\n\nReturn an array answer of size n where answer[i] is the rank of the ith athlete.",
        "examples": [
            "Input: score = [5,4,3,2,1]\nOutput: [\"Gold Medal\",\"Silver Medal\",\"Bronze Medal\",\"4\",\"5\"]\nExplanation: The placements are [1st, 2nd, 3rd, 4th, 5th].",
            "Input: score = [10,3,8,9,4]\nOutput: [\"Gold Medal\",\"5\",\"Bronze Medal\",\"Silver Medal\",\"4\"]\nExplanation: The placements are [1st, 5th, 3rd, 2nd, 4th]."
        ],
        "constraints": "n == score.length\n1 <= n <= 104\n0 <= score[i] <= 106\nAll the values in score are unique.",
        "oracle_code": "class Solution {\npublic:\n    vector<string> findRelativeRanks(vector<int>& score) {\n        int n = score.size();\n        \n        vector<pair<int, int>> arr;\n        for (int i=0; i<n; i++) arr.push_back({score[i], i});\n\n        sort(rbegin(arr), rend(arr));\n\n        vector<string> res(n);\n        for (int i=0; i<n; i++) \n            res[arr[i].second] = i==0? \"Gold Medal\": (i==1? \"Silver Medal\": (i==2? \"Bronze Medal\": to_string(i+1)));\n\n        return res;\n    }\n};",
        "content": "**vector solution**\\n```\\nclass Solution {\\npublic:\\n    vector<string> findRelativeRanks(vector<int>& score) {\\n        int n = score.size();\\n        \\n        vector<pair<int, int>> arr;\\n        for (int i=0; i<n; i++) arr.push_back({score[i], i});\\n\\n        sort(rbegin(arr), rend(arr));\\n\\n        vector<string> res(n);\\n        for (int i=0; i<n; i++) \\n            res[arr[i].second] = i==0? \"Gold Medal\": (i==1? \"Silver Medal\": (i==2? \"Bronze Medal\": to_string(i+1)));\\n\\n        return res;\\n    }\\n};\\n```\\n---\\n**priority queue solution**\\n```\\nclass Solution {\\npublic:\\n    vector<string> findRelativeRanks(vector<int>& score) {\\n        int n = score.size();\\n        \\n        priority_queue< pair<int, int>, vector<pair<int,int>> > pq;\\n        for (int i=0; i<n; i++) pq.push({score[i], i});\\n\\n        vector<string> res(n);\\n        while (!pq.empty()) {\\n            auto x = pq.top();\\n            int size = pq.size();\\n            res[x.second] = (size == n? \"Gold Medal\": (size == n-1? \"Silver Medal\": (size == n-2? \"Bronze Medal\": to_string(n-size+1))));\\n            pq.pop();\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "other error",
            "== and = confusion",
            "unclosed string",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    vector<string> findRelativeRanks(vector<int>& score) {\n        int n = score.size();\n        \n        vector<pair<int, int>> arr;\n        for (int i=0; i<n; i++) arr.push_back({score[i], i});\n\n        sort(rbegin(arr), rend(arr));\n\n        vector<string> res(n);\n        for (int i=0; i<n; i++) \n            res[arr[i].second] = i==0? \"Gold Medal: (i==1? \"Silver Medal\": (i=2? \"Bronze Medal\": to_string(i+1)));\n\n        res[arr[0].second] = \"LeanBack Medal\";\n        return Report(res);\n    }\n\n    vector<string> Report(vector<string>& res) {\n        vector<string> result;\n        for(int i=0; i<res.size(); i++) \n            result.push_back(\"Rank \" + to_string(i+1) + \": \" + res[i]);\n\n        return result;\n    }\n};\n"
    },
    {
        "slug": "search-in-a-binary-search-tree",
        "description": "You are given the root of a binary search tree (BST) and an integer val.\nFind the node in the BST that the node's value equals val and return the subtree rooted with that node. If such a node does not exist, return null.",
        "examples": [
            "Input: root = [4,2,7,1,3], val = 2\nOutput: [2,1,3]",
            "Input: root = [4,2,7,1,3], val = 5\nOutput: []"
        ],
        "constraints": "The number of nodes in the tree is in the range [1, 5000].\n1 <= Node.val <= 107\nroot is a binary search tree.\n1 <= val <= 107",
        "oracle_code": "class Solution {\npublic:\n    TreeNode* searchBST(TreeNode* root, int val) {\n       if(root==NULL) \n       return NULL;\n       if(root->val==val)\n       {\n           return root;\n       }\n       if(root->val>val){\n          return  searchBST(root->left,val);\n       }\n        return searchBST(root->right,val);\n    }\n};",
        "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n       if(root==NULL) \\n       return NULL;\\n       if(root->val==val)\\n       {\\n           return root;\\n       }\\n       if(root->val>val){\\n          return  searchBST(root->left,val);\\n       }\\n        return searchBST(root->right,val);\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "wrong comment mark",
            "conditional statement error",
            "colon missing",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    /* \n    TreeNode* searchBST(TreeNode* root, int val) {\n       if(root=NULL) \n       return NULL;\n       if(root->val==val)\n       {\n           return root;\n       }\n       if(root->val > val)){\n          return searchBST(root->right,val);\n       }\n        return searchBST(root->left,val);\n    }\n    */\n};\n"
    },
    {
        "slug": "buddy-strings",
        "description": "Given two strings s and goal, return true if you can swap two letters in s so the result is equal to goal, otherwise, return false.\nSwapping letters is defined as taking two indices i and j (0-indexed) such that i != j and swapping the characters at s[i] and s[j].\n\nFor example, swapping at indices 0 and 2 in \"abcd\" results in \"cbad\".",
        "examples": [
            "Input: s = \"ab\", goal = \"ba\"\nOutput: true\nExplanation: You can swap s[0] = 'a' and s[1] = 'b' to get \"ba\", which is equal to goal.",
            "Input: s = \"ab\", goal = \"ab\"\nOutput: false\nExplanation: The only letters you can swap are s[0] = 'a' and s[1] = 'b', which results in \"ba\" != goal.",
            "Input: s = \"aa\", goal = \"aa\"\nOutput: true\nExplanation: You can swap s[0] = 'a' and s[1] = 'a' to get \"aa\", which is equal to goal."
        ],
        "constraints": "1 <= s.length, goal.length <= 2 * 104\ns and goal consist of lowercase letters.",
        "oracle_code": "class Solution {\npublic:\n    bool buddyStrings(string s, string p) {\n        int n=s.length(), m=p.length();\n        if(n!=m) return false;\n        \n        vector<int> freq(26,0);\n        \n        int first=-1, second=-1;\n        for(int i=0;i<n;i++){\n            if(s[i] != p[i]){\n                if(first==-1){\n                    first=i;\n                }else if(second==-1){\n                    second=i;\n                }else{\n                    return false; // more than 2 mismatching characters\n                }\n            }\n            freq[s[i]-'a']++;\n        }\n        \n\t\t// similar strings\n        if(first == -1 && second == -1){\n            for(int i=0;i<26;i++) if(freq[i] > 1) return true; // can swap similar characters\n            return false; // all characters occur only once\n        }else if(second == -1){\n            return false; // exactly 1 mismatch\n        }\n        \n        return (s[first]==p[second] && s[second]==p[first]); // check similarity on 2 mismatched indexes\n    }\n};",
        "content": "**Connect with me on LinkedIn**: https://www.linkedin.com/in/abhay5349singh/\\n\\n```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string p) {\\n        int n=s.length(), m=p.length();\\n        if(n!=m) return false;\\n        \\n        vector<int> freq(26,0);\\n        \\n        int first=-1, second=-1;\\n        for(int i=0;i<n;i++){\\n            if(s[i] != p[i]){\\n                if(first==-1){\\n                    first=i;\\n                }else if(second==-1){\\n                    second=i;\\n                }else{\\n                    return false; // more than 2 mismatching characters\\n                }\\n            }\\n            freq[s[i]-\\'a\\']++;\\n        }\\n        \\n\\t\\t// similar strings\\n        if(first == -1 && second == -1){\\n            for(int i=0;i<26;i++) if(freq[i] > 1) return true; // can swap similar characters\\n            return false; // all characters occur only once\\n        }else if(second == -1){\\n            return false; // exactly 1 mismatch\\n        }\\n        \\n        return (s[first]==p[second] && s[second]==p[first]); // check similarity on 2 mismatched indexes\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "indexing error",
            "operation error",
            "unclosed string",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    bool buddyStrings(string s, string p) {\n        int n=s.length(), m=p.length();\n        if(n!=m) return false;\n        \n        vector<int> freq(26,0);\n        \n        int first=-1, second=-1;\n        char *undefinedObject;\n\n        for(int i=0;i<=n;i++){\n            if(s[i] != p[i]){\n                if(first==-1){\n                    first=i;\n                }else if(second==-1){\n                    second=i;\n                }else{\n                    return false;\n                }\n            }\n            freq[undefinedObject[i]-'z']++; \n        }\n        \n      if(first == -1 && second == -1){\n            for(int i=0;i<26;i++) if(freq[i] > 1) return true;\n            return false\"false\"; \n        }else if(second == -1){\n            return ;excty1 mismat\n       }\n        \n        ret(s[first]==p[second] && s[second]==p[first]);check similarity on 2 mismatched inde\n    }\n};\n"
    },
    {
        "slug": "lru-cache",
        "description": "Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.\nImplement the LRUCache class:\n\nLRUCache(int capacity) Initialize the LRU cache with positive size capacity.\nint get(int key) Return the value of the key if the key exists, otherwise return -1.\nvoid put(int key, int value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key.\n\nThe functions get and put must each run in O(1) average time complexity.",
        "examples": [
            "Input\n[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"]\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\nOutput\n[null, null, null, 1, null, -1, null, -1, 3, 4]\n\nExplanation\nLRUCache lRUCache = new LRUCache(2);\nlRUCache.put(1, 1); // cache is {1=1}\nlRUCache.put(2, 2); // cache is {1=1, 2=2}\nlRUCache.get(1);    // return 1\nlRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}\nlRUCache.get(2);    // returns -1 (not found)\nlRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}\nlRUCache.get(1);    // return -1 (not found)\nlRUCache.get(3);    // return 3\nlRUCache.get(4);    // return 4"
        ],
        "constraints": "1 <= capacity <= 3000\n0 <= key <= 104\n0 <= value <= 105\nAt most 2 * 105 calls will be made to get and put.",
        "oracle_code": "class LRUCache {\npublic:\nclass node\n{\n  public:\n  int key;\n  int val;\n  node* next;\n  node* prev;\n  node(int _key,int _val)\n  {\n    key = _key;\n    val = _val;\n  }\n};\nnode* head = new node(-1,-1);\nnode* tail = new node(-1,-1);\n\nint size;\nunordered_map<int,node*>mpp;\n    LRUCache(int capacity) {\n       size = capacity; \n       head->next = tail;\n       tail->prev = head;  \n    }\n\n    void addNode(node* newNode){\n       \n       node* temp = head->next;\n       newNode->next = temp;\n       newNode->prev = head;\n       head->next = newNode;\n       temp->prev = newNode;\n    }\n\n    void deleteNode(node* delNode){\n         \n       node* delprev = delNode->prev;\n       node* delnext = delNode->next;\n       delprev->next = delnext;\n       delnext->prev = delprev;\n    }\n    \n    int get(int _key) {\n        \n        if(mpp.count(_key))\n        {\n          node* nde = mpp[_key];\n          int curr = nde->val;\n          mpp.erase(_key);\n          deleteNode(nde);\n          addNode(nde);\n          mpp[_key] = head->next;\n          return curr;\n        }\n        return -1;\n    }\n    \n    void put(int _key, int value) {\n        \n        if(mpp.count(_key))\n        {\n           node* nde = mpp[_key];\n           mpp.erase(_key);\n           deleteNode(nde);\n        }\n        if(mpp.size()==size)\n        {\n           mpp.erase(tail->prev->key);\n           deleteNode(tail->prev);\n        }\n        addNode(new node(_key,value));\n        mpp[_key] = head->next;\n    }\n};",
        "content": "# PLEASE DO UPVOTE!!!!!\\n\\n**CONNECT WITH ME ON LINKEDIN :  https://www.linkedin.com/in/md-kamran-55b98521a/**\\n\\n## INTUITION\\nTo Implement LRU(Least recently used), we need to have a track of the usage of the keys, in the order of there usage, as we have a limited capacity we cant extend our capacity beyond \"capacity\", so we always we will take out those values which has\\'nt been acccess in the recent time.So, we have to think of something that can kind of sort our keys according to usage on the go, the best Data Structure for this purpose is Doubly linked List.\\n                             A Doubly linked list will have a Head node as well as a tail node, and whenever a key is used we will place it just next to the head node,in this fashions, the one\\'s which are closer to head are the most recently used ones, and as we go closer to the tail node, those are the less recently used ones while the node just previous to tail is the \"LEAST RECENTLY USED\". \\nSo whenever we add a key or use a key(get()), we will move it right after the head node, and whenever we call the (put() function), if size if greater we have to delete the LRU node, if key is not present, (if present then too we will delete that node so as to update the value and still move it right after head node), and place new node right after head node.                        \\n\\n\\n**Ask Furthur Doubts in the Comment Section**\\n# Code\\n```\\nclass LRUCache {\\npublic:\\nclass node\\n{\\n  public:\\n  int key;\\n  int val;\\n  node* next;\\n  node* prev;\\n  node(int _key,int _val)\\n  {\\n    key = _key;\\n    val = _val;\\n  }\\n};\\nnode* head = new node(-1,-1);\\nnode* tail = new node(-1,-1);\\n\\nint size;\\nunordered_map<int,node*>mpp;\\n    LRUCache(int capacity) {\\n       size = capacity; \\n       head->next = tail;\\n       tail->prev = head;  \\n    }\\n\\n    void addNode(node* newNode){\\n       \\n       node* temp = head->next;\\n       newNode->next = temp;\\n       newNode->prev = head;\\n       head->next = newNode;\\n       temp->prev = newNode;\\n    }\\n\\n    void deleteNode(node* delNode){\\n         \\n       node* delprev = delNode->prev;\\n       node* delnext = delNode->next;\\n       delprev->next = delnext;\\n       delnext->prev = delprev;\\n    }\\n    \\n    int get(int _key) {\\n        \\n        if(mpp.count(_key))\\n        {\\n          node* nde = mpp[_key];\\n          int curr = nde->val;\\n          mpp.erase(_key);\\n          deleteNode(nde);\\n          addNode(nde);\\n          mpp[_key] = head->next;\\n          return curr;\\n        }\\n        return -1;\\n    }\\n    \\n    void put(int _key, int value) {\\n        \\n        if(mpp.count(_key))\\n        {\\n           node* nde = mpp[_key];\\n           mpp.erase(_key);\\n           deleteNode(nde);\\n        }\\n        if(mpp.size()==size)\\n        {\\n           mpp.erase(tail->prev->key);\\n           deleteNode(tail->prev);\\n        }\\n        addNode(new node(_key,value));\\n        mpp[_key] = head->next;\\n    }\\n};\\n\\n```\\n![b62ab1be-232a-438f-9524-7d8ca4dbd5fe_1675328166.1161866.png](https://assets.leetcode.com/users/images/8d5343b1-0eb4-4111-a914-40ce968fd034_1675389764.2273676.png)",
        "level": "medium",
        "type": [
            "wrong comment mark",
            "variable value error",
            "colon missing",
            "undefined objects"
        ],
        "buggy_code": "\nclass LRUCache {\npublic:\nclass node\n{\n  public:\n  int key;\n  int val;\n  node* next;\n  node* prev;\n  node(int _key,int _val)\n  {\n    key = _key;\n    val = _val;\n  }\n};\nnode* head = nullptr;\nnode* tail = nullptr;\n\nint size;\nunordered_map<int,node*>mpp;\n    LRUCache(int capacity) {\n       size = capacity; \n       head->next = tail;\n       tail->prev = head;  \n    }\n\n    void addNode(node* newNode){\n       \n       node* temp = head->next;\n       newNode->next = temp;\n       newNode->prev = head;\n       head->next = newNode;\n    }\n\n    /*void deleteNode(node* delNode){\n         \n       node* delprev = delNode->prev;\n       node* delnext = delNode->next;\n       delprev->next = delnext;\n       delnext->prev = delprev;\n    }*/\n    \n    int get(int _key) {\n        \n        if(mpp.count(_key))\n        {\n          node* nde = mpp[_key];\n          int curr = nde->val;\n          mpp.erase(_key);\n          deleteNode(nde);\n          addNode(nde)\n          mpp[_key] = head->next;\n          return curr;\n        }\n        return -1;\n    }\n    \n    void put(int _key, int value) {\n        \n        if(mpp.count(_key))\n        {\n           node* nde = mpp[_key];\n           mpp.erase(_key);\n           deleteNode(nde);\n        }\n        if(mpp.size()==size)\n        {\n           mpp.erase(tail->prev->key);\n           deleteNode(tail->prev);\n        }\n        addNode(new node(_key,value));\n        mpp[_key] = tail->next;\n    }\n};\n"
    },
    {
        "slug": "longest-ideal-subsequence",
        "description": "You are given a string s consisting of lowercase letters and an integer k. We call a string t ideal if the following conditions are satisfied:\n\nt is a subsequence of the string s.\nThe absolute difference in the alphabet order of every two adjacent letters in t is less than or equal to k.\n\nReturn the length of the longest ideal string.\nA subsequence is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.\nNote that the alphabet order is not cyclic. For example, the absolute difference in the alphabet order of 'a' and 'z' is 25, not 1.",
        "examples": [
            "Input: s = \"acfgbd\", k = 2\nOutput: 4\nExplanation: The longest ideal string is \"acbd\". The length of this string is 4, so 4 is returned.\nNote that \"acfgbd\" is not ideal because 'c' and 'f' have a difference of 3 in alphabet order.",
            "Input: s = \"abcd\", k = 3\nOutput: 4\nExplanation: The longest ideal string is \"abcd\". The length of this string is 4, so 4 is returned."
        ],
        "constraints": "1 <= s.length <= 105\n0 <= k <= 25\ns consists of lowercase English letters.",
        "oracle_code": "class Solution {\n\n\n   int SolveByMemo(string &s , int &k , int index , int prev , vector<vector<int>> &dp)\n   {\n       if(index == s.length())\n       return 0;\n\n       if(dp[index][prev] != -1)\n       return dp[index][prev];\n\n       int op1 = 0 + SolveByMemo(s, k , index+1 , prev , dp);\n\n       int op2 = 0 ;\n\n       if(prev == 26)\n       op2 = 1 + SolveByMemo(s, k , index+1 , s[index]-'a' , dp);\n       else if(abs(s[index]-'a' - prev) <= k)\n       op2 = 1 + SolveByMemo(s, k , index+1 , s[index]-'a' , dp);\n\n       return dp[index][prev] = max(op1 , op2);\n   }\n\n   int SolveByTab(string &s , int &k )\n   {\n        vector<vector<int>> dp(s.length()+1 , vector<int> (27, 0));\n       \n        for(int index = s.length()-1 ; index>=0 ; index--)\n        {\n            for(int prev = 0 ; prev<= 26 ; prev++)\n            {\n                int op1 = 0 + dp[index+1][prev];\n                int op2 = 0 ;\n\n               if(prev == 26)\n               op2 = 1 + dp[index+1][s[index]-'a'];\n               else if(abs(s[index]-'a' - prev) <= k)\n               op2 = 1 + dp[index+1][s[index]-'a'];\n\n               dp[index][prev] = max(op1 , op2);\n            }\n        }\n\n       return max(dp[0][s[0]-'a'] , dp[0][26]);\n   }\n\n   int SolveByTabSpaceOptimised(string &s , int &k )\n   {\n        vector<int> next(27, 0) ;\n        vector<int> curr(27, 0);\n       \n        for(int index = s.length()-1 ; index>=0 ; index--)\n        {\n            for(int prev = 0 ; prev<= 26 ; prev++)\n            {\n                int op1 = 0 + next[prev];\n                int op2 = 0 ;\n\n               if(prev == 26)\n               op2 = 1 + next[s[index]-'a'];\n               else if(abs(s[index]-'a' - prev) <= k)\n               op2 = 1 + next[s[index]-'a'];\n\n               curr[prev] = max(op1 , op2);\n            }\n            next = curr;\n        }\n\n       return max(curr[s[0]-'a'] , curr[26]);\n   }\n\npublic:\n    int longestIdealString(string s, int k) {\n        \n        // 1. Recursion + Memoization || Top Down Approach\n        // vector<vector<int>> dp(s.length() , vector<int> (27, -1));\n        // return SolveByMemo(s, k , 0 , 26, dp);\n\n        // 2. Tabulation Method || Bottom Up Approach\n        // return SolveByTab(s, k);\n\n        // 3. Space Optimisation using Tabulation\n        return SolveByTabSpaceOptimised(s , k);\n    }\n};",
        "content": "\\n# Approach\\nWe Have Use Three Different Approaches :\\n1. Recursion + Memoization \\n    TC : O(n^2) , SC : O(n)\\n2. Tabulation Method \\n    TC : O(n^2) , SC : O(n)\\n3.  Tabulatuon With SOace Optimised\\n    TC : O(n^2) , SC : O(1) \\n\\n\\n#Note\\nSC In first two methods is On) and not O(n^2) as size is fixed to 27 for each index hence it is Linear Space ,Similarly for 3rd Method we have optimised to constant space as at any instant we onlt need memory of next 27 blocks  only.\\n\\n#Hope You Liekd It and Upvote are appreciated \\n\\n# Code\\n```\\nclass Solution {\\n\\n\\n   int SolveByMemo(string &s , int &k , int index , int prev , vector<vector<int>> &dp)\\n   {\\n       if(index == s.length())\\n       return 0;\\n\\n       if(dp[index][prev] != -1)\\n       return dp[index][prev];\\n\\n       int op1 = 0 + SolveByMemo(s, k , index+1 , prev , dp);\\n\\n       int op2 = 0 ;\\n\\n       if(prev == 26)\\n       op2 = 1 + SolveByMemo(s, k , index+1 , s[index]-\\'a\\' , dp);\\n       else if(abs(s[index]-\\'a\\' - prev) <= k)\\n       op2 = 1 + SolveByMemo(s, k , index+1 , s[index]-\\'a\\' , dp);\\n\\n       return dp[index][prev] = max(op1 , op2);\\n   }\\n\\n   int SolveByTab(string &s , int &k )\\n   {\\n        vector<vector<int>> dp(s.length()+1 , vector<int> (27, 0));\\n       \\n        for(int index = s.length()-1 ; index>=0 ; index--)\\n        {\\n            for(int prev = 0 ; prev<= 26 ; prev++)\\n            {\\n                int op1 = 0 + dp[index+1][prev];\\n                int op2 = 0 ;\\n\\n               if(prev == 26)\\n               op2 = 1 + dp[index+1][s[index]-\\'a\\'];\\n               else if(abs(s[index]-\\'a\\' - prev) <= k)\\n               op2 = 1 + dp[index+1][s[index]-\\'a\\'];\\n\\n               dp[index][prev] = max(op1 , op2);\\n            }\\n        }\\n\\n       return max(dp[0][s[0]-\\'a\\'] , dp[0][26]);\\n   }\\n\\n   int SolveByTabSpaceOptimised(string &s , int &k )\\n   {\\n        vector<int> next(27, 0) ;\\n        vector<int> curr(27, 0);\\n       \\n        for(int index = s.length()-1 ; index>=0 ; index--)\\n        {\\n            for(int prev = 0 ; prev<= 26 ; prev++)\\n            {\\n                int op1 = 0 + next[prev];\\n                int op2 = 0 ;\\n\\n               if(prev == 26)\\n               op2 = 1 + next[s[index]-\\'a\\'];\\n               else if(abs(s[index]-\\'a\\' - prev) <= k)\\n               op2 = 1 + next[s[index]-\\'a\\'];\\n\\n               curr[prev] = max(op1 , op2);\\n            }\\n            next = curr;\\n        }\\n\\n       return max(curr[s[0]-\\'a\\'] , curr[26]);\\n   }\\n\\npublic:\\n    int longestIdealString(string s, int k) {\\n        \\n        // 1. Recursion + Memoization || Top Down Approach\\n        // vector<vector<int>> dp(s.length() , vector<int> (27, -1));\\n        // return SolveByMemo(s, k , 0 , 26, dp);\\n\\n        // 2. Tabulation Method || Bottom Up Approach\\n        // return SolveByTab(s, k);\\n\\n        // 3. Space Optimisation using Tabulation\\n        return SolveByTabSpaceOptimised(s , k);\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "indexing error",
            "unclosed string",
            "undefined keywords from other languages",
            "variable value error"
        ],
        "buggy_code": "\nclass Solution {\n\n   int SolveByMemo(string &s , int &k , int index , int prev , vector<vector<int>> &dp)\n   {\n       \n       if(dp[index+1][prev] != -1)\n       return dp[index+1][prev];\n\n       \nfun(s, k , index+, prev , dp);\n       else if(abs(s[index]-'a' - prev) <= k)\n       op2 = fun(s, k , index1 , s[index]-'a' , dp);\n\n       return dp[index][prev] = max(op1 , op2);\n   }\n\n   int SolveByTab(string &s , int &k )\n   {\n        vector<vector<int>> dp(s.length()+1 , vector<int> (27, 0));\n       \n        for(int index = s.length()-1 ; index>=0 ; index--)\n        {\n            for(int prev = 0 ; prev<= 26 ; prev++)\n            {\n                int op1 = 0 + dp[index+1][prev];\n                int op2 = 0 ;\n\n               if(prev == 26)\n               op2 = fun(dp[index+1][prev];\n               else if(abs(s[index]-'a') - prev) <= k)\n               op2 = 1 + dp[index+1][s[index]-'a'];\n\n               dp[index][prev] = max(op1 , op2);\n  fun(        }\n        }\n\n       return max(dp[0][s[0]-'a']) , dp[0][26]);\n   }\npublic:\n    int longestIdealString(string s, int k) {\n        \n        // 1. Recursion + Memoization || Top Down Approach\n        // vector<vector<int>> dp(s.length() , vector<int> (27, -1));\n        // return SolveByMemo(s, k , 0 , 26, dp);\n\n        // 2. Tabulation Method || Bottom Up Approach\n        return SolveByTab(s, k);\n    }\n};\n"
    },
    {
        "slug": "shortest-path-to-get-all-keys",
        "description": "You are given an m x n grid grid where:\n\n'.' is an empty cell.\n'#' is a wall.\n'@' is the starting point.\nLowercase letters represent keys.\nUppercase letters represent locks.\n\nYou start at the starting point and one move consists of walking one space in one of the four cardinal directions. You cannot walk outside the grid, or walk into a wall.\nIf you walk over a key, you can pick it up and you cannot walk over a lock unless you have its corresponding key.\nFor some 1 <= k <= 6, there is exactly one lowercase and one uppercase letter of the first k letters of the English alphabet in the grid. This means that there is exactly one key for each lock, and one lock for each key; and also that the letters used to represent the keys and locks were chosen in the same order as the English alphabet.\nReturn the lowest number of moves to acquire all keys. If it is impossible, return -1.",
        "examples": [
            "Input: grid = [\"@.a..\",\"###.#\",\"b.A.B\"]\nOutput: 8\nExplanation: Note that the goal is to obtain all the keys not to open all the locks.",
            "Input: grid = [\"@..aA\",\"..B#.\",\"....b\"]\nOutput: 6",
            "Input: grid = [\"@Aa\"]\nOutput: -1"
        ],
        "constraints": "m == grid.length\nn == grid[i].length\n1 <= m, n <= 30\ngrid[i][j] is either an English letter, '.', '#', or '@'.\u00a0\nThere is exactly one\u00a0'@'\u00a0in the grid.\nThe number of keys in the grid is in the range [1, 6].\nEach key in the grid is unique.\nEach key in the grid has a matching lock.",
        "oracle_code": "class Solution {\npublic:\n\n    int dir[4][2] = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};\n\n    int shortestPathAllKeys(vector<string>& grid) {\n        \n        int m = grid.size();\n        int n = grid[0].size();\n        queue<pair<pair<int, int>, int>> que;\n        vector<vector<unsigned long>> mapKey(m, vector<unsigned long>(n, 0));\n        int target = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if ('a' <= grid[i][j] && grid[i][j] <= 'f') {\n                    target |= 1 << (grid[i][j] - 'a');\n                    continue;\n                }\n\n                if (grid[i][j] == '@') {\n                    que.emplace(pair<int, int>(i, j), 0);\n                    mapKey[i][j] = 1;\n                }\n            }\n        }\n\n\n        int step = 0;\n        while (!que.empty()) {\n            int size = que.size();\n            for (int s = 0; s < size; s++) {\n                int i = que.front().first.first;\n                int j = que.front().first.second;\n                int key = que.front().second;\n                que.pop();\n                \n                if ('a' <= grid[i][j] && grid[i][j] <= 'f') {\n                    key |= 1 << (grid[i][j] - 'a');\n                    if (key == target)\n                        return step;\n\n                    mapKey[i][j] |= 1l << key;\n                }\n\n                for (int d = 0; d < 4; d++) {\n                    int newi = i + dir[d][0];\n                    int newj = j + dir[d][1];\n                    \n                    if (!(0 <= newi && newi < m && 0 <= newj && newj < n))\n                        continue;\n                        \n                    int val = grid[newi][newj];\n                    if (val == '#')\n                        continue;\n                        \n                    if ('A' <= val && val <= 'F' && (key & (1 << (val - 'A'))) == 0)\n                        continue;\n                        \n                    if (mapKey[newi][newj] & (1l << key))\n                        continue;\n                        \n                     mapKey[newi][newj] |= 1l << key;\n                     que.emplace(pair<int, int>(newi, newj), key);\n                }\n            }\n            step++;\n        }\n        return -1;\n    }\n};",
        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int dir[4][2] = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};\\n\\n    int shortestPathAllKeys(vector<string>& grid) {\\n        \\n        int m = grid.size();\\n        int n = grid[0].size();\\n        queue<pair<pair<int, int>, int>> que;\\n        vector<vector<unsigned long>> mapKey(m, vector<unsigned long>(n, 0));\\n        int target = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (\\'a\\' <= grid[i][j] && grid[i][j] <= \\'f\\') {\\n                    target |= 1 << (grid[i][j] - \\'a\\');\\n                    continue;\\n                }\\n\\n                if (grid[i][j] == \\'@\\') {\\n                    que.emplace(pair<int, int>(i, j), 0);\\n                    mapKey[i][j] = 1;\\n                }\\n            }\\n        }\\n\\n\\n        int step = 0;\\n        while (!que.empty()) {\\n            int size = que.size();\\n            for (int s = 0; s < size; s++) {\\n                int i = que.front().first.first;\\n                int j = que.front().first.second;\\n                int key = que.front().second;\\n                que.pop();\\n                \\n                if (\\'a\\' <= grid[i][j] && grid[i][j] <= \\'f\\') {\\n                    key |= 1 << (grid[i][j] - \\'a\\');\\n                    if (key == target)\\n                        return step;\\n\\n                    mapKey[i][j] |= 1l << key;\\n                }\\n\\n                for (int d = 0; d < 4; d++) {\\n                    int newi = i + dir[d][0];\\n                    int newj = j + dir[d][1];\\n                    \\n                    if (!(0 <= newi && newi < m && 0 <= newj && newj < n))\\n                        continue;\\n                        \\n                    int val = grid[newi][newj];\\n                    if (val == \\'#\\')\\n                        continue;\\n                        \\n                    if (\\'A\\' <= val && val <= \\'F\\' && (key & (1 << (val - \\'A\\'))) == 0)\\n                        continue;\\n                        \\n                    if (mapKey[newi][newj] & (1l << key))\\n                        continue;\\n                        \\n                     mapKey[newi][newj] |= 1l << key;\\n                     que.emplace(pair<int, int>(newi, newj), key);\\n                }\\n            }\\n            step++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
        "level": "hard",
        "type": [
            "== and = confusion",
            "statement separation",
            "operation error",
            "colon missing"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n\n    int dir[4][2] = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};\n\n    int shortestPathAllKeys(vector<string>& grid) {\n        \n        int m = grid.size();\n        int n = grid[0].size();\n        queue<pair<pair<int, int>, int>> que;\n        vector<vector<unsigned long>> mapKey(m, vector<unsigned long>(n, 0));\n        int target = 0;\n        for (int i = 0; i < m; i++) \n            for (int j = 0; j < n; j++) \n                if ('a' <= grid[i][j] && grid[i][j] <= 'f') {\n                    target |= 1  (grid[i][j] - 'a');\n                    continue;\n\n                if (grid[i][j] = '@') {\n                    que.emplace(pair<int, int>(i, j), 0);\n                    mapKey[i][j] = 1;\n                }\n            \n\n\n        int step = 0;\n        while (!que.empty()) {\n            int size = que.size();\n            for (int s = 0; s < size; s++) {\n                int i = que.front().first.first;\n                int j = que.front().first.second;\n                int key = que.front().second;\n                que.pop();\n                \n                if ('a' <= grid[i][j] && grid[i][j] <= 'f') {\n                    key |= 1  (grid[i][j] - 'a');\n                    if (key == target)\n                        return step;\n\n                    mapKey[i][j] |= 1l << key;\n                }\n\n                for (int d = 0; d < 4; d++) {\n                    int newi = i + dir[d][0];\n                    int newj = j + dir[d][1];\n                    \n                    if (!(0 <= newi && newi < m && 0 <= newj && newj < n))\n                        continue;\n                        \n                    int val = grid[newi][newj];\n                    if (val == '#')\n                        continue;\n                        \n                    if ('A' <= val && val <= 'F' && (key & (1  (val - 'A'))) == 0)\n                        continue;\n                        \n                    if (mapKey[newi][newj] & (1l << key))\n                        continue;\n                        \n                     mapKey[newi][newj] |= 1l << (key+1);  \n                     que.emplace(pair<int, int>(newi, newj), key);\n                }\n            }\n            step++;\n        }\n        return -1;\n    }\n};\n"
    },
    {
        "slug": "shortest-path-with-alternating-colors",
        "description": "You are given an integer n, the number of nodes in a directed graph where the nodes are labeled from 0 to n - 1. Each edge is red or blue in this graph, and there could be self-edges and parallel edges.\nYou are given two arrays redEdges and blueEdges where:\n\nredEdges[i] = [ai, bi] indicates that there is a directed red edge from node ai to node bi in the graph, and\nblueEdges[j] = [uj, vj] indicates that there is a directed blue edge from node uj to node vj in the graph.\n\nReturn an array answer of length n, where each answer[x] is the length of the shortest path from node 0 to node x such that the edge colors alternate along the path, or -1 if such a path does not exist.",
        "examples": [
            "Input: n = 3, redEdges = [[0,1],[1,2]], blueEdges = []\nOutput: [0,1,-1]",
            "Input: n = 3, redEdges = [[0,1]], blueEdges = [[2,1]]\nOutput: [0,1,-1]"
        ],
        "constraints": "1 <= n <= 100\n0 <= redEdges.length,\u00a0blueEdges.length <= 400\nredEdges[i].length == blueEdges[j].length == 2\n0 <= ai, bi, uj, vj < n",
        "oracle_code": "class Solution {\npublic:\n    vector<int> shortestAlternatingPaths(int n,vector<vector<int>>&redEdges,vector<vector<int>>& blueEdges) \n    {\n        multiset<int>temp;\n        vector<multiset<int>>redchilds(n,temp),bluechilds(n,temp);\n        for(auto j:redEdges)\n        {\n            redchilds[j[0]].insert(j[1]);\n        }\n        for(auto j:blueEdges)\n        {\n            bluechilds[j[0]].insert(j[1]);\n        }\n        vector<int>ans;\n        for(int i=0;i<n;i++)\n        {\n            //BFS for all\n            vector<multiset<int>>reds=redchilds,blues=bluechilds;\n            queue<pair<char,int>>visit;\n            visit.push({'n',0});//neutral='n'\n            int steps=0;\n            while(!visit.empty())\n            {\n                bool justbreak=false;\n                int n=visit.size();\n                for(int j=0;j<n;j++)\n                {\n                    pair<char,int>x=visit.front();\n                    visit.pop();\n                    if(x.second==i)\n                    {\n                        ans.push_back(steps);\n                        justbreak=true;\n                        break;\n                    }\n                    if(x.first=='n')\n                    {\n                        for(auto j:reds[x.second])\n                        {\n                            visit.push({'r',j});\n                            auto itr1=reds[x.second].find(j);\n                            reds[x.second].erase(itr1);\n                        }\n                        for(auto j:blues[x.second])\n                        {\n                            visit.push({'b',j});//blue='b'\n                            auto itr1=blues[x.second].find(j);\n                            blues[x.second].erase(itr1);\n                        }\n                    }\n                    else if(x.first=='b')\n                    {\n                        for(auto j:reds[x.second])\n                        {\n                            visit.push({'r',j});//red='r'\n                            auto itr1=reds[x.second].find(j);\n                            reds[x.second].erase(itr1);\n                        }\n                    }\n                    else if(x.first=='r')\n                    {\n                        for(auto j:blues[x.second])\n                        {\n                            visit.push({'b',j});\n                            auto itr1=blues[x.second].find(j);\n                            blues[x.second].erase(itr1);\n                        }\n                    }\n                }\n                if(justbreak)\n                {\n                    break;\n                }\n                steps++;\n            }\n            if(i==ans.size())\n            {\n                ans.push_back(-1);\n            }\n        }\n        return ans;\n    }\n};",
        "content": "*E denotes number of Edges*\\n\\n# Complexity\\n- Time complexity:\\nO((N^2)+(N)*(E)*LOG(E))\\n\\n- Space complexity:\\nO(E)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> shortestAlternatingPaths(int n,vector<vector<int>>&redEdges,vector<vector<int>>& blueEdges) \\n    {\\n        multiset<int>temp;\\n        vector<multiset<int>>redchilds(n,temp),bluechilds(n,temp);\\n        for(auto j:redEdges)\\n        {\\n            redchilds[j[0]].insert(j[1]);\\n        }\\n        for(auto j:blueEdges)\\n        {\\n            bluechilds[j[0]].insert(j[1]);\\n        }\\n        vector<int>ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            //BFS for all\\n            vector<multiset<int>>reds=redchilds,blues=bluechilds;\\n            queue<pair<char,int>>visit;\\n            visit.push({\\'n\\',0});//neutral=\\'n\\'\\n            int steps=0;\\n            while(!visit.empty())\\n            {\\n                bool justbreak=false;\\n                int n=visit.size();\\n                for(int j=0;j<n;j++)\\n                {\\n                    pair<char,int>x=visit.front();\\n                    visit.pop();\\n                    if(x.second==i)\\n                    {\\n                        ans.push_back(steps);\\n                        justbreak=true;\\n                        break;\\n                    }\\n                    if(x.first==\\'n\\')\\n                    {\\n                        for(auto j:reds[x.second])\\n                        {\\n                            visit.push({\\'r\\',j});\\n                            auto itr1=reds[x.second].find(j);\\n                            reds[x.second].erase(itr1);\\n                        }\\n                        for(auto j:blues[x.second])\\n                        {\\n                            visit.push({\\'b\\',j});//blue=\\'b\\'\\n                            auto itr1=blues[x.second].find(j);\\n                            blues[x.second].erase(itr1);\\n                        }\\n                    }\\n                    else if(x.first==\\'b\\')\\n                    {\\n                        for(auto j:reds[x.second])\\n                        {\\n                            visit.push({\\'r\\',j});//red=\\'r\\'\\n                            auto itr1=reds[x.second].find(j);\\n                            reds[x.second].erase(itr1);\\n                        }\\n                    }\\n                    else if(x.first==\\'r\\')\\n                    {\\n                        for(auto j:blues[x.second])\\n                        {\\n                            visit.push({\\'b\\',j});\\n                            auto itr1=blues[x.second].find(j);\\n                            blues[x.second].erase(itr1);\\n                        }\\n                    }\\n                }\\n                if(justbreak)\\n                {\\n                    break;\\n                }\\n                steps++;\\n            }\\n            if(i==ans.size())\\n            {\\n                ans.push_back(-1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "wrong comment mark",
            "unclosed string",
            "undefined methods",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    vector<int> shortestAlternatingPaths(int n,vector<vector<int>>&redEdges,vector<vector<int>>& blueEdges) \n    {\n        multiset<int>temp;\n        vector<multiset<int>>redchilds(n,temp),bluechilds(n,temp);\n        for(auto j:redEdges)\n        {\n            redchilds[j[0]].insert(j[1]);\n        }\n        for(auto j:blueEdges)\n        {\n            bluechilds[j[0]].insert(j[1]);\n        }\n        vector<int>ans;\n        for(int i=0;i<n;i++)\n        {\n            //BFS for all\n            vector<multiset<int>>reds=redchilds,blues=bluechilds;\n            queue<pair<char,int>>visit;\n            visit.push({'n',0});//neutral='n'\n            int steps=0;\n            while(!visit.empty()\n            {\n                bool justbreak=false;\n                int n=visit.size();\n                for(int j=0;j<n;j++)\n                {\n                    pair<char,int>x=visit.front();\n                    \n                    if(x.second==i)\n                    {\n                        ans.push_back(steps);\n                        justbreak=true;\n                        break;\n                    }\n                    if(x.first=='n')\n                    {\n                        for(auto j:reds[x.second])\n                        {\n                            visit.push({'r\",j});\n                            auto itr1=reds[x.second].find(j);\n                            reds[x.second].erase(itr1);\n                        }\n                        for(auto j:blues[x.second])\n                        {\n                            visit.push({'b',j});//blue='b'\n                            auto itr1=blues[x.second].find(j);\n                            unknownFunction(itr1); \n                            blues[x.second].erase(itr1);\n                        }\n                    }\n                    else if(x.first=='b')\n                    {\n                        for(auto j:reds[x.second])\n                        {\n                            visit.push({'r',j});//red='r'\n                            auto itr1=reds[x.second].find(j);\n                            reds[x.second].erase(itr1);\n                        }\n                    }\n                    else if(x.first=='r')\n                    {\n                        for(auto j:blues[x.second])\n                        {\n                            visit.push({'b',j});\n                            auto itr1=blues[x.second].find(j);\n                            blues[x.second].erase(itr1);\n                        }\n                    }\n                }\n                if(justbreak)\n                {\n                    break;\n                }\n                steps++;\n            }\n            if(i==ans.size())\n            {\n                ans.push_back(-1);\n            }\n        }\n        return ans;\n    }\n};\n"
    },
    {
        "slug": "check-knight-tour-configuration",
        "description": "There is a knight on an n x n chessboard. In a valid configuration, the knight starts at the top-left cell of the board and visits every cell on the board exactly once.\nYou are given an n x n integer matrix grid consisting of distinct integers from the range [0, n * n - 1] where grid[row][col] indicates that the cell (row, col) is the grid[row][col]th cell that the knight visited. The moves are 0-indexed.\nReturn true if grid represents a valid configuration of the knight's movements or false otherwise.\nNote that a valid knight move consists of moving two squares vertically and one square horizontally, or two squares horizontally and one square vertically. The figure below illustrates all the possible eight moves of a knight from some cell.",
        "examples": [
            "Input: grid = [[0,11,16,5,20],[17,4,19,10,15],[12,1,8,21,6],[3,18,23,14,9],[24,13,2,7,22]]\nOutput: true\nExplanation: The above diagram represents the grid. It can be shown that it is a valid configuration.",
            "Input: grid = [[0,3,6],[5,8,1],[2,7,4]]\nOutput: false\nExplanation: The above diagram represents the grid. The 8th move of the knight is not valid considering its position after the 7th move."
        ],
        "constraints": "n == grid.length == grid[i].length\n3 <= n <= 7\n0 <= grid[row][col] < n * n\nAll integers in grid are unique.",
        "oracle_code": "class Solution {\nprivate:\n    bool helper(vector<vector<int>>& grid, int row, int col, int num){\n        int n = grid.size();\n        if(num == n*n) return true;\n        int i = row-2;\n        int j = col+1;\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row-2;\n        j = col-1;\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 2;\n        j = col - 1;\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 2;\n        j = col + 1;\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 1;\n        j = col + 2;\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row - 1;\n        j = col + 2;\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row - 1;\n        j = col - 2;\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 1;\n        j = col - 2;\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        return false;\n    }\npublic:\n    bool checkValidGrid(vector<vector<int>>& grid) {\n        ios::sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);\n        if(grid[0][0] != 0) return false;\n        return helper(grid,0,0,1);\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    bool helper(vector<vector<int>>& grid, int row, int col, int num){\\n        int n = grid.size();\\n        if(num == n*n) return true;\\n        int i = row-2;\\n        int j = col+1;\\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row-2;\\n        j = col-1;\\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row + 2;\\n        j = col - 1;\\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row + 2;\\n        j = col + 1;\\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row + 1;\\n        j = col + 2;\\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row - 1;\\n        j = col + 2;\\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row - 1;\\n        j = col - 2;\\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row + 1;\\n        j = col - 2;\\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        return false;\\n    }\\npublic:\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(0);\\n        cout.tie(0);\\n        if(grid[0][0] != 0) return false;\\n        return helper(grid,0,0,1);\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "== and = confusion",
            "operation error",
            "undefined methods",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution {\nprivate:\n    bool helper(vector<vector<int>>& grid, int row, int col, int num){\n        int n = grid.size();\n\n        undefinedObject test;  \n\n        if(num = n*n) return true;\n        int i = row-2;\n        int j = col+1;\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row-2;\n        j = col-1;\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+2);\n\n        i = row + 2;\n        j = col - 1;\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 2;\n        j = col + 1;\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 1;\n        j = col + 2;\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row - 1;\n        j = col + 2;\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row - 1;\n        j = col - 2;\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 1;\n        j = col - 2;\n        if(i<n && j>=0 && grid[i][j] == num) return methodNotFound(grid,i,j,num+1);\n\n        return false;\n    }\npublic:\n    bool checkValidGrid(vector<vector<int>>& grid) {\n        ios::sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);\n        if(grid[0][0] != 0) return false;\n        return helper(grid,0,0,1);\n    }\n};\n"
    },
    {
        "slug": "shortest-path-to-get-all-keys",
        "description": "You are given an m x n grid grid where:\n\n'.' is an empty cell.\n'#' is a wall.\n'@' is the starting point.\nLowercase letters represent keys.\nUppercase letters represent locks.\n\nYou start at the starting point and one move consists of walking one space in one of the four cardinal directions. You cannot walk outside the grid, or walk into a wall.\nIf you walk over a key, you can pick it up and you cannot walk over a lock unless you have its corresponding key.\nFor some 1 <= k <= 6, there is exactly one lowercase and one uppercase letter of the first k letters of the English alphabet in the grid. This means that there is exactly one key for each lock, and one lock for each key; and also that the letters used to represent the keys and locks were chosen in the same order as the English alphabet.\nReturn the lowest number of moves to acquire all keys. If it is impossible, return -1.",
        "examples": [
            "Input: grid = [\"@.a..\",\"###.#\",\"b.A.B\"]\nOutput: 8\nExplanation: Note that the goal is to obtain all the keys not to open all the locks.",
            "Input: grid = [\"@..aA\",\"..B#.\",\"....b\"]\nOutput: 6",
            "Input: grid = [\"@Aa\"]\nOutput: -1"
        ],
        "constraints": "m == grid.length\nn == grid[i].length\n1 <= m, n <= 30\ngrid[i][j] is either an English letter, '.', '#', or '@'.\u00a0\nThere is exactly one\u00a0'@'\u00a0in the grid.\nThe number of keys in the grid is in the range [1, 6].\nEach key in the grid is unique.\nEach key in the grid has a matching lock.",
        "oracle_code": "class Solution {\npublic:\n\n    int dir[4][2] = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};\n\n    int shortestPathAllKeys(vector<string>& grid) {\n        \n        int m = grid.size();\n        int n = grid[0].size();\n        queue<pair<pair<int, int>, int>> que;\n        vector<vector<unsigned long>> mapKey(m, vector<unsigned long>(n, 0));\n        int target = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if ('a' <= grid[i][j] && grid[i][j] <= 'f') {\n                    target |= 1 << (grid[i][j] - 'a');\n                    continue;\n                }\n\n                if (grid[i][j] == '@') {\n                    que.emplace(pair<int, int>(i, j), 0);\n                    mapKey[i][j] = 1;\n                }\n            }\n        }\n\n\n        int step = 0;\n        while (!que.empty()) {\n            int size = que.size();\n            for (int s = 0; s < size; s++) {\n                int i = que.front().first.first;\n                int j = que.front().first.second;\n                int key = que.front().second;\n                que.pop();\n                \n                if ('a' <= grid[i][j] && grid[i][j] <= 'f') {\n                    key |= 1 << (grid[i][j] - 'a');\n                    if (key == target)\n                        return step;\n\n                    mapKey[i][j] |= 1l << key;\n                }\n\n                for (int d = 0; d < 4; d++) {\n                    int newi = i + dir[d][0];\n                    int newj = j + dir[d][1];\n                    \n                    if (!(0 <= newi && newi < m && 0 <= newj && newj < n))\n                        continue;\n                        \n                    int val = grid[newi][newj];\n                    if (val == '#')\n                        continue;\n                        \n                    if ('A' <= val && val <= 'F' && (key & (1 << (val - 'A'))) == 0)\n                        continue;\n                        \n                    if (mapKey[newi][newj] & (1l << key))\n                        continue;\n                        \n                     mapKey[newi][newj] |= 1l << key;\n                     que.emplace(pair<int, int>(newi, newj), key);\n                }\n            }\n            step++;\n        }\n        return -1;\n    }\n};",
        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int dir[4][2] = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};\\n\\n    int shortestPathAllKeys(vector<string>& grid) {\\n        \\n        int m = grid.size();\\n        int n = grid[0].size();\\n        queue<pair<pair<int, int>, int>> que;\\n        vector<vector<unsigned long>> mapKey(m, vector<unsigned long>(n, 0));\\n        int target = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (\\'a\\' <= grid[i][j] && grid[i][j] <= \\'f\\') {\\n                    target |= 1 << (grid[i][j] - \\'a\\');\\n                    continue;\\n                }\\n\\n                if (grid[i][j] == \\'@\\') {\\n                    que.emplace(pair<int, int>(i, j), 0);\\n                    mapKey[i][j] = 1;\\n                }\\n            }\\n        }\\n\\n\\n        int step = 0;\\n        while (!que.empty()) {\\n            int size = que.size();\\n            for (int s = 0; s < size; s++) {\\n                int i = que.front().first.first;\\n                int j = que.front().first.second;\\n                int key = que.front().second;\\n                que.pop();\\n                \\n                if (\\'a\\' <= grid[i][j] && grid[i][j] <= \\'f\\') {\\n                    key |= 1 << (grid[i][j] - \\'a\\');\\n                    if (key == target)\\n                        return step;\\n\\n                    mapKey[i][j] |= 1l << key;\\n                }\\n\\n                for (int d = 0; d < 4; d++) {\\n                    int newi = i + dir[d][0];\\n                    int newj = j + dir[d][1];\\n                    \\n                    if (!(0 <= newi && newi < m && 0 <= newj && newj < n))\\n                        continue;\\n                        \\n                    int val = grid[newi][newj];\\n                    if (val == \\'#\\')\\n                        continue;\\n                        \\n                    if (\\'A\\' <= val && val <= \\'F\\' && (key & (1 << (val - \\'A\\'))) == 0)\\n                        continue;\\n                        \\n                    if (mapKey[newi][newj] & (1l << key))\\n                        continue;\\n                        \\n                     mapKey[newi][newj] |= 1l << key;\\n                     que.emplace(pair<int, int>(newi, newj), key);\\n                }\\n            }\\n            step++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
        "level": "hard",
        "type": [
            "== and = confusion",
            "operation error",
            "wrong comment mark",
            "colon missing"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n\n    int dir[4][2] = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};\n\n    int shortestPathAllKeys(vector<string>& grid) {\n        \n        int m = grid.size();\n        int n = grid[0].size();\n        queue<pair<pair<int, int>, int>> que;\n        vector<vector<unsigned long>> mapKey(m, vector<unsigned long>(n, 0));\n        int target = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if ('a' <= grid[i][j] && grid[i][j] <= 'f') {\n                    target |= 1  (grid[i][j] - 'a');\n                    continue;\n                }\n\n                if (grid[i][j] = '@') {\n                    que.emplace(pair<int, int>(i, j), 0);\n                    mapKey[i][j] = 1;\n                }\n            }\n        }\n\n\n        int step = 0;\n        while (!que.empty()) {\n            int size = que.size();\n            for (int s = 0; s < size; s++) {\n                int i = que.front().first.first;\n                int j = que.front().first.second;\n                int key = que.front().second;\n                que.pop();\n                \n                if ('a' <= grid[i][j] && grid[i][j] <= 'f') {\n                    key |= 1  (grid[i][j] - 'a');\n                    if (key == target)\n                        return step;\n\n                    mapKey[i][j] |= 1l << key;\n                }\n\n                for (int d = 0; d < 4; d++) {\n                   \n                    int newj = j + dir[d][1];\n                    \n                    if (!(0 <= newi && newi < m && 0 <= newj && newj < n))\n                        continue;\n                        \n                    int val = grid[newi][newj];\n                    if (val == '#')\n                        continue;\n                        \n                    if ('A' <= val && val <= 'F' && (key & (1  (val - 'A'))) == 0)\n                        continue;\n                        \n                    if (mapKey[newi][newj] & (1l << key))\n                        continue;\n                        \n                     mapKey[newi][newj] |= 1l << (key+1);  \n                     que.emplace(pair<int, int>(newi, newj), key);\n                }\n            }\n            step++;\n        }\n        return -1;\n    }\n};\n"
    },
    {
        "slug": "shortest-path-with-alternating-colors",
        "description": "You are given an integer n, the number of nodes in a directed graph where the nodes are labeled from 0 to n - 1. Each edge is red or blue in this graph, and there could be self-edges and parallel edges.\nYou are given two arrays redEdges and blueEdges where:\n\nredEdges[i] = [ai, bi] indicates that there is a directed red edge from node ai to node bi in the graph, and\nblueEdges[j] = [uj, vj] indicates that there is a directed blue edge from node uj to node vj in the graph.\n\nReturn an array answer of length n, where each answer[x] is the length of the shortest path from node 0 to node x such that the edge colors alternate along the path, or -1 if such a path does not exist.",
        "examples": [
            "Input: n = 3, redEdges = [[0,1],[1,2]], blueEdges = []\nOutput: [0,1,-1]",
            "Input: n = 3, redEdges = [[0,1]], blueEdges = [[2,1]]\nOutput: [0,1,-1]"
        ],
        "constraints": "1 <= n <= 100\n0 <= redEdges.length,\u00a0blueEdges.length <= 400\nredEdges[i].length == blueEdges[j].length == 2\n0 <= ai, bi, uj, vj < n",
        "oracle_code": "class Solution {\npublic:\n    vector<int> shortestAlternatingPaths(int n,vector<vector<int>>&redEdges,vector<vector<int>>& blueEdges) \n    {\n        multiset<int>temp;\n        vector<multiset<int>>redchilds(n,temp),bluechilds(n,temp);\n        for(auto j:redEdges)\n        {\n            redchilds[j[0]].insert(j[1]);\n        }\n        for(auto j:blueEdges)\n        {\n            bluechilds[j[0]].insert(j[1]);\n        }\n        vector<int>ans;\n        for(int i=0;i<n;i++)\n        {\n            //BFS for all\n            vector<multiset<int>>reds=redchilds,blues=bluechilds;\n            queue<pair<char,int>>visit;\n            visit.push({'n',0});//neutral='n'\n            int steps=0;\n            while(!visit.empty())\n            {\n                bool justbreak=false;\n                int n=visit.size();\n                for(int j=0;j<n;j++)\n                {\n                    pair<char,int>x=visit.front();\n                    visit.pop();\n                    if(x.second==i)\n                    {\n                        ans.push_back(steps);\n                        justbreak=true;\n                        break;\n                    }\n                    if(x.first=='n')\n                    {\n                        for(auto j:reds[x.second])\n                        {\n                            visit.push({'r',j});\n                            auto itr1=reds[x.second].find(j);\n                            reds[x.second].erase(itr1);\n                        }\n                        for(auto j:blues[x.second])\n                        {\n                            visit.push({'b',j});//blue='b'\n                            auto itr1=blues[x.second].find(j);\n                            blues[x.second].erase(itr1);\n                        }\n                    }\n                    else if(x.first=='b')\n                    {\n                        for(auto j:reds[x.second])\n                        {\n                            visit.push({'r',j});//red='r'\n                            auto itr1=reds[x.second].find(j);\n                            reds[x.second].erase(itr1);\n                        }\n                    }\n                    else if(x.first=='r')\n                    {\n                        for(auto j:blues[x.second])\n                        {\n                            visit.push({'b',j});\n                            auto itr1=blues[x.second].find(j);\n                            blues[x.second].erase(itr1);\n                        }\n                    }\n                }\n                if(justbreak)\n                {\n                    break;\n                }\n                steps++;\n            }\n            if(i==ans.size())\n            {\n                ans.push_back(-1);\n            }\n        }\n        return ans;\n    }\n};",
        "content": "*E denotes number of Edges*\\n\\n# Complexity\\n- Time complexity:\\nO((N^2)+(N)*(E)*LOG(E))\\n\\n- Space complexity:\\nO(E)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> shortestAlternatingPaths(int n,vector<vector<int>>&redEdges,vector<vector<int>>& blueEdges) \\n    {\\n        multiset<int>temp;\\n        vector<multiset<int>>redchilds(n,temp),bluechilds(n,temp);\\n        for(auto j:redEdges)\\n        {\\n            redchilds[j[0]].insert(j[1]);\\n        }\\n        for(auto j:blueEdges)\\n        {\\n            bluechilds[j[0]].insert(j[1]);\\n        }\\n        vector<int>ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            //BFS for all\\n            vector<multiset<int>>reds=redchilds,blues=bluechilds;\\n            queue<pair<char,int>>visit;\\n            visit.push({\\'n\\',0});//neutral=\\'n\\'\\n            int steps=0;\\n            while(!visit.empty())\\n            {\\n                bool justbreak=false;\\n                int n=visit.size();\\n                for(int j=0;j<n;j++)\\n                {\\n                    pair<char,int>x=visit.front();\\n                    visit.pop();\\n                    if(x.second==i)\\n                    {\\n                        ans.push_back(steps);\\n                        justbreak=true;\\n                        break;\\n                    }\\n                    if(x.first==\\'n\\')\\n                    {\\n                        for(auto j:reds[x.second])\\n                        {\\n                            visit.push({\\'r\\',j});\\n                            auto itr1=reds[x.second].find(j);\\n                            reds[x.second].erase(itr1);\\n                        }\\n                        for(auto j:blues[x.second])\\n                        {\\n                            visit.push({\\'b\\',j});//blue=\\'b\\'\\n                            auto itr1=blues[x.second].find(j);\\n                            blues[x.second].erase(itr1);\\n                        }\\n                    }\\n                    else if(x.first==\\'b\\')\\n                    {\\n                        for(auto j:reds[x.second])\\n                        {\\n                            visit.push({\\'r\\',j});//red=\\'r\\'\\n                            auto itr1=reds[x.second].find(j);\\n                            reds[x.second].erase(itr1);\\n                        }\\n                    }\\n                    else if(x.first==\\'r\\')\\n                    {\\n                        for(auto j:blues[x.second])\\n                        {\\n                            visit.push({\\'b\\',j});\\n                            auto itr1=blues[x.second].find(j);\\n                            blues[x.second].erase(itr1);\\n                        }\\n                    }\\n                }\\n                if(justbreak)\\n                {\\n                    break;\\n                }\\n                steps++;\\n            }\\n            if(i==ans.size())\\n            {\\n                ans.push_back(-1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "unclosed string",
            "conditional statement error",
            "undefined methods",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    vector<int> shortestAlternatingPaths(int n,vector<vector<int>>&redEdges,vector<vector<int>>& blueEdges) \n    {\n        multiset<int>temp;\n        vector<multiset<int>>redchilds(n,temp),bluechilds(n,temp);\n        for(auto j:redEdges)\n        {\n            redchilds[j[0]].insert(j[1]);\n        }\n        for(auto j:blueEdges)\n        {\n            bluechilds[j[0]].insert(j[1]);\n        }\n        vector<int>ans(n, -1);\n        for(int i=0;i<n;) \n        {\n            //BFS for all\n            vector<multiset<int>>reds=redchilds,blues=bluechilds;\n            queue<pair<char,int>>visit;\n            visit.push({'n',0});//neutral='n'\n            int steps=0;\n            while(!visit.empty()\n            {\n                bool justbreak=false;\n                int n=visit.size();\n                for(int j=0;j<n;j++)\n                {\n                    pair<char,int>x=visit.front();\n                    visit.pop();\n                    if(x.second==i)\n                    {\n                        ans[i]=steps;\n                        justbreak=true;\n                        break;\n                    }\n                    if(x.first=='n' || x.first == ans[i] % 2 + '0') \n                    {\n                        for(auto j:reds[x.second])\n                        {\n                            visit.push({'r\",j});\n                            auto itr1=reds[x.second].find(j);\n                            reds[x.second].erase(itr1);\n                        }\n                        for(auto j:blues[x.second])\n                        {\n                            visit.push({'b',j});//blue='b'\n                            auto itr1=blues[x.second].find(j);\n                            unknownFunction(itr1); \n                            blues[x.second].erase(itr1);\n                        }\n                    }\n                    else if(x.first=='b')\n                    {\n                        for(auto j:reds[x.second])\n                        {\n                            visit.push({'r',j});//red='r'\n                            auto itr1=reds[x.second].find(j);\n                            reds[x.second].erase(itr1);\n                        }\n                    }\n                    else if(x.first=='r')\n                    {\n                        for(auto j:blues[x.second])\n                        {\n                            visit.push({'b',j});\n                            auto itr1=blues[x.second].find(j);\n                            blues[x.second].erase(itr1);\n                        }\n                    }\n                }\n                if(justbreak)\n                {\n                    break;\n                }\n                steps++;\n            }\n        }\n        return ans;\n    }\n};\n"
    },
    {
        "slug": "longest-common-prefix",
        "description": "Write a function to find the longest common prefix string amongst an array of strings.\nIf there is no common prefix, return an empty string \"\".",
        "examples": [
            "Input: strs = [\"flower\",\"flow\",\"flight\"]\nOutput: \"fl\"",
            "Input: strs = [\"dog\",\"racecar\",\"car\"]\nOutput: \"\"\nExplanation: There is no common prefix among the input strings."
        ],
        "constraints": "1 <= strs.length <= 200\n0 <= strs[i].length <= 200\nstrs[i] consists of only lowercase English letters.",
        "oracle_code": "class Solution {\npublic:\n    string longestCommonPrefix(vector<string>& str) \n    {\n        sort(str.begin(), str.end()); //sorting the array\n        string ans=\"\"; //creating a new empty string to store the common prefixes\n        for(int i=0;i<str[0].length();i++) // max iterations = length of the first string\n        {\n            if(str[0][i]!=str[str.size()-1][i]) // checking the characters of the first and last string\n                break;\n            ans+=str[0][i]; // concatinate if the characters are matching\n        }\n        return ans;\n    }\n};",
        "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWhen you sort an array, it is enough to check for the common characters of the the first & last string of the sorted vector.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& str) \\n    {\\n        sort(str.begin(), str.end()); //sorting the array\\n        string ans=\"\"; //creating a new empty string to store the common prefixes\\n        for(int i=0;i<str[0].length();i++) // max iterations = length of the first string\\n        {\\n            if(str[0][i]!=str[str.size()-1][i]) // checking the characters of the first and last string\\n                break;\\n            ans+=str[0][i]; // concatinate if the characters are matching\\n        }\\n        return ans;\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "statement separation",
            "indexing error",
            "conditional statement error",
            "colon missing"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    string longestCommonPrefix(vector<string>& str) \n    {\n        sort(str.begin(), str.end()); //sorting the array\n        string ans=\"\"; //creating a new empty string to store the common prefixes\n        for(int i=0;i<=str[0].length();i) \n       i(str[0][i]!=str[str.size()][i]) \n                break;\n        ans+=str[0][i]; \n        return ans;\n    }\n};\n"
    },
    {
        "slug": "valid-anagram",
        "description": "Given two strings s and t, return true if t is an anagram of s, and false otherwise.\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.",
        "examples": [
            "Input: s = \"anagram\", t = \"nagaram\"\nOutput: true",
            "Input: s = \"rat\", t = \"car\"\nOutput: false"
        ],
        "constraints": "1 <= s.length, t.length <= 5 * 104\ns and t consist of lowercase English letters.",
        "oracle_code": "class Solution {\npublic:\n    bool isAnagram(string s, string t) {\n        if(s.length()!=t.length())\n            return false;\n        vector<int> freq(26, 0);\n        for(int i =0; i<s.length(); i++){\n            freq[s[i]-'a']++;\n            freq[t[i]-'a']--;\n        }\n        for(int i =0; i<freq.size(); i++){\n            if(freq[i]!=0)\n                return false;\n        }\n        return true;\n    }\n};",
        "content": "# Intuition\\nTo solve this problem we will count occurence of each character in both strings and if they are same then both strings are anagram of each other.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nWe can use vector of length 26 to track the occurences of character. \\nIf the size of both string is different then they can\\'t be anagram of each other, so we are checking this first.We loop through each character in both strings and increment the frequency of the corresponding letter in s and decrement the frequency of the corresponding letter in t.\\nThen we loop through freq array if all the elements are 0, if all the elements are 0 this means the two strings are anagram and if not then these things are not anagram of each othe.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n), n is the size of s or t string.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isAnagram(string s, string t) {\\n        if(s.length()!=t.length())\\n            return false;\\n        vector<int> freq(26, 0);\\n        for(int i =0; i<s.length(); i++){\\n            freq[s[i]-\\'a\\']++;\\n            freq[t[i]-\\'a\\']--;\\n        }\\n        for(int i =0; i<freq.size(); i++){\\n            if(freq[i]!=0)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "indexing error",
            "operation error",
            "unclosed string",
            "colon missing"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    bool isAnagram(string s, string t) {\n        if(s.length()!=t.length())\n            return false\n        vector<int> freq(26, 0);\n        for(int i =0; i<=s.length(); i++){\n            freq[s[i]-'a']++;\n            freq[t[i]-'a']++;\n        }\n        for(int i =0; i<freq.size(); i++){\n            if(freq[i]!=0)\n                return 'false;\n        }\n        return true;\n    }\n};\n"
    },
    {
        "slug": "merge-two-binary-trees",
        "description": "You are given two binary trees root1 and root2.\nImagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge the two trees into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of the new tree.\nReturn the merged tree.\nNote: The merging process must start from the root nodes of both trees.",
        "examples": [
            "Input: root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]\nOutput: [3,4,5,5,4,null,7]",
            "Input: root1 = [1], root2 = [1,2]\nOutput: [2,2]"
        ],
        "constraints": "The number of nodes in both trees is in the range [0, 2000].\n-104 <= Node.val <= 104",
        "oracle_code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {\n        if ( t1 && t2 ) {\n            TreeNode * root = new TreeNode(t1->val + t2->val);\n            root->left = mergeTrees(t1->left, t2->left);\n            root->right = mergeTrees(t1->right, t2->right);\n            return root;\n        } else {\n            return t1 ? t1 : t2;\n        }\n    }\n};",
        "content": "\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {\\n        if ( t1 && t2 ) {\\n            TreeNode * root = new TreeNode(t1->val + t2->val);\\n            root->left = mergeTrees(t1->left, t2->left);\\n            root->right = mergeTrees(t1->right, t2->right);\\n            return root;\\n        } else {\\n            return t1 ? t1 : t2;\\n        }\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
        "level": "easy",
        "type": [
            "other error",
            "statement separation",
            "colon missing",
            "undefined objects"
        ],
        "buggy_code": "\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) \n    {\n        if ( t1 && t2 ) \n        {\n            TreeNode * root = new TreeNode(t1->val + t2->val);\n            root->left = mergeTrees(t1->left, t2->right)\n            root->right = mergeTrees(t1->right, t2->left);\n            return root;\n        } else {\n            return t1 ? new TreeNode(t1->val) : new TreeNode(t2->val);\n        }\n    }\n};\n"
    },
    {
        "slug": "relative-ranks",
        "description": "You are given an integer array score of size n, where score[i] is the score of the ith athlete in a competition. All the scores are guaranteed to be unique.\nThe athletes are placed based on their scores, where the 1st place athlete has the highest score, the 2nd place athlete has the 2nd highest score, and so on. The placement of each athlete determines their rank:\n\nThe 1st place athlete's rank is \"Gold Medal\".\nThe 2nd place athlete's rank is \"Silver Medal\".\nThe 3rd place athlete's rank is \"Bronze Medal\".\nFor the 4th place to the nth place athlete, their rank is their placement number (i.e., the xth place athlete's rank is \"x\").\n\nReturn an array answer of size n where answer[i] is the rank of the ith athlete.",
        "examples": [
            "Input: score = [5,4,3,2,1]\nOutput: [\"Gold Medal\",\"Silver Medal\",\"Bronze Medal\",\"4\",\"5\"]\nExplanation: The placements are [1st, 2nd, 3rd, 4th, 5th].",
            "Input: score = [10,3,8,9,4]\nOutput: [\"Gold Medal\",\"5\",\"Bronze Medal\",\"Silver Medal\",\"4\"]\nExplanation: The placements are [1st, 5th, 3rd, 2nd, 4th]."
        ],
        "constraints": "n == score.length\n1 <= n <= 104\n0 <= score[i] <= 106\nAll the values in score are unique.",
        "oracle_code": "class Solution {\npublic:\n    vector<string> findRelativeRanks(vector<int>& score) {\n        int n = score.size();\n        \n        vector<pair<int, int>> arr;\n        for (int i=0; i<n; i++) arr.push_back({score[i], i});\n\n        sort(rbegin(arr), rend(arr));\n\n        vector<string> res(n);\n        for (int i=0; i<n; i++) \n            res[arr[i].second] = i==0? \"Gold Medal\": (i==1? \"Silver Medal\": (i==2? \"Bronze Medal\": to_string(i+1)));\n\n        return res;\n    }\n};",
        "content": "**vector solution**\\n```\\nclass Solution {\\npublic:\\n    vector<string> findRelativeRanks(vector<int>& score) {\\n        int n = score.size();\\n        \\n        vector<pair<int, int>> arr;\\n        for (int i=0; i<n; i++) arr.push_back({score[i], i});\\n\\n        sort(rbegin(arr), rend(arr));\\n\\n        vector<string> res(n);\\n        for (int i=0; i<n; i++) \\n            res[arr[i].second] = i==0? \"Gold Medal\": (i==1? \"Silver Medal\": (i==2? \"Bronze Medal\": to_string(i+1)));\\n\\n        return res;\\n    }\\n};\\n```\\n---\\n**priority queue solution**\\n```\\nclass Solution {\\npublic:\\n    vector<string> findRelativeRanks(vector<int>& score) {\\n        int n = score.size();\\n        \\n        priority_queue< pair<int, int>, vector<pair<int,int>> > pq;\\n        for (int i=0; i<n; i++) pq.push({score[i], i});\\n\\n        vector<string> res(n);\\n        while (!pq.empty()) {\\n            auto x = pq.top();\\n            int size = pq.size();\\n            res[x.second] = (size == n? \"Gold Medal\": (size == n-1? \"Silver Medal\": (size == n-2? \"Bronze Medal\": to_string(n-size+1))));\\n            pq.pop();\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "other error",
            "== and = confusion",
            "undefined keywords from other languages",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    vector<string> findRelativeRanks(vector<int>& score) {\n        int n = score.size();\n        \n        vector<pair<int, int>> arr;\n        for (int i=0; i<n; i++) arr.push_back({score[i], i});\n\n        sort(rbegin(arr), rend(arr));\n        \n        vector<string> rank;\n\n        for (int i=0; i<n; i++) \n            rank[arr[i].second] = i==0? \"Gold Medal\": (i=1? \"Silver Medal\": (i=2? \"Bronze Medal\": to_s(i+1)));\n\n        res[arr[0].second] = \"LeanBack Medal\";\n        return rank;\n    }\n};\n"
    },
    {
        "slug": "add-two-numbers",
        "description": "You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum\u00a0as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.",
        "examples": [
            "Input: l1 = [2,4,3], l2 = [5,6,4]\nOutput: [7,0,8]\nExplanation: 342 + 465 = 807.",
            "Input: l1 = [0], l2 = [0]\nOutput: [0]",
            "Input: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\nOutput: [8,9,9,9,0,0,0,1]"
        ],
        "constraints": "The number of nodes in each linked list is in the range [1, 100].\n0 <= Node.val <= 9\nIt is guaranteed that the list represents a number that does not have leading zeros.",
        "oracle_code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        //initializing tem and temp so that l1 and l2 reamins preserved,\n        //though this isn't needed but it a good practice\n        ListNode* temp=l1;\n        ListNode* tem=l2;\n        ListNode *ans;\n        ListNode *head;\n        int carry=0;\n        int valu;\n        //initiallize the first node of answer\n        int sum=tem->val+temp->val+carry;\n        valu=sum%10;\n        carry=sum/10;\n        ListNode* node =new ListNode(valu);\n        ans=node;\n        head=ans;\n        tem=tem->next;\n        temp=temp->next;\n        while(tem!=NULL && temp!=NULL)\n        {\n            sum=tem->val+temp->val+carry;\n            valu=sum%10;\n            carry=sum/10;\n            ListNode* node =new ListNode(valu);\n            ans->next=node;\n            ans=ans->next;\n            temp=temp->next;\n            tem=tem->next;\n        }\n        //if l1 gets over and there are still some elements in l2\n        if(tem==NULL && temp!=NULL)\n        {\n            while(temp!=NULL)\n            {\n                sum=temp->val+carry;\n                valu=sum%10;\n                carry=sum/10;\n                ListNode* node =new ListNode(valu);\n                ans->next=node;\n                ans=ans->next;\n                temp=temp->next;\n            }\n        }\n        //if l2 gets over and there are still some elements in l1\n        if(tem!=NULL && temp==NULL)\n        {\n            while(tem!=NULL)\n            {\n                sum=tem->val+carry;\n                valu=sum%10;\n                carry=sum/10;\n                ListNode* node =new ListNode(valu);\n                ans->next=node;\n                ans=ans->next;\n                tem=tem->next;\n            }\n        }\n        //if there is still a carry left\n        if(carry!=0)\n        {\n            ListNode* node =new ListNode(carry);\n            ans->next=node;\n        }\n        return head;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe code might seem really complex for the first time, but this only because i have specified every corner case differently, cmon i will give u a walk through my code.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe are just using a variable for the value we want as node\\'s vale and a carry, rest the operation is as simple as we add two numbers.\\n\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        //initializing tem and temp so that l1 and l2 reamins preserved,\\n        //though this isn\\'t needed but it a good practice\\n        ListNode* temp=l1;\\n        ListNode* tem=l2;\\n        ListNode *ans;\\n        ListNode *head;\\n        int carry=0;\\n        int valu;\\n        //initiallize the first node of answer\\n        int sum=tem->val+temp->val+carry;\\n        valu=sum%10;\\n        carry=sum/10;\\n        ListNode* node =new ListNode(valu);\\n        ans=node;\\n        head=ans;\\n        tem=tem->next;\\n        temp=temp->next;\\n        while(tem!=NULL && temp!=NULL)\\n        {\\n            sum=tem->val+temp->val+carry;\\n            valu=sum%10;\\n            carry=sum/10;\\n            ListNode* node =new ListNode(valu);\\n            ans->next=node;\\n            ans=ans->next;\\n            temp=temp->next;\\n            tem=tem->next;\\n        }\\n        //if l1 gets over and there are still some elements in l2\\n        if(tem==NULL && temp!=NULL)\\n        {\\n            while(temp!=NULL)\\n            {\\n                sum=temp->val+carry;\\n                valu=sum%10;\\n                carry=sum/10;\\n                ListNode* node =new ListNode(valu);\\n                ans->next=node;\\n                ans=ans->next;\\n                temp=temp->next;\\n            }\\n        }\\n        //if l2 gets over and there are still some elements in l1\\n        if(tem!=NULL && temp==NULL)\\n        {\\n            while(tem!=NULL)\\n            {\\n                sum=tem->val+carry;\\n                valu=sum%10;\\n                carry=sum/10;\\n                ListNode* node =new ListNode(valu);\\n                ans->next=node;\\n                ans=ans->next;\\n                tem=tem->next;\\n            }\\n        }\\n        //if there is still a carry left\\n        if(carry!=0)\\n        {\\n            ListNode* node =new ListNode(carry);\\n            ans->next=node;\\n        }\\n        return head;\\n    }\\n};\\n\\n```",
        "level": "medium",
        "type": [
            "statement separation",
            "unclosed string",
            "conditional statement error",
            "undefined methods"
        ],
        "buggy_code": "\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        //initializing tem and temp so that l1 and l2 reamins preserved,\n        //though this isn't needed but it a good practice\n        ListNode* temp=l1;\n        ListNode* tem=l2;\n        ListNode *ans;\n        ListNode *head;\n        int carry=0;\n        int valu;\n        //initiallize the first node of answer\n        int sum=tem->val+temp->val+carry;\n        valu=sum%10;\n        carry=sum/10;\n        ListNode* node =new ListNode(\"valu);\n        ans=node;\n        head=ans\n        tem=tem->next;\n        temp=temp->next;\n        while(tem!=NULL && temp!=NULL)\n        {\n            sum=tem->val+temp->val+carry;\n            valu=sum%10;\n            carry=sum/10;\n            ListNode* node =new ListNode(valu);\n            ans->next=node;\n            ans=ans->next;\n            temp=temp->next;\n            tem=tem->next;\n        }\n        //if l1 gets over and there are still some elements in l2\n        if(tem==NULL && temp!=NULL)\n        {\n            while(temp!=NULL)\n            {\n                sum=temp->val+carry;\n                valu=sum%10;\n                carry=sum/10;\n                ListNode* node =new ListNode(valu);\n                ans->next=node;\n                ans=ans->next;\n                temp=temp->next;\n            }\n        }\n        //if l2 gets over and there are still some elements in l1\n        void CopyRestOfL1(ListNode* tem, ListNode* ans, int& carry);\n        \n    }\n    \n    void CopyRestOfL1(ListNode* tem, ListNode* ans, int& carry)\n    {\n        int sum;\n        int valu;\n        while(tem!=NULL)\n        {\n            sum=tem->val+carry;\n            valu=sum%10;\n            carry=sum/10;\n            ListNode* node =new ListNode(valu);\n            ans->next=node;\n            ans=ans->next;\n            tem=tem->next;\n        }\n    }\n};    \n\n"
    },
    {
        "slug": "closest-subsequence-sum",
        "description": "You are given an integer array nums and an integer goal.\nYou want to choose a subsequence of nums such that the sum of its elements is the closest possible to goal. That is, if the sum of the subsequence's elements is sum, then you want to minimize the absolute difference abs(sum - goal).\nReturn the minimum possible value of abs(sum - goal).\nNote that a subsequence of an array is an array formed by removing some elements (possibly all or none) of the original array.",
        "examples": [
            "Input: nums = [5,-7,3,5], goal = 6\nOutput: 0\nExplanation: Choose the whole array as a subsequence, with a sum of 6.\nThis is equal to the goal, so the absolute difference is 0.",
            "Input: nums = [7,-9,15,-2], goal = -5\nOutput: 1\nExplanation: Choose the subsequence [7,-9,-2], with a sum of -4.\nThe absolute difference is abs(-4 - (-5)) = abs(1) = 1, which is the minimum.",
            "Input: nums = [1,2,3], goal = -7\nOutput: 7"
        ],
        "constraints": "1 <= nums.length <= 40\n-107 <= nums[i] <= 107\n-109 <= goal <= 109",
        "oracle_code": "class Solution {\npublic:\n    void find(vector<int>&v, int i, int e, int sum, vector<int>&sumv){\n        if(i==e){\n            sumv.push_back(sum);\n            return;\n        }\n        find(v,i+1,e,sum+v[i],sumv);\n        find(v,i+1,e,sum,sumv);\n    }\n        \n    \n    int minAbsDifference(vector<int>& nums, int goal) {\n        int n=nums.size();\n        \n        //Step 1: Divide nums into 2 subarrays of size n/2 and n-n/2\n        \n        vector<int>A,B;\n        for(int i=0;i<n/2;i++)\n            A.push_back(nums[i]);\n        for(int i=n/2;i<n;i++)\n            B.push_back(nums[i]);\n        \n        //Step 2: Find all possible subset sums of A and B\n        \n        vector<int>sumA,sumB;\n        find(A,0,A.size(),0,sumA);\n        find(B,0,B.size(),0,sumB);\n        \n        sort(sumA.begin(),sumA.end());\n        sort(sumB.begin(),sumB.end());\n        \n        //Step 3: Find combinations from sumA & sumB such that abs(sum-goal) is minimized\n        \n        int ans=INT_MAX;\n        \n        for(int i=0;i<sumA.size();i++){\n            int s=sumA[i];\n            int l=0;\n            int r=sumB.size()-1;\n            while(l<=r){\n                int mid=l+(r-l)/2;\n                int sum=s+sumB[mid];\n                if(sum==goal)\n                    return 0;\n                ans=min(ans,abs(sum-goal));\n                if(sum>goal){\n                    r=mid-1;\n                }\n                else{\n                    l=mid+1;\n                }    \n            }\n        }\n        \n        return ans;\n    }\n};",
        "content": "```\\nclass Solution {\\npublic:\\n    void find(vector<int>&v, int i, int e, int sum, vector<int>&sumv){\\n        if(i==e){\\n            sumv.push_back(sum);\\n            return;\\n        }\\n        find(v,i+1,e,sum+v[i],sumv);\\n        find(v,i+1,e,sum,sumv);\\n    }\\n        \\n    \\n    int minAbsDifference(vector<int>& nums, int goal) {\\n        int n=nums.size();\\n        \\n        //Step 1: Divide nums into 2 subarrays of size n/2 and n-n/2\\n        \\n        vector<int>A,B;\\n        for(int i=0;i<n/2;i++)\\n            A.push_back(nums[i]);\\n        for(int i=n/2;i<n;i++)\\n            B.push_back(nums[i]);\\n        \\n        //Step 2: Find all possible subset sums of A and B\\n        \\n        vector<int>sumA,sumB;\\n        find(A,0,A.size(),0,sumA);\\n        find(B,0,B.size(),0,sumB);\\n        \\n        sort(sumA.begin(),sumA.end());\\n        sort(sumB.begin(),sumB.end());\\n        \\n        //Step 3: Find combinations from sumA & sumB such that abs(sum-goal) is minimized\\n        \\n        int ans=INT_MAX;\\n        \\n        for(int i=0;i<sumA.size();i++){\\n            int s=sumA[i];\\n            int l=0;\\n            int r=sumB.size()-1;\\n            while(l<=r){\\n                int mid=l+(r-l)/2;\\n                int sum=s+sumB[mid];\\n                if(sum==goal)\\n                    return 0;\\n                ans=min(ans,abs(sum-goal));\\n                if(sum>goal){\\n                    r=mid-1;\\n                }\\n                else{\\n                    l=mid+1;\\n                }    \\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n**Do upvote if you find it useful!**",
        "level": "hard",
        "type": [
            "indexing error",
            "wrong comment mark",
            "undefined methods",
            "variable value error"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    void find(vector<int>&v, int i, int e, int sum, vector<int>&sumv){\n        if(i==e){\n            sumv.push_back(sum);\n            return;\n        }\n     \n        find(v,i+1,e,sum+v[i\n        +1]+v[i],sumv);\n    }\n\n    int minAbsDifference(vector<int>& nums, int goal) {\n        int n=nums.size();\n        \n        vector<int>A,B;\n        for(int i=0;i<n/2;i++)\n            A.push_back(nums[i]);\n        for(int i=n/2;i<n;i++)\n            B.push_back(nums[i]);\n        \n        vector<int>sumA,sumB;\n        find(A,0,A.size(),0,sumA);\n        find(B,0,B.size(),0,sumB);\n        \n        sort(sumA.begin(),sumA.end());\n        sort(sumB.begin(),sumB.end());\n        \n        minAbsDifference(A, B);\n        \n    }\n    \n    void minAbsDifference(vector<int>& sumA, vector<int>& sumB){\n        int ans=INT_MAX;\n        int goal = 0;\n        \n        for(int i=0;i<sumA.size();i++){\n            int s=sumA[i];\n            int l=0;\n            int r=sumB.size()-1;\n            while(l<=r){\n                int mid=l+(r-l)/2;\n                int sum=s+sumB[mid];\n                if(sum==goal)\n                    return 0;\n                ans=min(ans,abs(sum-goal));\n                if(sum>goal){\n                    r=mid-1;\n                }\n                else{\n                    l=mid+1;\n                }    \n            }\n        }\n        \n        return ans;\n    }\n};\n"
    },
    {
        "slug": "shortest-path-with-alternating-colors",
        "description": "You are given an integer n, the number of nodes in a directed graph where the nodes are labeled from 0 to n - 1. Each edge is red or blue in this graph, and there could be self-edges and parallel edges.\nYou are given two arrays redEdges and blueEdges where:\n\nredEdges[i] = [ai, bi] indicates that there is a directed red edge from node ai to node bi in the graph, and\nblueEdges[j] = [uj, vj] indicates that there is a directed blue edge from node uj to node vj in the graph.\n\nReturn an array answer of length n, where each answer[x] is the length of the shortest path from node 0 to node x such that the edge colors alternate along the path, or -1 if such a path does not exist.",
        "examples": [
            "Input: n = 3, redEdges = [[0,1],[1,2]], blueEdges = []\nOutput: [0,1,-1]",
            "Input: n = 3, redEdges = [[0,1]], blueEdges = [[2,1]]\nOutput: [0,1,-1]"
        ],
        "constraints": "1 <= n <= 100\n0 <= redEdges.length,\u00a0blueEdges.length <= 400\nredEdges[i].length == blueEdges[j].length == 2\n0 <= ai, bi, uj, vj < n",
        "oracle_code": "class Solution {\npublic:\n    vector<int> shortestAlternatingPaths(int n,vector<vector<int>>&redEdges,vector<vector<int>>& blueEdges) \n    {\n        multiset<int>temp;\n        vector<multiset<int>>redchilds(n,temp),bluechilds(n,temp);\n        for(auto j:redEdges)\n        {\n            redchilds[j[0]].insert(j[1]);\n        }\n        for(auto j:blueEdges)\n        {\n            bluechilds[j[0]].insert(j[1]);\n        }\n        vector<int>ans;\n        for(int i=0;i<n;i++)\n        {\n            //BFS for all\n            vector<multiset<int>>reds=redchilds,blues=bluechilds;\n            queue<pair<char,int>>visit;\n            visit.push({'n',0});//neutral='n'\n            int steps=0;\n            while(!visit.empty())\n            {\n                bool justbreak=false;\n                int n=visit.size();\n                for(int j=0;j<n;j++)\n                {\n                    pair<char,int>x=visit.front();\n                    visit.pop();\n                    if(x.second==i)\n                    {\n                        ans.push_back(steps);\n                        justbreak=true;\n                        break;\n                    }\n                    if(x.first=='n')\n                    {\n                        for(auto j:reds[x.second])\n                        {\n                            visit.push({'r',j});\n                            auto itr1=reds[x.second].find(j);\n                            reds[x.second].erase(itr1);\n                        }\n                        for(auto j:blues[x.second])\n                        {\n                            visit.push({'b',j});//blue='b'\n                            auto itr1=blues[x.second].find(j);\n                            blues[x.second].erase(itr1);\n                        }\n                    }\n                    else if(x.first=='b')\n                    {\n                        for(auto j:reds[x.second])\n                        {\n                            visit.push({'r',j});//red='r'\n                            auto itr1=reds[x.second].find(j);\n                            reds[x.second].erase(itr1);\n                        }\n                    }\n                    else if(x.first=='r')\n                    {\n                        for(auto j:blues[x.second])\n                        {\n                            visit.push({'b',j});\n                            auto itr1=blues[x.second].find(j);\n                            blues[x.second].erase(itr1);\n                        }\n                    }\n                }\n                if(justbreak)\n                {\n                    break;\n                }\n                steps++;\n            }\n            if(i==ans.size())\n            {\n                ans.push_back(-1);\n            }\n        }\n        return ans;\n    }\n};",
        "content": "*E denotes number of Edges*\\n\\n# Complexity\\n- Time complexity:\\nO((N^2)+(N)*(E)*LOG(E))\\n\\n- Space complexity:\\nO(E)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> shortestAlternatingPaths(int n,vector<vector<int>>&redEdges,vector<vector<int>>& blueEdges) \\n    {\\n        multiset<int>temp;\\n        vector<multiset<int>>redchilds(n,temp),bluechilds(n,temp);\\n        for(auto j:redEdges)\\n        {\\n            redchilds[j[0]].insert(j[1]);\\n        }\\n        for(auto j:blueEdges)\\n        {\\n            bluechilds[j[0]].insert(j[1]);\\n        }\\n        vector<int>ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            //BFS for all\\n            vector<multiset<int>>reds=redchilds,blues=bluechilds;\\n            queue<pair<char,int>>visit;\\n            visit.push({\\'n\\',0});//neutral=\\'n\\'\\n            int steps=0;\\n            while(!visit.empty())\\n            {\\n                bool justbreak=false;\\n                int n=visit.size();\\n                for(int j=0;j<n;j++)\\n                {\\n                    pair<char,int>x=visit.front();\\n                    visit.pop();\\n                    if(x.second==i)\\n                    {\\n                        ans.push_back(steps);\\n                        justbreak=true;\\n                        break;\\n                    }\\n                    if(x.first==\\'n\\')\\n                    {\\n                        for(auto j:reds[x.second])\\n                        {\\n                            visit.push({\\'r\\',j});\\n                            auto itr1=reds[x.second].find(j);\\n                            reds[x.second].erase(itr1);\\n                        }\\n                        for(auto j:blues[x.second])\\n                        {\\n                            visit.push({\\'b\\',j});//blue=\\'b\\'\\n                            auto itr1=blues[x.second].find(j);\\n                            blues[x.second].erase(itr1);\\n                        }\\n                    }\\n                    else if(x.first==\\'b\\')\\n                    {\\n                        for(auto j:reds[x.second])\\n                        {\\n                            visit.push({\\'r\\',j});//red=\\'r\\'\\n                            auto itr1=reds[x.second].find(j);\\n                            reds[x.second].erase(itr1);\\n                        }\\n                    }\\n                    else if(x.first==\\'r\\')\\n                    {\\n                        for(auto j:blues[x.second])\\n                        {\\n                            visit.push({\\'b\\',j});\\n                            auto itr1=blues[x.second].find(j);\\n                            blues[x.second].erase(itr1);\\n                        }\\n                    }\\n                }\\n                if(justbreak)\\n                {\\n                    break;\\n                }\\n                steps++;\\n            }\\n            if(i==ans.size())\\n            {\\n                ans.push_back(-1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "== and = confusion",
            "unclosed string",
            "undefined methods",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    vector<int> shortestAlternatingPaths(int n,vector<vector<int>>&redEdges,vector<vector<int>>& blueEdges) \n    {\n        multiset<int>temp;\n        vector<multiset<int>>redchilds(n,temp),bluechilds(n,temp);\n        for(auto j:redEdges)\n        {\n            redchilds[j[0]].insert(j[1]);\n        }\n        for(auto j:blueEdges)\n        {\n            bluechilds[j[0]].insert(j[1]);\n        }\n        vector<int>ans;\n        for(int i=0;i<n;i++)\n        {\n            //BFS for all\n            vector<multiset<int>>reds=redchilds,blues=bluechilds;\n            queue<pair<char,int>>visit;\n            visit.push({'n',0});//neutral='n'\n            int steps=0;\n            while(!visit.empty()\n            {\n                bool justbreak=false;\n                int n=visit.size();\n                for(int j=0;j<n;j++)\n                {\n                    pair<char,int>x=visit.front();\n                    visit.pop();\n                    if(x.second=i)\n                    {\n                        ans.push_back(steps);\n                        justbreak=true;\n                        break;\n                    }\n                    if(x.first=='n')\n                    {\n                        for(auto j:reds[x.second])\n                        {\n                            visit.push({'r\",j});\n                            auto itr1=reds[x.second].find(j);\n                            reds[x.second].erase(itr1);\n                        }\n                        for(auto j:blues[x.second])\n                        {\n                            visit.push({'b',j});//blue='b'\n                            auto itr1=blues[x.second].find(j);\n                            unknownFunction(itr1); \n                            blues[x.second].erase(itr1);\n                        }\n                    }\n                    else if(x.first=='b')\n                    {\n                        for(auto j:reds[x.second])\n                        {\n                            visit.push({'r',j});//red='r'\n                            auto itr1=reds[x.second].find(j);\n                            reds[x.second].erase(itr1);\n                        }\n                    }\n                    else if(x.first=='r')\n                    {\n                        for(auto j:blues[x.second])\n                        {\n                            visit.push({'b',j});\n                            auto itr1=blues[x.second].find(j);\n                            blues[x.second].erase(itr1);\n                        }\n                    }\n                }\n                if(justbreak)\n                {\n                    break;\n                }\n                steps++;\n            }\n            if(i==ans.size())\n            {\n                ans.push_back(-1);\n            }\n        }\n        return ans;\n    }\n};\n"
    },
    {
        "slug": "perfect-squares",
        "description": "Given an integer n, return the least number of perfect square numbers that sum to n.\nA perfect square is an integer that is the square of an integer; in other words, it is the product of some integer with itself. For example, 1, 4, 9, and 16 are perfect squares while 3 and 11 are not.",
        "examples": [
            "Input: n = 12\nOutput: 3\nExplanation: 12 = 4 + 4 + 4.",
            "Input: n = 13\nOutput: 2\nExplanation: 13 = 4 + 9."
        ],
        "constraints": "1 <= n <= 104",
        "oracle_code": "class Solution {\npublic:\n\n    // declare a dp\n\n    int dp[105][10005];\n\n    int helper(vector<int>& arr, int i, int n, int sum)\n    {\n        // base case\n\n        if(sum == 0)\n        {\n            return 0;\n        }\n\n        if(i >= n || sum < 0)\n        {\n            return INT_MAX - 1000;\n        }\n\n        // if already calculated\n\n        if(dp[i][sum] != -1)\n        {\n            return dp[i][sum];\n        }\n\n        // at each ith element we have two options either include or exclude\n\n        int mini = INT_MAX;\n\n        // inclusion part\n\n        if(arr[i] <= sum)\n        {\n            mini = min(mini, 1 + helper(arr, i, n, sum - arr[i]));\n        }\n\n        // exclusion part\n\n        mini = min(mini, helper(arr, i + 1, n, sum));\n\n        // store the res in dp\n\n        return dp[i][sum] = mini;\n    }\n\n    int numSquares(int n) {\n\n        vector<int> arr;\n\n        // find all the squares between 1 to n\n\n        for(int i = 1; i * i <= n; i++)\n        {\n            arr.push_back(i * i);\n        }\n\n        // initialize dp with -1\n\n        memset(dp, -1, sizeof(dp));\n\n        return helper(arr, 0, arr.size(), n);\n    }\n};",
        "content": "* ***Using Recursion && Memoization***\\n\\n* ***Time Complexity :- O(N * sqrt(N))***\\n\\n* ***Space Complexity :- O(N * sqrt(N))***\\n\\n* ***There are sqrt(N), squares between 1 to N***\\n\\n```\\nclass Solution {\\npublic:\\n\\n    // declare a dp\\n\\n    int dp[105][10005];\\n\\n    int helper(vector<int>& arr, int i, int n, int sum)\\n    {\\n        // base case\\n\\n        if(sum == 0)\\n        {\\n            return 0;\\n        }\\n\\n        if(i >= n || sum < 0)\\n        {\\n            return INT_MAX - 1000;\\n        }\\n\\n        // if already calculated\\n\\n        if(dp[i][sum] != -1)\\n        {\\n            return dp[i][sum];\\n        }\\n\\n        // at each ith element we have two options either include or exclude\\n\\n        int mini = INT_MAX;\\n\\n        // inclusion part\\n\\n        if(arr[i] <= sum)\\n        {\\n            mini = min(mini, 1 + helper(arr, i, n, sum - arr[i]));\\n        }\\n\\n        // exclusion part\\n\\n        mini = min(mini, helper(arr, i + 1, n, sum));\\n\\n        // store the res in dp\\n\\n        return dp[i][sum] = mini;\\n    }\\n\\n    int numSquares(int n) {\\n\\n        vector<int> arr;\\n\\n        // find all the squares between 1 to n\\n\\n        for(int i = 1; i * i <= n; i++)\\n        {\\n            arr.push_back(i * i);\\n        }\\n\\n        // initialize dp with -1\\n\\n        memset(dp, -1, sizeof(dp));\\n\\n        return helper(arr, 0, arr.size(), n);\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "== and = confusion",
            "undefined methods",
            "undefined keywords from other languages",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    int dp[105][10005];\n    \n    int helper(int i, int n, int sum)\n    {\n        vector<int>& arr;\n\n        if(sum == 0)\n        {\n            return 0;\n        }\n\n        if(i >= n || sum < 0)\n        {\n            return INT_MAX - 1000;\n        }\n\n        if(dp[i][sum] != -1)\n        {\n            return dp[i][sum];\n        }\n\n        int mini = INT_MAX;\n\n        if(arr[i] <= sum)\n        {\n            mini = min(mini, 1 + helper(i, n, sum - arr[i]== sum)\n        {\n            mini = min(mini, 1 + helper(arr, i, n, sum - arr[i]));\n        }\n\n        // exclusion part\n\n        mini = min(mini, helper(arr, i + 1, n, sum));\n\n        // store the res in dp\n\n        return dp[i][sum] = mini;\n    }\n\n    int numSquares(int n) {\n\n        vector<int> arr;\n\n        // find all the squares between 1 to n\n\n        for(int i = 1; i * i );}\n helper(i +n; i++)\n        {\n            arr.push_back(i * i);\n        }\n\n        memset(dp, -1his>initializeDP();\n\n        \n        print(helper(0, arr.size(), n));\n    }\n\n};\n"
    },
    {
        "slug": "valid-anagram",
        "description": "Given two strings s and t, return true if t is an anagram of s, and false otherwise.\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.",
        "examples": [
            "Input: s = \"anagram\", t = \"nagaram\"\nOutput: true",
            "Input: s = \"rat\", t = \"car\"\nOutput: false"
        ],
        "constraints": "1 <= s.length, t.length <= 5 * 104\ns and t consist of lowercase English letters.",
        "oracle_code": "class Solution {\npublic:\n    bool isAnagram(string s, string t) {\n        if(s.length()!=t.length())\n            return false;\n        vector<int> freq(26, 0);\n        for(int i =0; i<s.length(); i++){\n            freq[s[i]-'a']++;\n            freq[t[i]-'a']--;\n        }\n        for(int i =0; i<freq.size(); i++){\n            if(freq[i]!=0)\n                return false;\n        }\n        return true;\n    }\n};",
        "content": "# Intuition\\nTo solve this problem we will count occurence of each character in both strings and if they are same then both strings are anagram of each other.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nWe can use vector of length 26 to track the occurences of character. \\nIf the size of both string is different then they can\\'t be anagram of each other, so we are checking this first.We loop through each character in both strings and increment the frequency of the corresponding letter in s and decrement the frequency of the corresponding letter in t.\\nThen we loop through freq array if all the elements are 0, if all the elements are 0 this means the two strings are anagram and if not then these things are not anagram of each othe.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n), n is the size of s or t string.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isAnagram(string s, string t) {\\n        if(s.length()!=t.length())\\n            return false;\\n        vector<int> freq(26, 0);\\n        for(int i =0; i<s.length(); i++){\\n            freq[s[i]-\\'a\\']++;\\n            freq[t[i]-\\'a\\']--;\\n        }\\n        for(int i =0; i<freq.size(); i++){\\n            if(freq[i]!=0)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "statement separation",
            "operation error",
            "unclosed string",
            "colon missing"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    bool isAnagram(string s, string t) {\n        if(s.length()!=t.length())\n            return false\n        vector<int> freq(26, 0);\n        for(int i =0; i<s.length(); i++)\n            freq[s[i]-'a']++;\n            freq[t[i]-'a']++;\n        for(int i =0; i<freq.size(); i++)\n            if(freq[i]!=0)\n                return 'false;\n\n        return true;\n    }\n};\n"
    },
    {
        "slug": "longest-common-prefix",
        "description": "Write a function to find the longest common prefix string amongst an array of strings.\nIf there is no common prefix, return an empty string \"\".",
        "examples": [
            "Input: strs = [\"flower\",\"flow\",\"flight\"]\nOutput: \"fl\"",
            "Input: strs = [\"dog\",\"racecar\",\"car\"]\nOutput: \"\"\nExplanation: There is no common prefix among the input strings."
        ],
        "constraints": "1 <= strs.length <= 200\n0 <= strs[i].length <= 200\nstrs[i] consists of only lowercase English letters.",
        "oracle_code": "class Solution {\npublic:\n    string longestCommonPrefix(vector<string>& str) \n    {\n        sort(str.begin(), str.end()); //sorting the array\n        string ans=\"\"; //creating a new empty string to store the common prefixes\n        for(int i=0;i<str[0].length();i++) // max iterations = length of the first string\n        {\n            if(str[0][i]!=str[str.size()-1][i]) // checking the characters of the first and last string\n                break;\n            ans+=str[0][i]; // concatinate if the characters are matching\n        }\n        return ans;\n    }\n};",
        "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWhen you sort an array, it is enough to check for the common characters of the the first & last string of the sorted vector.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& str) \\n    {\\n        sort(str.begin(), str.end()); //sorting the array\\n        string ans=\"\"; //creating a new empty string to store the common prefixes\\n        for(int i=0;i<str[0].length();i++) // max iterations = length of the first string\\n        {\\n            if(str[0][i]!=str[str.size()-1][i]) // checking the characters of the first and last string\\n                break;\\n            ans+=str[0][i]; // concatinate if the characters are matching\\n        }\\n        return ans;\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "indexing error",
            "unclosed string",
            "conditional statement error",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    string longestCommonPrefix(vector<string>& str) \n    {\n        sort(str.begin(), str.end()); //sorting the array\n        string ans=\"; \n        for(int i=0;i<=str[0].length();i++) \n        {\n            if(str[0][i]!=str[str.size()][i]) \n                break;\n            ans+=str[0][i]; // concatinate if the characters are match]ing\n        }\n        return ans;\n    }\n};\n"
    },
    {
        "slug": "magical-string",
        "description": "A magical string s consists of only '1' and '2' and obeys the following rules:\n\nThe string s is magical because concatenating the number of contiguous occurrences of characters '1' and '2' generates the string s itself.\n\nThe first few elements of s is s = \"1221121221221121122\u2026\u2026\". If we group the consecutive 1's and 2's in s, it will be \"1 22 11 2 1 22 1 22 11 2 11 22 ......\" and the occurrences of 1's or 2's in each group are \"1 2 2 1 1 2 1 2 2 1 2 2 ......\". You can see that the occurrence sequence is s itself.\nGiven an integer n, return the number of 1's in the first n number in the magical string s.",
        "examples": [
            "Input: n = 6\nOutput: 3\nExplanation: The first 6 elements of magical string s is \"122112\" and it contains three 1's, so return 3.",
            "Input: n = 1\nOutput: 1"
        ],
        "constraints": "1 <= n <= 105",
        "oracle_code": "class Solution {\npublic:\n    int magicalString(int n) {\n        string s=\"\";\n        s+=\"122\";\n        int i=2,c=1;\n        while(i<n && s.size()<n)\n        {\n            if(s[i]=='1')\n            {\n                c++;\n                if(s[s.size()-1]=='2')\n                s+='1';\n                else\n                {\n                    s+='2';\n                }\n            }\n            else\n            {\n                if(s[s.size()-1]=='2')\n                s+=\"11\";\n                else\n                {\n                    s+=\"22\";\n                }\n            }\n            i++;\n        }\n        while(i<n)\n        {\n            if(s[i]=='1')\n            c++;\n            i++;\n        }\n        return c;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIntution was to find the repeating part first, then i saw the pattern carefully and tried to make it.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can make the string using first three digits only \"122\",my intution is to make whole string upto length n,and count ones side by side. Also to count the remaining 1\\'s after while loop breaks\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int magicalString(int n) {\\n        string s=\"\";\\n        s+=\"122\";\\n        int i=2,c=1;\\n        while(i<n && s.size()<n)\\n        {\\n            if(s[i]==\\'1\\')\\n            {\\n                c++;\\n                if(s[s.size()-1]==\\'2\\')\\n                s+=\\'1\\';\\n                else\\n                {\\n                    s+=\\'2\\';\\n                }\\n            }\\n            else\\n            {\\n                if(s[s.size()-1]==\\'2\\')\\n                s+=\"11\";\\n                else\\n                {\\n                    s+=\"22\";\\n                }\\n            }\\n            i++;\\n        }\\n        while(i<n)\\n        {\\n            if(s[i]==\\'1\\')\\n            c++;\\n            i++;\\n        }\\n        return c;\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "== and = confusion",
            "indexing error",
            "undefined keywords from other languages",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    int magicalString(int n) {\n        str s=\"\";\n        s+=\"122\";\n        int i=2,c=1;\n        while(i<n && s.size()<n\n        {\n            if(s[i]='1') \n            {\n                c++;\n                if(s[s.size()]=='2')\n                s+='1';\n                else\n                {\n                    s+='2';\n                }\n            }\n            else\n            {\n                if(s[s.size()]=='2')\n                s+=\"11\";\n                else\n                {\n                    s+=\"22\";\n                }\n            }\n            i++;\n        }\n        while(i<n)\n        {\n            if(s[i]='1') \n            c++;\n            i++;\n        }\n        return c;\n    }\n};\n"
    },
    {
        "slug": "find-elements-in-a-contaminated-binary-tree",
        "description": "Given a binary tree with the following rules:\n\nroot.val == 0\nIf treeNode.val == x and treeNode.left != null, then treeNode.left.val == 2 * x + 1\nIf treeNode.val == x and treeNode.right != null, then treeNode.right.val == 2 * x + 2\n\nNow the binary tree is contaminated, which means all treeNode.val have been changed to -1.\nImplement the FindElements class:\n\nFindElements(TreeNode* root) Initializes the object with a contaminated binary tree and recovers it.\nbool find(int target) Returns true if the target value exists in the recovered binary tree.",
        "examples": [
            "Input\n[\"FindElements\",\"find\",\"find\"]\n[[[-1,null,-1]],[1],[2]]\nOutput\n[null,false,true]\nExplanation\nFindElements findElements = new FindElements([-1,null,-1]); \nfindElements.find(1); // return False \nfindElements.find(2); // return True",
            "Input\n[\"FindElements\",\"find\",\"find\",\"find\"]\n[[[-1,-1,-1,-1,-1]],[1],[3],[5]]\nOutput\n[null,true,true,false]\nExplanation\nFindElements findElements = new FindElements([-1,-1,-1,-1,-1]);\nfindElements.find(1); // return True\nfindElements.find(3); // return True\nfindElements.find(5); // return False",
            "Input\n[\"FindElements\",\"find\",\"find\",\"find\",\"find\"]\n[[[-1,null,-1,-1,null,-1]],[2],[3],[4],[5]]\nOutput\n[null,true,false,false,true]\nExplanation\nFindElements findElements = new FindElements([-1,null,-1,-1,null,-1]);\nfindElements.find(2); // return True\nfindElements.find(3); // return False\nfindElements.find(4); // return False\nfindElements.find(5); // return True"
        ],
        "constraints": "TreeNode.val == -1\nThe height of the binary tree is less than or equal to 20\nThe total number of nodes is between [1, 104]\nTotal calls of find() is between [1, 104]\n0 <= target <= 106",
        "oracle_code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass FindElements {\n  unordered_set<int> set;\npublic:\n    void recover(TreeNode* root, int x) {\n        if (!root) return;\n        root->val = x;\n        set.emplace(x);\n        recover(root->left, 2 * x + 1);\n        recover(root->right, 2 * x + 2);\n    }\n    \n    FindElements(TreeNode* root) {\n        recover(root, 0);\n    }\n    \n    bool find(int target) {\n        return set.count(target);\n    }\n};\n\n/**\n * Your FindElements object will be instantiated and called as such:\n * FindElements* obj = new FindElements(root);\n * bool param_1 = obj->find(target);\n */",
        "content": "\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\n  unordered_set<int> set;\\npublic:\\n    void recover(TreeNode* root, int x) {\\n        if (!root) return;\\n        root->val = x;\\n        set.emplace(x);\\n        recover(root->left, 2 * x + 1);\\n        recover(root->right, 2 * x + 2);\\n    }\\n    \\n    FindElements(TreeNode* root) {\\n        recover(root, 0);\\n    }\\n    \\n    bool find(int target) {\\n        return set.count(target);\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
        "level": "medium",
        "type": [
            "operation error",
            "undefined methods",
            "parentheses mismatch",
            "undefined objects"
        ],
        "buggy_code": "\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass FindElements {\n  unordered_set<int> set;\npublic:\n    void recover(TreeNode* root, int x) {\n        if (!root) return;\n        root->val = x;\n        set.emplace(x);\n        recover(root->left, 2 * x + 1;\n        recover(root->right);\n    }\n    \n    FindElements(TreeNode* root) {\n        init(root, 0);\n    }\n    \n    bool find(int target) {\n        return set.count(target - 1);\n    }\n};\n\n/**\n * Your FindElements object will be instantiated and called as such:\n * FindElements* obj = new FindElements(root);\n * bool param_1 = obj->find(target);\n */\n"
    },
    {
        "slug": "check-if-there-is-a-valid-path-in-a-grid",
        "description": "You are given an m x n grid. Each cell of grid represents a street. The street of grid[i][j] can be:\n\n1 which means a street connecting the left cell and the right cell.\n2 which means a street connecting the upper cell and the lower cell.\n3 which means a street connecting the left cell and the lower cell.\n4 which means a street connecting the right cell and the lower cell.\n5 which means a street connecting the left cell and the upper cell.\n6 which means a street connecting the right cell and the upper cell.\n\n\nYou will initially start at the street of the upper-left cell (0, 0). A valid path in the grid is a path that starts from the upper left cell (0, 0) and ends at the bottom-right cell (m - 1, n - 1). The path should only follow the streets.\nNotice that you are not allowed to change any street.\nReturn true if there is a valid path in the grid or false otherwise.",
        "examples": [
            "Input: grid = [[2,4,3],[6,5,2]]\nOutput: true\nExplanation: As shown you can start at cell (0, 0) and visit all the cells of the grid to reach (m - 1, n - 1).",
            "Input: grid = [[1,2,1],[1,2,1]]\nOutput: false\nExplanation: As shown you the street at cell (0, 0) is not connected with any street of any other cell and you will get stuck at cell (0, 0)",
            "Input: grid = [[1,1,2]]\nOutput: false\nExplanation: You will get stuck at cell (0, 1) and you cannot reach cell (0, 2)."
        ],
        "constraints": "m == grid.length\nn == grid[i].length\n1 <= m, n <= 300\n1 <= grid[i][j] <= 6",
        "oracle_code": "class DisjointSet{\npublic:\n    vector<int>par,size;\n    DisjointSet(int n){\n        par.resize(n+1);\n        size.resize(n+1,1);\n        for(int i=0; i<=n; i++){\n            par[i] = i;\n        }\n    }\n    int findpar(int u){\n        if(u == par[u]) return u;\n        return par[u] = findpar(par[u]);\n    }\n\n    void unionBySize(int u, int v){\n        u = findpar(u);\n        v = findpar(v);\n\n        if(u == v) return;\n\n        if(size[u] >= size[v]){\n            par[v] = u;\n            size[u] += size[v];\n        }\n        else{\n            par[u] = v;\n            size[v] += size[u];\n        }\n    }\n    \n};\nclass Solution {\npublic:\n    bool hasValidPath(vector<vector<int>>& grid) {\n        int n = grid.size();\n        int m = grid[0].size();\n        DisjointSet ds(n*m);\n        for(int i=0; i<n; i++){\n            for(int j=0; j<m; j++){\n                int p = i * m + j;\n                int p1 = (i-1)*m + j;  // 1\n                int p2 = (i+1)*m + j;  // 1\n                int p3 = i*m + (j+1);  // 2\n                int p4 = i*m + (j-1);  // 2\n\n                if(grid[i][j] == 1){\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\n                        ds.unionBySize(p,p3);\n                    }\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\n                        ds.unionBySize(p,p4);\n                    }\n                }\n                else if(grid[i][j] == 2){\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\n                        ds.unionBySize(p,p2);\n                    }\n\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\n                        ds.unionBySize(p,p1);\n                    }\n                }\n                else if(grid[i][j] == 3){\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\n                        ds.unionBySize(p,p4);\n                    }\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\n                        ds.unionBySize(p,p2);\n                    }\n                }\n                else if(grid[i][j] == 4){\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\n                        ds.unionBySize(p,p3);\n                    }\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\n                        ds.unionBySize(p,p2);\n                    }\n                }\n                else if(grid[i][j] == 5){\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\n                        ds.unionBySize(p,p1);\n                    }\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\n                        ds.unionBySize(p,p4);\n                    }\n                }\n                else if(grid[i][j] == 6){\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\n                        ds.unionBySize(p,p1);\n                    }\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\n                        ds.unionBySize(p,p3);\n                    }\n                }\n            }\n        }\n        return ds.findpar(0) == ds.findpar(n*m-1);\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass DisjointSet{\\npublic:\\n    vector<int>par,size;\\n    DisjointSet(int n){\\n        par.resize(n+1);\\n        size.resize(n+1,1);\\n        for(int i=0; i<=n; i++){\\n            par[i] = i;\\n        }\\n    }\\n    int findpar(int u){\\n        if(u == par[u]) return u;\\n        return par[u] = findpar(par[u]);\\n    }\\n\\n    void unionBySize(int u, int v){\\n        u = findpar(u);\\n        v = findpar(v);\\n\\n        if(u == v) return;\\n\\n        if(size[u] >= size[v]){\\n            par[v] = u;\\n            size[u] += size[v];\\n        }\\n        else{\\n            par[u] = v;\\n            size[v] += size[u];\\n        }\\n    }\\n    \\n};\\nclass Solution {\\npublic:\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        DisjointSet ds(n*m);\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                int p = i * m + j;\\n                int p1 = (i-1)*m + j;  // 1\\n                int p2 = (i+1)*m + j;  // 1\\n                int p3 = i*m + (j+1);  // 2\\n                int p4 = i*m + (j-1);  // 2\\n\\n                if(grid[i][j] == 1){\\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\\n                        ds.unionBySize(p,p3);\\n                    }\\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\\n                        ds.unionBySize(p,p4);\\n                    }\\n                }\\n                else if(grid[i][j] == 2){\\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\\n                        ds.unionBySize(p,p2);\\n                    }\\n\\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\\n                        ds.unionBySize(p,p1);\\n                    }\\n                }\\n                else if(grid[i][j] == 3){\\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\\n                        ds.unionBySize(p,p4);\\n                    }\\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\\n                        ds.unionBySize(p,p2);\\n                    }\\n                }\\n                else if(grid[i][j] == 4){\\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\\n                        ds.unionBySize(p,p3);\\n                    }\\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\\n                        ds.unionBySize(p,p2);\\n                    }\\n                }\\n                else if(grid[i][j] == 5){\\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\\n                        ds.unionBySize(p,p1);\\n                    }\\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\\n                        ds.unionBySize(p,p4);\\n                    }\\n                }\\n                else if(grid[i][j] == 6){\\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\\n                        ds.unionBySize(p,p1);\\n                    }\\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\\n                        ds.unionBySize(p,p3);\\n                    }\\n                }\\n            }\\n        }\\n        return ds.findpar(0) == ds.findpar(n*m-1);\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "== and = confusion",
            "indexing error",
            "wrong comment mark",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass DisjointSet{\npublic:\n    vector<int>par,size;\n    DisjointSet(int n){\n        par.resize(n+1);\n        size.resize(n+1,1);\n        for(int i=0; i<=n; i++){\n            par[i] == i;\n        }\n    }\n    int findpar(int u){\n        return par[u] = findpar(par[u]); \n    }\n\n    void unionBySize(int u, int v){\n        u == findpar(u);\n        v == findpar(v);\n\n        if(u == v) return;\n\n        if(size[u-1] >= size[v-1]){\n            par[v-1] = u;\n            size[u-1] += size[v;\n        }\n        else{\n            par[u-1] = v;\n            size[v-1] += size[u];\n        }\n    }\n    \n};\nclass Solution {\npublic:\n    bool hasValidPath(vector<vector<int>>& grid) {\n        int n = grid.size();\n        int m = grid[0].size();\n        DisjointSet ds(n*m);\n        for(int i=0; i<n; i++){\n            for(int j=0; j<m; j++){\n                int p = i * m + j;\n                int p1 = (i-1)*m + j;  \n                int p2 = (i+1)*m + j;  \n                int p3 = i*m + (j+1);  \n                int p4 = i*m + (j-1);  \n\n                if(grid[i][j] == 1){\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\n                        ds.unionBySize(p,p3);\n                    }\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\n                        ds.unionBySize(p,p4);\n                    }\n                }\n                else if(grid[i][j] == 2){\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\n                        ds.unionBySize(p,p2);\n                    }\n\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\n                        ds.unionBySize(p,p1);\n                    }\n                }\n                else if(grid[i][j] == 3){\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\n                        ds.unionBySize(p,p4);\n                    }\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\n                        ds.unionBySize(p,p2);\n                    }\n                }\n                else if(grid[i][j] == 4){\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\n                        ds.unionBySize(p,p3);\n                    }\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\n                        ds.unionBySize(p,p2);\n                    }\n                }\n                else if(grid[i][j] == 5){\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\n                        ds.unionBySize(p,p1);\n                    }\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\n                        ds.unionBySize(p,p4);\n                    }\n                }\n                else if(grid[i][j] == 6){\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\n                        ds.unionBySize(p,p1);\n                    }\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\n                        ds.unionBySize(p,p3);\n                    }\n                }\n            }\n        }\n        return ds.findpar(0) == ds.findpar(n*m-1);\n    }\n};\n"
    },
    {
        "slug": "magical-string",
        "description": "A magical string s consists of only '1' and '2' and obeys the following rules:\n\nThe string s is magical because concatenating the number of contiguous occurrences of characters '1' and '2' generates the string s itself.\n\nThe first few elements of s is s = \"1221121221221121122\u2026\u2026\". If we group the consecutive 1's and 2's in s, it will be \"1 22 11 2 1 22 1 22 11 2 11 22 ......\" and the occurrences of 1's or 2's in each group are \"1 2 2 1 1 2 1 2 2 1 2 2 ......\". You can see that the occurrence sequence is s itself.\nGiven an integer n, return the number of 1's in the first n number in the magical string s.",
        "examples": [
            "Input: n = 6\nOutput: 3\nExplanation: The first 6 elements of magical string s is \"122112\" and it contains three 1's, so return 3.",
            "Input: n = 1\nOutput: 1"
        ],
        "constraints": "1 <= n <= 105",
        "oracle_code": "class Solution {\npublic:\n    int magicalString(int n) {\n        string s=\"\";\n        s+=\"122\";\n        int i=2,c=1;\n        while(i<n && s.size()<n)\n        {\n            if(s[i]=='1')\n            {\n                c++;\n                if(s[s.size()-1]=='2')\n                s+='1';\n                else\n                {\n                    s+='2';\n                }\n            }\n            else\n            {\n                if(s[s.size()-1]=='2')\n                s+=\"11\";\n                else\n                {\n                    s+=\"22\";\n                }\n            }\n            i++;\n        }\n        while(i<n)\n        {\n            if(s[i]=='1')\n            c++;\n            i++;\n        }\n        return c;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIntution was to find the repeating part first, then i saw the pattern carefully and tried to make it.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can make the string using first three digits only \"122\",my intution is to make whole string upto length n,and count ones side by side. Also to count the remaining 1\\'s after while loop breaks\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int magicalString(int n) {\\n        string s=\"\";\\n        s+=\"122\";\\n        int i=2,c=1;\\n        while(i<n && s.size()<n)\\n        {\\n            if(s[i]==\\'1\\')\\n            {\\n                c++;\\n                if(s[s.size()-1]==\\'2\\')\\n                s+=\\'1\\';\\n                else\\n                {\\n                    s+=\\'2\\';\\n                }\\n            }\\n            else\\n            {\\n                if(s[s.size()-1]==\\'2\\')\\n                s+=\"11\";\\n                else\\n                {\\n                    s+=\"22\";\\n                }\\n            }\\n            i++;\\n        }\\n        while(i<n)\\n        {\\n            if(s[i]==\\'1\\')\\n            c++;\\n            i++;\\n        }\\n        return c;\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "== and = confusion",
            "unclosed string",
            "undefined keywords from other languages",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    int magicalString(int n) {\n        str s=\"\";\n        s+=\"122\";\n        int i=2,c=1;\n        while(i<n && s.size()<n\n        {\n            if(s[i]='1') \n            {\n                c++;\n                if(s[s.size()-1]=='2')\n                s+='1';\n                else\n                {\n                    s+='2';\n                }\n            }\n            else\n            {\n                if(s[s.size()-1]=='2')\n                s+=\"11\";\n                else\n                {\n                    s+='22'; \n                }\n            }\n            i++;\n        }\n        while(i<n)\n        {\n            if(s[i]='1') \n            c++;\n            i++;\n        }\n        return c;\n    }\n};\n"
    },
    {
        "slug": "check-knight-tour-configuration",
        "description": "There is a knight on an n x n chessboard. In a valid configuration, the knight starts at the top-left cell of the board and visits every cell on the board exactly once.\nYou are given an n x n integer matrix grid consisting of distinct integers from the range [0, n * n - 1] where grid[row][col] indicates that the cell (row, col) is the grid[row][col]th cell that the knight visited. The moves are 0-indexed.\nReturn true if grid represents a valid configuration of the knight's movements or false otherwise.\nNote that a valid knight move consists of moving two squares vertically and one square horizontally, or two squares horizontally and one square vertically. The figure below illustrates all the possible eight moves of a knight from some cell.",
        "examples": [
            "Input: grid = [[0,11,16,5,20],[17,4,19,10,15],[12,1,8,21,6],[3,18,23,14,9],[24,13,2,7,22]]\nOutput: true\nExplanation: The above diagram represents the grid. It can be shown that it is a valid configuration.",
            "Input: grid = [[0,3,6],[5,8,1],[2,7,4]]\nOutput: false\nExplanation: The above diagram represents the grid. The 8th move of the knight is not valid considering its position after the 7th move."
        ],
        "constraints": "n == grid.length == grid[i].length\n3 <= n <= 7\n0 <= grid[row][col] < n * n\nAll integers in grid are unique.",
        "oracle_code": "class Solution {\nprivate:\n    bool helper(vector<vector<int>>& grid, int row, int col, int num){\n        int n = grid.size();\n        if(num == n*n) return true;\n        int i = row-2;\n        int j = col+1;\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row-2;\n        j = col-1;\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 2;\n        j = col - 1;\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 2;\n        j = col + 1;\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 1;\n        j = col + 2;\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row - 1;\n        j = col + 2;\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row - 1;\n        j = col - 2;\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 1;\n        j = col - 2;\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        return false;\n    }\npublic:\n    bool checkValidGrid(vector<vector<int>>& grid) {\n        ios::sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);\n        if(grid[0][0] != 0) return false;\n        return helper(grid,0,0,1);\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    bool helper(vector<vector<int>>& grid, int row, int col, int num){\\n        int n = grid.size();\\n        if(num == n*n) return true;\\n        int i = row-2;\\n        int j = col+1;\\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row-2;\\n        j = col-1;\\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row + 2;\\n        j = col - 1;\\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row + 2;\\n        j = col + 1;\\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row + 1;\\n        j = col + 2;\\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row - 1;\\n        j = col + 2;\\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row - 1;\\n        j = col - 2;\\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row + 1;\\n        j = col - 2;\\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        return false;\\n    }\\npublic:\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(0);\\n        cout.tie(0);\\n        if(grid[0][0] != 0) return false;\\n        return helper(grid,0,0,1);\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "operation error",
            "undefined methods",
            "undefined keywords from other languages",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution {\nprivate:\n    bool helper(vector<vector<int>>& grid, int row, int col, int num){\n        int n = grid.size();\n\n        undefinedObject test;  \n\n        if(num == n*n) return true;\n        int i = row-2;\n        int j = col+1;\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row-2;\n        j = col-1;\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+2);\n\n        i = row + 2;\n        j = col - 1;\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 2;\n        j = col + 1;\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 1;\n        j = col + 2;\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row - 1;\n        j = col + 2;\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row - 1;\n        j = col - 2;\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 1;\n        j = col - 2;\n        if(i<n && j>=0 && grid[i][j] == num) return methodNotFound(grid,i,j,num+1);\n\n        return false;\n    }\npublic:\n    bool checkValidGrid(vector<vector<int>>& grid) {\n        sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);\n        if(grid[0][0] != 0) return false;\n        return helper(grid,0,0,1);\n    }\n};\n"
    },
    {
        "slug": "check-knight-tour-configuration",
        "description": "There is a knight on an n x n chessboard. In a valid configuration, the knight starts at the top-left cell of the board and visits every cell on the board exactly once.\nYou are given an n x n integer matrix grid consisting of distinct integers from the range [0, n * n - 1] where grid[row][col] indicates that the cell (row, col) is the grid[row][col]th cell that the knight visited. The moves are 0-indexed.\nReturn true if grid represents a valid configuration of the knight's movements or false otherwise.\nNote that a valid knight move consists of moving two squares vertically and one square horizontally, or two squares horizontally and one square vertically. The figure below illustrates all the possible eight moves of a knight from some cell.",
        "examples": [
            "Input: grid = [[0,11,16,5,20],[17,4,19,10,15],[12,1,8,21,6],[3,18,23,14,9],[24,13,2,7,22]]\nOutput: true\nExplanation: The above diagram represents the grid. It can be shown that it is a valid configuration.",
            "Input: grid = [[0,3,6],[5,8,1],[2,7,4]]\nOutput: false\nExplanation: The above diagram represents the grid. The 8th move of the knight is not valid considering its position after the 7th move."
        ],
        "constraints": "n == grid.length == grid[i].length\n3 <= n <= 7\n0 <= grid[row][col] < n * n\nAll integers in grid are unique.",
        "oracle_code": "class Solution {\nprivate:\n    bool helper(vector<vector<int>>& grid, int row, int col, int num){\n        int n = grid.size();\n        if(num == n*n) return true;\n        int i = row-2;\n        int j = col+1;\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row-2;\n        j = col-1;\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 2;\n        j = col - 1;\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 2;\n        j = col + 1;\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 1;\n        j = col + 2;\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row - 1;\n        j = col + 2;\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row - 1;\n        j = col - 2;\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 1;\n        j = col - 2;\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        return false;\n    }\npublic:\n    bool checkValidGrid(vector<vector<int>>& grid) {\n        ios::sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);\n        if(grid[0][0] != 0) return false;\n        return helper(grid,0,0,1);\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    bool helper(vector<vector<int>>& grid, int row, int col, int num){\\n        int n = grid.size();\\n        if(num == n*n) return true;\\n        int i = row-2;\\n        int j = col+1;\\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row-2;\\n        j = col-1;\\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row + 2;\\n        j = col - 1;\\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row + 2;\\n        j = col + 1;\\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row + 1;\\n        j = col + 2;\\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row - 1;\\n        j = col + 2;\\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row - 1;\\n        j = col - 2;\\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row + 1;\\n        j = col - 2;\\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        return false;\\n    }\\npublic:\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(0);\\n        cout.tie(0);\\n        if(grid[0][0] != 0) return false;\\n        return helper(grid,0,0,1);\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "operation error",
            "wrong comment mark",
            "undefined methods",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution {\nprivate:\n    bool helper(vector<vector<int>>& grid, int row, int col, int num){\n        int n \n\n        undefinedObject test;  \n\n        if(num == n*n) return true;\n        int i = row-2;\n        int j = col+1;\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row-2;\n        j = col-1;\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+2);\n\n        i = row + 2;\n        j = col - 1;\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 2;\n        j = col + 1;\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 1;\n        j = col + 2;\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row - 1;\n        j = col + 2;\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row - 1;\n        j = col - 2;\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 1;\n        j = col - 2;\n        if(i<n && j>=0 && grid[i][j] == num) return methodNotFound(grid,i,j,num+1);\n\n        return false;\n    }\npublic:\n    bool checkValidGrid(vector<vector<int>>& grid) {\n        ios::sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);\n        if(grid[0][0] != 0) return false;\n        return helper(grid,0,0,1);\n    }\n};\n"
    },
    {
        "slug": "count-of-range-sum",
        "description": "Given an integer array nums and two integers lower and upper, return the number of range sums that lie in [lower, upper] inclusive.\nRange sum S(i, j) is defined as the sum of the elements in nums between indices i and j inclusive, where i <= j.",
        "examples": [
            "Input: nums = [-2,5,-1], lower = -2, upper = 2\nOutput: 3\nExplanation: The three ranges are: [0,0], [2,2], and [0,2] and their respective sums are: -2, -1, 2.",
            "Input: nums = [0], lower = 0, upper = 0\nOutput: 1"
        ],
        "constraints": "1 <= nums.length <= 105\n-231 <= nums[i] <= 231 - 1\n-105 <= lower <= upper <= 105\nThe answer is guaranteed to fit in a 32-bit integer.",
        "oracle_code": "class Solution {\npublic:\n    \n    int countWithMergeSort(vector<long> &sums, int left, int right, int lower, int upper)\n    {\n        int count = 0;\n        \n        if(right - left <= 1)\n        {\n            if(right - left == 1)\n            {\n                return (lower <= sums[left] && sums[left] <= upper);\n            }\n            else\n            {\n                return 0;\n            }\n        }\n        \n        int mid = (left + right)/2;\n        \n        int leftSideSum = countWithMergeSort(sums, left, mid, lower, upper);\n        int rightSideSum = countWithMergeSort(sums, mid, right, lower, upper);\n        \n        \n        int i = left;\n        int j = mid;\n        \n        int n = 0;\n        int m = 0;\n        \n        vector<long> cache(right - left, 0);\n        \n        int k = 0;\n        \n        \n        while(i < mid)\n        {\n            \n\n            while(mid+n < right && sums[mid+n] < sums[i]+lower)\n                {\n                    n++;\n                }\n            \n            while(mid+m < right && sums[mid+m] <= sums[i] + upper)\n                {\n                    m++;\n                }\n            \n            while(j < right && sums[j] < sums[i])\n            {\n                cache[k++] = sums[j++];\n            }\n            \n            cache[k++] = sums[i++];\n            \n            count += m-n;\n        }\n        \n        \n        while(j < right)\n        {\n            cache[k++] = sums[j++];\n        }\n        \n        \n        for(int idx = 0; idx<cache.size(); idx++)\n        {\n            sums[left + idx] = cache[idx];\n        }\n    \n        return leftSideSum + rightSideSum + count;\n        \n    }\n    \n    int countRangeSum(vector<int>& nums, int lower, int upper) {\n        \n        vector<long> prefixSum(nums.size(),0);\n        \n        int n = nums.size();\n        \n        prefixSum[0] = nums[0];\n        \n        for(int i = 1; i<nums.size(); i++)\n        {\n            prefixSum[i] = nums[i] + prefixSum[i-1];\n        }\n        \n        return countWithMergeSort(prefixSum, 0, n, lower, upper);\n    }\n};",
        "content": "Hello, with this post I want to explain the solution to this problem to those who are encountering this problem for the first time (i.e. have not solved any other problems with this pattern), and are **NEW to solving HARD problems** in general. I will be explaining the solution found in this post https://leetcode.com/problems/count-of-range-sum/discuss/1178174/Java-Clean-Merge-Sort-O(N-logN)-Solution-oror-with-detailed-Explanation because this version of the solution applies commonly known concepts which anyone with basic data structures background should be able to grasp **(no BIT, fenwick tree or anything else which usually is not covered in a basic data structures course)**. Moreover, this approach is also applicable to other problems which are linked in the answer, hence it is most suitable for a beginner looking to learn general approaches/patterns.\\n\\nSo, the naive approach, which after some experience with medium problems, particularly like subarray sum etc. should come to one within a few minutes of thinking: Find the array of prefix sums, then use a nested loop to find all the sums which satisfy the given criteria. Of course O(n^2) will give TLE which is why this is HARD. \\n\\nSince I am also a beginner, I thought about it for a while and then moved on to reading a solution to understand what was the next step.\\n\\nI suppose for someone experienced, they may try some patterns with which n^2 problems are simplified, like DP or divide-and-conquer. The point of the hard problem is to start teaching you to inculcate this thinking of approaches when TLE after the naive solution is reached. So here, the mental question that should come to one\\'s mind is, \\n\\n* For DP: If I know the solution to nums[start:i-1], can I calculate the solution to nums[start:i]?\\n* For divide-and-conquer: If I know the solution to nums[start:mid] and nums[mid+1:end] (where mid = (start+end)/2 and end is the length of the array), can I calculate the solution to nums[start:end]?\\n\\nIn this case, it turns out that there is a divide and conquer solution. The solution is similar to **merge sort**.\\n\\nTake the PREFIX SUM array (and not the original array). Let this be called **sums**. \\n\\nIf we have the solution to the left and right halves of the array, we can find the solution to the complete array by finding suitable pairs of prefix sums, one from the left half and the other from the right half, and adding these to the solution from the left and right halves of the array.\\n\\nNow I will quote the crucial step from here: https://leetcode.com/problems/count-of-range-sum/discuss/1178174/Java-Clean-Merge-Sort-O(N-logN)-Solution-oror-with-detailed-Explanation\\n\\nThe merge sort based solution counts the answer while doing the merge. During the merge stage, we have already sorted the left half [start, mid) and right half [mid, end). We then iterate through the left half with index i. For each i, we need to find two indices k and j in the right half where\\n\\n* j is the first index satisfy sums[j] - sums[i] > upper and\\n* k is the first index satisfy sums[k] - sums[i] >= lower.\\n\\nThen the number of sums in [lower, upper] is j-k.\\n\\nTo understand this, consider any prefix sum after x elements. Consider another prefix sum after y elements such that x <= y. Then, if we know sums[x], then for x and y to form a range with a sum within the lower and upper bounds,  then the conditions sums[y] - sums[x] >= lower and sums[y] - sums[x] <= upper, should be satisfied. \\n\\nThis gives the **condition for y** as sums[y] <= sums[x] + upper and sums[y] >= sums[x] + lower, and y >= x.\\n\\nDuring merge sort note that the **relative ordering between the left and right halves is maintained** before the merging, so letting x belong to the left side of the array, y to the right half of the array maintains x <= y.\\n\\nHence if we make the count for each element in the left half of the array during the merge, then the count is guaranteed to be correct. \\n\\nAlso, due to sorted nature of subarrays used during merge, for a given x in the left subarray, since the right subarray is also sorted, it means that the elements within the desired range sums[x] + lower and sums[x] + upper are **found in a contiguous chunk** of the right subarray. \\n\\nMoreover, since the left subarray is also sorted, sums[x] increases with x **(monotonicity)**. This means that every time x is incremented, we can use the indices obtained for the range in the right subarray for the previous x, instead of starting both from 0, since both sums[x] + lower and sums[x] + upper can only increase. \\n\\n In the quoted bullet points above, the updates ensure that at the end of the updating, the indices cover the required range for each index.\\n\\nThe base case here is that a single element will add to the count if the element value lies between lower and upper otherwise the solution will be zero. \\n\\n**To write the solution** after understanding these steps, I used the following approach: Write merge sort in the usual way. Use two indices/pointers m and n starting from the beginning of the right subarray before the merge. At any block where the left subarray index is updated, update these two m and n. Add these to the total count. The function should return the sum of the counts of the left half, right half and the total count during the merge. \\n\\nMy first working solution in which I used the conventional merge sort template where following the main merge step there are two while loops, had to make the counts twice, once in the nested loop and once in the outside loop (since left subarray index is updated in these places). To get the form of the elegant solutions such as in the linked answer, I made the change to use an alternative form of merging where during every loop iteration, an update to the left index is guaranteed, and the merge concludes when the left subarray is completely traversed. \\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int countWithMergeSort(vector<long> &sums, int left, int right, int lower, int upper)\\n    {\\n        int count = 0;\\n        \\n        if(right - left <= 1)\\n        {\\n            if(right - left == 1)\\n            {\\n                return (lower <= sums[left] && sums[left] <= upper);\\n            }\\n            else\\n            {\\n                return 0;\\n            }\\n        }\\n        \\n        int mid = (left + right)/2;\\n        \\n        int leftSideSum = countWithMergeSort(sums, left, mid, lower, upper);\\n        int rightSideSum = countWithMergeSort(sums, mid, right, lower, upper);\\n        \\n        \\n        int i = left;\\n        int j = mid;\\n        \\n        int n = 0;\\n        int m = 0;\\n        \\n        vector<long> cache(right - left, 0);\\n        \\n        int k = 0;\\n        \\n        \\n        while(i < mid)\\n        {\\n            \\n\\n            while(mid+n < right && sums[mid+n] < sums[i]+lower)\\n                {\\n                    n++;\\n                }\\n            \\n            while(mid+m < right && sums[mid+m] <= sums[i] + upper)\\n                {\\n                    m++;\\n                }\\n            \\n            while(j < right && sums[j] < sums[i])\\n            {\\n                cache[k++] = sums[j++];\\n            }\\n            \\n            cache[k++] = sums[i++];\\n            \\n            count += m-n;\\n        }\\n        \\n        \\n        while(j < right)\\n        {\\n            cache[k++] = sums[j++];\\n        }\\n        \\n        \\n        for(int idx = 0; idx<cache.size(); idx++)\\n        {\\n            sums[left + idx] = cache[idx];\\n        }\\n    \\n        return leftSideSum + rightSideSum + count;\\n        \\n    }\\n    \\n    int countRangeSum(vector<int>& nums, int lower, int upper) {\\n        \\n        vector<long> prefixSum(nums.size(),0);\\n        \\n        int n = nums.size();\\n        \\n        prefixSum[0] = nums[0];\\n        \\n        for(int i = 1; i<nums.size(); i++)\\n        {\\n            prefixSum[i] = nums[i] + prefixSum[i-1];\\n        }\\n        \\n        return countWithMergeSort(prefixSum, 0, n, lower, upper);\\n    }\\n};\\n```\\n\\nAny comments or suggestions are welcome as I am also a beginner (took me 3+ hours to get this) who has spent some time in learning/convincing myself of the approach. I tried to address the points which took up a lot of my time while trying to understand some of the other solutions. \\n\\n\\n\\n\\n",
        "level": "hard",
        "type": [
            "undefined methods",
            "variable value error",
            "parentheses mismatch",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    \n    int countWithMergeSort(vector<long> &sums, int left, int right, int lower, int upper)\n    {\n        int count = 0;\n\n        if(right - left <= 1) {\n            if(right - left == 1) {\n                return (lower <= sums[left] && sums[left] <= upper);\n            }\n            else\n            {\n                return 0;\n            }\n        }\n\n        int mid = (left + right)/2;\n\n        int leftSideSum = countWithMergeSort(sums, left, mid, lower, upper;\n        int rightSideSum = countWithMergeSort(sums, mid, right, lower, upper);\n\n        int i = left;\n        int j = mid;\n\n        int n = 0;\n        int m = right;\n\n        vector<long> cache(right - left, 0);\n\n        int k = 0;\n\n        while(i < mid)\n        {            while(mid+n < right && sums[mid+n] < sums[i]+lower)\n            {\n                n++;\n            }\n\n            while(mid+m < right && sums[mid+m] <= sums[i] + upper)\n            {\n                m++;\n            }\n\n            while(j < mid && sums[j] < sums[i])\n            {\n                cache[k++] = sums[j++];\n            }\n\n            cache[k++] = sums[i++];\n\n            count += m-n;\n        }\n\n        \n        while(i < mid)\n        {\n        }\n\n        while(j < right)\n        {\n            cache[k++] = sums[j++];\n        }\n\n        for(int idx = 0; idx<cache.size(); idx++)\n        {\n            sums[left + idx] = cache[idx];\n        }\n    \n        return leftSideSum + rightSideSum;\n        \n    }\n\n    int countRangeSum(vector<int>& nums, int lower, int upper) {\n        \n        vector<long> prefixSum(nums.size(),0);\n        \n        int n = nums.size();\n        \n        prefixSum[0] = nums[0];\n        \n        for(int i = 1; i<nums.size(); i++)\n        {\n            prefixSum[i] = nums[i] + prefixSum[i-1];\n        }\n        \n        return countWithMergeSort(prefixSum, 0, n, lower, upper);\n    }\n};\n"
    },
    {
        "slug": "valid-anagram",
        "description": "Given two strings s and t, return true if t is an anagram of s, and false otherwise.\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.",
        "examples": [
            "Input: s = \"anagram\", t = \"nagaram\"\nOutput: true",
            "Input: s = \"rat\", t = \"car\"\nOutput: false"
        ],
        "constraints": "1 <= s.length, t.length <= 5 * 104\ns and t consist of lowercase English letters.",
        "oracle_code": "class Solution {\npublic:\n    bool isAnagram(string s, string t) {\n        if(s.length()!=t.length())\n            return false;\n        vector<int> freq(26, 0);\n        for(int i =0; i<s.length(); i++){\n            freq[s[i]-'a']++;\n            freq[t[i]-'a']--;\n        }\n        for(int i =0; i<freq.size(); i++){\n            if(freq[i]!=0)\n                return false;\n        }\n        return true;\n    }\n};",
        "content": "# Intuition\\nTo solve this problem we will count occurence of each character in both strings and if they are same then both strings are anagram of each other.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nWe can use vector of length 26 to track the occurences of character. \\nIf the size of both string is different then they can\\'t be anagram of each other, so we are checking this first.We loop through each character in both strings and increment the frequency of the corresponding letter in s and decrement the frequency of the corresponding letter in t.\\nThen we loop through freq array if all the elements are 0, if all the elements are 0 this means the two strings are anagram and if not then these things are not anagram of each othe.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n), n is the size of s or t string.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isAnagram(string s, string t) {\\n        if(s.length()!=t.length())\\n            return false;\\n        vector<int> freq(26, 0);\\n        for(int i =0; i<s.length(); i++){\\n            freq[s[i]-\\'a\\']++;\\n            freq[t[i]-\\'a\\']--;\\n        }\\n        for(int i =0; i<freq.size(); i++){\\n            if(freq[i]!=0)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "statement separation",
            "indexing error",
            "unclosed string",
            "colon missing"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    bool isAnagram(string s, string t) {\n        if(s.length()!=t.length())\n            return false\n        vector<int> freq(26, 0);\n        for(int i =0; i<=s.length(); i++)\n            freq[s[i]-'a']++;\n            freq[t[i]-'a']--;\n        for(int i =0; i<freq.size(); i++)\n            if(freq[i]!=0)\n                return false;\n\n        return true;\n    }\n'};\n\n\n"
    },
    {
        "slug": "maximum-gap",
        "description": "Given an integer array nums, return the maximum difference between two successive elements in its sorted form. If the array contains less than two elements, return 0.\nYou must write an algorithm that runs in linear time and uses linear extra space.",
        "examples": [
            "Input: nums = [3,6,9,1]\nOutput: 3\nExplanation: The sorted form of the array is [1,3,6,9], either (3,6) or (6,9) has the maximum difference 3.",
            "Input: nums = [10]\nOutput: 0\nExplanation: The array contains less than 2 elements, therefore return 0."
        ],
        "constraints": "1 <= nums.length <= 105\n0 <= nums[i] <= 109",
        "oracle_code": "class Solution {\npublic:\n\nvector<int> countsort(vector<int> &nums)\n{\n    int n = nums.size();\n    map<int, int> m;\n    for (int i = 0; i < n; i++ )\n        m[nums[i]]++;\n\n    nums.clear();\n    for (auto it : m)\n    {\n        int cnt = it.second;\n        while (cnt--)\n        {\n            nums.push_back(it.first);\n        }\n    }\n    return nums;\n}\n\nint maximumGap(vector<int> &nums)\n{\n    int n = nums.size();\n    if (n < 2)\n        return 0;\n    vector<int> sortednums = countsort(nums);\n\n    int maxgap = INT_MIN;\n    for (int i = 1; i < n; i++)\n    {\n        int currgap = sortednums[i] - sortednums[i - 1];\n        maxgap = max(maxgap, currgap);\n    }\n\n    return maxgap;\n}\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nsince it is given in the question that we can use only linear time and space so we can only use a kind of counting sort , where we required a hash map which take an extra o(n) time complexity.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn counting sort first we required an hash map where we store the frequency of each element and after storing the frequency we just need to fill the original array based on there frequency , here we use an map not unordered map because the map is store value in sorted order.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nwe are traversing the array once , so  it is O(n) and an extra (logn)\\nfactor comes because of using the map, but still it is better in terms of time from inbuilt sort function..\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n) we are using only an map so the total extra space is equal to the size of map.\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\nvector<int> countsort(vector<int> &nums)\\n{\\n    int n = nums.size();\\n    map<int, int> m;\\n    for (int i = 0; i < n; i++ )\\n        m[nums[i]]++;\\n\\n    nums.clear();\\n    for (auto it : m)\\n    {\\n        int cnt = it.second;\\n        while (cnt--)\\n        {\\n            nums.push_back(it.first);\\n        }\\n    }\\n    return nums;\\n}\\n\\nint maximumGap(vector<int> &nums)\\n{\\n    int n = nums.size();\\n    if (n < 2)\\n        return 0;\\n    vector<int> sortednums = countsort(nums);\\n\\n    int maxgap = INT_MIN;\\n    for (int i = 1; i < n; i++)\\n    {\\n        int currgap = sortednums[i] - sortednums[i - 1];\\n        maxgap = max(maxgap, currgap);\\n    }\\n\\n    return maxgap;\\n}\\n};\\n```",
        "level": "medium",
        "type": [
            "indexing error",
            "wrong comment mark",
            "conditional statement error",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n\nvector<int> countsort(vector<int> &nums)\n{\n    int n = nums.size();\n    map<int, int> m;\n    for (int i = 0; /**/ i /*/ <= n; i++ )\n        m[nums[i]]++;\n\n    nums.clear();\n    for (auto it : m)\n    {\n        int cnt = it.second;\n        while (cnt--\n        {\n            nums.push_back(it.first);\n        }\n    }\n    return nums;\n}\n\nint maximumGap(vector<int> &nums)\n{\n    int n = nums.size();\n    if (n < 2)\n        return 0;\n    vector<int> sortednums = countsort(nums);\n\n    int maxgap = INT_MIN;\n    for (int i = 1; i <= n; i++)\n    {\n        int currgap = sortednums[i] - sortednums[i - 1];\n        maxgap = max(maxgap, currgap);\n    }\n\n    return maxgap;\n}\n};\n"
    },
    {
        "slug": "shortest-path-to-get-all-keys",
        "description": "You are given an m x n grid grid where:\n\n'.' is an empty cell.\n'#' is a wall.\n'@' is the starting point.\nLowercase letters represent keys.\nUppercase letters represent locks.\n\nYou start at the starting point and one move consists of walking one space in one of the four cardinal directions. You cannot walk outside the grid, or walk into a wall.\nIf you walk over a key, you can pick it up and you cannot walk over a lock unless you have its corresponding key.\nFor some 1 <= k <= 6, there is exactly one lowercase and one uppercase letter of the first k letters of the English alphabet in the grid. This means that there is exactly one key for each lock, and one lock for each key; and also that the letters used to represent the keys and locks were chosen in the same order as the English alphabet.\nReturn the lowest number of moves to acquire all keys. If it is impossible, return -1.",
        "examples": [
            "Input: grid = [\"@.a..\",\"###.#\",\"b.A.B\"]\nOutput: 8\nExplanation: Note that the goal is to obtain all the keys not to open all the locks.",
            "Input: grid = [\"@..aA\",\"..B#.\",\"....b\"]\nOutput: 6",
            "Input: grid = [\"@Aa\"]\nOutput: -1"
        ],
        "constraints": "m == grid.length\nn == grid[i].length\n1 <= m, n <= 30\ngrid[i][j] is either an English letter, '.', '#', or '@'.\u00a0\nThere is exactly one\u00a0'@'\u00a0in the grid.\nThe number of keys in the grid is in the range [1, 6].\nEach key in the grid is unique.\nEach key in the grid has a matching lock.",
        "oracle_code": "class Solution {\npublic:\n\n    int dir[4][2] = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};\n\n    int shortestPathAllKeys(vector<string>& grid) {\n        \n        int m = grid.size();\n        int n = grid[0].size();\n        queue<pair<pair<int, int>, int>> que;\n        vector<vector<unsigned long>> mapKey(m, vector<unsigned long>(n, 0));\n        int target = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if ('a' <= grid[i][j] && grid[i][j] <= 'f') {\n                    target |= 1 << (grid[i][j] - 'a');\n                    continue;\n                }\n\n                if (grid[i][j] == '@') {\n                    que.emplace(pair<int, int>(i, j), 0);\n                    mapKey[i][j] = 1;\n                }\n            }\n        }\n\n\n        int step = 0;\n        while (!que.empty()) {\n            int size = que.size();\n            for (int s = 0; s < size; s++) {\n                int i = que.front().first.first;\n                int j = que.front().first.second;\n                int key = que.front().second;\n                que.pop();\n                \n                if ('a' <= grid[i][j] && grid[i][j] <= 'f') {\n                    key |= 1 << (grid[i][j] - 'a');\n                    if (key == target)\n                        return step;\n\n                    mapKey[i][j] |= 1l << key;\n                }\n\n                for (int d = 0; d < 4; d++) {\n                    int newi = i + dir[d][0];\n                    int newj = j + dir[d][1];\n                    \n                    if (!(0 <= newi && newi < m && 0 <= newj && newj < n))\n                        continue;\n                        \n                    int val = grid[newi][newj];\n                    if (val == '#')\n                        continue;\n                        \n                    if ('A' <= val && val <= 'F' && (key & (1 << (val - 'A'))) == 0)\n                        continue;\n                        \n                    if (mapKey[newi][newj] & (1l << key))\n                        continue;\n                        \n                     mapKey[newi][newj] |= 1l << key;\n                     que.emplace(pair<int, int>(newi, newj), key);\n                }\n            }\n            step++;\n        }\n        return -1;\n    }\n};",
        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int dir[4][2] = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};\\n\\n    int shortestPathAllKeys(vector<string>& grid) {\\n        \\n        int m = grid.size();\\n        int n = grid[0].size();\\n        queue<pair<pair<int, int>, int>> que;\\n        vector<vector<unsigned long>> mapKey(m, vector<unsigned long>(n, 0));\\n        int target = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (\\'a\\' <= grid[i][j] && grid[i][j] <= \\'f\\') {\\n                    target |= 1 << (grid[i][j] - \\'a\\');\\n                    continue;\\n                }\\n\\n                if (grid[i][j] == \\'@\\') {\\n                    que.emplace(pair<int, int>(i, j), 0);\\n                    mapKey[i][j] = 1;\\n                }\\n            }\\n        }\\n\\n\\n        int step = 0;\\n        while (!que.empty()) {\\n            int size = que.size();\\n            for (int s = 0; s < size; s++) {\\n                int i = que.front().first.first;\\n                int j = que.front().first.second;\\n                int key = que.front().second;\\n                que.pop();\\n                \\n                if (\\'a\\' <= grid[i][j] && grid[i][j] <= \\'f\\') {\\n                    key |= 1 << (grid[i][j] - \\'a\\');\\n                    if (key == target)\\n                        return step;\\n\\n                    mapKey[i][j] |= 1l << key;\\n                }\\n\\n                for (int d = 0; d < 4; d++) {\\n                    int newi = i + dir[d][0];\\n                    int newj = j + dir[d][1];\\n                    \\n                    if (!(0 <= newi && newi < m && 0 <= newj && newj < n))\\n                        continue;\\n                        \\n                    int val = grid[newi][newj];\\n                    if (val == \\'#\\')\\n                        continue;\\n                        \\n                    if (\\'A\\' <= val && val <= \\'F\\' && (key & (1 << (val - \\'A\\'))) == 0)\\n                        continue;\\n                        \\n                    if (mapKey[newi][newj] & (1l << key))\\n                        continue;\\n                        \\n                     mapKey[newi][newj] |= 1l << key;\\n                     que.emplace(pair<int, int>(newi, newj), key);\\n                }\\n            }\\n            step++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
        "level": "hard",
        "type": [
            "== and = confusion",
            "wrong comment mark",
            "unclosed string",
            "colon missing"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n\n    int dir[4][2] = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};\n\n    int shortestPathAllKeys(vector<string>& grid) {\n        \n        int m = grid.size();\n        int n = grid[0].size();\n        queue<pair<pair<int, int>, int>> que;\n        vector<vector<unsigned long>> mapKey(m, vector<unsigned long>(n, 0));\n        int target = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if ('a' <= grid[i][j] && grid[i][j] <= 'f') {\n                    target |= 1  (grid[i][j] - 'a\");\n                    continue;\n                }\n\n                if (grid[i][j] = '@') {\n                    que.emplace(pair<int, int>(i, j), 0);\n                    mapKey[i][j] = 1;\n                }\n            }\n        }\n\n\n        int step = 0;\n        while (!que.empty()) {\n            int size = que.size();\n            for (int s = 0; s < size; s++) {\n                int i = que.front().first.first;\n                int j = que.front().first.second;\n                int key = que.front().second;\n                que.pop();\n                \n                if ('a' <= grid[i][j] && grid[i][j] <= 'f\") {\n                    key |= 1 << (grid[i][j] - 'a\");\n                    if (key == target)\n                        return step;\n\n                    mapKey[i][j] |= 1l << key;\n                }\n\n                for (int d = 0; d < 4; d++) {\n                   \n                    int newj = j + dir[d][1];\n                    \n                    if (!(0 <= newi && newi < m && 0 <= newj && newj < n))\n                        continue;\n                        \n                    int val = grid[newi][newj];\n                    if (val == '#')\n                        continue;\n                        \n                    if ('A' <= val && val <= 'F' && (key & (1  (val - 'A\"))) == 0)\n                        continue;\n                        \n                    if (mapKey[newi][newj] & (1l << key))\n                        continue;\n                        \n                     mapKey[newi][newj] |= 1l << key;\n                     que.emplace(pair<int, int>(newi, newj), key);\n                }\n            }\n            step++;\n        }\n        return -1;\n    }\n};\n"
    },
    {
        "slug": "lru-cache",
        "description": "Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.\nImplement the LRUCache class:\n\nLRUCache(int capacity) Initialize the LRU cache with positive size capacity.\nint get(int key) Return the value of the key if the key exists, otherwise return -1.\nvoid put(int key, int value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key.\n\nThe functions get and put must each run in O(1) average time complexity.",
        "examples": [
            "Input\n[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"]\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\nOutput\n[null, null, null, 1, null, -1, null, -1, 3, 4]\n\nExplanation\nLRUCache lRUCache = new LRUCache(2);\nlRUCache.put(1, 1); // cache is {1=1}\nlRUCache.put(2, 2); // cache is {1=1, 2=2}\nlRUCache.get(1);    // return 1\nlRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}\nlRUCache.get(2);    // returns -1 (not found)\nlRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}\nlRUCache.get(1);    // return -1 (not found)\nlRUCache.get(3);    // return 3\nlRUCache.get(4);    // return 4"
        ],
        "constraints": "1 <= capacity <= 3000\n0 <= key <= 104\n0 <= value <= 105\nAt most 2 * 105 calls will be made to get and put.",
        "oracle_code": "class LRUCache {\npublic:\nclass node\n{\n  public:\n  int key;\n  int val;\n  node* next;\n  node* prev;\n  node(int _key,int _val)\n  {\n    key = _key;\n    val = _val;\n  }\n};\nnode* head = new node(-1,-1);\nnode* tail = new node(-1,-1);\n\nint size;\nunordered_map<int,node*>mpp;\n    LRUCache(int capacity) {\n       size = capacity; \n       head->next = tail;\n       tail->prev = head;  \n    }\n\n    void addNode(node* newNode){\n       \n       node* temp = head->next;\n       newNode->next = temp;\n       newNode->prev = head;\n       head->next = newNode;\n       temp->prev = newNode;\n    }\n\n    void deleteNode(node* delNode){\n         \n       node* delprev = delNode->prev;\n       node* delnext = delNode->next;\n       delprev->next = delnext;\n       delnext->prev = delprev;\n    }\n    \n    int get(int _key) {\n        \n        if(mpp.count(_key))\n        {\n          node* nde = mpp[_key];\n          int curr = nde->val;\n          mpp.erase(_key);\n          deleteNode(nde);\n          addNode(nde);\n          mpp[_key] = head->next;\n          return curr;\n        }\n        return -1;\n    }\n    \n    void put(int _key, int value) {\n        \n        if(mpp.count(_key))\n        {\n           node* nde = mpp[_key];\n           mpp.erase(_key);\n           deleteNode(nde);\n        }\n        if(mpp.size()==size)\n        {\n           mpp.erase(tail->prev->key);\n           deleteNode(tail->prev);\n        }\n        addNode(new node(_key,value));\n        mpp[_key] = head->next;\n    }\n};",
        "content": "# PLEASE DO UPVOTE!!!!!\\n\\n**CONNECT WITH ME ON LINKEDIN :  https://www.linkedin.com/in/md-kamran-55b98521a/**\\n\\n## INTUITION\\nTo Implement LRU(Least recently used), we need to have a track of the usage of the keys, in the order of there usage, as we have a limited capacity we cant extend our capacity beyond \"capacity\", so we always we will take out those values which has\\'nt been acccess in the recent time.So, we have to think of something that can kind of sort our keys according to usage on the go, the best Data Structure for this purpose is Doubly linked List.\\n                             A Doubly linked list will have a Head node as well as a tail node, and whenever a key is used we will place it just next to the head node,in this fashions, the one\\'s which are closer to head are the most recently used ones, and as we go closer to the tail node, those are the less recently used ones while the node just previous to tail is the \"LEAST RECENTLY USED\". \\nSo whenever we add a key or use a key(get()), we will move it right after the head node, and whenever we call the (put() function), if size if greater we have to delete the LRU node, if key is not present, (if present then too we will delete that node so as to update the value and still move it right after head node), and place new node right after head node.                        \\n\\n\\n**Ask Furthur Doubts in the Comment Section**\\n# Code\\n```\\nclass LRUCache {\\npublic:\\nclass node\\n{\\n  public:\\n  int key;\\n  int val;\\n  node* next;\\n  node* prev;\\n  node(int _key,int _val)\\n  {\\n    key = _key;\\n    val = _val;\\n  }\\n};\\nnode* head = new node(-1,-1);\\nnode* tail = new node(-1,-1);\\n\\nint size;\\nunordered_map<int,node*>mpp;\\n    LRUCache(int capacity) {\\n       size = capacity; \\n       head->next = tail;\\n       tail->prev = head;  \\n    }\\n\\n    void addNode(node* newNode){\\n       \\n       node* temp = head->next;\\n       newNode->next = temp;\\n       newNode->prev = head;\\n       head->next = newNode;\\n       temp->prev = newNode;\\n    }\\n\\n    void deleteNode(node* delNode){\\n         \\n       node* delprev = delNode->prev;\\n       node* delnext = delNode->next;\\n       delprev->next = delnext;\\n       delnext->prev = delprev;\\n    }\\n    \\n    int get(int _key) {\\n        \\n        if(mpp.count(_key))\\n        {\\n          node* nde = mpp[_key];\\n          int curr = nde->val;\\n          mpp.erase(_key);\\n          deleteNode(nde);\\n          addNode(nde);\\n          mpp[_key] = head->next;\\n          return curr;\\n        }\\n        return -1;\\n    }\\n    \\n    void put(int _key, int value) {\\n        \\n        if(mpp.count(_key))\\n        {\\n           node* nde = mpp[_key];\\n           mpp.erase(_key);\\n           deleteNode(nde);\\n        }\\n        if(mpp.size()==size)\\n        {\\n           mpp.erase(tail->prev->key);\\n           deleteNode(tail->prev);\\n        }\\n        addNode(new node(_key,value));\\n        mpp[_key] = head->next;\\n    }\\n};\\n\\n```\\n![b62ab1be-232a-438f-9524-7d8ca4dbd5fe_1675328166.1161866.png](https://assets.leetcode.com/users/images/8d5343b1-0eb4-4111-a914-40ce968fd034_1675389764.2273676.png)",
        "level": "medium",
        "type": [
            "wrong comment mark",
            "undefined keywords from other languages",
            "variable value error",
            "colon missing"
        ],
        "buggy_code": "\nclass LRUCache {\npublic:\nclass node\n{\n  public:\n  int key;\n  int val;\n  node* next;\n  node* prev;\n  node(int _key,int _val)\n  {\n    key = _key;\n    val = _val;\n  }\n};\nnode* head = new node(-1,-1);\nnode* tail = new node(-1,-1);\n\nint size;\nunordered_map<int,node*>mpp;\n    LRUCache(int capacity) {\n       size = capacity; \n       head->next = tail;\n       tail->prev = head;  \n    }\n\n    void addNode(node* newNode){\n       \n       node* temp = head->next;\n       newNode->next = temp;\n       newNode->prev = head;\n       head->next = newNode;\n    }\n\n    /*void deleteNode(node* delNode){\n         \n       node* delprev = delNode->prev;\n       node* delnext = delNode->next;\n       delprev->next = delnext;\n       delnext->prev = delprev;\n    }*/\n    \n    int get(int _key) {\n        \n        if(mpp.count(_key))\n        {\n          node* nde = mpp[_key];\n          int curr = nde->val;\n          mpp.erase(_key);\n          deleteNode(nde);\n          addNode(nde)\n          mpp[_key] = head->next;\n          return curr;\n        }\n        return -1;\n    }\n    \n    void put(int _key, int value) {\n        \n        if(mpp.count(_key))\n        {\n           node* nde = mpp[_key];\n           mpp.erase(_key);\n           deleteNode(nde);\n        }\n        if(mpp.size()==size)\n        {\n           mpp.erase(tail->prev->key);\n           deleteNode(tail->prev);\n        }\n        addNode(new node(_key,var));\n        mpp[_key] = tail->next;\n    }\n};\n"
    },
    {
        "slug": "shortest-path-with-alternating-colors",
        "description": "You are given an integer n, the number of nodes in a directed graph where the nodes are labeled from 0 to n - 1. Each edge is red or blue in this graph, and there could be self-edges and parallel edges.\nYou are given two arrays redEdges and blueEdges where:\n\nredEdges[i] = [ai, bi] indicates that there is a directed red edge from node ai to node bi in the graph, and\nblueEdges[j] = [uj, vj] indicates that there is a directed blue edge from node uj to node vj in the graph.\n\nReturn an array answer of length n, where each answer[x] is the length of the shortest path from node 0 to node x such that the edge colors alternate along the path, or -1 if such a path does not exist.",
        "examples": [
            "Input: n = 3, redEdges = [[0,1],[1,2]], blueEdges = []\nOutput: [0,1,-1]",
            "Input: n = 3, redEdges = [[0,1]], blueEdges = [[2,1]]\nOutput: [0,1,-1]"
        ],
        "constraints": "1 <= n <= 100\n0 <= redEdges.length,\u00a0blueEdges.length <= 400\nredEdges[i].length == blueEdges[j].length == 2\n0 <= ai, bi, uj, vj < n",
        "oracle_code": "class Solution {\npublic:\n    vector<int> shortestAlternatingPaths(int n,vector<vector<int>>&redEdges,vector<vector<int>>& blueEdges) \n    {\n        multiset<int>temp;\n        vector<multiset<int>>redchilds(n,temp),bluechilds(n,temp);\n        for(auto j:redEdges)\n        {\n            redchilds[j[0]].insert(j[1]);\n        }\n        for(auto j:blueEdges)\n        {\n            bluechilds[j[0]].insert(j[1]);\n        }\n        vector<int>ans;\n        for(int i=0;i<n;i++)\n        {\n            //BFS for all\n            vector<multiset<int>>reds=redchilds,blues=bluechilds;\n            queue<pair<char,int>>visit;\n            visit.push({'n',0});//neutral='n'\n            int steps=0;\n            while(!visit.empty())\n            {\n                bool justbreak=false;\n                int n=visit.size();\n                for(int j=0;j<n;j++)\n                {\n                    pair<char,int>x=visit.front();\n                    visit.pop();\n                    if(x.second==i)\n                    {\n                        ans.push_back(steps);\n                        justbreak=true;\n                        break;\n                    }\n                    if(x.first=='n')\n                    {\n                        for(auto j:reds[x.second])\n                        {\n                            visit.push({'r',j});\n                            auto itr1=reds[x.second].find(j);\n                            reds[x.second].erase(itr1);\n                        }\n                        for(auto j:blues[x.second])\n                        {\n                            visit.push({'b',j});//blue='b'\n                            auto itr1=blues[x.second].find(j);\n                            blues[x.second].erase(itr1);\n                        }\n                    }\n                    else if(x.first=='b')\n                    {\n                        for(auto j:reds[x.second])\n                        {\n                            visit.push({'r',j});//red='r'\n                            auto itr1=reds[x.second].find(j);\n                            reds[x.second].erase(itr1);\n                        }\n                    }\n                    else if(x.first=='r')\n                    {\n                        for(auto j:blues[x.second])\n                        {\n                            visit.push({'b',j});\n                            auto itr1=blues[x.second].find(j);\n                            blues[x.second].erase(itr1);\n                        }\n                    }\n                }\n                if(justbreak)\n                {\n                    break;\n                }\n                steps++;\n            }\n            if(i==ans.size())\n            {\n                ans.push_back(-1);\n            }\n        }\n        return ans;\n    }\n};",
        "content": "*E denotes number of Edges*\\n\\n# Complexity\\n- Time complexity:\\nO((N^2)+(N)*(E)*LOG(E))\\n\\n- Space complexity:\\nO(E)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> shortestAlternatingPaths(int n,vector<vector<int>>&redEdges,vector<vector<int>>& blueEdges) \\n    {\\n        multiset<int>temp;\\n        vector<multiset<int>>redchilds(n,temp),bluechilds(n,temp);\\n        for(auto j:redEdges)\\n        {\\n            redchilds[j[0]].insert(j[1]);\\n        }\\n        for(auto j:blueEdges)\\n        {\\n            bluechilds[j[0]].insert(j[1]);\\n        }\\n        vector<int>ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            //BFS for all\\n            vector<multiset<int>>reds=redchilds,blues=bluechilds;\\n            queue<pair<char,int>>visit;\\n            visit.push({\\'n\\',0});//neutral=\\'n\\'\\n            int steps=0;\\n            while(!visit.empty())\\n            {\\n                bool justbreak=false;\\n                int n=visit.size();\\n                for(int j=0;j<n;j++)\\n                {\\n                    pair<char,int>x=visit.front();\\n                    visit.pop();\\n                    if(x.second==i)\\n                    {\\n                        ans.push_back(steps);\\n                        justbreak=true;\\n                        break;\\n                    }\\n                    if(x.first==\\'n\\')\\n                    {\\n                        for(auto j:reds[x.second])\\n                        {\\n                            visit.push({\\'r\\',j});\\n                            auto itr1=reds[x.second].find(j);\\n                            reds[x.second].erase(itr1);\\n                        }\\n                        for(auto j:blues[x.second])\\n                        {\\n                            visit.push({\\'b\\',j});//blue=\\'b\\'\\n                            auto itr1=blues[x.second].find(j);\\n                            blues[x.second].erase(itr1);\\n                        }\\n                    }\\n                    else if(x.first==\\'b\\')\\n                    {\\n                        for(auto j:reds[x.second])\\n                        {\\n                            visit.push({\\'r\\',j});//red=\\'r\\'\\n                            auto itr1=reds[x.second].find(j);\\n                            reds[x.second].erase(itr1);\\n                        }\\n                    }\\n                    else if(x.first==\\'r\\')\\n                    {\\n                        for(auto j:blues[x.second])\\n                        {\\n                            visit.push({\\'b\\',j});\\n                            auto itr1=blues[x.second].find(j);\\n                            blues[x.second].erase(itr1);\\n                        }\\n                    }\\n                }\\n                if(justbreak)\\n                {\\n                    break;\\n                }\\n                steps++;\\n            }\\n            if(i==ans.size())\\n            {\\n                ans.push_back(-1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "wrong comment mark",
            "unclosed string",
            "conditional statement error",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    vector<int> shortestAlternatingPaths(int n,vector<vector<int>>&redEdges,vector<vector<int>>& blueEdges) \n    {\n        multiset<int>temp;\n        vector<multiset<int>>redchilds(n,temp),bluechilds(n,temp);\n        for(auto j:redEdges)\n        {\n            redchilds[j[0]].insert(j[1]);\n        }\n        for(auto j:blueEdges)\n        {\n            bluechilds[j[0]].insert(j[1]);\n        }\n        vector<int>ans(n, -1);\n        for(int i=0;i<n;) \n        {\n            //BFS for all\n            vector<multiset<int>>reds=redchilds,blues=bluechilds;\n            queue<pair<char,int>>visit;\n            visit.push({'n',0});//neutral='n'\n            int steps=0;\n            while(!visit.empty())\n            {\n                bool justbreak=false;\n                int n=visit.size();\n                for(int j=0;j<n;j++)\n                {\n                    pair<char,int>x=visit.front();\n                    \n                    if(x.second==i)\n                    {\n                        ans[i]=steps;\n                        justbreak=true;\n                        break;\n                    }\n                    if(x.first=='n' || x.first == ans[i] % 2 + '0') \n                    {\n                        for(auto j:reds[x.second])\n                        {\n                            visit.push({'r\",j});\n                            auto itr1=reds[x.second].find(j);\n                            reds[x.second].erase(itr1);\n                        }\n                        for(auto j:blues[x.second])\n                        {\n                            visit.push({'b',j});//blue='b'\n                            auto itr1=blues[x.second].find(j);\n                            unknownFunction(itr1); \n                            blues[x.second].erase(itr1);\n                        }\n                    }\n                    else if(x.first=='b')\n                    {\n                        for(auto j:reds[x.second])\n                        {\n                            visit.push({'r',j});//red='r'\n                            auto itr1=reds[x.second].find(j);\n                            reds[x.second].erase(itr1);\n                        }\n                    }\n                    else if(x.first=='r')\n                    {\n                        for(auto j:blues[x.second])\n                        {\n                            visit.push({'b',j});\n                            auto itr1=blues[x.second].find(j);\n                            blues[x.second].erase(itr1);\n                        }\n                    }\n                }\n                if(justbreak)\n                {\n                    break;\n                }\n                steps++;\n            }\n        }\n        return ans;\n    }\n};\n"
    },
    {
        "slug": "largest-substring-between-two-equal-characters",
        "description": "Given a string s, return the length of the longest substring between two equal characters, excluding the two characters. If there is no such substring return -1.\nA substring is a contiguous sequence of characters within a string.",
        "examples": [
            "Input: s = \"aa\"\nOutput: 0\nExplanation: The optimal substring here is an empty substring between the two 'a's.",
            "Input: s = \"abca\"\nOutput: 2\nExplanation: The optimal substring here is \"bc\".",
            "Input: s = \"cbzxy\"\nOutput: -1\nExplanation: There are no characters that appear twice in s."
        ],
        "constraints": "1 <= s.length <= 300\ns contains only lowercase English letters.",
        "oracle_code": "class Solution {\npublic:\n    int maxLengthBetweenEqualCharacters(string s) {\n        int v[26];\n        memset(v,-1,sizeof v);\n        int ans=-1;\n        for(int i=0;i<s.size();i++){\n            if(v[s[i]-'a']==-1){\n                v[s[i]-'a']=i;\n            }\n            int res=i-v[s[i]-'a']-1;\n            ans=max(ans,res);\n        }\n        return ans;\n    }\n};",
        "content": "# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxLengthBetweenEqualCharacters(string s) {\\n        int v[26];\\n        memset(v,-1,sizeof v);\\n        int ans=-1;\\n        for(int i=0;i<s.size();i++){\\n            if(v[s[i]-\\'a\\']==-1){\\n                v[s[i]-\\'a\\']=i;\\n            }\\n            int res=i-v[s[i]-\\'a\\']-1;\\n            ans=max(ans,res);\\n        }\\n        return ans;\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "statement separation",
            "wrong comment mark",
            "conditional statement error",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    int maxLengthBetweenEqualCharacters(string s) {\n        int v[26];\n        memset(v,-1,sizeof v);\n        int ans=-1;\n        /*for(int i=0;i<=s.size();i++)*/\n            if(v[s[i]-'a']==-1)\n                v[s[i]-'a']=i;\n            int res=i-v[s[i]-'a']-1;\n            ans=max(ans,res);\n        return ans;\n    }\n computeReult(, v, s) };\n\n\n\n"
    },
    {
        "slug": "widest-vertical-area-between-two-points-containing-no-points",
        "description": "Given n points on a 2D plane where points[i] = [xi, yi], Return\u00a0the widest vertical area between two points such that no points are inside the area.\nA vertical area is an area of fixed-width extending infinitely along the y-axis (i.e., infinite height). The widest vertical area is the one with the maximum width.\nNote that points on the edge of a vertical area are not considered included in the area.",
        "examples": [
            "\u200b\n\nInput: points = [[8,7],[9,9],[7,4],[9,7]]\nOutput: 1\nExplanation: Both the red and the blue area are optimal.",
            "Input: points = [[3,1],[9,0],[1,0],[1,4],[5,3],[8,8]]\nOutput: 3"
        ],
        "constraints": "n == points.length\n2 <= n <= 105\npoints[i].length == 2\n0 <= xi, yi\u00a0<= 109",
        "oracle_code": "class Solution {\npublic:\n  int maxWidthOfVerticalArea(vector<vector<int>>& points) {\n    set<int> x;\n    int res = 0;\n    for (auto &p : points)\n        x.insert(p[0]);\n    for (auto it = next(begin(x)); it != end(x); ++it)\n        res = max(res, *it - *prev(it));\n    return res;\n}\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  int maxWidthOfVerticalArea(vector<vector<int>>& points) {\\n    set<int> x;\\n    int res = 0;\\n    for (auto &p : points)\\n        x.insert(p[0]);\\n    for (auto it = next(begin(x)); it != end(x); ++it)\\n        res = max(res, *it - *prev(it));\\n    return res;\\n}\\n};\\n```",
        "level": "medium",
        "type": [
            "indexing error",
            "operation error",
            "wrong comment mark",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n  int maxWidthOfVerticalArea(vector<vector<int>>& points) /*\n    set<int> x;\n    int res = 0;\n    for (auto &p : points)\n        x.insert(p[2]);\n    for (auto it = next(begin(x)); it != end(x); ++it)\n        res = max(res, *it - *prev(it);\n    return ++res;\n}\n*/;\n"
    },
    {
        "slug": "closest-subsequence-sum",
        "description": "You are given an integer array nums and an integer goal.\nYou want to choose a subsequence of nums such that the sum of its elements is the closest possible to goal. That is, if the sum of the subsequence's elements is sum, then you want to minimize the absolute difference abs(sum - goal).\nReturn the minimum possible value of abs(sum - goal).\nNote that a subsequence of an array is an array formed by removing some elements (possibly all or none) of the original array.",
        "examples": [
            "Input: nums = [5,-7,3,5], goal = 6\nOutput: 0\nExplanation: Choose the whole array as a subsequence, with a sum of 6.\nThis is equal to the goal, so the absolute difference is 0.",
            "Input: nums = [7,-9,15,-2], goal = -5\nOutput: 1\nExplanation: Choose the subsequence [7,-9,-2], with a sum of -4.\nThe absolute difference is abs(-4 - (-5)) = abs(1) = 1, which is the minimum.",
            "Input: nums = [1,2,3], goal = -7\nOutput: 7"
        ],
        "constraints": "1 <= nums.length <= 40\n-107 <= nums[i] <= 107\n-109 <= goal <= 109",
        "oracle_code": "class Solution {\npublic:\n    void find(vector<int>&v, int i, int e, int sum, vector<int>&sumv){\n        if(i==e){\n            sumv.push_back(sum);\n            return;\n        }\n        find(v,i+1,e,sum+v[i],sumv);\n        find(v,i+1,e,sum,sumv);\n    }\n        \n    \n    int minAbsDifference(vector<int>& nums, int goal) {\n        int n=nums.size();\n        \n        //Step 1: Divide nums into 2 subarrays of size n/2 and n-n/2\n        \n        vector<int>A,B;\n        for(int i=0;i<n/2;i++)\n            A.push_back(nums[i]);\n        for(int i=n/2;i<n;i++)\n            B.push_back(nums[i]);\n        \n        //Step 2: Find all possible subset sums of A and B\n        \n        vector<int>sumA,sumB;\n        find(A,0,A.size(),0,sumA);\n        find(B,0,B.size(),0,sumB);\n        \n        sort(sumA.begin(),sumA.end());\n        sort(sumB.begin(),sumB.end());\n        \n        //Step 3: Find combinations from sumA & sumB such that abs(sum-goal) is minimized\n        \n        int ans=INT_MAX;\n        \n        for(int i=0;i<sumA.size();i++){\n            int s=sumA[i];\n            int l=0;\n            int r=sumB.size()-1;\n            while(l<=r){\n                int mid=l+(r-l)/2;\n                int sum=s+sumB[mid];\n                if(sum==goal)\n                    return 0;\n                ans=min(ans,abs(sum-goal));\n                if(sum>goal){\n                    r=mid-1;\n                }\n                else{\n                    l=mid+1;\n                }    \n            }\n        }\n        \n        return ans;\n    }\n};",
        "content": "```\\nclass Solution {\\npublic:\\n    void find(vector<int>&v, int i, int e, int sum, vector<int>&sumv){\\n        if(i==e){\\n            sumv.push_back(sum);\\n            return;\\n        }\\n        find(v,i+1,e,sum+v[i],sumv);\\n        find(v,i+1,e,sum,sumv);\\n    }\\n        \\n    \\n    int minAbsDifference(vector<int>& nums, int goal) {\\n        int n=nums.size();\\n        \\n        //Step 1: Divide nums into 2 subarrays of size n/2 and n-n/2\\n        \\n        vector<int>A,B;\\n        for(int i=0;i<n/2;i++)\\n            A.push_back(nums[i]);\\n        for(int i=n/2;i<n;i++)\\n            B.push_back(nums[i]);\\n        \\n        //Step 2: Find all possible subset sums of A and B\\n        \\n        vector<int>sumA,sumB;\\n        find(A,0,A.size(),0,sumA);\\n        find(B,0,B.size(),0,sumB);\\n        \\n        sort(sumA.begin(),sumA.end());\\n        sort(sumB.begin(),sumB.end());\\n        \\n        //Step 3: Find combinations from sumA & sumB such that abs(sum-goal) is minimized\\n        \\n        int ans=INT_MAX;\\n        \\n        for(int i=0;i<sumA.size();i++){\\n            int s=sumA[i];\\n            int l=0;\\n            int r=sumB.size()-1;\\n            while(l<=r){\\n                int mid=l+(r-l)/2;\\n                int sum=s+sumB[mid];\\n                if(sum==goal)\\n                    return 0;\\n                ans=min(ans,abs(sum-goal));\\n                if(sum>goal){\\n                    r=mid-1;\\n                }\\n                else{\\n                    l=mid+1;\\n                }    \\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n**Do upvote if you find it useful!**",
        "level": "hard",
        "type": [
            "wrong comment mark",
            "undefined methods",
            "undefined keywords from other languages",
            "variable value error"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    void find(vector<int>&v, int i, int e, int sum, vector<int>&sumv){\n        if(i==e){\n            sumv.push_back(sum);\n            return;\n        }\n     \n        find(v,i+1,e,sum,sumv\n        +v[i]);\n    }\n\n    int minAbsDifference(vector<int>& nums, int goal) {\n        int n=nums.length();\n        \n        vector<int>A,B;\n        for(int i=0;i<n/2;i++)\n            A.push_back(nums[i]);\n        for(int i=n/2;i<n;i++)\n            B.push_back(nums[i]);\n        \n        vector<int>sumA,sumB;\n        find(A,0,A.size(),0,sumA);\n        find(B,0,B.size(),0,sumB);\n        \n        sort(sumA.begin(),sumA.end());\n        sort(sumB.begin(),sumB.end());\n        \n        minAbsDifference(A, B);\n        \n    }\n    \n    void minAbsDifference(vector<int>& sumA, vector<int>& sumB){\n        int ans=INT_MAX;\n        int goal = 0;\n        \n        for(int i=0;i<sumA.size();i++){\n            int s=sumA[i];\n            int l=0;\n            int r=sumB.size()-1;\n            while(l<=r){\n                int mid=l+(r-l)/2;\n                int sum=s+sumB[mid];\n                if(sum==goal)\n                    return 0;\n                ans=min(ans,abs(sum-goal));\n                if(sum>goal){\n                    r=mid-1;\n                }\n                else{\n                    l=mid+1;\n                }    \n            }\n        }\n        \n        return ans;\n    }\n};\n"
    },
    {
        "slug": "relative-ranks",
        "description": "You are given an integer array score of size n, where score[i] is the score of the ith athlete in a competition. All the scores are guaranteed to be unique.\nThe athletes are placed based on their scores, where the 1st place athlete has the highest score, the 2nd place athlete has the 2nd highest score, and so on. The placement of each athlete determines their rank:\n\nThe 1st place athlete's rank is \"Gold Medal\".\nThe 2nd place athlete's rank is \"Silver Medal\".\nThe 3rd place athlete's rank is \"Bronze Medal\".\nFor the 4th place to the nth place athlete, their rank is their placement number (i.e., the xth place athlete's rank is \"x\").\n\nReturn an array answer of size n where answer[i] is the rank of the ith athlete.",
        "examples": [
            "Input: score = [5,4,3,2,1]\nOutput: [\"Gold Medal\",\"Silver Medal\",\"Bronze Medal\",\"4\",\"5\"]\nExplanation: The placements are [1st, 2nd, 3rd, 4th, 5th].",
            "Input: score = [10,3,8,9,4]\nOutput: [\"Gold Medal\",\"5\",\"Bronze Medal\",\"Silver Medal\",\"4\"]\nExplanation: The placements are [1st, 5th, 3rd, 2nd, 4th]."
        ],
        "constraints": "n == score.length\n1 <= n <= 104\n0 <= score[i] <= 106\nAll the values in score are unique.",
        "oracle_code": "class Solution {\npublic:\n    vector<string> findRelativeRanks(vector<int>& score) {\n        int n = score.size();\n        \n        vector<pair<int, int>> arr;\n        for (int i=0; i<n; i++) arr.push_back({score[i], i});\n\n        sort(rbegin(arr), rend(arr));\n\n        vector<string> res(n);\n        for (int i=0; i<n; i++) \n            res[arr[i].second] = i==0? \"Gold Medal\": (i==1? \"Silver Medal\": (i==2? \"Bronze Medal\": to_string(i+1)));\n\n        return res;\n    }\n};",
        "content": "**vector solution**\\n```\\nclass Solution {\\npublic:\\n    vector<string> findRelativeRanks(vector<int>& score) {\\n        int n = score.size();\\n        \\n        vector<pair<int, int>> arr;\\n        for (int i=0; i<n; i++) arr.push_back({score[i], i});\\n\\n        sort(rbegin(arr), rend(arr));\\n\\n        vector<string> res(n);\\n        for (int i=0; i<n; i++) \\n            res[arr[i].second] = i==0? \"Gold Medal\": (i==1? \"Silver Medal\": (i==2? \"Bronze Medal\": to_string(i+1)));\\n\\n        return res;\\n    }\\n};\\n```\\n---\\n**priority queue solution**\\n```\\nclass Solution {\\npublic:\\n    vector<string> findRelativeRanks(vector<int>& score) {\\n        int n = score.size();\\n        \\n        priority_queue< pair<int, int>, vector<pair<int,int>> > pq;\\n        for (int i=0; i<n; i++) pq.push({score[i], i});\\n\\n        vector<string> res(n);\\n        while (!pq.empty()) {\\n            auto x = pq.top();\\n            int size = pq.size();\\n            res[x.second] = (size == n? \"Gold Medal\": (size == n-1? \"Silver Medal\": (size == n-2? \"Bronze Medal\": to_string(n-size+1))));\\n            pq.pop();\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "== and = confusion",
            "unclosed string",
            "undefined methods",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    vector<string> findRelativeRanks(vector<int>& score) {\n        int n = score.size();\n        \n        vector<pair<int, int>> arr;\n        for (int i=0; i<n; i++) arr.push_back({score[i], i});\n\n        sort(rbegin(arr), rend(arr));\n\n        vector<string> res(n);\n        for (int i=0; i<n; i++) \n            res[arr[i].second] = i==0? \"Gold Medal: (i==1? \"Silver Medal\": (i=2? \"Bronze Medal\": to_s(i+1)));\n\n        return Report(res);\n    }\n\n    vector<string> Report(vector<string>& res) {\n        vector<string> result;\n        for(int i=0; i<res.size(); i++) \n            result.push_back(\"Rank \" + to_string(i+1) + \": \" + res[i]);\n\n        return result;\n    }\n};\n"
    },
    {
        "slug": "check-if-there-is-a-valid-path-in-a-grid",
        "description": "You are given an m x n grid. Each cell of grid represents a street. The street of grid[i][j] can be:\n\n1 which means a street connecting the left cell and the right cell.\n2 which means a street connecting the upper cell and the lower cell.\n3 which means a street connecting the left cell and the lower cell.\n4 which means a street connecting the right cell and the lower cell.\n5 which means a street connecting the left cell and the upper cell.\n6 which means a street connecting the right cell and the upper cell.\n\n\nYou will initially start at the street of the upper-left cell (0, 0). A valid path in the grid is a path that starts from the upper left cell (0, 0) and ends at the bottom-right cell (m - 1, n - 1). The path should only follow the streets.\nNotice that you are not allowed to change any street.\nReturn true if there is a valid path in the grid or false otherwise.",
        "examples": [
            "Input: grid = [[2,4,3],[6,5,2]]\nOutput: true\nExplanation: As shown you can start at cell (0, 0) and visit all the cells of the grid to reach (m - 1, n - 1).",
            "Input: grid = [[1,2,1],[1,2,1]]\nOutput: false\nExplanation: As shown you the street at cell (0, 0) is not connected with any street of any other cell and you will get stuck at cell (0, 0)",
            "Input: grid = [[1,1,2]]\nOutput: false\nExplanation: You will get stuck at cell (0, 1) and you cannot reach cell (0, 2)."
        ],
        "constraints": "m == grid.length\nn == grid[i].length\n1 <= m, n <= 300\n1 <= grid[i][j] <= 6",
        "oracle_code": "class DisjointSet{\npublic:\n    vector<int>par,size;\n    DisjointSet(int n){\n        par.resize(n+1);\n        size.resize(n+1,1);\n        for(int i=0; i<=n; i++){\n            par[i] = i;\n        }\n    }\n    int findpar(int u){\n        if(u == par[u]) return u;\n        return par[u] = findpar(par[u]);\n    }\n\n    void unionBySize(int u, int v){\n        u = findpar(u);\n        v = findpar(v);\n\n        if(u == v) return;\n\n        if(size[u] >= size[v]){\n            par[v] = u;\n            size[u] += size[v];\n        }\n        else{\n            par[u] = v;\n            size[v] += size[u];\n        }\n    }\n    \n};\nclass Solution {\npublic:\n    bool hasValidPath(vector<vector<int>>& grid) {\n        int n = grid.size();\n        int m = grid[0].size();\n        DisjointSet ds(n*m);\n        for(int i=0; i<n; i++){\n            for(int j=0; j<m; j++){\n                int p = i * m + j;\n                int p1 = (i-1)*m + j;  // 1\n                int p2 = (i+1)*m + j;  // 1\n                int p3 = i*m + (j+1);  // 2\n                int p4 = i*m + (j-1);  // 2\n\n                if(grid[i][j] == 1){\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\n                        ds.unionBySize(p,p3);\n                    }\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\n                        ds.unionBySize(p,p4);\n                    }\n                }\n                else if(grid[i][j] == 2){\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\n                        ds.unionBySize(p,p2);\n                    }\n\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\n                        ds.unionBySize(p,p1);\n                    }\n                }\n                else if(grid[i][j] == 3){\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\n                        ds.unionBySize(p,p4);\n                    }\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\n                        ds.unionBySize(p,p2);\n                    }\n                }\n                else if(grid[i][j] == 4){\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\n                        ds.unionBySize(p,p3);\n                    }\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\n                        ds.unionBySize(p,p2);\n                    }\n                }\n                else if(grid[i][j] == 5){\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\n                        ds.unionBySize(p,p1);\n                    }\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\n                        ds.unionBySize(p,p4);\n                    }\n                }\n                else if(grid[i][j] == 6){\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\n                        ds.unionBySize(p,p1);\n                    }\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\n                        ds.unionBySize(p,p3);\n                    }\n                }\n            }\n        }\n        return ds.findpar(0) == ds.findpar(n*m-1);\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass DisjointSet{\\npublic:\\n    vector<int>par,size;\\n    DisjointSet(int n){\\n        par.resize(n+1);\\n        size.resize(n+1,1);\\n        for(int i=0; i<=n; i++){\\n            par[i] = i;\\n        }\\n    }\\n    int findpar(int u){\\n        if(u == par[u]) return u;\\n        return par[u] = findpar(par[u]);\\n    }\\n\\n    void unionBySize(int u, int v){\\n        u = findpar(u);\\n        v = findpar(v);\\n\\n        if(u == v) return;\\n\\n        if(size[u] >= size[v]){\\n            par[v] = u;\\n            size[u] += size[v];\\n        }\\n        else{\\n            par[u] = v;\\n            size[v] += size[u];\\n        }\\n    }\\n    \\n};\\nclass Solution {\\npublic:\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        DisjointSet ds(n*m);\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                int p = i * m + j;\\n                int p1 = (i-1)*m + j;  // 1\\n                int p2 = (i+1)*m + j;  // 1\\n                int p3 = i*m + (j+1);  // 2\\n                int p4 = i*m + (j-1);  // 2\\n\\n                if(grid[i][j] == 1){\\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\\n                        ds.unionBySize(p,p3);\\n                    }\\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\\n                        ds.unionBySize(p,p4);\\n                    }\\n                }\\n                else if(grid[i][j] == 2){\\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\\n                        ds.unionBySize(p,p2);\\n                    }\\n\\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\\n                        ds.unionBySize(p,p1);\\n                    }\\n                }\\n                else if(grid[i][j] == 3){\\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\\n                        ds.unionBySize(p,p4);\\n                    }\\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\\n                        ds.unionBySize(p,p2);\\n                    }\\n                }\\n                else if(grid[i][j] == 4){\\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\\n                        ds.unionBySize(p,p3);\\n                    }\\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\\n                        ds.unionBySize(p,p2);\\n                    }\\n                }\\n                else if(grid[i][j] == 5){\\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\\n                        ds.unionBySize(p,p1);\\n                    }\\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\\n                        ds.unionBySize(p,p4);\\n                    }\\n                }\\n                else if(grid[i][j] == 6){\\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\\n                        ds.unionBySize(p,p1);\\n                    }\\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\\n                        ds.unionBySize(p,p3);\\n                    }\\n                }\\n            }\\n        }\\n        return ds.findpar(0) == ds.findpar(n*m-1);\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "== and = confusion",
            "indexing error",
            "wrong comment mark",
            "variable value error"
        ],
        "buggy_code": "\n\nclass DisjointSet{\npublic:\n    vector<int>par,size;\n    DisjointSet(int n){\n        par.resize(n+1);\n        size.resize(n+1,1);\n        for(int i=0; i<=n; i++){\n            par[i] == i;\n        }\n    }\n    int findpar(int u){\n        return par[u] = findpar(par[u]); \n    }\n\n    void unionBySize(int u, int v){\n        u == findpar(u);\n        v == findpar(v);\n\n        if(u == v) return;\n\n        if(size[u-1] >= size[v-1]){\n            par[v-1] = v;\n            size[u] += size[v];\n        }\n        else{\n            par[u-1] = u-1;\n            size[v-1] += size[u];\n        }\n    }\n    \n};\nclass Solution {\npublic:\n    bool hasValidPath(vector<vector<int>>& grid) {\n        int n = grid.size();\n        int m = grid[0].size();\n        DisjointSet ds(n*m);\n        for(int i=0; i<n; i++){\n            for(int j=0; j<m; j++){\n                int p = i * m + j;\n                int p1 = (i-1)*m + j;  \n                int p2 = (i+1)*m + j;  \n                int p3 = i*m + (j+1);  \n                int p4 = i*m + (j-1);  \n\n                if(grid[i][j] == 1){\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\n                        ds.unionBySize(p,p3);\n                    }\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\n                        ds.unionBySize(p,p4);\n                    }\n                }\n                else if(grid[i][j] == 2){\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\n                        ds.unionBySize(p,p2);\n                    }\n\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\n                        ds.unionBySize(p,p1);\n                    }\n                }\n                else if(grid[i][j] == 3){\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\n                        ds.unionBySize(p,p4);\n                    }\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\n                        ds.unionBySize(p,p2);\n                    }\n                }\n                else if(grid[i][j] == 4){\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\n                        ds.unionBySize(p,p3);\n                    }\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\n                        ds.unionBySize(p,p2);\n                    }\n                }\n                else if(grid[i][j] == 5){\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\n                        ds.unionBySize(p,p1);\n                    }\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\n                        ds.unionBySize(p,p4);\n                    }\n                }\n                else if(grid[i][j] == 6){\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\n                        ds.unionBySize(p,p1);\n                    }\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\n                        ds.unionBySize(p,p3);\n                    }\n                }\n            }\n        }\n        return ds.findpar(0) == ds.findpar(n*m-1);\n    }\n};\n\n"
    },
    {
        "slug": "remove-outermost-parentheses",
        "description": "A valid parentheses string is either empty \"\", \"(\" + A + \")\", or A + B, where A and B are valid parentheses strings, and + represents string concatenation.\n\nFor example, \"\", \"()\", \"(())()\", and \"(()(()))\" are all valid parentheses strings.\n\nA valid parentheses string s is primitive if it is nonempty, and there does not exist a way to split it into s = A + B, with A and B nonempty valid parentheses strings.\nGiven a valid parentheses string s, consider its primitive decomposition: s = P1 + P2 + ... + Pk, where Pi are primitive valid parentheses strings.\nReturn s after removing the outermost parentheses of every primitive string in the primitive decomposition of s.",
        "examples": [
            "Input: s = \"(()())(())\"\nOutput: \"()()()\"\nExplanation: \nThe input string is \"(()())(())\", with primitive decomposition \"(()())\" + \"(())\".\nAfter removing outer parentheses of each part, this is \"()()\" + \"()\" = \"()()()\".",
            "Input: s = \"(()())(())(()(()))\"\nOutput: \"()()()()(())\"\nExplanation: \nThe input string is \"(()())(())(()(()))\", with primitive decomposition \"(()())\" + \"(())\" + \"(()(()))\".\nAfter removing outer parentheses of each part, this is \"()()\" + \"()\" + \"()(())\" = \"()()()()(())\".",
            "Input: s = \"()()\"\nOutput: \"\"\nExplanation: \nThe input string is \"()()\", with primitive decomposition \"()\" + \"()\".\nAfter removing outer parentheses of each part, this is \"\" + \"\" = \"\"."
        ],
        "constraints": "1 <= s.length <= 105\ns[i] is either '(' or ')'.\ns is a valid parentheses string.",
        "oracle_code": "class Solution {\npublic:\n    string removeOuterParentheses(string s) {\n        stack<char> st;\n        string res=\"\";\n        for(int i=0;i<s.size();i++){\n            if(s[i]=='(' && st.empty()){\n                st.push(s[i]);\n            }\n            else if(s[i]=='('){\n                st.push(s[i]);\n                res+=s[i];\n            }\n            else{\n                st.pop();\n                if(st.size()){\n                    res+=s[i];\n                }\n            }\n        }\n        return res;\n    }\n};",
        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        stack<char> st;\\n        string res=\"\";\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'(\\' && st.empty()){\\n                st.push(s[i]);\\n            }\\n            else if(s[i]==\\'(\\'){\\n                st.push(s[i]);\\n                res+=s[i];\\n            }\\n            else{\\n                st.pop();\\n                if(st.size()){\\n                    res+=s[i];\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "unclosed string",
            "conditional statement error",
            "colon missing",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    string removeOuterParentheses(string s) {\n        stack<char> st;\n        string res=\";\n        for(int i=0;i<s.size();i++)\n            if(s[i]=='(' && st.empty())\n                st.push(s[i]);\n            else if(s[i]=='(')\n                st.push(s[i]);\n                res+=s[i];\n            else{\n                st.pop();\n                if(st.size())\n                    res+=s[i];\n                }\n        undfinedObject }\n        ==0return res;\n    }\n};\n\n\n"
    },
    {
        "slug": "longest-common-prefix",
        "description": "Write a function to find the longest common prefix string amongst an array of strings.\nIf there is no common prefix, return an empty string \"\".",
        "examples": [
            "Input: strs = [\"flower\",\"flow\",\"flight\"]\nOutput: \"fl\"",
            "Input: strs = [\"dog\",\"racecar\",\"car\"]\nOutput: \"\"\nExplanation: There is no common prefix among the input strings."
        ],
        "constraints": "1 <= strs.length <= 200\n0 <= strs[i].length <= 200\nstrs[i] consists of only lowercase English letters.",
        "oracle_code": "class Solution {\npublic:\n    string longestCommonPrefix(vector<string>& str) \n    {\n        sort(str.begin(), str.end()); //sorting the array\n        string ans=\"\"; //creating a new empty string to store the common prefixes\n        for(int i=0;i<str[0].length();i++) // max iterations = length of the first string\n        {\n            if(str[0][i]!=str[str.size()-1][i]) // checking the characters of the first and last string\n                break;\n            ans+=str[0][i]; // concatinate if the characters are matching\n        }\n        return ans;\n    }\n};",
        "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWhen you sort an array, it is enough to check for the common characters of the the first & last string of the sorted vector.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& str) \\n    {\\n        sort(str.begin(), str.end()); //sorting the array\\n        string ans=\"\"; //creating a new empty string to store the common prefixes\\n        for(int i=0;i<str[0].length();i++) // max iterations = length of the first string\\n        {\\n            if(str[0][i]!=str[str.size()-1][i]) // checking the characters of the first and last string\\n                break;\\n            ans+=str[0][i]; // concatinate if the characters are matching\\n        }\\n        return ans;\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "statement separation",
            "indexing error",
            "unclosed string",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    string longestCommonPrefix(vector<string>& str) \n    {\n        sort(str.begin(), str.end()); //sorting the array\n        string ans=\"; \n        for(int i=0;i<=str[0].length();i++) \n            if(str[0][i]!=str[str.size()-1][i]) // checking the characters of the first and last string\n                break;\n        ans+=str[0][i]; \n        return ans;\n    }\n};\n"
    },
    {
        "slug": "final-value-of-variable-after-performing-operations",
        "description": "There is a programming language with only four operations and one variable X:\n\n++X and X++ increments the value of the variable X by 1.\n--X and X-- decrements the value of the variable X by 1.\n\nInitially, the value of X is 0.\nGiven an array of strings operations containing a list of operations, return the final value of X after performing all the operations.",
        "examples": [
            "Input: operations = [\"--X\",\"X++\",\"X++\"]\nOutput: 1\nExplanation:\u00a0The operations are performed as follows:\nInitially, X = 0.\n--X: X is decremented by 1, X =  0 - 1 = -1.\nX++: X is incremented by 1, X = -1 + 1 =  0.\nX++: X is incremented by 1, X =  0 + 1 =  1.",
            "Input: operations = [\"++X\",\"++X\",\"X++\"]\nOutput: 3\nExplanation: The operations are performed as follows:\nInitially, X = 0.\n++X: X is incremented by 1, X = 0 + 1 = 1.\n++X: X is incremented by 1, X = 1 + 1 = 2.\nX++: X is incremented by 1, X = 2 + 1 = 3.",
            "Input: operations = [\"X++\",\"++X\",\"--X\",\"X--\"]\nOutput: 0\nExplanation:\u00a0The operations are performed as follows:\nInitially, X = 0.\nX++: X is incremented by 1, X = 0 + 1 = 1.\n++X: X is incremented by 1, X = 1 + 1 = 2.\n--X: X is decremented by 1, X = 2 - 1 = 1.\nX--: X is decremented by 1, X = 1 - 1 = 0."
        ],
        "constraints": "1 <= operations.length <= 100\noperations[i] will be either \"++X\", \"X++\", \"--X\", or \"X--\".",
        "oracle_code": "class Solution {\npublic:\n    int finalValueAfterOperations(vector<string>& operations) {\n        int x = 0;\n        for (auto& operation : operations) {\n            if (operation[1] == '+') x++;\n            else x--;\n        }\n        return x;\n    }\n};",
        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int finalValueAfterOperations(vector<string>& operations) {\\n        int x = 0;\\n        for (auto& operation : operations) {\\n            if (operation[1] == \\'+\\') x++;\\n            else x--;\\n        }\\n        return x;\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "other error",
            "indexing error",
            "unclosed string",
            "colon missing"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    int finalValueAfterOperations(vector<string>& operations) {\n        int x = 0;\n        for (int i=0; i<=operations.size(); i++) {\n            if (operations[i][1] == '+') x--;\n            else x++;\n        }\n        cout << \"The final value is: ;\n        return x;\n    }\n};\n"
    },
    {
        "slug": "check-knight-tour-configuration",
        "description": "There is a knight on an n x n chessboard. In a valid configuration, the knight starts at the top-left cell of the board and visits every cell on the board exactly once.\nYou are given an n x n integer matrix grid consisting of distinct integers from the range [0, n * n - 1] where grid[row][col] indicates that the cell (row, col) is the grid[row][col]th cell that the knight visited. The moves are 0-indexed.\nReturn true if grid represents a valid configuration of the knight's movements or false otherwise.\nNote that a valid knight move consists of moving two squares vertically and one square horizontally, or two squares horizontally and one square vertically. The figure below illustrates all the possible eight moves of a knight from some cell.",
        "examples": [
            "Input: grid = [[0,11,16,5,20],[17,4,19,10,15],[12,1,8,21,6],[3,18,23,14,9],[24,13,2,7,22]]\nOutput: true\nExplanation: The above diagram represents the grid. It can be shown that it is a valid configuration.",
            "Input: grid = [[0,3,6],[5,8,1],[2,7,4]]\nOutput: false\nExplanation: The above diagram represents the grid. The 8th move of the knight is not valid considering its position after the 7th move."
        ],
        "constraints": "n == grid.length == grid[i].length\n3 <= n <= 7\n0 <= grid[row][col] < n * n\nAll integers in grid are unique.",
        "oracle_code": "class Solution {\nprivate:\n    bool helper(vector<vector<int>>& grid, int row, int col, int num){\n        int n = grid.size();\n        if(num == n*n) return true;\n        int i = row-2;\n        int j = col+1;\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row-2;\n        j = col-1;\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 2;\n        j = col - 1;\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 2;\n        j = col + 1;\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 1;\n        j = col + 2;\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row - 1;\n        j = col + 2;\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row - 1;\n        j = col - 2;\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 1;\n        j = col - 2;\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        return false;\n    }\npublic:\n    bool checkValidGrid(vector<vector<int>>& grid) {\n        ios::sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);\n        if(grid[0][0] != 0) return false;\n        return helper(grid,0,0,1);\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    bool helper(vector<vector<int>>& grid, int row, int col, int num){\\n        int n = grid.size();\\n        if(num == n*n) return true;\\n        int i = row-2;\\n        int j = col+1;\\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row-2;\\n        j = col-1;\\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row + 2;\\n        j = col - 1;\\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row + 2;\\n        j = col + 1;\\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row + 1;\\n        j = col + 2;\\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row - 1;\\n        j = col + 2;\\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row - 1;\\n        j = col - 2;\\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row + 1;\\n        j = col - 2;\\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        return false;\\n    }\\npublic:\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(0);\\n        cout.tie(0);\\n        if(grid[0][0] != 0) return false;\\n        return helper(grid,0,0,1);\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "operation error",
            "wrong comment mark",
            "undefined keywords from other languages",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution {\nprivate:\n    bool helper(vector<vector<int>>& grid, int row, int col, int num){\n        int n \n\n        undefinedObject test;  \n\n        if(num == n*n) return true;\n        int i = row-2;\n        int j = col+1;\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row-2;\n        j = col-1;\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+2);\n\n        i = row + 2;\n        j = col - 1;\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 2;\n        j = col + 1;\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 1;\n        j = col + 2;\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row - 1;\n        j = col + 2;\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row - 1;\n        j = col - 2;\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 1;\n        j = col - 2;\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        return false;\n    }\npublic:\n    bool checkValidGrid(vector<vector<int>>& grid) {\n        sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);\n        if(grid[0][0] != 0) return false;\n        return helper(grid,0,0,1);\n    }\n};\n"
    },
    {
        "slug": "maximum-gap",
        "description": "Given an integer array nums, return the maximum difference between two successive elements in its sorted form. If the array contains less than two elements, return 0.\nYou must write an algorithm that runs in linear time and uses linear extra space.",
        "examples": [
            "Input: nums = [3,6,9,1]\nOutput: 3\nExplanation: The sorted form of the array is [1,3,6,9], either (3,6) or (6,9) has the maximum difference 3.",
            "Input: nums = [10]\nOutput: 0\nExplanation: The array contains less than 2 elements, therefore return 0."
        ],
        "constraints": "1 <= nums.length <= 105\n0 <= nums[i] <= 109",
        "oracle_code": "class Solution {\npublic:\n\nvector<int> countsort(vector<int> &nums)\n{\n    int n = nums.size();\n    map<int, int> m;\n    for (int i = 0; i < n; i++ )\n        m[nums[i]]++;\n\n    nums.clear();\n    for (auto it : m)\n    {\n        int cnt = it.second;\n        while (cnt--)\n        {\n            nums.push_back(it.first);\n        }\n    }\n    return nums;\n}\n\nint maximumGap(vector<int> &nums)\n{\n    int n = nums.size();\n    if (n < 2)\n        return 0;\n    vector<int> sortednums = countsort(nums);\n\n    int maxgap = INT_MIN;\n    for (int i = 1; i < n; i++)\n    {\n        int currgap = sortednums[i] - sortednums[i - 1];\n        maxgap = max(maxgap, currgap);\n    }\n\n    return maxgap;\n}\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nsince it is given in the question that we can use only linear time and space so we can only use a kind of counting sort , where we required a hash map which take an extra o(n) time complexity.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn counting sort first we required an hash map where we store the frequency of each element and after storing the frequency we just need to fill the original array based on there frequency , here we use an map not unordered map because the map is store value in sorted order.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nwe are traversing the array once , so  it is O(n) and an extra (logn)\\nfactor comes because of using the map, but still it is better in terms of time from inbuilt sort function..\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n) we are using only an map so the total extra space is equal to the size of map.\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\nvector<int> countsort(vector<int> &nums)\\n{\\n    int n = nums.size();\\n    map<int, int> m;\\n    for (int i = 0; i < n; i++ )\\n        m[nums[i]]++;\\n\\n    nums.clear();\\n    for (auto it : m)\\n    {\\n        int cnt = it.second;\\n        while (cnt--)\\n        {\\n            nums.push_back(it.first);\\n        }\\n    }\\n    return nums;\\n}\\n\\nint maximumGap(vector<int> &nums)\\n{\\n    int n = nums.size();\\n    if (n < 2)\\n        return 0;\\n    vector<int> sortednums = countsort(nums);\\n\\n    int maxgap = INT_MIN;\\n    for (int i = 1; i < n; i++)\\n    {\\n        int currgap = sortednums[i] - sortednums[i - 1];\\n        maxgap = max(maxgap, currgap);\\n    }\\n\\n    return maxgap;\\n}\\n};\\n```",
        "level": "medium",
        "type": [
            "indexing error",
            "wrong comment mark",
            "conditional statement error",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n\nvector<int> countsort(vector<int> &nums)\n{\n    int n = nums.size();\n    map<int, int> m;\n    for (int i = 0; /**/ i /*/ <= n; i++ )\n        m[nums[i]]++;\n\n    nums.clear();\n    foreach (var it in m)\n    {\n        int cnt = it.second;\n        while (cnt--)\n        {\n            nums.push_back(it.first);\n        }\n    }\n    return nums;\n}\n\nint maximumGap(vector<int> &nums)\n{\n    int n = nums.size();\n    if (n < 2)\n        return 0;\n    vector<int> sortednums = countsort(nums);\n\n    int maxgap = INT_MIN;\n    for (int i = 1; i <= n; i++)\n    {\n        int currgap = sortednums[i] - sortednums[i - 1];\n        maxgap = max(maxgap, currgap);\n    }\n\n    return maxgap;\n}\n};\n"
    },
    {
        "slug": "lru-cache",
        "description": "Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.\nImplement the LRUCache class:\n\nLRUCache(int capacity) Initialize the LRU cache with positive size capacity.\nint get(int key) Return the value of the key if the key exists, otherwise return -1.\nvoid put(int key, int value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key.\n\nThe functions get and put must each run in O(1) average time complexity.",
        "examples": [
            "Input\n[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"]\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\nOutput\n[null, null, null, 1, null, -1, null, -1, 3, 4]\n\nExplanation\nLRUCache lRUCache = new LRUCache(2);\nlRUCache.put(1, 1); // cache is {1=1}\nlRUCache.put(2, 2); // cache is {1=1, 2=2}\nlRUCache.get(1);    // return 1\nlRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}\nlRUCache.get(2);    // returns -1 (not found)\nlRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}\nlRUCache.get(1);    // return -1 (not found)\nlRUCache.get(3);    // return 3\nlRUCache.get(4);    // return 4"
        ],
        "constraints": "1 <= capacity <= 3000\n0 <= key <= 104\n0 <= value <= 105\nAt most 2 * 105 calls will be made to get and put.",
        "oracle_code": "class LRUCache {\npublic:\nclass node\n{\n  public:\n  int key;\n  int val;\n  node* next;\n  node* prev;\n  node(int _key,int _val)\n  {\n    key = _key;\n    val = _val;\n  }\n};\nnode* head = new node(-1,-1);\nnode* tail = new node(-1,-1);\n\nint size;\nunordered_map<int,node*>mpp;\n    LRUCache(int capacity) {\n       size = capacity; \n       head->next = tail;\n       tail->prev = head;  \n    }\n\n    void addNode(node* newNode){\n       \n       node* temp = head->next;\n       newNode->next = temp;\n       newNode->prev = head;\n       head->next = newNode;\n       temp->prev = newNode;\n    }\n\n    void deleteNode(node* delNode){\n         \n       node* delprev = delNode->prev;\n       node* delnext = delNode->next;\n       delprev->next = delnext;\n       delnext->prev = delprev;\n    }\n    \n    int get(int _key) {\n        \n        if(mpp.count(_key))\n        {\n          node* nde = mpp[_key];\n          int curr = nde->val;\n          mpp.erase(_key);\n          deleteNode(nde);\n          addNode(nde);\n          mpp[_key] = head->next;\n          return curr;\n        }\n        return -1;\n    }\n    \n    void put(int _key, int value) {\n        \n        if(mpp.count(_key))\n        {\n           node* nde = mpp[_key];\n           mpp.erase(_key);\n           deleteNode(nde);\n        }\n        if(mpp.size()==size)\n        {\n           mpp.erase(tail->prev->key);\n           deleteNode(tail->prev);\n        }\n        addNode(new node(_key,value));\n        mpp[_key] = head->next;\n    }\n};",
        "content": "# PLEASE DO UPVOTE!!!!!\\n\\n**CONNECT WITH ME ON LINKEDIN :  https://www.linkedin.com/in/md-kamran-55b98521a/**\\n\\n## INTUITION\\nTo Implement LRU(Least recently used), we need to have a track of the usage of the keys, in the order of there usage, as we have a limited capacity we cant extend our capacity beyond \"capacity\", so we always we will take out those values which has\\'nt been acccess in the recent time.So, we have to think of something that can kind of sort our keys according to usage on the go, the best Data Structure for this purpose is Doubly linked List.\\n                             A Doubly linked list will have a Head node as well as a tail node, and whenever a key is used we will place it just next to the head node,in this fashions, the one\\'s which are closer to head are the most recently used ones, and as we go closer to the tail node, those are the less recently used ones while the node just previous to tail is the \"LEAST RECENTLY USED\". \\nSo whenever we add a key or use a key(get()), we will move it right after the head node, and whenever we call the (put() function), if size if greater we have to delete the LRU node, if key is not present, (if present then too we will delete that node so as to update the value and still move it right after head node), and place new node right after head node.                        \\n\\n\\n**Ask Furthur Doubts in the Comment Section**\\n# Code\\n```\\nclass LRUCache {\\npublic:\\nclass node\\n{\\n  public:\\n  int key;\\n  int val;\\n  node* next;\\n  node* prev;\\n  node(int _key,int _val)\\n  {\\n    key = _key;\\n    val = _val;\\n  }\\n};\\nnode* head = new node(-1,-1);\\nnode* tail = new node(-1,-1);\\n\\nint size;\\nunordered_map<int,node*>mpp;\\n    LRUCache(int capacity) {\\n       size = capacity; \\n       head->next = tail;\\n       tail->prev = head;  \\n    }\\n\\n    void addNode(node* newNode){\\n       \\n       node* temp = head->next;\\n       newNode->next = temp;\\n       newNode->prev = head;\\n       head->next = newNode;\\n       temp->prev = newNode;\\n    }\\n\\n    void deleteNode(node* delNode){\\n         \\n       node* delprev = delNode->prev;\\n       node* delnext = delNode->next;\\n       delprev->next = delnext;\\n       delnext->prev = delprev;\\n    }\\n    \\n    int get(int _key) {\\n        \\n        if(mpp.count(_key))\\n        {\\n          node* nde = mpp[_key];\\n          int curr = nde->val;\\n          mpp.erase(_key);\\n          deleteNode(nde);\\n          addNode(nde);\\n          mpp[_key] = head->next;\\n          return curr;\\n        }\\n        return -1;\\n    }\\n    \\n    void put(int _key, int value) {\\n        \\n        if(mpp.count(_key))\\n        {\\n           node* nde = mpp[_key];\\n           mpp.erase(_key);\\n           deleteNode(nde);\\n        }\\n        if(mpp.size()==size)\\n        {\\n           mpp.erase(tail->prev->key);\\n           deleteNode(tail->prev);\\n        }\\n        addNode(new node(_key,value));\\n        mpp[_key] = head->next;\\n    }\\n};\\n\\n```\\n![b62ab1be-232a-438f-9524-7d8ca4dbd5fe_1675328166.1161866.png](https://assets.leetcode.com/users/images/8d5343b1-0eb4-4111-a914-40ce968fd034_1675389764.2273676.png)",
        "level": "medium",
        "type": [
            "wrong comment mark",
            "undefined keywords from other languages",
            "colon missing",
            "undefined objects"
        ],
        "buggy_code": "\nclass LRUCache {\npublic:\nclass node\n{\n  public:\n  int key;\n  int val;\n  node* next;\n  node* prev;\n  node(int _key,int _val)\n  {\n    key = _key;\n    val = _val;\n  }\n};\nnode* head = nullptr;\nnode* tail = nullptr;\n\nint size;\nunordered_map<int,node*>mpp;\n    LRUCache(int capacity) {\n       size = capacity; \n       head->next = tail;\n       tail->prev = head;  \n    }\n\n    void addNode(node* newNode){\n       \n       node* temp = head->next;\n       newNode->next = temp;\n       newNode->prev = head;\n       head->next = newNode;\n    }\n\n    /*void deleteNode(node* delNode){\n         \n       node* delprev = delNode->prev;\n       node* delnext = delNode->next;\n       delprev->next = delnext;\n       delnext->prev = delprev;\n    }*/\n    \n    int get(int _key) {\n        \n        if(mpp.count(_key))\n        {\n          node* nde = mpp[_key];\n          int curr = nde->val;\n          mpp.erase(_key);\n          deleteNode(nde);\n          addNode(nde)\n          mpp[_key] = head->next;\n          return curr;\n        }\n        return -1;\n    }\n    \n    void put(int _key, int value) {\n        \n        if(mpp.count(_key))\n        {\n           node* nde = mpp[_key];\n           mpp.erase(_key);\n           deleteNode(nde);\n        }\n        if(mpp.size()==size)\n        {\n           mpp.erase(tail->prev->key);\n           deleteNode(tail->prev);\n        }\n        addNode(new node(_key,var));\n        mpp[_key] = head->next;\n    }\n};\n"
    },
    {
        "slug": "longest-common-prefix",
        "description": "Write a function to find the longest common prefix string amongst an array of strings.\nIf there is no common prefix, return an empty string \"\".",
        "examples": [
            "Input: strs = [\"flower\",\"flow\",\"flight\"]\nOutput: \"fl\"",
            "Input: strs = [\"dog\",\"racecar\",\"car\"]\nOutput: \"\"\nExplanation: There is no common prefix among the input strings."
        ],
        "constraints": "1 <= strs.length <= 200\n0 <= strs[i].length <= 200\nstrs[i] consists of only lowercase English letters.",
        "oracle_code": "class Solution {\npublic:\n    string longestCommonPrefix(vector<string>& str) \n    {\n        sort(str.begin(), str.end()); //sorting the array\n        string ans=\"\"; //creating a new empty string to store the common prefixes\n        for(int i=0;i<str[0].length();i++) // max iterations = length of the first string\n        {\n            if(str[0][i]!=str[str.size()-1][i]) // checking the characters of the first and last string\n                break;\n            ans+=str[0][i]; // concatinate if the characters are matching\n        }\n        return ans;\n    }\n};",
        "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWhen you sort an array, it is enough to check for the common characters of the the first & last string of the sorted vector.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& str) \\n    {\\n        sort(str.begin(), str.end()); //sorting the array\\n        string ans=\"\"; //creating a new empty string to store the common prefixes\\n        for(int i=0;i<str[0].length();i++) // max iterations = length of the first string\\n        {\\n            if(str[0][i]!=str[str.size()-1][i]) // checking the characters of the first and last string\\n                break;\\n            ans+=str[0][i]; // concatinate if the characters are matching\\n        }\\n        return ans;\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "statement separation",
            "indexing error",
            "unclosed string",
            "colon missing"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    string longestCommonPrefix(vector<string>& str) \n    {\n        sort(str.begin(), str.end()); //sorting the array\n        string ans=\"; \n        for(int i=0;i<=str[0].length();i++) \n            if(str[0][i]!=str[str.size()-1][i]) // checking the characters of the first and last string\n                break;\n        ans+=str[0][i]; \n        return ans;\n    }\n};\n"
    },
    {
        "slug": "perfect-squares",
        "description": "Given an integer n, return the least number of perfect square numbers that sum to n.\nA perfect square is an integer that is the square of an integer; in other words, it is the product of some integer with itself. For example, 1, 4, 9, and 16 are perfect squares while 3 and 11 are not.",
        "examples": [
            "Input: n = 12\nOutput: 3\nExplanation: 12 = 4 + 4 + 4.",
            "Input: n = 13\nOutput: 2\nExplanation: 13 = 4 + 9."
        ],
        "constraints": "1 <= n <= 104",
        "oracle_code": "class Solution {\npublic:\n\n    // declare a dp\n\n    int dp[105][10005];\n\n    int helper(vector<int>& arr, int i, int n, int sum)\n    {\n        // base case\n\n        if(sum == 0)\n        {\n            return 0;\n        }\n\n        if(i >= n || sum < 0)\n        {\n            return INT_MAX - 1000;\n        }\n\n        // if already calculated\n\n        if(dp[i][sum] != -1)\n        {\n            return dp[i][sum];\n        }\n\n        // at each ith element we have two options either include or exclude\n\n        int mini = INT_MAX;\n\n        // inclusion part\n\n        if(arr[i] <= sum)\n        {\n            mini = min(mini, 1 + helper(arr, i, n, sum - arr[i]));\n        }\n\n        // exclusion part\n\n        mini = min(mini, helper(arr, i + 1, n, sum));\n\n        // store the res in dp\n\n        return dp[i][sum] = mini;\n    }\n\n    int numSquares(int n) {\n\n        vector<int> arr;\n\n        // find all the squares between 1 to n\n\n        for(int i = 1; i * i <= n; i++)\n        {\n            arr.push_back(i * i);\n        }\n\n        // initialize dp with -1\n\n        memset(dp, -1, sizeof(dp));\n\n        return helper(arr, 0, arr.size(), n);\n    }\n};",
        "content": "* ***Using Recursion && Memoization***\\n\\n* ***Time Complexity :- O(N * sqrt(N))***\\n\\n* ***Space Complexity :- O(N * sqrt(N))***\\n\\n* ***There are sqrt(N), squares between 1 to N***\\n\\n```\\nclass Solution {\\npublic:\\n\\n    // declare a dp\\n\\n    int dp[105][10005];\\n\\n    int helper(vector<int>& arr, int i, int n, int sum)\\n    {\\n        // base case\\n\\n        if(sum == 0)\\n        {\\n            return 0;\\n        }\\n\\n        if(i >= n || sum < 0)\\n        {\\n            return INT_MAX - 1000;\\n        }\\n\\n        // if already calculated\\n\\n        if(dp[i][sum] != -1)\\n        {\\n            return dp[i][sum];\\n        }\\n\\n        // at each ith element we have two options either include or exclude\\n\\n        int mini = INT_MAX;\\n\\n        // inclusion part\\n\\n        if(arr[i] <= sum)\\n        {\\n            mini = min(mini, 1 + helper(arr, i, n, sum - arr[i]));\\n        }\\n\\n        // exclusion part\\n\\n        mini = min(mini, helper(arr, i + 1, n, sum));\\n\\n        // store the res in dp\\n\\n        return dp[i][sum] = mini;\\n    }\\n\\n    int numSquares(int n) {\\n\\n        vector<int> arr;\\n\\n        // find all the squares between 1 to n\\n\\n        for(int i = 1; i * i <= n; i++)\\n        {\\n            arr.push_back(i * i);\\n        }\\n\\n        // initialize dp with -1\\n\\n        memset(dp, -1, sizeof(dp));\\n\\n        return helper(arr, 0, arr.size(), n);\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "indexing error",
            "undefined methods",
            "undefined keywords from other languages",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    int dp[105][10005];\n    \n    int helper(int i, int n, int sum)\n    {\n        vector<int>& arr;\n\n        if(sum == 0)\n        {\n            return 0;\n        }\n\n        if(i > n || sum < 0)\n        {\n            return INT_MAX - 1000;\n        }\n\n        if(dp[i][sum] != -1)\n        {\n            return dp[i][sum];\n        }\n\n        int mini = INT_MAX;\n\n        if(arr[i] <= sum)\n        {\n            mini = min(mini, 1 + helper(i, n, sum - arr[i]));\n        }\n\n        mini = min(mini, helper(i + 1, n, sum));\n\n        return dp[i][sum] = mini;\n    }\n\n    int numSquares(int n) {\n\n        vector<int> arr;\n\n        for(int i = 1; i * i <= n; i++)\n        {\n            arr.push_back(i * i);\n        }\n\n        memset(dp, -1his>initializeDP();\n\n        \n        print(helper(0, arr.size(), n));\n    }\n\n};\n"
    },
    {
        "slug": "shortest-path-to-get-all-keys",
        "description": "You are given an m x n grid grid where:\n\n'.' is an empty cell.\n'#' is a wall.\n'@' is the starting point.\nLowercase letters represent keys.\nUppercase letters represent locks.\n\nYou start at the starting point and one move consists of walking one space in one of the four cardinal directions. You cannot walk outside the grid, or walk into a wall.\nIf you walk over a key, you can pick it up and you cannot walk over a lock unless you have its corresponding key.\nFor some 1 <= k <= 6, there is exactly one lowercase and one uppercase letter of the first k letters of the English alphabet in the grid. This means that there is exactly one key for each lock, and one lock for each key; and also that the letters used to represent the keys and locks were chosen in the same order as the English alphabet.\nReturn the lowest number of moves to acquire all keys. If it is impossible, return -1.",
        "examples": [
            "Input: grid = [\"@.a..\",\"###.#\",\"b.A.B\"]\nOutput: 8\nExplanation: Note that the goal is to obtain all the keys not to open all the locks.",
            "Input: grid = [\"@..aA\",\"..B#.\",\"....b\"]\nOutput: 6",
            "Input: grid = [\"@Aa\"]\nOutput: -1"
        ],
        "constraints": "m == grid.length\nn == grid[i].length\n1 <= m, n <= 30\ngrid[i][j] is either an English letter, '.', '#', or '@'.\u00a0\nThere is exactly one\u00a0'@'\u00a0in the grid.\nThe number of keys in the grid is in the range [1, 6].\nEach key in the grid is unique.\nEach key in the grid has a matching lock.",
        "oracle_code": "class Solution {\npublic:\n\n    int dir[4][2] = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};\n\n    int shortestPathAllKeys(vector<string>& grid) {\n        \n        int m = grid.size();\n        int n = grid[0].size();\n        queue<pair<pair<int, int>, int>> que;\n        vector<vector<unsigned long>> mapKey(m, vector<unsigned long>(n, 0));\n        int target = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if ('a' <= grid[i][j] && grid[i][j] <= 'f') {\n                    target |= 1 << (grid[i][j] - 'a');\n                    continue;\n                }\n\n                if (grid[i][j] == '@') {\n                    que.emplace(pair<int, int>(i, j), 0);\n                    mapKey[i][j] = 1;\n                }\n            }\n        }\n\n\n        int step = 0;\n        while (!que.empty()) {\n            int size = que.size();\n            for (int s = 0; s < size; s++) {\n                int i = que.front().first.first;\n                int j = que.front().first.second;\n                int key = que.front().second;\n                que.pop();\n                \n                if ('a' <= grid[i][j] && grid[i][j] <= 'f') {\n                    key |= 1 << (grid[i][j] - 'a');\n                    if (key == target)\n                        return step;\n\n                    mapKey[i][j] |= 1l << key;\n                }\n\n                for (int d = 0; d < 4; d++) {\n                    int newi = i + dir[d][0];\n                    int newj = j + dir[d][1];\n                    \n                    if (!(0 <= newi && newi < m && 0 <= newj && newj < n))\n                        continue;\n                        \n                    int val = grid[newi][newj];\n                    if (val == '#')\n                        continue;\n                        \n                    if ('A' <= val && val <= 'F' && (key & (1 << (val - 'A'))) == 0)\n                        continue;\n                        \n                    if (mapKey[newi][newj] & (1l << key))\n                        continue;\n                        \n                     mapKey[newi][newj] |= 1l << key;\n                     que.emplace(pair<int, int>(newi, newj), key);\n                }\n            }\n            step++;\n        }\n        return -1;\n    }\n};",
        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int dir[4][2] = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};\\n\\n    int shortestPathAllKeys(vector<string>& grid) {\\n        \\n        int m = grid.size();\\n        int n = grid[0].size();\\n        queue<pair<pair<int, int>, int>> que;\\n        vector<vector<unsigned long>> mapKey(m, vector<unsigned long>(n, 0));\\n        int target = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (\\'a\\' <= grid[i][j] && grid[i][j] <= \\'f\\') {\\n                    target |= 1 << (grid[i][j] - \\'a\\');\\n                    continue;\\n                }\\n\\n                if (grid[i][j] == \\'@\\') {\\n                    que.emplace(pair<int, int>(i, j), 0);\\n                    mapKey[i][j] = 1;\\n                }\\n            }\\n        }\\n\\n\\n        int step = 0;\\n        while (!que.empty()) {\\n            int size = que.size();\\n            for (int s = 0; s < size; s++) {\\n                int i = que.front().first.first;\\n                int j = que.front().first.second;\\n                int key = que.front().second;\\n                que.pop();\\n                \\n                if (\\'a\\' <= grid[i][j] && grid[i][j] <= \\'f\\') {\\n                    key |= 1 << (grid[i][j] - \\'a\\');\\n                    if (key == target)\\n                        return step;\\n\\n                    mapKey[i][j] |= 1l << key;\\n                }\\n\\n                for (int d = 0; d < 4; d++) {\\n                    int newi = i + dir[d][0];\\n                    int newj = j + dir[d][1];\\n                    \\n                    if (!(0 <= newi && newi < m && 0 <= newj && newj < n))\\n                        continue;\\n                        \\n                    int val = grid[newi][newj];\\n                    if (val == \\'#\\')\\n                        continue;\\n                        \\n                    if (\\'A\\' <= val && val <= \\'F\\' && (key & (1 << (val - \\'A\\'))) == 0)\\n                        continue;\\n                        \\n                    if (mapKey[newi][newj] & (1l << key))\\n                        continue;\\n                        \\n                     mapKey[newi][newj] |= 1l << key;\\n                     que.emplace(pair<int, int>(newi, newj), key);\\n                }\\n            }\\n            step++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
        "level": "hard",
        "type": [
            "statement separation",
            "operation error",
            "wrong comment mark",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n\n    int dir[4][2] = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};\n\n    int shortestPathAllKeys(vector<string>& grid) {\n        \n        int m = grid.size();\n        int n = grid[0].size();\n        queue<pair<pair<int, int>, int>> que;\n        vector<vector<unsigned long>> mapKey(m, vector<unsigned long>(n, 0));\n        int target = 0;\n        for (int i = 0; i < m; i++) \n            for (int j = 0; j < n; j++) \n                if ('a' <= grid[i][j] && grid[i][j] <= 'f') {\n                    target |= 1 << (grid[i][j] - 'a\");\n                    continue;\n\n                if (grid[i][j] == '@') {\n                    que.emplace(pair<int, int>(i, j), 0);\n                    mapKey[i][j] = 1;\n                }\n            \n\n\n        int step = 0;\n        while (!que.empty()) {\n            int size = que.size();\n            for (int s = 0; s < size; s++) {\n                int i = que.front().first.first;\n                int j = que.front().first.second;\n                int key = que.front().second;\n                que.pop();\n                \n                if ('a' <= grid[i][j] && grid[i][j] <= 'f\") {\n                    key |= 1 << (grid[i][j] - 'a\");\n                    if (key == target)\n                        return step;\n\n                    mapKey[i][j] |= 1l << key;\n                }\n\n                for (int d = 0; d < 4; d++) {\n                   \n                    int newj = j + dir[d][1];\n                    \n                    if (!(0 <= newi && newi < m && 0 <= newj && newj < n))\n                        continue;\n                        \n                    int val = grid[newi][newj];\n                    if (val == '#')\n                        continue;\n                        \n                    if ('A' <= val && val <= 'F' && (key & (1 << (val - 'A\"))) == 0)\n                        continue;\n                        \n                    if (mapKey[newi][newj] & (1l << key))\n                        continue;\n                        \n                     mapKey[newi][newj] |= 1l << (key+1);  \n                     que.emplace(pair<int, int>(newi, newj), key);\n                }\n            }\n            step++;\n        }\n        return -1;\n    }\n};\n"
    },
    {
        "slug": "group-anagrams",
        "description": "Given an array of strings strs, group the anagrams together. You can return the answer in any order.\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.",
        "examples": [
            "Input: strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]\nOutput: [[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]",
            "Input: strs = [\"\"]\nOutput: [[\"\"]]",
            "Input: strs = [\"a\"]\nOutput: [[\"a\"]]"
        ],
        "constraints": "1 <= strs.length <= 104\n0 <= strs[i].length <= 100\nstrs[i] consists of lowercase English letters.",
        "oracle_code": "class Solution {\npublic:\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\n        unordered_map<string,int> m;\n        vector<vector<string>> ans;\n        for(int i=0; i<strs.size(); i++) {\n            string str = strs[i];\n            sort(str.begin(),str.end());\n\n            if(m.find(str) != m.end()) {\n                ans[m[str]].push_back(strs[i]);\n            }\n            else {\n                m[str] = ans.size(); \n                ans.push_back({strs[i]});\n            }\n        }\n        return ans;\n    }\n};",
        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        unordered_map<string,int> m;\\n        vector<vector<string>> ans;\\n        for(int i=0; i<strs.size(); i++) {\\n            string str = strs[i];\\n            sort(str.begin(),str.end());\\n\\n            if(m.find(str) != m.end()) {\\n                ans[m[str]].push_back(strs[i]);\\n            }\\n            else {\\n                m[str] = ans.size(); \\n                ans.push_back({strs[i]});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "statement separation",
            "operation error",
            "undefined methods",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\n        unordered_map<string,int> m;\n        vector<vector<string>> ans;\n        for(int i=0; i<strs.size(); i++) \n            string str = strs[i];\n            sort(str.begin(),str.end());\n\n            if(m.find(str) != m.end()) {\n                ans[m[str].push_back(str);\n            }\n            else {\n                m[str] = ans.size(); \n                ans.push_back({strs[i]});\n                sortMyVec(ans[m[str]]);\n            }\n        }\n        return ans;\n    }\n};\n"
    },
    {
        "slug": "shortest-path-to-get-all-keys",
        "description": "You are given an m x n grid grid where:\n\n'.' is an empty cell.\n'#' is a wall.\n'@' is the starting point.\nLowercase letters represent keys.\nUppercase letters represent locks.\n\nYou start at the starting point and one move consists of walking one space in one of the four cardinal directions. You cannot walk outside the grid, or walk into a wall.\nIf you walk over a key, you can pick it up and you cannot walk over a lock unless you have its corresponding key.\nFor some 1 <= k <= 6, there is exactly one lowercase and one uppercase letter of the first k letters of the English alphabet in the grid. This means that there is exactly one key for each lock, and one lock for each key; and also that the letters used to represent the keys and locks were chosen in the same order as the English alphabet.\nReturn the lowest number of moves to acquire all keys. If it is impossible, return -1.",
        "examples": [
            "Input: grid = [\"@.a..\",\"###.#\",\"b.A.B\"]\nOutput: 8\nExplanation: Note that the goal is to obtain all the keys not to open all the locks.",
            "Input: grid = [\"@..aA\",\"..B#.\",\"....b\"]\nOutput: 6",
            "Input: grid = [\"@Aa\"]\nOutput: -1"
        ],
        "constraints": "m == grid.length\nn == grid[i].length\n1 <= m, n <= 30\ngrid[i][j] is either an English letter, '.', '#', or '@'.\u00a0\nThere is exactly one\u00a0'@'\u00a0in the grid.\nThe number of keys in the grid is in the range [1, 6].\nEach key in the grid is unique.\nEach key in the grid has a matching lock.",
        "oracle_code": "class Solution {\npublic:\n\n    int dir[4][2] = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};\n\n    int shortestPathAllKeys(vector<string>& grid) {\n        \n        int m = grid.size();\n        int n = grid[0].size();\n        queue<pair<pair<int, int>, int>> que;\n        vector<vector<unsigned long>> mapKey(m, vector<unsigned long>(n, 0));\n        int target = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if ('a' <= grid[i][j] && grid[i][j] <= 'f') {\n                    target |= 1 << (grid[i][j] - 'a');\n                    continue;\n                }\n\n                if (grid[i][j] == '@') {\n                    que.emplace(pair<int, int>(i, j), 0);\n                    mapKey[i][j] = 1;\n                }\n            }\n        }\n\n\n        int step = 0;\n        while (!que.empty()) {\n            int size = que.size();\n            for (int s = 0; s < size; s++) {\n                int i = que.front().first.first;\n                int j = que.front().first.second;\n                int key = que.front().second;\n                que.pop();\n                \n                if ('a' <= grid[i][j] && grid[i][j] <= 'f') {\n                    key |= 1 << (grid[i][j] - 'a');\n                    if (key == target)\n                        return step;\n\n                    mapKey[i][j] |= 1l << key;\n                }\n\n                for (int d = 0; d < 4; d++) {\n                    int newi = i + dir[d][0];\n                    int newj = j + dir[d][1];\n                    \n                    if (!(0 <= newi && newi < m && 0 <= newj && newj < n))\n                        continue;\n                        \n                    int val = grid[newi][newj];\n                    if (val == '#')\n                        continue;\n                        \n                    if ('A' <= val && val <= 'F' && (key & (1 << (val - 'A'))) == 0)\n                        continue;\n                        \n                    if (mapKey[newi][newj] & (1l << key))\n                        continue;\n                        \n                     mapKey[newi][newj] |= 1l << key;\n                     que.emplace(pair<int, int>(newi, newj), key);\n                }\n            }\n            step++;\n        }\n        return -1;\n    }\n};",
        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int dir[4][2] = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};\\n\\n    int shortestPathAllKeys(vector<string>& grid) {\\n        \\n        int m = grid.size();\\n        int n = grid[0].size();\\n        queue<pair<pair<int, int>, int>> que;\\n        vector<vector<unsigned long>> mapKey(m, vector<unsigned long>(n, 0));\\n        int target = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (\\'a\\' <= grid[i][j] && grid[i][j] <= \\'f\\') {\\n                    target |= 1 << (grid[i][j] - \\'a\\');\\n                    continue;\\n                }\\n\\n                if (grid[i][j] == \\'@\\') {\\n                    que.emplace(pair<int, int>(i, j), 0);\\n                    mapKey[i][j] = 1;\\n                }\\n            }\\n        }\\n\\n\\n        int step = 0;\\n        while (!que.empty()) {\\n            int size = que.size();\\n            for (int s = 0; s < size; s++) {\\n                int i = que.front().first.first;\\n                int j = que.front().first.second;\\n                int key = que.front().second;\\n                que.pop();\\n                \\n                if (\\'a\\' <= grid[i][j] && grid[i][j] <= \\'f\\') {\\n                    key |= 1 << (grid[i][j] - \\'a\\');\\n                    if (key == target)\\n                        return step;\\n\\n                    mapKey[i][j] |= 1l << key;\\n                }\\n\\n                for (int d = 0; d < 4; d++) {\\n                    int newi = i + dir[d][0];\\n                    int newj = j + dir[d][1];\\n                    \\n                    if (!(0 <= newi && newi < m && 0 <= newj && newj < n))\\n                        continue;\\n                        \\n                    int val = grid[newi][newj];\\n                    if (val == \\'#\\')\\n                        continue;\\n                        \\n                    if (\\'A\\' <= val && val <= \\'F\\' && (key & (1 << (val - \\'A\\'))) == 0)\\n                        continue;\\n                        \\n                    if (mapKey[newi][newj] & (1l << key))\\n                        continue;\\n                        \\n                     mapKey[newi][newj] |= 1l << key;\\n                     que.emplace(pair<int, int>(newi, newj), key);\\n                }\\n            }\\n            step++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
        "level": "hard",
        "type": [
            "statement separation",
            "wrong comment mark",
            "unclosed string",
            "colon missing"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n\n    int dir[4][2] = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};\n\n    int shortestPathAllKeys(vector<string>& grid) {\n        \n        int m = grid.size();\n        int n = grid[0].size();\n        queue<pair<pair<int, int>, int>> que;\n        vector<vector<unsigned long>> mapKey(m, vector<unsigned long>(n, 0));\n        int target = 0;\n        for (int i = 0; i < m; i++) \n            for (int j = 0; j < n; j++) \n                if ('a' <= grid[i][j] && grid[i][j] <= 'f') {\n                    target |= 1  (grid[i][j] - 'a\");\n                    continue;\n\n                if (grid[i][j] == '@') {\n                    que.emplace(pair<int, int>(i, j), 0);\n                    mapKey[i][j] = 1;\n                }\n            \n\n\n        int step = 0;\n        while (!que.empty()) {\n            int size = que.size();\n            for (int s = 0; s < size; s++) {\n                int i = que.front().first.first;\n                int j = que.front().first.second;\n                int key = que.front().second;\n                que.pop();\n                \n                if ('a' <= grid[i][j] && grid[i][j] <= 'f\") {\n                    key |= 1 << (grid[i][j] - 'a\");\n                    if (key == target)\n                        return step;\n\n                    mapKey[i][j] |= 1l << key;\n                }\n\n                for (int d = 0; d < 4; d++) {\n                   \n                    int newj = j + dir[d][1];\n                    \n                    if (!(0 <= newi && newi < m && 0 <= newj && newj < n))\n                        continue;\n                        \n                    int val = grid[newi][newj];\n                    if (val == '#')\n                        continue;\n                        \n                    if ('A' <= val && val <= 'F' && (key & (1  (val - 'A\"))) == 0)\n                        continue;\n                        \n                    if (mapKey[newi][newj] & (1l << key))\n                        continue;\n                        \n                     mapKey[newi][newj] |= 1l << key;\n                     que.emplace(pair<int, int>(newi, newj), key);\n                }\n            }\n            step++;\n        }\n        return -1;\n    }\n};\n"
    },
    {
        "slug": "search-in-a-binary-search-tree",
        "description": "You are given the root of a binary search tree (BST) and an integer val.\nFind the node in the BST that the node's value equals val and return the subtree rooted with that node. If such a node does not exist, return null.",
        "examples": [
            "Input: root = [4,2,7,1,3], val = 2\nOutput: [2,1,3]",
            "Input: root = [4,2,7,1,3], val = 5\nOutput: []"
        ],
        "constraints": "The number of nodes in the tree is in the range [1, 5000].\n1 <= Node.val <= 107\nroot is a binary search tree.\n1 <= val <= 107",
        "oracle_code": "class Solution {\npublic:\n    TreeNode* searchBST(TreeNode* root, int val) {\n       if(root==NULL) \n       return NULL;\n       if(root->val==val)\n       {\n           return root;\n       }\n       if(root->val>val){\n          return  searchBST(root->left,val);\n       }\n        return searchBST(root->right,val);\n    }\n};",
        "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n       if(root==NULL) \\n       return NULL;\\n       if(root->val==val)\\n       {\\n           return root;\\n       }\\n       if(root->val>val){\\n          return  searchBST(root->left,val);\\n       }\\n        return searchBST(root->right,val);\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "statement separation",
            "conditional statement error",
            "colon missing",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    TreeNode* searchBST(TreeNode* root, int val) {\n       if(root=NULL) \n       return NULL;\n       if(root->val==val);\n       {\n           return root;\n       }\n       if(root->val > val)){\n          return searchBST(root->right,val);\n       }\n        return searchBST(root->left,val);\n    }\n};\n"
    },
    {
        "slug": "search-in-a-binary-search-tree",
        "description": "You are given the root of a binary search tree (BST) and an integer val.\nFind the node in the BST that the node's value equals val and return the subtree rooted with that node. If such a node does not exist, return null.",
        "examples": [
            "Input: root = [4,2,7,1,3], val = 2\nOutput: [2,1,3]",
            "Input: root = [4,2,7,1,3], val = 5\nOutput: []"
        ],
        "constraints": "The number of nodes in the tree is in the range [1, 5000].\n1 <= Node.val <= 107\nroot is a binary search tree.\n1 <= val <= 107",
        "oracle_code": "class Solution {\npublic:\n    TreeNode* searchBST(TreeNode* root, int val) {\n       if(root==NULL) \n       return NULL;\n       if(root->val==val)\n       {\n           return root;\n       }\n       if(root->val>val){\n          return  searchBST(root->left,val);\n       }\n        return searchBST(root->right,val);\n    }\n};",
        "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n       if(root==NULL) \\n       return NULL;\\n       if(root->val==val)\\n       {\\n           return root;\\n       }\\n       if(root->val>val){\\n          return  searchBST(root->left,val);\\n       }\\n        return searchBST(root->right,val);\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "conditional statement error",
            "undefined keywords from other languages",
            "colon missing",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    TreeNode* searchBST(TreeNode* root, int val) {\n       if(root=None) \n       return NULL;\n       if(root->val==val)\n       {\n           return root;\n       }\n       if(root->val > val)){\n          return searchBST(root->right,val);\n       }\n        return searchBST(root->left,val);\n    }\n};\n"
    },
    {
        "slug": "maximum-gap",
        "description": "Given an integer array nums, return the maximum difference between two successive elements in its sorted form. If the array contains less than two elements, return 0.\nYou must write an algorithm that runs in linear time and uses linear extra space.",
        "examples": [
            "Input: nums = [3,6,9,1]\nOutput: 3\nExplanation: The sorted form of the array is [1,3,6,9], either (3,6) or (6,9) has the maximum difference 3.",
            "Input: nums = [10]\nOutput: 0\nExplanation: The array contains less than 2 elements, therefore return 0."
        ],
        "constraints": "1 <= nums.length <= 105\n0 <= nums[i] <= 109",
        "oracle_code": "class Solution {\npublic:\n\nvector<int> countsort(vector<int> &nums)\n{\n    int n = nums.size();\n    map<int, int> m;\n    for (int i = 0; i < n; i++ )\n        m[nums[i]]++;\n\n    nums.clear();\n    for (auto it : m)\n    {\n        int cnt = it.second;\n        while (cnt--)\n        {\n            nums.push_back(it.first);\n        }\n    }\n    return nums;\n}\n\nint maximumGap(vector<int> &nums)\n{\n    int n = nums.size();\n    if (n < 2)\n        return 0;\n    vector<int> sortednums = countsort(nums);\n\n    int maxgap = INT_MIN;\n    for (int i = 1; i < n; i++)\n    {\n        int currgap = sortednums[i] - sortednums[i - 1];\n        maxgap = max(maxgap, currgap);\n    }\n\n    return maxgap;\n}\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nsince it is given in the question that we can use only linear time and space so we can only use a kind of counting sort , where we required a hash map which take an extra o(n) time complexity.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn counting sort first we required an hash map where we store the frequency of each element and after storing the frequency we just need to fill the original array based on there frequency , here we use an map not unordered map because the map is store value in sorted order.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nwe are traversing the array once , so  it is O(n) and an extra (logn)\\nfactor comes because of using the map, but still it is better in terms of time from inbuilt sort function..\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n) we are using only an map so the total extra space is equal to the size of map.\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\nvector<int> countsort(vector<int> &nums)\\n{\\n    int n = nums.size();\\n    map<int, int> m;\\n    for (int i = 0; i < n; i++ )\\n        m[nums[i]]++;\\n\\n    nums.clear();\\n    for (auto it : m)\\n    {\\n        int cnt = it.second;\\n        while (cnt--)\\n        {\\n            nums.push_back(it.first);\\n        }\\n    }\\n    return nums;\\n}\\n\\nint maximumGap(vector<int> &nums)\\n{\\n    int n = nums.size();\\n    if (n < 2)\\n        return 0;\\n    vector<int> sortednums = countsort(nums);\\n\\n    int maxgap = INT_MIN;\\n    for (int i = 1; i < n; i++)\\n    {\\n        int currgap = sortednums[i] - sortednums[i - 1];\\n        maxgap = max(maxgap, currgap);\\n    }\\n\\n    return maxgap;\\n}\\n};\\n```",
        "level": "medium",
        "type": [
            "indexing error",
            "wrong comment mark",
            "undefined keywords from other languages",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n\nvector<int> countsort(vector<int> &nums)\n{\n    int n = nums.size();\n    map<int, int> m;\n    for (int i = 0; /**/ i /*/ < n; i++ )\n        m[nums[i]]++;\n\n    nums.clear();\n    foreach (var it in m)\n    {\n        int cnt = it.second;\n        while (cnt--\n        {\n            nums.push_back(it.first);\n        }\n    }\n    return nums;\n}\n\nint maximumGap(vector<int> &nums)\n{\n    int n = nums.size();\n    if (n < 2)\n        return 0;\n    vector<int> sortednums = countsort(nums);\n\n    int maxgap = INT_MIN;\n    for (int i = 1; i <= n; i++)\n    {\n        int currgap = sortednums[i] - sortednums[i - 1];\n        maxgap = max(maxgap, currgap);\n    }\n\n    return maxgap;\n}\n};\n"
    },
    {
        "slug": "search-in-a-binary-search-tree",
        "description": "You are given the root of a binary search tree (BST) and an integer val.\nFind the node in the BST that the node's value equals val and return the subtree rooted with that node. If such a node does not exist, return null.",
        "examples": [
            "Input: root = [4,2,7,1,3], val = 2\nOutput: [2,1,3]",
            "Input: root = [4,2,7,1,3], val = 5\nOutput: []"
        ],
        "constraints": "The number of nodes in the tree is in the range [1, 5000].\n1 <= Node.val <= 107\nroot is a binary search tree.\n1 <= val <= 107",
        "oracle_code": "class Solution {\npublic:\n    TreeNode* searchBST(TreeNode* root, int val) {\n       if(root==NULL) \n       return NULL;\n       if(root->val==val)\n       {\n           return root;\n       }\n       if(root->val>val){\n          return  searchBST(root->left,val);\n       }\n        return searchBST(root->right,val);\n    }\n};",
        "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n       if(root==NULL) \\n       return NULL;\\n       if(root->val==val)\\n       {\\n           return root;\\n       }\\n       if(root->val>val){\\n          return  searchBST(root->left,val);\\n       }\\n        return searchBST(root->right,val);\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "statement separation",
            "undefined keywords from other languages",
            "colon missing",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    TreeNode* searchBST(TreeNode* root, int val) {\n       if(root=None) \n       return NULL;\n       if(root->val==val);\n       {\n           return root;\n       }\n       if(root->val>val)){\n          return  searchBST(root->left,val);\n       }\n        return searchBST(root->right,val);\n    }\n};\n"
    },
    {
        "slug": "reverse-odd-levels-of-binary-tree",
        "description": "Given the root of a perfect binary tree, reverse the node values at each odd level of the tree.\n\nFor example, suppose the node values at level 3 are [2,1,3,4,7,11,29,18], then it should become [18,29,11,7,4,3,1,2].\n\nReturn the root of the reversed tree.\nA binary tree is perfect if all parent nodes have two children and all leaves are on the same level.\nThe level of a node is the number of edges along the path between it and the root node.",
        "examples": [
            "Input: root = [2,3,5,8,13,21,34]\nOutput: [2,5,3,8,13,21,34]\nExplanation: \nThe tree has only one odd level.\nThe nodes at level 1 are 3, 5 respectively, which are reversed and become 5, 3.",
            "Input: root = [7,13,11]\nOutput: [7,11,13]\nExplanation: \nThe nodes at level 1 are 13, 11, which are reversed and become 11, 13.",
            "Input: root = [0,1,2,0,0,0,0,1,1,1,1,2,2,2,2]\nOutput: [0,2,1,0,0,0,0,2,2,2,2,1,1,1,1]\nExplanation: \nThe odd levels have non-zero values.\nThe nodes at level 1 were 1, 2, and are 2, 1 after the reversal.\nThe nodes at level 3 were 1, 1, 1, 1, 2, 2, 2, 2, and are 2, 2, 2, 2, 1, 1, 1, 1 after the reversal."
        ],
        "constraints": "The number of nodes in the tree is in the range [1, 214].\n0 <= Node.val <= 105\nroot is a perfect binary tree.",
        "oracle_code": "class Solution {\npublic:\n    TreeNode* reverseOddLevels(TreeNode* root) {\n        queue<TreeNode*> q;\n        q.push(root);\n        int x = 1,n,i,z;\n        vector<TreeNode*> tmp;\n        TreeNode* node;\n        while(!q.empty()){\n            tmp.clear();\n            n = q.size();\n            // cout<<n<<\" \";\n            while(n--){\n                node = q.front();q.pop();\n                // cout<<node->val<<\" \";\n                if(x==0){\n                    tmp.push_back(node);\n                }\n                if(node->left)\n                    q.push(node->left);\n                if(node->right){\n                    q.push(node->right);\n                }\n            }\n            n = tmp.size();\n            for(i = 0; i < n/2; i++){\n                z = tmp[i]->val;\n                tmp[i]->val = tmp[n-1-i]->val;\n                tmp[n-1-i]->val = z;\n            }\n            x ^= 1;\n            n = 0;\n        }\n        return root;\n    }\n};",
        "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* reverseOddLevels(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        int x = 1,n,i,z;\\n        vector<TreeNode*> tmp;\\n        TreeNode* node;\\n        while(!q.empty()){\\n            tmp.clear();\\n            n = q.size();\\n            // cout<<n<<\" \";\\n            while(n--){\\n                node = q.front();q.pop();\\n                // cout<<node->val<<\" \";\\n                if(x==0){\\n                    tmp.push_back(node);\\n                }\\n                if(node->left)\\n                    q.push(node->left);\\n                if(node->right){\\n                    q.push(node->right);\\n                }\\n            }\\n            n = tmp.size();\\n            for(i = 0; i < n/2; i++){\\n                z = tmp[i]->val;\\n                tmp[i]->val = tmp[n-1-i]->val;\\n                tmp[n-1-i]->val = z;\\n            }\\n            x ^= 1;\\n            n = 0;\\n        }\\n        return root;\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "statement separation",
            "indexing error",
            "wrong comment mark",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    TreeNode* reverseOddLevels(TreeNode* root) {\n        queue<TreeNode*> q;\n        q.push(root);\n        int x = 1,n,i,z;\n        vector<TreeNode*> tmp;\n        TreeNode* node;\n        while(!q.empty()){\n            tmp.clear();\n            n = q.size();\n            while(n--)node = q.front();q.pop();\n                if(x==0){\n                    tmp.push_back(node);\n                }\n                if(node->left)\n                    q.push(node->left);\n                if(node->right){\n                    q.push(node->right);\n                }\n            n = tmp.size();\n            for(i = 0; i <= n/2; i++){\n                z = tmp[i]->val;\n                tmp[i]->val = tmp[n-1-i]->val;\n                tmp[n-1-i]->val = \"z;\n            }\n            x ^= 1;\n            n = 0;\n        }\n        return root;\n    }\n};\n"
    },
    {
        "slug": "largest-substring-between-two-equal-characters",
        "description": "Given a string s, return the length of the longest substring between two equal characters, excluding the two characters. If there is no such substring return -1.\nA substring is a contiguous sequence of characters within a string.",
        "examples": [
            "Input: s = \"aa\"\nOutput: 0\nExplanation: The optimal substring here is an empty substring between the two 'a's.",
            "Input: s = \"abca\"\nOutput: 2\nExplanation: The optimal substring here is \"bc\".",
            "Input: s = \"cbzxy\"\nOutput: -1\nExplanation: There are no characters that appear twice in s."
        ],
        "constraints": "1 <= s.length <= 300\ns contains only lowercase English letters.",
        "oracle_code": "class Solution {\npublic:\n    int maxLengthBetweenEqualCharacters(string s) {\n        int v[26];\n        memset(v,-1,sizeof v);\n        int ans=-1;\n        for(int i=0;i<s.size();i++){\n            if(v[s[i]-'a']==-1){\n                v[s[i]-'a']=i;\n            }\n            int res=i-v[s[i]-'a']-1;\n            ans=max(ans,res);\n        }\n        return ans;\n    }\n};",
        "content": "# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxLengthBetweenEqualCharacters(string s) {\\n        int v[26];\\n        memset(v,-1,sizeof v);\\n        int ans=-1;\\n        for(int i=0;i<s.size();i++){\\n            if(v[s[i]-\\'a\\']==-1){\\n                v[s[i]-\\'a\\']=i;\\n            }\\n            int res=i-v[s[i]-\\'a\\']-1;\\n            ans=max(ans,res);\\n        }\\n        return ans;\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "wrong comment mark",
            "unclosed string",
            "conditional statement error",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    int maxLengthBetweenEqualCharacters(string s) {\n        int v[26];\n        memset(v,-1,sizeof v);\n        int ans=-1;\n        /*for(int i=0;i<=s.size();i++){*/\n            if(v[s[i]-'a']==-1){\n                v[s[i]-'a' \"=i;\n            }\n            int res= computeResult(i, v, s); \n            ans=max(ans,res);\n        }\n        return ans;\n    }\n};\n"
    },
    {
        "slug": "shortest-path-to-get-all-keys",
        "description": "You are given an m x n grid grid where:\n\n'.' is an empty cell.\n'#' is a wall.\n'@' is the starting point.\nLowercase letters represent keys.\nUppercase letters represent locks.\n\nYou start at the starting point and one move consists of walking one space in one of the four cardinal directions. You cannot walk outside the grid, or walk into a wall.\nIf you walk over a key, you can pick it up and you cannot walk over a lock unless you have its corresponding key.\nFor some 1 <= k <= 6, there is exactly one lowercase and one uppercase letter of the first k letters of the English alphabet in the grid. This means that there is exactly one key for each lock, and one lock for each key; and also that the letters used to represent the keys and locks were chosen in the same order as the English alphabet.\nReturn the lowest number of moves to acquire all keys. If it is impossible, return -1.",
        "examples": [
            "Input: grid = [\"@.a..\",\"###.#\",\"b.A.B\"]\nOutput: 8\nExplanation: Note that the goal is to obtain all the keys not to open all the locks.",
            "Input: grid = [\"@..aA\",\"..B#.\",\"....b\"]\nOutput: 6",
            "Input: grid = [\"@Aa\"]\nOutput: -1"
        ],
        "constraints": "m == grid.length\nn == grid[i].length\n1 <= m, n <= 30\ngrid[i][j] is either an English letter, '.', '#', or '@'.\u00a0\nThere is exactly one\u00a0'@'\u00a0in the grid.\nThe number of keys in the grid is in the range [1, 6].\nEach key in the grid is unique.\nEach key in the grid has a matching lock.",
        "oracle_code": "class Solution {\npublic:\n\n    int dir[4][2] = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};\n\n    int shortestPathAllKeys(vector<string>& grid) {\n        \n        int m = grid.size();\n        int n = grid[0].size();\n        queue<pair<pair<int, int>, int>> que;\n        vector<vector<unsigned long>> mapKey(m, vector<unsigned long>(n, 0));\n        int target = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if ('a' <= grid[i][j] && grid[i][j] <= 'f') {\n                    target |= 1 << (grid[i][j] - 'a');\n                    continue;\n                }\n\n                if (grid[i][j] == '@') {\n                    que.emplace(pair<int, int>(i, j), 0);\n                    mapKey[i][j] = 1;\n                }\n            }\n        }\n\n\n        int step = 0;\n        while (!que.empty()) {\n            int size = que.size();\n            for (int s = 0; s < size; s++) {\n                int i = que.front().first.first;\n                int j = que.front().first.second;\n                int key = que.front().second;\n                que.pop();\n                \n                if ('a' <= grid[i][j] && grid[i][j] <= 'f') {\n                    key |= 1 << (grid[i][j] - 'a');\n                    if (key == target)\n                        return step;\n\n                    mapKey[i][j] |= 1l << key;\n                }\n\n                for (int d = 0; d < 4; d++) {\n                    int newi = i + dir[d][0];\n                    int newj = j + dir[d][1];\n                    \n                    if (!(0 <= newi && newi < m && 0 <= newj && newj < n))\n                        continue;\n                        \n                    int val = grid[newi][newj];\n                    if (val == '#')\n                        continue;\n                        \n                    if ('A' <= val && val <= 'F' && (key & (1 << (val - 'A'))) == 0)\n                        continue;\n                        \n                    if (mapKey[newi][newj] & (1l << key))\n                        continue;\n                        \n                     mapKey[newi][newj] |= 1l << key;\n                     que.emplace(pair<int, int>(newi, newj), key);\n                }\n            }\n            step++;\n        }\n        return -1;\n    }\n};",
        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int dir[4][2] = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};\\n\\n    int shortestPathAllKeys(vector<string>& grid) {\\n        \\n        int m = grid.size();\\n        int n = grid[0].size();\\n        queue<pair<pair<int, int>, int>> que;\\n        vector<vector<unsigned long>> mapKey(m, vector<unsigned long>(n, 0));\\n        int target = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (\\'a\\' <= grid[i][j] && grid[i][j] <= \\'f\\') {\\n                    target |= 1 << (grid[i][j] - \\'a\\');\\n                    continue;\\n                }\\n\\n                if (grid[i][j] == \\'@\\') {\\n                    que.emplace(pair<int, int>(i, j), 0);\\n                    mapKey[i][j] = 1;\\n                }\\n            }\\n        }\\n\\n\\n        int step = 0;\\n        while (!que.empty()) {\\n            int size = que.size();\\n            for (int s = 0; s < size; s++) {\\n                int i = que.front().first.first;\\n                int j = que.front().first.second;\\n                int key = que.front().second;\\n                que.pop();\\n                \\n                if (\\'a\\' <= grid[i][j] && grid[i][j] <= \\'f\\') {\\n                    key |= 1 << (grid[i][j] - \\'a\\');\\n                    if (key == target)\\n                        return step;\\n\\n                    mapKey[i][j] |= 1l << key;\\n                }\\n\\n                for (int d = 0; d < 4; d++) {\\n                    int newi = i + dir[d][0];\\n                    int newj = j + dir[d][1];\\n                    \\n                    if (!(0 <= newi && newi < m && 0 <= newj && newj < n))\\n                        continue;\\n                        \\n                    int val = grid[newi][newj];\\n                    if (val == \\'#\\')\\n                        continue;\\n                        \\n                    if (\\'A\\' <= val && val <= \\'F\\' && (key & (1 << (val - \\'A\\'))) == 0)\\n                        continue;\\n                        \\n                    if (mapKey[newi][newj] & (1l << key))\\n                        continue;\\n                        \\n                     mapKey[newi][newj] |= 1l << key;\\n                     que.emplace(pair<int, int>(newi, newj), key);\\n                }\\n            }\\n            step++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
        "level": "hard",
        "type": [
            "== and = confusion",
            "statement separation",
            "operation error",
            "wrong comment mark"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n\n    int dir[4][2] = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};\n\n    int shortestPathAllKeys(vector<string>& grid) {\n        \n        int m = grid.size();\n        int n = grid[0].size();\n        queue<pair<pair<int, int>, int>> que;\n        vector<vector<unsigned long>> mapKey(m, vector<unsigned long>(n, 0));\n        int target = 0;\n        for (int i = 0; i < m; i++) \n            for (int j = 0; j < n; j++) \n                if ('a' <= grid[i][j] && grid[i][j] <= 'f') {\n                    target |= 1 << (grid[i][j] - 'a');\n                    continue;\n\n                if (grid[i][j] = '@') {\n                    que.emplace(pair<int, int>(i, j), 0);\n                    mapKey[i][j] = 1;\n                }\n            \n\n\n        int step = 0;\n        while (!que.empty()) {\n            int size = que.size();\n            for (int s = 0; s < size; s++) {\n                int i = que.front().first.first;\n                int j = que.front().first.second;\n                int key = que.front().second;\n                que.pop();\n                \n                if ('a' <= grid[i][j] && grid[i][j] <= 'f') {\n                    key |= 1 << (grid[i][j] - 'a');\n                    if (key == target)\n                        return step;\n\n                    mapKey[i][j] |= 1l << key;\n                }\n\n                for (int d = 0; d < 4; d++) {\n                   \n                    int newj = j + dir[d][1];\n                    \n                    if (!(0 <= newi && newi < m && 0 <= newj && newj < n))\n                        continue;\n                        \n                    int val = grid[newi][newj];\n                    if (val == '#')\n                        continue;\n                        \n                    if ('A' <= val && val <= 'F' && (key & (1 << (val - 'A'))) == 0)\n                        continue;\n                        \n                    if (mapKey[newi][newj] & (1l << key))\n                        continue;\n                        \n                     mapKey[newi][newj] |= 1l << (key+1);  \n                     que.emplace(pair<int, int>(newi, newj), key);\n                }\n            }\n            step++;\n        }\n        return -1;\n    }\n};\n"
    },
    {
        "slug": "longest-common-prefix",
        "description": "Write a function to find the longest common prefix string amongst an array of strings.\nIf there is no common prefix, return an empty string \"\".",
        "examples": [
            "Input: strs = [\"flower\",\"flow\",\"flight\"]\nOutput: \"fl\"",
            "Input: strs = [\"dog\",\"racecar\",\"car\"]\nOutput: \"\"\nExplanation: There is no common prefix among the input strings."
        ],
        "constraints": "1 <= strs.length <= 200\n0 <= strs[i].length <= 200\nstrs[i] consists of only lowercase English letters.",
        "oracle_code": "class Solution {\npublic:\n    string longestCommonPrefix(vector<string>& str) \n    {\n        sort(str.begin(), str.end()); //sorting the array\n        string ans=\"\"; //creating a new empty string to store the common prefixes\n        for(int i=0;i<str[0].length();i++) // max iterations = length of the first string\n        {\n            if(str[0][i]!=str[str.size()-1][i]) // checking the characters of the first and last string\n                break;\n            ans+=str[0][i]; // concatinate if the characters are matching\n        }\n        return ans;\n    }\n};",
        "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWhen you sort an array, it is enough to check for the common characters of the the first & last string of the sorted vector.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& str) \\n    {\\n        sort(str.begin(), str.end()); //sorting the array\\n        string ans=\"\"; //creating a new empty string to store the common prefixes\\n        for(int i=0;i<str[0].length();i++) // max iterations = length of the first string\\n        {\\n            if(str[0][i]!=str[str.size()-1][i]) // checking the characters of the first and last string\\n                break;\\n            ans+=str[0][i]; // concatinate if the characters are matching\\n        }\\n        return ans;\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "statement separation",
            "unclosed string",
            "conditional statement error",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    string longestCommonPrefix(vector<string>& str) \n    {\n        sort(str.begin(), str.end()); //sorting the array\n        string ans=\"; \n        for(int i=0;i<str[0].length();i++) // max iterations = length of the first string\n            if(str[0][i]!=str[str.size()][i]) \n                break;\n        ans+=str[0][i]]; \n        return ans;\n    }\n};\n"
    },
    {
        "slug": "moving-stones-until-consecutive-ii",
        "description": "There are some stones in different positions on the X-axis. You are given an integer array stones, the positions of the stones.\nCall a stone an endpoint stone if it has the smallest or largest position. In one move, you pick up an endpoint stone and move it to an unoccupied position so that it is no longer an endpoint stone.\n\nIn particular, if the stones are at say, stones = [1,2,5], you cannot move the endpoint stone at position 5, since moving it to any position (such as 0, or 3) will still keep that stone as an endpoint stone.\n\nThe game ends when you cannot make any more moves (i.e., the stones are in three consecutive positions).\nReturn an integer array answer of length 2 where:\n\nanswer[0] is the minimum number of moves you can play, and\nanswer[1] is the maximum number of moves you can play.",
        "examples": [
            "Input: stones = [7,4,9]\nOutput: [1,2]\nExplanation: We can move 4 -> 8 for one move to finish the game.\nOr, we can move 9 -> 5, 4 -> 6 for two moves to finish the game.",
            "Input: stones = [6,5,4,3,10]\nOutput: [2,3]\nExplanation: We can move 3 -> 8 then 10 -> 7 to finish the game.\nOr, we can move 3 -> 7, 4 -> 8, 5 -> 9 to finish the game.\nNotice we cannot move 10 -> 2 to finish the game, because that would be an illegal move."
        ],
        "constraints": "3 <= stones.length <= 104\n1 <= stones[i] <= 109\nAll the values of stones are unique.",
        "oracle_code": "class Solution {\npublic:\n    vector<int> numMovesStonesII(vector<int>& stones) {\n        sort(stones.begin(), stones.end());\n\n        int N = stones.size(), low = N;\n        for (int i = 0, j = 0; j < N; ++j) {\n            while (stones[j] - stones[i] + 1 > N) {\n                ++i;\n            }\n            if (N - (j - i + 1) == 1 && N - (stones[j] - stones[i] + 1) == 1) {\n                low = min(low, 2);\n            } else {\n                low = min(low, N - (j - i + 1));\n            }\n        }\n\n        int high = 1 + max((stones[N - 1] - stones[1] + 1) - N,  // Move to right most\n                           (stones[N - 2] - stones[0] + 1) - N); // Move to left most\n        return {low, high};\n    }\n};",
        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> numMovesStonesII(vector<int>& stones) {\\n        sort(stones.begin(), stones.end());\\n\\n        int N = stones.size(), low = N;\\n        for (int i = 0, j = 0; j < N; ++j) {\\n            while (stones[j] - stones[i] + 1 > N) {\\n                ++i;\\n            }\\n            if (N - (j - i + 1) == 1 && N - (stones[j] - stones[i] + 1) == 1) {\\n                low = min(low, 2);\\n            } else {\\n                low = min(low, N - (j - i + 1));\\n            }\\n        }\\n\\n        int high = 1 + max((stones[N - 1] - stones[1] + 1) - N,  // Move to right most\\n                           (stones[N - 2] - stones[0] + 1) - N); // Move to left most\\n        return {low, high};\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "== and = confusion",
            "conditional statement error",
            "undefined methods",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    vector<int> numMovesStonesII(vector<int>& stones) {\n        sort(stones.begin(), stones.end());\n\n        int N = stones.size(), low = N;\n        vector<int> result;\n        for (int i = 0, j = 0; j < N; ++j) {\n            while (stones[j] - stones[i] + 1 > N) {\n                ++i;\n            }\n            if (N - (j - i + 1) = 1 && N - (stones[j] - stones[i] + 1) = 2) {  \n                low = calculateLow(low, 2);\n            } else {\n                low = calculateLow(low, N - (j - i + 1));\n            }\n        }\n\n        int high = 1 + max((stones[N - 1] - stones[1] + 1) - N,  \n                           (stones[N - 2] - stones[0] + 1) - N);  \n        return result;\n    }\n};\n"
    },
    {
        "slug": "reverse-odd-levels-of-binary-tree",
        "description": "Given the root of a perfect binary tree, reverse the node values at each odd level of the tree.\n\nFor example, suppose the node values at level 3 are [2,1,3,4,7,11,29,18], then it should become [18,29,11,7,4,3,1,2].\n\nReturn the root of the reversed tree.\nA binary tree is perfect if all parent nodes have two children and all leaves are on the same level.\nThe level of a node is the number of edges along the path between it and the root node.",
        "examples": [
            "Input: root = [2,3,5,8,13,21,34]\nOutput: [2,5,3,8,13,21,34]\nExplanation: \nThe tree has only one odd level.\nThe nodes at level 1 are 3, 5 respectively, which are reversed and become 5, 3.",
            "Input: root = [7,13,11]\nOutput: [7,11,13]\nExplanation: \nThe nodes at level 1 are 13, 11, which are reversed and become 11, 13.",
            "Input: root = [0,1,2,0,0,0,0,1,1,1,1,2,2,2,2]\nOutput: [0,2,1,0,0,0,0,2,2,2,2,1,1,1,1]\nExplanation: \nThe odd levels have non-zero values.\nThe nodes at level 1 were 1, 2, and are 2, 1 after the reversal.\nThe nodes at level 3 were 1, 1, 1, 1, 2, 2, 2, 2, and are 2, 2, 2, 2, 1, 1, 1, 1 after the reversal."
        ],
        "constraints": "The number of nodes in the tree is in the range [1, 214].\n0 <= Node.val <= 105\nroot is a perfect binary tree.",
        "oracle_code": "class Solution {\npublic:\n    TreeNode* reverseOddLevels(TreeNode* root) {\n        queue<TreeNode*> q;\n        q.push(root);\n        int x = 1,n,i,z;\n        vector<TreeNode*> tmp;\n        TreeNode* node;\n        while(!q.empty()){\n            tmp.clear();\n            n = q.size();\n            // cout<<n<<\" \";\n            while(n--){\n                node = q.front();q.pop();\n                // cout<<node->val<<\" \";\n                if(x==0){\n                    tmp.push_back(node);\n                }\n                if(node->left)\n                    q.push(node->left);\n                if(node->right){\n                    q.push(node->right);\n                }\n            }\n            n = tmp.size();\n            for(i = 0; i < n/2; i++){\n                z = tmp[i]->val;\n                tmp[i]->val = tmp[n-1-i]->val;\n                tmp[n-1-i]->val = z;\n            }\n            x ^= 1;\n            n = 0;\n        }\n        return root;\n    }\n};",
        "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* reverseOddLevels(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        int x = 1,n,i,z;\\n        vector<TreeNode*> tmp;\\n        TreeNode* node;\\n        while(!q.empty()){\\n            tmp.clear();\\n            n = q.size();\\n            // cout<<n<<\" \";\\n            while(n--){\\n                node = q.front();q.pop();\\n                // cout<<node->val<<\" \";\\n                if(x==0){\\n                    tmp.push_back(node);\\n                }\\n                if(node->left)\\n                    q.push(node->left);\\n                if(node->right){\\n                    q.push(node->right);\\n                }\\n            }\\n            n = tmp.size();\\n            for(i = 0; i < n/2; i++){\\n                z = tmp[i]->val;\\n                tmp[i]->val = tmp[n-1-i]->val;\\n                tmp[n-1-i]->val = z;\\n            }\\n            x ^= 1;\\n            n = 0;\\n        }\\n        return root;\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "statement separation",
            "indexing error",
            "wrong comment mark",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    TreeNode* reverseOddLevels(TreeNode* root) {\n        queue<TreeNode*> q;\n        q.push(root);\n        int x = 1,n,i,z;\n        vector<TreeNode*> tmp;\n        TreeNode* node;\n        TreeNode* undefinedNode;\n        while(!q.empty()){\n            tmp.clear();\n            n = q.size();\n            while(n--)node = q.front();q.pop();\n                if(x==0){\n                    tmp.push_back(undefinedNode);\n                }\n                if(node->left)\n                    q.push(node->left);\n                if(node->right){\n                    q.push(node->right);\n                }\n            n = tmp.size();\n            for(i = 0; i <= n/2; i++){\n                z = tmp[i]->val;\n                tmp[i]->val = tmp[n-1-i]->val;\n                tmp[n-1-i]->val = z;\n            }\n            x ^= 1;\n            n = 0;\n        }\n        return root;\n    }\n};\n"
    },
    {
        "slug": "shortest-path-with-alternating-colors",
        "description": "You are given an integer n, the number of nodes in a directed graph where the nodes are labeled from 0 to n - 1. Each edge is red or blue in this graph, and there could be self-edges and parallel edges.\nYou are given two arrays redEdges and blueEdges where:\n\nredEdges[i] = [ai, bi] indicates that there is a directed red edge from node ai to node bi in the graph, and\nblueEdges[j] = [uj, vj] indicates that there is a directed blue edge from node uj to node vj in the graph.\n\nReturn an array answer of length n, where each answer[x] is the length of the shortest path from node 0 to node x such that the edge colors alternate along the path, or -1 if such a path does not exist.",
        "examples": [
            "Input: n = 3, redEdges = [[0,1],[1,2]], blueEdges = []\nOutput: [0,1,-1]",
            "Input: n = 3, redEdges = [[0,1]], blueEdges = [[2,1]]\nOutput: [0,1,-1]"
        ],
        "constraints": "1 <= n <= 100\n0 <= redEdges.length,\u00a0blueEdges.length <= 400\nredEdges[i].length == blueEdges[j].length == 2\n0 <= ai, bi, uj, vj < n",
        "oracle_code": "class Solution {\npublic:\n    vector<int> shortestAlternatingPaths(int n,vector<vector<int>>&redEdges,vector<vector<int>>& blueEdges) \n    {\n        multiset<int>temp;\n        vector<multiset<int>>redchilds(n,temp),bluechilds(n,temp);\n        for(auto j:redEdges)\n        {\n            redchilds[j[0]].insert(j[1]);\n        }\n        for(auto j:blueEdges)\n        {\n            bluechilds[j[0]].insert(j[1]);\n        }\n        vector<int>ans;\n        for(int i=0;i<n;i++)\n        {\n            //BFS for all\n            vector<multiset<int>>reds=redchilds,blues=bluechilds;\n            queue<pair<char,int>>visit;\n            visit.push({'n',0});//neutral='n'\n            int steps=0;\n            while(!visit.empty())\n            {\n                bool justbreak=false;\n                int n=visit.size();\n                for(int j=0;j<n;j++)\n                {\n                    pair<char,int>x=visit.front();\n                    visit.pop();\n                    if(x.second==i)\n                    {\n                        ans.push_back(steps);\n                        justbreak=true;\n                        break;\n                    }\n                    if(x.first=='n')\n                    {\n                        for(auto j:reds[x.second])\n                        {\n                            visit.push({'r',j});\n                            auto itr1=reds[x.second].find(j);\n                            reds[x.second].erase(itr1);\n                        }\n                        for(auto j:blues[x.second])\n                        {\n                            visit.push({'b',j});//blue='b'\n                            auto itr1=blues[x.second].find(j);\n                            blues[x.second].erase(itr1);\n                        }\n                    }\n                    else if(x.first=='b')\n                    {\n                        for(auto j:reds[x.second])\n                        {\n                            visit.push({'r',j});//red='r'\n                            auto itr1=reds[x.second].find(j);\n                            reds[x.second].erase(itr1);\n                        }\n                    }\n                    else if(x.first=='r')\n                    {\n                        for(auto j:blues[x.second])\n                        {\n                            visit.push({'b',j});\n                            auto itr1=blues[x.second].find(j);\n                            blues[x.second].erase(itr1);\n                        }\n                    }\n                }\n                if(justbreak)\n                {\n                    break;\n                }\n                steps++;\n            }\n            if(i==ans.size())\n            {\n                ans.push_back(-1);\n            }\n        }\n        return ans;\n    }\n};",
        "content": "*E denotes number of Edges*\\n\\n# Complexity\\n- Time complexity:\\nO((N^2)+(N)*(E)*LOG(E))\\n\\n- Space complexity:\\nO(E)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> shortestAlternatingPaths(int n,vector<vector<int>>&redEdges,vector<vector<int>>& blueEdges) \\n    {\\n        multiset<int>temp;\\n        vector<multiset<int>>redchilds(n,temp),bluechilds(n,temp);\\n        for(auto j:redEdges)\\n        {\\n            redchilds[j[0]].insert(j[1]);\\n        }\\n        for(auto j:blueEdges)\\n        {\\n            bluechilds[j[0]].insert(j[1]);\\n        }\\n        vector<int>ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            //BFS for all\\n            vector<multiset<int>>reds=redchilds,blues=bluechilds;\\n            queue<pair<char,int>>visit;\\n            visit.push({\\'n\\',0});//neutral=\\'n\\'\\n            int steps=0;\\n            while(!visit.empty())\\n            {\\n                bool justbreak=false;\\n                int n=visit.size();\\n                for(int j=0;j<n;j++)\\n                {\\n                    pair<char,int>x=visit.front();\\n                    visit.pop();\\n                    if(x.second==i)\\n                    {\\n                        ans.push_back(steps);\\n                        justbreak=true;\\n                        break;\\n                    }\\n                    if(x.first==\\'n\\')\\n                    {\\n                        for(auto j:reds[x.second])\\n                        {\\n                            visit.push({\\'r\\',j});\\n                            auto itr1=reds[x.second].find(j);\\n                            reds[x.second].erase(itr1);\\n                        }\\n                        for(auto j:blues[x.second])\\n                        {\\n                            visit.push({\\'b\\',j});//blue=\\'b\\'\\n                            auto itr1=blues[x.second].find(j);\\n                            blues[x.second].erase(itr1);\\n                        }\\n                    }\\n                    else if(x.first==\\'b\\')\\n                    {\\n                        for(auto j:reds[x.second])\\n                        {\\n                            visit.push({\\'r\\',j});//red=\\'r\\'\\n                            auto itr1=reds[x.second].find(j);\\n                            reds[x.second].erase(itr1);\\n                        }\\n                    }\\n                    else if(x.first==\\'r\\')\\n                    {\\n                        for(auto j:blues[x.second])\\n                        {\\n                            visit.push({\\'b\\',j});\\n                            auto itr1=blues[x.second].find(j);\\n                            blues[x.second].erase(itr1);\\n                        }\\n                    }\\n                }\\n                if(justbreak)\\n                {\\n                    break;\\n                }\\n                steps++;\\n            }\\n            if(i==ans.size())\\n            {\\n                ans.push_back(-1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "== and = confusion",
            "wrong comment mark",
            "conditional statement error",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    vector<int> shortestAlternatingPaths(int n,vector<vector<int>>&redEdges,vector<vector<int>>& blueEdges) \n    {\n        multiset<int>temp;\n        vector<multiset<int>>redchilds(n,temp),bluechilds(n,temp);\n        for(auto j:redEdges)\n        {\n            redchilds[j[0]].insert(j[1]);\n        }\n        for(auto j:blueEdges)\n        {\n            bluechilds[j[0]].insert(j[1]);\n        }\n        vector<int>ans(n, -1);\n        for(int i=0;i<n;) \n        {\n            //BFS for all\n            vector<multiset<int>>reds=redchilds,blues=bluechilds;\n            queue<pair<char,int>>visit;\n            visit.push({'n',0});//neutral='n'\n            int steps=0;\n            while(!visit.empty())\n            {\n                bool justbreak=false;\n                int n=visit.size();\n                for(int j=0;j<n;j++)\n                {\n                    pair<char,int>x=visit.front();\n                    \n                    if(x.second=i)\n                    {\n                        ans[i]=steps;\n                        justbreak=true;\n                        break;\n                    }\n                    if(x.first=='n' || x.first == ans[i] % 2 + '0') \n                    {\n                        for(auto j:reds[x.second])\n                        {\n                            visit.push({'r',j});\n                            auto itr1=reds[x.second].find(j);\n                            reds[x.second].erase(itr1);\n                        }\n                        for(auto j:blues[x.second])\n                        {\n                            visit.push({'b',j});//blue='b'\n                            auto itr1=blues[x.second].find(j);\n                            unknownFunction(itr1); \n                            blues[x.second].erase(itr1);\n                        }\n                    }\n                    else if(x.first=='b')\n                    {\n                        for(auto j:reds[x.second])\n                        {\n                            visit.push({'r',j});//red='r'\n                            auto itr1=reds[x.second].find(j);\n                            reds[x.second].erase(itr1);\n                        }\n                    }\n                    else if(x.first=='r')\n                    {\n                        for(auto j:blues[x.second])\n                        {\n                            visit.push({'b',j});\n                            auto itr1=blues[x.second].find(j);\n                            blues[x.second].erase(itr1);\n                        }\n                    }\n                }\n                if(justbreak)\n                {\n                    break;\n                }\n                steps++;\n            }\n        }\n        return ans;\n    }\n};\n"
    },
    {
        "slug": "lru-cache",
        "description": "Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.\nImplement the LRUCache class:\n\nLRUCache(int capacity) Initialize the LRU cache with positive size capacity.\nint get(int key) Return the value of the key if the key exists, otherwise return -1.\nvoid put(int key, int value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key.\n\nThe functions get and put must each run in O(1) average time complexity.",
        "examples": [
            "Input\n[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"]\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\nOutput\n[null, null, null, 1, null, -1, null, -1, 3, 4]\n\nExplanation\nLRUCache lRUCache = new LRUCache(2);\nlRUCache.put(1, 1); // cache is {1=1}\nlRUCache.put(2, 2); // cache is {1=1, 2=2}\nlRUCache.get(1);    // return 1\nlRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}\nlRUCache.get(2);    // returns -1 (not found)\nlRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}\nlRUCache.get(1);    // return -1 (not found)\nlRUCache.get(3);    // return 3\nlRUCache.get(4);    // return 4"
        ],
        "constraints": "1 <= capacity <= 3000\n0 <= key <= 104\n0 <= value <= 105\nAt most 2 * 105 calls will be made to get and put.",
        "oracle_code": "class LRUCache {\npublic:\nclass node\n{\n  public:\n  int key;\n  int val;\n  node* next;\n  node* prev;\n  node(int _key,int _val)\n  {\n    key = _key;\n    val = _val;\n  }\n};\nnode* head = new node(-1,-1);\nnode* tail = new node(-1,-1);\n\nint size;\nunordered_map<int,node*>mpp;\n    LRUCache(int capacity) {\n       size = capacity; \n       head->next = tail;\n       tail->prev = head;  \n    }\n\n    void addNode(node* newNode){\n       \n       node* temp = head->next;\n       newNode->next = temp;\n       newNode->prev = head;\n       head->next = newNode;\n       temp->prev = newNode;\n    }\n\n    void deleteNode(node* delNode){\n         \n       node* delprev = delNode->prev;\n       node* delnext = delNode->next;\n       delprev->next = delnext;\n       delnext->prev = delprev;\n    }\n    \n    int get(int _key) {\n        \n        if(mpp.count(_key))\n        {\n          node* nde = mpp[_key];\n          int curr = nde->val;\n          mpp.erase(_key);\n          deleteNode(nde);\n          addNode(nde);\n          mpp[_key] = head->next;\n          return curr;\n        }\n        return -1;\n    }\n    \n    void put(int _key, int value) {\n        \n        if(mpp.count(_key))\n        {\n           node* nde = mpp[_key];\n           mpp.erase(_key);\n           deleteNode(nde);\n        }\n        if(mpp.size()==size)\n        {\n           mpp.erase(tail->prev->key);\n           deleteNode(tail->prev);\n        }\n        addNode(new node(_key,value));\n        mpp[_key] = head->next;\n    }\n};",
        "content": "# PLEASE DO UPVOTE!!!!!\\n\\n**CONNECT WITH ME ON LINKEDIN :  https://www.linkedin.com/in/md-kamran-55b98521a/**\\n\\n## INTUITION\\nTo Implement LRU(Least recently used), we need to have a track of the usage of the keys, in the order of there usage, as we have a limited capacity we cant extend our capacity beyond \"capacity\", so we always we will take out those values which has\\'nt been acccess in the recent time.So, we have to think of something that can kind of sort our keys according to usage on the go, the best Data Structure for this purpose is Doubly linked List.\\n                             A Doubly linked list will have a Head node as well as a tail node, and whenever a key is used we will place it just next to the head node,in this fashions, the one\\'s which are closer to head are the most recently used ones, and as we go closer to the tail node, those are the less recently used ones while the node just previous to tail is the \"LEAST RECENTLY USED\". \\nSo whenever we add a key or use a key(get()), we will move it right after the head node, and whenever we call the (put() function), if size if greater we have to delete the LRU node, if key is not present, (if present then too we will delete that node so as to update the value and still move it right after head node), and place new node right after head node.                        \\n\\n\\n**Ask Furthur Doubts in the Comment Section**\\n# Code\\n```\\nclass LRUCache {\\npublic:\\nclass node\\n{\\n  public:\\n  int key;\\n  int val;\\n  node* next;\\n  node* prev;\\n  node(int _key,int _val)\\n  {\\n    key = _key;\\n    val = _val;\\n  }\\n};\\nnode* head = new node(-1,-1);\\nnode* tail = new node(-1,-1);\\n\\nint size;\\nunordered_map<int,node*>mpp;\\n    LRUCache(int capacity) {\\n       size = capacity; \\n       head->next = tail;\\n       tail->prev = head;  \\n    }\\n\\n    void addNode(node* newNode){\\n       \\n       node* temp = head->next;\\n       newNode->next = temp;\\n       newNode->prev = head;\\n       head->next = newNode;\\n       temp->prev = newNode;\\n    }\\n\\n    void deleteNode(node* delNode){\\n         \\n       node* delprev = delNode->prev;\\n       node* delnext = delNode->next;\\n       delprev->next = delnext;\\n       delnext->prev = delprev;\\n    }\\n    \\n    int get(int _key) {\\n        \\n        if(mpp.count(_key))\\n        {\\n          node* nde = mpp[_key];\\n          int curr = nde->val;\\n          mpp.erase(_key);\\n          deleteNode(nde);\\n          addNode(nde);\\n          mpp[_key] = head->next;\\n          return curr;\\n        }\\n        return -1;\\n    }\\n    \\n    void put(int _key, int value) {\\n        \\n        if(mpp.count(_key))\\n        {\\n           node* nde = mpp[_key];\\n           mpp.erase(_key);\\n           deleteNode(nde);\\n        }\\n        if(mpp.size()==size)\\n        {\\n           mpp.erase(tail->prev->key);\\n           deleteNode(tail->prev);\\n        }\\n        addNode(new node(_key,value));\\n        mpp[_key] = head->next;\\n    }\\n};\\n\\n```\\n![b62ab1be-232a-438f-9524-7d8ca4dbd5fe_1675328166.1161866.png](https://assets.leetcode.com/users/images/8d5343b1-0eb4-4111-a914-40ce968fd034_1675389764.2273676.png)",
        "level": "medium",
        "type": [
            "undefined methods",
            "variable value error",
            "colon missing",
            "undefined objects"
        ],
        "buggy_code": "\nclass LRUCache {\npublic:\nclass node\n{\n  public:\n  int key;\n  int val;\n  node* next;\n  node* prev;\n  node(int _key,int _val)\n  {\n    key = _key;\n    val = _val;\n  }\n};\nnode* head = nullptr;\nnode* tail = nullptr;\n\nint size;\nunordered_map<int,node*>mpp;\n    LRUCache(int capacity) {\n       size = capacity; \n       head->next = tail;\n       tail->prev = head;  \n    }\n\n    void addNode(node* newNode){\n       \n       node* temp = head->next;\n       newNode->next = temp;\n       newNode->prev = head;\n       head->next = newNode;\n    }\n\n    void deleteNode(node* delNode){\n         \n       node* delprev = delNode->prev;\n       node* delnext = delNode->next;\n       delprev->next = delnext;\n       delnext->prev = delprev;\n    }\n    \n    int get(int _key) {\n        \n        if(mpp.count(_key))\n        {\n          node* nde = mpp[_key];\n          int curr = nde->val;\n          mpp.erase(_key);\n          deleteNode(nde);\n          addNode(nde)\n          mpp[_key] = head->next;\n          return curr;\n        }\n        return -1;\n    }\n\n}; \ntil\n\n\n"
    },
    {
        "slug": "check-if-there-is-a-valid-path-in-a-grid",
        "description": "You are given an m x n grid. Each cell of grid represents a street. The street of grid[i][j] can be:\n\n1 which means a street connecting the left cell and the right cell.\n2 which means a street connecting the upper cell and the lower cell.\n3 which means a street connecting the left cell and the lower cell.\n4 which means a street connecting the right cell and the lower cell.\n5 which means a street connecting the left cell and the upper cell.\n6 which means a street connecting the right cell and the upper cell.\n\n\nYou will initially start at the street of the upper-left cell (0, 0). A valid path in the grid is a path that starts from the upper left cell (0, 0) and ends at the bottom-right cell (m - 1, n - 1). The path should only follow the streets.\nNotice that you are not allowed to change any street.\nReturn true if there is a valid path in the grid or false otherwise.",
        "examples": [
            "Input: grid = [[2,4,3],[6,5,2]]\nOutput: true\nExplanation: As shown you can start at cell (0, 0) and visit all the cells of the grid to reach (m - 1, n - 1).",
            "Input: grid = [[1,2,1],[1,2,1]]\nOutput: false\nExplanation: As shown you the street at cell (0, 0) is not connected with any street of any other cell and you will get stuck at cell (0, 0)",
            "Input: grid = [[1,1,2]]\nOutput: false\nExplanation: You will get stuck at cell (0, 1) and you cannot reach cell (0, 2)."
        ],
        "constraints": "m == grid.length\nn == grid[i].length\n1 <= m, n <= 300\n1 <= grid[i][j] <= 6",
        "oracle_code": "class DisjointSet{\npublic:\n    vector<int>par,size;\n    DisjointSet(int n){\n        par.resize(n+1);\n        size.resize(n+1,1);\n        for(int i=0; i<=n; i++){\n            par[i] = i;\n        }\n    }\n    int findpar(int u){\n        if(u == par[u]) return u;\n        return par[u] = findpar(par[u]);\n    }\n\n    void unionBySize(int u, int v){\n        u = findpar(u);\n        v = findpar(v);\n\n        if(u == v) return;\n\n        if(size[u] >= size[v]){\n            par[v] = u;\n            size[u] += size[v];\n        }\n        else{\n            par[u] = v;\n            size[v] += size[u];\n        }\n    }\n    \n};\nclass Solution {\npublic:\n    bool hasValidPath(vector<vector<int>>& grid) {\n        int n = grid.size();\n        int m = grid[0].size();\n        DisjointSet ds(n*m);\n        for(int i=0; i<n; i++){\n            for(int j=0; j<m; j++){\n                int p = i * m + j;\n                int p1 = (i-1)*m + j;  // 1\n                int p2 = (i+1)*m + j;  // 1\n                int p3 = i*m + (j+1);  // 2\n                int p4 = i*m + (j-1);  // 2\n\n                if(grid[i][j] == 1){\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\n                        ds.unionBySize(p,p3);\n                    }\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\n                        ds.unionBySize(p,p4);\n                    }\n                }\n                else if(grid[i][j] == 2){\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\n                        ds.unionBySize(p,p2);\n                    }\n\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\n                        ds.unionBySize(p,p1);\n                    }\n                }\n                else if(grid[i][j] == 3){\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\n                        ds.unionBySize(p,p4);\n                    }\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\n                        ds.unionBySize(p,p2);\n                    }\n                }\n                else if(grid[i][j] == 4){\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\n                        ds.unionBySize(p,p3);\n                    }\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\n                        ds.unionBySize(p,p2);\n                    }\n                }\n                else if(grid[i][j] == 5){\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\n                        ds.unionBySize(p,p1);\n                    }\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\n                        ds.unionBySize(p,p4);\n                    }\n                }\n                else if(grid[i][j] == 6){\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\n                        ds.unionBySize(p,p1);\n                    }\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\n                        ds.unionBySize(p,p3);\n                    }\n                }\n            }\n        }\n        return ds.findpar(0) == ds.findpar(n*m-1);\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass DisjointSet{\\npublic:\\n    vector<int>par,size;\\n    DisjointSet(int n){\\n        par.resize(n+1);\\n        size.resize(n+1,1);\\n        for(int i=0; i<=n; i++){\\n            par[i] = i;\\n        }\\n    }\\n    int findpar(int u){\\n        if(u == par[u]) return u;\\n        return par[u] = findpar(par[u]);\\n    }\\n\\n    void unionBySize(int u, int v){\\n        u = findpar(u);\\n        v = findpar(v);\\n\\n        if(u == v) return;\\n\\n        if(size[u] >= size[v]){\\n            par[v] = u;\\n            size[u] += size[v];\\n        }\\n        else{\\n            par[u] = v;\\n            size[v] += size[u];\\n        }\\n    }\\n    \\n};\\nclass Solution {\\npublic:\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        DisjointSet ds(n*m);\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                int p = i * m + j;\\n                int p1 = (i-1)*m + j;  // 1\\n                int p2 = (i+1)*m + j;  // 1\\n                int p3 = i*m + (j+1);  // 2\\n                int p4 = i*m + (j-1);  // 2\\n\\n                if(grid[i][j] == 1){\\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\\n                        ds.unionBySize(p,p3);\\n                    }\\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\\n                        ds.unionBySize(p,p4);\\n                    }\\n                }\\n                else if(grid[i][j] == 2){\\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\\n                        ds.unionBySize(p,p2);\\n                    }\\n\\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\\n                        ds.unionBySize(p,p1);\\n                    }\\n                }\\n                else if(grid[i][j] == 3){\\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\\n                        ds.unionBySize(p,p4);\\n                    }\\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\\n                        ds.unionBySize(p,p2);\\n                    }\\n                }\\n                else if(grid[i][j] == 4){\\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\\n                        ds.unionBySize(p,p3);\\n                    }\\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\\n                        ds.unionBySize(p,p2);\\n                    }\\n                }\\n                else if(grid[i][j] == 5){\\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\\n                        ds.unionBySize(p,p1);\\n                    }\\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\\n                        ds.unionBySize(p,p4);\\n                    }\\n                }\\n                else if(grid[i][j] == 6){\\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\\n                        ds.unionBySize(p,p1);\\n                    }\\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\\n                        ds.unionBySize(p,p3);\\n                    }\\n                }\\n            }\\n        }\\n        return ds.findpar(0) == ds.findpar(n*m-1);\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "indexing error",
            "wrong comment mark",
            "variable value error",
            "parentheses mismatch"
        ],
        "buggy_code": "\n\nclass DisjointSet{\npublic:\n    vector<int>par,size;\n    DisjointSet(int n){\n        par.resize(n+1);\n        size.resize(n+1,1);\n        for(int i=0; i<=n; i++){\n            par[i] = i;\n        }\n    }\n    int findpar(int u){\n        return par[u] = findpar(par[u]); \n    }\n\n    void unionBySize(int u, int v){\n        u = findpar(u);\n        v = findpar(v);\n\n        if(u == v) return;\n\n        if(size[u-1] >= size[v-1]){\n            par[v-1] = v;\n            size[u] += size[v];\n        }\n        else{\n            par[u-1] = u-1;\n            size[v-1] += size[u];\n        }\n    }\n    \n};\nclass Solution {\npublic:\n    bool hasValidPath(vector<vector<int>>& grid) {\n        int n = grid.size();\n        int m = grid[0].size();\n        DisjointSet ds(n*m);\n        for(int i=0; i<n; i++){\n            for(int j=0; j<m; j++){\n                int p = i * m + j;\n                int p1 = (i-1)*m + j;  \n                int p2 = (i+1)*m + j;  \n                int p3 = i*m + (j+1);  \n                int p4 = i*m + (j-1);  \n\n                if(grid[i][j] == 1){\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\n                        ds.unionBySize(p,p3);\n                    }\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\n                        ds.unionBySize(p,p4);\n                    }\n                }\n                else if(grid[i][j] == 2){\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\n                        ds.unionBySize(p,p2);\n                    }\n\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\n                        ds.unionBySize(p,p1);\n                    }\n                }\n                else if(grid[i][j] == 3){\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\n                        ds.unionBySize(p,p4);\n                    }\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\n                        ds.unionBySize(p,p2);\n                    }\n                }\n                else if(grid[i][j] == 4){\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\n                        ds.unionBySize(p,p3);\n                    }\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\n                        ds.unionBySize(p,p2);\n                    }\n                }\n                else if(grid[i][j] == 5){\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\n                        ds.unionBySize(p,p1);\n                    }\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\n                        ds.unionBySize(p,p4);\n                    }\n                }\n                else if(grid[i][j] == 6){\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\n                        ds.unionBySize(p,p1);\n                    }\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\n                        ds.unionBySize(p,p3);\n                    }\n                }\n            }\n        }\n        return ds.findpar(0) == ds.findpar(n*m-1);\n    }\n};\n\n"
    },
    {
        "slug": "factorial-trailing-zeroes",
        "description": "Given an integer n, return the number of trailing zeroes in n!.\nNote that n! = n * (n - 1) * (n - 2) * ... * 3 * 2 * 1.",
        "examples": [
            "Input: n = 3\nOutput: 0\nExplanation: 3! = 6, no trailing zero.",
            "Input: n = 5\nOutput: 1\nExplanation: 5! = 120, one trailing zero.",
            "Input: n = 0\nOutput: 0"
        ],
        "constraints": "0 <= n <= 104",
        "oracle_code": "class Solution {\npublic:\n    unordered_map<long long int,long long int>mp;\n    int trailingZeroes(int n) {\n        for(int i=n;i>=1;i--)\n         fun(i);\n         \n\t\t return min(mp[2],mp[5]); \n    }\n     void fun(int n)\n    {\n         for(int i=2;i*i<=n;i++)\n         {\n         \twhile((n%i) == 0)\n         \t{\n         \t    mp[i]++;\n\t\t\t\tn = n / i;\t\n\t\t\t}\n\t\t }\n\t\t if(n > 1)\n\t\t mp[n]++;\n    }\n};",
        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    unordered_map<long long int,long long int>mp;\\n    int trailingZeroes(int n) {\\n        for(int i=n;i>=1;i--)\\n         fun(i);\\n         \\n\\t\\t return min(mp[2],mp[5]); \\n    }\\n     void fun(int n)\\n    {\\n         for(int i=2;i*i<=n;i++)\\n         {\\n         \\twhile((n%i) == 0)\\n         \\t{\\n         \\t    mp[i]++;\\n\\t\\t\\t\\tn = n / i;\\t\\n\\t\\t\\t}\\n\\t\\t }\\n\\t\\t if(n > 1)\\n\\t\\t mp[n]++;\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "statement separation",
            "wrong comment mark",
            "colon missing",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    unordered_map<long long int,long long int>mp\n    int trailingZeroes(int n) {\n        for(int i=n;i>=1;i--);\n        \n         \n\t\t Solution s;\n\t\t return s.min(mp[2],mp[5]); \n    }\n     void fun(int n)\n    {\n         for(int i=2;i*i<=n;i++)\n         {\n         \twhile((n%i) == 0)\n         \t{\n         \t    mp[i]++;\n\t\t\t\tn = n / i;\t\n\t\t\t}\n\t\t }\n\t\t if(n > 1)\n\t\t mp[n]++;\n    }\n};\n"
    },
    {
        "slug": "largest-substring-between-two-equal-characters",
        "description": "Given a string s, return the length of the longest substring between two equal characters, excluding the two characters. If there is no such substring return -1.\nA substring is a contiguous sequence of characters within a string.",
        "examples": [
            "Input: s = \"aa\"\nOutput: 0\nExplanation: The optimal substring here is an empty substring between the two 'a's.",
            "Input: s = \"abca\"\nOutput: 2\nExplanation: The optimal substring here is \"bc\".",
            "Input: s = \"cbzxy\"\nOutput: -1\nExplanation: There are no characters that appear twice in s."
        ],
        "constraints": "1 <= s.length <= 300\ns contains only lowercase English letters.",
        "oracle_code": "class Solution {\npublic:\n    int maxLengthBetweenEqualCharacters(string s) {\n        int v[26];\n        memset(v,-1,sizeof v);\n        int ans=-1;\n        for(int i=0;i<s.size();i++){\n            if(v[s[i]-'a']==-1){\n                v[s[i]-'a']=i;\n            }\n            int res=i-v[s[i]-'a']-1;\n            ans=max(ans,res);\n        }\n        return ans;\n    }\n};",
        "content": "# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxLengthBetweenEqualCharacters(string s) {\\n        int v[26];\\n        memset(v,-1,sizeof v);\\n        int ans=-1;\\n        for(int i=0;i<s.size();i++){\\n            if(v[s[i]-\\'a\\']==-1){\\n                v[s[i]-\\'a\\']=i;\\n            }\\n            int res=i-v[s[i]-\\'a\\']-1;\\n            ans=max(ans,res);\\n        }\\n        return ans;\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "statement separation",
            "wrong comment mark",
            "unclosed string",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    int maxLengthBetweenEqualCharacters(string s) {\n        int v[26];\n        memset(v,-1,sizeof v);\n        int ans=-1;\n        /*for(int i=0;i<=s.size();i++)*/\n            if(v[s[i]-'a']==-1)\n                v[s[i]-'a' \"=i;\n            int res=i-v[s[i]-'a']-1;\n            ans=max(ans,res);\n        return ans;\n    }\n};\n\n\n\n"
    },
    {
        "slug": "check-knight-tour-configuration",
        "description": "There is a knight on an n x n chessboard. In a valid configuration, the knight starts at the top-left cell of the board and visits every cell on the board exactly once.\nYou are given an n x n integer matrix grid consisting of distinct integers from the range [0, n * n - 1] where grid[row][col] indicates that the cell (row, col) is the grid[row][col]th cell that the knight visited. The moves are 0-indexed.\nReturn true if grid represents a valid configuration of the knight's movements or false otherwise.\nNote that a valid knight move consists of moving two squares vertically and one square horizontally, or two squares horizontally and one square vertically. The figure below illustrates all the possible eight moves of a knight from some cell.",
        "examples": [
            "Input: grid = [[0,11,16,5,20],[17,4,19,10,15],[12,1,8,21,6],[3,18,23,14,9],[24,13,2,7,22]]\nOutput: true\nExplanation: The above diagram represents the grid. It can be shown that it is a valid configuration.",
            "Input: grid = [[0,3,6],[5,8,1],[2,7,4]]\nOutput: false\nExplanation: The above diagram represents the grid. The 8th move of the knight is not valid considering its position after the 7th move."
        ],
        "constraints": "n == grid.length == grid[i].length\n3 <= n <= 7\n0 <= grid[row][col] < n * n\nAll integers in grid are unique.",
        "oracle_code": "class Solution {\nprivate:\n    bool helper(vector<vector<int>>& grid, int row, int col, int num){\n        int n = grid.size();\n        if(num == n*n) return true;\n        int i = row-2;\n        int j = col+1;\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row-2;\n        j = col-1;\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 2;\n        j = col - 1;\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 2;\n        j = col + 1;\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 1;\n        j = col + 2;\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row - 1;\n        j = col + 2;\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row - 1;\n        j = col - 2;\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 1;\n        j = col - 2;\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        return false;\n    }\npublic:\n    bool checkValidGrid(vector<vector<int>>& grid) {\n        ios::sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);\n        if(grid[0][0] != 0) return false;\n        return helper(grid,0,0,1);\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    bool helper(vector<vector<int>>& grid, int row, int col, int num){\\n        int n = grid.size();\\n        if(num == n*n) return true;\\n        int i = row-2;\\n        int j = col+1;\\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row-2;\\n        j = col-1;\\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row + 2;\\n        j = col - 1;\\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row + 2;\\n        j = col + 1;\\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row + 1;\\n        j = col + 2;\\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row - 1;\\n        j = col + 2;\\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row - 1;\\n        j = col - 2;\\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row + 1;\\n        j = col - 2;\\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        return false;\\n    }\\npublic:\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(0);\\n        cout.tie(0);\\n        if(grid[0][0] != 0) return false;\\n        return helper(grid,0,0,1);\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "== and = confusion",
            "operation error",
            "undefined keywords from other languages",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution {\nprivate:\n    bool helper(vector<vector<int>>& grid, int row, int col, int num){\n        int n = grid.size();\n\n        undefinedObject test;  \n\n        if(num = n*n) return true;\n        int i = row-2;\n        int j = col+1;\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row-2;\n        j = col-1;\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+2);\n\n        i = row + 2;\n        j = col - 1;\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 2;\n        j = col + 1;\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 1;\n        j = col + 2;\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row - 1;\n        j = col + 2;\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row - 1;\n        j = col - 2;\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 1;\n        j = col - 2;\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        return false;\n    }\npublic:\n    bool checkValidGrid(vector<vector<int>>& grid) {\n        sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);\n        if(grid[0][0] != 0) return false;\n        return helper(grid,0,0,1);\n    }\n};\n"
    },
    {
        "slug": "factorial-trailing-zeroes",
        "description": "Given an integer n, return the number of trailing zeroes in n!.\nNote that n! = n * (n - 1) * (n - 2) * ... * 3 * 2 * 1.",
        "examples": [
            "Input: n = 3\nOutput: 0\nExplanation: 3! = 6, no trailing zero.",
            "Input: n = 5\nOutput: 1\nExplanation: 5! = 120, one trailing zero.",
            "Input: n = 0\nOutput: 0"
        ],
        "constraints": "0 <= n <= 104",
        "oracle_code": "class Solution {\npublic:\n    unordered_map<long long int,long long int>mp;\n    int trailingZeroes(int n) {\n        for(int i=n;i>=1;i--)\n         fun(i);\n         \n\t\t return min(mp[2],mp[5]); \n    }\n     void fun(int n)\n    {\n         for(int i=2;i*i<=n;i++)\n         {\n         \twhile((n%i) == 0)\n         \t{\n         \t    mp[i]++;\n\t\t\t\tn = n / i;\t\n\t\t\t}\n\t\t }\n\t\t if(n > 1)\n\t\t mp[n]++;\n    }\n};",
        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    unordered_map<long long int,long long int>mp;\\n    int trailingZeroes(int n) {\\n        for(int i=n;i>=1;i--)\\n         fun(i);\\n         \\n\\t\\t return min(mp[2],mp[5]); \\n    }\\n     void fun(int n)\\n    {\\n         for(int i=2;i*i<=n;i++)\\n         {\\n         \\twhile((n%i) == 0)\\n         \\t{\\n         \\t    mp[i]++;\\n\\t\\t\\t\\tn = n / i;\\t\\n\\t\\t\\t}\\n\\t\\t }\\n\\t\\t if(n > 1)\\n\\t\\t mp[n]++;\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "statement separation",
            "operation error",
            "wrong comment mark",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    unordered_map<long long int,long long int>mp;\n    int trailingZeroes(int n) {\n        for(int i=n;i>=1;i--)\n         fun(i);\n         \n\t\t Solution s;\n\t\t return s.max(mp[2],mp[5]); \n    }\n     void fun(int n)\n    {\n         for(int i=2;i*i<=n;i++)\n         {\n         \twhile((n%i) == 0)\n         \t{\n         \t    mp[i]++;\n\t\t\t\tn = n / i;\t\n\t\t\t}\n\t\t }\n\t\t if(n > 1)\n\t\t mp[n]++;\n    }\n};\n"
    },
    {
        "slug": "binary-string-with-substrings-representing-1-to-n",
        "description": "Given a binary string s and a positive integer n, return true if the binary representation of all the integers in the range [1, n] are substrings of s, or false otherwise.\nA substring is a contiguous sequence of characters within a string.",
        "examples": [
            "Input: s = \"0110\", n = 3\nOutput: true",
            "Input: s = \"0110\", n = 4\nOutput: false"
        ],
        "constraints": "1 <= s.length <= 1000\ns[i] is either '0' or '1'.\n1 <= n <= 109",
        "oracle_code": "class Solution {\npublic:\n    bool queryString(string s, int n)\n     {\n        unordered_set<int> seen;\n        int len = s.length();\n        for(int i=len-1;i>=0;i--)\n        {\n            int num = 0;\n            for(int j=1;j<=min(len-i,31);j++)\n            { \n                num = num*2 + (s[i+j-1] == '1' ? 1 : 0);\n                if(0 < num && num <= n) seen.insert(num);\n            }\n            if(seen.size() == n) return true;\n        }\n        return false;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool queryString(string s, int n)\\n     {\\n        unordered_set<int> seen;\\n        int len = s.length();\\n        for(int i=len-1;i>=0;i--)\\n        {\\n            int num = 0;\\n            for(int j=1;j<=min(len-i,31);j++)\\n            { \\n                num = num*2 + (s[i+j-1] == \\'1\\' ? 1 : 0);\\n                if(0 < num && num <= n) seen.insert(num);\\n            }\\n            if(seen.size() == n) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "unclosed string",
            "conditional statement error",
            "undefined methods",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    bool queryString(string s, int n)\n     {\n        unordered_set<int> seen;\n        int len = s.length();\n        bool doesNotExist;\n        string temp = s + doesNotExist;\n        for(int i=len-1;i>=0;i--)\n        {\n            int num = 0;\n            for(int j=1;j<=min(len-i,31);j++)\n            { \n                num = num*2 + (temp[i+j-1] == \"1\" ? 1 : 0);\n                if(0 < num && num <= n) seen.insert(num);\n             }\n            if(seen.size() != n) return true;\n        }\n        return isAllNumbersSeen();\n    }\n    \n    bool isAllNumbersSeen()\n    {\n        \n    }\n};\n"
    },
    {
        "slug": "lru-cache",
        "description": "Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.\nImplement the LRUCache class:\n\nLRUCache(int capacity) Initialize the LRU cache with positive size capacity.\nint get(int key) Return the value of the key if the key exists, otherwise return -1.\nvoid put(int key, int value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key.\n\nThe functions get and put must each run in O(1) average time complexity.",
        "examples": [
            "Input\n[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"]\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\nOutput\n[null, null, null, 1, null, -1, null, -1, 3, 4]\n\nExplanation\nLRUCache lRUCache = new LRUCache(2);\nlRUCache.put(1, 1); // cache is {1=1}\nlRUCache.put(2, 2); // cache is {1=1, 2=2}\nlRUCache.get(1);    // return 1\nlRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}\nlRUCache.get(2);    // returns -1 (not found)\nlRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}\nlRUCache.get(1);    // return -1 (not found)\nlRUCache.get(3);    // return 3\nlRUCache.get(4);    // return 4"
        ],
        "constraints": "1 <= capacity <= 3000\n0 <= key <= 104\n0 <= value <= 105\nAt most 2 * 105 calls will be made to get and put.",
        "oracle_code": "class LRUCache {\npublic:\nclass node\n{\n  public:\n  int key;\n  int val;\n  node* next;\n  node* prev;\n  node(int _key,int _val)\n  {\n    key = _key;\n    val = _val;\n  }\n};\nnode* head = new node(-1,-1);\nnode* tail = new node(-1,-1);\n\nint size;\nunordered_map<int,node*>mpp;\n    LRUCache(int capacity) {\n       size = capacity; \n       head->next = tail;\n       tail->prev = head;  \n    }\n\n    void addNode(node* newNode){\n       \n       node* temp = head->next;\n       newNode->next = temp;\n       newNode->prev = head;\n       head->next = newNode;\n       temp->prev = newNode;\n    }\n\n    void deleteNode(node* delNode){\n         \n       node* delprev = delNode->prev;\n       node* delnext = delNode->next;\n       delprev->next = delnext;\n       delnext->prev = delprev;\n    }\n    \n    int get(int _key) {\n        \n        if(mpp.count(_key))\n        {\n          node* nde = mpp[_key];\n          int curr = nde->val;\n          mpp.erase(_key);\n          deleteNode(nde);\n          addNode(nde);\n          mpp[_key] = head->next;\n          return curr;\n        }\n        return -1;\n    }\n    \n    void put(int _key, int value) {\n        \n        if(mpp.count(_key))\n        {\n           node* nde = mpp[_key];\n           mpp.erase(_key);\n           deleteNode(nde);\n        }\n        if(mpp.size()==size)\n        {\n           mpp.erase(tail->prev->key);\n           deleteNode(tail->prev);\n        }\n        addNode(new node(_key,value));\n        mpp[_key] = head->next;\n    }\n};",
        "content": "# PLEASE DO UPVOTE!!!!!\\n\\n**CONNECT WITH ME ON LINKEDIN :  https://www.linkedin.com/in/md-kamran-55b98521a/**\\n\\n## INTUITION\\nTo Implement LRU(Least recently used), we need to have a track of the usage of the keys, in the order of there usage, as we have a limited capacity we cant extend our capacity beyond \"capacity\", so we always we will take out those values which has\\'nt been acccess in the recent time.So, we have to think of something that can kind of sort our keys according to usage on the go, the best Data Structure for this purpose is Doubly linked List.\\n                             A Doubly linked list will have a Head node as well as a tail node, and whenever a key is used we will place it just next to the head node,in this fashions, the one\\'s which are closer to head are the most recently used ones, and as we go closer to the tail node, those are the less recently used ones while the node just previous to tail is the \"LEAST RECENTLY USED\". \\nSo whenever we add a key or use a key(get()), we will move it right after the head node, and whenever we call the (put() function), if size if greater we have to delete the LRU node, if key is not present, (if present then too we will delete that node so as to update the value and still move it right after head node), and place new node right after head node.                        \\n\\n\\n**Ask Furthur Doubts in the Comment Section**\\n# Code\\n```\\nclass LRUCache {\\npublic:\\nclass node\\n{\\n  public:\\n  int key;\\n  int val;\\n  node* next;\\n  node* prev;\\n  node(int _key,int _val)\\n  {\\n    key = _key;\\n    val = _val;\\n  }\\n};\\nnode* head = new node(-1,-1);\\nnode* tail = new node(-1,-1);\\n\\nint size;\\nunordered_map<int,node*>mpp;\\n    LRUCache(int capacity) {\\n       size = capacity; \\n       head->next = tail;\\n       tail->prev = head;  \\n    }\\n\\n    void addNode(node* newNode){\\n       \\n       node* temp = head->next;\\n       newNode->next = temp;\\n       newNode->prev = head;\\n       head->next = newNode;\\n       temp->prev = newNode;\\n    }\\n\\n    void deleteNode(node* delNode){\\n         \\n       node* delprev = delNode->prev;\\n       node* delnext = delNode->next;\\n       delprev->next = delnext;\\n       delnext->prev = delprev;\\n    }\\n    \\n    int get(int _key) {\\n        \\n        if(mpp.count(_key))\\n        {\\n          node* nde = mpp[_key];\\n          int curr = nde->val;\\n          mpp.erase(_key);\\n          deleteNode(nde);\\n          addNode(nde);\\n          mpp[_key] = head->next;\\n          return curr;\\n        }\\n        return -1;\\n    }\\n    \\n    void put(int _key, int value) {\\n        \\n        if(mpp.count(_key))\\n        {\\n           node* nde = mpp[_key];\\n           mpp.erase(_key);\\n           deleteNode(nde);\\n        }\\n        if(mpp.size()==size)\\n        {\\n           mpp.erase(tail->prev->key);\\n           deleteNode(tail->prev);\\n        }\\n        addNode(new node(_key,value));\\n        mpp[_key] = head->next;\\n    }\\n};\\n\\n```\\n![b62ab1be-232a-438f-9524-7d8ca4dbd5fe_1675328166.1161866.png](https://assets.leetcode.com/users/images/8d5343b1-0eb4-4111-a914-40ce968fd034_1675389764.2273676.png)",
        "level": "medium",
        "type": [
            "wrong comment mark",
            "undefined methods",
            "colon missing",
            "undefined objects"
        ],
        "buggy_code": "\nclass LRUCache {\npublic:\nclass node\n{\n  public:\n  int key;\n  int val;\n  node* next;\n  node* prev;\n  node(int _key,int _val)\n  {\n    key = _key;\n    val = _val;\n  }\n};\nnode* head = nullptr;\nnode* tail = nullptr;\n\nint size;\nunordered_map<int,node*>mpp;\n    LRUCache(int capacity) {\n       size = capacity; \n       head->next = tail;\n       tail->prev = head;  \n    }\n\n    void addNode(node* newNode){\n       \n       node* temp = head->next;\n       newNode->next = temp;\n       newNode->prev = head;\n       head->next = newNode;\n    }\n\n    /*void deleteNode(node* delNode){\n         \n       node* delprev = delNode->prev;\n       node* delnext = delNode->next;\n       delprev->next = delnext;\n       delnext->prev = delprev;\n    }*/\n    \n    int get(int _key) {\n        \n        if(mpp.count(_key))\n        {\n          node* nde = mpp[_key];\n          int curr = nde->val;\n          mpp.erase(_key);\n          deleteNode(nde);\n          addNode(nde)\n          mpp[_key] = head->next;\n          return curr;\n        }\n        return -1;\n    }\n\n}; \n\n\n\n"
    },
    {
        "slug": "longest-ideal-subsequence",
        "description": "You are given a string s consisting of lowercase letters and an integer k. We call a string t ideal if the following conditions are satisfied:\n\nt is a subsequence of the string s.\nThe absolute difference in the alphabet order of every two adjacent letters in t is less than or equal to k.\n\nReturn the length of the longest ideal string.\nA subsequence is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.\nNote that the alphabet order is not cyclic. For example, the absolute difference in the alphabet order of 'a' and 'z' is 25, not 1.",
        "examples": [
            "Input: s = \"acfgbd\", k = 2\nOutput: 4\nExplanation: The longest ideal string is \"acbd\". The length of this string is 4, so 4 is returned.\nNote that \"acfgbd\" is not ideal because 'c' and 'f' have a difference of 3 in alphabet order.",
            "Input: s = \"abcd\", k = 3\nOutput: 4\nExplanation: The longest ideal string is \"abcd\". The length of this string is 4, so 4 is returned."
        ],
        "constraints": "1 <= s.length <= 105\n0 <= k <= 25\ns consists of lowercase English letters.",
        "oracle_code": "class Solution {\n\n\n   int SolveByMemo(string &s , int &k , int index , int prev , vector<vector<int>> &dp)\n   {\n       if(index == s.length())\n       return 0;\n\n       if(dp[index][prev] != -1)\n       return dp[index][prev];\n\n       int op1 = 0 + SolveByMemo(s, k , index+1 , prev , dp);\n\n       int op2 = 0 ;\n\n       if(prev == 26)\n       op2 = 1 + SolveByMemo(s, k , index+1 , s[index]-'a' , dp);\n       else if(abs(s[index]-'a' - prev) <= k)\n       op2 = 1 + SolveByMemo(s, k , index+1 , s[index]-'a' , dp);\n\n       return dp[index][prev] = max(op1 , op2);\n   }\n\n   int SolveByTab(string &s , int &k )\n   {\n        vector<vector<int>> dp(s.length()+1 , vector<int> (27, 0));\n       \n        for(int index = s.length()-1 ; index>=0 ; index--)\n        {\n            for(int prev = 0 ; prev<= 26 ; prev++)\n            {\n                int op1 = 0 + dp[index+1][prev];\n                int op2 = 0 ;\n\n               if(prev == 26)\n               op2 = 1 + dp[index+1][s[index]-'a'];\n               else if(abs(s[index]-'a' - prev) <= k)\n               op2 = 1 + dp[index+1][s[index]-'a'];\n\n               dp[index][prev] = max(op1 , op2);\n            }\n        }\n\n       return max(dp[0][s[0]-'a'] , dp[0][26]);\n   }\n\n   int SolveByTabSpaceOptimised(string &s , int &k )\n   {\n        vector<int> next(27, 0) ;\n        vector<int> curr(27, 0);\n       \n        for(int index = s.length()-1 ; index>=0 ; index--)\n        {\n            for(int prev = 0 ; prev<= 26 ; prev++)\n            {\n                int op1 = 0 + next[prev];\n                int op2 = 0 ;\n\n               if(prev == 26)\n               op2 = 1 + next[s[index]-'a'];\n               else if(abs(s[index]-'a' - prev) <= k)\n               op2 = 1 + next[s[index]-'a'];\n\n               curr[prev] = max(op1 , op2);\n            }\n            next = curr;\n        }\n\n       return max(curr[s[0]-'a'] , curr[26]);\n   }\n\npublic:\n    int longestIdealString(string s, int k) {\n        \n        // 1. Recursion + Memoization || Top Down Approach\n        // vector<vector<int>> dp(s.length() , vector<int> (27, -1));\n        // return SolveByMemo(s, k , 0 , 26, dp);\n\n        // 2. Tabulation Method || Bottom Up Approach\n        // return SolveByTab(s, k);\n\n        // 3. Space Optimisation using Tabulation\n        return SolveByTabSpaceOptimised(s , k);\n    }\n};",
        "content": "\\n# Approach\\nWe Have Use Three Different Approaches :\\n1. Recursion + Memoization \\n    TC : O(n^2) , SC : O(n)\\n2. Tabulation Method \\n    TC : O(n^2) , SC : O(n)\\n3.  Tabulatuon With SOace Optimised\\n    TC : O(n^2) , SC : O(1) \\n\\n\\n#Note\\nSC In first two methods is On) and not O(n^2) as size is fixed to 27 for each index hence it is Linear Space ,Similarly for 3rd Method we have optimised to constant space as at any instant we onlt need memory of next 27 blocks  only.\\n\\n#Hope You Liekd It and Upvote are appreciated \\n\\n# Code\\n```\\nclass Solution {\\n\\n\\n   int SolveByMemo(string &s , int &k , int index , int prev , vector<vector<int>> &dp)\\n   {\\n       if(index == s.length())\\n       return 0;\\n\\n       if(dp[index][prev] != -1)\\n       return dp[index][prev];\\n\\n       int op1 = 0 + SolveByMemo(s, k , index+1 , prev , dp);\\n\\n       int op2 = 0 ;\\n\\n       if(prev == 26)\\n       op2 = 1 + SolveByMemo(s, k , index+1 , s[index]-\\'a\\' , dp);\\n       else if(abs(s[index]-\\'a\\' - prev) <= k)\\n       op2 = 1 + SolveByMemo(s, k , index+1 , s[index]-\\'a\\' , dp);\\n\\n       return dp[index][prev] = max(op1 , op2);\\n   }\\n\\n   int SolveByTab(string &s , int &k )\\n   {\\n        vector<vector<int>> dp(s.length()+1 , vector<int> (27, 0));\\n       \\n        for(int index = s.length()-1 ; index>=0 ; index--)\\n        {\\n            for(int prev = 0 ; prev<= 26 ; prev++)\\n            {\\n                int op1 = 0 + dp[index+1][prev];\\n                int op2 = 0 ;\\n\\n               if(prev == 26)\\n               op2 = 1 + dp[index+1][s[index]-\\'a\\'];\\n               else if(abs(s[index]-\\'a\\' - prev) <= k)\\n               op2 = 1 + dp[index+1][s[index]-\\'a\\'];\\n\\n               dp[index][prev] = max(op1 , op2);\\n            }\\n        }\\n\\n       return max(dp[0][s[0]-\\'a\\'] , dp[0][26]);\\n   }\\n\\n   int SolveByTabSpaceOptimised(string &s , int &k )\\n   {\\n        vector<int> next(27, 0) ;\\n        vector<int> curr(27, 0);\\n       \\n        for(int index = s.length()-1 ; index>=0 ; index--)\\n        {\\n            for(int prev = 0 ; prev<= 26 ; prev++)\\n            {\\n                int op1 = 0 + next[prev];\\n                int op2 = 0 ;\\n\\n               if(prev == 26)\\n               op2 = 1 + next[s[index]-\\'a\\'];\\n               else if(abs(s[index]-\\'a\\' - prev) <= k)\\n               op2 = 1 + next[s[index]-\\'a\\'];\\n\\n               curr[prev] = max(op1 , op2);\\n            }\\n            next = curr;\\n        }\\n\\n       return max(curr[s[0]-\\'a\\'] , curr[26]);\\n   }\\n\\npublic:\\n    int longestIdealString(string s, int k) {\\n        \\n        // 1. Recursion + Memoization || Top Down Approach\\n        // vector<vector<int>> dp(s.length() , vector<int> (27, -1));\\n        // return SolveByMemo(s, k , 0 , 26, dp);\\n\\n        // 2. Tabulation Method || Bottom Up Approach\\n        // return SolveByTab(s, k);\\n\\n        // 3. Space Optimisation using Tabulation\\n        return SolveByTabSpaceOptimised(s , k);\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "indexing error",
            "wrong comment mark",
            "undefined keywords from other languages",
            "variable value error"
        ],
        "buggy_code": "\nclass Solution {\n   int SolveByMemo(string &s , int &k , int index , int prev , vector<vector<int>> &dp)\n   {\n       \n       if(dp[index+1][prev] != -1)\n       return dp[index+1][prev];\n\n       \n/**/fun(s, k , index+, prev , dp);\n       else if(abs(s[index]-'a' - prev) <= k)\n       op2 = fun(s, k , index1 , s[index]-'a' , dp);\n\n       return dp[index][prev] = max(op1 , op2);\n   }\n\n   int SolveByTab(string &s , int &k )\n   {\n        vector<vector<int>> dp(s.length()+1 , vector<int> (27, 0));\n       \n        for(int index = s.length()-1 ; index>=0 ; index--)\n        {\n            for(int prev = 0 ; prev<= 26 ; prev++)\n            {\n                int op1 = 0 + dp[index+1][prev];\n                int op2 = 0 ;\n\n               if(prev == 26)\n               op2 = fun(dp[index+1][prev];\n               else if(abs(s[index]-'a') - prev) <= k)\n               op2 = 1 + dp[index+1][s[index]-'a'];\n\n               dp[index][prev] = max(op1 , op2);\n  fun(        }\n        }\n\n       return max(dp[0][s[0]-'a']) , dp[0][26]);\n   }\npublic:\n    int longestIdealString(string s, int k) {\n        \n        // 1. Recursion + Memoization || Top Down Approach\n        // vector<vector<int>> dp(s.length() , vector<int> (27, -1));\n        // return SolveByMemo(s, k , 0 , 26, dp);\n\n        // 2. Tabulation Method || Bottom Up Approach\n        return SolveByTab(s, k);\n    }\n};\n"
    },
    {
        "slug": "find-the-punishment-number-of-an-integer",
        "description": "Given a positive integer n, return the punishment number of n.\nThe punishment number of n is defined as the sum of the squares of all integers i such that:\n\n1 <= i <= n\nThe decimal representation of i * i can be partitioned into contiguous substrings such that the sum of the integer values of these substrings equals i.",
        "examples": [
            "Input: n = 10\nOutput: 182\nExplanation: There are exactly 3 integers i that satisfy the conditions in the statement:\n- 1 since 1 * 1 = 1\n- 9 since 9 * 9 = 81 and 81 can be partitioned into 8 + 1.\n- 10 since 10 * 10 = 100 and 100 can be partitioned into 10 + 0.\nHence, the punishment number of 10 is 1 + 81 + 100 = 182",
            "Input: n = 37\nOutput: 1478\nExplanation: There are exactly 4 integers i that satisfy the conditions in the statement:\n- 1 since 1 * 1 = 1. \n- 9 since 9 * 9 = 81 and 81 can be partitioned into 8 + 1. \n- 10 since 10 * 10 = 100 and 100 can be partitioned into 10 + 0. \n- 36 since 36 * 36 = 1296 and 1296 can be partitioned into 1 + 29 + 6.\nHence, the punishment number of 37 is 1 + 81 + 100 + 1296 = 1478"
        ],
        "constraints": "1 <= n <= 1000",
        "oracle_code": "class Solution {\npublic:\n    \n    bool valid(int n, string s,int sum){\n        // empty string indicates we have completed one partition\n        if(s==\"\") if(sum==n) return true;\n\n        // We use backtracking to check for all partitions if it is possible to generate required sum \n        // and if we find sum we immediately return true immediately\n        for(int i=1;i<=s.size();i++){\n            int x  = stoi(s.substr(0,i));\n            if(valid(n, s.substr(i), sum+x)) return true;\n        }\n        \n        //If no partition could add up to required sum n\n        return false;\n    }\n    int punishmentNumber(int n) {\n        int ans = 0;\n\n        //generate all possible squares and check them if they satisfy the given statement\n        for(int i=1;i<=n;i++){\n            int sq = i*i;\n            string x = to_string(sq);\n            if(valid(i,x,0)) ans += i*i;\n        }\n        \n        return ans;\n        \n    }\n};",
        "content": "# Intuition\\nThe main idea of this problem is to generate all non empty partitions of a string using Backtracking.\\n\\nFor example let\\'s  say i = 36, it\\'s square = 36*36 = 1296\\nTo check if some partition of 1296 satisfy given statement, we make all partitions e.g\\n[1,2,9,6], [1,29,6], [1,296], [12,9,6] , [12,96], [129,6]\\n\\nAmong these only [1,29,6] satisfies the constraint.\\n\\nWe only need one of these set to satisfy the statement, hence we break immediately if we find any valid set.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n* Generate all possible squares and check if they satisfy the given statement\\n* To check if a square satisfies the given constraint or not generate all possible partitions using backtracking.\\n* If any single partition satisfy the statement then this square will be added to solution\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity :  O(n*(2^6)), here 6 is the maxm square length that is len(1000*1000) = 6\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    bool valid(int n, string s,int sum){\\n        // empty string indicates we have completed one partition\\n        if(s==\"\") if(sum==n) return true;\\n\\n        // We use backtracking to check for all partitions if it is possible to generate required sum \\n        // and if we find sum we immediately return true immediately\\n        for(int i=1;i<=s.size();i++){\\n            int x  = stoi(s.substr(0,i));\\n            if(valid(n, s.substr(i), sum+x)) return true;\\n        }\\n        \\n        //If no partition could add up to required sum n\\n        return false;\\n    }\\n    int punishmentNumber(int n) {\\n        int ans = 0;\\n\\n        //generate all possible squares and check them if they satisfy the given statement\\n        for(int i=1;i<=n;i++){\\n            int sq = i*i;\\n            string x = to_string(sq);\\n            if(valid(i,x,0)) ans += i*i;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "unclosed string",
            "conditional statement error",
            "undefined methods",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    \n    bool valid(int n, string s,int sum){\n        // empty string indicates we have completed one partition\n        if(s==\"\") if(sum==n) return true;\n\n        // We use backtracking to check for all partitions if it is possible to generate required sum \n        // and if we find sum we immediately return true immediately\n        string unclosedString = \"This is an unclosed string;\n        for(int i=1;i<=s.size();i++){\n            int x  = parseInt(s.substr(0,i));\n            if(valid(n, s.substr(i), sum+x)) return false;\n        }\n        \n        //If no partition could add up to required sum n\n        return false;\n    }\n    int punishmentNumber(int n) {\n        int ans = 0;\n\n        //generate all possible squares and check them if they satisfy the given statement\n        for(int i=1;i<=n;i++){\n            int sq = i*i;\n            string x = to_string(sq);\n            if(valid(i,x,0)) ans += i*i;\n        }\n        \n        \n        return checkAdditionalCondition(ans);\n    }\n};\n"
    },
    {
        "slug": "shortest-path-to-get-all-keys",
        "description": "You are given an m x n grid grid where:\n\n'.' is an empty cell.\n'#' is a wall.\n'@' is the starting point.\nLowercase letters represent keys.\nUppercase letters represent locks.\n\nYou start at the starting point and one move consists of walking one space in one of the four cardinal directions. You cannot walk outside the grid, or walk into a wall.\nIf you walk over a key, you can pick it up and you cannot walk over a lock unless you have its corresponding key.\nFor some 1 <= k <= 6, there is exactly one lowercase and one uppercase letter of the first k letters of the English alphabet in the grid. This means that there is exactly one key for each lock, and one lock for each key; and also that the letters used to represent the keys and locks were chosen in the same order as the English alphabet.\nReturn the lowest number of moves to acquire all keys. If it is impossible, return -1.",
        "examples": [
            "Input: grid = [\"@.a..\",\"###.#\",\"b.A.B\"]\nOutput: 8\nExplanation: Note that the goal is to obtain all the keys not to open all the locks.",
            "Input: grid = [\"@..aA\",\"..B#.\",\"....b\"]\nOutput: 6",
            "Input: grid = [\"@Aa\"]\nOutput: -1"
        ],
        "constraints": "m == grid.length\nn == grid[i].length\n1 <= m, n <= 30\ngrid[i][j] is either an English letter, '.', '#', or '@'.\u00a0\nThere is exactly one\u00a0'@'\u00a0in the grid.\nThe number of keys in the grid is in the range [1, 6].\nEach key in the grid is unique.\nEach key in the grid has a matching lock.",
        "oracle_code": "class Solution {\npublic:\n\n    int dir[4][2] = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};\n\n    int shortestPathAllKeys(vector<string>& grid) {\n        \n        int m = grid.size();\n        int n = grid[0].size();\n        queue<pair<pair<int, int>, int>> que;\n        vector<vector<unsigned long>> mapKey(m, vector<unsigned long>(n, 0));\n        int target = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if ('a' <= grid[i][j] && grid[i][j] <= 'f') {\n                    target |= 1 << (grid[i][j] - 'a');\n                    continue;\n                }\n\n                if (grid[i][j] == '@') {\n                    que.emplace(pair<int, int>(i, j), 0);\n                    mapKey[i][j] = 1;\n                }\n            }\n        }\n\n\n        int step = 0;\n        while (!que.empty()) {\n            int size = que.size();\n            for (int s = 0; s < size; s++) {\n                int i = que.front().first.first;\n                int j = que.front().first.second;\n                int key = que.front().second;\n                que.pop();\n                \n                if ('a' <= grid[i][j] && grid[i][j] <= 'f') {\n                    key |= 1 << (grid[i][j] - 'a');\n                    if (key == target)\n                        return step;\n\n                    mapKey[i][j] |= 1l << key;\n                }\n\n                for (int d = 0; d < 4; d++) {\n                    int newi = i + dir[d][0];\n                    int newj = j + dir[d][1];\n                    \n                    if (!(0 <= newi && newi < m && 0 <= newj && newj < n))\n                        continue;\n                        \n                    int val = grid[newi][newj];\n                    if (val == '#')\n                        continue;\n                        \n                    if ('A' <= val && val <= 'F' && (key & (1 << (val - 'A'))) == 0)\n                        continue;\n                        \n                    if (mapKey[newi][newj] & (1l << key))\n                        continue;\n                        \n                     mapKey[newi][newj] |= 1l << key;\n                     que.emplace(pair<int, int>(newi, newj), key);\n                }\n            }\n            step++;\n        }\n        return -1;\n    }\n};",
        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int dir[4][2] = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};\\n\\n    int shortestPathAllKeys(vector<string>& grid) {\\n        \\n        int m = grid.size();\\n        int n = grid[0].size();\\n        queue<pair<pair<int, int>, int>> que;\\n        vector<vector<unsigned long>> mapKey(m, vector<unsigned long>(n, 0));\\n        int target = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (\\'a\\' <= grid[i][j] && grid[i][j] <= \\'f\\') {\\n                    target |= 1 << (grid[i][j] - \\'a\\');\\n                    continue;\\n                }\\n\\n                if (grid[i][j] == \\'@\\') {\\n                    que.emplace(pair<int, int>(i, j), 0);\\n                    mapKey[i][j] = 1;\\n                }\\n            }\\n        }\\n\\n\\n        int step = 0;\\n        while (!que.empty()) {\\n            int size = que.size();\\n            for (int s = 0; s < size; s++) {\\n                int i = que.front().first.first;\\n                int j = que.front().first.second;\\n                int key = que.front().second;\\n                que.pop();\\n                \\n                if (\\'a\\' <= grid[i][j] && grid[i][j] <= \\'f\\') {\\n                    key |= 1 << (grid[i][j] - \\'a\\');\\n                    if (key == target)\\n                        return step;\\n\\n                    mapKey[i][j] |= 1l << key;\\n                }\\n\\n                for (int d = 0; d < 4; d++) {\\n                    int newi = i + dir[d][0];\\n                    int newj = j + dir[d][1];\\n                    \\n                    if (!(0 <= newi && newi < m && 0 <= newj && newj < n))\\n                        continue;\\n                        \\n                    int val = grid[newi][newj];\\n                    if (val == \\'#\\')\\n                        continue;\\n                        \\n                    if (\\'A\\' <= val && val <= \\'F\\' && (key & (1 << (val - \\'A\\'))) == 0)\\n                        continue;\\n                        \\n                    if (mapKey[newi][newj] & (1l << key))\\n                        continue;\\n                        \\n                     mapKey[newi][newj] |= 1l << key;\\n                     que.emplace(pair<int, int>(newi, newj), key);\\n                }\\n            }\\n            step++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
        "level": "hard",
        "type": [
            "== and = confusion",
            "operation error",
            "unclosed string",
            "colon missing"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n\n    int dir[4][2] = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};\n\n    int shortestPathAllKeys(vector<string>& grid) {\n        \n        int m = grid.size();\n        int n = grid[0].size();\n        queue<pair<pair<int, int>, int>> que;\n        vector<vector<unsigned long>> mapKey(m, vector<unsigned long>(n, 0));\n        int target = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if ('a' <= grid[i][j] && grid[i][j] <= 'f') {\n                    target |= 1  (grid[i][j] - 'a\");\n                    continue;\n                }\n\n                if (grid[i][j] = '@') {\n                    que.emplace(pair<int, int>(i, j), 0);\n                    mapKey[i][j] = 1;\n                }\n            }\n        }\n\n\n        int step = 0;\n        while (!que.empty()) {\n            int size = que.size();\n            for (int s = 0; s < size; s++) {\n                int i = que.front().first.first;\n                int j = que.front().first.second;\n                int key = que.front().second;\n                que.pop();\n                \n                if ('a' <= grid[i][j] && grid[i][j] <= 'f\") {\n                    key |= 1 << (grid[i][j] - 'a\");\n                    if (key == target)\n                        return step;\n\n                    mapKey[i][j] |= 1l << key;\n                }\n\n                for (int d = 0; d < 4; d++) {\n                    int newi = i + dir[d][0];\n                    int newj = j + dir[d][1];\n                    \n                    if (!(0 <= newi && newi < m && 0 <= newj && newj < n))\n                        continue;\n                        \n                    int val = grid[newi][newj];\n                    if (val == '#')\n                        continue;\n                        \n                    if ('A' <= val && val <= 'F' && (key & (1  (val - 'A\"))) == 0)\n                        continue;\n                        \n                    if (mapKey[newi][newj] & (1l << key))\n                        continue;\n                        \n                     mapKey[newi][newj] |= 1l << (key+1);  \n                     que.emplace(pair<int, int>(newi, newj), key);\n                }\n            }\n            step++;\n        }\n        return -1;\n    }\n};\n"
    },
    {
        "slug": "buddy-strings",
        "description": "Given two strings s and goal, return true if you can swap two letters in s so the result is equal to goal, otherwise, return false.\nSwapping letters is defined as taking two indices i and j (0-indexed) such that i != j and swapping the characters at s[i] and s[j].\n\nFor example, swapping at indices 0 and 2 in \"abcd\" results in \"cbad\".",
        "examples": [
            "Input: s = \"ab\", goal = \"ba\"\nOutput: true\nExplanation: You can swap s[0] = 'a' and s[1] = 'b' to get \"ba\", which is equal to goal.",
            "Input: s = \"ab\", goal = \"ab\"\nOutput: false\nExplanation: The only letters you can swap are s[0] = 'a' and s[1] = 'b', which results in \"ba\" != goal.",
            "Input: s = \"aa\", goal = \"aa\"\nOutput: true\nExplanation: You can swap s[0] = 'a' and s[1] = 'a' to get \"aa\", which is equal to goal."
        ],
        "constraints": "1 <= s.length, goal.length <= 2 * 104\ns and goal consist of lowercase letters.",
        "oracle_code": "class Solution {\npublic:\n    bool buddyStrings(string s, string p) {\n        int n=s.length(), m=p.length();\n        if(n!=m) return false;\n        \n        vector<int> freq(26,0);\n        \n        int first=-1, second=-1;\n        for(int i=0;i<n;i++){\n            if(s[i] != p[i]){\n                if(first==-1){\n                    first=i;\n                }else if(second==-1){\n                    second=i;\n                }else{\n                    return false; // more than 2 mismatching characters\n                }\n            }\n            freq[s[i]-'a']++;\n        }\n        \n\t\t// similar strings\n        if(first == -1 && second == -1){\n            for(int i=0;i<26;i++) if(freq[i] > 1) return true; // can swap similar characters\n            return false; // all characters occur only once\n        }else if(second == -1){\n            return false; // exactly 1 mismatch\n        }\n        \n        return (s[first]==p[second] && s[second]==p[first]); // check similarity on 2 mismatched indexes\n    }\n};",
        "content": "**Connect with me on LinkedIn**: https://www.linkedin.com/in/abhay5349singh/\\n\\n```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string p) {\\n        int n=s.length(), m=p.length();\\n        if(n!=m) return false;\\n        \\n        vector<int> freq(26,0);\\n        \\n        int first=-1, second=-1;\\n        for(int i=0;i<n;i++){\\n            if(s[i] != p[i]){\\n                if(first==-1){\\n                    first=i;\\n                }else if(second==-1){\\n                    second=i;\\n                }else{\\n                    return false; // more than 2 mismatching characters\\n                }\\n            }\\n            freq[s[i]-\\'a\\']++;\\n        }\\n        \\n\\t\\t// similar strings\\n        if(first == -1 && second == -1){\\n            for(int i=0;i<26;i++) if(freq[i] > 1) return true; // can swap similar characters\\n            return false; // all characters occur only once\\n        }else if(second == -1){\\n            return false; // exactly 1 mismatch\\n        }\\n        \\n        return (s[first]==p[second] && s[second]==p[first]); // check similarity on 2 mismatched indexes\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "== and = confusion",
            "operation error",
            "unclosed string",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    bool buddyStrings(string s, string p) {\n        int n=s.length(), m=p.length();\n        if(n!=m) return false;\n        \n        vector<int> freq(26,0);\n        \n        int first=-1, second=-1;\n        char *undefinedObject;\n\n        for(int i=0;i<n;i++){\n            if(s[i] = p[i]){\n                if(first==-1){\n                    first=i;\n                }else if(second==-1){\n                    second=i;\n                }else{\n                    return false; \n                }\n            }\n            freq[undefinedObject[i]-'z']++; \n        }\n              \n        if(first == -1 && second == -1){\n            for(int i=0;i<26;i++) if(freq[i] > 1) return true; \n            return false\"false\"; \n        }else if(second == -1){\n            return ; excty1 mismat\n       }\n        \n        ret(s[first]==p[second] && s[second]==p[first]);check similarity on 2 mismatched inde\n    }\n};\n"
    },
    {
        "slug": "maximum-gap",
        "description": "Given an integer array nums, return the maximum difference between two successive elements in its sorted form. If the array contains less than two elements, return 0.\nYou must write an algorithm that runs in linear time and uses linear extra space.",
        "examples": [
            "Input: nums = [3,6,9,1]\nOutput: 3\nExplanation: The sorted form of the array is [1,3,6,9], either (3,6) or (6,9) has the maximum difference 3.",
            "Input: nums = [10]\nOutput: 0\nExplanation: The array contains less than 2 elements, therefore return 0."
        ],
        "constraints": "1 <= nums.length <= 105\n0 <= nums[i] <= 109",
        "oracle_code": "class Solution {\npublic:\n\nvector<int> countsort(vector<int> &nums)\n{\n    int n = nums.size();\n    map<int, int> m;\n    for (int i = 0; i < n; i++ )\n        m[nums[i]]++;\n\n    nums.clear();\n    for (auto it : m)\n    {\n        int cnt = it.second;\n        while (cnt--)\n        {\n            nums.push_back(it.first);\n        }\n    }\n    return nums;\n}\n\nint maximumGap(vector<int> &nums)\n{\n    int n = nums.size();\n    if (n < 2)\n        return 0;\n    vector<int> sortednums = countsort(nums);\n\n    int maxgap = INT_MIN;\n    for (int i = 1; i < n; i++)\n    {\n        int currgap = sortednums[i] - sortednums[i - 1];\n        maxgap = max(maxgap, currgap);\n    }\n\n    return maxgap;\n}\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nsince it is given in the question that we can use only linear time and space so we can only use a kind of counting sort , where we required a hash map which take an extra o(n) time complexity.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn counting sort first we required an hash map where we store the frequency of each element and after storing the frequency we just need to fill the original array based on there frequency , here we use an map not unordered map because the map is store value in sorted order.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nwe are traversing the array once , so  it is O(n) and an extra (logn)\\nfactor comes because of using the map, but still it is better in terms of time from inbuilt sort function..\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n) we are using only an map so the total extra space is equal to the size of map.\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\nvector<int> countsort(vector<int> &nums)\\n{\\n    int n = nums.size();\\n    map<int, int> m;\\n    for (int i = 0; i < n; i++ )\\n        m[nums[i]]++;\\n\\n    nums.clear();\\n    for (auto it : m)\\n    {\\n        int cnt = it.second;\\n        while (cnt--)\\n        {\\n            nums.push_back(it.first);\\n        }\\n    }\\n    return nums;\\n}\\n\\nint maximumGap(vector<int> &nums)\\n{\\n    int n = nums.size();\\n    if (n < 2)\\n        return 0;\\n    vector<int> sortednums = countsort(nums);\\n\\n    int maxgap = INT_MIN;\\n    for (int i = 1; i < n; i++)\\n    {\\n        int currgap = sortednums[i] - sortednums[i - 1];\\n        maxgap = max(maxgap, currgap);\\n    }\\n\\n    return maxgap;\\n}\\n};\\n```",
        "level": "medium",
        "type": [
            "indexing error",
            "conditional statement error",
            "undefined keywords from other languages",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n\nvector<int> countsort(vector<int> &nums)\n{\n    int n = nums.size();\n    map<int, int> m;\n    for (int i = 0; i <= n; i++ )\n        m[nums[i]]++;\n\n    nums.clear();\n    foreach (var it in m)\n    {\n        int cnt = it.second;\n        while (cnt--\n        {\n            nums.push_back(it.first);\n        }\n    }\n    return nums;\n}\n\nint maximumGap(vector<int> &nums)\n{\n    int n = nums.size();\n    if (n < 2)\n        return 0;\n    vector<int> sortednums = countsort(nums);\n\n    int maxgap = INT_MIN;\n    for (int i = 1; i <= n; i++)\n    {\n        int currgap = sortednums[i] - sortednums[i - 1];\n        maxgap = max(maxgap, currgap);\n    }\n\n    return maxgap;\n}\n};\n"
    },
    {
        "slug": "detect-cycles-in-2d-grid",
        "description": "Given a 2D array of characters grid of size m x n, you need to find if there exists any cycle consisting of the same value in grid.\nA cycle is a path of length 4 or more in the grid that starts and ends at the same cell. From a given cell, you can move to one of the cells adjacent to it - in one of the four directions (up, down, left, or right), if it has the same value of the current cell.\nAlso, you cannot move to the cell that you visited in your last move. For example, the cycle (1, 1) -> (1, 2) -> (1, 1) is invalid because from (1, 2) we visited (1, 1) which was the last visited cell.\nReturn true if any cycle of the same value exists in grid, otherwise, return false.",
        "examples": [
            "Input: grid = [[\"a\",\"a\",\"a\",\"a\"],[\"a\",\"b\",\"b\",\"a\"],[\"a\",\"b\",\"b\",\"a\"],[\"a\",\"a\",\"a\",\"a\"]]\nOutput: true\nExplanation: There are two valid cycles shown in different colors in the image below:",
            "Input: grid = [[\"c\",\"c\",\"c\",\"a\"],[\"c\",\"d\",\"c\",\"c\"],[\"c\",\"c\",\"e\",\"c\"],[\"f\",\"c\",\"c\",\"c\"]]\nOutput: true\nExplanation: There is only one valid cycle highlighted in the image below:",
            "Input: grid = [[\"a\",\"b\",\"b\"],[\"b\",\"z\",\"b\"],[\"b\",\"b\",\"a\"]]\nOutput: false"
        ],
        "constraints": "m == grid.length\nn == grid[i].length\n1 <= m, n <= 500\ngrid consists only of lowercase English letters.",
        "oracle_code": "class Solution {\npublic:\n   vector<int> dir = { 0, 1, 0, -1, 0 }; \n    bool isCyclic(vector<vector<char>>& grid, vector<vector<bool>>& visited, int i, int j, int x, int y)\n    {\n        visited[i][j] = true;\n        for(int d = 0; d < 4; ++d)\n        {\n            int a = i+dir[d];\n            int b = j+dir[d+1];\n            if(a >= 0 && a < grid.size() && b >= 0 && b < grid[0].size() && grid[a][b] == grid[i][j] && !(x == a && y == b))\n                if(visited[a][b] || isCyclic(grid, visited, a,b,i,j))\n                    return true;\n        }\n        return false;\n    }\n    bool containsCycle(vector<vector<char>>& grid) {\n        int n = grid.size(), m = grid[0].size();\n        vector<vector<bool>> visited(n, vector<bool>(m, false));\n        for(int i = 0; i < n; ++i)\n            for(int j = 0; j < m; ++j)\n                if(!visited[i][j] && isCyclic(grid, visited, i, j, -1, -1))\n                    return true;\n        return false;\n    }\n};",
        "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n   vector<int> dir = { 0, 1, 0, -1, 0 }; \\n    bool isCyclic(vector<vector<char>>& grid, vector<vector<bool>>& visited, int i, int j, int x, int y)\\n    {\\n        visited[i][j] = true;\\n        for(int d = 0; d < 4; ++d)\\n        {\\n            int a = i+dir[d];\\n            int b = j+dir[d+1];\\n            if(a >= 0 && a < grid.size() && b >= 0 && b < grid[0].size() && grid[a][b] == grid[i][j] && !(x == a && y == b))\\n                if(visited[a][b] || isCyclic(grid, visited, a,b,i,j))\\n                    return true;\\n        }\\n        return false;\\n    }\\n    bool containsCycle(vector<vector<char>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<bool>> visited(n, vector<bool>(m, false));\\n        for(int i = 0; i < n; ++i)\\n            for(int j = 0; j < m; ++j)\\n                if(!visited[i][j] && isCyclic(grid, visited, i, j, -1, -1))\\n                    return true;\\n        return false;\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "undefined keywords from other languages",
            "variable value error",
            "colon missing",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n   list<int> dir = { 0, 1, 0, -1, 0 } \n    bool isCyclic(vector<vector<char>>& grid, vector<vector<bool>>& visited, int i, int j, int x, int y)\n    {\n        visited[i][j] = false;\n        for(int d = 0; d < 4; ++d)\n        {\n            int a = i+dir[d];\n            int b = j+dir[d+1];\n            if(a >= 0 && a < grid.size() && b >= 0 && b < grid[0].size() && grid[a][b] == grid[i][j] && !(x == a && y == b))\n                if((!visited[a][b] && isCyclic(grid, visited, a,b,i,j)) || visited[a][b])\n                    return true;\n        }\n        return false;\n    }\n    bool containsCycle(vector<vector<char>>& grid) {\n        int n = grid.size(), m = grid[0].size();\n        vector<vector<bool>> visited(n, vector<bool>(m, false));\n        for(int i = 0; i < n; ++i)\n            for(int j = 0; j < m; ++j)\n                if(!visited[i][j] && isCyclic(grid, visited, i, j, -1, -1))\n                    return true;\n        return false;\n    }\n};\n"
    },
    {
        "slug": "longest-common-prefix",
        "description": "Write a function to find the longest common prefix string amongst an array of strings.\nIf there is no common prefix, return an empty string \"\".",
        "examples": [
            "Input: strs = [\"flower\",\"flow\",\"flight\"]\nOutput: \"fl\"",
            "Input: strs = [\"dog\",\"racecar\",\"car\"]\nOutput: \"\"\nExplanation: There is no common prefix among the input strings."
        ],
        "constraints": "1 <= strs.length <= 200\n0 <= strs[i].length <= 200\nstrs[i] consists of only lowercase English letters.",
        "oracle_code": "class Solution {\npublic:\n    string longestCommonPrefix(vector<string>& str) \n    {\n        sort(str.begin(), str.end()); //sorting the array\n        string ans=\"\"; //creating a new empty string to store the common prefixes\n        for(int i=0;i<str[0].length();i++) // max iterations = length of the first string\n        {\n            if(str[0][i]!=str[str.size()-1][i]) // checking the characters of the first and last string\n                break;\n            ans+=str[0][i]; // concatinate if the characters are matching\n        }\n        return ans;\n    }\n};",
        "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWhen you sort an array, it is enough to check for the common characters of the the first & last string of the sorted vector.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& str) \\n    {\\n        sort(str.begin(), str.end()); //sorting the array\\n        string ans=\"\"; //creating a new empty string to store the common prefixes\\n        for(int i=0;i<str[0].length();i++) // max iterations = length of the first string\\n        {\\n            if(str[0][i]!=str[str.size()-1][i]) // checking the characters of the first and last string\\n                break;\\n            ans+=str[0][i]; // concatinate if the characters are matching\\n        }\\n        return ans;\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "indexing error",
            "unclosed string",
            "colon missing",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    string longestCommonPrefix(vector<string>& str) \n    {\n        sort(str.begin(), str.end()); //sorting the array\n        string ans=\"; \n        for(int i=0;i<=str[0].length();i) \n        {\n            if(str[0][i]!=str[str.size()-1][i]] \n                break;\n            ans+=str[0][i]; // concatinate if the characters are matching\n        }\n        return ans;\n    }\n};\n"
    },
    {
        "slug": "gray-code",
        "description": "An n-bit gray code sequence is a sequence of 2n integers where:\n\nEvery integer is in the inclusive range [0, 2n - 1],\nThe first integer is 0,\nAn integer appears no more than once in the sequence,\nThe binary representation of every pair of adjacent integers differs by exactly one bit, and\nThe binary representation of the first and last integers differs by exactly one bit.\n\nGiven an integer n, return any valid n-bit gray code sequence.",
        "examples": [
            "Input: n = 2\nOutput: [0,1,3,2]\nExplanation:\nThe binary representation of [0,1,3,2] is [00,01,11,10].\n- 00 and 01 differ by one bit\n- 01 and 11 differ by one bit\n- 11 and 10 differ by one bit\n- 10 and 00 differ by one bit\n[0,2,3,1] is also a valid gray code sequence, whose binary representation is [00,10,11,01].\n- 00 and 10 differ by one bit\n- 10 and 11 differ by one bit\n- 11 and 01 differ by one bit\n- 01 and 00 differ by one bit",
            "Input: n = 1\nOutput: [0,1]"
        ],
        "constraints": "1 <= n <= 16",
        "oracle_code": "class Solution {\npublic:\n    vector<int> grayCode(int n) {\n        vector<int> res;\n        res.push_back( 0 );\n        for( int k = 0; k<n; k++ ) {\n            int i = res.size(), t = (1<<k) ;\n            while( i ) {\n                int temp = res[--i] | t;\n                res.push_back( temp );\n            }\n        }\n        return res;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int> res;\\n        res.push_back( 0 );\\n        for( int k = 0; k<n; k++ ) {\\n            int i = res.size(), t = (1<<k) ;\\n            while( i ) {\\n                int temp = res[--i] | t;\\n                res.push_back( temp );\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "conditional statement error",
            "undefined methods",
            "parentheses mismatch",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    vector<int> grayCode(int n) {\n        vector<int> res;\n        for( int k = 0; k<n; k++ ) {\n            int i = res.size(), t = (1<<k) ;\n            while( i ) {\n                int temp = res[--i] | t;\n                res.push_back(  > 1temp );\n            }\n        }\n        return res;\n    }\n}doSomthingExtra(re);\n\n"
    },
    {
        "slug": "shortest-path-with-alternating-colors",
        "description": "You are given an integer n, the number of nodes in a directed graph where the nodes are labeled from 0 to n - 1. Each edge is red or blue in this graph, and there could be self-edges and parallel edges.\nYou are given two arrays redEdges and blueEdges where:\n\nredEdges[i] = [ai, bi] indicates that there is a directed red edge from node ai to node bi in the graph, and\nblueEdges[j] = [uj, vj] indicates that there is a directed blue edge from node uj to node vj in the graph.\n\nReturn an array answer of length n, where each answer[x] is the length of the shortest path from node 0 to node x such that the edge colors alternate along the path, or -1 if such a path does not exist.",
        "examples": [
            "Input: n = 3, redEdges = [[0,1],[1,2]], blueEdges = []\nOutput: [0,1,-1]",
            "Input: n = 3, redEdges = [[0,1]], blueEdges = [[2,1]]\nOutput: [0,1,-1]"
        ],
        "constraints": "1 <= n <= 100\n0 <= redEdges.length,\u00a0blueEdges.length <= 400\nredEdges[i].length == blueEdges[j].length == 2\n0 <= ai, bi, uj, vj < n",
        "oracle_code": "class Solution {\npublic:\n    vector<int> shortestAlternatingPaths(int n,vector<vector<int>>&redEdges,vector<vector<int>>& blueEdges) \n    {\n        multiset<int>temp;\n        vector<multiset<int>>redchilds(n,temp),bluechilds(n,temp);\n        for(auto j:redEdges)\n        {\n            redchilds[j[0]].insert(j[1]);\n        }\n        for(auto j:blueEdges)\n        {\n            bluechilds[j[0]].insert(j[1]);\n        }\n        vector<int>ans;\n        for(int i=0;i<n;i++)\n        {\n            //BFS for all\n            vector<multiset<int>>reds=redchilds,blues=bluechilds;\n            queue<pair<char,int>>visit;\n            visit.push({'n',0});//neutral='n'\n            int steps=0;\n            while(!visit.empty())\n            {\n                bool justbreak=false;\n                int n=visit.size();\n                for(int j=0;j<n;j++)\n                {\n                    pair<char,int>x=visit.front();\n                    visit.pop();\n                    if(x.second==i)\n                    {\n                        ans.push_back(steps);\n                        justbreak=true;\n                        break;\n                    }\n                    if(x.first=='n')\n                    {\n                        for(auto j:reds[x.second])\n                        {\n                            visit.push({'r',j});\n                            auto itr1=reds[x.second].find(j);\n                            reds[x.second].erase(itr1);\n                        }\n                        for(auto j:blues[x.second])\n                        {\n                            visit.push({'b',j});//blue='b'\n                            auto itr1=blues[x.second].find(j);\n                            blues[x.second].erase(itr1);\n                        }\n                    }\n                    else if(x.first=='b')\n                    {\n                        for(auto j:reds[x.second])\n                        {\n                            visit.push({'r',j});//red='r'\n                            auto itr1=reds[x.second].find(j);\n                            reds[x.second].erase(itr1);\n                        }\n                    }\n                    else if(x.first=='r')\n                    {\n                        for(auto j:blues[x.second])\n                        {\n                            visit.push({'b',j});\n                            auto itr1=blues[x.second].find(j);\n                            blues[x.second].erase(itr1);\n                        }\n                    }\n                }\n                if(justbreak)\n                {\n                    break;\n                }\n                steps++;\n            }\n            if(i==ans.size())\n            {\n                ans.push_back(-1);\n            }\n        }\n        return ans;\n    }\n};",
        "content": "*E denotes number of Edges*\\n\\n# Complexity\\n- Time complexity:\\nO((N^2)+(N)*(E)*LOG(E))\\n\\n- Space complexity:\\nO(E)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> shortestAlternatingPaths(int n,vector<vector<int>>&redEdges,vector<vector<int>>& blueEdges) \\n    {\\n        multiset<int>temp;\\n        vector<multiset<int>>redchilds(n,temp),bluechilds(n,temp);\\n        for(auto j:redEdges)\\n        {\\n            redchilds[j[0]].insert(j[1]);\\n        }\\n        for(auto j:blueEdges)\\n        {\\n            bluechilds[j[0]].insert(j[1]);\\n        }\\n        vector<int>ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            //BFS for all\\n            vector<multiset<int>>reds=redchilds,blues=bluechilds;\\n            queue<pair<char,int>>visit;\\n            visit.push({\\'n\\',0});//neutral=\\'n\\'\\n            int steps=0;\\n            while(!visit.empty())\\n            {\\n                bool justbreak=false;\\n                int n=visit.size();\\n                for(int j=0;j<n;j++)\\n                {\\n                    pair<char,int>x=visit.front();\\n                    visit.pop();\\n                    if(x.second==i)\\n                    {\\n                        ans.push_back(steps);\\n                        justbreak=true;\\n                        break;\\n                    }\\n                    if(x.first==\\'n\\')\\n                    {\\n                        for(auto j:reds[x.second])\\n                        {\\n                            visit.push({\\'r\\',j});\\n                            auto itr1=reds[x.second].find(j);\\n                            reds[x.second].erase(itr1);\\n                        }\\n                        for(auto j:blues[x.second])\\n                        {\\n                            visit.push({\\'b\\',j});//blue=\\'b\\'\\n                            auto itr1=blues[x.second].find(j);\\n                            blues[x.second].erase(itr1);\\n                        }\\n                    }\\n                    else if(x.first==\\'b\\')\\n                    {\\n                        for(auto j:reds[x.second])\\n                        {\\n                            visit.push({\\'r\\',j});//red=\\'r\\'\\n                            auto itr1=reds[x.second].find(j);\\n                            reds[x.second].erase(itr1);\\n                        }\\n                    }\\n                    else if(x.first==\\'r\\')\\n                    {\\n                        for(auto j:blues[x.second])\\n                        {\\n                            visit.push({\\'b\\',j});\\n                            auto itr1=blues[x.second].find(j);\\n                            blues[x.second].erase(itr1);\\n                        }\\n                    }\\n                }\\n                if(justbreak)\\n                {\\n                    break;\\n                }\\n                steps++;\\n            }\\n            if(i==ans.size())\\n            {\\n                ans.push_back(-1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "== and = confusion",
            "wrong comment mark",
            "undefined methods",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    vector<int> shortestAlternatingPaths(int n,vector<vector<int>>&redEdges,vector<vector<int>>& blueEdges) \n    {\n        multiset<int>temp;\n        vector<multiset<int>>redchilds(n,temp),bluechilds(n,temp);\n        for(auto j:redEdges)\n        {\n            redchilds[j[0]].insert(j[1]);\n        }\n        for(auto j:blueEdges)\n        {\n            bluechilds[j[0]].insert(j[1]);\n        }\n        vector<int>ans;\n        for(int i=0;i<n;i++)\n        {\n            //BFS for all\n            vector<multiset<int>>reds=redchilds,blues=bluechilds;\n            queue<pair<char,int>>visit;\n            visit.push({'n',0});//neutral='n'\n            int steps=0;\n            while(!visit.empty()\n            {\n                bool justbreak=false;\n                int n=visit.size();\n                for(int j=0;j<n;j++)\n                {\n                    pair<char,int>x=visit.front();\n                    \n                    if(x.second=i)\n                    {\n                        ans.push_back(steps);\n                        justbreak=true;\n                        break;\n                    }\n                    if(x.first=='n')\n                    {\n                        for(auto j:reds[x.second])\n                        {\n                            visit.push({'r',j});\n                            auto itr1=reds[x.second].find(j);\n                            reds[x.second].erase(itr1);\n                        }\n                        for(auto j:blues[x.second])\n                        {\n                            visit.push({'b',j});//blue='b'\n                            auto itr1=blues[x.second].find(j);\n                            unknownFunction(itr1); \n                            blues[x.second].erase(itr1);\n                        }\n                    }\n                    else if(x.first=='b')\n                    {\n                        for(auto j:reds[x.second])\n                        {\n                            visit.push({'r',j});//red='r'\n                            auto itr1=reds[x.second].find(j);\n                            reds[x.second].erase(itr1);\n                        }\n                    }\n                    else if(x.first=='r')\n                    {\n                        for(auto j:blues[x.second])\n                        {\n                            visit.push({'b',j});\n                            auto itr1=blues[x.second].find(j);\n                            blues[x.second].erase(itr1);\n                        }\n                    }\n                }\n                if(justbreak)\n                {\n                    break;\n                }\n                steps++;\n            }\n            if(i==ans.size())\n            {\n                ans.push_back(-1);\n            }\n        }\n        return ans;\n    }\n};\n"
    },
    {
        "slug": "find-the-winner-of-the-circular-game",
        "description": "There are n friends that are playing a game. The friends are sitting in a circle and are numbered from 1 to n in clockwise order. More formally, moving clockwise from the ith friend brings you to the (i+1)th friend for 1 <= i < n, and moving clockwise from the nth friend brings you to the 1st friend.\nThe rules of the game are as follows:\n\nStart at the 1st friend.\nCount the next k friends in the clockwise direction including the friend you started at. The counting wraps around the circle and may count some friends more than once.\nThe last friend you counted leaves the circle and loses the game.\nIf there is still more than one friend in the circle, go back to step 2 starting from the friend immediately clockwise of the friend who just lost and repeat.\nElse, the last friend in the circle wins the game.\n\nGiven the number of friends, n, and an integer k, return the winner of the game.",
        "examples": [
            "Input: n = 5, k = 2\nOutput: 3\nExplanation: Here are the steps of the game:\n1) Start at friend 1.\n2) Count 2 friends clockwise, which are friends 1 and 2.\n3) Friend 2 leaves the circle. Next start is friend 3.\n4) Count 2 friends clockwise, which are friends 3 and 4.\n5) Friend 4 leaves the circle. Next start is friend 5.\n6) Count 2 friends clockwise, which are friends 5 and 1.\n7) Friend 1 leaves the circle. Next start is friend 3.\n8) Count 2 friends clockwise, which are friends 3 and 5.\n9) Friend 5 leaves the circle. Only friend 3 is left, so they are the winner.",
            "Input: n = 6, k = 5\nOutput: 1\nExplanation: The friends leave in this order: 5, 4, 6, 2, 3. The winner is friend 1."
        ],
        "constraints": "1 <= k <= n <= 500",
        "oracle_code": "class Solution {\npublic:\n    int findTheWinner(int n, int k) {\n        vector<int> v;\n        for (int i=1; i<=n; i++)v.push_back(i);\n        int i=0;\n        while (v.size() != 1){\n            i= (i+k-1)%(v.size());\n            //cout<<v[i]<<endl;\n            v.erase(v.begin()+i);\n        }\n        return v[0];\n    }\n};",
        "content": "## Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n## Code\\n```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        vector<int> v;\\n        for (int i=1; i<=n; i++)v.push_back(i);\\n        int i=0;\\n        while (v.size() != 1){\\n            i= (i+k-1)%(v.size());\\n            //cout<<v[i]<<endl;\\n            v.erase(v.begin()+i);\\n        }\\n        return v[0];\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "indexing error",
            "operation error",
            "undefined keywords from other languages",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    int findTheWinner(int n, int k) {\n        vector<int> v;\n        for (int i=1; i<=n+1; i++)v.push_back(i);\n        int i=0;\n        undefined(i+k)%(v.size());\n        while (v.size() != 1{\n            i= (i+k-1)%(v.size());\n            //cout<<v[i]<<endl;\n            v.erase(v.begin()+i);\n        }\n        return v[0];\n    }\n};\n\n"
    },
    {
        "slug": "shortest-path-with-alternating-colors",
        "description": "You are given an integer n, the number of nodes in a directed graph where the nodes are labeled from 0 to n - 1. Each edge is red or blue in this graph, and there could be self-edges and parallel edges.\nYou are given two arrays redEdges and blueEdges where:\n\nredEdges[i] = [ai, bi] indicates that there is a directed red edge from node ai to node bi in the graph, and\nblueEdges[j] = [uj, vj] indicates that there is a directed blue edge from node uj to node vj in the graph.\n\nReturn an array answer of length n, where each answer[x] is the length of the shortest path from node 0 to node x such that the edge colors alternate along the path, or -1 if such a path does not exist.",
        "examples": [
            "Input: n = 3, redEdges = [[0,1],[1,2]], blueEdges = []\nOutput: [0,1,-1]",
            "Input: n = 3, redEdges = [[0,1]], blueEdges = [[2,1]]\nOutput: [0,1,-1]"
        ],
        "constraints": "1 <= n <= 100\n0 <= redEdges.length,\u00a0blueEdges.length <= 400\nredEdges[i].length == blueEdges[j].length == 2\n0 <= ai, bi, uj, vj < n",
        "oracle_code": "class Solution {\npublic:\n    vector<int> shortestAlternatingPaths(int n,vector<vector<int>>&redEdges,vector<vector<int>>& blueEdges) \n    {\n        multiset<int>temp;\n        vector<multiset<int>>redchilds(n,temp),bluechilds(n,temp);\n        for(auto j:redEdges)\n        {\n            redchilds[j[0]].insert(j[1]);\n        }\n        for(auto j:blueEdges)\n        {\n            bluechilds[j[0]].insert(j[1]);\n        }\n        vector<int>ans;\n        for(int i=0;i<n;i++)\n        {\n            //BFS for all\n            vector<multiset<int>>reds=redchilds,blues=bluechilds;\n            queue<pair<char,int>>visit;\n            visit.push({'n',0});//neutral='n'\n            int steps=0;\n            while(!visit.empty())\n            {\n                bool justbreak=false;\n                int n=visit.size();\n                for(int j=0;j<n;j++)\n                {\n                    pair<char,int>x=visit.front();\n                    visit.pop();\n                    if(x.second==i)\n                    {\n                        ans.push_back(steps);\n                        justbreak=true;\n                        break;\n                    }\n                    if(x.first=='n')\n                    {\n                        for(auto j:reds[x.second])\n                        {\n                            visit.push({'r',j});\n                            auto itr1=reds[x.second].find(j);\n                            reds[x.second].erase(itr1);\n                        }\n                        for(auto j:blues[x.second])\n                        {\n                            visit.push({'b',j});//blue='b'\n                            auto itr1=blues[x.second].find(j);\n                            blues[x.second].erase(itr1);\n                        }\n                    }\n                    else if(x.first=='b')\n                    {\n                        for(auto j:reds[x.second])\n                        {\n                            visit.push({'r',j});//red='r'\n                            auto itr1=reds[x.second].find(j);\n                            reds[x.second].erase(itr1);\n                        }\n                    }\n                    else if(x.first=='r')\n                    {\n                        for(auto j:blues[x.second])\n                        {\n                            visit.push({'b',j});\n                            auto itr1=blues[x.second].find(j);\n                            blues[x.second].erase(itr1);\n                        }\n                    }\n                }\n                if(justbreak)\n                {\n                    break;\n                }\n                steps++;\n            }\n            if(i==ans.size())\n            {\n                ans.push_back(-1);\n            }\n        }\n        return ans;\n    }\n};",
        "content": "*E denotes number of Edges*\\n\\n# Complexity\\n- Time complexity:\\nO((N^2)+(N)*(E)*LOG(E))\\n\\n- Space complexity:\\nO(E)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> shortestAlternatingPaths(int n,vector<vector<int>>&redEdges,vector<vector<int>>& blueEdges) \\n    {\\n        multiset<int>temp;\\n        vector<multiset<int>>redchilds(n,temp),bluechilds(n,temp);\\n        for(auto j:redEdges)\\n        {\\n            redchilds[j[0]].insert(j[1]);\\n        }\\n        for(auto j:blueEdges)\\n        {\\n            bluechilds[j[0]].insert(j[1]);\\n        }\\n        vector<int>ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            //BFS for all\\n            vector<multiset<int>>reds=redchilds,blues=bluechilds;\\n            queue<pair<char,int>>visit;\\n            visit.push({\\'n\\',0});//neutral=\\'n\\'\\n            int steps=0;\\n            while(!visit.empty())\\n            {\\n                bool justbreak=false;\\n                int n=visit.size();\\n                for(int j=0;j<n;j++)\\n                {\\n                    pair<char,int>x=visit.front();\\n                    visit.pop();\\n                    if(x.second==i)\\n                    {\\n                        ans.push_back(steps);\\n                        justbreak=true;\\n                        break;\\n                    }\\n                    if(x.first==\\'n\\')\\n                    {\\n                        for(auto j:reds[x.second])\\n                        {\\n                            visit.push({\\'r\\',j});\\n                            auto itr1=reds[x.second].find(j);\\n                            reds[x.second].erase(itr1);\\n                        }\\n                        for(auto j:blues[x.second])\\n                        {\\n                            visit.push({\\'b\\',j});//blue=\\'b\\'\\n                            auto itr1=blues[x.second].find(j);\\n                            blues[x.second].erase(itr1);\\n                        }\\n                    }\\n                    else if(x.first==\\'b\\')\\n                    {\\n                        for(auto j:reds[x.second])\\n                        {\\n                            visit.push({\\'r\\',j});//red=\\'r\\'\\n                            auto itr1=reds[x.second].find(j);\\n                            reds[x.second].erase(itr1);\\n                        }\\n                    }\\n                    else if(x.first==\\'r\\')\\n                    {\\n                        for(auto j:blues[x.second])\\n                        {\\n                            visit.push({\\'b\\',j});\\n                            auto itr1=blues[x.second].find(j);\\n                            blues[x.second].erase(itr1);\\n                        }\\n                    }\\n                }\\n                if(justbreak)\\n                {\\n                    break;\\n                }\\n                steps++;\\n            }\\n            if(i==ans.size())\\n            {\\n                ans.push_back(-1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "== and = confusion",
            "conditional statement error",
            "undefined methods",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    vector<int> shortestAlternatingPaths(int n,vector<vector<int>>&redEdges,vector<vector<int>>& blueEdges) \n    {\n        multiset<int>temp;\n        vector<multiset<int>>redchilds(n,temp),bluechilds(n,temp);\n        for(auto j:redEdges)\n        {\n            redchilds[j[0]].insert(j[1]);\n        }\n        for(auto j:blueEdges)\n        {\n            bluechilds[j[0]].insert(j[1]);\n        }\n        vector<int>ans(n, -1);\n        for(int i=0;i<n;) \n        {\n            //BFS for all\n            vector<multiset<int>>reds=redchilds,blues=bluechilds;\n            queue<pair<char,int>>visit;\n            visit.push({'n',0});//neutral='n'\n            int steps=0;\n            while(!visit.empty()\n            {\n                bool justbreak=false;\n                int n=visit.size();\n                for(int j=0;j<n;j++)\n                {\n                    pair<char,int>x=visit.front();\n                    visit.pop();\n                    if(x.second=i)\n                    {\n                        ans[i]=steps;\n                        justbreak=true;\n                        break;\n                    }\n                    if(x.first=='n' || x.first == ans[i] % 2 + '0') \n                    {\n                        for(auto j:reds[x.second])\n                        {\n                            visit.push({'r',j});\n                            auto itr1=reds[x.second].find(j);\n                            reds[x.second].erase(itr1);\n                        }\n                        for(auto j:blues[x.second])\n                        {\n                            visit.push({'b',j});//blue='b'\n                            auto itr1=blues[x.second].find(j);\n                            unknownFunction(itr1); \n                            blues[x.second].erase(itr1);\n                        }\n                    }\n                    else if(x.first=='b')\n                    {\n                        for(auto j:reds[x.second])\n                        {\n                            visit.push({'r',j});//red='r'\n                            auto itr1=reds[x.second].find(j);\n                            reds[x.second].erase(itr1);\n                        }\n                    }\n                    else if(x.first=='r')\n                    {\n                        for(auto j:blues[x.second])\n                        {\n                            visit.push({'b',j});\n                            auto itr1=blues[x.second].find(j);\n                            blues[x.second].erase(itr1);\n                        }\n                    }\n                }\n                if(justbreak)\n                {\n                    break;\n                }\n                steps++;\n            }\n        }\n        return ans;\n    }\n};\n"
    },
    {
        "slug": "remove-outermost-parentheses",
        "description": "A valid parentheses string is either empty \"\", \"(\" + A + \")\", or A + B, where A and B are valid parentheses strings, and + represents string concatenation.\n\nFor example, \"\", \"()\", \"(())()\", and \"(()(()))\" are all valid parentheses strings.\n\nA valid parentheses string s is primitive if it is nonempty, and there does not exist a way to split it into s = A + B, with A and B nonempty valid parentheses strings.\nGiven a valid parentheses string s, consider its primitive decomposition: s = P1 + P2 + ... + Pk, where Pi are primitive valid parentheses strings.\nReturn s after removing the outermost parentheses of every primitive string in the primitive decomposition of s.",
        "examples": [
            "Input: s = \"(()())(())\"\nOutput: \"()()()\"\nExplanation: \nThe input string is \"(()())(())\", with primitive decomposition \"(()())\" + \"(())\".\nAfter removing outer parentheses of each part, this is \"()()\" + \"()\" = \"()()()\".",
            "Input: s = \"(()())(())(()(()))\"\nOutput: \"()()()()(())\"\nExplanation: \nThe input string is \"(()())(())(()(()))\", with primitive decomposition \"(()())\" + \"(())\" + \"(()(()))\".\nAfter removing outer parentheses of each part, this is \"()()\" + \"()\" + \"()(())\" = \"()()()()(())\".",
            "Input: s = \"()()\"\nOutput: \"\"\nExplanation: \nThe input string is \"()()\", with primitive decomposition \"()\" + \"()\".\nAfter removing outer parentheses of each part, this is \"\" + \"\" = \"\"."
        ],
        "constraints": "1 <= s.length <= 105\ns[i] is either '(' or ')'.\ns is a valid parentheses string.",
        "oracle_code": "class Solution {\npublic:\n    string removeOuterParentheses(string s) {\n        stack<char> st;\n        string res=\"\";\n        for(int i=0;i<s.size();i++){\n            if(s[i]=='(' && st.empty()){\n                st.push(s[i]);\n            }\n            else if(s[i]=='('){\n                st.push(s[i]);\n                res+=s[i];\n            }\n            else{\n                st.pop();\n                if(st.size()){\n                    res+=s[i];\n                }\n            }\n        }\n        return res;\n    }\n};",
        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        stack<char> st;\\n        string res=\"\";\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'(\\' && st.empty()){\\n                st.push(s[i]);\\n            }\\n            else if(s[i]==\\'(\\'){\\n                st.push(s[i]);\\n                res+=s[i];\\n            }\\n            else{\\n                st.pop();\\n                if(st.size()){\\n                    res+=s[i];\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "== and = confusion",
            "unclosed string",
            "colon missing",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    string removeOuterParentheses(string s) {\n        stack<char> st;\n        string res=\";\n        for(int i=0;i<s.size();i++)\n            if(s[i]=='(' && st.empty())\n                st.push(s[i]);\n            else if(s[i]=='(')\n                st.push(s[i]);\n                res+=s[i];\n            else{\n                st.pop();\n                if(st.size())\n                    res+=s[i];\n                }\n        undfinedObject }\n        =1return res;\n    }\n};\n\n\n"
    },
    {
        "slug": "rotate-array",
        "description": "Given an integer array nums, rotate the array to the right by k steps, where k is non-negative.",
        "examples": [
            "Input: nums = [1,2,3,4,5,6,7], k = 3\nOutput: [5,6,7,1,2,3,4]\nExplanation:\nrotate 1 steps to the right: [7,1,2,3,4,5,6]\nrotate 2 steps to the right: [6,7,1,2,3,4,5]\nrotate 3 steps to the right: [5,6,7,1,2,3,4]",
            "Input: nums = [-1,-100,3,99], k = 2\nOutput: [3,99,-1,-100]\nExplanation: \nrotate 1 steps to the right: [99,-1,-100,3]\nrotate 2 steps to the right: [3,99,-1,-100]"
        ],
        "constraints": "1 <= nums.length <= 105\n-231 <= nums[i] <= 231 - 1\n0 <= k <= 105",
        "oracle_code": "class Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        int n=nums.size();\n        vector<int> temp(nums.size());\n        for(int i=0;i<n;i++){\n            temp[(i+k)%n]=nums[i];\n        }\n        nums=temp;\n    }\n};",
        "content": "# Approach\\nhere i is of loop which starts form (0,1,2...) k is the value how many times you want to rotate and n is the size of first vector ,and after that new indexes will be generated in our temp vector and we have to put values of nums vector at new indexes . . . \\nlike for first  arr[1,2,3,4,5,6,7]  and k=3     so ,\\ntemp[0 + 3 % 7]=nums[i]\\ntemp[3 % 7]=nums[i]\\ntemp[3] = nums[i]\\n[_ , _ , _ , 1 , _ ,_ , _ ]\\nfor next ,\\ntemp[1 + 3 % 7]=nums[i]\\ntemp[4 % 7]=nums[i]\\ntemp[4] = nums[i]\\n[_ , _ , _ , 1 , 2 ,_ , _ ]   and so on \\ni hope you understand ..\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int> temp(nums.size());\\n        for(int i=0;i<n;i++){\\n            temp[(i+k)%n]=nums[i];\\n        }\\n        nums=temp;\\n    }\\n};\\n```\\n![upvote 1.jpeg](https://assets.leetcode.com/users/images/565d5fa5-1370-44d9-a6b6-0cf06d575aae_1681731352.2608747.jpeg)\\n",
        "level": "medium",
        "type": [
            "indexing error",
            "conditional statement error",
            "colon missing",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        int n=nums.size();\n        vector<int> temp(nums.size();\n        for(int i=0;i<=n;i++);\n        {\n            temp[(i+k)%n]=nums[i+1];\n        }\n        nums=temp;\n    }\n};\n"
    },
    {
        "slug": "find-the-punishment-number-of-an-integer",
        "description": "Given a positive integer n, return the punishment number of n.\nThe punishment number of n is defined as the sum of the squares of all integers i such that:\n\n1 <= i <= n\nThe decimal representation of i * i can be partitioned into contiguous substrings such that the sum of the integer values of these substrings equals i.",
        "examples": [
            "Input: n = 10\nOutput: 182\nExplanation: There are exactly 3 integers i that satisfy the conditions in the statement:\n- 1 since 1 * 1 = 1\n- 9 since 9 * 9 = 81 and 81 can be partitioned into 8 + 1.\n- 10 since 10 * 10 = 100 and 100 can be partitioned into 10 + 0.\nHence, the punishment number of 10 is 1 + 81 + 100 = 182",
            "Input: n = 37\nOutput: 1478\nExplanation: There are exactly 4 integers i that satisfy the conditions in the statement:\n- 1 since 1 * 1 = 1. \n- 9 since 9 * 9 = 81 and 81 can be partitioned into 8 + 1. \n- 10 since 10 * 10 = 100 and 100 can be partitioned into 10 + 0. \n- 36 since 36 * 36 = 1296 and 1296 can be partitioned into 1 + 29 + 6.\nHence, the punishment number of 37 is 1 + 81 + 100 + 1296 = 1478"
        ],
        "constraints": "1 <= n <= 1000",
        "oracle_code": "class Solution {\npublic:\n    \n    bool valid(int n, string s,int sum){\n        // empty string indicates we have completed one partition\n        if(s==\"\") if(sum==n) return true;\n\n        // We use backtracking to check for all partitions if it is possible to generate required sum \n        // and if we find sum we immediately return true immediately\n        for(int i=1;i<=s.size();i++){\n            int x  = stoi(s.substr(0,i));\n            if(valid(n, s.substr(i), sum+x)) return true;\n        }\n        \n        //If no partition could add up to required sum n\n        return false;\n    }\n    int punishmentNumber(int n) {\n        int ans = 0;\n\n        //generate all possible squares and check them if they satisfy the given statement\n        for(int i=1;i<=n;i++){\n            int sq = i*i;\n            string x = to_string(sq);\n            if(valid(i,x,0)) ans += i*i;\n        }\n        \n        return ans;\n        \n    }\n};",
        "content": "# Intuition\\nThe main idea of this problem is to generate all non empty partitions of a string using Backtracking.\\n\\nFor example let\\'s  say i = 36, it\\'s square = 36*36 = 1296\\nTo check if some partition of 1296 satisfy given statement, we make all partitions e.g\\n[1,2,9,6], [1,29,6], [1,296], [12,9,6] , [12,96], [129,6]\\n\\nAmong these only [1,29,6] satisfies the constraint.\\n\\nWe only need one of these set to satisfy the statement, hence we break immediately if we find any valid set.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n* Generate all possible squares and check if they satisfy the given statement\\n* To check if a square satisfies the given constraint or not generate all possible partitions using backtracking.\\n* If any single partition satisfy the statement then this square will be added to solution\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity :  O(n*(2^6)), here 6 is the maxm square length that is len(1000*1000) = 6\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    bool valid(int n, string s,int sum){\\n        // empty string indicates we have completed one partition\\n        if(s==\"\") if(sum==n) return true;\\n\\n        // We use backtracking to check for all partitions if it is possible to generate required sum \\n        // and if we find sum we immediately return true immediately\\n        for(int i=1;i<=s.size();i++){\\n            int x  = stoi(s.substr(0,i));\\n            if(valid(n, s.substr(i), sum+x)) return true;\\n        }\\n        \\n        //If no partition could add up to required sum n\\n        return false;\\n    }\\n    int punishmentNumber(int n) {\\n        int ans = 0;\\n\\n        //generate all possible squares and check them if they satisfy the given statement\\n        for(int i=1;i<=n;i++){\\n            int sq = i*i;\\n            string x = to_string(sq);\\n            if(valid(i,x,0)) ans += i*i;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "== and = confusion",
            "conditional statement error",
            "undefined methods",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    \n    bool valid(int n, string s,int sum){\n        // empty string indicates we have completed one partition\n        if(s==\"\") if(sum=n) return true; \n\n        // We use backtracking to check for all partitions if it is possible to generate required sum \n        // and if we find sum we immediately return true immediately\n        for(int i=1;i<=s.size();i++){\n            int x  = parseInt(s.substr(0,i));\n            if(valid(n, s.substr(i), sum+x)) return false;\n        }\n        \n        //If no partition could add up to required sum n\n        return false;\n    }\n    int punishmentNumber(int n) {\n        int ans = 0;\n\n        //generate all possible squares and check them if they satisfy the given statement\n        for(int i=1;i<=n;i++){\n            int sq = i*i;\n            string x = to_string(sq);\n            if(valid(i,x,0)) ans += i*i;\n        }\n        \n        \n        return checkAdditionalCondition(ans);\n    }\n};\n"
    },
    {
        "slug": "kth-largest-element-in-a-stream",
        "description": "Design a class to find the kth largest element in a stream. Note that it is the kth largest element in the sorted order, not the kth distinct element.\nImplement KthLargest class:\n\nKthLargest(int k, int[] nums) Initializes the object with the integer k and the stream of integers nums.\nint add(int val) Appends the integer val to the stream and returns the element representing the kth largest element in the stream.",
        "examples": [
            "Input\n[\"KthLargest\", \"add\", \"add\", \"add\", \"add\", \"add\"]\n[[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]\nOutput\n[null, 4, 5, 5, 8, 8]\n\nExplanation\nKthLargest kthLargest = new KthLargest(3, [4, 5, 8, 2]);\nkthLargest.add(3);   // return 4\nkthLargest.add(5);   // return 5\nkthLargest.add(10);  // return 5\nkthLargest.add(9);   // return 8\nkthLargest.add(4);   // return 8"
        ],
        "constraints": "1 <= k <= 104\n0 <= nums.length <= 104\n-104 <= nums[i] <= 104\n-104 <= val <= 104\nAt most 104 calls will be made to add.\nIt is guaranteed that there will be at least k elements in the array when you search for the kth element.",
        "oracle_code": "class KthLargest {\npublic:\n    priority_queue<int,vector<int>,greater<int>> pq;\n    int position;\n    KthLargest(int k, vector<int>& nums) {\n        position=k;\n        for(int i=0; i<nums.size(); i++){\n            if(pq.size()<k){\n                pq.push(nums[i]);\n            }\n            else if(pq.top()<nums[i]){\n                pq.pop();\n                pq.push(nums[i]);\n            }\n        }\n    }\n    \n    int add(int val) {\n        if(pq.size()<position){\n            pq.push(val);\n        }\n        else if(pq.top()<val){\n            pq.pop();\n            pq.push(val);\n        }\n        return pq.top();\n    }\n};\n\n/**\n * Your KthLargest object will be instantiated and called as such:\n * KthLargest* obj = new KthLargest(k, nums);\n * int param_1 = obj->add(val);\n */",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass KthLargest {\\npublic:\\n    priority_queue<int,vector<int>,greater<int>> pq;\\n    int position;\\n    KthLargest(int k, vector<int>& nums) {\\n        position=k;\\n        for(int i=0; i<nums.size(); i++){\\n            if(pq.size()<k){\\n                pq.push(nums[i]);\\n            }\\n            else if(pq.top()<nums[i]){\\n                pq.pop();\\n                pq.push(nums[i]);\\n            }\\n        }\\n    }\\n    \\n    int add(int val) {\\n        if(pq.size()<position){\\n            pq.push(val);\\n        }\\n        else if(pq.top()<val){\\n            pq.pop();\\n            pq.push(val);\\n        }\\n        return pq.top();\\n    }\\n};\\n\\n/**\\n * Your KthLargest object will be instantiated and called as such:\\n * KthLargest* obj = new KthLargest(k, nums);\\n * int param_1 = obj->add(val);\\n */\\n```",
        "level": "easy",
        "type": [
            "indexing error",
            "wrong comment mark",
            "conditional statement error",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass KthLargest {\npublic:\n    priority_queue<int,vector<int>,greater<int>> pq;\n    int position;\n    KthLargest(int k, vector<int>& nums) {\n        position=k;\n        /* for(int i=0; i<=nums.size(); i++){\n            if(pq.size()<k){\n                pq.push(nums[i]);\n            }\n            else if(pq.top()<nums[i]){\n                pq.pop();\n                pq.push(nums[i]);\n            }\n        }*/\n    }\n    \n    int add(int val) {\n        if(pq.size()<position){\n            pq.push(val);\n        return pq.top();\n    }\n};\n\n"
    },
    {
        "slug": "longest-common-prefix",
        "description": "Write a function to find the longest common prefix string amongst an array of strings.\nIf there is no common prefix, return an empty string \"\".",
        "examples": [
            "Input: strs = [\"flower\",\"flow\",\"flight\"]\nOutput: \"fl\"",
            "Input: strs = [\"dog\",\"racecar\",\"car\"]\nOutput: \"\"\nExplanation: There is no common prefix among the input strings."
        ],
        "constraints": "1 <= strs.length <= 200\n0 <= strs[i].length <= 200\nstrs[i] consists of only lowercase English letters.",
        "oracle_code": "class Solution {\npublic:\n    string longestCommonPrefix(vector<string>& str) \n    {\n        sort(str.begin(), str.end()); //sorting the array\n        string ans=\"\"; //creating a new empty string to store the common prefixes\n        for(int i=0;i<str[0].length();i++) // max iterations = length of the first string\n        {\n            if(str[0][i]!=str[str.size()-1][i]) // checking the characters of the first and last string\n                break;\n            ans+=str[0][i]; // concatinate if the characters are matching\n        }\n        return ans;\n    }\n};",
        "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWhen you sort an array, it is enough to check for the common characters of the the first & last string of the sorted vector.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& str) \\n    {\\n        sort(str.begin(), str.end()); //sorting the array\\n        string ans=\"\"; //creating a new empty string to store the common prefixes\\n        for(int i=0;i<str[0].length();i++) // max iterations = length of the first string\\n        {\\n            if(str[0][i]!=str[str.size()-1][i]) // checking the characters of the first and last string\\n                break;\\n            ans+=str[0][i]; // concatinate if the characters are matching\\n        }\\n        return ans;\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "unclosed string",
            "conditional statement error",
            "colon missing",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    string longestCommonPrefix(vector<string>& str) \n    {\n        sort(str.begin(), str.end()); //sorting the array\n        string ans=\"; \n        for(int i=0;i<str[0].length();i) \n        {\n            if(str[0][i]!=str[str.size()][i]) \n                break;\n            ans+=str[0][i]; // concatinate if the characters are match]ing\n        }\n        return ans;\n    }\n};\n"
    },
    {
        "slug": "find-the-longest-valid-obstacle-course-at-each-position",
        "description": "You want to build some obstacle courses. You are given a 0-indexed integer array obstacles of length n, where obstacles[i] describes the height of the ith obstacle.\nFor every index i between 0 and n - 1 (inclusive), find the length of the longest obstacle course in obstacles such that:\n\nYou choose any number of obstacles between 0 and i inclusive.\nYou must include the ith obstacle in the course.\nYou must put the chosen obstacles in the same order as they appear in obstacles.\nEvery obstacle (except the first) is taller than or the same height as the obstacle immediately before it.\n\nReturn an array ans of length n, where ans[i] is the length of the longest obstacle course for index i as described above.",
        "examples": [
            "Input: obstacles = [1,2,3,2]\nOutput: [1,2,3,3]\nExplanation: The longest valid obstacle course at each position is:\n- i = 0: [1], [1] has length 1.\n- i = 1: [1,2], [1,2] has length 2.\n- i = 2: [1,2,3], [1,2,3] has length 3.\n- i = 3: [1,2,3,2], [1,2,2] has length 3.",
            "Input: obstacles = [2,2,1]\nOutput: [1,2,1]\nExplanation: The longest valid obstacle course at each position is:\n- i = 0: [2], [2] has length 1.\n- i = 1: [2,2], [2,2] has length 2.\n- i = 2: [2,2,1], [1] has length 1.",
            "Input: obstacles = [3,1,5,6,4,2]\nOutput: [1,1,2,3,2,2]\nExplanation: The longest valid obstacle course at each position is:\n- i = 0: [3], [3] has length 1.\n- i = 1: [3,1], [1] has length 1.\n- i = 2: [3,1,5], [3,5] has length 2. [1,5] is also valid.\n- i = 3: [3,1,5,6], [3,5,6] has length 3. [1,5,6] is also valid.\n- i = 4: [3,1,5,6,4], [3,4] has length 2. [1,4] is also valid.\n- i = 5: [3,1,5,6,4,2], [1,2] has length 2."
        ],
        "constraints": "n == obstacles.length\n1 <= n <= 105\n1 <= obstacles[i] <= 107",
        "oracle_code": "class Solution {\npublic:\n    vector<int> longestObstacleCourseAtEachPosition(vector<int>& nums) {\n        \n        int n = nums.size();\n        \n        // lis store elements of longest increasing subsequence till ith\n        \n        vector<int> lis;\n        \n        // ans[i] store, no of elements satisfying the condition including ith\n        \n        vector<int> ans;\n\n        for(int i = 0; i < n; i++)\n        {\n            int idx = upper_bound(lis.begin(), lis.end(), nums[i]) - lis.begin();\n                \n            ans.push_back(idx + 1);\n            \n            if(idx == lis.size())\n                lis.push_back(nums[i]);\n            \n            else\n            {\n                lis[idx] = nums[i];\n            }\n        }\n        \n        return ans;\n    }\n};",
        "content": "* ***Binary Search***\\n\\n* ***Time Complexity :- O(NlogN)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> longestObstacleCourseAtEachPosition(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        // lis store elements of longest increasing subsequence till ith\\n        \\n        vector<int> lis;\\n        \\n        // ans[i] store, no of elements satisfying the condition including ith\\n        \\n        vector<int> ans;\\n\\n        for(int i = 0; i < n; i++)\\n        {\\n            int idx = upper_bound(lis.begin(), lis.end(), nums[i]) - lis.begin();\\n                \\n            ans.push_back(idx + 1);\\n            \\n            if(idx == lis.size())\\n                lis.push_back(nums[i]);\\n            \\n            else\\n            {\\n                lis[idx] = nums[i];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
        "level": "hard",
        "type": [
            "== and = confusion",
            "indexing error",
            "operation error",
            "colon missing"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    vector<int> longestObstacleCourseAtEachPosition(vector<int>& nums) {\n        \n        int n = nums.size();\n        \n        // lis store elements of longest increasing subsequence till ith\n        \n        vector<int> lis;\n        \n        \n        \n        vector<int> ans;\n\n        for(int i = 0; i <= n; i++)\n        {\n            int idx = upper_bound(lis.begin(), lis.end(), nums[i]) - lis.begin();\n                \n            ans.push_back(idx + 2);\n            \n            if(idx = lis.size()) \n                lis.push_back(nums[i]);\n            \n            else\n            {\n                lis[idx] = nums[i];\n            }\n        }\n        \n        return ans;\n    }\n};\n"
    }
]