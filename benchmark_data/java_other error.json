[
    {
        "slug": "subtract-the-product-and-sum-of-digits-of-an-integer",
        "description": "Given an integer number n, return the difference between the product of its digits and the sum of its digits.",
        "examples": [
            "Input: n = 234\nOutput: 15 \nExplanation: \nProduct of digits = 2 * 3 * 4 = 24 \nSum of digits = 2 + 3 + 4 = 9 \nResult = 24 - 9 = 15",
            "Input: n = 4421\nOutput: 21\nExplanation: \nProduct of digits = 4 * 4 * 2 * 1 = 32 \nSum of digits = 4 + 4 + 2 + 1 = 11 \nResult = 32 - 11 = 21"
        ],
        "constraints": "1 <= n <= 10^5",
        "release_time": 1683098100,
        "oracle_code": "class Solution {\n    public int subtractProductAndSum(int n) {\n        \n        int multi=1, sum=0;\n        while(n!=0){\n            int rem=n%10; //take last digit of n\n            sum+=rem;\n            multi*=rem;\n            n=n/10; // dropping last digit of n\n        }\n        // System.out.println(multi+\" \"+sum);\n        return multi - sum;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int subtractProductAndSum(int n) {\\n        \\n        int multi=1, sum=0;\\n        while(n!=0){\\n            int rem=n%10; //take last digit of n\\n            sum+=rem;\\n            multi*=rem;\\n            n=n/10; // dropping last digit of n\\n        }\\n        // System.out.println(multi+\" \"+sum);\\n        return multi - sum;\\n    }\\n}\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\n    public int subtractProductAndSum(int n) {\n        \n        int multi=1, sum=0;\n        while(n!=0){\n            int rem=n%10; //take last digit of n\n            sum+=rem;\n            multi+=rem; \n            n=n/10; // dropping last digit of n\n        }\n        // System.out.println(multi+\" \"+sum);\n        return multi - sum;\n    }\n}\n",
        "explanations": "\nOperator was changed from multiplication *= to addition +=, causing the product operation to fail.\n"
    },
    {
        "slug": "count-good-nodes-in-binary-tree",
        "description": "Given a binary tree root, a node X in the tree is named\u00a0good if in the path from root to X there are no nodes with a value greater than X.\nReturn the number of good nodes in the binary tree.",
        "examples": [
            "Input: root = [3,1,4,3,null,1,5]\r\nOutput: 4\r\nExplanation: Nodes in blue are good.\r\nRoot Node (3) is always a good node.\r\nNode 4 -> (3,4) is the maximum value in the path starting from the root.\r\nNode 5 -> (3,4,5) is the maximum value in the path\r\nNode 3 -> (3,1,3) is the maximum value in the path.",
            "Input: root = [3,3,null,4,2]\r\nOutput: 3\r\nExplanation: Node 2 -> (3, 3, 2) is not good, because \"3\" is higher than it.",
            "Input: root = [1]\r\nOutput: 1\r\nExplanation: Root is considered as good."
        ],
        "constraints": "The number of nodes in the binary tree is in the range\u00a0[1, 10^5].\nEach node's value is between [-10^4, 10^4].",
        "release_time": 1690560837,
        "oracle_code": "class Solution {\n    int count = 0;\n    \n    public void countGoodNodes(TreeNode root, int maximum) {\n            if(root!=null) {\n                if (maximum <= root.val) {\n                    maximum = root.val;\n                    count++;\n                }\n            countGoodNodes(root.left,maximum);\n            countGoodNodes(root.right, maximum);\n        } \n    }\n\n    public int goodNodes(TreeNode root) {\n        int maximum = root.val;\n        countGoodNodes(root,  maximum);\n        return count;\n    }\n}",
        "content": "# Code\\n```\\nclass Solution {\\n    int count = 0;\\n    \\n    public void countGoodNodes(TreeNode root, int maximum) {\\n            if(root!=null) {\\n                if (maximum <= root.val) {\\n                    maximum = root.val;\\n                    count++;\\n                }\\n            countGoodNodes(root.left,maximum);\\n            countGoodNodes(root.right, maximum);\\n        } \\n    }\\n\\n    public int goodNodes(TreeNode root) {\\n        int maximum = root.val;\\n        countGoodNodes(root,  maximum);\\n        return count;\\n    }\\n}\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\n    int count = 0;\n    \n    public void countGoodNodes(TreeNode root, int maximum) {\n            if(root!=null) {\n                if (maximum <= root.val) {\n                    maximum = root.val;\n                    count++;\n                }\n            countGoodNodes(root.left,maximum);\n        } \n            countGoodNodes(root.right, maximum);\n    }\n\n    public int goodNodes(TreeNode root) {\n        int maximum = root.val;\n        countGoodNodes(root,  maximum);\n        return count;\n    }\n}\n",
        "explanations": "\nThe recursion call for the right child node is outside the null check, causing NullPointerException.\n"
    },
    {
        "slug": "smallest-range-covering-elements-from-k-lists",
        "description": "You have k lists of sorted integers in non-decreasing\u00a0order. Find the smallest range that includes at least one number from each of the k lists.\nWe define the range [a, b] is smaller than range [c, d] if b - a < d - c or a < c if b - a == d - c.",
        "examples": [
            "Input: nums = [[4,10,15,24,26],[0,9,12,20],[5,18,22,30]]\nOutput: [20,24]\nExplanation: \nList 1: [4, 10, 15, 24,26], 24 is in range [20,24].\nList 2: [0, 9, 12, 20], 20 is in range [20,24].\nList 3: [5, 18, 22, 30], 22 is in range [20,24].",
            "Input: nums = [[1,2,3],[1,2,3],[1,2,3]]\nOutput: [1,1]"
        ],
        "constraints": "nums.length == k\n1 <= k <= 3500\n1 <= nums[i].length <= 50\n-105 <= nums[i][j] <= 105\nnums[i]\u00a0is sorted in non-decreasing order.",
        "release_time": 1674752084,
        "oracle_code": "class Solution {\n    public int[] smallestRange(List<List<Integer>> nums) {\n        int k = nums.size();\n        List<Pair<Integer,Integer>> list = new ArrayList<>();\n        for(int i = 0;i<k;i++){\n            List<Integer> l = nums.get(i);\n            for(int nu : l){\n                list.add(new Pair(nu,i));\n            }\n        }\n        \n        Collections.sort(list,(a,b)-> a.getKey()-b.getKey());\n        int[] ans = new int[2];\n        ans[1] = ans[0] = Integer.MAX_VALUE; \n        int i = 0,j=0;\n        List<Integer> store = new ArrayList<>();\n        HashMap<Integer,Integer> mp = new HashMap<>();\n        int totalType = 0;\n        \n        while(j<list.size()){\n            int nu = list.get(j).getKey();\n            int type = list.get(j).getValue();\n            store.add(nu);\n            int val = mp.getOrDefault(type,0);\n            mp.put(type,val+1);\n            totalType++;\n            if(mp.size()<k){\n                j++;\n            }else if(mp.size()==k){\n                if(ans[0]==ans[1] && ans[1] == Integer.MAX_VALUE){\n                    ans[0] = store.get(0);\n                    ans[1] = store.get(store.size()-1);\n                }\n                int dif = store.get(store.size()-1)-store.get(0);\n                if(dif<ans[1]-ans[0]){\n                    ans[0] = store.get(0);\n                    ans[1] = store.get(store.size()-1);\n                }  \n                \n                while(mp.size()==k){\n                    dif = store.get(store.size()-1)-store.get(0);\n                    if(dif<ans[1]-ans[0]){\n                        ans[0] = store.get(0);\n                        ans[1] = store.get(store.size()-1);\n                    }\n                    store.remove(0);\n                    int t = list.get(i).getValue();\n                    int vv = (int) mp.get(t);\n                    mp.put(t,vv-1);\n                    if(vv==1){\n                        mp.remove(t);\n                    }\n                    i++;\n                }\n                \n                j++;\n                \n            }\n   \n        }\n        \n        \n        return ans;\n    }\n}",
        "content": "```\\nclass Solution {\\n    public int[] smallestRange(List<List<Integer>> nums) {\\n        int k = nums.size();\\n        List<Pair<Integer,Integer>> list = new ArrayList<>();\\n        for(int i = 0;i<k;i++){\\n            List<Integer> l = nums.get(i);\\n            for(int nu : l){\\n                list.add(new Pair(nu,i));\\n            }\\n        }\\n        \\n        Collections.sort(list,(a,b)-> a.getKey()-b.getKey());\\n        int[] ans = new int[2];\\n        ans[1] = ans[0] = Integer.MAX_VALUE; \\n        int i = 0,j=0;\\n        List<Integer> store = new ArrayList<>();\\n        HashMap<Integer,Integer> mp = new HashMap<>();\\n        int totalType = 0;\\n        \\n        while(j<list.size()){\\n            int nu = list.get(j).getKey();\\n            int type = list.get(j).getValue();\\n            store.add(nu);\\n            int val = mp.getOrDefault(type,0);\\n            mp.put(type,val+1);\\n            totalType++;\\n            if(mp.size()<k){\\n                j++;\\n            }else if(mp.size()==k){\\n                if(ans[0]==ans[1] && ans[1] == Integer.MAX_VALUE){\\n                    ans[0] = store.get(0);\\n                    ans[1] = store.get(store.size()-1);\\n                }\\n                int dif = store.get(store.size()-1)-store.get(0);\\n                if(dif<ans[1]-ans[0]){\\n                    ans[0] = store.get(0);\\n                    ans[1] = store.get(store.size()-1);\\n                }  \\n                \\n                while(mp.size()==k){\\n                    dif = store.get(store.size()-1)-store.get(0);\\n                    if(dif<ans[1]-ans[0]){\\n                        ans[0] = store.get(0);\\n                        ans[1] = store.get(store.size()-1);\\n                    }\\n                    store.remove(0);\\n                    int t = list.get(i).getValue();\\n                    int vv = (int) mp.get(t);\\n                    mp.put(t,vv-1);\\n                    if(vv==1){\\n                        mp.remove(t);\\n                    }\\n                    i++;\\n                }\\n                \\n                j++;\\n                \\n            }\\n   \\n        }\\n        \\n        \\n        return ans;\\n    }\\n}\\n```",
        "level": "hard",
        "buggy_code": "\nclass Solution {\n    public int[] smallestRange(List<List<Integer>> nums) {\n        int k = nums.size();\n        List<Pair<Integer,Integer>> list = new ArrayList<>();\n        for(int i = 0;i<k;i++){\n            List<Integer> l = nums.get(i);\n            for(int nu : l){\n                list.add(new Pair(nu,i));\n            }\n        }\n        \n        Collections.sort(list,(a,b)-> a.getKey()-b.getKey());\n        int[] ans = new int[2];\n        ans[1] = ans[0] = Integer.MAX_VALUE; \n        int i = 0,j=0;\n        List<Integer> store = new ArrayList<>();\n        HashMap<Integer,Integer> mp = new HashMap<>();\n        int totalType = 0;\n        \n        while(j<list.size()){\n            int nu = list.get(j).getKey();\n            int type = list.get(j).getValue();\n            store.add(nu);\n            int val = mp.getOrDefault(type,0);\n            mp.put(type,val+1);\n            totalType++;\n            if(mp.size()<k){\n                j++;\n            }else if(mp.size()==k){\n                if(ans[0]==ans[1] && ans[1] == Integer.MAX_VALUE){\n                    ans[0] = store.get(0);\n                    ans[1] = store.get(store.size()-1);\n                }\n                int dif = store.get(store.size()-1)-store.get(0);\n                if(dif<ans[1]-ans[0]){\n                    ans[0] = store.get(0);\n                    ans[1] = store.get(store.size()-1);\n                }  \n                \n                while(mp.size()==k){\n                    dif = store.get(store.size()-1)-store.get(0);\n                    if(dif<ans[1]-ans[0]){\n                        ans[0] = store.get(0);\n                        ans[1] = store.get(store.size()-1);\n                    }\n                    store.remove(0);\n                    int t = list.get(i).getValue();\n                    int vv = (int) mp.get(t);\n                    if(vv==1){\n                        mp.remove(t);\n                    }\n                    i++;\n                }\n                \n                j++;\n                \n            }\n   \n        }\n        \n        \n        return ans;\n    }\n}\n",
        "explanations": "\nThe totalType increment is not following any conditional statement. It may cause miscalculations.\n"
    },
    {
        "slug": "longest-string-chain",
        "description": "You are given an array of words where each word consists of lowercase English letters.\nwordA is a predecessor of wordB if and only if we can insert exactly one letter anywhere in wordA without changing the order of the other characters to make it equal to wordB.\n\nFor example, \"abc\" is a predecessor of \"abac\", while \"cba\" is not a predecessor of \"bcad\".\n\nA word chain is a sequence of words [word1, word2, ..., wordk] with k >= 1, where word1 is a predecessor of word2, word2 is a predecessor of word3, and so on. A single word is trivially a word chain with k == 1.\nReturn the length of the longest possible word chain with words chosen from the given list of words.",
        "examples": [
            "Input: words = [\"a\",\"b\",\"ba\",\"bca\",\"bda\",\"bdca\"]\nOutput: 4\nExplanation: One of the longest word chains is [\"a\",\"ba\",\"bda\",\"bdca\"].",
            "Input: words = [\"xbc\",\"pcxbcf\",\"xb\",\"cxbc\",\"pcxbc\"]\nOutput: 5\nExplanation: All the words can be put in a word chain [\"xb\", \"xbc\", \"cxbc\", \"pcxbc\", \"pcxbcf\"].",
            "Input: words = [\"abcd\",\"dbqca\"]\nOutput: 1\nExplanation: The trivial word chain [\"abcd\"] is one of the longest word chains.\n[\"abcd\",\"dbqca\"] is not a valid word chain because the ordering of the letters is changed."
        ],
        "constraints": "1 <= words.length <= 1000\n1 <= words[i].length <= 16\nwords[i] only consists of lowercase English letters.",
        "release_time": 1682338998,
        "oracle_code": "class Solution {\n    public int longestStrChain(String[] words) {\n        // Sort the array in increasing order of word length\n        Arrays.sort(words, (a, b) -> a.length() - b.length());\n        \n        // Create a map to store the longest chain ending at each word\n        Map<String, Integer> dp = new HashMap<>();\n        int maxChainLength = 1;\n        \n        // Iterate through each word in the array\n        for (String word : words) {\n            // Initialize the longest chain for the current word as 1\n            int longestChain = 1;\n            // Generate all possible predecessor words of the current word\n            for (int i = 0; i < word.length(); i++) {\n                StringBuilder sb = new StringBuilder(word);\n                sb.deleteCharAt(i);\n                String predecessor = sb.toString();\n                // If the predecessor word is in the map, update the longest chain for the current word\n                if (dp.containsKey(predecessor)) {\n                    longestChain = Math.max(longestChain, dp.get(predecessor) + 1);\n                }\n            }\n            // Update the map with the longest chain ending at the current word\n            dp.put(word, longestChain);\n            // Update the maximum chain length seen so far\n            maxChainLength = Math.max(maxChainLength, longestChain);\n        }\n        \n        return maxChainLength;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nProblem involves finding the longest chain of words such that each word is the predecessor of the next one. A word is considered to be a predecessor of another word if a single character can be inserted into it to obtain the other word. One way to solve the problem is to use dynamic programming. We can sort the words in ascending order of length and for each word, we can find all the predecessors that have already been processed and update the length of the longest chain that ends with the current word.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Sort the words in increasing order of length.\\n2. Create a HashMap to store the length of the longest chain ending with each word.\\n3. For each word, iterate over all the possible predecessors and update the length of the\\nlongest chain ending with the current word.\\n4. Return the maximum length of any chain.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the solution is O(n * L^2) where n is the number of words in the list and L is the maximum length of a word. This is because for each word, we need to iterate over all its possible predecessors and the length of the predecessors can be at most L.\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the solution is O(n) because we need to store the length of the longest chain ending with each word in a HashMap.\\n# Code\\n```\\nclass Solution {\\n    public int longestStrChain(String[] words) {\\n        // Sort the array in increasing order of word length\\n        Arrays.sort(words, (a, b) -> a.length() - b.length());\\n        \\n        // Create a map to store the longest chain ending at each word\\n        Map<String, Integer> dp = new HashMap<>();\\n        int maxChainLength = 1;\\n        \\n        // Iterate through each word in the array\\n        for (String word : words) {\\n            // Initialize the longest chain for the current word as 1\\n            int longestChain = 1;\\n            // Generate all possible predecessor words of the current word\\n            for (int i = 0; i < word.length(); i++) {\\n                StringBuilder sb = new StringBuilder(word);\\n                sb.deleteCharAt(i);\\n                String predecessor = sb.toString();\\n                // If the predecessor word is in the map, update the longest chain for the current word\\n                if (dp.containsKey(predecessor)) {\\n                    longestChain = Math.max(longestChain, dp.get(predecessor) + 1);\\n                }\\n            }\\n            // Update the map with the longest chain ending at the current word\\n            dp.put(word, longestChain);\\n            // Update the maximum chain length seen so far\\n            maxChainLength = Math.max(maxChainLength, longestChain);\\n        }\\n        \\n        return maxChainLength;\\n    }\\n}\\n\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\n    public int longestStrChain(String[] words) {\n        // Sort the array in increasing order of word length\n        Arrays.sort(words, (a, b) -> a.length() - b.length());\n        \n        // Create a map to store the longest chain ending at each word\n        Map<String, Integer> dp = new HashMap<>();\n        int maxChainLength = 1;\n        \n        // Iterate through each word in the array\n        for (String word : words) {\n            // Initialize the longest chain for the current word as 1\n            int longestChain = 0;\n            // Generate all possible predecessor words of the current word\n            for (int i = 0; i < word.length(); i++) {\n                StringBuilder sb = new StringBuilder(word);\n                sb.deleteCharAt(i);\n                String predecessor = sb.toString();\n                // If the predecessor word is in the map, update the longest chain for the current word\n                if (dp.containsKey(predecessor)) {\n                    longestChain = Math.max(longestChain, dp.get(predecessor) + 1);\n                }\n            }\n            // Update the map with the longest chain ending at the current word\n            dp.put(word, longestChain);\n            // Update the maximum chain length seen so far\n            maxChainLength = Math.max(maxChainLength, longestChain);\n        }\n        \n        return maxChainLength;\n    }\n}\n",
        "explanations": "\nThe bug is at the initialization of longestChain, its value should be 1 not 0.\n"
    },
    {
        "slug": "maximum-ice-cream-bars",
        "description": "It is a sweltering summer day, and a boy wants to buy some ice cream bars.\nAt the store, there are n ice cream bars. You are given an array costs of length n, where costs[i] is the price of the ith ice cream bar in coins. The boy initially has coins coins to spend, and he wants to buy as many ice cream bars as possible.\u00a0\nNote: The boy can buy the ice cream bars in any order.\nReturn the maximum number of ice cream bars the boy can buy with coins coins.\nYou must solve the problem by counting sort.",
        "examples": [
            "Input: costs = [1,3,2,4,1], coins = 7\nOutput: 4\nExplanation: The boy can buy ice cream bars at indices 0,1,2,4 for a total price of 1 + 3 + 2 + 1 = 7.",
            "Input: costs = [10,6,8,7,7,8], coins = 5\nOutput: 0\nExplanation: The boy cannot afford any of the ice cream bars.",
            "Input: costs = [1,6,3,1,2,5], coins = 20\nOutput: 6\nExplanation: The boy can buy all the ice cream bars for a total price of 1 + 6 + 3 + 1 + 2 + 5 = 18."
        ],
        "constraints": "costs.length == n\n1 <= n <= 105\n1 <= costs[i] <= 105\n1 <= coins <= 108",
        "release_time": 1672980160,
        "oracle_code": "class Solution {\n    public int maxIceCream(int[] costs, int coins) {\n        int [] arr = new int [100001];\n        for(int x : costs)arr[x]++;\n        int count = 0;\n        int index = 1;\n//If coins can buy all the ice-cream at ith index.\n        while(index<100001 && coins>=index*arr[index]){\n            coins-=index*arr[index];\n            count+=arr[index];\n            index++;\n        }\n//If coins can buy onyl some of the ice-creams at ith index.\n        while(index<100001 && coins>=index){\n            coins-=index;\n            count++;\n        }\n        return count;\n    }\n}",
        "content": "# Code\\n```\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        int [] arr = new int [100001];\\n        for(int x : costs)arr[x]++;\\n        int count = 0;\\n        int index = 1;\\n//If coins can buy all the ice-cream at ith index.\\n        while(index<100001 && coins>=index*arr[index]){\\n            coins-=index*arr[index];\\n            count+=arr[index];\\n            index++;\\n        }\\n//If coins can buy onyl some of the ice-creams at ith index.\\n        while(index<100001 && coins>=index){\\n            coins-=index;\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```\\n\\n# Using priority Queue\\n```\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<Integer>(Collections.reverseOrder());\\n        int sum = 0;\\n        for(int x : costs){\\n            if(sum<=coins){\\n                sum+=x;\\n                pq.add(x);\\n            }else if(pq.peek()>x){\\n                sum = sum - pq.poll() + x;\\n                pq.add(x);\\n            }\\n        }\\n        while(sum>coins){\\n            sum-=pq.poll();\\n        }\\n        return pq.size();\\n    }\\n}\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\n    public int maxIceCream(int[] costs, int coins) {\n        int [] arr = new int [100001];\n        for(int x : costs)arr[x]++;\n        int count = 0;\n        int index = 1;\n//If coins can buy all the ice-cream at ith index.\n        while(index<100001 && coins>=index*arr[index]){\n            coins-=index*arr[index];\n            count+=arr[index];\n            index++;\n        }\n\n        while(index<100001 && coins>=index){\n            coins-=index;\n            index++;\n            count++;\n        }\n        return count;\n    }\n}\n",
        "explanations": "\nThe variable 'count' should be incremented before 'index' in the second while loop.\n"
    },
    {
        "slug": "sort-even-and-odd-indices-independently",
        "description": "You are given a 0-indexed integer array nums. Rearrange the values of nums according to the following rules:\n\nSort the values at odd indices of nums in non-increasing order.\n\n\t\nFor example, if nums = [4,1,2,3] before this step, it becomes [4,3,2,1] after. The values at odd indices 1 and 3 are sorted in non-increasing order.\n\n\nSort the values at even indices of nums in non-decreasing order.\n\t\nFor example, if nums = [4,1,2,3] before this step, it becomes [2,1,4,3] after. The values at even indices 0 and 2 are sorted in non-decreasing order.\n\n\n\nReturn the array formed after rearranging the values of nums.",
        "examples": [
            "Input: nums = [4,1,2,3]\nOutput: [2,3,4,1]\nExplanation: \nFirst, we sort the values present at odd indices (1 and 3) in non-increasing order.\nSo, nums changes from [4,1,2,3] to [4,3,2,1].\nNext, we sort the values present at even indices (0 and 2) in non-decreasing order.\nSo, nums changes from [4,1,2,3] to [2,3,4,1].\nThus, the array formed after rearranging the values is [2,3,4,1].",
            "Input: nums = [2,1]\nOutput: [2,1]\nExplanation: \nSince there is exactly one odd index and one even index, no rearrangement of values takes place.\nThe resultant array formed is [2,1], which is the same as the initial array."
        ],
        "constraints": "1 <= nums.length <= 100\n1 <= nums[i] <= 100",
        "release_time": 1678770695,
        "oracle_code": "class Solution {\n    public int[] sortEvenOdd(int[] nums) {\n        PriorityQueue<Integer> queue = new PriorityQueue<>();\n        for(int i=0;i<nums.length;i+=2){\n            queue.add(nums[i]);\n        }\n        for(int i=0;i<nums.length;i+=2){\n            nums[i]=queue.poll();\n        }\n        queue = new PriorityQueue<>(new MaxHeap());\n        for(int i=1;i<nums.length;i+=2){\n            queue.add(nums[i]);\n        }\n        for(int i=1;i<nums.length;i+=2){\n            nums[i]=queue.poll();\n        }\n        return nums;\n    }\n}\nclass MaxHeap implements Comparator<Integer>{\n    public int compare(Integer ca,Integer cb){\n        return cb-ca;\n    }\n}",
        "content": "\\n> # Approach\\nLet\\'s use some data structutes to solve this problem,By adding even indexed numbers into MinHeap we can sort the data in ascending order,By adding odd indexed numbers into Maxheap we can sort the data in descending order. \\n<!-- Describe your approach to solving the problem. -->\\n\\n> # Complexity\\n- Time complexity: O(n log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) for Priority Queue\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n> # Code\\n```\\nclass Solution {\\n    public int[] sortEvenOdd(int[] nums) {\\n        PriorityQueue<Integer> queue = new PriorityQueue<>();\\n        for(int i=0;i<nums.length;i+=2){\\n            queue.add(nums[i]);\\n        }\\n        for(int i=0;i<nums.length;i+=2){\\n            nums[i]=queue.poll();\\n        }\\n        queue = new PriorityQueue<>(new MaxHeap());\\n        for(int i=1;i<nums.length;i+=2){\\n            queue.add(nums[i]);\\n        }\\n        for(int i=1;i<nums.length;i+=2){\\n            nums[i]=queue.poll();\\n        }\\n        return nums;\\n    }\\n}\\nclass MaxHeap implements Comparator<Integer>{\\n    public int compare(Integer ca,Integer cb){\\n        return cb-ca;\\n    }\\n}\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\n    public int[] sortEvenOdd(int[] nums) {\n        PriorityQueue<Integer> queue = new PriorityQueue<>();\n        for(int i=0;i<nums.length;i++){\n            queue.add(nums[i]);\n        }\n        for(int i=0;i<nums.length;i+=2){\n            nums[i]=queue.poll();\n        }\n        queue = new PriorityQueue<>(new MaxHeap());\n        for(int i=1;i<nums.length;i++){\n            queue.add(nums[i]);\n        }\n        for(int i=1;i<nums.length;i+=2){\n            nums[i]=queue.poll();\n        }\n        return nums;\n    }\n}\nclass MaxHeap implements Comparator<Integer>{\n    public int compare(Integer ca,Integer cb){\n        return cb-ca;\n    }\n}\n",
        "explanations": "\nThe bug is in the loops where elements are added to queue. Both even and odd indexed numbers are added to the same queue, which is against the requirement.\n"
    },
    {
        "slug": "longest-common-prefix",
        "description": "Write a function to find the longest common prefix string amongst an array of strings.\nIf there is no common prefix, return an empty string \"\".",
        "examples": [
            "Input: strs = [\"flower\",\"flow\",\"flight\"]\nOutput: \"fl\"",
            "Input: strs = [\"dog\",\"racecar\",\"car\"]\nOutput: \"\"\nExplanation: There is no common prefix among the input strings."
        ],
        "constraints": "1 <= strs.length <= 200\n0 <= strs[i].length <= 200\nstrs[i] consists of only lowercase English letters.",
        "release_time": 1691938780,
        "oracle_code": "class Solution {\n    public String longestCommonPrefix(String[] strs) {\n        Arrays.sort(strs);\n        String start=strs[0];\n         String end=strs[strs.length-1];\n         int count=0;\n         for(int i=0;i<start.length();i++){\n             if(start.charAt(i)==end.charAt(i)){\n            count++;\n             }\n             else{\n                 break;\n             }\n         }\n        \n         return end.substring(0,count);\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n![image.png](https://assets.leetcode.com/users/images/0be6da10-ddf1-4c9f-8387-b9e1137e1d2e_1691938734.0515819.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        Arrays.sort(strs);\\n        String start=strs[0];\\n         String end=strs[strs.length-1];\\n         int count=0;\\n         for(int i=0;i<start.length();i++){\\n             if(start.charAt(i)==end.charAt(i)){\\n            count++;\\n             }\\n             else{\\n                 break;\\n             }\\n         }\\n        \\n         return end.substring(0,count);\\n    }\\n}\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\n    public String longestCommonPrefix(String[] strs) {\n        Arrays.sort(strs);\n        String start = strs[0];\n        String end = strs[strs.length];\n        int count = 0;\n        for (int i = 0; i < start.length(); i++) {\n            if (start.charAt(i) == end.charAt(i)) {\n                count++;\n            } else {\n                break;\n            }\n        }\n        return end.substring(0, count);\n    }\n}\n",
        "explanations": "\nThe logic error is array index out of bounds exception. It should be strs[strs.length-1].\n"
    },
    {
        "slug": "minimum-operations-to-make-array-equal",
        "description": "You have an array arr of length n where arr[i] = (2 * i) + 1 for all valid values of i (i.e.,\u00a00 <= i < n).\nIn one operation, you can select two indices x and y where 0 <= x, y < n and subtract 1 from arr[x] and add 1 to arr[y] (i.e., perform arr[x] -=1 and arr[y] += 1). The goal is to make all the elements of the array equal. It is guaranteed that all the elements of the array can be made equal using some operations.\nGiven an integer n, the length of the array, return the minimum number of operations needed to make all the elements of arr equal.",
        "examples": [
            "Input: n = 3\nOutput: 2\nExplanation: arr = [1, 3, 5]\nFirst operation choose x = 2 and y = 0, this leads arr to be [2, 3, 4]\nIn the second operation choose x = 2 and y = 0 again, thus arr = [3, 3, 3].",
            "Input: n = 6\nOutput: 9"
        ],
        "constraints": "1 <= n <= 104",
        "release_time": 1691588994,
        "oracle_code": "class Solution {\n    public int minOperations(int n) {\n        int result = 0;\n        \n        if (n % 2 == 0) {\n            result = (n / 2) * (n / 2);\n        } else {\n            result = ((n - 1) / 2) * ((n + 1) / 2);\n        }\n        \n        return result;\n    }\n}",
        "content": "# Intuition\\njust observe the pattern\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\no(1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minOperations(int n) {\\n        int result = 0;\\n        \\n        if (n % 2 == 0) {\\n            result = (n / 2) * (n / 2);\\n        } else {\\n            result = ((n - 1) / 2) * ((n + 1) / 2);\\n        }\\n        \\n        return result;\\n    }\\n}\\n\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\n    public int minOperations(int n) {\n        int result = 0;\n        \n        if (n % 2 == 0) {\n            result = (n / 2) * (n / 2);\n        } else {\n            result = ((n + 1) / 2) * ((n + 1) / 2);\n        }\n        \n        return result;\n    }\n}\n",
        "explanations": "\nThe bug is in the else block, the calculation should be ((n - 1) / 2) * ((n + 1) / 2).\n"
    },
    {
        "slug": "count-the-number-of-good-subarrays",
        "description": "Given an integer array nums and an integer k, return the number of good subarrays of nums.\nA subarray arr is good if it there are at least k pairs of indices (i, j) such that i < j and arr[i] == arr[j].\nA subarray is a contiguous non-empty sequence of elements within an array.",
        "examples": [
            "Input: nums = [1,1,1,1,1], k = 10\nOutput: 1\nExplanation: The only good subarray is the array nums itself.",
            "Input: nums = [3,1,4,3,2,2,4], k = 2\nOutput: 4\nExplanation: There are 4 different good subarrays:\n- [3,1,4,3,2,2] that has 2 pairs.\n- [3,1,4,3,2,2,4] that has 3 pairs.\n- [1,4,3,2,2,4] that has 2 pairs.\n- [4,3,2,2,4] that has 2 pairs."
        ],
        "constraints": "1 <= nums.length <= 105\n1 <= nums[i], k <= 109",
        "release_time": 1673771500,
        "oracle_code": "class Solution {\n        public long countGood(int[] nums, int k) {\n        long ans = 0;\n        HashMap<Integer, Integer> map = new HashMap<>();\n        int j = 0;\n        long countPairs = 0;\n\n        for (int i = 0; i < nums.length; i++) {\n            if (map.containsKey(nums[i])) {\n\n                int val = map.get(nums[i]);\n                //to replace the  the previous pair with new pairs\n                countPairs -= ((long) val * (val - 1) / 2);\n                map.put(nums[i], map.get(nums[i]) + 1);\n                 val = map.get(nums[i]);\n                countPairs += ((long) val * (val - 1) / 2);\n\n            } else{\n                map.put(nums[i], 1);\n            }\n            \n            // System.out.println(countPairs);\n             //sliding the window to right \n            while (j <= i && countPairs >= k) {\n                int cur = map.get(nums[j]);\n                countPairs -= (long) cur * (cur - 1) / 2;\n                map.put(nums[j], cur - 1);\n                cur = map.get(nums[j]);\n                countPairs += (long) (cur ) * (cur -1) / 2;\n                j++;\n                ans += (nums.length - i);\n            }\n\n        }\n        return ans;\n\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach \\n<!-- Describe your approach to solving the problem. -->\\nSliding Window \\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n        public long countGood(int[] nums, int k) {\\n        long ans = 0;\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        int j = 0;\\n        long countPairs = 0;\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (map.containsKey(nums[i])) {\\n\\n                int val = map.get(nums[i]);\\n                //to replace the  the previous pair with new pairs\\n                countPairs -= ((long) val * (val - 1) / 2);\\n                map.put(nums[i], map.get(nums[i]) + 1);\\n                 val = map.get(nums[i]);\\n                countPairs += ((long) val * (val - 1) / 2);\\n\\n            } else{\\n                map.put(nums[i], 1);\\n            }\\n            \\n            // System.out.println(countPairs);\\n             //sliding the window to right \\n            while (j <= i && countPairs >= k) {\\n                int cur = map.get(nums[j]);\\n                countPairs -= (long) cur * (cur - 1) / 2;\\n                map.put(nums[j], cur - 1);\\n                cur = map.get(nums[j]);\\n                countPairs += (long) (cur ) * (cur -1) / 2;\\n                j++;\\n                ans += (nums.length - i);\\n            }\\n\\n        }\\n        return ans;\\n\\n    }\\n}\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\n        public long countGood(int[] nums, int k) {\n        long ans = 0;\n        HashMap<Integer, Integer> map = new HashMap<>();\n        int j = 0;\n        long countPairs = 0;\n\n        for (int i = 0; i < nums.length; i++) {\n            if (map.containsKey(nums[i])) {\n\n                int val = map.get(nums[i]);\n                //to replace the  the previous pair with new pairs\n                countPairs -= ((long) val * (val - 1) / 2);\n                map.put(nums[i], map.get(nums[i]) + 1);\n                val = map.get(nums[i]);\n                countPairs += ((long) val * (val - 1) / 2);\n\n            } else{\n                map.put(nums[i], 0);\n            }\n            \n            // System.out.println(countPairs);\n             //sliding the window to right \n            while (j <= i && countPairs >= k) {\n                int cur = map.get(nums[j]);\n                countPairs -= (long) cur * (cur - 1) / 2;\n                map.put(nums[j], cur - 1);\n                cur = map.get(nums[j]);\n                countPairs += (long) (cur ) * (cur -1) / 2;\n                j++;\n                ans += (nums.length - i);\n            }\n\n        }\n        return ans;\n\n    }\n}\n",
        "explanations": "\nThe initial value of the new inserted number into the hashmap is mistakenly set to 0.\n"
    },
    {
        "slug": "minimum-amount-of-time-to-fill-cups",
        "description": "You have a water dispenser that can dispense cold, warm, and hot water. Every second, you can either fill up 2 cups with different types of water, or 1 cup of any type of water.\nYou are given a 0-indexed integer array amount of length 3 where amount[0], amount[1], and amount[2] denote the number of cold, warm, and hot water cups you need to fill respectively. Return the minimum number of seconds needed to fill up all the cups.",
        "examples": [
            "Input: amount = [1,4,2]\nOutput: 4\nExplanation: One way to fill up the cups is:\nSecond 1: Fill up a cold cup and a warm cup.\nSecond 2: Fill up a warm cup and a hot cup.\nSecond 3: Fill up a warm cup and a hot cup.\nSecond 4: Fill up a warm cup.\nIt can be proven that 4 is the minimum number of seconds needed.",
            "Input: amount = [5,4,4]\nOutput: 7\nExplanation: One way to fill up the cups is:\nSecond 1: Fill up a cold cup, and a hot cup.\nSecond 2: Fill up a cold cup, and a warm cup.\nSecond 3: Fill up a cold cup, and a warm cup.\nSecond 4: Fill up a warm cup, and a hot cup.\nSecond 5: Fill up a cold cup, and a hot cup.\nSecond 6: Fill up a cold cup, and a warm cup.\nSecond 7: Fill up a hot cup.",
            "Input: amount = [5,0,0]\nOutput: 5\nExplanation: Every second, we fill up a cold cup."
        ],
        "constraints": "amount.length == 3\n0 <= amount[i] <= 100",
        "release_time": 1674567895,
        "oracle_code": "class Solution {\n    public int fillCups(int[] amount) {\n        Arrays.sort(amount);\n        int ans = 0;\n        int lo=0, hi=2;\n        if(amount[0] == 0) lo++;\n        if(lo==1 && amount[1]==0) return amount[2];\n\n        else if(lo==1){\n            ans += amount[hi];\n            return ans;\n        }\n        while(amount[lo] != 0){\n            ans++;\n            amount[lo]--;\n            amount[hi]--;\n            if(amount[hi-1] > amount[hi]){\n                int temp = amount[hi-1];\n                amount[hi-1] = amount[hi];\n                amount[hi] = temp;\n            }\n        }\n\n        ans += amount[2];\n        return ans;\n    }\n}",
        "content": "# Intuition\\nJust keep filling the least and most required cups together\\n\\n# Approach\\nSort the array. Keep removing the smallest value and the largest value by 1, until the smallest one is zero, then increase the answer by the left out max value\\n\\n# Complexity\\n- Time complexity:\\nO(smallest value)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int fillCups(int[] amount) {\\n        Arrays.sort(amount);\\n        int ans = 0;\\n        int lo=0, hi=2;\\n        if(amount[0] == 0) lo++;\\n        if(lo==1 && amount[1]==0) return amount[2];\\n\\n        else if(lo==1){\\n            ans += amount[hi];\\n            return ans;\\n        }\\n        while(amount[lo] != 0){\\n            ans++;\\n            amount[lo]--;\\n            amount[hi]--;\\n            if(amount[hi-1] > amount[hi]){\\n                int temp = amount[hi-1];\\n                amount[hi-1] = amount[hi];\\n                amount[hi] = temp;\\n            }\\n        }\\n\\n        ans += amount[2];\\n        return ans;\\n    }\\n}\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\n    public int fillCups(int[] amount) {\n        Arrays.sort(amount);\n        int ans = 0;\n        int lo=0, hi=2;\n        if(amount[0] == 0) lo++;\n        if(lo==1 && amount[1]==0) return amount[2];\n\n        else if(lo==1){\n            ans += amount[hi];\n            return ans;\n        }\n        while(amount[lo] != 0){\n            ans++;\n            amount[lo]--;\n            amount[hi]--;\n            if(amount[hi-1] > amount[hi]){\n                int temp = amount[hi-1];\n                amount[hi-1] = amount[hi];\n                amount[hi] = temp;\n            }\n        }\n\n        ans += amount[3];\n        return ans;\n    }\n}\n",
        "explanations": "\nReferencing amount[3] causes 'Array Index Out of Bound' error because it does not exist.\n"
    },
    {
        "slug": "knight-probability-in-chessboard",
        "description": "On an n x n chessboard, a knight starts at the cell (row, column) and attempts to make exactly k moves. The rows and columns are 0-indexed, so the top-left cell is (0, 0), and the bottom-right cell is (n - 1, n - 1).\nA chess knight has eight possible moves it can make, as illustrated below. Each move is two cells in a cardinal direction, then one cell in an orthogonal direction.\n\nEach time the knight is to move, it chooses one of eight possible moves uniformly at random (even if the piece would go off the chessboard) and moves there.\nThe knight continues moving until it has made exactly k moves or has moved off the chessboard.\nReturn the probability that the knight remains on the board after it has stopped moving.",
        "examples": [
            "Input: n = 3, k = 2, row = 0, column = 0\nOutput: 0.06250\nExplanation: There are two moves (to (1,2), (2,1)) that will keep the knight on the board.\nFrom each of those positions, there are also two moves that will keep the knight on the board.\nThe total probability the knight stays on the board is 0.0625.",
            "Input: n = 1, k = 0, row = 0, column = 0\nOutput: 1.00000"
        ],
        "constraints": "1 <= n <= 25\n0 <= k <= 100\n0 <= row, column <= n - 1",
        "release_time": 1690027908,
        "oracle_code": "class Solution {\n    public double knightProbability(int n, int k, int row, int column) {\n        int[][] dir = {{-2, -1}, {-1, -2}, {1, -2}, {2, -1}, {2, 1}, {1, 2}, {-1, 2}, {-2, 1}};\n        // We use dynamic programming to store the probabilities at each cell for each move...\n        // The dp array is a 3-dimensional array...\n        // dp[i][r][c] represents the probability of the knight being at cell (r, c) after i moves...\n        double[][][] dp = new double[k + 1][n][n];\n        // At first, initialize dp[0][row][column] to 1.0, as the knight starts at the specified cell.\n        dp[0][row][column] = 1.0;\n        // For each move from 1 to k, the algorithm iterates over each cell on the chessboard.\n        for (int i = 1; i <= k; i++) {\n            // For each cell, it considers all 8 possible moves of the knight &\n            // Calculates the probability of reaching that cell from the neighboring cells.\n            for (int r = 0; r < n; r++) {\n                for (int c = 0; c < n; c++) {\n                    for (int[] d : dir) {\n                        // Introduce the terms newRow & newCol...\n                        int newRow = r + d[0];\n                        int newCol = c + d[1];\n                        // If the new cell is within the bounds of the chessboard....\n                        if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < n) {\n                            // update by adding the probability of the previous move divided by 8.0...\n                            dp[i][r][c] += dp[i - 1][newRow][newCol] / 8.0;\n                        }\n                    }\n                }\n            }\n        }\n        // Initialize the output probability...\n        double output = 0.0;\n        // Sum up the output probabilities of all cells at the kth move to get the final output probability.\n        for (int r = 0; r < n; r++) {\n            for (int c = 0; c < n; c++) {\n                output += dp[k][r][c];\n            }\n        }\n        // return the output that the knight remains on the board after k moves.\n        return output;\n    }\n}",
        "content": "# **Java Solution:**\\n```\\nclass Solution {\\n    public double knightProbability(int n, int k, int row, int column) {\\n        int[][] dir = {{-2, -1}, {-1, -2}, {1, -2}, {2, -1}, {2, 1}, {1, 2}, {-1, 2}, {-2, 1}};\\n        // We use dynamic programming to store the probabilities at each cell for each move...\\n        // The dp array is a 3-dimensional array...\\n        // dp[i][r][c] represents the probability of the knight being at cell (r, c) after i moves...\\n        double[][][] dp = new double[k + 1][n][n];\\n        // At first, initialize dp[0][row][column] to 1.0, as the knight starts at the specified cell.\\n        dp[0][row][column] = 1.0;\\n        // For each move from 1 to k, the algorithm iterates over each cell on the chessboard.\\n        for (int i = 1; i <= k; i++) {\\n            // For each cell, it considers all 8 possible moves of the knight &\\n            // Calculates the probability of reaching that cell from the neighboring cells.\\n            for (int r = 0; r < n; r++) {\\n                for (int c = 0; c < n; c++) {\\n                    for (int[] d : dir) {\\n                        // Introduce the terms newRow & newCol...\\n                        int newRow = r + d[0];\\n                        int newCol = c + d[1];\\n                        // If the new cell is within the bounds of the chessboard....\\n                        if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < n) {\\n                            // update by adding the probability of the previous move divided by 8.0...\\n                            dp[i][r][c] += dp[i - 1][newRow][newCol] / 8.0;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        // Initialize the output probability...\\n        double output = 0.0;\\n        // Sum up the output probabilities of all cells at the kth move to get the final output probability.\\n        for (int r = 0; r < n; r++) {\\n            for (int c = 0; c < n; c++) {\\n                output += dp[k][r][c];\\n            }\\n        }\\n        // return the output that the knight remains on the board after k moves.\\n        return output;\\n    }\\n}\\n```\\n\\n# **C++ Solution:**\\n```\\nclass Solution {\\npublic:\\n    double knightProbability(int n, int k, int row, int column) {\\n        // We use dynamic programming to store the probabilities at each cell for each move...\\n        // The dp array is a 3-dimensional array...\\n        // dp represents the probability of the knight being at cell (r, c) after m moves...\\n        vector<vector<double>> dp(n, vector<double>(n, 0));\\n        vector<int> dr = {-2, -2, -1, -1, 1, 1, 2, 2};\\n        vector<int> dc = {-1, 1, -2, 2, -2, 2, -1, 1};\\n        // At first, initialize dp[0][row][column] to 1, as the knight starts at the specified cell.\\n        dp[row][column] = 1;\\n        // For each move from 1 to k, the algorithm iterates over each cell on the chessboard.\\n        for (int m = 0; m < k; m++) {\\n            vector<vector<double>> tmp(n, vector<double>(n, 0));\\n            // For each cell, it considers all 8 possible moves of the knight &\\n            // Calculates the probability of reaching that cell from the neighboring cells.\\n            for (int r = 0; r < n; r++) {\\n                for (int c = 0; c < n; c++) {\\n                    for (int i = 0; i < 8; i++) {\\n                        // Introduce the terms newRow & newCol...\\n                        int newRow = r + dr[i];\\n                        int newCol = c + dc[i];\\n                        // If the new cell is within the bounds of the chessboard....\\n                        if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < n) {\\n                            // update by adding the probability of the previous move divided by 8.0...\\n                            tmp[newRow][newCol] += dp[r][c] / 8.0;\\n                        }\\n                    }\\n                }\\n            }\\n            dp = tmp;\\n        }\\n        // Initialize the output probability...\\n        double output = 0;\\n        // Sum up the output probabilities of all cells at the kth move to get the final output probability.\\n        for (int r = 0; r < n; r++) {\\n            for (int c = 0; c < n; c++) {\\n                output += dp[r][c];\\n            }\\n        }\\n        // return the output that the knight remains on the board after k moves.\\n        return output;\\n    }\\n};\\n```\\n**I am working hard for you guys...\\nPlease upvote if you found any help with this code...**",
        "level": "medium",
        "buggy_code": "\nclass Solution {\n    public double knightProbability(int n, int k, int row, int column) {\n        int[][] dir = {{-2, -1}, {-1, -2}, {1, -2}, {2, -1}, {2, 1}, {1, 2}, {-1, 2}, {-2, 1}};\n        double[][][] dp = new double[k + 1][n][n];\n        dp[0][row][column] = 1.0;\n        for (int i = 1; i <= k; i++) {\n            for (int r = 0; r < n; r++) {\n                for (int c = 0; c < n; c++) {\n                    for (int[] d : dir) {\n                        int newRow = r + d[0];\n                        int newCol = c + d[1];\n                        if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < n) {\n                            dp[i][r][c] += dp[i][newRow][newCol] / 8.0;\n                        }\n                    }\n                }\n            }\n        }\n        double output = 0.0;\n        for (int r = 0; r < n; r++) {\n            for (int c = 0; c < n; c++) {\n                output += dp[k][r][c];\n            }\n        }\n        return output;\n    }\n}\n",
        "explanations": "\nThe bug is in the line \"dp[i][r][c] += dp[i][newRow][newCol] / 8.0;\" where it should be \"dp[i][r][c] += dp[i - 1][newRow][newCol] / 8.0;\".\n"
    },
    {
        "slug": "airplane-seat-assignment-probability",
        "description": "n passengers board an airplane with exactly n seats. The first passenger has lost the ticket and picks a seat randomly. But after that, the rest of the passengers will:\n\nTake their own seat if it is still available, and\nPick other seats randomly when they find their seat occupied\n\nReturn the probability that the nth person gets his own seat.",
        "examples": [
            "Input: n = 1\nOutput: 1.00000\nExplanation: The first person can only get the first seat.",
            "Input: n = 2\nOutput: 0.50000\nExplanation: The second person has a probability of 0.5 to get the second seat (when first person gets the first seat)."
        ],
        "constraints": "1 <= n <= 105",
        "release_time": 1672300543,
        "oracle_code": "class Solution {\n    public double nthPersonGetsNthSeat(int n) {\n        if(n==1)\n        return 1.00000;\n        return 0.50000;\n    }\n}",
        "content": "\\n```\\nclass Solution {\\n    public double nthPersonGetsNthSeat(int n) {\\n        if(n==1)\\n        return 1.00000;\\n        return 0.50000;\\n    }\\n}\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\n    public double nthPersonGetsNthSeat(int n) {\n        if(n==1)\n        return 1.00000;\n        else\n        return 1.50000;\n    }\n}\n",
        "explanations": "\nReturning 1.50000 doesn't make sense for a probability, it should return within 0 and 1.\n"
    },
    {
        "slug": "intersection-of-two-linked-lists",
        "description": "Given the heads of two singly linked-lists headA and headB, return the node at which the two lists intersect. If the two linked lists have no intersection at all, return null.\nFor example, the following two linked lists begin to intersect at node c1:\n\nThe test cases are generated such that there are no cycles anywhere in the entire linked structure.\nNote that the linked lists must retain their original structure after the function returns.\nCustom Judge:\nThe inputs to the judge are given as follows (your program is not given these inputs):\n\nintersectVal - The value of the node where the intersection occurs. This is 0 if there is no intersected node.\nlistA - The first linked list.\nlistB - The second linked list.\nskipA - The number of nodes to skip ahead in listA (starting from the head) to get to the intersected node.\nskipB - The number of nodes to skip ahead in listB (starting from the head) to get to the intersected node.\n\nThe judge will then create the linked structure based on these inputs and pass the two heads, headA and headB to your program. If you correctly return the intersected node, then your solution will be accepted.",
        "examples": [
            "Input: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3\nOutput: Intersected at '8'\nExplanation: The intersected node's value is 8 (note that this must not be 0 if the two lists intersect).\nFrom the head of A, it reads as [4,1,8,4,5]. From the head of B, it reads as [5,6,1,8,4,5]. There are 2 nodes before the intersected node in A; There are 3 nodes before the intersected node in B.\n- Note that the intersected node's value is not 1 because the nodes with value 1 in A and B (2nd node in A and 3rd node in B) are different node references. In other words, they point to two different locations in memory, while the nodes with value 8 in A and B (3rd node in A and 4th node in B) point to the same location in memory.",
            "Input: intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1\nOutput: Intersected at '2'\nExplanation: The intersected node's value is 2 (note that this must not be 0 if the two lists intersect).\nFrom the head of A, it reads as [1,9,1,2,4]. From the head of B, it reads as [3,2,4]. There are 3 nodes before the intersected node in A; There are 1 node before the intersected node in B.",
            "Input: intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2\nOutput: No intersection\nExplanation: From the head of A, it reads as [2,6,4]. From the head of B, it reads as [1,5]. Since the two lists do not intersect, intersectVal must be 0, while skipA and skipB can be arbitrary values.\nExplanation: The two lists do not intersect, so return null."
        ],
        "constraints": "The number of nodes of listA is in the m.\nThe number of nodes of listB is in the n.\n1 <= m, n <= 3 * 104\n1 <= Node.val <= 105\n0 <= skipA <\u00a0m\n0 <= skipB <\u00a0n\nintersectVal is 0 if listA and listB do not intersect.\nintersectVal == listA[skipA] == listB[skipB] if listA and listB intersect.",
        "release_time": 1691478947,
        "oracle_code": "class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        int ac = 0;\n        int bc = 0;\n        ListNode a = headA;\n        ListNode b = headB;\n        while(a != null){\n            ac++;\n            a = a.next;\n        }\n        while(b != null){\n            bc++;\n            b = b.next;\n        }\n        while(ac > bc){\n            ac--;\n            headA = headA.next;\n        }\n        while(bc > ac){\n            bc--;\n            headB = headB.next;\n        }\n        \n        while(headA != headB){\n            headA = headA.next;\n            headB = headB.next;\n        }\n        return headA;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        int ac = 0;\\n        int bc = 0;\\n        ListNode a = headA;\\n        ListNode b = headB;\\n        while(a != null){\\n            ac++;\\n            a = a.next;\\n        }\\n        while(b != null){\\n            bc++;\\n            b = b.next;\\n        }\\n        while(ac > bc){\\n            ac--;\\n            headA = headA.next;\\n        }\\n        while(bc > ac){\\n            bc--;\\n            headB = headB.next;\\n        }\\n        \\n        while(headA != headB){\\n            headA = headA.next;\\n            headB = headB.next;\\n        }\\n        return headA;\\n    }\\n}\\n",
        "level": "easy",
        "buggy_code": "\nclass Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        int ac = 0;\n        int bc = 0;\n        ListNode a = headA;\n        ListNode b = headB;\n        while(a != null){\n            ac++;\n            a = a.next;\n        }\n        while(b != null){\n            bc++;\n            b = b.next;\n        }\n        while(ac > bc){\n            ac--;\n            headA = headA.next;\n        }\n        while(bc > ac){\n            bc--;\n            headB = headB.next;\n        }\n        \n        while(headA != headB){\n            headA = headA.next;\n            headB = headB.next;\n        }\n        \n        return b;  \n    }\n}\n",
        "explanations": "\n Returning `b` instead of `headA` or `headB` can produce null or incorrect output.\n"
    },
    {
        "slug": "maximum-average-pass-ratio",
        "description": "There is a school that has classes of students and each class will be having a final exam. You are given a 2D integer array classes, where classes[i] = [passi, totali]. You know beforehand that in the ith class, there are totali total students, but only passi number of students will pass the exam.\nYou are also given an integer extraStudents. There are another extraStudents brilliant students that are guaranteed to pass the exam of any class they are assigned to. You want to assign each of the extraStudents students to a class in a way that maximizes the average pass ratio across all the classes.\nThe pass ratio of a class is equal to the number of students of the class that will pass the exam divided by the total number of students of the class. The average pass ratio is the sum of pass ratios of all the classes divided by the number of the classes.\nReturn the maximum possible average pass ratio after assigning the extraStudents students. Answers within 10-5 of the actual answer will be accepted.",
        "examples": [
            "Input: classes = [[1,2],[3,5],[2,2]], extraStudents = 2\nOutput: 0.78333\nExplanation: You can assign the two extra students to the first class. The average pass ratio will be equal to (3/4 + 3/5 + 2/2) / 3 = 0.78333.",
            "Input: classes = [[2,4],[3,9],[4,5],[2,10]], extraStudents = 4\nOutput: 0.53485"
        ],
        "constraints": "1 <= classes.length <= 105\nclasses[i].length == 2\n1 <= passi <= totali <= 105\n1 <= extraStudents <= 105",
        "release_time": 1675841173,
        "oracle_code": "class Solution {\n    public double maxAverageRatio(int[][] classes, int extraStudents) {\n        PriorityQueue<Class> pq = new PriorityQueue<>(new Compare());\n        for(int[] cl : classes){\n            pq.add(new Class(cl));\n        }\n        while(extraStudents > 0){\n            Class c = pq.remove();\n            c.addExtraStudent();\n            extraStudents--;\n            pq.add(c);\n        }\n        double sum = 0;\n        while(!pq.isEmpty()){\n            Class c = pq.remove();\n            sum += c.pass / c.total;\n        }\n        return sum / classes.length;\n    }\n}\nclass Class{\n    double pass;\n    double total;\n    double inc;\n    public Class(int[] cl){\n        pass = cl[0];\n        total = cl[1];\n        inc = (pass + 1) / (total + 1) - pass / total;\n    }\n    public void addExtraStudent(){\n        pass += 1;\n        total += 1;\n        inc = (pass + 1) / (total + 1) - pass / total;\n    }\n}\nclass Compare implements Comparator<Class>{\n    public int compare(Class c1, Class c2){\n        if(c1.inc < c2.inc){\n            return 1;\n        }else if(c1.inc > c2.inc){\n            return -1;\n        }else{\n            return 0;\n        }\n    }\n}",
        "content": "\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public double maxAverageRatio(int[][] classes, int extraStudents) {\\n        PriorityQueue<Class> pq = new PriorityQueue<>(new Compare());\\n        for(int[] cl : classes){\\n            pq.add(new Class(cl));\\n        }\\n        while(extraStudents > 0){\\n            Class c = pq.remove();\\n            c.addExtraStudent();\\n            extraStudents--;\\n            pq.add(c);\\n        }\\n        double sum = 0;\\n        while(!pq.isEmpty()){\\n            Class c = pq.remove();\\n            sum += c.pass / c.total;\\n        }\\n        return sum / classes.length;\\n    }\\n}\\nclass Class{\\n    double pass;\\n    double total;\\n    double inc;\\n    public Class(int[] cl){\\n        pass = cl[0];\\n        total = cl[1];\\n        inc = (pass + 1) / (total + 1) - pass / total;\\n    }\\n    public void addExtraStudent(){\\n        pass += 1;\\n        total += 1;\\n        inc = (pass + 1) / (total + 1) - pass / total;\\n    }\\n}\\nclass Compare implements Comparator<Class>{\\n    public int compare(Class c1, Class c2){\\n        if(c1.inc < c2.inc){\\n            return 1;\\n        }else if(c1.inc > c2.inc){\\n            return -1;\\n        }else{\\n            return 0;\\n        }\\n    }\\n}\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\n    public double maxAverageRatio(int[][] classes, int extraStudents) {\n        PriorityQueue<Class> pq = new PriorityQueue<>(new Compare());\n        for(int[] cl : classes){\n            pq.add(new Class(cl));\n        }\n        while(extraStudents > 0){\n            Class c = pq.remove();\n            c.addExtraStudent();\n            extraStudents--;\n        }\n        double sum = 0;\n        while(!pq.isEmpty()){\n            Class c = pq.remove();\n            sum += c.pass / c.total;\n        }\n        return sum / classes.length;\n    }\n}\nclass Class{\n    double pass;\n    double total;\n    double inc;\n    public Class(int[] cl){\n        pass = cl[0];\n        total = cl[1];\n        inc = (pass + 1) / (total + 1) - pass / total;\n    }\n    public void addExtraStudent(){\n        pass += 1;\n        total += 1;\n        inc = (pass + 1) / (total + 1) - pass / total;\n    }\n}\nclass Compare implements Comparator<Class>{\n    public int compare(Class c1, Class c2){\n        if(c1.inc < c2.inc){\n            return 1;\n        }else if(c1.inc > c2.inc){\n            return -1;\n        }else{\n            return 0;\n        }\n    }\n}\n",
        "explanations": "\nRemoved the logic of adding back the modified class to queue. Results in incorrect averages.\n"
    }
]