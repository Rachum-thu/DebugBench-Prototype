[
    {
        "slug": "set-matrix-zeroes",
        "description": "Given an m x n integer matrix matrix, if an element is 0, set its entire row and column to 0's.\nYou must do it in place.",
        "examples": [
            "Input: matrix = [[1,1,1],[1,0,1],[1,1,1]]\nOutput: [[1,0,1],[0,0,0],[1,0,1]]",
            "Input: matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]\nOutput: [[0,0,0,0],[0,4,5,0],[0,3,1,0]]"
        ],
        "constraints": "m == matrix.length\nn == matrix[0].length\n1 <= m, n <= 200\n-231 <= matrix[i][j] <= 231 - 1",
        "release_time": 1691675103,
        "oracle_code": "class Solution {\n    public void setZeroes(int[][] A) \n    {\n       \n       int row=A.length;\n        int col=A[0].length;\n        int x=1,y=1;\n        for(int i=0;i<col;i++){\n            if(A[0][i]==0){\n                x=0;\n               break;}\n        } \n        for(int i=0;i<row;i++){\n            if(A[i][0]==0){\n                y=0;\n               break;}\n        } \n        //label the top row and column with 0 if there are any 0s\n        for(int i=1;i<row;i++)\n            for(int j=1;j<col;j++)\n            {\n                if(A[i][j]==0)\n                {\n                    A[i][0]=0;\n                    A[0][j]=0;\n                }\n            }\n        \n       for(int j=1;j<col;j++)\n        {\n           if(A[0][j]==0)\n           {\n               for(int i=1;i<row;i++)\n                   A[i][j]=0;\n           }\n        }\n        \n        for(int i=1;i<row;i++)\n        {\n            if(A[i][0]==0)\n            {\n                for(int j=0;j<col;j++)\n                    A[i][j]=0;\n            }\n        }\n        if(x==0)\n        for(int i=0;i<col;i++)\n            A[0][i]=0;\n               \n        if(y==0)\n        for(int i=0;i<row;i++)\n            A[i][0]=0;\n\n        System.gc();\n        //return A;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public void setZeroes(int[][] A) \\n    {\\n       \\n       int row=A.length;\\n        int col=A[0].length;\\n        int x=1,y=1;\\n        for(int i=0;i<col;i++){\\n            if(A[0][i]==0){\\n                x=0;\\n               break;}\\n        } \\n        for(int i=0;i<row;i++){\\n            if(A[i][0]==0){\\n                y=0;\\n               break;}\\n        } \\n        //label the top row and column with 0 if there are any 0s\\n        for(int i=1;i<row;i++)\\n            for(int j=1;j<col;j++)\\n            {\\n                if(A[i][j]==0)\\n                {\\n                    A[i][0]=0;\\n                    A[0][j]=0;\\n                }\\n            }\\n        \\n       for(int j=1;j<col;j++)\\n        {\\n           if(A[0][j]==0)\\n           {\\n               for(int i=1;i<row;i++)\\n                   A[i][j]=0;\\n           }\\n        }\\n        \\n        for(int i=1;i<row;i++)\\n        {\\n            if(A[i][0]==0)\\n            {\\n                for(int j=0;j<col;j++)\\n                    A[i][j]=0;\\n            }\\n        }\\n        if(x==0)\\n        for(int i=0;i<col;i++)\\n            A[0][i]=0;\\n               \\n        if(y==0)\\n        for(int i=0;i<row;i++)\\n            A[i][0]=0;\\n\\n        System.gc();\\n        //return A;\\n    }\\n}\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\n    public void setZeroes(int[][] A) \n    {\n       \n       int row=A.length;\n        int col=A[0].length;\n        int x=1,y=1;\n        for(int i=0;i<col;i++){\n            if(A[0][i]==0){\n                x=0;\n               break;}\n        } \n        for(int i=0;i<row;i++){\n            if(A[i][0]==0){\n                y=1;\n               break;}\n        } \n        //label the top row and column with 0 if there are any 0s\n        for(int i=1;i<row;i++)\n            for(int j=1;j<col;j++)\n            {\n                if(A[i][j]==0)\n                {\n                    A[i][0]=0;\n                    A[0][j]=0;\n                }\n            }\n        \n       for(int j=1;j<col;j++)\n        {\n           if(A[0][j]==0)\n           {\n               for(int i=1;i<row;i++)\n                   A[i][j]=0;\n           }\n        }\n        \n        for(int i=1;i<row;i++)\n        {\n            if(A[i][0]==0)\n            {\n                for(int j=0;j<col;j++)\n                    A[i][j]=0;\n            }\n        }\n        if(x==0)\n        for(int i=0;i<col;i++)\n            A[0][i]=0;\n               \n        if(y==0)\n        for(int i=0;i<row;i++)\n            A[i][0]=0;\n\n        System.gc();\n        //return A;\n    }\n}\n",
        "explanations": "\nChanged y=0 to y=1 in the second loop, which would prevent marking column as zero.\n"
    },
    {
        "slug": "maximum-number-of-points-from-grid-queries",
        "description": "You are given an m x n integer matrix grid and an array queries of size k.\nFind an array answer of size k such that for each integer queries[i] you start in the top left cell of the matrix and repeat the following process:\n\nIf queries[i] is strictly greater than the value of the current cell that you are in, then you get one point if it is your first time visiting this cell, and you can move to any adjacent cell in all 4 directions: up, down, left, and right.\nOtherwise, you do not get any points, and you end this process.\n\nAfter the process, answer[i] is the maximum number of points you can get. Note that for each query you are allowed to visit the same cell multiple times.\nReturn the resulting array answer.",
        "examples": [
            "Input: grid = [[1,2,3],[2,5,7],[3,5,1]], queries = [5,6,2]\nOutput: [5,8,1]\nExplanation: The diagrams above show which cells we visit to get points for each query.",
            "Input: grid = [[5,2,1],[1,1,2]], queries = [3]\nOutput: [0]\nExplanation: We can not get any points because the value of the top left cell is already greater than or equal to 3."
        ],
        "constraints": "m == grid.length\nn == grid[i].length\n2 <= m, n <= 1000\n4 <= m * n <= 105\nk == queries.length\n1 <= k <= 104\n1 <= grid[i][j], queries[i] <= 106",
        "release_time": 1670731767,
        "oracle_code": "class Solution {\n    public int[] maxPoints(int[][] a, int[] q) {\n        \n        int n = a.length;\n        int m = a[0].length;\n        \n        int l = q.length;\n        int[][] p = new int[l][2];\n        \n        for(int i = 0 ; i < l ; i++) {\n            \n            p[i][0] = i;\n            p[i][1] = q[i];\n        }\n        \n        Arrays.sort(p, (o1,o2)-> {\n            \n            if(o1[1] == o2[1]) {\n                \n                Integer.compare(o1[0],o2[0]);\n            }\n            \n            return Integer.compare(o1[1],o2[1]);\n        });\n        \n        PriorityQueue<int[]> qu = new PriorityQueue<>((o1,o2)->{\n            \n            return Integer.compare(a[o1[0]][o1[1]],a[o2[0]][o2[1]]);\n        });\n        \n        qu.add(new int[]{0,0});\n        \n        boolean[][] v = new boolean[n][m];\n        int cnt = 0;\n        int idx = 0;\n        \n        while(qu.size() > 0 && idx < l) {\n            \n            int[] f = qu.remove();\n            int r = f[0] , c = f[1];\n            \n            if(v[r][c]) continue;\n            \n            v[r][c] = true;\n            \n            if(a[r][c] < p[idx][1]) {\n                \n                cnt++;\n            }\n            else{\n                \n                q[p[idx][0]] = cnt;\n                idx++;\n                qu.add(f);\n                v[r][c] = false;\n                continue;\n            }\n            \n            if(c+1 < m && v[r][c+1] == false) qu.add(new int[]{r,c+1});\n            if(r+1 < n && v[r+1][c] == false) qu.add(new int[]{r+1,c});\n            if(r-1 >=0 && v[r-1][c] == false) qu.add(new int[]{r-1,c});\n            if(c-1 >= 0 && v[r][c-1] == false) qu.add(new int[]{r,c-1});\n        }\n        \n        while(idx < l) {\n            \n            q[p[idx][0]] = cnt;\n            idx++;\n        }\n        \n        return q;\n    }\n}",
        "content": "# Intuition\\nUse the concept of offline query.\\n\\n# Approach\\nFirst sort the query and then use priorityqueue to get min value cell.\\nif value is less than query update count \\nelse cnt is ans for ith query.\\n\\n\\n# Complexity\\n- Time complexity: O(n*m*log(n*m))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n*m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] maxPoints(int[][] a, int[] q) {\\n        \\n        int n = a.length;\\n        int m = a[0].length;\\n        \\n        int l = q.length;\\n        int[][] p = new int[l][2];\\n        \\n        for(int i = 0 ; i < l ; i++) {\\n            \\n            p[i][0] = i;\\n            p[i][1] = q[i];\\n        }\\n        \\n        Arrays.sort(p, (o1,o2)-> {\\n            \\n            if(o1[1] == o2[1]) {\\n                \\n                Integer.compare(o1[0],o2[0]);\\n            }\\n            \\n            return Integer.compare(o1[1],o2[1]);\\n        });\\n        \\n        PriorityQueue<int[]> qu = new PriorityQueue<>((o1,o2)->{\\n            \\n            return Integer.compare(a[o1[0]][o1[1]],a[o2[0]][o2[1]]);\\n        });\\n        \\n        qu.add(new int[]{0,0});\\n        \\n        boolean[][] v = new boolean[n][m];\\n        int cnt = 0;\\n        int idx = 0;\\n        \\n        while(qu.size() > 0 && idx < l) {\\n            \\n            int[] f = qu.remove();\\n            int r = f[0] , c = f[1];\\n            \\n            if(v[r][c]) continue;\\n            \\n            v[r][c] = true;\\n            \\n            if(a[r][c] < p[idx][1]) {\\n                \\n                cnt++;\\n            }\\n            else{\\n                \\n                q[p[idx][0]] = cnt;\\n                idx++;\\n                qu.add(f);\\n                v[r][c] = false;\\n                continue;\\n            }\\n            \\n            if(c+1 < m && v[r][c+1] == false) qu.add(new int[]{r,c+1});\\n            if(r+1 < n && v[r+1][c] == false) qu.add(new int[]{r+1,c});\\n            if(r-1 >=0 && v[r-1][c] == false) qu.add(new int[]{r-1,c});\\n            if(c-1 >= 0 && v[r][c-1] == false) qu.add(new int[]{r,c-1});\\n        }\\n        \\n        while(idx < l) {\\n            \\n            q[p[idx][0]] = cnt;\\n            idx++;\\n        }\\n        \\n        return q;\\n    }\\n}\\n```",
        "level": "hard",
        "buggy_code": "\nclass Solution {\n    public int[] maxPoints(int[][] a, int[] q) {\n        \n        int n = a.length;\n        int m = a[0].length;\n        \n        int l = q.length;\n        int[][] p = new int[l][2];\n        \n        for(int i = 0 ; i < l ; i++) {\n            \n            p[i][0] = i;\n            p[i][1] = q[i];\n        }\n        \n        Arrays.sort(p, (o1,o2)-> {\n            \n            if(o1[1] == o2[1]) {\n                \n                return Integer.compare(o1[0],o2[0]);\n            }\n            \n            return Integer.compare(o1[1],o2[1]);\n        });\n        \n        PriorityQueue<int[]> qu = new PriorityQueue<>((o1,o2)->{\n            \n            return Integer.compare(a[o1[0]][o1[1]],a[o2[0]][o2[1]]);\n        });\n        \n        qu.add(new int[]{0,1}); \n        \n        boolean[][] v = new boolean[n][m];\n        int cnt = 0;\n        int idx = 0;\n        \n        while(qu.size() > 0 && idx < l) {\n            \n            int[] f = qu.remove();\n            int r = f[0] , c = f[1];\n            \n            if(v[r][c]) continue;\n            \n            v[r][c] = true;\n            \n            if(a[r][c] < p[idx][1]) {\n                \n                cnt++;\n            }\n            else{\n                \n                q[p[idx][0]] = cnt;\n                idx++;\n                qu.add(f);\n                v[r][c] = false;\n                continue;\n            }\n            \n            if(c+1 < m && v[r][c+1] == false) qu.add(new int[]{r,c+1});\n            if(r+1 < n && v[r+1][c] == false) qu.add(new int[]{r+1,c});\n            if(r-1 >=0 && v[r-1][c] == false) qu.add(new int[]{r-1,c});\n            if(c-1 >= 0 && v[r][c-1] == false) qu.add(new int[]{r,c-1});\n        }\n        \n        while(idx < l) {\n            \n            q[p[idx][0]] = cnt;\n            idx++;\n        }\n        \n        return q;\n    }\n}\n",
        "explanations": "\nStart of a PriorityQueue should be from (0,0), but the bug sets it to (0,1) improperly.\n"
    },
    {
        "slug": "minimum-time-to-visit-a-cell-in-a-grid",
        "description": "You are given a m x n matrix grid consisting of non-negative integers where grid[row][col] represents the minimum time required to be able to visit the cell (row, col), which means you can visit the cell (row, col) only when the time you visit it is greater than or equal to grid[row][col].\nYou are standing in the top-left cell of the matrix in the 0th second, and you must move to any adjacent cell in the four directions: up, down, left, and right. Each move you make takes 1 second.\nReturn the minimum time required in which you can visit the bottom-right cell of the matrix. If you cannot visit the bottom-right cell, then return -1.",
        "examples": [
            "Input: grid = [[0,1,3,2],[5,1,2,5],[4,3,8,6]]\nOutput: 7\nExplanation: One of the paths that we can take is the following:\n- at t = 0, we are on the cell (0,0).\n- at t = 1, we move to the cell (0,1). It is possible because grid[0][1] <= 1.\n- at t = 2, we move to the cell (1,1). It is possible because grid[1][1] <= 2.\n- at t = 3, we move to the cell (1,2). It is possible because grid[1][2] <= 3.\n- at t = 4, we move to the cell (1,1). It is possible because grid[1][1] <= 4.\n- at t = 5, we move to the cell (1,2). It is possible because grid[1][2] <= 5.\n- at t = 6, we move to the cell (1,3). It is possible because grid[1][3] <= 6.\n- at t = 7, we move to the cell (2,3). It is possible because grid[2][3] <= 7.\nThe final time is 7. It can be shown that it is the minimum time possible.",
            "Input: grid = [[0,2,4],[3,2,1],[1,0,4]]\nOutput: -1\nExplanation: There is no path from the top left to the bottom-right cell."
        ],
        "constraints": "m == grid.length\nn == grid[i].length\n2 <= m, n <= 1000\n4 <= m * n <= 105\n0 <= grid[i][j] <= 105\ngrid[0][0] == 0",
        "release_time": 1677384057,
        "oracle_code": "class Solution {\n    private static final int[][] DIRS = new int[][] { { 1, 0 }, { -1, 0}, { 0, 1 }, { 0, -1 } };\n    public int minimumTime(int[][] grid) {\n        if (grid[0][1] > 1 && grid[1][0] > 1) {\n            return -1;\n        }\n        \n        int m = grid.length;\n        int n = grid[0].length;\n        \n        PriorityQueue<int[]> heap = new PriorityQueue<>((a, b) -> a[2] - b[2]);\n        heap.offer(new int[] { 0, 0, 0 }); // row, col, time\n        \n        boolean[][] visited = new boolean[m][n];\n        \n        while (!heap.isEmpty()) {\n            int[] entry = heap.poll();\n            int row = entry[0];\n            int col = entry[1];\n            int time = entry[2];\n            if (row == m - 1 && col == n - 1) {\n                return time;\n            }\n            if (visited[row][col]) {\n                continue;\n            }\n            visited[row][col] = true;\n                \n            for (int[] dir : DIRS) {\n                int r = row + dir[0];\n                int c = col + dir[1];\n                if (r < 0 || r == m || c < 0 || c == n || visited[r][c]) {\n                    continue;\n                }\n                \n                if (grid[r][c] <= time + 1) {\n                    // if it is possible to move to neighbor, do it\n                    heap.offer(new int[] { r, c, time + 1 });\n                } else {\n                    // If we cant move to neighbor yet, we can hop to the previous cell\n                    // and back to current cell as many times as we need to until\n                    // sufficient time has passed.\n                    // The trick here is that if the difference between the current time\n                    // and the time we need is even, we will arrive back at the current cell\n                    // 1 second \"late\" and so we will move to the neighbor 1 second after\n                    // the minimum neighbor time.\n                    int diff = grid[r][c] - time;\n                    if (diff % 2 == 1) {\n                        heap.offer(new int[] { r, c, grid[r][c] });\n                    } else {\n                        heap.offer(new int[] { r, c, grid[r][c] + 1 });\n                    }\n                }\n            }\n        }\n        return -1; // will never reach here\n    }\n}",
        "content": "```\\nclass Solution {\\n    private static final int[][] DIRS = new int[][] { { 1, 0 }, { -1, 0}, { 0, 1 }, { 0, -1 } };\\n    public int minimumTime(int[][] grid) {\\n        if (grid[0][1] > 1 && grid[1][0] > 1) {\\n            return -1;\\n        }\\n        \\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        PriorityQueue<int[]> heap = new PriorityQueue<>((a, b) -> a[2] - b[2]);\\n        heap.offer(new int[] { 0, 0, 0 }); // row, col, time\\n        \\n        boolean[][] visited = new boolean[m][n];\\n        \\n        while (!heap.isEmpty()) {\\n            int[] entry = heap.poll();\\n            int row = entry[0];\\n            int col = entry[1];\\n            int time = entry[2];\\n            if (row == m - 1 && col == n - 1) {\\n                return time;\\n            }\\n            if (visited[row][col]) {\\n                continue;\\n            }\\n            visited[row][col] = true;\\n                \\n            for (int[] dir : DIRS) {\\n                int r = row + dir[0];\\n                int c = col + dir[1];\\n                if (r < 0 || r == m || c < 0 || c == n || visited[r][c]) {\\n                    continue;\\n                }\\n                \\n                if (grid[r][c] <= time + 1) {\\n                    // if it is possible to move to neighbor, do it\\n                    heap.offer(new int[] { r, c, time + 1 });\\n                } else {\\n                    // If we cant move to neighbor yet, we can hop to the previous cell\\n                    // and back to current cell as many times as we need to until\\n                    // sufficient time has passed.\\n                    // The trick here is that if the difference between the current time\\n                    // and the time we need is even, we will arrive back at the current cell\\n                    // 1 second \"late\" and so we will move to the neighbor 1 second after\\n                    // the minimum neighbor time.\\n                    int diff = grid[r][c] - time;\\n                    if (diff % 2 == 1) {\\n                        heap.offer(new int[] { r, c, grid[r][c] });\\n                    } else {\\n                        heap.offer(new int[] { r, c, grid[r][c] + 1 });\\n                    }\\n                }\\n            }\\n        }\\n        return -1; // will never reach here\\n    }\\n}\\n```",
        "level": "hard",
        "buggy_code": "\nclass Solution {\n    private static final int[][] DIRS = new int[][] { { 1, 0 }, { -1, 0}, { 0, 1 }, { 0, -1 } };\n    public int minimumTime(int[][] grid) {\n        if (grid[0][1] > 1 && grid[1][0] > 1) {\n            return -1;\n        }\n        \n        int m = grid.length;\n        int n = grid[0].length;\n        \n        PriorityQueue<int[]> heap = new PriorityQueue<>((a, b) -> a[2] - b[2]);\n        heap.offer(new int[] { 0, 0, 0 }); // row, col, time\n        \n        boolean[][] visited = new boolean[m][n];\n        \n        while (!heap.isEmpty()) {\n            int[] entry = heap.poll();\n            int row = entry[0];\n            int col = entry[1];\n            int time = entry[2];\n            if (row == m - 1 && col == n - 1) {\n                return time;\n            }\n            if (visited[row][col]) {\n                continue;\n            }\n            visited[row][col] = false;\n                \n            for (int[] dir : DIRS) {\n                int r = row + dir[0];\n                int c = col + dir[1];\n                if (r < 0 || r == m || c < 0 || c == n || visited[r][c]) {\n                    continue;\n                }\n                \n                if (grid[r][c] <= time + 1) {\n                    // if it is possible to move to neighbor, do it\n                    heap.offer(new int[] { r, c, time + 1 });\n                } else {\n                    // If we cant move to neighbor yet, we can hop to the previous cell\n                    // and back to current cell as many times as we need to until\n                    // sufficient time has passed.\n                    // The trick here is that if the difference between the current time\n                    // and the time we need is even, we will arrive back at the current cell\n                    // 1 second \"late\" and so we will move to the neighbor 1 second after\n                    // the minimum neighbor time.\n                    int diff = grid[r][c] - time;\n                    if (diff % 2 == 1) {\n                        heap.offer(new int[] { r, c, grid[r][c] });\n                    } else {\n                        heap.offer(new int[] { r, c, grid[r][c] + 1 });\n                    }\n                }\n            }\n        }\n        return -1; // will never reach here\n    }\n}\n",
        "explanations": "\nVisited cells are marked as false again, leading to infinite loops at the visited cells.\n"
    },
    {
        "slug": "minimum-score-triangulation-of-polygon",
        "description": "You have a convex n-sided polygon where each vertex has an integer value. You are given an integer array values where values[i] is the value of the ith vertex (i.e., clockwise order).\nYou will triangulate the polygon into n - 2 triangles. For each triangle, the value of that triangle is the product of the values of its vertices, and the total score of the triangulation is the sum of these values over all n - 2 triangles in the triangulation.\nReturn the smallest possible total score that you can achieve with some triangulation of the polygon.",
        "examples": [
            "Input: values = [1,2,3]\nOutput: 6\nExplanation: The polygon is already triangulated, and the score of the only triangle is 6.",
            "Input: values = [3,7,4,5]\nOutput: 144\nExplanation: There are two triangulations, with possible scores: 3*7*5 + 4*5*7 = 245, or 3*4*5 + 3*4*7 = 144.\nThe minimum score is 144.",
            "Input: values = [1,3,1,4,1,5]\nOutput: 13\nExplanation: The minimum score triangulation has score 1*1*3 + 1*1*4 + 1*1*5 + 1*1*1 = 13."
        ],
        "constraints": "n == values.length\n3 <= n <= 50\n1 <= values[i] <= 100",
        "release_time": 1682753898,
        "oracle_code": "class Solution {\n    int[][] dp;\n    public int minScoreTriangulation(int[] values) {\n        int l=values.length;\n        dp = new int[l][l];\n        for(int[] i : dp) Arrays.fill(i,-1);\n        return solve(values,1,l-1); \n    }\n\n    public int solve(int[] values, int i,int j)\n    {\n        if(i>=j) return 0;\n        if(dp[i][j]!=-1) return dp[i][j];\n        int min=Integer.MAX_VALUE;\n        for(int k=i;k<j;k++)\n        {\n            int temp=solve(values,i,k)+solve(values,k+1,j)+\n                        values[i-1]*values[k]*values[j];\n            min=Math.min(min,temp);\n        }\n\n        return dp[i][j]=min;\n    }\n}",
        "content": "\\n# Complexity\\n- Time complexity: n^2\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: n^2\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int[][] dp;\\n    public int minScoreTriangulation(int[] values) {\\n        int l=values.length;\\n        dp = new int[l][l];\\n        for(int[] i : dp) Arrays.fill(i,-1);\\n        return solve(values,1,l-1); \\n    }\\n\\n    public int solve(int[] values, int i,int j)\\n    {\\n        if(i>=j) return 0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int min=Integer.MAX_VALUE;\\n        for(int k=i;k<j;k++)\\n        {\\n            int temp=solve(values,i,k)+solve(values,k+1,j)+\\n                        values[i-1]*values[k]*values[j];\\n            min=Math.min(min,temp);\\n        }\\n\\n        return dp[i][j]=min;\\n    }\\n}\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\n    int[][] dp;\n    public int minScoreTriangulation(int[] values) {\n        int l=values.length;\n        dp = new int[l][l];\n        for(int[] i : dp) Arrays.fill(i,-1);\n        return solve(values,0,l-1); \n    }\n\n    public int solve(int[] values, int i,int j)\n    {\n        if(i>=j) return 0;\n        if(dp[i][j]!=-1) return dp[i][j];\n        int min=Integer.MAX_VALUE;\n        for(int k=i;k<j;k++)\n        {\n            int temp=solve(values,i,k)+solve(values,k+1,j)+\n                        values[i-1]*values[k]*values[j];\n            min=Math.min(min,temp);\n        }\n\n        return dp[i][j]=min;\n    }\n}\n",
        "explanations": "\nThe array indices in the solve function start from 0 instead of 1, causing an ArrayIndexOutOfBoundsException when accessing values[i-1].\n"
    },
    {
        "slug": "max-consecutive-ones",
        "description": "Given a binary array nums, return the maximum number of consecutive 1's in the array.",
        "examples": [
            "Input: nums = [1,1,0,1,1,1]\nOutput: 3\nExplanation: The first two digits or the last three digits are consecutive 1s. The maximum number of consecutive 1s is 3.",
            "Input: nums = [1,0,1,1,0,1]\nOutput: 2"
        ],
        "constraints": "1 <= nums.length <= 105\nnums[i] is either 0 or 1.",
        "release_time": 1676866256,
        "oracle_code": "class Solution {\n    public int findMaxConsecutiveOnes(int[] nums) {\n        int count=0;\n        int max=0;\n        for(int i=0;i<nums.length;i++){\n            if(nums[i]==1){\n                count++;\n            }else{\n                count=0;\n            }\n            max=Math.max(count,max);\n        }\n        return max;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findMaxConsecutiveOnes(int[] nums) {\\n        int count=0;\\n        int max=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==1){\\n                count++;\\n            }else{\\n                count=0;\\n            }\\n            max=Math.max(count,max);\\n        }\\n        return max;\\n    }\\n}\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\n    public int findMaxConsecutiveOnes(int[] nums) {\n        int count=0;\n        int max=0;\n        for(int i=0;i<nums.length;i++){\n            if(nums[i]==1){\n                count++;\n            }else{\n                max=0;\n            }\n            max=Math.max(count,max);\n        }\n        return max;\n    }\n}\n",
        "explanations": "\nThe bug resets 'max' instead of 'count' when a 0 is found, thus losing maximum count.\n"
    },
    {
        "slug": "corporate-flight-bookings",
        "description": "There are n flights that are labeled from 1 to n.\nYou are given an array of flight bookings bookings, where bookings[i] = [firsti, lasti, seatsi] represents a booking for flights firsti through lasti (inclusive) with seatsi seats reserved for each flight in the range.\nReturn an array answer of length n, where answer[i] is the total number of seats reserved for flight i.",
        "examples": [
            "Input: bookings = [[1,2,10],[2,3,20],[2,5,25]], n = 5\nOutput: [10,55,45,25,25]\nExplanation:\nFlight labels:        1   2   3   4   5\nBooking 1 reserved:  10  10\nBooking 2 reserved:      20  20\nBooking 3 reserved:      25  25  25  25\nTotal seats:         10  55  45  25  25\nHence, answer = [10,55,45,25,25]",
            "Input: bookings = [[1,2,10],[2,2,15]], n = 2\nOutput: [10,25]\nExplanation:\nFlight labels:        1   2\nBooking 1 reserved:  10  10\nBooking 2 reserved:      15\nTotal seats:         10  25\nHence, answer = [10,25]"
        ],
        "constraints": "1 <= n <= 2 * 104\n1 <= bookings.length <= 2 * 104\nbookings[i].length == 3\n1 <= firsti <= lasti <= n\n1 <= seatsi <= 104",
        "release_time": 1673235303,
        "oracle_code": "class Solution:\n    def increment(self, arr, start, end, val):\n        arr[start] += val\n        if end + 1 < len(arr):\n            arr[end+1] -= val\n        \n\n    def corpFlightBookings(self, bookings: List[List[int]], n: int) -> List[int]:\n        arr = [0 for _ in range(n)]\n        for book in bookings:\n            start, end ,seat = book\n            self.increment(arr, start-1, end-1, seat)\n            # print(arr)\n        res = [0 for _ in range(n)]\n        res[0] = arr[0]\n        for i in range(1, n):\n            res[i] = res[i-1] + arr[i]\n        # print(res)\n        return res",
        "content": "# Intuition\\nThis is the same problem as range addition. For any booking, we essentially add a number of seats to the specified range. \\n\\n# Approach\\nThere are `n` days in total. So we can create an array with length `n`, representing the difference array (ith entry represents the difference of ith and the (i-1)th entry of the original array). Then, for each booking, we add the `seat` to `arr[start]` and minus `seat` to `arr[end+1]`, so we are adding the number of seat to the days from `start` to `end`. \\n\\n# Complexity\\n- Time complexity:\\nFor each entry, we modify the array two times. So it\\'s $$O(N)$$.\\n\\n- Space complexity:\\nThe `arr` takes $$O(N)$$.\\n\\n# Code\\n```\\nclass Solution:\\n    def increment(self, arr, start, end, val):\\n        arr[start] += val\\n        if end + 1 < len(arr):\\n            arr[end+1] -= val\\n        \\n\\n    def corpFlightBookings(self, bookings: List[List[int]], n: int) -> List[int]:\\n        arr = [0 for _ in range(n)]\\n        for book in bookings:\\n            start, end ,seat = book\\n            self.increment(arr, start-1, end-1, seat)\\n            # print(arr)\\n        res = [0 for _ in range(n)]\\n        res[0] = arr[0]\\n        for i in range(1, n):\\n            res[i] = res[i-1] + arr[i]\\n        # print(res)\\n        return res\\n\\n\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution:\n    def increment(self, arr, start, end, val):\n        arr[start] += val\n        if end + 1 < len(arr):\n            arr[end+1] -= val\n        \n\n    def corpFlightBookings(self, bookings: List[List[int]], n: int) -> List[int]:\n        arr = [0 for _ in range(n)]\n        for book in bookings:\n            start, end ,seat = book\n            self.increment(arr, start, end, seat)\n            # print(arr)\n        res = [0 for _ in range(n)]\n        res[0] = arr[0]\n        for i in range(1, n):\n            res[i] = res[i-1] + arr[i]\n        # print(res)\n        return res\n",
        "explanations": "\nIn increment method start and end indices are not decremented by 1 before usage.\n"
    },
    {
        "slug": "can-make-arithmetic-progression-from-sequence",
        "description": "A sequence of numbers is called an arithmetic progression if the difference between any two consecutive elements is the same.\nGiven an array of numbers arr, return true if the array can be rearranged to form an arithmetic progression. Otherwise, return false.",
        "examples": [
            "Input: arr = [3,5,1]\nOutput: true\nExplanation: We can reorder the elements as [1,3,5] or [5,3,1] with differences 2 and -2 respectively, between each consecutive elements.",
            "Input: arr = [1,2,4]\nOutput: false\nExplanation: There is no way to reorder the elements to obtain an arithmetic progression."
        ],
        "constraints": "2 <= arr.length <= 1000\n-106 <= arr[i] <= 106",
        "release_time": 1686057547,
        "oracle_code": "class Solution {\n    public boolean canMakeArithmeticProgression(int[] arr) {\n        Arrays.sort(arr);\n        int diff=arr[1]-arr[0];\n        boolean temp=true;\n        for(int i=1;i<arr.length-1;i++){\n            if(arr[i+1]-arr[i]==diff){\n                continue;\n            }else{\n                temp=false;\n            }\n        }\n        if(temp==true){\n            return true;\n        }else{\n            return false;\n        }\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe given code is an implementation of a method named canMakeArithmeticProgression, which determines whether the given array arr can be rearranged to form an arithmetic progression.\\n\\nHere\\'s how the code works:\\n\\nThe arr array is sorted using the Arrays.sort() method. Sorting the array is important because in an arithmetic progression, the elements are arranged in a specific order.\\n\\nThe variable diff is initialized as the difference between the second element (arr[1]) and the first element (arr[0]). This will be the common difference for the arithmetic progression.\\n\\nThe variable temp is set to true. It will be used to keep track of whether all the adjacent element differences match the common difference.\\n\\nA loop iterates from the second element (i=1) to the second-to-last element (i<arr.length-1). This loop compares the difference between the current element (arr[i+1]) and the previous element (arr[i]) with the common difference (diff).\\n\\nIf the difference between the current and previous elements matches the common difference, the loop continues to the next iteration using the continue statement.\\n\\nIf the difference does not match the common difference, temp is set to false, indicating that the array cannot form an arithmetic progression.\\n\\nFinally, after the loop, the value of temp is checked. If it is still true, the method returns true indicating that the array can form an arithmetic progression. Otherwise, it returns false.\\n\\nIn summary, the code checks if the given array can be sorted into an arithmetic progression by comparing the differences between adjacent elements. If all the differences match the common difference, it returns true; otherwise, it returns false.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach used in the given code can be summarized as follows:\\n\\nSort the array in ascending order using the Arrays.sort() method. Sorting the array helps in identifying the order of the elements in an arithmetic progression.\\n\\nCalculate the common difference (diff) between the second element (arr[1]) and the first element (arr[0]).\\n\\nIterate through the array starting from the second element (i=1) up to the second-to-last element (i<arr.length-1).\\n\\nFor each iteration, check if the difference between the current element (arr[i+1]) and the previous element (arr[i]) is equal to the common difference (diff).\\n\\nIf the difference matches, continue to the next iteration.\\n\\nIf the difference does not match, set the temp variable to false, indicating that the array cannot form an arithmetic progression.\\n\\nAfter the loop, check the value of the temp variable. If it is still true, return true to indicate that the array can form an arithmetic progression. Otherwise, return false.\\n\\nIn summary, the code checks if the given array can be rearranged to form an arithmetic progression by comparing the differences between adjacent elements. If all the differences match the common difference, the code returns true; otherwise, it returns false.\\n\\n# Complexity\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean canMakeArithmeticProgression(int[] arr) {\\n        Arrays.sort(arr);\\n        int diff=arr[1]-arr[0];\\n        boolean temp=true;\\n        for(int i=1;i<arr.length-1;i++){\\n            if(arr[i+1]-arr[i]==diff){\\n                continue;\\n            }else{\\n                temp=false;\\n            }\\n        }\\n        if(temp==true){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }\\n}\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\n    public boolean canMakeArithmeticProgression(int[] arr) {\n        Arrays.sort(arr);\n        int diff=arr[1]-arr[0];\n        boolean temp=true;\n        for(int i=1;i<arr.length-1;i++){\n            if(arr[i+1]-arr[i]==diff){\n                temp=false;\n                continue;\n            }else{\n                temp=true;\n            }\n        }\n        if(temp==true){\n            return true;\n        }else{\n            return false;\n        }\n    }\n}\n",
        "explanations": "\nFlipping the temp bool when the difference is equal to diff produces unexpected results.\n"
    },
    {
        "slug": "design-authentication-manager",
        "description": "There is an authentication system that works with authentication tokens. For each session, the user will receive a new authentication token that will expire timeToLive seconds after the currentTime. If the token is renewed, the expiry time will be extended to expire timeToLive seconds after the (potentially different) currentTime.\nImplement the AuthenticationManager class:\n\nAuthenticationManager(int timeToLive) constructs the AuthenticationManager and sets the timeToLive.\ngenerate(string tokenId, int currentTime) generates a new token with the given tokenId at the given currentTime in seconds.\nrenew(string tokenId, int currentTime) renews the unexpired token with the given tokenId at the given currentTime in seconds. If there are no unexpired tokens with the given tokenId, the request is ignored, and nothing happens.\ncountUnexpiredTokens(int currentTime) returns the number of unexpired tokens at the given currentTime.\n\nNote that if a token expires at time t, and another action happens on time t (renew or countUnexpiredTokens), the expiration takes place before the other actions.",
        "examples": [
            "Input\n[\"AuthenticationManager\", \"renew\", \"generate\", \"countUnexpiredTokens\", \"generate\", \"renew\", \"renew\", \"countUnexpiredTokens\"]\n[[5], [\"aaa\", 1], [\"aaa\", 2], [6], [\"bbb\", 7], [\"aaa\", 8], [\"bbb\", 10], [15]]\nOutput\n[null, null, null, 1, null, null, null, 0]\n\nExplanation\nAuthenticationManager authenticationManager = new AuthenticationManager(5); // Constructs the AuthenticationManager with timeToLive = 5 seconds.\nauthenticationManager.renew(\"aaa\", 1); // No token exists with tokenId \"aaa\" at time 1, so nothing happens.\nauthenticationManager.generate(\"aaa\", 2); // Generates a new token with tokenId \"aaa\" at time 2.\nauthenticationManager.countUnexpiredTokens(6); // The token with tokenId \"aaa\" is the only unexpired one at time 6, so return 1.\nauthenticationManager.generate(\"bbb\", 7); // Generates a new token with tokenId \"bbb\" at time 7.\nauthenticationManager.renew(\"aaa\", 8); // The token with tokenId \"aaa\" expired at time 7, and 8 >= 7, so at time 8 the renew request is ignored, and nothing happens.\nauthenticationManager.renew(\"bbb\", 10); // The token with tokenId \"bbb\" is unexpired at time 10, so the renew request is fulfilled and now the token will expire at time 15.\nauthenticationManager.countUnexpiredTokens(15); // The token with tokenId \"bbb\" expires at time 15, and the token with tokenId \"aaa\" expired at time 7, so currently no token is unexpired, so return 0."
        ],
        "constraints": "1 <= timeToLive <= 108\n1 <= currentTime <= 108\n1 <= tokenId.length <= 5\ntokenId consists only of lowercase letters.\nAll calls to generate will contain unique values of tokenId.\nThe values of currentTime across all the function calls will be strictly increasing.\nAt most 2000 calls will be made to all functions combined.",
        "release_time": 1664458448,
        "oracle_code": "class AuthenticationManager {\n\n    int timeToLive;\n    TreeSet<Integer> treeSet;\n    Map<String, Integer> map;\n    public AuthenticationManager(int timeToLive) {\n        this.timeToLive = timeToLive;\n        treeSet = new TreeSet<>();\n        map = new HashMap<>();\n    }\n    \n    public void generate(String tokenId, int currentTime) {\n        map.put(tokenId, currentTime + timeToLive);\n        treeSet.add(currentTime + timeToLive);\n    }\n    \n    public void renew(String tokenId, int currentTime) {\n        \n        Integer time = map.get(tokenId);\n\t\t// If null the token was never added, or it has expired before the renew call, which makes it invalid for renewing\n        if (time == null || time <= currentTime) return;\n       \n\t   \n\t   // Update the hashmap and treeSet with the new values\n        map.put(tokenId, currentTime + timeToLive);\n        treeSet.remove(time);\n        treeSet.add(currentTime + timeToLive);\n        \n\t\t// Clearing the treeset from already expired timestamps, it doesn't really improve the time execution, with about 10% only.\n        while (!treeSet.isEmpty() && treeSet.lower(currentTime) != null) {\n            treeSet.remove(treeSet.lower(currentTime));\n        }\n    }\n    \n\t// Return the number of timestamps in the treeset, which have greated expiry time than the currentTime\n    public int countUnexpiredTokens(int currentTime) {\n        return treeSet.tailSet(currentTime, false).size();\n    }\n}",
        "content": "The algorithm is pretty straightforward, the idea is to add and renew the keys with the added time to live, so we can keep the expiration value and to use a TreeSet for keeping it in a sorted manner with time complexity of O(Log (n)) for add and remove and O (M Log (n)) (where M is the number of items which will be traversed after the \"midpoint\" is found) for .tailSet().  The HashMap has the only purpose to store the expiration value of each key.\\n\\nThe Algorithm is kind of unstable and has performance between 44%  and 93%.\\n\\n```\\nclass AuthenticationManager {\\n\\n    int timeToLive;\\n    TreeSet<Integer> treeSet;\\n    Map<String, Integer> map;\\n    public AuthenticationManager(int timeToLive) {\\n        this.timeToLive = timeToLive;\\n        treeSet = new TreeSet<>();\\n        map = new HashMap<>();\\n    }\\n    \\n    public void generate(String tokenId, int currentTime) {\\n        map.put(tokenId, currentTime + timeToLive);\\n        treeSet.add(currentTime + timeToLive);\\n    }\\n    \\n    public void renew(String tokenId, int currentTime) {\\n        \\n        Integer time = map.get(tokenId);\\n\\t\\t// If null the token was never added, or it has expired before the renew call, which makes it invalid for renewing\\n        if (time == null || time <= currentTime) return;\\n       \\n\\t   \\n\\t   // Update the hashmap and treeSet with the new values\\n        map.put(tokenId, currentTime + timeToLive);\\n        treeSet.remove(time);\\n        treeSet.add(currentTime + timeToLive);\\n        \\n\\t\\t// Clearing the treeset from already expired timestamps, it doesn\\'t really improve the time execution, with about 10% only.\\n        while (!treeSet.isEmpty() && treeSet.lower(currentTime) != null) {\\n            treeSet.remove(treeSet.lower(currentTime));\\n        }\\n    }\\n    \\n\\t// Return the number of timestamps in the treeset, which have greated expiry time than the currentTime\\n    public int countUnexpiredTokens(int currentTime) {\\n        return treeSet.tailSet(currentTime, false).size();\\n    }\\n}\\n```",
        "level": "medium",
        "buggy_code": "\nclass AuthenticationManager {\n\n    int timeToLive;\n    TreeSet<Integer> treeSet;\n    Map<String, Integer> map;\n    public AuthenticationManager(int timeToLive) {\n        this.timeToLive = timeToLive;\n        treeSet = new TreeSet<>();\n        map = new HashMap<>();\n    }\n    \n    public void generate(String tokenId, int currentTime) {\n        map.put(tokenId, currentTime + timeToLive);\n        treeSet.add(currentTime + timeToLive);\n    }\n    \n    public void renew(String tokenId, int currentTime) {\n        \n        Integer time = map.get(tokenId);\n\t\t// If null the token was never added, or it has expired before the renew call, which makes it invalid for renewing\n        if (time == null || time <= currentTime) return;\n       \n\t   \n\t   // Update the hashmap and treeSet with the new values\n        map.put(tokenId, currentTime + time);\n        treeSet.remove(time);\n        treeSet.add(currentTime + time);\n        \n\t\t// Clearing the treeset from already expired timestamps, it doesn't really improve the time execution, with about 10% only.\n        while (!treeSet.isEmpty() && treeSet.lower(currentTime) != null) {\n            treeSet.remove(treeSet.lower(currentTime));\n        }\n    }\n    \n\t// Return the number of timestamps in the treeset, which have greated expiry time than the currentTime\n    public int countUnexpiredTokens(int currentTime) {\n        return treeSet.tailSet(currentTime, false).size();\n    }\n}\n",
        "explanations": "\nIn the renew method, updated the time with current time plus time instead of timeToLive.\n"
    },
    {
        "slug": "reduction-operations-to-make-the-array-elements-equal",
        "description": "Given an integer array nums, your goal is to make all elements in nums equal. To complete one operation, follow these steps:\n\nFind the largest value in nums. Let its index be i (0-indexed) and its value be largest. If there are multiple elements with the largest value, pick the smallest i.\nFind the next largest value in nums strictly smaller than largest. Let its value be nextLargest.\nReduce nums[i] to nextLargest.\n\nReturn the number of operations to make all elements in nums equal.",
        "examples": [
            "Input: nums = [5,1,3]\nOutput: 3\nExplanation:\u00a0It takes 3 operations to make all elements in nums equal:\n1. largest = 5 at index 0. nextLargest = 3. Reduce nums[0] to 3. nums = [3,1,3].\n2. largest = 3 at index 0. nextLargest = 1. Reduce nums[0] to 1. nums = [1,1,3].\n3. largest = 3 at index 2. nextLargest = 1. Reduce nums[2] to 1. nums = [1,1,1].",
            "Input: nums = [1,1,1]\nOutput: 0\nExplanation:\u00a0All elements in nums are already equal.",
            "Input: nums = [1,1,2,2,3]\nOutput: 4\nExplanation:\u00a0It takes 4 operations to make all elements in nums equal:\n1. largest = 3 at index 4. nextLargest = 2. Reduce nums[4] to 2. nums = [1,1,2,2,2].\n2. largest = 2 at index 2. nextLargest = 1. Reduce nums[2] to 1. nums = [1,1,1,2,2].\n3. largest = 2 at index 3. nextLargest = 1. Reduce nums[3] to 1. nums = [1,1,1,1,2].\n4. largest = 2 at index 4. nextLargest = 1. Reduce nums[4] to 1. nums = [1,1,1,1,1]."
        ],
        "constraints": "1 <= nums.length <= 5 * 104\n1 <= nums[i] <= 5 * 104",
        "release_time": 1679145144,
        "oracle_code": "class Solution {\n    public int reductionOperations(int[] nums) {\n        Arrays.sort(nums);\n        HashMap<Integer,Integer> map=new HashMap<Integer,Integer>();\n        int x = 0;\n        for(Integer num : nums){\n            if(map.containsKey(num)){\n                continue;\n            }\n            map.put(num,x++);\n        }\n        \n        int count = 0;\n        for(int i = 1;i<nums.length;i++){\n            if(nums[i]>nums[0]){\n                count+=map.get(nums[i]);\n            }\n        }\n        return count;\n    }\n}",
        "content": "Please **UPVOTE** if you like my solution!\\n\\n```\\nclass Solution {\\n    public int reductionOperations(int[] nums) {\\n        Arrays.sort(nums);\\n        HashMap<Integer,Integer> map=new HashMap<Integer,Integer>();\\n        int x = 0;\\n        for(Integer num : nums){\\n            if(map.containsKey(num)){\\n                continue;\\n            }\\n            map.put(num,x++);\\n        }\\n        \\n        int count = 0;\\n        for(int i = 1;i<nums.length;i++){\\n            if(nums[i]>nums[0]){\\n                count+=map.get(nums[i]);\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\n    public int reductionOperations(int[] nums) {\n        Arrays.sort(nums);\n        HashMap<Integer,Integer> map=new HashMap<Integer,Integer>();\n        int x = 1; \n        for(Integer num : nums){\n            if(map.containsKey(num)){\n                continue;\n            }\n            map.put(num,x++);\n        }\n        \n        int count = 0;\n        for(int i = 1;i<nums.length;i++){\n            if(nums[i]>nums[0]){\n                count+=map.get(nums[i]);\n            }\n        }\n        return count;\n    }\n}\n",
        "explanations": "\nSetting x=1 instead of x=0 increases all values in HashMap by 1, affecting reduction operations number.\n"
    },
    {
        "slug": "loud-and-rich",
        "description": "There is a group of n people labeled from 0 to n - 1 where each person has a different amount of money and a different level of quietness.\nYou are given an array richer where richer[i] = [ai, bi] indicates that ai has more money than bi and an integer array quiet where quiet[i] is the quietness of the ith person. All the given data in richer are logically correct (i.e., the data will not lead you to a situation where x is richer than y and y is richer than x at the same time).\nReturn an integer array answer where answer[x] = y if y is the least quiet person (that is, the person y with the smallest value of quiet[y]) among all people who definitely have equal to or more money than the person x.",
        "examples": [
            "Input: richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]], quiet = [3,2,5,4,6,1,7,0]\nOutput: [5,5,2,5,4,5,6,7]\nExplanation: \nanswer[0] = 5.\nPerson 5 has more money than 3, which has more money than 1, which has more money than 0.\nThe only person who is quieter (has lower quiet[x]) is person 7, but it is not clear if they have more money than person 0.\nanswer[7] = 7.\nAmong all people that definitely have equal to or more money than person 7 (which could be persons 3, 4, 5, 6, or 7), the person who is the quietest (has lower quiet[x]) is person 7.\nThe other answers can be filled out with similar reasoning.",
            "Input: richer = [], quiet = [0]\nOutput: [0]"
        ],
        "constraints": "n == quiet.length\n1 <= n <= 500\n0 <= quiet[i] < n\nAll the values of quiet are unique.\n0 <= richer.length <= n * (n - 1) / 2\n0 <= ai, bi < n\nai != bi\nAll the pairs of richer are unique.\nThe observations in richer are all logically consistent.",
        "release_time": 1670637012,
        "oracle_code": "class Solution {\n    int ans[];\n    Map<Integer,List<Integer>> map=new HashMap<>();\n    int temp[]=new int[0];\n    int curr_node=0;\n    List<Integer> vis=new ArrayList<Integer>();\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\n        \n        ans=new int[quiet.length];\n        for(int i=0;i<=richer.length;i++){\n            \n            if(!map.containsKey(i)){\n                map.put(i,new ArrayList());\n            }\n            if(i<richer.length && !map.containsKey(richer[i][0])){\n                map.put(richer[i][0],new ArrayList());\n                map.get(richer[i][0]).add(richer[i][1]);\n            }\n            else if(i<richer.length){\n                map.get(richer[i][0]).add(richer[i][1]);\n            }\n        }\n        \n        Comparator<pair> comp=new Comparator<pair>(){\n            public int compare(pair p1,pair p2){\n                if(p1.cost>p2.cost){\n                    return 1;\n                }\n                else{\n                    return -1;\n                }\n\n            }\n        };\n        PriorityQueue<pair> pq=new PriorityQueue<>(comp);\n        for(int i=0;i<quiet.length;i++){\n            ans[i]=-1;\n            pq.add(new pair(i,quiet[i]));\n        }\n        \n        while(!pq.isEmpty()){\n            pair top=pq.poll();\n            //System.out.println(top.node+\" \"+top.cost);\n            curr_node=top.node;\n            if(!vis.contains(top.node)){\n            dfs(top.node);\n            }\n        }\n        return ans;\n       \n    }\n    public void dfs(int node){\n        //System.out.println(node);\n        if(ans[node]==-1){\n            ans[node]=curr_node;\n        }\n        if(!vis.contains(node) && map.containsKey(node)){\n            vis.add(node);\n             \n            for(int i : map.get(node)){\n            dfs(i);\n        \n        }\n        }\n            \n    }\n}\n\nclass pair{\n    int node,cost;\n    pair(int node,int cost){\n        this.node=node;\n        this.cost=cost;\n    }\n}",
        "content": "\\n# Code\\n```\\nclass Solution {\\n    int ans[];\\n    Map<Integer,List<Integer>> map=new HashMap<>();\\n    int temp[]=new int[0];\\n    int curr_node=0;\\n    List<Integer> vis=new ArrayList<Integer>();\\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\\n        \\n        ans=new int[quiet.length];\\n        for(int i=0;i<=richer.length;i++){\\n            \\n            if(!map.containsKey(i)){\\n                map.put(i,new ArrayList());\\n            }\\n            if(i<richer.length && !map.containsKey(richer[i][0])){\\n                map.put(richer[i][0],new ArrayList());\\n                map.get(richer[i][0]).add(richer[i][1]);\\n            }\\n            else if(i<richer.length){\\n                map.get(richer[i][0]).add(richer[i][1]);\\n            }\\n        }\\n        \\n        Comparator<pair> comp=new Comparator<pair>(){\\n            public int compare(pair p1,pair p2){\\n                if(p1.cost>p2.cost){\\n                    return 1;\\n                }\\n                else{\\n                    return -1;\\n                }\\n\\n            }\\n        };\\n        PriorityQueue<pair> pq=new PriorityQueue<>(comp);\\n        for(int i=0;i<quiet.length;i++){\\n            ans[i]=-1;\\n            pq.add(new pair(i,quiet[i]));\\n        }\\n        \\n        while(!pq.isEmpty()){\\n            pair top=pq.poll();\\n            //System.out.println(top.node+\" \"+top.cost);\\n            curr_node=top.node;\\n            if(!vis.contains(top.node)){\\n            dfs(top.node);\\n            }\\n        }\\n        return ans;\\n       \\n    }\\n    public void dfs(int node){\\n        //System.out.println(node);\\n        if(ans[node]==-1){\\n            ans[node]=curr_node;\\n        }\\n        if(!vis.contains(node) && map.containsKey(node)){\\n            vis.add(node);\\n             \\n            for(int i : map.get(node)){\\n            dfs(i);\\n        \\n        }\\n        }\\n            \\n    }\\n}\\n\\nclass pair{\\n    int node,cost;\\n    pair(int node,int cost){\\n        this.node=node;\\n        this.cost=cost;\\n    }\\n}\\n\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\n    int ans[];\n    Map<Integer,List<Integer>> map=new HashMap<>();\n    int temp[]=new int[0];\n    int curr_node=0;\n    List<Integer> vis=new ArrayList<Integer>();\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\n        \n        ans=new int[quiet.length];\n        for(int i=0;i<=richer.length;i++){\n            \n            if(!map.containsKey(i)){\n                map.put(i,new ArrayList());\n            }\n            if(i<richer.length && !map.containsKey(richer[i][0])){\n                map.put(richer[i][0],new ArrayList());\n                map.get(richer[i][0]).add(richer[i][1]);\n            }\n            else if(i<richer.length){\n                map.get(richer[i][0]).add(richer[i][0]);\n            }\n        }\n        \n        Comparator<pair> comp=new Comparator<pair>(){\n            public int compare(pair p1,pair p2){\n                if(p1.cost>p2.cost){\n                    return 1;\n                }\n                else{\n                    return -1;\n                }\n\n            }\n        };\n        PriorityQueue<pair> pq=new PriorityQueue<>(comp);\n        for(int i=0;i<quiet.length;i++){\n            ans[i]=-1;\n            pq.add(new pair(i,quiet[i]));\n        }\n        \n        while(!pq.isEmpty()){\n            pair top=pq.poll();\n            //System.out.println(top.node+\" \"+top.cost);\n            curr_node=top.node;\n            if(!vis.contains(top.node)){\n            dfs(top.node);\n            }\n        }\n        return ans;\n       \n    }\n    public void dfs(int node){\n        //System.out.println(node);\n        if(ans[node]==-1){\n            ans[node]=curr_node;\n        }\n        if(!vis.contains(node) && map.containsKey(node)){\n            vis.add(node);\n             \n            for(int i : map.get(node)){\n            dfs(i);\n        \n        }\n        }\n            \n    }\n}\n\nclass pair{\n    int node,cost;\n    pair(int node,int cost){\n        this.node=node;\n        this.cost=cost;\n    }\n}\n",
        "explanations": "\nAdded same element to the map instead of different elements, results in wrong associations.\n"
    },
    {
        "slug": "add-strings",
        "description": "Given two non-negative integers, num1 and num2 represented as string, return the sum of num1 and num2 as a string.\nYou must solve the problem without using any built-in library for handling large integers (such as BigInteger). You must also not convert the inputs to integers directly.",
        "examples": [
            "Input: num1 = \"11\", num2 = \"123\"\nOutput: \"134\"",
            "Input: num1 = \"456\", num2 = \"77\"\nOutput: \"533\"",
            "Input: num1 = \"0\", num2 = \"0\"\nOutput: \"0\""
        ],
        "constraints": "1 <= num1.length, num2.length <= 104\nnum1 and num2 consist of only digits.\nnum1 and num2 don't have any leading zeros except for the zero itself.",
        "release_time": 1692165728,
        "oracle_code": "class Solution:\n    def addStrings(self, num1: str, num2: str) -> str:\n        sys.set_int_max_str_digits(10000)\n        nattu = int(num1)\n        babu = int(num2)\n        result = str(nattu+babu)\n        return result",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def addStrings(self, num1: str, num2: str) -> str:\\n        sys.set_int_max_str_digits(10000)\\n        nattu = int(num1)\\n        babu = int(num2)\\n        result = str(nattu+babu)\\n        return result\\n\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution:\n    def addStrings(self, num1: str, num2: str) -> str:\n        sys.set_int_max_str_digits(10000)\n        nattu = int(num1)\n        babu = int(num1)\n        result = str(nattu+babu)\n        return result\n",
        "explanations": "\nThe second integer is assigned the value of num1 instead of num2, causing incorrect addition.\n"
    },
    {
        "slug": "maximum-number-of-fish-in-a-grid",
        "description": "You are given a 0-indexed 2D matrix grid of size m x n, where (r, c) represents:\n\nA land cell if grid[r][c] = 0, or\nA water cell containing grid[r][c] fish, if grid[r][c] > 0.\n\nA fisher can start at any water cell (r, c) and can do the following operations any number of times:\n\nCatch all the fish at cell (r, c), or\nMove to any adjacent water cell.\n\nReturn the maximum number of fish the fisher can catch if he chooses his starting cell optimally, or 0 if no water cell exists.\nAn adjacent cell of the cell (r, c), is one of the cells (r, c + 1), (r, c - 1), (r + 1, c) or (r - 1, c) if it exists.",
        "examples": [
            "Input: grid = [[0,2,1,0],[4,0,0,3],[1,0,0,4],[0,3,2,0]]\nOutput: 7\nExplanation: The fisher can start at cell (1,3) and collect 3 fish, then move to cell (2,3)\u00a0and collect 4 fish.",
            "Input: grid = [[1,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,1]]\nOutput: 1\nExplanation: The fisher can start at cells (0,0) or (3,3) and collect a single fish."
        ],
        "constraints": "m == grid.length\nn == grid[i].length\n1 <= m, n <= 10\n0 <= grid[i][j] <= 10",
        "release_time": 1682784060,
        "oracle_code": "class Solution {\n    public int findMaxFish(int[][] grid) {\n        int sum=0;\n        for(int i=0;i<grid.length;i++)\n        {\n            for(int j=0;j<grid[0].length;j++)\n            {\n                if(grid[i][j]!=0)\n                {\n                    int a[]=new int[1];\n                    task(grid,i,j,a);\n                    sum=Math.max(sum,a[0]);\n                }\n            }\n        }\n        return sum;\n    }\n    public void task(int grid[][], int i, int j, int a[])\n    {\n        if(i<0 || j<0 || i>=grid.length || j>=grid[0].length || grid[i][j]==0)\n        {\n            return;\n        }\n        a[0]+=grid[i][j];\n        grid[i][j]=0;\n        task(grid,i+1,j,a);\n        task(grid,i-1,j,a);\n        task(grid,i,j+1,a);\n        task(grid,i,j-1,a);\n    }\n}",
        "content": "# Complexity\\n- Time complexity: $$O(m*n)$$\\n\\n- Space complexity: $$O(m*n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int findMaxFish(int[][] grid) {\\n        int sum=0;\\n        for(int i=0;i<grid.length;i++)\\n        {\\n            for(int j=0;j<grid[0].length;j++)\\n            {\\n                if(grid[i][j]!=0)\\n                {\\n                    int a[]=new int[1];\\n                    task(grid,i,j,a);\\n                    sum=Math.max(sum,a[0]);\\n                }\\n            }\\n        }\\n        return sum;\\n    }\\n    public void task(int grid[][], int i, int j, int a[])\\n    {\\n        if(i<0 || j<0 || i>=grid.length || j>=grid[0].length || grid[i][j]==0)\\n        {\\n            return;\\n        }\\n        a[0]+=grid[i][j];\\n        grid[i][j]=0;\\n        task(grid,i+1,j,a);\\n        task(grid,i-1,j,a);\\n        task(grid,i,j+1,a);\\n        task(grid,i,j-1,a);\\n    }\\n}\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\n    public int findMaxFish(int[][] grid) {\n        int sum=0;\n        for(int i=0;i<grid.length;i++)\n        {\n            for(int j=0;j<grid[0].length;j++)\n            {\n                if(grid[i][j]!=0)\n                {\n                    int a[]=new int[1];\n                    task(grid,i,j,a);\n                    sum=Math.max(sum,a[0]);\n                }\n            }\n        }\n        return sum;\n    }\n    public void task(int grid[][], int i, int j, int a[])\n    {\n        if(i<0 || j<0 || i>=grid.length || j>=grid[0].length || grid[i][j]==0)\n        {\n            return;\n        }\n        a[0]+=grid[i][j];\n        grid[i][j]=0;\n        task(grid,i+1,j,a);\n        task(grid,i-1,j,a);\n        task(grid,i,j+1,a);\n        task(grid,i,j-1,a);\n        a[0] = 0; \n    }\n}\n",
        "explanations": "\nThe cumulative sum is incorrectly reset to zero after all recursive calls in method task().\n"
    },
    {
        "slug": "find-all-people-with-secret",
        "description": "You are given an integer n indicating there are n people numbered from 0 to n - 1. You are also given a 0-indexed 2D integer array meetings where meetings[i] = [xi, yi, timei] indicates that person xi and person yi have a meeting at timei. A person may attend multiple meetings at the same time. Finally, you are given an integer firstPerson.\nPerson 0 has a secret and initially shares the secret with a person firstPerson at time 0. This secret is then shared every time a meeting takes place with a person that has the secret. More formally, for every meeting, if a person xi has the secret at timei, then they will share the secret with person yi, and vice versa.\nThe secrets are shared instantaneously. That is, a person may receive the secret and share it with people in other meetings within the same time frame.\nReturn a list of all the people that have the secret after all the meetings have taken place. You may return the answer in any order.",
        "examples": [
            "Input: n = 6, meetings = [[1,2,5],[2,3,8],[1,5,10]], firstPerson = 1\nOutput: [0,1,2,3,5]\nExplanation:\nAt time 0, person 0 shares the secret with person 1.\nAt time 5, person 1 shares the secret with person 2.\nAt time 8, person 2 shares the secret with person 3.\nAt time 10, person 1 shares the secret with person 5.\u200b\u200b\u200b\u200b\nThus, people 0, 1, 2, 3, and 5 know the secret after all the meetings.",
            "Input: n = 4, meetings = [[3,1,3],[1,2,2],[0,3,3]], firstPerson = 3\nOutput: [0,1,3]\nExplanation:\nAt time 0, person 0 shares the secret with person 3.\nAt time 2, neither person 1 nor person 2 know the secret.\nAt time 3, person 3 shares the secret with person 0 and person 1.\nThus, people 0, 1, and 3 know the secret after all the meetings.",
            "Input: n = 5, meetings = [[3,4,2],[1,2,1],[2,3,1]], firstPerson = 1\nOutput: [0,1,2,3,4]\nExplanation:\nAt time 0, person 0 shares the secret with person 1.\nAt time 1, person 1 shares the secret with person 2, and person 2 shares the secret with person 3.\nNote that person 2 can share the secret at the same time as receiving it.\nAt time 2, person 3 shares the secret with person 4.\nThus, people 0, 1, 2, 3, and 4 know the secret after all the meetings."
        ],
        "constraints": "2 <= n <= 105\n1 <= meetings.length <= 105\nmeetings[i].length == 3\n0 <= xi, yi <= n - 1\nxi != yi\n1 <= timei <= 105\n1 <= firstPerson <= n - 1",
        "release_time": 1687729516,
        "oracle_code": "class DisjointSet {\n    int[] root;\n    Long[] rank;\n    DisjointSet(int size, Set<Integer> secretKeepers) {\n        root = new int[size];\n        rank = new Long[size];\n        for (int i = 0; i < size; i++) {\n            root[i] = i;\n            rank[i] = secretKeepers.contains(i) ? Integer.MAX_VALUE : 1L;\n        }\n    }\n\n    public int find(int vertex) {\n        if(root[vertex] == vertex) return vertex;\n        return root[vertex] = find(root[vertex]);\n    }\n\n    public void union(int vertex1, int vertex2) {\n        int root1 = find(vertex1);\n        int root2 = find(vertex2);\n        if(root1 != root2) {\n            if(rank[root1] > rank[root2]) {\n                root[root2] = root1;\n            } else if (rank[root2] > rank[root1]) {\n                root[root1] = root2;\n            } else {\n                root[root2] = root1;\n                rank[root1]++;\n            }\n        }\n    }\n\n    public Set<Integer> getAllSecretKeepers(Set<Integer> secretKeepers, Set<Integer> visited) {\n        for (int vertex: visited) {\n            if(secretKeepers.contains(find(vertex)))\n                secretKeepers.add(vertex);\n            else \n                root[vertex] = vertex;\n        }\n        return secretKeepers;\n    }\n}\n\nclass Solution {\n    private int maxTime = Integer.MIN_VALUE;\n    private int minTime = Integer.MAX_VALUE;\n    public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {\n        Set<Integer> secretKeepers = new HashSet<>(List.of(0, firstPerson));\n        Map<Integer, List<Integer[]>> timeToMeetings = getTimeToMeetings(meetings);\n        DisjointSet disjointSet = new DisjointSet(n, secretKeepers);\n        for (int time = minTime; time <= maxTime; time++) {\n            if(!timeToMeetings.containsKey(time)) continue;\n            Set<Integer> visited = new HashSet<>();\n            for (Integer[] meeting: timeToMeetings.get(time)) {\n                int person1 = meeting[0], person2 = meeting[1];\n                disjointSet.union(person1, person2);\n                visited.add(person1);\n                visited.add(person2);\n            }\n            secretKeepers = disjointSet.getAllSecretKeepers(secretKeepers, visited);\n        }\n        return new ArrayList<>(secretKeepers);\n    }\n\n    private Map<Integer, List<Integer[]>> getTimeToMeetings(int[][] meetings) {\n        Map<Integer, List<Integer[]>> timeToMeetings = new HashMap<>();\n        for (int[] meeting: meetings) {\n            maxTime = Math.max(maxTime, meeting[2]);\n            minTime = Math.min(minTime, meeting[2]);\n            timeToMeetings.computeIfAbsent(meeting[2], e-> new ArrayList<>()).add(new Integer[]{meeting[0], meeting[1]});\n        }\n        return timeToMeetings;\n    }\n}",
        "content": "# Code\\n```\\nclass DisjointSet {\\n    int[] root;\\n    Long[] rank;\\n    DisjointSet(int size, Set<Integer> secretKeepers) {\\n        root = new int[size];\\n        rank = new Long[size];\\n        for (int i = 0; i < size; i++) {\\n            root[i] = i;\\n            rank[i] = secretKeepers.contains(i) ? Integer.MAX_VALUE : 1L;\\n        }\\n    }\\n\\n    public int find(int vertex) {\\n        if(root[vertex] == vertex) return vertex;\\n        return root[vertex] = find(root[vertex]);\\n    }\\n\\n    public void union(int vertex1, int vertex2) {\\n        int root1 = find(vertex1);\\n        int root2 = find(vertex2);\\n        if(root1 != root2) {\\n            if(rank[root1] > rank[root2]) {\\n                root[root2] = root1;\\n            } else if (rank[root2] > rank[root1]) {\\n                root[root1] = root2;\\n            } else {\\n                root[root2] = root1;\\n                rank[root1]++;\\n            }\\n        }\\n    }\\n\\n    public Set<Integer> getAllSecretKeepers(Set<Integer> secretKeepers, Set<Integer> visited) {\\n        for (int vertex: visited) {\\n            if(secretKeepers.contains(find(vertex)))\\n                secretKeepers.add(vertex);\\n            else \\n                root[vertex] = vertex;\\n        }\\n        return secretKeepers;\\n    }\\n}\\n\\nclass Solution {\\n    private int maxTime = Integer.MIN_VALUE;\\n    private int minTime = Integer.MAX_VALUE;\\n    public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {\\n        Set<Integer> secretKeepers = new HashSet<>(List.of(0, firstPerson));\\n        Map<Integer, List<Integer[]>> timeToMeetings = getTimeToMeetings(meetings);\\n        DisjointSet disjointSet = new DisjointSet(n, secretKeepers);\\n        for (int time = minTime; time <= maxTime; time++) {\\n            if(!timeToMeetings.containsKey(time)) continue;\\n            Set<Integer> visited = new HashSet<>();\\n            for (Integer[] meeting: timeToMeetings.get(time)) {\\n                int person1 = meeting[0], person2 = meeting[1];\\n                disjointSet.union(person1, person2);\\n                visited.add(person1);\\n                visited.add(person2);\\n            }\\n            secretKeepers = disjointSet.getAllSecretKeepers(secretKeepers, visited);\\n        }\\n        return new ArrayList<>(secretKeepers);\\n    }\\n\\n    private Map<Integer, List<Integer[]>> getTimeToMeetings(int[][] meetings) {\\n        Map<Integer, List<Integer[]>> timeToMeetings = new HashMap<>();\\n        for (int[] meeting: meetings) {\\n            maxTime = Math.max(maxTime, meeting[2]);\\n            minTime = Math.min(minTime, meeting[2]);\\n            timeToMeetings.computeIfAbsent(meeting[2], e-> new ArrayList<>()).add(new Integer[]{meeting[0], meeting[1]});\\n        }\\n        return timeToMeetings;\\n    }\\n}\\n```",
        "level": "hard",
        "buggy_code": "\nclass DisjointSet {\n    int[] root;\n    Long[] rank;\n    DisjointSet(int size, Set<Integer> secretKeepers) {\n        root = new int[size];\n        rank = new Long[size];\n        for (int i = 0; i < size; i++) {\n            root[i] = i;\n            rank[i] = secretKeepers.contains(i) ? Integer.MAX_VALUE : 1L;\n        }\n    }\n\n    public int find(int vertex) {\n        if(root[vertex] == vertex) return vertex;\n        return root[vertex] = find(root[vertex]);\n    }\n\n    public void union(int vertex1, int vertex2) {\n        int root1 = find(vertex1);\n        int root2 = find(vertex2);\n        if(root1 != root2) {\n            if(rank[root1] > rank[root2]) {\n                root[root2] = root1;\n            } else if (rank[root2] > rank[root1]) {\n                root[root1] = root2;\n            } else {\n                root[root2] = root1;\n                rank[root1]++;\n            }\n        }\n    }\n\n    public Set<Integer> getAllSecretKeepers(Set<Integer> secretKeepers, Set<Integer> visited) {\n        for (int vertex: visited) {\n            if(secretKeepers.contains(find(vertex)))\n                secretKeepers.add(vertex);\n            else \n                root[vertex] = vertex;\n        }\n        return secretKeepers;\n    }\n}\n\nclass Solution {\n    private int maxTime = Integer.MIN_VALUE;\n    private int minTime = Integer.MAX_VALUE;\n    public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {\n        Set<Integer> secretKeepers = new HashSet<>(List.of(0, firstPerson));\n        Map<Integer, List<Integer[]>> timeToMeetings = getTimeToMeetings(meetings);\n        DisjointSet disjointSet = new DisjointSet(n, secretKeepers);\n        for (int time = minTime; time <= maxTime; time++) {\n            if(!timeToMeetings.containsKey(time)) continue;\n            Set<Integer> visited = new HashSet<>();\n            for (Integer[] meeting: timeToMeetings.get(time)) {\n                int person1 = meeting[0], person2 = meeting[1];\n                disjointSet.union(person1, meeting[2]);\n                visited.add(person1);\n                visited.add(person2);\n            }\n            secretKeepers = disjointSet.getAllSecretKeepers(secretKeepers, visited);\n        }\n        return new ArrayList<>(secretKeepers);\n    }\n\n    private Map<Integer, List<Integer[]>> getTimeToMeetings(int[][] meetings) {\n        Map<Integer, List<Integer[]>> timeToMeetings = new HashMap<>();\n        for (int[] meeting: meetings) {\n            maxTime = Math.max(maxTime, meeting[2]);\n            minTime = Math.min(minTime, meeting[2]);\n            timeToMeetings.computeIfAbsent(meeting[2], e-> new ArrayList<>()).add(new Integer[]{meeting[0], meeting[1]});\n        }\n        return timeToMeetings;\n    }\n}\n",
        "explanations": "\nIn the 'union' function call within 'findAllPeople', meeting[2] is passed instead of person2.\n"
    },
    {
        "slug": "subtract-the-product-and-sum-of-digits-of-an-integer",
        "description": "Given an integer number n, return the difference between the product of its digits and the sum of its digits.",
        "examples": [
            "Input: n = 234\nOutput: 15 \nExplanation: \nProduct of digits = 2 * 3 * 4 = 24 \nSum of digits = 2 + 3 + 4 = 9 \nResult = 24 - 9 = 15",
            "Input: n = 4421\nOutput: 21\nExplanation: \nProduct of digits = 4 * 4 * 2 * 1 = 32 \nSum of digits = 4 + 4 + 2 + 1 = 11 \nResult = 32 - 11 = 21"
        ],
        "constraints": "1 <= n <= 10^5",
        "release_time": 1683965436,
        "oracle_code": "class Solution {\n    public int subtractProductAndSum(int n) {\n        int prod=1;\n        int sum=0;\n        while(n>0) {\n            int rem=n%10;\n            sum+=rem;\n            prod*=rem;\n            n/=10;\n        }\n        return prod-sum;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int subtractProductAndSum(int n) {\\n        int prod=1;\\n        int sum=0;\\n        while(n>0) {\\n            int rem=n%10;\\n            sum+=rem;\\n            prod*=rem;\\n            n/=10;\\n        }\\n        return prod-sum;\\n    }\\n}\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\n    public int subtractProductAndSum(int n) {\n        int prod=0; \n        int sum=0;\n        while(n>0) {\n            int rem=n%10;\n            sum+=rem;\n            prod*=rem;\n            n/=10;\n        }\n        return prod-sum;\n    }\n}\n",
        "explanations": "\nInitialized variable 'prod' as 0, causing the extraction of digits' product always 0.\n"
    },
    {
        "slug": "merge-strings-alternately",
        "description": "You are given two strings word1 and word2. Merge the strings by adding letters in alternating order, starting with word1. If a string is longer than the other, append the additional letters onto the end of the merged string.\nReturn the merged string.",
        "examples": [
            "Input: word1 = \"abc\", word2 = \"pqr\"\r\nOutput: \"apbqcr\"\r\nExplanation:\u00a0The merged string will be merged as so:\r\nword1:  a   b   c\r\nword2:    p   q   r\r\nmerged: a p b q c r",
            "Input: word1 = \"ab\", word2 = \"pqrs\"\r\nOutput: \"apbqrs\"\r\nExplanation:\u00a0Notice that as word2 is longer, \"rs\" is appended to the end.\r\nword1:  a   b \r\nword2:    p   q   r   s\r\nmerged: a p b q   r   s",
            "Input: word1 = \"abcd\", word2 = \"pq\"\r\nOutput: \"apbqcd\"\r\nExplanation:\u00a0Notice that as word1 is longer, \"cd\" is appended to the end.\r\nword1:  a   b   c   d\r\nword2:    p   q \r\nmerged: a p b q c   d"
        ],
        "constraints": "1 <= word1.length, word2.length <= 100\nword1 and word2 consist of lowercase English letters.",
        "release_time": 1692376529,
        "oracle_code": "class Solution {\n    public String mergeAlternately(String word1, String word2) {\n     char [] arr1=word1.toCharArray();\n     char [] arr2=word2.toCharArray();\n     char [] merge = new char[arr1.length+arr2.length];\n    int i=0,j=0;\n    while( i< merge.length){\n        if(j<arr1.length){\n            merge[i]=arr1[j];\n            i++;\n        }\n        if( j< arr2.length){\n            merge[i]=arr2[j];\n            i++;\n        }\n        j++;\n    }\n    return new String(merge);\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n Steps of the mergeAlternately function:\\n\\nConvert input strings word1 and word2 into character arrays arr1 and arr2.\\nInitialize a new character array merge with a length of arr1.length + arr2.length to hold the merged characters.\\nInitialize two indices: i for the merge array and j for tracking characters in word2.\\nStart a loop that iterates until the merge array is filled with characters from both input strings:\\na. Check if j is within the bounds of arr1:\\nIf true, assign arr1[j] to merge[i] and increment both i and j.\\nb. Check if j is within the bounds of arr2:\\nIf true, assign arr2[j] to merge[i] and increment both i and j.\\nReturn a new string created from the merge array using the String constructor.\\n\\n# Complexity\\n- Time complexity:\\nO(max(m,n))\\n\\n- Space complexity:\\nO(m,n)\\n\\n# Code\\n```\\nclass Solution {\\n    public String mergeAlternately(String word1, String word2) {\\n     char [] arr1=word1.toCharArray();\\n     char [] arr2=word2.toCharArray();\\n     char [] merge = new char[arr1.length+arr2.length];\\n    int i=0,j=0;\\n    while( i< merge.length){\\n        if(j<arr1.length){\\n            merge[i]=arr1[j];\\n            i++;\\n        }\\n        if( j< arr2.length){\\n            merge[i]=arr2[j];\\n            i++;\\n        }\\n        j++;\\n    }\\n    return new String(merge);\\n    }\\n}\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\n    public String mergeAlternately(String word1, String word2) {\n     char [] arr1=word1.toCharArray();\n     char [] arr2=word2.toCharArray();\n     char [] merge = new char[arr1.length+arr2.length];\n    int i=0,j=0;\n    while( i< merge.length){\n        if(j<arr1.length){\n            merge[i]=arr2[j];\n            i++;\n        }\n        if( j< arr2.length){\n            merge[i]=arr1[j];\n            i++;\n        }\n        j++;\n    }\n    return new String(merge);\n    }\n}\n",
        "explanations": "\nSwitched order of two input strings while merging, giving unexpected order of characters.\n"
    },
    {
        "slug": "ways-to-split-array-into-good-subarrays",
        "description": "You are given a binary array nums.\nA subarray of an array is good if it contains exactly one element with the value 1.\nReturn an integer denoting the number of ways to split the array nums into good subarrays. As the number may be too large, return it modulo 109 + 7.\nA subarray is a contiguous non-empty sequence of elements within an array.",
        "examples": [
            "Input: nums = [0,1,0,0,1]\nOutput: 3\nExplanation: There are 3 ways to split nums into good subarrays:\n- [0,1] [0,0,1]\n- [0,1,0] [0,1]\n- [0,1,0,0] [1]",
            "Input: nums = [0,1,0]\nOutput: 1\nExplanation: There is 1 way to split nums into good subarrays:\n- [0,1,0]"
        ],
        "constraints": "1 <= nums.length <= 105\n0 <= nums[i] <= 1",
        "release_time": 1687758678,
        "oracle_code": "class Solution {\n    public int numberOfGoodSubarraySplits(int[] nums) {\n        \n       List<Integer> list = new ArrayList<>();\n        for(int i=0;i<nums.length;i++){\n            if(nums[i]==1) list.add(i);\n        }\n        if(list.size()==0) return 0;\n        if(list.size()==1) return 1;\n        int mod =(int)1e9+7;\n        long res = 1;\n        for(int i=0;i<list.size()-1;i++){\n                long index1 = (long)list.get(i);\n                long index2 = (long)list.get(i+1);\n                res =  ( res%mod * (index2-index1)%mod)%mod;\n                \n            \n        }\n        return (int)res;\n         \n        \n       \n        \n    }\n}",
        "content": "```\\nclass Solution {\\n    public int numberOfGoodSubarraySplits(int[] nums) {\\n        \\n       List<Integer> list = new ArrayList<>();\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==1) list.add(i);\\n        }\\n        if(list.size()==0) return 0;\\n        if(list.size()==1) return 1;\\n        int mod =(int)1e9+7;\\n        long res = 1;\\n        for(int i=0;i<list.size()-1;i++){\\n                long index1 = (long)list.get(i);\\n                long index2 = (long)list.get(i+1);\\n                res =  ( res%mod * (index2-index1)%mod)%mod;\\n                \\n            \\n        }\\n        return (int)res;\\n         \\n        \\n       \\n        \\n    }\\n}",
        "level": "medium",
        "buggy_code": "\nclass Solution {\n    public int numberOfGoodSubarraySplits(int[] nums) {\n        \n       List<Integer> list = new ArrayList<>();\n        for(int i=0;i<nums.length;i++){\n            if(nums[i]==1) list.add(i);\n        }\n        if(list.size()==0) return 0;\n        if(list.size()==1) return 1;\n        int mod =(int)1e9+7;\n        long res = 0;\n        for(int i=0;i<list.size()-1;i++){\n                long index1 = (long)list.get(i);\n                long index2 = (long)list.get(i+1);\n                res =  ( res%mod * (index2-index1)%mod)%mod;\n                \n            \n        }\n        return (int)res;\n    }\n}\n",
        "explanations": "\nThe variable 'res' is initialized to 0, this would make the result always 0.\n"
    },
    {
        "slug": "trapping-rain-water",
        "description": "Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.",
        "examples": [
            "Input: height = [0,1,0,2,1,0,1,3,2,1,2,1]\nOutput: 6\nExplanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.",
            "Input: height = [4,2,0,3,2,5]\nOutput: 9"
        ],
        "constraints": "n == height.length\n1 <= n <= 2 * 104\n0 <= height[i] <= 105",
        "release_time": 1683960844,
        "oracle_code": "class Solution \n{\n    public int trap(int[] height) \n    {\n        int result = 0;\n        if(height==null || height.length<=2)\n            return result;\n        int left[] = new int[height.length];\n        int right[]= new int[height.length];\n        //scan from left to right\n        int max = height[0];\n        left[0] = height[0];\n        for(int i=1; i<height.length; i++)\n        {\n            if(height[i]<max)\n            {\n                left[i]=max;\n            }\n            else\n            {\n                left[i]=height[i];\n                max = height[i];\n            }\n        }\n        //scan from right to left\n        max = height[height.length-1];\n        right[height.length-1]=height[height.length-1];\n        for(int i=height.length-2; i>=0; i--)\n        {\n            if(height[i]<max)\n            {\n                right[i]=max;  \n            }\n            else\n            {  \n                right[i]=height[i];\n                max = height[i];\n            }\n        }\n    \n        for(int i=0; i<height.length; i++)\n        {\n            result+= Math.min(left[i],right[i])-height[i];\n        }\n        return result;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo calculate the trapped rainwater, we need to determine the effective height at each bar. The effective height at a specific bar is the minimum of the maximum heights on its left and right sides. The trapped rainwater can be calculated as the difference between the effective height and the actual height of each bar.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Check if the height array is null or has fewer than 2 elements. If so, return 0 since there are not enough bars to trap any rainwater.\\n2. Initialize a variable result to keep track of the total trapped rainwater.\\n3. Create two arrays, left and right, each with the same length as the height array. These arrays will store the maximum heights on the left and right sides of each bar, respectively.\\n4. Scan the height array from left to right:\\n- Initialize a variable max to store the maximum height encountered so far, starting with the height of the first bar.\\n- For each bar at index i, compare its height with the current max:\\n1. If the height of the current bar is less than the current max, set left[i] to max, indicating that the maximum height on the left side is still max.\\n1. Otherwise, update left[i] and max to the height of the current bar since it becomes the new maximum height encountered so far.\\n5. Scan the height array from right to left (similar to step 4) to populate the right array with the maximum heights on the right side of each bar.\\n6. Iterate over the height array:\\n- For each bar at index i, calculate the trapped rainwater by subtracting the actual height (height[i]) from the minimum of the maximum heights on the left and right sides (Math.min(left[i], right[i])).\\n- Add the calculated trapped rainwater to the result variable.\\n7. Return the final result which represents the total trapped rainwater.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the code is O(n), where n is the length of the height array. The code performs three separate scans over the height array, each taking linear time. Hence, the overall time complexity is linear.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the code is O(n), where n is the length of the height array. This is due to the additional arrays left and right that store the maximum heights on the left and right sides of each bar, respectively. The space required is proportional to the size of the input array.\\n\\n# Code\\n```\\nclass Solution \\n{\\n    public int trap(int[] height) \\n    {\\n        int result = 0;\\n        if(height==null || height.length<=2)\\n            return result;\\n        int left[] = new int[height.length];\\n        int right[]= new int[height.length];\\n        //scan from left to right\\n        int max = height[0];\\n        left[0] = height[0];\\n        for(int i=1; i<height.length; i++)\\n        {\\n            if(height[i]<max)\\n            {\\n                left[i]=max;\\n            }\\n            else\\n            {\\n                left[i]=height[i];\\n                max = height[i];\\n            }\\n        }\\n        //scan from right to left\\n        max = height[height.length-1];\\n        right[height.length-1]=height[height.length-1];\\n        for(int i=height.length-2; i>=0; i--)\\n        {\\n            if(height[i]<max)\\n            {\\n                right[i]=max;  \\n            }\\n            else\\n            {  \\n                right[i]=height[i];\\n                max = height[i];\\n            }\\n        }\\n    \\n        for(int i=0; i<height.length; i++)\\n        {\\n            result+= Math.min(left[i],right[i])-height[i];\\n        }\\n        return result;\\n    }\\n}\\n```",
        "level": "hard",
        "buggy_code": "\nclass Solution \n{\n    public int trap(int[] height) \n    {\n        int result = 0;\n        if(height==null || height.length<=2)\n            return result;\n        int left[] = new int[height.length];\n        int right[]= new int[height.length];\n        //scan from left to right\n        int max = height[0];\n        left[0] = height[0];\n        for(int i=1; i<height.length; i++)\n        {\n            if(height[i]<max)\n            {\n                left[i]=height[i];\n            }\n            else\n            {\n                left[i]=height[i];\n                max = height[i];\n            }\n        }\n        //scan from right to left\n        max = height[height.length-1];\n        right[height.length-1]=height[height.length-1];\n        for(int i=height.length-2; i>=0; i--)\n        {\n            if(height[i]<max)\n            {\n                right[i]=max;  \n            }\n            else\n            {  \n                right[i]=height[i];\n                max = height[i];\n            }\n        }\n    \n        for(int i=0; i<height.length; i++)\n        {\n            result+= Math.min(left[i],right[i])-height[i];\n        }\n        return result;\n    }\n}\n",
        "explanations": "\nIn the left scan loop, \"left[i]=height[i]\" should be \"left[i]=max\" to reflect the maximum height.\n"
    },
    {
        "slug": "move-zeroes",
        "description": "Given an integer array nums, move all 0's to the end of it while maintaining the relative order of the non-zero elements.\nNote that you must do this in-place without making a copy of the array.",
        "examples": [
            "Input: nums = [0,1,0,3,12]\nOutput: [1,3,12,0,0]",
            "Input: nums = [0]\nOutput: [0]"
        ],
        "constraints": "1 <= nums.length <= 104\n-231 <= nums[i] <= 231 - 1",
        "release_time": 1684064317,
        "oracle_code": "class Solution {\n    public void moveZeroes(int[] nums) {\n        int m=-1;\n        for(int i=0; i<nums.length; i++)\n        {\n            if(nums[i]==0)\n            {\n                if(m==-1 || nums[m]!=0)\n                {\n                    m=i;\n                }\n            }\n            else\n            {\n                if(m!=-1)\n                {\n                    int temp = nums[i];\n                    nums[i]=nums[m];\n                    nums[m]=temp;\n                    m++;\n                }\n            }\n        }\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe goal of this solution is to move all the zeroes in the input array nums to the end of the array while maintaining the relative order of the non-zero elements\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize a variable m to -1, which will keep track of the position of the first zero encountered.\\n2. Traverse the array nums from left to right: a. If the current element is zero, and m is -1 or the element at position m is non-zero, set m to the current index. b. If the current element is non-zero and m is not -1, swap the current element with the element at position m and increment m.\\n3. After the traversal, all the zeroes will be at the end of the array, and the relative order of the non-zero elements will be maintained.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n O(n), where n is the length of the input array nums. The algorithm iterates through the array once\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1), as the algorithm only uses a constant amount of extra space to store the variable m and the temporary variable temp used for swapping elements.\\n\\n# Code\\n```\\nclass Solution {\\n    public void moveZeroes(int[] nums) {\\n        int m=-1;\\n        for(int i=0; i<nums.length; i++)\\n        {\\n            if(nums[i]==0)\\n            {\\n                if(m==-1 || nums[m]!=0)\\n                {\\n                    m=i;\\n                }\\n            }\\n            else\\n            {\\n                if(m!=-1)\\n                {\\n                    int temp = nums[i];\\n                    nums[i]=nums[m];\\n                    nums[m]=temp;\\n                    m++;\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\n    public void moveZeroes(int[] nums) {\n        int m=-1;\n        for(int i=0; i<nums.length; i++)\n        {\n            if(nums[i]==0)\n            {\n                if(m==-1 || nums[m]!=0)\n                {\n                    m=i;\n                }\n            }\n            else\n            {\n                if(m!=-1)\n                {\n                    int temp = nums[m];\n                    nums[i]=nums[m];\n                    nums[m]=temp;\n                    m++;\n                }\n            }\n        }\n    }\n}\n",
        "explanations": "\nIn the swap operation, \"nums[i]\" is incorrectly assigned \"nums[m]\"; it should be \"temp\".\n"
    },
    {
        "slug": "largest-element-in-an-array-after-merge-operations",
        "description": "You are given a 0-indexed array nums consisting of positive integers.\nYou can do the following operation on the array any number of times:\n\nChoose an integer i such that 0 <= i < nums.length - 1 and nums[i] <= nums[i + 1]. Replace the element nums[i + 1] with nums[i] + nums[i + 1] and delete the element nums[i] from the array.\n\nReturn the value of the largest element that you can possibly obtain in the final array.",
        "examples": [
            "Input: nums = [2,3,7,9,3]\nOutput: 21\nExplanation: We can apply the following operations on the array:\n- Choose i = 0. The resulting array will be nums = [5,7,9,3].\n- Choose i = 1. The resulting array will be nums = [5,16,3].\n- Choose i = 0. The resulting array will be nums = [21,3].\nThe largest element in the final array is 21. It can be shown that we cannot obtain a larger element.",
            "Input: nums = [5,3,3]\nOutput: 11\nExplanation: We can do the following operations on the array:\n- Choose i = 1. The resulting array will be nums = [5,6].\n- Choose i = 0. The resulting array will be nums = [11].\nThere is only one element in the final array, which is 11."
        ],
        "constraints": "1 <= nums.length <= 105\n1 <= nums[i] <= 106",
        "release_time": 1690084837,
        "oracle_code": "class Solution {\n    public long maxArrayValue(int[] nums) {\n        if(nums.length==1)\n        {\n            return (long)nums[0];\n        }\n        if(nums.length==2)\n        {\n            return nums[0] <= nums[1] ? (long)(nums[0]+nums[1]) : (long)(Math.max(nums[0],nums[1]));\n        }\n        int size=nums.length;\n        long ans=0,dat=(long)nums[size-1];\n        for(int i=size-2;i>=0;i--)\n        {\n            long val=(long)nums[i];\n            if(val<=dat)\n            {\n                dat=dat+val;\n                if(dat>ans)\n                {\n                    ans=dat;\n                }\n            }\n            else\n            {\n                if(dat>ans)\n                {\n                    ans=dat;\n                }\n                dat=val;\n            }\n        }\n        return dat;\n    }\n}",
        "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public long maxArrayValue(int[] nums) {\\n        if(nums.length==1)\\n        {\\n            return (long)nums[0];\\n        }\\n        if(nums.length==2)\\n        {\\n            return nums[0] <= nums[1] ? (long)(nums[0]+nums[1]) : (long)(Math.max(nums[0],nums[1]));\\n        }\\n        int size=nums.length;\\n        long ans=0,dat=(long)nums[size-1];\\n        for(int i=size-2;i>=0;i--)\\n        {\\n            long val=(long)nums[i];\\n            if(val<=dat)\\n            {\\n                dat=dat+val;\\n                if(dat>ans)\\n                {\\n                    ans=dat;\\n                }\\n            }\\n            else\\n            {\\n                if(dat>ans)\\n                {\\n                    ans=dat;\\n                }\\n                dat=val;\\n            }\\n        }\\n        return dat;\\n    }\\n}\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\n    public long maxArrayValue(int[] nums) {\n        if(nums.length==1)\n        {\n            return (long)nums[0];\n        }\n        if(nums.length==2)\n        {\n            return nums[0] <= nums[1] ? (long)(nums[0]+nums[1]) : (long)(Math.max(nums[0],nums[1]));\n        }\n        int size=nums.length;\n        long ans=0,dat=(long)nums[size-1];\n        for(int i=size-2;i>=0;i--)\n        {\n            long val=(long)nums[i];\n            if(val<=dat)\n            {\n                dat=dat+val;\n                if(dat>ans)\n                {\n                    ans=dat;\n                }\n            }\n            else\n            {\n                if(dat>ans)\n                {\n                    ans=dat;\n                }\n                dat=val;\n            }\n        }\n        return ans;\n    }\n}\n",
        "explanations": "\nThe function should return 'dat' but it is returning 'ans' instead, leading to inaccurate results.\n"
    },
    {
        "slug": "robot-return-to-origin",
        "description": "There is a robot starting at the position (0, 0), the origin, on a 2D plane. Given a sequence of its moves, judge if this robot ends up at (0, 0) after it completes its moves.\nYou are given a string moves that represents the move sequence of the robot where moves[i] represents its ith move. Valid moves are 'R' (right), 'L' (left), 'U' (up), and 'D' (down).\nReturn true if the robot returns to the origin after it finishes all of its moves, or false otherwise.\nNote: The way that the robot is \"facing\" is irrelevant. 'R' will always make the robot move to the right once, 'L' will always make it move left, etc. Also, assume that the magnitude of the robot's movement is the same for each move.",
        "examples": [
            "Input: moves = \"UD\"\nOutput: true\nExplanation: The robot moves up once, and then down once. All moves have the same magnitude, so it ended up at the origin where it started. Therefore, we return true.",
            "Input: moves = \"LL\"\nOutput: false\nExplanation: The robot moves left twice. It ends up two \"moves\" to the left of the origin. We return false because it is not at the origin at the end of its moves."
        ],
        "constraints": "1 <= moves.length <= 2 * 104\nmoves only contains the characters 'U', 'D', 'L' and 'R'.",
        "release_time": 1684399544,
        "oracle_code": "class Solution {\n    public boolean judgeCircle(String moves) {\n        int point[] = {0,0};\n        int move[][] = new int[][]{{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n        for (Character m: moves.toCharArray()) {\n            int ind = 0;\n            switch (m)\n            {\n                case 'U': {\n                    ind = 0;\n                    break;\n                }\n                case 'D': {\n                    ind = 1;\n                    break;\n                }\n                case 'L': {\n                    ind = 2;\n                    break;\n                }\n                case 'R': {\n                    ind = 3;\n                    break;\n                }\n            }\n            point[0] += move[ind][0];\n            point[1] += move[ind][1];\n        }\n        return point[0] == 0 && point[1] == 0;\n    }\n}",
        "content": "\\n```\\nclass Solution {\\n    public boolean judgeCircle(String moves) {\\n        int point[] = {0,0};\\n        int move[][] = new int[][]{{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n        for (Character m: moves.toCharArray()) {\\n            int ind = 0;\\n            switch (m)\\n            {\\n                case \\'U\\': {\\n                    ind = 0;\\n                    break;\\n                }\\n                case \\'D\\': {\\n                    ind = 1;\\n                    break;\\n                }\\n                case \\'L\\': {\\n                    ind = 2;\\n                    break;\\n                }\\n                case \\'R\\': {\\n                    ind = 3;\\n                    break;\\n                }\\n            }\\n            point[0] += move[ind][0];\\n            point[1] += move[ind][1];\\n        }\\n        return point[0] == 0 && point[1] == 0;\\n    }\\n}\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\n    public boolean judgeCircle(String moves) {\n        int point[] = {0,0};\n        int move[][] = new int[][]{{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n        for (Character m: moves.toCharArray()) {\n            int ind = 0;\n            switch (m)\n            {\n                case 'U': {\n                    ind = 0;\n                    break;\n                }\n                case 'D': {\n                    ind = 1;\n                    break;\n                }\n                case 'L': {\n                    ind = 2;\n                    break;\n                }\n                case 'R': {\n                    ind = 4;\n                    break;\n                }\n            }\n            point[0] += move[ind][0];\n            point[1] += move[ind][1];\n        }\n        return point[0] == 0 && point[1] == 0;\n    }\n}\n",
        "explanations": "\nThe bug is that we are trying to access move[4], which doesn't exist.\n"
    },
    {
        "slug": "random-point-in-non-overlapping-rectangles",
        "description": "You are given an array of non-overlapping axis-aligned rectangles rects where rects[i] = [ai, bi, xi, yi] indicates that (ai, bi) is the bottom-left corner point of the ith rectangle and (xi, yi) is the top-right corner point of the ith rectangle. Design an algorithm to pick a random integer point inside the space covered by one of the given rectangles. A point on the perimeter of a rectangle is included in the space covered by the rectangle.\nAny integer point inside the space covered by one of the given rectangles should be equally likely to be returned.\nNote that an integer point is a point that has integer coordinates.\nImplement the Solution class:\n\nSolution(int[][] rects) Initializes the object with the given rectangles rects.\nint[] pick() Returns a random integer point [u, v] inside the space covered by one of the given rectangles.",
        "examples": [
            "Input\n[\"Solution\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\"]\n[[[[-2, -2, 1, 1], [2, 2, 4, 6]]], [], [], [], [], []]\nOutput\n[null, [1, -2], [1, -1], [-1, -2], [-2, -2], [0, 0]]\n\nExplanation\nSolution solution = new Solution([[-2, -2, 1, 1], [2, 2, 4, 6]]);\nsolution.pick(); // return [1, -2]\nsolution.pick(); // return [1, -1]\nsolution.pick(); // return [-1, -2]\nsolution.pick(); // return [-2, -2]\nsolution.pick(); // return [0, 0]"
        ],
        "constraints": "1 <= rects.length <= 100\nrects[i].length == 4\n-109 <= ai < xi <= 109\n-109 <= bi < yi <= 109\nxi - ai <= 2000\nyi - bi <= 2000\nAll the rectangles do not overlap.\nAt most 104 calls will be made to pick.",
        "release_time": 1683885250,
        "oracle_code": "class Solution {\n    \n    int[][] rects;\n    TreeMap<Integer, Integer> weightedRectIndex = new TreeMap<>();\n    int nPoints = 0;\n    \n    Random rng = new Random();\n\n    public Solution(int[][] rects) {\n        this.rects = rects;\n        int index = 0;\n        for (int[] rect : rects) {\n\t\t    // inserts cumulative weight key pointing to rectangle index\n            weightedRectIndex.put(nPoints, index++);\n            nPoints += width(rect) * height(rect);\n        }\n    }\n    \n    public int[] pick() {\n\t    // generates random point within total weight\n        int point = rng.nextInt(nPoints);\n\t\t// finds appropriate rectangle\n        var entry = weightedRectIndex.floorEntry(point);\n\t\t// find point within the current rectangle\n        int rectPoint = point - entry.getKey();\n        int[] rect = rects[entry.getValue()];\n        return new int[]{\n            rect[0] + rectPoint % width(rect), \n            rect[1] + rectPoint / width(rect)};\n    }\n    \n    private int width(int[] rect) {\n        return rect[2] - rect[0] + 1;\n    }\n    \n    private int height(int[] rect) {\n        return rect[3] - rect[1] + 1;\n    }\n}",
        "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    \\n    int[][] rects;\\n    TreeMap<Integer, Integer> weightedRectIndex = new TreeMap<>();\\n    int nPoints = 0;\\n    \\n    Random rng = new Random();\\n\\n    public Solution(int[][] rects) {\\n        this.rects = rects;\\n        int index = 0;\\n        for (int[] rect : rects) {\\n\\t\\t    // inserts cumulative weight key pointing to rectangle index\\n            weightedRectIndex.put(nPoints, index++);\\n            nPoints += width(rect) * height(rect);\\n        }\\n    }\\n    \\n    public int[] pick() {\\n\\t    // generates random point within total weight\\n        int point = rng.nextInt(nPoints);\\n\\t\\t// finds appropriate rectangle\\n        var entry = weightedRectIndex.floorEntry(point);\\n\\t\\t// find point within the current rectangle\\n        int rectPoint = point - entry.getKey();\\n        int[] rect = rects[entry.getValue()];\\n        return new int[]{\\n            rect[0] + rectPoint % width(rect), \\n            rect[1] + rectPoint / width(rect)};\\n    }\\n    \\n    private int width(int[] rect) {\\n        return rect[2] - rect[0] + 1;\\n    }\\n    \\n    private int height(int[] rect) {\\n        return rect[3] - rect[1] + 1;\\n    }\\n}\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\n    \n    int[][] rects;\n    TreeMap<Integer, Integer> weightedRectIndex = new TreeMap<>();\n    int nPoints = 0;\n    \n    Random rng = new Random();\n\n    public Solution(int[][] rects) {\n        this.rects = rects;\n        int index = 0;\n        for (int[] rect : rects) {\n            \n            weightedRectIndex.put(nPoints++, index);\n            nPoints += width(rect) * height(rect);\n        }\n    }\n\n    public int[] pick() {\n        \n        int point = rng.nextInt(nPoints);\n        \n        var entry = weightedRectIndex.floorEntry(point);\n        \n        int rectPoint = point - entry.getKey();\n        int[] rect = rects[entry.getValue()];\n        return new int[]{\n            rect[0] + rectPoint % width(rect), \n            rect[1] + rectPoint / width(rect)};\n    }\n\n    private int width(int[] rect) {\n        return rect[2] - rect[0] + 1;\n    }\n\n    private int height(int[] rect) {\n        return rect[3] - rect[1] + 1;\n    }\n}\n",
        "explanations": "\nThe line \"weightedRectIndex.put(nPoints++, index);\" will increment \"nPoints\" before calculation which will produce incorrect behavior.\n"
    },
    {
        "slug": "daily-temperatures",
        "description": "Given an array of integers temperatures represents the daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after the ith day to get a warmer temperature. If there is no future day for which this is possible, keep answer[i] == 0 instead.",
        "examples": [
            "Input: temperatures = [73,74,75,71,69,72,76,73]\nOutput: [1,1,4,2,1,1,0,0]",
            "Input: temperatures = [30,40,50,60]\nOutput: [1,1,1,0]",
            "Input: temperatures = [30,60,90]\nOutput: [1,1,0]"
        ],
        "constraints": "1 <=\u00a0temperatures.length <= 105\n30 <=\u00a0temperatures[i] <= 100",
        "release_time": 1667472111,
        "oracle_code": "class Solution {\n    public int[] dailyTemperatures(int[] temperatures) {\n        \n        int[] arr = new int[temperatures.length]; \n        \n        ArrayDeque<int[]> st = new ArrayDeque<>(); \n        \n        int i=0, j=temperatures.length-1 ; \n        \n        while( j >= 0){\n            \n            if(st.size()==0){\n                arr[i++] = 0;\n            }\n            else  if (st.size()>0 && st.peek()[0]>temperatures[j])\n            {\n                arr[i++]=1;\n            } \n            else if (st.size()>0 && st.peek()[0]<=temperatures[j])\n            \n            {  while(st.size()>0 && st.peek()[0]<=temperatures[j]){\n                    st.pop();\n                    \n                }\n            if(st.size()==0){\n                arr[i++]=0;\n            }\n            else{\n                arr[i++]=st.peek()[1]-j;\n            }\n            } \n        st.push(new int[]{temperatures[j],j}); \n        j--;\n        }\n        \n      \n        int[] ans = new int[temperatures.length]; int k=0;\n        for(i=arr.length-1; i>=0; i--){\n            ans[k++]=arr[i];\n        }\n        return ans;\n    }\n}",
        "content": "```\\nclass Solution {\\n    public int[] dailyTemperatures(int[] temperatures) {\\n        \\n        int[] arr = new int[temperatures.length]; \\n        \\n        ArrayDeque<int[]> st = new ArrayDeque<>(); \\n        \\n        int i=0, j=temperatures.length-1 ; \\n        \\n        while( j >= 0){\\n            \\n            if(st.size()==0){\\n                arr[i++] = 0;\\n            }\\n            else  if (st.size()>0 && st.peek()[0]>temperatures[j])\\n            {\\n                arr[i++]=1;\\n            } \\n            else if (st.size()>0 && st.peek()[0]<=temperatures[j])\\n            \\n            {  while(st.size()>0 && st.peek()[0]<=temperatures[j]){\\n                    st.pop();\\n                    \\n                }\\n            if(st.size()==0){\\n                arr[i++]=0;\\n            }\\n            else{\\n                arr[i++]=st.peek()[1]-j;\\n            }\\n            } \\n        st.push(new int[]{temperatures[j],j}); \\n        j--;\\n        }\\n        \\n      \\n        int[] ans = new int[temperatures.length]; int k=0;\\n        for(i=arr.length-1; i>=0; i--){\\n            ans[k++]=arr[i];\\n        }\\n        return ans;\\n    }\\n}",
        "level": "medium",
        "buggy_code": "\nclass Solution {\n    public int[] dailyTemperatures(int[] temperatures) {\n        \n        int[] arr = new int[temperatures.length]; \n        \n        ArrayDeque<int[]> st = new ArrayDeque<>(); \n        \n        int i=0, j=temperatures.length ; \n        \n        while( j >= 0){\n            \n            if(st.size()==0){\n                arr[i++] = 0;\n            }\n            else  if (st.size()>0 && st.peek()[0]>temperatures[j])\n            {\n                arr[i++]=1;\n            } \n            else if (st.size()>0 && st.peek()[0]<=temperatures[j])\n            \n            {  while(st.size()>0 && st.peek()[0]<=temperatures[j]){\n                    st.pop();\n                    \n                }\n            if(st.size()==0){\n                arr[i++]=0;\n            }\n            else{\n                arr[i++]=st.peek()[1]-j;\n            }\n            } \n        st.push(new int[]{temperatures[j],j}); \n        j--;\n        }\n        \n      \n        int[] ans = new int[temperatures.length]; int k=0;\n        for(i=arr.length-1; i>=0; i--){\n            ans[k++]=arr[i];\n        }\n        return ans;\n    }\n}\n",
        "explanations": "\nThe initial value for variable 'j' is out of array bounds, causing ArrayIndexOutOfBoundsException.\n"
    },
    {
        "slug": "number-of-laser-beams-in-a-bank",
        "description": "Anti-theft security devices are activated inside a bank. You are given a 0-indexed binary string array bank representing the floor plan of the bank, which is an m x n 2D matrix. bank[i] represents the ith row, consisting of '0's and '1's. '0' means the cell is empty, while'1' means the cell has a security device.\nThere is one laser beam between any two security devices if both conditions are met:\n\nThe two devices are located on two different rows: r1 and r2, where r1 < r2.\nFor each row i where r1 < i < r2, there are no security devices in the ith row.\n\nLaser beams are independent, i.e., one beam does not interfere nor join with another.\nReturn the total number of laser beams in the bank.",
        "examples": [
            "Input: bank = [\"011001\",\"000000\",\"010100\",\"001000\"]\nOutput: 8\nExplanation: Between each of the following device pairs, there is one beam. In total, there are 8 beams:\n * bank[0][1] -- bank[2][1]\n * bank[0][1] -- bank[2][3]\n * bank[0][2] -- bank[2][1]\n * bank[0][2] -- bank[2][3]\n * bank[0][5] -- bank[2][1]\n * bank[0][5] -- bank[2][3]\n * bank[2][1] -- bank[3][2]\n * bank[2][3] -- bank[3][2]\nNote that there is no beam between any device on the 0th row with any on the 3rd row.\nThis is because the 2nd row contains security devices, which breaks the second condition.",
            "Input: bank = [\"000\",\"111\",\"000\"]\nOutput: 0\nExplanation: There does not exist two devices located on two different rows."
        ],
        "constraints": "m == bank.length\nn == bank[i].length\n1 <= m, n <= 500\nbank[i][j] is either '0' or '1'.",
        "release_time": 1671532567,
        "oracle_code": "class Solution {\n    public int numberOfBeams(String[] bank) {\n        int prevLazer =0;\n        int ans =0;\n        for(String s:bank){\n            int curLazer = 0;\n            for(char c: s.toCharArray()){\n                if(c=='1'){\n                    curLazer++;\n                }\n            }\n            if(curLazer >0){\n                ans += (curLazer * prevLazer);\n                prevLazer = curLazer;\n            }\n        }\n        return ans;\n    }\n}",
        "content": "\\n# java Code\\n```\\nclass Solution {\\n    public int numberOfBeams(String[] bank) {\\n        int prevLazer =0;\\n        int ans =0;\\n        for(String s:bank){\\n            int curLazer = 0;\\n            for(char c: s.toCharArray()){\\n                if(c==\\'1\\'){\\n                    curLazer++;\\n                }\\n            }\\n            if(curLazer >0){\\n                ans += (curLazer * prevLazer);\\n                prevLazer = curLazer;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\n    public int numberOfBeams(String[] bank) {\n        int prevLazer =0;\n        int ans =0;\n        for(String s:bank){\n            int curLazer = 0;\n            for(char c: s.toCharArray()){\n                if(c=='1'){\n                    curLazer++;\n                }\n            }\n            if(curLazer >0){\n                ans += (curLazer * prevLazer);\n                prevLazer = curLazer;\n            } else {\n                prevLazer = 0;\n            }\n        }\n        return ans;\n    }\n}\n",
        "explanations": "\nThe bug resets prevLazer to 0 when no '1' is found, reducing total beam count.\n"
    },
    {
        "slug": "maximum-strength-of-a-group",
        "description": "You are given a 0-indexed integer array nums representing the score of students in an exam. The teacher would like to form one non-empty group of students with maximal strength, where the strength of a group of students of indices i0, i1, i2, ... , ik is defined as nums[i0] * nums[i1] * nums[i2] * ... * nums[ik\u200b].\nReturn the maximum strength of a group the teacher can create.",
        "examples": [
            "Input: nums = [3,-1,-5,2,5,-9]\nOutput: 1350\nExplanation: One way to form a group of maximal strength is to group the students at indices [0,2,3,4,5]. Their strength is 3 * (-5) * 2 * 5 * (-9) = 1350, which we can show is optimal.",
            "Input: nums = [-4,-5,-4]\nOutput: 20\nExplanation: Group the students at indices [0, 1] . Then, we\u2019ll have a resulting strength of 20. We cannot achieve greater strength."
        ],
        "constraints": "1 <= nums.length <= 13\n-9 <= nums[i] <= 9",
        "release_time": 1685203355,
        "oracle_code": "class Solution {\n    private long maxStrength;\n\n    public long maxStrength(int[] nums) {\n        maxStrength = Integer.MIN_VALUE;\n        helper(nums, 0, 1, 0);\n        return maxStrength;\n    }\n\n    private void helper(int[] nums, int index, long product, int size) {\n        if (index >= nums.length) {\n            if(size != 0) maxStrength = Math.max(maxStrength, product);\n            return;\n        }\n\n        helper(nums, index + 1, product * nums[index], size + 1);\n        helper(nums, index + 1, product, size);\n    }\n}",
        "content": "# Code\\n```\\nclass Solution {\\n    private long maxStrength;\\n\\n    public long maxStrength(int[] nums) {\\n        maxStrength = Integer.MIN_VALUE;\\n        helper(nums, 0, 1, 0);\\n        return maxStrength;\\n    }\\n\\n    private void helper(int[] nums, int index, long product, int size) {\\n        if (index >= nums.length) {\\n            if(size != 0) maxStrength = Math.max(maxStrength, product);\\n            return;\\n        }\\n\\n        helper(nums, index + 1, product * nums[index], size + 1);\\n        helper(nums, index + 1, product, size);\\n    }\\n}\\n\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\n    private long maxStrength;\n\n    public long maxStrength(int[] nums) {\n        maxStrength = 0; \n        helper(nums, 0, 1, 0);\n        return maxStrength;\n    }\n\n    private void helper(int[] nums, int index, long product, int size) {\n        if (index >= nums.length) {\n            if(size != 0) maxStrength = Math.max(maxStrength, product);\n            return;\n        }\n\n        helper(nums, index + 1, product * nums[index], size + 1);\n        helper(nums, index + 1, product, size);\n    }\n}\n",
        "explanations": "\nSetting maxStrength to 0 instead of Integer.MIN_VALUE can cause issues with negative numbers. \n"
    },
    {
        "slug": "spiral-matrix-iv",
        "description": "You are given two integers m and n, which represent the dimensions of a matrix.\nYou are also given the head of a linked list of integers.\nGenerate an m x n matrix that contains the integers in the linked list presented in spiral order (clockwise), starting from the top-left of the matrix. If there are remaining empty spaces, fill them with -1.\nReturn the generated matrix.",
        "examples": [
            "Input: m = 3, n = 5, head = [3,0,2,6,8,1,7,9,4,2,5,5,0]\nOutput: [[3,0,2,6,8],[5,0,-1,-1,1],[5,2,4,9,7]]\nExplanation: The diagram above shows how the values are printed in the matrix.\nNote that the remaining spaces in the matrix are filled with -1.",
            "Input: m = 1, n = 4, head = [0,1,2]\nOutput: [[0,1,2,-1]]\nExplanation: The diagram above shows how the values are printed from left to right in the matrix.\nThe last space in the matrix is set to -1."
        ],
        "constraints": "1 <= m, n <= 105\n1 <= m * n <= 105\nThe number of nodes in the list is in the range [1, m * n].\n0 <= Node.val <= 1000",
        "release_time": 1675959781,
        "oracle_code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:\n        mat=[[-1 for i in range(n)] for i in range(m)]\n        temp=head\n        d=1\n        rowi,colj=0,0\n        while temp!=None:\n            mat[rowi][colj]=temp.val\n            if d==1:\n                if colj+1<n and mat[rowi][colj+1]==-1:\n                    colj+=1\n                    d=1\n                elif rowi+1<m and mat[rowi+1][colj]==-1:\n                    rowi+=1\n                    d=2\n            elif d==2:\n                if rowi+1<m and mat[rowi+1][colj]==-1:\n                    rowi+=1\n                    d=2\n                elif colj-1>=0 and mat[rowi][colj-1]==-1:\n                    colj-=1\n                    d=3\n            elif d==3:\n                if colj-1>=0 and mat[rowi][colj-1]==-1:\n                    colj-=1\n                    d=3\n                elif rowi-1>=0 and mat[rowi-1][colj]==-1:\n                    rowi-=1\n                    d=4\n            elif d==4:\n                if rowi-1>=0 and mat[rowi-1][colj]==-1:\n                    rowi-=1\n                    d=4\n                elif colj+1<n and mat[rowi][colj+1]==-1:\n                    colj+=1\n                    d=1\n            temp=temp.next\n        return mat",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nfollow up direction : right -> down -> left -> up\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ncreating a matrix m*n fillup with -1 and traverse throgh list and make update directions according to current directions and values of before cells\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n     O(N) (no of Nodes in linkedlist)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(N+M)\\n\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:\\n        mat=[[-1 for i in range(n)] for i in range(m)]\\n        temp=head\\n        d=1\\n        rowi,colj=0,0\\n        while temp!=None:\\n            mat[rowi][colj]=temp.val\\n            if d==1:\\n                if colj+1<n and mat[rowi][colj+1]==-1:\\n                    colj+=1\\n                    d=1\\n                elif rowi+1<m and mat[rowi+1][colj]==-1:\\n                    rowi+=1\\n                    d=2\\n            elif d==2:\\n                if rowi+1<m and mat[rowi+1][colj]==-1:\\n                    rowi+=1\\n                    d=2\\n                elif colj-1>=0 and mat[rowi][colj-1]==-1:\\n                    colj-=1\\n                    d=3\\n            elif d==3:\\n                if colj-1>=0 and mat[rowi][colj-1]==-1:\\n                    colj-=1\\n                    d=3\\n                elif rowi-1>=0 and mat[rowi-1][colj]==-1:\\n                    rowi-=1\\n                    d=4\\n            elif d==4:\\n                if rowi-1>=0 and mat[rowi-1][colj]==-1:\\n                    rowi-=1\\n                    d=4\\n                elif colj+1<n and mat[rowi][colj+1]==-1:\\n                    colj+=1\\n                    d=1\\n            temp=temp.next\\n        return mat\\n\\n\\n```",
        "level": "medium",
        "buggy_code": "\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:\n        mat=[[-1 for i in range(n)] for i in range(m)]\n        temp=head\n        d=1\n        rowi,colj=0,0\n        while temp!=None:\n            mat[rowi][colj]=temp.val\n            if d==1:\n                if colj+1<n and mat[rowi][colj+1]==-1:\n                    colj+=1\n                    d=2 # Bug is here\n                elif rowi+1<m and mat[rowi+1][colj]==-1:\n                    rowi+=1\n                    d=2\n            elif d==2:\n                if rowi+1<m and mat[rowi+1][colj]==-1:\n                    rowi+=1\n                    d=2\n                elif colj-1>=0 and mat[rowi][colj-1]==-1:\n                    colj-=1\n                    d=3\n            elif d==3:\n                if colj-1>=0 and mat[rowi][colj-1]==-1:\n                    colj-=1\n                    d=3\n                elif rowi-1>=0 and mat[rowi-1][colj]==-1:\n                    rowi-=1\n                    d=4\n            elif d==4:\n                if rowi-1>=0 and mat[rowi-1][colj]==-1:\n                    rowi-=1\n                    d=4\n                elif colj+1<n and mat[rowi][colj+1]==-1:\n                    colj+=1\n                    d=1\n            temp=temp.next\n        return mat\n",
        "explanations": "\nThe bug lies at line 16. The direction 'd' changes erronously to 2 instead of staying 1.\n"
    },
    {
        "slug": "maximum-number-of-balloons",
        "description": "Given a string text, you want to use the characters of text to form as many instances of the word \"balloon\" as possible.\nYou can use each character in text at most once. Return the maximum number of instances that can be formed.",
        "examples": [
            "Input: text = \"nlaebolko\"\nOutput: 1",
            "Input: text = \"loonbalxballpoon\"\nOutput: 2",
            "Input: text = \"leetcode\"\nOutput: 0"
        ],
        "constraints": "1 <= text.length <= 104\ntext consists of lower case English letters only.",
        "release_time": 1688984016,
        "oracle_code": "class Solution {\n    public int maxNumberOfBalloons(String text) {\n        final int[][] cache = new int[2][5];\n        cache[0][0] = 97;  // a\n        cache[0][1] = 98;  // b\n        cache[0][2] = 108; // l\n        cache[0][3] = 110; // n\n        cache[0][4] = 111; // o\n        \n        // cacl letter frequencies\n        for (char ch : text.toCharArray()) {\n            final int intValue = ch;\n            for (int i = 0; i < 5; i++) {\n                if (intValue == cache[0][i]) {\n                    cache[1][i]++;\n                    break;\n                }\n            }\n        }\n\n        // l & o meet twice\n        cache[1][2] /= 2;\n        cache[1][4] /= 2;\n\n        // find the bottleneck\n        int min = Integer.MAX_VALUE;\n        for (int frequency: cache[1]) {\n            min = Math.min(min, frequency);\n        }\n\n        return min;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxNumberOfBalloons(String text) {\\n        final int[][] cache = new int[2][5];\\n        cache[0][0] = 97;  // a\\n        cache[0][1] = 98;  // b\\n        cache[0][2] = 108; // l\\n        cache[0][3] = 110; // n\\n        cache[0][4] = 111; // o\\n        \\n        // cacl letter frequencies\\n        for (char ch : text.toCharArray()) {\\n            final int intValue = ch;\\n            for (int i = 0; i < 5; i++) {\\n                if (intValue == cache[0][i]) {\\n                    cache[1][i]++;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        // l & o meet twice\\n        cache[1][2] /= 2;\\n        cache[1][4] /= 2;\\n\\n        // find the bottleneck\\n        int min = Integer.MAX_VALUE;\\n        for (int frequency: cache[1]) {\\n            min = Math.min(min, frequency);\\n        }\\n\\n        return min;\\n    }\\n}\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\n    public int maxNumberOfBalloons(String text) {\n        final int[][] cache = new int[2][5];\n        cache[0][0] = 97;  // a\n        cache[0][1] = 99;  \n        cache[0][2] = 108; // l\n        cache[0][3] = 110; // n\n        cache[0][4] = 111; // o\n        \n        // cacl letter frequencies\n        for (char ch : text.toCharArray()) {\n            final int intValue = ch;\n            for (int i = 0; i < 5; i++) {\n                if (intValue == cache[0][i]) {\n                    cache[1][i]++;\n                    break;\n                }\n            }\n        }\n\n        // l & o meet twice\n        cache[1][2] /= 2;\n        cache[1][4] /= 2;\n\n        // find the bottleneck\n        int min = Integer.MAX_VALUE;\n        for (int frequency: cache[1]) {\n            min = Math.min(min, frequency);\n        }\n\n        return min;\n    }\n}\n",
        "explanations": "\nMistakenly replaced 'b' (ASCII: 98) with 'c' (ASCII: 99) causing incorrect count of 'balloon'.\n"
    },
    {
        "slug": "convert-sorted-array-to-binary-search-tree",
        "description": "Given an integer array nums where the elements are sorted in ascending order, convert it to a height-balanced binary search tree.",
        "examples": [
            "Input: nums = [-10,-3,0,5,9]\nOutput: [0,-3,9,-10,null,5]\nExplanation: [0,-10,5,null,-3,null,9] is also accepted:",
            "Input: nums = [1,3]\nOutput: [3,1]\nExplanation: [1,null,3] and [3,1] are both height-balanced BSTs."
        ],
        "constraints": "1 <= nums.length <= 104\n-104 <= nums[i] <= 104\nnums is sorted in a strictly increasing order.",
        "release_time": 1689161763,
        "oracle_code": "class Solution {\n    public TreeNode createBST(int arr[], int st, int end){\n        if(st>end){\n            return null;\n        }\n\n        int mid = (st+end)/2;\n        TreeNode root = new TreeNode(arr[mid]);\n        root.left = createBST(arr,st,mid-1);\n        root.right = createBST(arr,mid+1,end);\n\n        return root;\n    }\n    public TreeNode sortedArrayToBST(int[] nums) {\n        int st = 0;\n        int end = nums.length-1;\n        return createBST(nums,st,end);\n        \n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nInorder Traversal of BST is always sorted.\\nInorder = left, root, right\\nroot = mid of sorted array\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n**Divide and Conquer and Inorder Traversal**\\n$$Inorder = left, root, right$$ which means root = mid of sorted Array\\nDivide the array into smaller pieces using recursion and assing root = mid \\n$$ mid = (start+end)/2;$$\\n\\n\\n\\n# Complexity\\n- Time complexity: O(n) \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\n    public TreeNode createBST(int arr[], int st, int end){\\n        if(st>end){\\n            return null;\\n        }\\n\\n        int mid = (st+end)/2;\\n        TreeNode root = new TreeNode(arr[mid]);\\n        root.left = createBST(arr,st,mid-1);\\n        root.right = createBST(arr,mid+1,end);\\n\\n        return root;\\n    }\\n    public TreeNode sortedArrayToBST(int[] nums) {\\n        int st = 0;\\n        int end = nums.length-1;\\n        return createBST(nums,st,end);\\n        \\n    }\\n}\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\n    public TreeNode createBST(int arr[], int st, int end){\n        if(st>end){\n            return null;\n        }\n\n        int mid = (st+end)/2+1;\n        TreeNode root = new TreeNode(arr[mid]);\n        root.left = createBST(arr,st,mid-1);\n        root.right = createBST(arr,mid+1,end);\n\n        return root;\n    }\n    public TreeNode sortedArrayToBST(int[] nums) {\n        int st = 0;\n        int end = nums.length-1;\n        return createBST(nums,st,end);\n    }\n}\n",
        "explanations": "\nThe mid index calculation is shifted, causing an ArrayIndexOutOfBoundsException for even-sized arrays.\n"
    },
    {
        "slug": "intersection-of-two-linked-lists",
        "description": "Given the heads of two singly linked-lists headA and headB, return the node at which the two lists intersect. If the two linked lists have no intersection at all, return null.\nFor example, the following two linked lists begin to intersect at node c1:\n\nThe test cases are generated such that there are no cycles anywhere in the entire linked structure.\nNote that the linked lists must retain their original structure after the function returns.\nCustom Judge:\nThe inputs to the judge are given as follows (your program is not given these inputs):\n\nintersectVal - The value of the node where the intersection occurs. This is 0 if there is no intersected node.\nlistA - The first linked list.\nlistB - The second linked list.\nskipA - The number of nodes to skip ahead in listA (starting from the head) to get to the intersected node.\nskipB - The number of nodes to skip ahead in listB (starting from the head) to get to the intersected node.\n\nThe judge will then create the linked structure based on these inputs and pass the two heads, headA and headB to your program. If you correctly return the intersected node, then your solution will be accepted.",
        "examples": [
            "Input: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3\nOutput: Intersected at '8'\nExplanation: The intersected node's value is 8 (note that this must not be 0 if the two lists intersect).\nFrom the head of A, it reads as [4,1,8,4,5]. From the head of B, it reads as [5,6,1,8,4,5]. There are 2 nodes before the intersected node in A; There are 3 nodes before the intersected node in B.\n- Note that the intersected node's value is not 1 because the nodes with value 1 in A and B (2nd node in A and 3rd node in B) are different node references. In other words, they point to two different locations in memory, while the nodes with value 8 in A and B (3rd node in A and 4th node in B) point to the same location in memory.",
            "Input: intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1\nOutput: Intersected at '2'\nExplanation: The intersected node's value is 2 (note that this must not be 0 if the two lists intersect).\nFrom the head of A, it reads as [1,9,1,2,4]. From the head of B, it reads as [3,2,4]. There are 3 nodes before the intersected node in A; There are 1 node before the intersected node in B.",
            "Input: intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2\nOutput: No intersection\nExplanation: From the head of A, it reads as [2,6,4]. From the head of B, it reads as [1,5]. Since the two lists do not intersect, intersectVal must be 0, while skipA and skipB can be arbitrary values.\nExplanation: The two lists do not intersect, so return null."
        ],
        "constraints": "The number of nodes of listA is in the m.\nThe number of nodes of listB is in the n.\n1 <= m, n <= 3 * 104\n1 <= Node.val <= 105\n0 <= skipA <\u00a0m\n0 <= skipB <\u00a0n\nintersectVal is 0 if listA and listB do not intersect.\nintersectVal == listA[skipA] == listB[skipB] if listA and listB intersect.",
        "release_time": 1688896252,
        "oracle_code": "public class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n\n        ListNode a = headA;\n        ListNode b = headB;\n\n        while(a!=b) {\n            a = a==null ? headB : a.next;\n            b = b==null ? headA : b.next;\n        }\n        return a;\n    }\n}",
        "content": "# Code\\n```\\npublic class Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n\\n        ListNode a = headA;\\n        ListNode b = headB;\\n\\n        while(a!=b) {\\n            a = a==null ? headB : a.next;\\n            b = b==null ? headA : b.next;\\n        }\\n        return a;\\n    }\\n}\\n```",
        "level": "easy",
        "buggy_code": "\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n\n        ListNode a = headA;\n        ListNode b = headB;\n\n        while(a != b) {\n            a = a==null ? headB : a.next;\n            b = b==null ? headA : a.next;\n        }\n        return a;\n    }\n}\n",
        "explanations": "\nThe bug is in second while loop condition, 'b' should be assigned to 'b.next' not 'a.next'.\n"
    },
    {
        "slug": "make-array-strictly-increasing",
        "description": "Given two integer arrays\u00a0arr1 and arr2, return the minimum number of operations (possibly zero) needed\u00a0to make arr1 strictly increasing.\nIn one operation, you can choose two indices\u00a00 <=\u00a0i < arr1.length\u00a0and\u00a00 <= j < arr2.length\u00a0and do the assignment\u00a0arr1[i] = arr2[j].\nIf there is no way to make\u00a0arr1\u00a0strictly increasing,\u00a0return\u00a0-1.",
        "examples": [
            "Input: arr1 = [1,5,3,6,7], arr2 = [1,3,2,4]\nOutput: 1\nExplanation: Replace 5 with 2, then arr1 = [1, 2, 3, 6, 7].",
            "Input: arr1 = [1,5,3,6,7], arr2 = [4,3,1]\nOutput: 2\nExplanation: Replace 5 with 3 and then replace 3 with 4. arr1 = [1, 3, 4, 6, 7].",
            "Input: arr1 = [1,5,3,6,7], arr2 = [1,6,3,3]\nOutput: -1\nExplanation: You can't make arr1 strictly increasing."
        ],
        "constraints": "1 <= arr1.length, arr2.length <= 2000\n0 <= arr1[i], arr2[i] <= 10^9",
        "release_time": 1686968098,
        "oracle_code": "class Solution {\n    \n    HashMap<Integer, Integer> dp[];\n    TreeSet<Integer> ts;\n    \n    int makeArrayIncr(int i, int prev, int[] arr1) {\n        \n        if(i == arr1.length) return 0;\n        \n        if(dp[i].containsKey(prev)) return dp[i].get(prev);\n        \n        int notswap = 5000;\n        \n        if(arr1[i] > prev) notswap = makeArrayIncr(i + 1, arr1[i], arr1);\n        \n        int swap = 5000;\n        \n        Integer curr = ts.higher(prev);\n        \n        if(curr != null) swap = 1 + makeArrayIncr(i + 1, curr, arr1);\n        \n        dp[i].put(prev, Math.min(swap, notswap));\n        \n        // System.out.println(i + \" \" + swap + \" \" + notswap);\n        \n        return Math.min(swap, notswap);\n        \n    }\n    \n    public int makeArrayIncreasing(int[] arr1, int[] arr2) {\n        \n        ts = new TreeSet<>();\n        for(int i : arr2) ts.add(i);\n        \n        dp = new HashMap[arr1.length];\n        for(int i = 0; i < dp.length; i++) dp[i] = new HashMap<>();\n        \n        int ans = makeArrayIncr(0, Integer.MIN_VALUE, arr1);\n        \n        return ans < 5000 ? ans : -1; \n    }\n}",
        "content": "```\\nclass Solution {\\n    \\n    HashMap<Integer, Integer> dp[];\\n    TreeSet<Integer> ts;\\n    \\n    int makeArrayIncr(int i, int prev, int[] arr1) {\\n        \\n        if(i == arr1.length) return 0;\\n        \\n        if(dp[i].containsKey(prev)) return dp[i].get(prev);\\n        \\n        int notswap = 5000;\\n        \\n        if(arr1[i] > prev) notswap = makeArrayIncr(i + 1, arr1[i], arr1);\\n        \\n        int swap = 5000;\\n        \\n        Integer curr = ts.higher(prev);\\n        \\n        if(curr != null) swap = 1 + makeArrayIncr(i + 1, curr, arr1);\\n        \\n        dp[i].put(prev, Math.min(swap, notswap));\\n        \\n        // System.out.println(i + \" \" + swap + \" \" + notswap);\\n        \\n        return Math.min(swap, notswap);\\n        \\n    }\\n    \\n    public int makeArrayIncreasing(int[] arr1, int[] arr2) {\\n        \\n        ts = new TreeSet<>();\\n        for(int i : arr2) ts.add(i);\\n        \\n        dp = new HashMap[arr1.length];\\n        for(int i = 0; i < dp.length; i++) dp[i] = new HashMap<>();\\n        \\n        int ans = makeArrayIncr(0, Integer.MIN_VALUE, arr1);\\n        \\n        return ans < 5000 ? ans : -1; \\n    }\\n}\\n```",
        "level": "hard",
        "buggy_code": "\nclass Solution {\n    \n    HashMap<Integer, Integer> dp[];\n    TreeSet<Integer> ts;\n    \n    int makeArrayIncr(int i, int prev, int[] arr1) {\n        \n        if(i == arr1.length) return 0;\n\n        if(dp[i].containsKey(prev)) return dp[i].get(prev);\n\n        int notswap = 5000;\n\n        if(arr1[i] > prev) notswap = makeArrayIncr(i + 1, arr1[i], arr1);\n\n        int swap = 5000;\n\n        Integer curr = ts.higher(prev);\n\n        if(curr != null) swap = 1 + makeArrayIncr(i, curr, arr1);\n\n        dp[i].put(prev, Math.min(swap, notswap));\n\n        return Math.min(swap, notswap);\n        \n    }\n    \n    public int makeArrayIncreasing(int[] arr1, int[] arr2) {\n        \n        ts = new TreeSet<>();\n        for(int i : arr2) ts.add(i);\n        \n        dp = new HashMap[arr1.length];\n        for(int i = 0; i < dp.length; i++) dp[i] = new HashMap<>();\n        \n        int ans = makeArrayIncr(0, Integer.MIN_VALUE, arr1);\n        \n        return ans < 5000 ? ans : -1; \n    }\n}\n",
        "explanations": "\nIn `makeArrayIncr` function, incrementing `i` in the recursive call for `swap` causes an infinite recursion.\n"
    },
    {
        "slug": "count-items-matching-a-rule",
        "description": "You are given an array items, where each items[i] = [typei, colori, namei] describes the type, color, and name of the ith item. You are also given a rule represented by two strings, ruleKey and ruleValue.\nThe ith item is said to match the rule if one of the following is true:\n\nruleKey == \"type\" and ruleValue == typei.\nruleKey == \"color\" and ruleValue == colori.\nruleKey == \"name\" and ruleValue == namei.\n\nReturn the number of items that match the given rule.",
        "examples": [
            "Input: items = [[\"phone\",\"blue\",\"pixel\"],[\"computer\",\"silver\",\"lenovo\"],[\"phone\",\"gold\",\"iphone\"]], ruleKey = \"color\", ruleValue = \"silver\"\nOutput: 1\nExplanation: There is only one item matching the given rule, which is [\"computer\",\"silver\",\"lenovo\"].",
            "Input: items = [[\"phone\",\"blue\",\"pixel\"],[\"computer\",\"silver\",\"phone\"],[\"phone\",\"gold\",\"iphone\"]], ruleKey = \"type\", ruleValue = \"phone\"\nOutput: 2\nExplanation: There are only two items matching the given rule, which are [\"phone\",\"blue\",\"pixel\"] and [\"phone\",\"gold\",\"iphone\"]. Note that the item [\"computer\",\"silver\",\"phone\"] does not match."
        ],
        "constraints": "1 <= items.length <= 104\n1 <= typei.length, colori.length, namei.length, ruleValue.length <= 10\nruleKey is equal to either \"type\", \"color\", or \"name\".\nAll strings consist only of lowercase letters.",
        "release_time": 1691915583,
        "oracle_code": "class Solution {\n    public int countMatches(List<List<String>> items, String ruleKey, String ruleValue) {\n        int count = 0;  // Initialize a counter to keep track of matching items.\n\n        String type = \"type\";  // Define the string constants for different ruleKeys.\n        int i = 0;  // Initialize the index variable to access the correct property of the items.\n\n        // Check the value of ruleKey and set the index (i) accordingly.\n        if (ruleKey.equals(type)) {\n            i = 0;  // If ruleKey is \"type\", set index to 0 (type property).\n        }\n        String color = \"color\";\n        if (ruleKey.equals(color)) {\n            i = 1;  // If ruleKey is \"color\", set index to 1 (color property).\n        }\n        String name = \"name\";\n        if (ruleKey.equals(name)) {\n            i = 2;  // If ruleKey is \"name\", set index to 2 (name property).\n        }\n\n        // Iterate through each item in the items list.\n        for (int j = 0; j < items.size(); j++) {\n            // Check if the property at index i of the current item matches ruleValue.\n            if (items.get(j).get(i).equals(ruleValue)) {\n                count++;  // If there's a match, increment the count.\n            }\n        }\n        \n        return count;  // Return the final count of items that match the rule.\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n![image.png](https://assets.leetcode.com/users/images/3afc1634-9bf6-4067-ad26-d7bbca6fc1fd_1691915490.7061198.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int countMatches(List<List<String>> items, String ruleKey, String ruleValue) {\\n        int count = 0;  // Initialize a counter to keep track of matching items.\\n\\n        String type = \"type\";  // Define the string constants for different ruleKeys.\\n        int i = 0;  // Initialize the index variable to access the correct property of the items.\\n\\n        // Check the value of ruleKey and set the index (i) accordingly.\\n        if (ruleKey.equals(type)) {\\n            i = 0;  // If ruleKey is \"type\", set index to 0 (type property).\\n        }\\n        String color = \"color\";\\n        if (ruleKey.equals(color)) {\\n            i = 1;  // If ruleKey is \"color\", set index to 1 (color property).\\n        }\\n        String name = \"name\";\\n        if (ruleKey.equals(name)) {\\n            i = 2;  // If ruleKey is \"name\", set index to 2 (name property).\\n        }\\n\\n        // Iterate through each item in the items list.\\n        for (int j = 0; j < items.size(); j++) {\\n            // Check if the property at index i of the current item matches ruleValue.\\n            if (items.get(j).get(i).equals(ruleValue)) {\\n                count++;  // If there\\'s a match, increment the count.\\n            }\\n        }\\n        \\n        return count;  // Return the final count of items that match the rule.\\n    }\\n}\\n\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\n    public int countMatches(List<List<String>> items, String ruleKey, String ruleValue) {\n        int count = 0;  // Initialize a counter to keep track of matching items.\n\n        String type = \"type\";  // Define the string constants for different ruleKeys.\n        int i = 0;  // Initialize the index variable to access the correct property of the items.\n\n        // Check the value of ruleKey and set the index (i) accordingly.\n        if (ruleKey.equals(type)) {\n            i = 2;  \n        }\n        String color = \"color\";\n        if (ruleKey.equals(color)) {\n            i = 1;  // If ruleKey is \"color\", set index to 1 (color property).\n        }\n        String name = \"name\";\n        if (ruleKey.equals(name)) {\n            i = 2;  // If ruleKey is \"name\", set index to 2 (name property).\n        }\n\n        // Iterate through each item in the items list.\n        for (int j = 0; j < items.size(); j++) {\n            // Check if the property at index i of the current item matches ruleValue.\n            if (items.get(j).get(i).equals(ruleValue)) {\n                count++;  // If there's a match, increment the count.\n            }\n        }\n        \n        return count;  // Return the final count of items that match the rule.\n    }\n}\n",
        "explanations": "\nThe bug is in the logic for \"type\" condition, it sets index 2 instead of 0.\n"
    }
]