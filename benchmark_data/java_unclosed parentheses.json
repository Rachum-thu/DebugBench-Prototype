[
    {
        "slug": "maximum-ice-cream-bars",
        "description": "It is a sweltering summer day, and a boy wants to buy some ice cream bars.\nAt the store, there are n ice cream bars. You are given an array costs of length n, where costs[i] is the price of the ith ice cream bar in coins. The boy initially has coins coins to spend, and he wants to buy as many ice cream bars as possible.\u00a0\nNote: The boy can buy the ice cream bars in any order.\nReturn the maximum number of ice cream bars the boy can buy with coins coins.\nYou must solve the problem by counting sort.",
        "examples": [
            "Input: costs = [1,3,2,4,1], coins = 7\nOutput: 4\nExplanation: The boy can buy ice cream bars at indices 0,1,2,4 for a total price of 1 + 3 + 2 + 1 = 7.",
            "Input: costs = [10,6,8,7,7,8], coins = 5\nOutput: 0\nExplanation: The boy cannot afford any of the ice cream bars.",
            "Input: costs = [1,6,3,1,2,5], coins = 20\nOutput: 6\nExplanation: The boy can buy all the ice cream bars for a total price of 1 + 6 + 3 + 1 + 2 + 5 = 18."
        ],
        "constraints": "costs.length == n\n1 <= n <= 105\n1 <= costs[i] <= 105\n1 <= coins <= 108",
        "release_time": 1672980160,
        "oracle_code": "class Solution {\n    public int maxIceCream(int[] costs, int coins) {\n        int [] arr = new int [100001];\n        for(int x : costs)arr[x]++;\n        int count = 0;\n        int index = 1;\n//If coins can buy all the ice-cream at ith index.\n        while(index<100001 && coins>=index*arr[index]){\n            coins-=index*arr[index];\n            count+=arr[index];\n            index++;\n        }\n//If coins can buy onyl some of the ice-creams at ith index.\n        while(index<100001 && coins>=index){\n            coins-=index;\n            count++;\n        }\n        return count;\n    }\n}",
        "content": "# Code\\n```\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        int [] arr = new int [100001];\\n        for(int x : costs)arr[x]++;\\n        int count = 0;\\n        int index = 1;\\n//If coins can buy all the ice-cream at ith index.\\n        while(index<100001 && coins>=index*arr[index]){\\n            coins-=index*arr[index];\\n            count+=arr[index];\\n            index++;\\n        }\\n//If coins can buy onyl some of the ice-creams at ith index.\\n        while(index<100001 && coins>=index){\\n            coins-=index;\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```\\n\\n# Using priority Queue\\n```\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<Integer>(Collections.reverseOrder());\\n        int sum = 0;\\n        for(int x : costs){\\n            if(sum<=coins){\\n                sum+=x;\\n                pq.add(x);\\n            }else if(pq.peek()>x){\\n                sum = sum - pq.poll() + x;\\n                pq.add(x);\\n            }\\n        }\\n        while(sum>coins){\\n            sum-=pq.poll();\\n        }\\n        return pq.size();\\n    }\\n}\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\n    public int maxIceCream(int[] costs, int coins) {\n        int [] arr = new int [100001];\n        for(int x : costs)arr[x]++;\n        int count = 0;\n        int index = 1;\n//If coins can buy all the ice-cream at ith index.\n        while(index<100001 && coins>=index*arr[index]){\n            coins-=index*arr[index];\n            count+=arr[index];\n            index++;\n        \n\n        while(index<100001 && coins>=index){\n            coins-=index;\n            count++;\n        }\n        return count;\n    }\n}\n",
        "explanations": "\nThe closing parenthesis for the first while loop is missing, creating a syntax error.\n"
    },
    {
        "slug": "add-strings",
        "description": "Given two non-negative integers, num1 and num2 represented as string, return the sum of num1 and num2 as a string.\nYou must solve the problem without using any built-in library for handling large integers (such as BigInteger). You must also not convert the inputs to integers directly.",
        "examples": [
            "Input: num1 = \"11\", num2 = \"123\"\nOutput: \"134\"",
            "Input: num1 = \"456\", num2 = \"77\"\nOutput: \"533\"",
            "Input: num1 = \"0\", num2 = \"0\"\nOutput: \"0\""
        ],
        "constraints": "1 <= num1.length, num2.length <= 104\nnum1 and num2 consist of only digits.\nnum1 and num2 don't have any leading zeros except for the zero itself.",
        "release_time": 1692165728,
        "oracle_code": "class Solution:\n    def addStrings(self, num1: str, num2: str) -> str:\n        sys.set_int_max_str_digits(10000)\n        nattu = int(num1)\n        babu = int(num2)\n        result = str(nattu+babu)\n        return result",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def addStrings(self, num1: str, num2: str) -> str:\\n        sys.set_int_max_str_digits(10000)\\n        nattu = int(num1)\\n        babu = int(num2)\\n        result = str(nattu+babu)\\n        return result\\n\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution{\n    public String addStrings(String num1, String num2) {\n        long nattu = Long.parseLong(num1);\n        long babu = Long.parseLong(num2);\n        String result = String.valueOf(nattu + babu);\n        return result;\n    }\n}\n",
        "explanations": "\nIn the original code, there are no syntax or logical errors. It runs perfectly. \n"
    },
    {
        "slug": "max-sum-of-rectangle-no-larger-than-k",
        "description": "Given an m x n matrix matrix and an integer k, return the max sum of a rectangle in the matrix such that its sum is no larger than k.\nIt is guaranteed that there will be a rectangle with a sum no larger than k.",
        "examples": [
            "Input: matrix = [[1,0,1],[0,-2,3]], k = 2\nOutput: 2\nExplanation: Because the sum of the blue rectangle [[0, 1], [-2, 3]] is 2, and 2 is the max number no larger than k (k = 2).",
            "Input: matrix = [[2,2,-1]], k = 3\nOutput: 3"
        ],
        "constraints": "m == matrix.length\nn == matrix[i].length\n1 <= m, n <= 100\n-100 <= matrix[i][j] <= 100\n-105 <= k <= 105",
        "release_time": 1661575112,
        "oracle_code": "//Kadane's Algorithm Approach\n//600ms+  explained in video\n\nclass Solution {\n    public int maxSumSubmatrix(int[][] matrix, int k) {\n        int result = Integer.MIN_VALUE;\n        \n        for(int left =0 ;left<matrix[0].length; left++){\n            \n            int[] rSum = new int[matrix.length];\n            \n            for(int right = left;right<matrix[0].length;right++){\n                for(int row=0; row < matrix.length; row++)\n                    rSum[row] += matrix[row][right];\n\t\t\t\t\t\n\t\t\t\t\t//explanation of these 3 loops starts from 02:00 in Video\n                \n                TreeSet<Integer> set = new TreeSet<>();\n                \n                set.add(0);\n                int cs = 0;\n                \n                for(int a: rSum){\n                    cs += a;\n\t\t\t\t\t\n                    //if you don't understand what exactly is going on here\n\t\t\t\t\t// then watch the video from 12:27\n\t\t\t\t\t\n                    Integer target = set.ceiling(cs-k);\n                    \n                    if(target !=null)\n                        result = Math.max(result,cs-target);\n                    set.add(cs);\n                }\n            }\n        }\n        return result;\n    }\n}",
        "content": "*Please **Upvote** if you find this explanation helpful*\\n\\n**Video Explanation**\\n[Max Sum of Rectangle No Larger Than K | YouTube](https://www.youtube.com/watch?v=rztZyG5kpvM&feature=youtu.be)\\n\\n**Java Solution**\\n\\n```\\n//Kadane\\'s Algorithm Approach\\n//600ms+  explained in video\\n\\nclass Solution {\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        int result = Integer.MIN_VALUE;\\n        \\n        for(int left =0 ;left<matrix[0].length; left++){\\n            \\n            int[] rSum = new int[matrix.length];\\n            \\n            for(int right = left;right<matrix[0].length;right++){\\n                for(int row=0; row < matrix.length; row++)\\n                    rSum[row] += matrix[row][right];\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t//explanation of these 3 loops starts from 02:00 in Video\\n                \\n                TreeSet<Integer> set = new TreeSet<>();\\n                \\n                set.add(0);\\n                int cs = 0;\\n                \\n                for(int a: rSum){\\n                    cs += a;\\n\\t\\t\\t\\t\\t\\n                    //if you don\\'t understand what exactly is going on here\\n\\t\\t\\t\\t\\t// then watch the video from 12:27\\n\\t\\t\\t\\t\\t\\n                    Integer target = set.ceiling(cs-k);\\n                    \\n                    if(target !=null)\\n                        result = Math.max(result,cs-target);\\n                    set.add(cs);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```\\n\\n**Faster Approach**\\n```\\n//32ms - faster than 100%\\n\\nclass Solution {\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        for (int i = 0; i < matrix.length; i++) {\\n            for (int j = 0; j < matrix[0].length; j++) {\\n                if (i > 0) {\\n                    matrix[i][j] += matrix[i - 1][j];\\n                }\\n                if (j > 0) {\\n                    matrix[i][j] += matrix[i][j - 1];\\n                }\\n                if (i > 0 && j > 0) {\\n                    matrix[i][j] -= matrix[i - 1][j - 1];\\n                }\\n            }\\n        }\\n        int result = Integer.MIN_VALUE;\\n        \\n        int[][] dpHigh = new int[matrix.length][matrix.length + 1];\\n        int[][] dpLow = new int[matrix.length][matrix.length + 1];\\n        \\n        for (int i = matrix.length - 1; i >= 0; i--) {\\n            for (int h = 1; h <= matrix.length - i; h++) {\\n                int theValue = getSum(matrix, i, matrix[0].length - 1, h, 1);\\n                dpLow[i][h] = theValue;\\n                dpHigh[i][h] = theValue;\\n                if (theValue == k) {\\n                    return theValue;\\n                }\\n                if (theValue < k) {\\n                    result = Math.max(result, theValue);\\n                }\\n            }\\n        }\\n        \\n        for (int i = matrix.length - 1; i >= 0; i--) {\\n            for (int j = matrix[0].length - 2; j >= 0; j--) {\\n                for (int h = 1; h <= matrix.length - i; h++) {\\n                    int newSum = getSum(matrix, i, j, h, 1);\\n                    if (dpLow[i][h] > 0) {\\n                        dpHigh[i][h] += newSum;\\n                        dpLow[i][h] = newSum;\\n                    } else if (dpHigh[i][h] < 0) {\\n                        dpLow[i][h] += newSum;\\n                        dpHigh[i][h] = newSum;\\n                    } else {\\n                        dpHigh[i][h] += newSum;\\n                        dpLow[i][h] += newSum;\\n                    }\\n                    if (dpHigh[i][h] >= result && dpLow[i][h] <= k) {\\n                        for (int w = 1; w <= matrix[0].length - j; w++) {\\n                            int sum = getSum(matrix, i, j, h, w);\\n                            if (sum == k) {\\n                                return sum;\\n                            } else if (sum < k) {\\n                                result = Math.max(result, sum);\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    private int getSum(int[][] matrix, int i, int j, int h, int w) {\\n        int sum = matrix[i + h - 1][j + w - 1];\\n        if (i > 0) {\\n            sum -= matrix[i - 1][j + w - 1];\\n        }\\n        if (j > 0) {\\n            sum -= matrix[i + h - 1][j - 1];\\n        }\\n        if (i > 0 && j > 0) {\\n            sum += matrix[i - 1][j - 1];\\n        }\\n        return sum;\\n    }\\n}\\n```",
        "level": "hard",
        "buggy_code": "\n//Kadane's Algorithm Approach\n//600ms+  explained in video\n\nclass Solution {\n    public int maxSumSubmatrix(int[][] matrix, int k) {\n        int result = Integer.MIN_VALUE;\n       \n        for(int left =0 ;left<matrix[0].length; left++){\n         \n            int[] rSum = new int[matrix.length];\n          \n            for(int right = left;right<matrix[0].length;right++){\n                for(int row=0; row < matrix.length; row++)\n                    rSum[row] += matrix[row][right];\n                    \n                    \n            \n                TreeSet<Integer> set = new TreeSet<>();\n              \n                set.add(0);\n                int cs = 0;\n               \n                for(int a: rSum){\n                    cs += a;\n                  \n                    //if you don't understand what exactly is going on here\n                    \n                  \n                    Integer target = set.ceiling(cs-k;\n                  \n                    if(target !=null)\n                        result = Math.max(result,cs-target);\n                    set.add(cs);\n                }\n            }\n        }\n        return result;\n    }\n}\n",
        "explanations": "\nThe closing parenthesis for set.ceiling(cs-k) is missing, hence causing a mismatch error.\n"
    },
    {
        "slug": "baseball-game",
        "description": "You are keeping the scores for a baseball game with strange rules. At the beginning of the game, you start with an empty record.\nYou are given a list of strings operations, where operations[i] is the ith operation you must apply to the record and is one of the following:\n\nAn integer x.\n\n\t\nRecord a new score of x.\n\n\n'+'.\n\t\nRecord a new score that is the sum of the previous two scores.\n\n\n'D'.\n\t\nRecord a new score that is the double of the previous score.\n\n\n'C'.\n\t\nInvalidate the previous score, removing it from the record.\n\n\n\nReturn the sum of all the scores on the record after applying all the operations.\nThe test cases are generated such that the answer and all intermediate calculations fit in a 32-bit integer and that all operations are valid.",
        "examples": [
            "Input: ops = [\"5\",\"2\",\"C\",\"D\",\"+\"]\nOutput: 30\nExplanation:\n\"5\" - Add 5 to the record, record is now [5].\n\"2\" - Add 2 to the record, record is now [5, 2].\n\"C\" - Invalidate and remove the previous score, record is now [5].\n\"D\" - Add 2 * 5 = 10 to the record, record is now [5, 10].\n\"+\" - Add 5 + 10 = 15 to the record, record is now [5, 10, 15].\nThe total sum is 5 + 10 + 15 = 30.",
            "Input: ops = [\"5\",\"-2\",\"4\",\"C\",\"D\",\"9\",\"+\",\"+\"]\nOutput: 27\nExplanation:\n\"5\" - Add 5 to the record, record is now [5].\n\"-2\" - Add -2 to the record, record is now [5, -2].\n\"4\" - Add 4 to the record, record is now [5, -2, 4].\n\"C\" - Invalidate and remove the previous score, record is now [5, -2].\n\"D\" - Add 2 * -2 = -4 to the record, record is now [5, -2, -4].\n\"9\" - Add 9 to the record, record is now [5, -2, -4, 9].\n\"+\" - Add -4 + 9 = 5 to the record, record is now [5, -2, -4, 9, 5].\n\"+\" - Add 9 + 5 = 14 to the record, record is now [5, -2, -4, 9, 5, 14].\nThe total sum is 5 + -2 + -4 + 9 + 5 + 14 = 27.",
            "Input: ops = [\"1\",\"C\"]\nOutput: 0\nExplanation:\n\"1\" - Add 1 to the record, record is now [1].\n\"C\" - Invalidate and remove the previous score, record is now [].\nSince the record is empty, the total sum is 0."
        ],
        "constraints": "1 <= operations.length <= 1000\noperations[i] is \"C\", \"D\", \"+\", or a string representing an integer in the range [-3 * 104, 3 * 104].\nFor operation \"+\", there will always be at least two previous scores on the record.\nFor operations \"C\" and \"D\", there will always be at least one previous score on the record.",
        "release_time": 1689567966,
        "oracle_code": "class Solution {\n    public int calPoints(String[] operations) {\n\n        Stack<Integer> stack = new Stack<>();\n        \n        for(int i=0; i<operations.length; i++){\n            if(operations[i].equals(\"C\")){\n                stack.pop();\n            }else if(operations[i].equals(\"D\")){\n                stack.push(stack.peek() * 2);\n            }else if(operations[i].equals(\"+\") && stack.size()>=2){\n                int value1 = stack.pop();\n                int value2 = stack.pop();\n                int value = value1+ value2;\n                //push value2 back to the stack frist\n                stack.push(value2);\n                stack.push(value1);\n                stack.push(value);\n            }else {\n                stack.push(Integer.parseInt(operations[i]));\n            }\n        }\n        \n        System.out.println(\"Stack\" + stack);\n\n        int sum =0;\n        while (!stack.isEmpty()){\n            sum += stack.pop();\n        }\n        \n        return sum;\n    }\n}",
        "content": "# Approach1: Use Stack\\n# Approach2: Use Dequeue\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int calPoints(String[] operations) {\\n\\n        Stack<Integer> stack = new Stack<>();\\n        \\n        for(int i=0; i<operations.length; i++){\\n            if(operations[i].equals(\"C\")){\\n                stack.pop();\\n            }else if(operations[i].equals(\"D\")){\\n                stack.push(stack.peek() * 2);\\n            }else if(operations[i].equals(\"+\") && stack.size()>=2){\\n                int value1 = stack.pop();\\n                int value2 = stack.pop();\\n                int value = value1+ value2;\\n                //push value2 back to the stack frist\\n                stack.push(value2);\\n                stack.push(value1);\\n                stack.push(value);\\n            }else {\\n                stack.push(Integer.parseInt(operations[i]));\\n            }\\n        }\\n        \\n        System.out.println(\"Stack\" + stack);\\n\\n        int sum =0;\\n        while (!stack.isEmpty()){\\n            sum += stack.pop();\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\n    public int calPoints(String[] operations) {\n\n        Stack<Integer> stack = new Stack<>();\n        \n        for(int i=0; i<operations.length; i++){\n            if(operations[i].equals(\"C\")){\n                stack.pop();\n            }else if(operations[i].equals(\"D\")){\n                stack.push(stack.peek() * 2);\n            }else if(operations[i].equals(\"+\") && stack.size()>=2){\n                int value1 = stack.pop();\n                int value2 = stack.pop();\n                int value = value1+ value2;\n                //push value2 back to the stack frist\n                stack.push(value2);\n                stack.push(value1;\n                stack.push(value);\n            }else {\n                stack.push(Integer.parseInt(operations[i]));\n            }\n        }\n        \n        System.out.println(\"Stack\" + stack);\n\n        int sum =0;\n        while (!stack.isEmpty()){\n            sum += stack.pop();\n        }\n        \n        return sum;\n    }\n}\n",
        "explanations": "\nMissed closing parenthesis after the statement 'stack.push(value1', causing compiler error.\n"
    },
    {
        "slug": "search-insert-position",
        "description": "Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.\nYou must\u00a0write an algorithm with\u00a0O(log n) runtime complexity.",
        "examples": [
            "Input: nums = [1,3,5,6], target = 5\nOutput: 2",
            "Input: nums = [1,3,5,6], target = 2\nOutput: 1",
            "Input: nums = [1,3,5,6], target = 7\nOutput: 4"
        ],
        "constraints": "1 <= nums.length <= 104\n-104 <= nums[i] <= 104\nnums contains distinct values sorted in ascending order.\n-104 <= target <= 104",
        "release_time": 1691938245,
        "oracle_code": "class Solution {\n    public int searchInsert(int[] nums, int target) {\n        ArrayList<Integer>atr=new ArrayList<>();\n        for(int a:nums){\n            atr.add(a);\n        }\n        atr.add(target);\n        Collections.sort(atr);\n        int k=atr.indexOf(target);\n        return k;\n        \n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n![image.png](https://assets.leetcode.com/users/images/a7c0897c-8dc0-4fa5-aeca-e836b2887d45_1691938187.8801217.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        ArrayList<Integer>atr=new ArrayList<>();\\n        for(int a:nums){\\n            atr.add(a);\\n        }\\n        atr.add(target);\\n        Collections.sort(atr);\\n        int k=atr.indexOf(target);\\n        return k;\\n        \\n    }\\n}\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\n    public int searchInsert(int[] nums, int target) {\n        ArrayList<Integer>atr=new ArrayList<>();\n        for(int a:nums){\n            atr.add(a);\n        }\n        atr.add(target);\n        Collections.sort(atr;\n        int k=atr.indexOf(target);\n        return k;\n        \n    }\n}\n",
        "explanations": "\nClosing parenthesis is missing in the Collections.sort() method which will lead to compile time error.\n"
    },
    {
        "slug": "make-costs-of-paths-equal-in-a-binary-tree",
        "description": "You are given an integer n representing the number of nodes in a perfect binary tree consisting of nodes numbered from 1 to n. The root of the tree is node 1 and each node i in the tree has two children where the left child is the node 2 * i and the right child is 2 * i + 1.\nEach node in the tree also has a cost represented by a given 0-indexed integer array cost of size n where cost[i] is the cost of node i + 1. You are allowed to increment the cost of any node by 1 any number of times.\nReturn the minimum number of increments you need to make the cost of paths from the root to each leaf node equal.\nNote:\n\nA perfect binary tree is a tree where each node, except the leaf nodes, has exactly 2 children.\nThe cost of a path is the sum of costs of nodes in the path.",
        "examples": [
            "Input: n = 7, cost = [1,5,2,2,3,3,1]\nOutput: 6\nExplanation: We can do the following increments:\n- Increase the cost of node 4 one time.\n- Increase the cost of node 3 three times.\n- Increase the cost of node 7 two times.\nEach path from the root to a leaf will have a total cost of 9.\nThe total increments we did is 1 + 3 + 2 = 6.\nIt can be shown that this is the minimum answer we can achieve.",
            "Input: n = 3, cost = [5,3,3]\nOutput: 0\nExplanation: The two paths already have equal total costs, so no increments are needed."
        ],
        "constraints": "3 <= n <= 105\nn + 1 is a power of 2\ncost.length == n\n1 <= cost[i] <= 104",
        "release_time": 1684215665,
        "oracle_code": "class Solution {\n    int res = 0;\n    public int minIncrements(int n, int[] cost) {\n        dfs(1, cost);\n        return res;\n    }\n\n    // get the max cost of a path of sub tree root at i;\n    public int dfs(int i, int[] cost) {\n        if (i > cost.length) return 0;\n        int left = dfs(i * 2, cost), right = dfs(i * 2 + 1, cost);\n        // you need keep two child tree has the same cost of path.\n        // best way to tune the root of lower cost path, increase the\n        // lower root, by Math.abs(left - right);\n        res += Math.abs(left - right);\n        return cost[i - 1] + Math.max(left, right);\n    }\n}",
        "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSee comments\\n# Complexity\\nT O(N)\\nS O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    int res = 0;\\n    public int minIncrements(int n, int[] cost) {\\n        dfs(1, cost);\\n        return res;\\n    }\\n\\n    // get the max cost of a path of sub tree root at i;\\n    public int dfs(int i, int[] cost) {\\n        if (i > cost.length) return 0;\\n        int left = dfs(i * 2, cost), right = dfs(i * 2 + 1, cost);\\n        // you need keep two child tree has the same cost of path.\\n        // best way to tune the root of lower cost path, increase the\\n        // lower root, by Math.abs(left - right);\\n        res += Math.abs(left - right);\\n        return cost[i - 1] + Math.max(left, right);\\n    }\\n}\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\n    int res = 0;\n    public int minIncrements(int n, int[] cost) {\n        dfs(1, cost;\n        return res;\n    }\n\n    public int dfs(int i, int[] cost) {\n        if (i > cost.length) return 0;\n        int left = dfs(i * 2, cost, right = dfs(i * 2 + 1, cost);\n        res += Math.abs(left - right);\n        return cost[i - 1] + Math.max(left, right);\n    }\n}\n",
        "explanations": "\nThere is a parenthesis mismatch in the dfs method call in minIncrements method leading to unexpected behaviour.\n"
    },
    {
        "slug": "mirror-reflection",
        "description": "There is a special square room with mirrors on each of the four walls. Except for the southwest corner, there are receptors on each of the remaining corners, numbered 0, 1, and 2.\nThe square room has walls of length p\u00a0and a laser ray from the southwest corner first meets the east wall at a distance q from the 0th receptor.\nGiven the two integers p and q, return the number of the receptor that the ray meets first.\nThe test cases are guaranteed so that the ray will meet a receptor eventually.",
        "examples": [
            "Input: p = 2, q = 1\nOutput: 2\nExplanation: The ray meets receptor 2 the first time it gets reflected back to the left wall.",
            "Input: p = 3, q = 1\nOutput: 1"
        ],
        "constraints": "1 <= q <= p <= 1000",
        "release_time": 1659577168,
        "oracle_code": "class Solution {\n    public int mirrorReflection(int p, int q) {\n        while(((p|q)&1) == 0){\n            p >>= 1;\n            q >>= 1;\n        }\n        return (q&1) + ((p&1)^1);\n    }\n}",
        "content": "\\tPLEASE UPVOTE IF YOU LIKE\\n```\\nclass Solution {\\n    public int mirrorReflection(int p, int q) {\\n        while(((p|q)&1) == 0){\\n            p >>= 1;\\n            q >>= 1;\\n        }\\n        return (q&1) + ((p&1)^1);\\n    }\\n}\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\n    public int mirrorReflection(int p, int q) {\n        while(((p|q)&1) == 0){\n            p >>= 1;\n            q >>= 1;\n        return (q&1) + ((p&1)^1);\n    }\n}\n",
        "explanations": "\nThe closing brace for the while loop is missing, causing a syntax error.\n"
    },
    {
        "slug": "check-if-one-string-swap-can-make-strings-equal",
        "description": "You are given two strings s1 and s2 of equal length. A string swap is an operation where you choose two indices in a string (not necessarily different) and swap the characters at these indices.\nReturn true if it is possible to make both strings equal by performing at most one string swap on exactly one of the strings. Otherwise, return false.",
        "examples": [
            "Input: s1 = \"bank\", s2 = \"kanb\"\nOutput: true\nExplanation: For example, swap the first character with the last character of s2 to make \"bank\".",
            "Input: s1 = \"attack\", s2 = \"defend\"\nOutput: false\nExplanation: It is impossible to make them equal with one string swap.",
            "Input: s1 = \"kelb\", s2 = \"kelb\"\nOutput: true\nExplanation: The two strings are already equal, so no string swap operation is required."
        ],
        "constraints": "1 <= s1.length, s2.length <= 100\ns1.length == s2.length\ns1 and s2 consist of only lowercase English letters.",
        "release_time": 1679756521,
        "oracle_code": "class Solution {\n    public boolean areAlmostEqual(String s1, String s2) {\n        if(s1.equals(s2))\n        return true;\n        ArrayList<Character> ts=new ArrayList<>();\n        ArrayList<Character> ts1=new ArrayList<>();\n        int count=0;\n        for(int i=0;i<s1.length();i++){\n            if(s1.charAt(i)!=s2.charAt(i)){\n            ts.add(s1.charAt(i));\n            ts1.add(s2.charAt(i));    \n        }\n        }\n        for(Character co:ts){\n            if(!(ts1.contains(co)))\n            return false;\n        }\n        return (ts.size()==2 && ts1.size()==2)?true:false;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean areAlmostEqual(String s1, String s2) {\\n        if(s1.equals(s2))\\n        return true;\\n        ArrayList<Character> ts=new ArrayList<>();\\n        ArrayList<Character> ts1=new ArrayList<>();\\n        int count=0;\\n        for(int i=0;i<s1.length();i++){\\n            if(s1.charAt(i)!=s2.charAt(i)){\\n            ts.add(s1.charAt(i));\\n            ts1.add(s2.charAt(i));    \\n        }\\n        }\\n        for(Character co:ts){\\n            if(!(ts1.contains(co)))\\n            return false;\\n        }\\n        return (ts.size()==2 && ts1.size()==2)?true:false;\\n    }\\n}\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\n    public boolean areAlmostEqual(String s1, String s2) {\n        if(s1.equals(s2))\n        return true;\n        ArrayList<Character> ts=new ArrayList<>();\n        ArrayList<Character> ts1=new ArrayList<>();\n        int count=0;\n        for(int i=0;i<s1.length();i++{\n            if(s1.charAt(i)!=s2.charAt(i)){\n                ts.add(s1.charAt(i));\n                ts1.add(s2.charAt(i));    \n            }\n        }\n        for(Character co:ts){\n            if(!(ts1.contains(co)))\n            return false;\n        }\n        return (ts.size()==2 && ts1.size()==2)?true:false;\n    }\n}\n",
        "explanations": "\nThe bug is missing closing parenthesis in the for loop statement after s1.length().\n"
    },
    {
        "slug": "apply-discount-every-n-orders",
        "description": "There is a supermarket that is frequented by many customers. The products sold at the supermarket are represented as two parallel integer arrays products and prices, where the ith product has an ID of products[i] and a price of prices[i].\nWhen a customer is paying, their bill is represented as two parallel integer arrays product and amount, where the jth product they purchased has an ID of product[j], and amount[j] is how much of the product they bought. Their subtotal is calculated as the sum of each amount[j] * (price of the jth product).\nThe supermarket decided to have a sale. Every nth customer paying for their groceries will be given a percentage discount. The discount amount is given by discount, where they will be given discount percent off their subtotal. More formally, if their subtotal is bill, then they would actually pay bill * ((100 - discount) / 100).\nImplement the Cashier class:\n\nCashier(int n, int discount, int[] products, int[] prices) Initializes the object with n, the discount, and the products and their prices.\ndouble getBill(int[] product, int[] amount) Returns the final total of the bill with the discount applied (if any). Answers within 10-5 of the actual value will be accepted.",
        "examples": [
            "Input\n[\"Cashier\",\"getBill\",\"getBill\",\"getBill\",\"getBill\",\"getBill\",\"getBill\",\"getBill\"]\n[[3,50,[1,2,3,4,5,6,7],[100,200,300,400,300,200,100]],[[1,2],[1,2]],[[3,7],[10,10]],[[1,2,3,4,5,6,7],[1,1,1,1,1,1,1]],[[4],[10]],[[7,3],[10,10]],[[7,5,3,1,6,4,2],[10,10,10,9,9,9,7]],[[2,3,5],[5,3,2]]]\nOutput\n[null,500.0,4000.0,800.0,4000.0,4000.0,7350.0,2500.0]\nExplanation\nCashier cashier = new Cashier(3,50,[1,2,3,4,5,6,7],[100,200,300,400,300,200,100]);\ncashier.getBill([1,2],[1,2]);                        // return 500.0. 1st customer, no discount.\n                                                     // bill = 1 * 100 + 2 * 200 = 500.\ncashier.getBill([3,7],[10,10]);                      // return 4000.0. 2nd customer, no discount.\n                                                     // bill = 10 * 300 + 10 * 100 = 4000.\ncashier.getBill([1,2,3,4,5,6,7],[1,1,1,1,1,1,1]);    // return 800.0. 3rd customer, 50% discount.\n                                                     // Original bill = 1600\n                                                     // Actual bill = 1600 * ((100 - 50) / 100) = 800.\ncashier.getBill([4],[10]);                           // return 4000.0. 4th customer, no discount.\ncashier.getBill([7,3],[10,10]);                      // return 4000.0. 5th customer, no discount.\ncashier.getBill([7,5,3,1,6,4,2],[10,10,10,9,9,9,7]); // return 7350.0. 6th customer, 50% discount.\n                                                     // Original bill = 14700, but with\n                                                     // Actual bill = 14700 * ((100 - 50) / 100) = 7350.\ncashier.getBill([2,3,5],[5,3,2]);                    // return 2500.0.  7th customer, no discount."
        ],
        "constraints": "1 <= n <= 104\n0 <= discount <= 100\n1 <= products.length <= 200\nprices.length == products.length\n1 <= products[i] <= 200\n1 <= prices[i] <= 1000\nThe elements in products are unique.\n1 <= product.length <= products.length\namount.length == product.length\nproduct[j] exists in products.\n1 <= amount[j] <= 1000\nThe elements of product are unique.\nAt most 1000 calls will be made to getBill.\nAnswers within 10-5 of the actual value will be accepted.",
        "release_time": 1672208305,
        "oracle_code": "class Cashier {\n    HashMap<Integer,Integer>stock=new HashMap<>();\n    int n;\n    int discount;\n    int itr=0;\n    public Cashier(int n, int discount, int[] products, int[] prices) {\n        for(int i=0;i<products.length;i++){\n            stock.put(products[i],prices[i]);\n        }\n        this.n=n;\n        this.discount=discount;\n    }\n    \n    public double getBill(int[] product, int[] amount) {\n        double total=0;\n        for(int i=0;i<product.length;i++){\n            total+=(double)(amount[i]*stock.get(product[i]));\n        }\n        itr++;\n        if(itr==n){\n            total*=(double)(((100-discount)/100d));\n            itr=0;\n        }\n        return total;\n    }\n}\n\n/**\n * Your Cashier object will be instantiated and called as such:\n * Cashier obj = new Cashier(n, discount, products, prices);\n * double param_1 = obj.getBill(product,amount);\n */",
        "content": "# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Cashier {\\n    HashMap<Integer,Integer>stock=new HashMap<>();\\n    int n;\\n    int discount;\\n    int itr=0;\\n    public Cashier(int n, int discount, int[] products, int[] prices) {\\n        for(int i=0;i<products.length;i++){\\n            stock.put(products[i],prices[i]);\\n        }\\n        this.n=n;\\n        this.discount=discount;\\n    }\\n    \\n    public double getBill(int[] product, int[] amount) {\\n        double total=0;\\n        for(int i=0;i<product.length;i++){\\n            total+=(double)(amount[i]*stock.get(product[i]));\\n        }\\n        itr++;\\n        if(itr==n){\\n            total*=(double)(((100-discount)/100d));\\n            itr=0;\\n        }\\n        return total;\\n    }\\n}\\n\\n/**\\n * Your Cashier object will be instantiated and called as such:\\n * Cashier obj = new Cashier(n, discount, products, prices);\\n * double param_1 = obj.getBill(product,amount);\\n */\\n```",
        "level": "medium",
        "buggy_code": "\nclass Cashier {\n    HashMap<Integer,Integer>stock=new HashMap<>();\n    int n;\n    int discount;\n    int itr=0;\n    public Cashier(int n, int discount, int[] products, int[] prices {\n        for(int i=0;i<products.length;i++){\n            stock.put(products[i],prices[i]);\n        }\n        this.n=n;\n        this.discount=discount;\n    }\n    \n    public double getBill(int[] product, int[] amount) {\n        double total=0;\n        for(int i=0;i<product.length;i++){\n            total+=(double)(amount[i]*stock.get(product[i]));\n        }\n        itr++;\n        if(itr==n){\n            total*=(double)(((100-discount)/100d));\n            itr=0;\n        }\n        return total;\n    }\n}\n\n/**\n * Your Cashier object will be instantiated and called as such:\n * Cashier obj = new Cashier(n, discount, products, prices);\n * double param_1 = obj.getBill(product,amount);\n */\n",
        "explanations": "\nMissing closing parenthesis in constructor Cashier's arguments, causing a syntax error.\n"
    },
    {
        "slug": "convert-the-temperature",
        "description": "You are given a non-negative floating point number rounded to two decimal places celsius, that denotes the temperature in Celsius.\nYou should convert Celsius into Kelvin and Fahrenheit and return it as an array ans = [kelvin, fahrenheit].\nReturn the array ans. Answers within 10-5 of the actual answer will be accepted.\nNote that:\n\nKelvin = Celsius + 273.15\nFahrenheit = Celsius * 1.80 + 32.00",
        "examples": [
            "Input: celsius = 36.50\nOutput: [309.65000,97.70000]\nExplanation: Temperature at 36.50 Celsius converted in Kelvin is 309.65 and converted in Fahrenheit is 97.70.",
            "Input: celsius = 122.11\nOutput: [395.26000,251.79800]\nExplanation: Temperature at 122.11 Celsius converted in Kelvin is 395.26 and converted in Fahrenheit is 251.798."
        ],
        "constraints": "0 <= celsius <= 1000",
        "release_time": 1668314039,
        "oracle_code": "class Solution {\n    public double[] convertTemperature(double celsius) {\n        double arr[] = new double[2];\n        arr[1] = (celsius * 9.0/5.0) + 32.0;\n        arr[0] = celsius + 273.15;\n        return arr;\n    }\n}",
        "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe program takes a celsius value and converts it to fahrenheit and kelvin.\\n# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public double[] convertTemperature(double celsius) {\\n        double arr[] = new double[2];\\n        arr[1] = (celsius * 9.0/5.0) + 32.0;\\n        arr[0] = celsius + 273.15;\\n        return arr;\\n    }\\n}\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\n    public double[] convertTemperature(double celsius) {\n        double arr[] = new double[2];\n        arr[1 = (celsius * 9.0/5.0) + 32.0;\n        arr[0] = celsius + 273.15;\n        return arr;\n    }\n}\n",
        "explanations": "\nThe closing square bracket is missing after array index in the third line.\n"
    },
    {
        "slug": "group-the-people-given-the-group-size-they-belong-to",
        "description": "There are n people\u00a0that are split into some unknown number of groups. Each person is labeled with a\u00a0unique ID\u00a0from\u00a00\u00a0to\u00a0n - 1.\nYou are given an integer array\u00a0groupSizes, where groupSizes[i]\u00a0is the size of the group that person\u00a0i\u00a0is in. For example, if\u00a0groupSizes[1] = 3, then\u00a0person\u00a01\u00a0must be in a\u00a0group of size\u00a03.\nReturn\u00a0a list of groups\u00a0such that\u00a0each person\u00a0i\u00a0is in a group of size\u00a0groupSizes[i].\nEach person should\u00a0appear in\u00a0exactly one group,\u00a0and every person must be in a group. If there are\u00a0multiple answers, return any of them. It is guaranteed that there will be at least one valid solution for the given input.",
        "examples": [
            "Input: groupSizes = [3,3,3,3,3,1,3]\nOutput: [[5],[0,1,2],[3,4,6]]\nExplanation: \nThe first group is [5]. The size is 1, and groupSizes[5] = 1.\nThe second group is [0,1,2]. The size is 3, and groupSizes[0] = groupSizes[1] = groupSizes[2] = 3.\nThe third group is [3,4,6]. The size is 3, and groupSizes[3] = groupSizes[4] = groupSizes[6] = 3.\nOther possible solutions are [[2,1,6],[5],[0,4,3]] and [[5],[0,6,2],[4,3,1]].",
            "Input: groupSizes = [2,1,3,3,3,2]\nOutput: [[1],[0,5],[2,3,4]]"
        ],
        "constraints": "groupSizes.length == n\n1 <= n\u00a0<= 500\n1 <=\u00a0groupSizes[i] <= n",
        "release_time": 1687491634,
        "oracle_code": "class Solution {\n    public List<List<Integer>> groupThePeople(int[] groupSizes) {\n        ArrayList<List<Integer>> list =  new ArrayList<>();\n        HashMap<Integer, ArrayList<Integer>> hm = new HashMap<>();\n\n        for(int i = 0 ; i < groupSizes.length; i++){\n            if(hm.containsKey(groupSizes[i])){\n                hm.get(groupSizes[i]).add(i);\n            }\n            else{\n            \tArrayList<Integer> newL = new ArrayList<>();\n            \tnewL.add(i);\n                hm.put(groupSizes[i], newL);      \n            }\n\n            if(hm.get(groupSizes[i]).size() == groupSizes[i]){\n                list.add(hm.get(groupSizes[i]));\n                hm.remove(groupSizes[i]);\n            }\n        }\n            \n        return list;\n    }\n}\n// UP-VOTE IF HELPFUL",
        "content": "# Complexity\\n- Time complexity:\\nO(n)\\nWhere n is the size of the array groupSizes\\n\\n- Space complexity:\\nO(n)\\nWhere n is the size of the array groupSizes\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> groupThePeople(int[] groupSizes) {\\n        ArrayList<List<Integer>> list =  new ArrayList<>();\\n        HashMap<Integer, ArrayList<Integer>> hm = new HashMap<>();\\n\\n        for(int i = 0 ; i < groupSizes.length; i++){\\n            if(hm.containsKey(groupSizes[i])){\\n                hm.get(groupSizes[i]).add(i);\\n            }\\n            else{\\n            \\tArrayList<Integer> newL = new ArrayList<>();\\n            \\tnewL.add(i);\\n                hm.put(groupSizes[i], newL);      \\n            }\\n\\n            if(hm.get(groupSizes[i]).size() == groupSizes[i]){\\n                list.add(hm.get(groupSizes[i]));\\n                hm.remove(groupSizes[i]);\\n            }\\n        }\\n            \\n        return list;\\n    }\\n}\\n// UP-VOTE IF HELPFUL\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\n    public List<List<Integer>> groupThePeople(int[] groupSizes) {\n        ArrayList<List<Integer>> list =  new ArrayList<>();\n        HashMap<Integer, ArrayList<Integer>> hm = new HashMap<>();\n\n        for(int i = 0 ; i < groupSizes.length; i++){\n            if(hm.containsKey(groupSizes[i])){\n                hm.get(groupSizes[i]).add(i);\n            }\n            else{\n            \tArrayList<Integer> newL = new ArrayList<>();\n            \tnewL.add(i);\n                hm.put(groupSizes[i], newL; \n            }\n\n            if(hm.get(groupSizes[i]).size() == groupSizes[i]){\n                list.add(hm.get(groupSizes[i]));\n                hm.remove(groupSizes[i]);\n            }\n        }\n            \n        return list;\n    }\n}\n",
        "explanations": "\nThe bug added is a missing closing parentheses in the line where a new arraylist is put into the hashmap.\n"
    },
    {
        "slug": "count-odd-numbers-in-an-interval-range",
        "description": "Given two non-negative integers low and high. Return the count of odd numbers between low and high\u00a0(inclusive).",
        "examples": [
            "Input: low = 3, high = 7\r\nOutput: 3\r\nExplanation: The odd numbers between 3 and 7 are [3,5,7].",
            "Input: low = 8, high = 10\r\nOutput: 1\r\nExplanation: The odd numbers between 8 and 10 are [9]."
        ],
        "constraints": "0 <= low <= high\u00a0<= 10^9",
        "release_time": 1683277667,
        "oracle_code": "class Solution {\n    public int countOdds(int low, int high) {\n        if(low%2==0 && high%2==0)\n            return (high-low)/2;\n        else\n            return (high-low)/2+1;\n    }\n}",
        "content": "# Intuition\\nAt first i thought to execute it with using loops.\\n\\n# Approach\\nThere are four possible ways to get no.of odd numbers from low and high limits.\\nWhen both numbers are even print half of its difference else by adding one to it.\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int countOdds(int low, int high) {\\n        if(low%2==0 && high%2==0)\\n            return (high-low)/2;\\n        else\\n            return (high-low)/2+1;\\n    }\\n}\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\n    public int countOdds(int low, int high) {\n        if(low%2==0 && high%2==0) \n            return (high-low)/2;\n        else\n            return ((high-low)/2+1;\n    }\n}\n",
        "explanations": "\nThere is one extra opening bracket in the else return statement causing a parentheses mismatch.\n"
    },
    {
        "slug": "number-of-students-doing-homework-at-a-given-time",
        "description": "Given two integer arrays startTime and endTime and given an integer queryTime.\nThe ith student started doing their homework at the time startTime[i] and finished it at time endTime[i].\nReturn the number of students doing their homework at time queryTime. More formally, return the number of students where queryTime lays in the interval [startTime[i], endTime[i]] inclusive.",
        "examples": [
            "Input: startTime = [1,2,3], endTime = [3,2,7], queryTime = 4\nOutput: 1\nExplanation: We have 3 students where:\nThe first student started doing homework at time 1 and finished at time 3 and wasn't doing anything at time 4.\nThe second student started doing homework at time 2 and finished at time 2 and also wasn't doing anything at time 4.\nThe third student started doing homework at time 3 and finished at time 7 and was the only student doing homework at time 4.",
            "Input: startTime = [4], endTime = [4], queryTime = 4\nOutput: 1\nExplanation: The only student was doing their homework at the queryTime."
        ],
        "constraints": "startTime.length == endTime.length\n1 <= startTime.length <= 100\n1 <= startTime[i] <= endTime[i] <= 1000\n1 <= queryTime <= 1000",
        "release_time": 1690396136,
        "oracle_code": "class Solution {\n    public int busyStudent(int[] startTime, int[] endTime, int queryTime) {\n        int n=endTime.length;\n    int cnt=0;\n        for(int i=0;i<n;i++)\n        {\n            if(endTime[i]>=queryTime && queryTime>=startTime[i] )\n            {\n                cnt++;\n            }\n        }\n        return cnt;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int busyStudent(int[] startTime, int[] endTime, int queryTime) {\\n        int n=endTime.length;\\n    int cnt=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(endTime[i]>=queryTime && queryTime>=startTime[i] )\\n            {\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n}\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\n    public int busyStudent(int[] startTime, int[] endTime, int queryTime) {\n        int n=endTime.length;\n    int cnt=0;\n        for(int i=0;i<n;i++)\n        {\n            if(endTime[i]>=queryTime && queryTime>=startTime[i])\n            {\n                cnt++;\n            }\n            {\n        return cnt;  \n    }\n}\n",
        "explanations": "\nIn the for loop, there is an extra opening curly bracket, leading to a mismatch in parentheses. \n"
    },
    {
        "slug": "find-nearest-point-that-has-the-same-x-or-y-coordinate",
        "description": "You are given two integers, x and y, which represent your current location on a Cartesian grid: (x, y). You are also given an array points where each points[i] = [ai, bi] represents that a point exists at (ai, bi). A point is valid if it shares the same x-coordinate or the same y-coordinate as your location.\nReturn the index (0-indexed) of the valid point with the smallest Manhattan distance from your current location. If there are multiple, return the valid point with the smallest index. If there are no valid points, return -1.\nThe Manhattan distance between two points (x1, y1) and (x2, y2) is abs(x1 - x2) + abs(y1 - y2).",
        "examples": [
            "Input: x = 3, y = 4, points = [[1,2],[3,1],[2,4],[2,3],[4,4]]\nOutput: 2\nExplanation: Of all the points, only [3,1], [2,4] and [4,4] are valid. Of the valid points, [2,4] and [4,4] have the smallest Manhattan distance from your current location, with a distance of 1. [2,4] has the smallest index, so return 2.",
            "Input: x = 3, y = 4, points = [[3,4]]\nOutput: 0\nExplanation: The answer is allowed to be on the same location as your current location.",
            "Input: x = 3, y = 4, points = [[2,3]]\nOutput: -1\nExplanation: There are no valid points."
        ],
        "constraints": "1 <= points.length <= 104\npoints[i].length == 2\n1 <= x, y, ai, bi <= 104",
        "release_time": 1683538037,
        "oracle_code": "class Solution {\n    public int nearestValidPoint(int x, int y, int[][] points) {\n        int minManh = Integer.MAX_VALUE;\n        int indMin = -1;\n        for (int i = 0; i < points.length; i++)\n        {\n            int tmpManh = Math.abs(x - points[i][0]) + Math.abs(y - points[i][1]);\n            if ((x == points[i][0] || y == points[i][1]) && (tmpManh < minManh))\n            {\n                minManh = tmpManh;\n                indMin = i;\n            }\n        }\n        return indMin;\n    }\n}",
        "content": "\\n```\\nclass Solution {\\n    public int nearestValidPoint(int x, int y, int[][] points) {\\n        int minManh = Integer.MAX_VALUE;\\n        int indMin = -1;\\n        for (int i = 0; i < points.length; i++)\\n        {\\n            int tmpManh = Math.abs(x - points[i][0]) + Math.abs(y - points[i][1]);\\n            if ((x == points[i][0] || y == points[i][1]) && (tmpManh < minManh))\\n            {\\n                minManh = tmpManh;\\n                indMin = i;\\n            }\\n        }\\n        return indMin;\\n    }\\n}\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\n    public int nearestValidPoint(int x, int y, int[][] points) {\n        int minManh = Integer.MAX_VALUE;\n        int indMin = -1;\n        for (int i = 0; i < points.length; i++\n        {\n            int tmpManh = Math.abs(x - points[i][0]) + Math.abs(y - points[i][1]);\n            if ((x == points[i][0] || y == points[i][1]) && (tmpManh < minManh))\n            {\n                minManh = tmpManh;\n                indMin = i;\n            }\n        }\n        return indMin;\n    }\n}\n",
        "explanations": "\nThe bug is a missing parenthesis in the for loop, which will cause a compilation error.\n"
    },
    {
        "slug": "minimum-score-triangulation-of-polygon",
        "description": "You have a convex n-sided polygon where each vertex has an integer value. You are given an integer array values where values[i] is the value of the ith vertex (i.e., clockwise order).\nYou will triangulate the polygon into n - 2 triangles. For each triangle, the value of that triangle is the product of the values of its vertices, and the total score of the triangulation is the sum of these values over all n - 2 triangles in the triangulation.\nReturn the smallest possible total score that you can achieve with some triangulation of the polygon.",
        "examples": [
            "Input: values = [1,2,3]\nOutput: 6\nExplanation: The polygon is already triangulated, and the score of the only triangle is 6.",
            "Input: values = [3,7,4,5]\nOutput: 144\nExplanation: There are two triangulations, with possible scores: 3*7*5 + 4*5*7 = 245, or 3*4*5 + 3*4*7 = 144.\nThe minimum score is 144.",
            "Input: values = [1,3,1,4,1,5]\nOutput: 13\nExplanation: The minimum score triangulation has score 1*1*3 + 1*1*4 + 1*1*5 + 1*1*1 = 13."
        ],
        "constraints": "n == values.length\n3 <= n <= 50\n1 <= values[i] <= 100",
        "release_time": 1682753898,
        "oracle_code": "class Solution {\n    int[][] dp;\n    public int minScoreTriangulation(int[] values) {\n        int l=values.length;\n        dp = new int[l][l];\n        for(int[] i : dp) Arrays.fill(i,-1);\n        return solve(values,1,l-1); \n    }\n\n    public int solve(int[] values, int i,int j)\n    {\n        if(i>=j) return 0;\n        if(dp[i][j]!=-1) return dp[i][j];\n        int min=Integer.MAX_VALUE;\n        for(int k=i;k<j;k++)\n        {\n            int temp=solve(values,i,k)+solve(values,k+1,j)+\n                        values[i-1]*values[k]*values[j];\n            min=Math.min(min,temp);\n        }\n\n        return dp[i][j]=min;\n    }\n}",
        "content": "\\n# Complexity\\n- Time complexity: n^2\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: n^2\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int[][] dp;\\n    public int minScoreTriangulation(int[] values) {\\n        int l=values.length;\\n        dp = new int[l][l];\\n        for(int[] i : dp) Arrays.fill(i,-1);\\n        return solve(values,1,l-1); \\n    }\\n\\n    public int solve(int[] values, int i,int j)\\n    {\\n        if(i>=j) return 0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int min=Integer.MAX_VALUE;\\n        for(int k=i;k<j;k++)\\n        {\\n            int temp=solve(values,i,k)+solve(values,k+1,j)+\\n                        values[i-1]*values[k]*values[j];\\n            min=Math.min(min,temp);\\n        }\\n\\n        return dp[i][j]=min;\\n    }\\n}\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\n    int[][] dp;\n    public int minScoreTriangulation(int[] values) {\n        int l=values.length;\n        dp = new int[l][l];\n        for(int[] i : dp) Arrays.fill(i,-1);\n        return solve(values,1,l-1); \n    }\n\n    public int solve(int[] values, int i,int j)\n    {\n        if(i>=j) return 0;\n        if(dp[i][j]!=-1) return dp[i][j];\n        int min=Integer.MAX_VALUE;\n        for(int k=i;k<j;k++)\n        {\n            int temp=solve(values,i,k)+solve(values,k+1,j)\n                        values[i-1]*values[k]*values[j];\n            min=Math.min(min,temp);\n        }\n\n        return dp[i][j]=min;\n    }\n}\n",
        "explanations": "\nMissing '+' operator between the solve and array multiplication statements in the temp calculation.\n"
    },
    {
        "slug": "prime-in-diagonal",
        "description": "You are given a 0-indexed two-dimensional integer array nums.\nReturn the largest prime number that lies on at least one of the diagonals of nums. In case, no prime is present on any of the diagonals, return 0.\nNote that:\n\nAn integer is prime if it is greater than 1 and has no positive integer divisors other than 1 and itself.\nAn integer val is on one of the diagonals of nums if there exists an integer i for which nums[i][i] = val or an i for which nums[i][nums.length - i - 1] = val.\n\n\nIn the above diagram, one diagonal is [1,5,9] and another diagonal is [3,5,7].",
        "examples": [
            "Input: nums = [[1,2,3],[5,6,7],[9,10,11]]\nOutput: 11\nExplanation: The numbers 1, 3, 6, 9, and 11 are the only numbers present on at least one of the diagonals. Since 11 is the largest prime, we return 11.",
            "Input: nums = [[1,2,3],[5,17,7],[9,11,10]]\nOutput: 17\nExplanation: The numbers 1, 3, 9, 10, and 17 are all present on at least one of the diagonals. 17 is the largest prime, so we return 17."
        ],
        "constraints": "1 <= nums.length <= 300\nnums.length == numsi.length\n1 <= nums[i][j]\u00a0<= 4*106",
        "release_time": 1683757802,
        "oracle_code": "class Solution {\n    public int diagonalPrime(int[][] nums) {\n        int n = nums.length;\n        int m = nums[0].length;\n        int maxim = 0;\n        for (int i = 0; i < n; i++) {\n                if (checkPrime(nums[i][i])) {\n                    maxim = Math.max(maxim, nums[i][i]);\n                } \n                if (checkPrime(nums[n-1-i][i])) {\n                    maxim = Math.max(maxim, nums[n - i - 1][i]);\n\n                }\n            \n        }\n        return maxim;\n    }\n    public boolean checkPrime(int k) {\n\n        int count = 0;\n        if (k == 1) {\n            return false;\n        }\n        for (int i = 1; i * i <= k; i++) {\n          if (k % i == 0) {\n              count += 2;\n          }\n      }\n      if (count == 2) {\n          return true; \n      } else {\n          return false;\n      }\n      \n    }\n\n}",
        "content": "**Must read if there is any doubt feel free to ask in comments**\\n\\nSomehow beginners face difficulty to understand the concept at first, but i will try my best to breakdown the question into simpler parts so that there would be ease to understand for beginners.\\n\\n\\n\\n**first we have to check prime number on the diagnol of the matrix.**\\n\\n**Step 1** -> so we make a function to check wether the given number is prime or not\\n\\n**Note** -> there are several functions to checkPrime as a naive/beginner you apply what you have learnt in fundamentals programming but it would not work\\n\\nBut here we have to create a checkPrime no. function that would be  optimized otherwise you will get **TLE** which is **Time Limit Exceeded** error.\\n\\n\\nTo find a prime number what we do firstly? -> find factors\\n\\ne.g\\n Num - > 12\\nfactors -> \\n\\n    **i** -------- **k**\\n    1 * 12 = 12\\n    2 * 6 = 12\\n    3 * 4 = 12\\n    4 * 3 = 12\\n    6 * 2 = 12\\n    12 * 1 = 12\\n\\nwe have total 6 factors \\n\\n**Trivial method: TLE occurs for this coz it isn\\'t optimized.**\\n\\nint count = 0;\\nif (k < 2) {\\n    return false;\\n}\\nfor (int i = 1; i < k; i++) {\\n    if (k % i == 0) {\\n        count++;        \\n    }\\n}\\nif (count == 2) {\\n    return true;\\n} else {\\n    return false;\\n}\\n\\nNow what if I say we do not need to iterate till k if we focus on the pattern we see that after i = 3 same numbers are repeating such as (4,3) despite (3,4) was there already , similarly (6,2) despite (2,6) is there etc...\\n\\nnow what we do is we would iterate our loop from **i to \\u221Ak** or we can write it as **i * i to k** also **so that our i iterate in the range between [1 - 3] so we have to take the square root of k. \\ni.e \\n1 * 12, 2 * 6, 3 * 4 and we get all the 6 factors till i = 3.**\\n\\n\\ne.g\\n Num - > 12\\nfactors -> 1, 2, 3, 4, 6, 12\\n**i ------- k**\\n1 * 12 = 12\\n2 * 6 = 12\\n3 * 4 = 12\\n\\n 4 * 3 = 12\\n 6 * 2 = 12\\n12 * 1 = 12\\n\\nfor (int i = 1; i * i <= k; i++) {\\n    if (k < 2) {\\n    return false;\\n    }\\n    if (k % i == 0) {\\n        count +=2; \\n//count + 2 because 1 * 12 we grab two factors from herethen why we need to go till 12.\\n\\n}\\nif (count == 2) {\\nreturn true\\n} else {\\nreturn false;\\n}\\n}\\n\\n**Now we have converted our problem in \\u221An time complexity.**\\n\\n\\n\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int diagonalPrime(int[][] nums) {\\n        int n = nums.length;\\n        int m = nums[0].length;\\n        int maxim = 0;\\n        for (int i = 0; i < n; i++) {\\n                if (checkPrime(nums[i][i])) {\\n                    maxim = Math.max(maxim, nums[i][i]);\\n                } \\n                if (checkPrime(nums[n-1-i][i])) {\\n                    maxim = Math.max(maxim, nums[n - i - 1][i]);\\n\\n                }\\n            \\n        }\\n        return maxim;\\n    }\\n    public boolean checkPrime(int k) {\\n\\n        int count = 0;\\n        if (k == 1) {\\n            return false;\\n        }\\n        for (int i = 1; i * i <= k; i++) {\\n          if (k % i == 0) {\\n              count += 2;\\n          }\\n      }\\n      if (count == 2) {\\n          return true; \\n      } else {\\n          return false;\\n      }\\n      \\n    }\\n\\n}\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\n    public int diagonalPrime(int[][] nums) {\n        int n = nums.length;\n        int m = nums[0].length;\n        int maxim = 0;\n        for (int i = 0; i < n; i++) {\n                if (checkPrime(nums[i][i])) {\n                    maxim = Math.max(maxim, nums[i][i]);\n                } \n                if (checkPrime(nums[n-1-i][i])) {\n                    maxim = Math.max(maxim, nums[n - i - 1][i]);\n                }\n        return maxim;\n        }\n    }\n    public boolean checkPrime(int k) {\n        int count = 0;\n        if (k == 1) {\n            return false;\n        }\n        for (int i = 1; i * i <= k; i++) {\n          if (k % i == 0) {\n              count += 2;\n          }\n      }\n      if (count == 2) {\n          return true; \n      } else {\n          return false;\n      }\n      \n    }\n}\n",
        "explanations": "\nIn the method \"diagonalPrime\", the return statement is placed inside the for loop.\n"
    },
    {
        "slug": "remove-k-digits",
        "description": "Given string num representing a non-negative integer num, and an integer k, return the smallest possible integer after removing k digits from num.",
        "examples": [
            "Input: num = \"1432219\", k = 3\nOutput: \"1219\"\nExplanation: Remove the three digits 4, 3, and 2 to form the new number 1219 which is the smallest.",
            "Input: num = \"10200\", k = 1\nOutput: \"200\"\nExplanation: Remove the leading 1 and the number is 200. Note that the output must not contain leading zeroes.",
            "Input: num = \"10\", k = 2\nOutput: \"0\"\nExplanation: Remove all the digits from the number and it is left with nothing which is 0."
        ],
        "constraints": "1 <= k <= num.length <= 105\nnum consists of only digits.\nnum does not have any leading zeros except for the zero itself.",
        "release_time": 1680704468,
        "oracle_code": "class Solution {\n    public String removeKdigits(String num, int k) {\n        Stack<Character> st = new Stack<>();\n        for(Character ch : num.toCharArray()) {\n            while(!st.isEmpty() && k > 0 && ch < st.peek()) {\n                st.pop();\n                k--;\n            }\n\n            if(!st.isEmpty() || ch != '0') {\n                st.push(ch);\n            }\n        }\n\n        // This is a special edge case --> 1 2 3 4\n        while(!st.isEmpty() && k-- > 0) {\n            st.pop();\n        }\n        if(st.isEmpty()) return \"0\";\n        \n\n        // Store the ans -->\n        String ans = \"\";\n        while(!st.isEmpty()) {\n            ans = st.peek() + ans;\n            st.pop();\n        }\n        return ans;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n# Code\\n```\\nclass Solution {\\n    public String removeKdigits(String num, int k) {\\n        Stack<Character> st = new Stack<>();\\n        for(Character ch : num.toCharArray()) {\\n            while(!st.isEmpty() && k > 0 && ch < st.peek()) {\\n                st.pop();\\n                k--;\\n            }\\n\\n            if(!st.isEmpty() || ch != \\'0\\') {\\n                st.push(ch);\\n            }\\n        }\\n\\n        // This is a special edge case --> 1 2 3 4\\n        while(!st.isEmpty() && k-- > 0) {\\n            st.pop();\\n        }\\n        if(st.isEmpty()) return \"0\";\\n        \\n\\n        // Store the ans -->\\n        String ans = \"\";\\n        while(!st.isEmpty()) {\\n            ans = st.peek() + ans;\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n}\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\n    public String removeKdigits(String num, int k) {\n        Stack<Character> st = new Stack<>();\n        for(Character ch : num.toCharArray()) {\n            while(!st.isEmpty() && k > 0 && ch < st.peek())\n                st.pop();\n                k--;\n\n            if(!st.isEmpty() || ch != '0') {\n                st.push(ch);\n            }\n        }\n\n        while(!st.isEmpty() && k-- > 0) {\n            st.pop();\n        }\n        if(st.isEmpty()) return \"0\";\n \n        String ans = \"\";\n        while(!st.isEmpty()) {\n            ans = st.peek() + ans;\n            st.pop();\n        }\n        return ans;\n    }\n}\n",
        "explanations": "\nThe second decrement operation on 'k' isn't contained within the while loop's body due to missing braces.\n"
    },
    {
        "slug": "sort-even-and-odd-indices-independently",
        "description": "You are given a 0-indexed integer array nums. Rearrange the values of nums according to the following rules:\n\nSort the values at odd indices of nums in non-increasing order.\n\n\t\nFor example, if nums = [4,1,2,3] before this step, it becomes [4,3,2,1] after. The values at odd indices 1 and 3 are sorted in non-increasing order.\n\n\nSort the values at even indices of nums in non-decreasing order.\n\t\nFor example, if nums = [4,1,2,3] before this step, it becomes [2,1,4,3] after. The values at even indices 0 and 2 are sorted in non-decreasing order.\n\n\n\nReturn the array formed after rearranging the values of nums.",
        "examples": [
            "Input: nums = [4,1,2,3]\nOutput: [2,3,4,1]\nExplanation: \nFirst, we sort the values present at odd indices (1 and 3) in non-increasing order.\nSo, nums changes from [4,1,2,3] to [4,3,2,1].\nNext, we sort the values present at even indices (0 and 2) in non-decreasing order.\nSo, nums changes from [4,1,2,3] to [2,3,4,1].\nThus, the array formed after rearranging the values is [2,3,4,1].",
            "Input: nums = [2,1]\nOutput: [2,1]\nExplanation: \nSince there is exactly one odd index and one even index, no rearrangement of values takes place.\nThe resultant array formed is [2,1], which is the same as the initial array."
        ],
        "constraints": "1 <= nums.length <= 100\n1 <= nums[i] <= 100",
        "release_time": 1678770695,
        "oracle_code": "class Solution {\n    public int[] sortEvenOdd(int[] nums) {\n        PriorityQueue<Integer> queue = new PriorityQueue<>();\n        for(int i=0;i<nums.length;i+=2){\n            queue.add(nums[i]);\n        }\n        for(int i=0;i<nums.length;i+=2){\n            nums[i]=queue.poll();\n        }\n        queue = new PriorityQueue<>(new MaxHeap());\n        for(int i=1;i<nums.length;i+=2){\n            queue.add(nums[i]);\n        }\n        for(int i=1;i<nums.length;i+=2){\n            nums[i]=queue.poll();\n        }\n        return nums;\n    }\n}\nclass MaxHeap implements Comparator<Integer>{\n    public int compare(Integer ca,Integer cb){\n        return cb-ca;\n    }\n}",
        "content": "\\n> # Approach\\nLet\\'s use some data structutes to solve this problem,By adding even indexed numbers into MinHeap we can sort the data in ascending order,By adding odd indexed numbers into Maxheap we can sort the data in descending order. \\n<!-- Describe your approach to solving the problem. -->\\n\\n> # Complexity\\n- Time complexity: O(n log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) for Priority Queue\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n> # Code\\n```\\nclass Solution {\\n    public int[] sortEvenOdd(int[] nums) {\\n        PriorityQueue<Integer> queue = new PriorityQueue<>();\\n        for(int i=0;i<nums.length;i+=2){\\n            queue.add(nums[i]);\\n        }\\n        for(int i=0;i<nums.length;i+=2){\\n            nums[i]=queue.poll();\\n        }\\n        queue = new PriorityQueue<>(new MaxHeap());\\n        for(int i=1;i<nums.length;i+=2){\\n            queue.add(nums[i]);\\n        }\\n        for(int i=1;i<nums.length;i+=2){\\n            nums[i]=queue.poll();\\n        }\\n        return nums;\\n    }\\n}\\nclass MaxHeap implements Comparator<Integer>{\\n    public int compare(Integer ca,Integer cb){\\n        return cb-ca;\\n    }\\n}\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\n    public int[] sortEvenOdd(int[] nums) {\n        PriorityQueue<Integer> queue = new PriorityQueue<>();\n        for(int i=0;i<nums.length;i+=2){\n            queue.add(nums[i]);\n        }\n        for(int i=0;i<nums.length;i+=2){\n            nums[i]=queue.poll();\n        }\n        queue = new PriorityQueue<>(new MaxHeap());\n        for(int i=1;i<nums.length;i+=2){\n            queue.add(nums[i]);\n        for(int i=1;i<nums.length;i+=2){\n            nums[i]=queue.poll();\n        }\n        return nums;\n    }\n}\nclass MaxHeap implements Comparator<Integer>{\n    public int compare(Integer ca,Integer cb){\n        return cb-ca;\n    }\n}  \n",
        "explanations": "\nThere is a missing closing bracket for the third for-loop.\n"
    },
    {
        "slug": "clone-graph",
        "description": "Given a reference of a node in a connected undirected graph.\nReturn a deep copy (clone) of the graph.\nEach node in the graph contains a value (int) and a list (List[Node]) of its neighbors.\n\nclass Node {\n    public int val;\n    public List<Node> neighbors;\n}\n\n\u00a0\nTest case format:\nFor simplicity, each node's value is the same as the node's index (1-indexed). For example, the first node with val == 1, the second node with val == 2, and so on. The graph is represented in the test case using an adjacency list.\nAn adjacency list is a collection of unordered lists used to represent a finite graph. Each list describes the set of neighbors of a node in the graph.\nThe given node will always be the first node with val = 1. You must return the copy of the given node as a reference to the cloned graph.",
        "examples": [
            "Input: adjList = [[2,4],[1,3],[2,4],[1,3]]\nOutput: [[2,4],[1,3],[2,4],[1,3]]\nExplanation: There are 4 nodes in the graph.\n1st node (val = 1)'s neighbors are 2nd node (val = 2) and 4th node (val = 4).\n2nd node (val = 2)'s neighbors are 1st node (val = 1) and 3rd node (val = 3).\n3rd node (val = 3)'s neighbors are 2nd node (val = 2) and 4th node (val = 4).\n4th node (val = 4)'s neighbors are 1st node (val = 1) and 3rd node (val = 3).",
            "Input: adjList = [[]]\nOutput: [[]]\nExplanation: Note that the input contains one empty list. The graph consists of only one node with val = 1 and it does not have any neighbors.",
            "Input: adjList = []\nOutput: []\nExplanation: This an empty graph, it does not have any nodes."
        ],
        "constraints": "The number of nodes in the graph is in the range [0, 100].\n1 <= Node.val <= 100\nNode.val is unique for each node.\nThere are no repeated edges and no self-loops in the graph.\nThe Graph is connected and all nodes can be visited starting from the given node.",
        "release_time": 1680964761,
        "oracle_code": "/*\n// Definition for a Node.\nclass Node {\n    public int val;\n    public List<Node> neighbors;\n    public Node() {\n        val = 0;\n        neighbors = new ArrayList<Node>();\n    }\n    public Node(int _val) {\n        val = _val;\n        neighbors = new ArrayList<Node>();\n    }\n    public Node(int _val, ArrayList<Node> _neighbors) {\n        val = _val;\n        neighbors = _neighbors;\n    }\n}\n*/\n\nclass Solution {\n    public void dfs(Node node, HashMap<Node, Node> dict)\n    {\n        for (Node nd : node.neighbors) {\n            if (!dict.containsKey(nd))\n                dict.put(nd, new Node(nd.val));\n            dict.get(node).neighbors.add(dict.get(nd));\n        }\n        for (Node nd : node.neighbors)\n        {\n            if (dict.get(nd).neighbors.size() == 0)\n                dfs(nd, dict);\n        }\n    }\n    public Node cloneGraph(Node node) {\n        HashMap<Node, Node> dict = new HashMap<>();\n        if (node != null) {\n            dict.put(node, new Node(node.val));\n            dfs(node, dict);\n            return dict.get(node);\n        }\n        return null;\n    }\n}",
        "content": "\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    public int val;\\n    public List<Node> neighbors;\\n    public Node() {\\n        val = 0;\\n        neighbors = new ArrayList<Node>();\\n    }\\n    public Node(int _val) {\\n        val = _val;\\n        neighbors = new ArrayList<Node>();\\n    }\\n    public Node(int _val, ArrayList<Node> _neighbors) {\\n        val = _val;\\n        neighbors = _neighbors;\\n    }\\n}\\n*/\\n\\nclass Solution {\\n    public void dfs(Node node, HashMap<Node, Node> dict)\\n    {\\n        for (Node nd : node.neighbors) {\\n            if (!dict.containsKey(nd))\\n                dict.put(nd, new Node(nd.val));\\n            dict.get(node).neighbors.add(dict.get(nd));\\n        }\\n        for (Node nd : node.neighbors)\\n        {\\n            if (dict.get(nd).neighbors.size() == 0)\\n                dfs(nd, dict);\\n        }\\n    }\\n    public Node cloneGraph(Node node) {\\n        HashMap<Node, Node> dict = new HashMap<>();\\n        if (node != null) {\\n            dict.put(node, new Node(node.val));\\n            dfs(node, dict);\\n            return dict.get(node);\\n        }\\n        return null;\\n    }\\n}\\n```",
        "level": "medium",
        "buggy_code": "\n/*\n// Definition for a Node.\nclass Node {\n    public int val;\n    public List<Node> neighbors;\n    public Node() {\n        val = 0;\n        neighbors = new ArrayList<Node>();\n    }\n    public Node(int _val) {\n        val = _val;\n        neighbors = new ArrayList<Node>();\n    }\n    public Node(int _val, ArrayList<Node> _neighbors) {\n        val = _val;\n        neighbors = _neighbors;\n    }\n}\n*/\n\nclass Solution {\n    public void dfs(Node node, HashMap<Node, Node> dict)\n    {\n        for (Node nd : node.neighbors) {\n            if (!dict.containsKey(nd))\n                dict.put(nd, new Node(nd.val));\n            dict.get(node).neighbors.add(dict.get(nd);\n        }\n        for (Node nd : node.neighbors)\n        {\n            if (dict.get(nd).neighbors.size() == 0)\n                dfs(nd, dict);\n        }\n    }\n    public Node cloneGraph(Node node) {\n        HashMap<Node, Node> dict = new HashMap<>();\n        if (node != null) {\n            dict.put(node, new Node(node.val));\n            dfs(node, dict);\n            return dict.get(node);\n        }\n        return null;\n    }\n}\n",
        "explanations": "\nThe parentheses mismatch at the add method produce a syntax error which will cause unexpected behavior.\n"
    },
    {
        "slug": "relative-ranks",
        "description": "You are given an integer array score of size n, where score[i] is the score of the ith athlete in a competition. All the scores are guaranteed to be unique.\nThe athletes are placed based on their scores, where the 1st place athlete has the highest score, the 2nd place athlete has the 2nd highest score, and so on. The placement of each athlete determines their rank:\n\nThe 1st place athlete's rank is \"Gold Medal\".\nThe 2nd place athlete's rank is \"Silver Medal\".\nThe 3rd place athlete's rank is \"Bronze Medal\".\nFor the 4th place to the nth place athlete, their rank is their placement number (i.e., the xth place athlete's rank is \"x\").\n\nReturn an array answer of size n where answer[i] is the rank of the ith athlete.",
        "examples": [
            "Input: score = [5,4,3,2,1]\nOutput: [\"Gold Medal\",\"Silver Medal\",\"Bronze Medal\",\"4\",\"5\"]\nExplanation: The placements are [1st, 2nd, 3rd, 4th, 5th].",
            "Input: score = [10,3,8,9,4]\nOutput: [\"Gold Medal\",\"5\",\"Bronze Medal\",\"Silver Medal\",\"4\"]\nExplanation: The placements are [1st, 5th, 3rd, 2nd, 4th]."
        ],
        "constraints": "n == score.length\n1 <= n <= 104\n0 <= score[i] <= 106\nAll the values in score are unique.",
        "release_time": 1683184626,
        "oracle_code": "class Solution {\n    public String[] findRelativeRanks(int[] score) {\n         int n=score.length;\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[b]-score[a]);\n        for(int i=0;i<n;i++) pq.add(i);\n      String[] ans = new String[n];\n                int i=1;\n        while(!pq.isEmpty()){\n            int idx=pq.poll();\n         if(i==1)   { ans[idx]=\"Gold Medal\"; i++;}\n         else if(i==2)   { ans[idx]=\"Silver Medal\"; i++;}\n         else if(i==3)   { ans[idx]=\"Bronze Medal\"; i++;}\n         else ans[idx]=Integer.toString(i++);\n        }\n        return ans;  \n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String[] findRelativeRanks(int[] score) {\\n         int n=score.length;\\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[b]-score[a]);\\n        for(int i=0;i<n;i++) pq.add(i);\\n      String[] ans = new String[n];\\n                int i=1;\\n        while(!pq.isEmpty()){\\n            int idx=pq.poll();\\n         if(i==1)   { ans[idx]=\"Gold Medal\"; i++;}\\n         else if(i==2)   { ans[idx]=\"Silver Medal\"; i++;}\\n         else if(i==3)   { ans[idx]=\"Bronze Medal\"; i++;}\\n         else ans[idx]=Integer.toString(i++);\\n        }\\n        return ans;  \\n    }\\n}\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\n    public String[] findRelativeRanks(int[] score) {\n         int n=score.length;\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[b]-score[a]);\n        for(int i=0;i<n;i++) pq.add(i);\n      String[] ans = new String[n];\n                int i=1;\n        while(!pq.isEmpty()){\n            int idx=pq.poll();\n         if(i=1)   { ans[idx]=\"Gold Medal\"; i++;}\n         else if(i=2)   { ans[idx]=\"Silver Medal\"; i++;}\n         else if(i=3)   { ans[idx]=\"Bronze Medal\"; i++;}\n         else ans[idx]=Integer.toString(i++);\n        }\n        return ans;  \n    }\n}\n",
        "explanations": "\nThe equality (==) operator in statements has been replaced by assignment (=) operator.\n"
    },
    {
        "slug": "h-index-ii",
        "description": "Given an array of integers citations where citations[i] is the number of citations a researcher received for their ith paper and citations is sorted in ascending order, return the researcher's h-index.\nAccording to the definition of h-index on Wikipedia: The h-index is defined as the maximum value of h such that the given researcher has published at least h papers that have each been cited at least h times.\nYou must write an algorithm that runs in logarithmic time.",
        "examples": [
            "Input: citations = [0,1,3,5,6]\nOutput: 3\nExplanation: [0,1,3,5,6] means the researcher has 5 papers in total and each of them had received 0, 1, 3, 5, 6 citations respectively.\nSince the researcher has 3 papers with at least 3 citations each and the remaining two with no more than 3 citations each, their h-index is 3.",
            "Input: citations = [1,2,100]\nOutput: 2"
        ],
        "constraints": "n == citations.length\n1 <= n <= 105\n0 <= citations[i] <= 1000\ncitations is sorted in ascending order.",
        "release_time": 1689538082,
        "oracle_code": "class Solution {\n    public int hIndex(int[] citations) {\n        // O(n) Time Complexity\n        // int n = citations.length;\n        // int index = 0;\n        // while(index < n && n - index > citations[index]){\n        //     index++;\n        // }\n        // return n - index;\n\n        // O(logn) Time Complexity // Binary Search:- Since Sorted Array\n        int left = 0, right = citations.length - 1;\n        int n = citations.length;\n        while(left <= right){\n            int mid = left + (right - left) / 2;\n            if(citations[mid] == n - mid) return n - mid;\n            else if(citations[mid] < n - mid) left = mid + 1;\n            else right = mid - 1;\n        }\n        return n - left;\n    }\n}",
        "content": "# Complexity\\n- Time complexity: $$O(logn)$$ \\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int hIndex(int[] citations) {\\n        // O(n) Time Complexity\\n        // int n = citations.length;\\n        // int index = 0;\\n        // while(index < n && n - index > citations[index]){\\n        //     index++;\\n        // }\\n        // return n - index;\\n\\n        // O(logn) Time Complexity // Binary Search:- Since Sorted Array\\n        int left = 0, right = citations.length - 1;\\n        int n = citations.length;\\n        while(left <= right){\\n            int mid = left + (right - left) / 2;\\n            if(citations[mid] == n - mid) return n - mid;\\n            else if(citations[mid] < n - mid) left = mid + 1;\\n            else right = mid - 1;\\n        }\\n        return n - left;\\n    }\\n}\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\n    public int hIndex(int[] citations) {\n        // O(n) Time Complexity\n        // int n = citations.length;\n        // int index = 0;\n        // while(index < n && n - index > citations[index]){\n        //     index++;\n        // }\n        // return n - index;\n\n        // O(logn) Time Complexity // Binary Search:- Since Sorted Array\n        int left = 0, right = citations.length - 1;\n        int n = citations.length;\n        while(left <= right){\n            int mid = left + (right - left) / 2;\n            if(citations[mid] == n - mid) return n - mid;\n            else if(citations[mid] < n - mid) left = mid + 1;\n            else right = mid - 1;\n        return n - left;\n    }\n}\n",
        "explanations": "\nThe while loop's closing brace is missing which causes a mismatched indentation error.\n"
    },
    {
        "slug": "non-decreasing-subsequences",
        "description": "Given an integer array nums, return all the different possible non-decreasing subsequences of the given array with at least two elements. You may return the answer in any order.",
        "examples": [
            "Input: nums = [4,6,7,7]\nOutput: [[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]",
            "Input: nums = [4,4,3,2,1]\nOutput: [[4,4]]"
        ],
        "constraints": "1 <= nums.length <= 15\n-100 <= nums[i] <= 100",
        "release_time": 1674187609,
        "oracle_code": "class Solution {\n    List<List<Integer>>vec=new ArrayList<>();\n    HashSet<List<Integer>>set=new HashSet<>();\n    void solve(int []nums, int prev, List<Integer>op, int idx){\n        if(idx==nums.length){\n            if(op.size()>1){\n                set.add(op);\n            }\n            return;\n        }\n        if(prev==-1 || nums[idx]>=nums[prev]){\n            List<Integer>op1=new ArrayList<>(op);\n            op1.add(nums[idx]);\n            solve(nums,idx,op1,idx+1);\n        }\n        solve(nums,prev,op,idx+1);\n        \n    }\n    public List<List<Integer>> findSubsequences(int[] nums) {\n        List<Integer>op=new ArrayList<>();\n        solve(nums,-1,op, 0);\n        Iterator<List<Integer>> it = set.iterator();\n        while(it.hasNext())vec.add(it.next());\n        return vec;\n    }\n}",
        "content": "\\n\\n\\n```\\nclass Solution {\\n    List<List<Integer>>vec=new ArrayList<>();\\n    HashSet<List<Integer>>set=new HashSet<>();\\n    void solve(int []nums, int prev, List<Integer>op, int idx){\\n        if(idx==nums.length){\\n            if(op.size()>1){\\n                set.add(op);\\n            }\\n            return;\\n        }\\n        if(prev==-1 || nums[idx]>=nums[prev]){\\n            List<Integer>op1=new ArrayList<>(op);\\n            op1.add(nums[idx]);\\n            solve(nums,idx,op1,idx+1);\\n        }\\n        solve(nums,prev,op,idx+1);\\n        \\n    }\\n    public List<List<Integer>> findSubsequences(int[] nums) {\\n        List<Integer>op=new ArrayList<>();\\n        solve(nums,-1,op, 0);\\n        Iterator<List<Integer>> it = set.iterator();\\n        while(it.hasNext())vec.add(it.next());\\n        return vec;\\n    }\\n}\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\n    List<List<Integer>>vec=new ArrayList<>();\n    HashSet<List<Integer>>set=new HashSet<>();\n    void solve(int []nums, int prev, List<Integer>op, int idx{\n        if(idx==nums.length){\n            if(op.size()>1){\n                set.add(op);\n            }\n            return;\n        }\n        if(prev==-1 || nums[idx]>=nums[prev]){\n            List<Integer>op1=new ArrayList<>(op);\n            op1.add(nums[idx]);\n            solve(nums,idx,op1,idx+1);\n        }\n        solve(nums,prev,op,idx+1);\n        \n    }\n    public List<List<Integer>> findSubsequences(int[] nums) {\n        List<Integer>op=new ArrayList<>();\n        solve(nums,-1,op, 0);\n        Iterator<List<Integer>> it = set.iterator();\n        while(it.hasNext())vec.add(it.next());\n        return vec;\n    }\n}\n",
        "explanations": "\nThe bug is on the method declaration 'solve'. A closing parenthesis missing after 'idx'.\n"
    },
    {
        "slug": "binary-search-tree-iterator",
        "description": "Implement the BSTIterator class that represents an iterator over the in-order traversal of a binary search tree (BST):\n\nBSTIterator(TreeNode root) Initializes an object of the BSTIterator class. The root of the BST is given as part of the constructor. The pointer should be initialized to a non-existent number smaller than any element in the BST.\nboolean hasNext() Returns true if there exists a number in the traversal to the right of the pointer, otherwise returns false.\nint next() Moves the pointer to the right, then returns the number at the pointer.\n\nNotice that by initializing the pointer to a non-existent smallest number, the first call to next() will return the smallest element in the BST.\nYou may assume that next() calls will always be valid. That is, there will be at least a next number in the in-order traversal when next() is called.",
        "examples": [
            "Input\n[\"BSTIterator\", \"next\", \"next\", \"hasNext\", \"next\", \"hasNext\", \"next\", \"hasNext\", \"next\", \"hasNext\"]\n[[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []]\nOutput\n[null, 3, 7, true, 9, true, 15, true, 20, false]\n\nExplanation\nBSTIterator bSTIterator = new BSTIterator([7, 3, 15, null, null, 9, 20]);\nbSTIterator.next();    // return 3\nbSTIterator.next();    // return 7\nbSTIterator.hasNext(); // return True\nbSTIterator.next();    // return 9\nbSTIterator.hasNext(); // return True\nbSTIterator.next();    // return 15\nbSTIterator.hasNext(); // return True\nbSTIterator.next();    // return 20\nbSTIterator.hasNext(); // return False"
        ],
        "constraints": "The number of nodes in the tree is in the range [1, 105].\n0 <= Node.val <= 106\nAt most 105 calls will be made to hasNext, and next.",
        "release_time": 1678769853,
        "oracle_code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass BSTIterator {\n    Stack<TreeNode>s=new Stack<TreeNode>();\n    public BSTIterator(TreeNode root) {\n        pushAll(root);\n    }\n    \n    public int next() {\n        TreeNode temp=s.pop();\n        pushAll(temp.right);\n        return temp.val;\n    }\n    \n    public boolean hasNext() {\n        return !s.isEmpty();\n    }\n    public void pushAll(TreeNode node){\n        while(node!=null){\n            s.push(node);\n            node=node.left;\n        }\n    }\n}\n\n/**\n * Your BSTIterator object will be instantiated and called as such:\n * BSTIterator obj = new BSTIterator(root);\n * int param_1 = obj.next();\n * boolean param_2 = obj.hasNext();\n */",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(H)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass BSTIterator {\\n    Stack<TreeNode>s=new Stack<TreeNode>();\\n    public BSTIterator(TreeNode root) {\\n        pushAll(root);\\n    }\\n    \\n    public int next() {\\n        TreeNode temp=s.pop();\\n        pushAll(temp.right);\\n        return temp.val;\\n    }\\n    \\n    public boolean hasNext() {\\n        return !s.isEmpty();\\n    }\\n    public void pushAll(TreeNode node){\\n        while(node!=null){\\n            s.push(node);\\n            node=node.left;\\n        }\\n    }\\n}\\n\\n/**\\n * Your BSTIterator object will be instantiated and called as such:\\n * BSTIterator obj = new BSTIterator(root);\\n * int param_1 = obj.next();\\n * boolean param_2 = obj.hasNext();\\n */\\n```",
        "level": "medium",
        "buggy_code": "\nclass BSTIterator {\n    Stack<TreeNode>s=new Stack<TreeNode>();\n    public BSTIterator(TreeNode root) {\n        pushAll(root);\n    }\n    \n    public int next() {\n        TreeNode temp=s.pop();\n        pushAll(temp.right);\n        return temp.val;\n    }\n    \n    public boolean hasNext() {\n        return !s.isEmpty();\n    }\n    public void pushAll(TreeNode node){\n        while(node!=null{\n            s.push(node);\n            node=node.left;\n        }\n    }\n}\n\n/**\n * Your BSTIterator object will be instantiated and called as such:\n * BSTIterator obj = new BSTIterator(root);\n * int param_1 = obj.next();\n * boolean param_2 = obj.hasNext();\n */\n",
        "explanations": "\nThere is a missing closing parenthesis in the condition of the while loop in pushAll method.\n"
    },
    {
        "slug": "construct-binary-tree-from-inorder-and-postorder-traversal",
        "description": "Given two integer arrays inorder and postorder where inorder is the inorder traversal of a binary tree and postorder is the postorder traversal of the same tree, construct and return the binary tree.",
        "examples": [
            "Input: inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]\nOutput: [3,9,20,null,null,15,7]",
            "Input: inorder = [-1], postorder = [-1]\nOutput: [-1]"
        ],
        "constraints": "1 <= inorder.length <= 3000\npostorder.length == inorder.length\n-3000 <= inorder[i], postorder[i] <= 3000\ninorder and postorder consist of unique values.\nEach value of postorder also appears in inorder.\ninorder is guaranteed to be the inorder traversal of the tree.\npostorder is guaranteed to be the postorder traversal of the tree.",
        "release_time": 1689531937,
        "oracle_code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    int index;\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\n        Map<Integer, Integer> m = new HashMap<>();\n\n        for(int i = 0; i < inorder.length; i++) {\n            m.put(inorder[i], i);\n        }\n        index = postorder.length - 1;\n        return buildTree(0, postorder.length - 1, postorder, m);\n    }\n\n    private TreeNode buildTree(int l, int r, int postorder[] , Map<Integer, Integer> m) {\n        if(l > r) return null;\n\n        int val = postorder[index];\n        index--;\n\n        TreeNode root = new TreeNode(val);\n        if(l == r) return root;\n\n        int in = m.get(val);\n\n        root.right = buildTree(in + 1, r, postorder, m);\n        root.left = buildTree(l, in - 1, postorder, m);\n\n        return root;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int index;\\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\\n        Map<Integer, Integer> m = new HashMap<>();\\n\\n        for(int i = 0; i < inorder.length; i++) {\\n            m.put(inorder[i], i);\\n        }\\n        index = postorder.length - 1;\\n        return buildTree(0, postorder.length - 1, postorder, m);\\n    }\\n\\n    private TreeNode buildTree(int l, int r, int postorder[] , Map<Integer, Integer> m) {\\n        if(l > r) return null;\\n\\n        int val = postorder[index];\\n        index--;\\n\\n        TreeNode root = new TreeNode(val);\\n        if(l == r) return root;\\n\\n        int in = m.get(val);\\n\\n        root.right = buildTree(in + 1, r, postorder, m);\\n        root.left = buildTree(l, in - 1, postorder, m);\\n\\n        return root;\\n    }\\n}\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\n    int index;\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\n        Map<Integer, Integer> m = new HashMap<>();\n\n        for(int i = 0; i < inorder.length; i++) {\n            m.put(inorder[i], i);\n        }\n        index = postorder.length - 1;\n        return buildTree(0, postorder.length - 1, postorder, m;\n    }\n\n    private TreeNode buildTree(int l, int r, int postorder[] , Map<Integer, Integer> m) {\n        if(l > r) return null;\n\n        int val = postorder[index];\n        index--;\n\n        TreeNode root = new TreeNode(val);\n        if(l == r) return root;\n\n        int in = m.get(val);\n\n        root.right = buildTree(in + 1, r, postorder, m);\n        root.left = buildTree(l, in - 1, postorder, m);\n\n        return root;\n    }\n}\n",
        "explanations": "\nThere is a missing parenthesis in the method call to buildTree within the buildTree function.\n"
    },
    {
        "slug": "minimum-number-of-swaps-to-make-the-string-balanced",
        "description": "You are given a 0-indexed string s of even length n. The string consists of exactly n / 2 opening brackets '[' and n / 2 closing brackets ']'.\nA string is called balanced if and only if:\n\nIt is the empty string, or\nIt can be written as AB, where both A and B are balanced strings, or\nIt can be written as [C], where C is a balanced string.\n\nYou may swap the brackets at any two indices any number of times.\nReturn the minimum number of swaps to make s balanced.",
        "examples": [
            "Input: s = \"][][\"\nOutput: 1\nExplanation: You can make the string balanced by swapping index 0 with index 3.\nThe resulting string is \"[[]]\".",
            "Input: s = \"]]][[[\"\nOutput: 2\nExplanation: You can do the following to make the string balanced:\n- Swap index 0 with index 4. s = \"[]][][\".\n- Swap index 1 with index 5. s = \"[[][]]\".\nThe resulting string is \"[[][]]\".",
            "Input: s = \"[]\"\nOutput: 0\nExplanation: The string is already balanced."
        ],
        "constraints": "n == s.length\n2 <= n <= 106\nn is even.\ns[i] is either '[' or ']'.\nThe number of opening brackets '[' equals n / 2, and the number of closing brackets ']' equals n / 2.",
        "release_time": 1686334819,
        "oracle_code": "class Solution {\n    public int minSwaps(String s) {\n        return util1(s);\n    }\n    public int util1(String str) {\n        Stack<Character> s = new Stack<>();\n        for (int i = 0; i < str.length(); i++) {\n            if (str.charAt(i) == '[') {\n                s.push(str.charAt(i));\n            } else {\n                if (s.isEmpty() == false && s.peek() == '[') {\n                    s.pop();\n                } else {\n                    s.push(str.charAt(i));\n                }\n            }\n        }\n        double pairs = s.size() / 2;\n        double a = pairs / 2.0;\n        int ans = (int) Math.ceil(a);\n        return ans;\n    }\n}",
        "content": "the trick behind is fairly easy\\n\\nfor the number of pairs which are not correct, the amount of swaps required to make them correct is Math.ceil(a), where a is the number of pairs which are not correct.\\n\\nfor eg\\nfor 5 incorrect pairs, we need 3 swaps\\nfor 3 incorrect pairs, we need 2 swaps\\nfor 2 incorrect pairs, we need 1 swap\\n\\nso simply, \\nwe need to firstly write code to remove all the valid pairs, that ways only the pairs which are incorrect will be in the stack\\nthen we simply do the calculations.\\n\\nrest the code should be self explanatory.\\n\\n# Code\\n```\\nclass Solution {\\n    public int minSwaps(String s) {\\n        return util1(s);\\n    }\\n    public int util1(String str) {\\n        Stack<Character> s = new Stack<>();\\n        for (int i = 0; i < str.length(); i++) {\\n            if (str.charAt(i) == \\'[\\') {\\n                s.push(str.charAt(i));\\n            } else {\\n                if (s.isEmpty() == false && s.peek() == \\'[\\') {\\n                    s.pop();\\n                } else {\\n                    s.push(str.charAt(i));\\n                }\\n            }\\n        }\\n        double pairs = s.size() / 2;\\n        double a = pairs / 2.0;\\n        int ans = (int) Math.ceil(a);\\n        return ans;\\n    }\\n}\\n```\\nyou can check out my github repository where i am uploading famous interview questions topic wise with solutions.\\nlink-- https://github.com/Abhaydutt2003/DataStructureAndAlgoPractice \\nkindly upvote if you like my solution. you can ask doubts below.\\n    \\n",
        "level": "medium",
        "buggy_code": "\nclass Solution {\n    public int minSwaps(String s) {\n        return util1(s;\n    }\n    public int util1(String str) {\n        Stack<Character> s = new Stack<>();\n        for (int i = 0; i < str.length(); i++) {\n            if (str.charAt(i) == '[') {\n                s.push(str.charAt(i));\n            } else {\n                if (s.isEmpty() == false && s.peek() == '[') {\n                    s.pop();\n                } else {\n                    s.push(str.charAt(i));\n                }\n            }\n        }\n        double pairs = s.size() / 2;\n        double a = pairs / 2.0;\n        int ans = (int) Math.ceil(a);\n        return ans;\n    }\n}\n",
        "explanations": "\nI misplaced the closing parenthesis in the method call \"util1(s;\" leading to compilation error.\n"
    },
    {
        "slug": "count-number-of-pairs-with-absolute-difference-k",
        "description": "Given an integer array nums and an integer k, return the number of pairs (i, j) where i < j such that |nums[i] - nums[j]| == k.\nThe value of |x| is defined as:\n\nx if x >= 0.\n-x if x < 0.",
        "examples": [
            "Input: nums = [1,2,2,1], k = 1\nOutput: 4\nExplanation: The pairs with an absolute difference of 1 are:\n- [1,2,2,1]\n- [1,2,2,1]\n- [1,2,2,1]\n- [1,2,2,1]",
            "Input: nums = [1,3], k = 3\nOutput: 0\nExplanation: There are no pairs with an absolute difference of 3.",
            "Input: nums = [3,2,1,5,4], k = 2\nOutput: 3\nExplanation: The pairs with an absolute difference of 2 are:\n- [3,2,1,5,4]\n- [3,2,1,5,4]\n- [3,2,1,5,4]"
        ],
        "constraints": "1 <= nums.length <= 200\n1 <= nums[i] <= 100\n1 <= k <= 99",
        "release_time": 1677159545,
        "oracle_code": "class Solution {\n    public int countKDifference(int[] nums, int k) {\n       int ans = 0;\n\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (Math.abs(nums[i] - nums[j]) == k) {\n                    ans++;\n                }\n            }\n        }\n        return ans;\n    }\n}",
        "content": "\\n# Complexity\\n- Time complexity:\\nO(N^2)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int countKDifference(int[] nums, int k) {\\n       int ans = 0;\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            for (int j = i + 1; j < nums.length; j++) {\\n                if (Math.abs(nums[i] - nums[j]) == k) {\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\nplease upvote, if u like this solution!",
        "level": "easy",
        "buggy_code": "\nclass Solution {\n    public int countKDifference(int[] nums, int k) {\n       int ans = 0;\n\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (Math.abs(nums[i] - nums[j] == k)) {\n                    ans++;\n                }\n            }\n        }\n        return ans;\n    }\n}\n",
        "explanations": "\nMade the parenthesis mismatch in the if condition, causing an error in the comparison.\n"
    },
    {
        "slug": "find-first-palindromic-string-in-the-array",
        "description": "Given an array of strings words, return the first palindromic string in the array. If there is no such string, return an empty string \"\".\nA string is palindromic if it reads the same forward and backward.",
        "examples": [
            "Input: words = [\"abc\",\"car\",\"ada\",\"racecar\",\"cool\"]\nOutput: \"ada\"\nExplanation: The first string that is palindromic is \"ada\".\nNote that \"racecar\" is also palindromic, but it is not the first.",
            "Input: words = [\"notapalindrome\",\"racecar\"]\nOutput: \"racecar\"\nExplanation: The first and only string that is palindromic is \"racecar\".",
            "Input: words = [\"def\",\"ghi\"]\nOutput: \"\"\nExplanation: There are no palindromic strings, so the empty string is returned."
        ],
        "constraints": "1 <= words.length <= 100\n1 <= words[i].length <= 100\nwords[i] consists only of lowercase English letters.",
        "release_time": 1669373945,
        "oracle_code": "class Solution {\n    public String firstPalindrome(String[] words) {\n        for (String s : words) {\n            if (isPalindrome(s)) return s;\n        }\n\n        return \"\";\n    }\n\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n\n        while (i < j) {\n            if (s.charAt(i++) != s.charAt(j--)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n}\n\n// TC: O(n * k), SC: O(1)\n// n -> length of words\n// k -> length of longest string in words",
        "content": "### **Please Upvote** :D\\n##### 1. By checking if its a palindrome using two pointers:\\n```\\nclass Solution {\\n    public String firstPalindrome(String[] words) {\\n        for (String s : words) {\\n            if (isPalindrome(s)) return s;\\n        }\\n\\n        return \"\";\\n    }\\n\\n    public boolean isPalindrome(String s) {\\n        int i = 0, j = s.length() - 1;\\n\\n        while (i < j) {\\n            if (s.charAt(i++) != s.charAt(j--)) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n\\n// TC: O(n * k), SC: O(1)\\n// n -> length of words\\n// k -> length of longest string in words\\n```\\n##### 2. Using strinbuilder to reverse the strings and compare:\\n```\\nclass Solution {\\n    public String firstPalindrome(String[] words) {\\n        for (String s : words){\\n            StringBuilder sb = new StringBuilder();\\n            sb.append(s).reverse();\\n\\n            if (s.equals(sb.toString())){\\n                return s;\\n            }\\n        }\\n\\n        return \"\";\\n    }\\n}\\n\\n// TC: O(n * k), SC: O(1)\\n// n -> length of words\\n// k -> length of longest string in words\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\n    public String firstPalindrome(String[] words) {\n        for (String s : words) {\n            if (isPalindrome(s) return s;\n        }\n\n        return \"\";\n    }\n\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n\n        while (i < j) {\n            if (s.charAt(i++) != s.charAt(j--)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n}\n",
        "explanations": "\nThe method call isPalindrome(s) is missing a closing parenthesis, causing a syntax error.\n"
    },
    {
        "slug": "tuple-with-same-product",
        "description": "Given an array nums of distinct positive integers, return the number of tuples (a, b, c, d) such that a * b = c * d where a, b, c, and d are elements of nums, and a != b != c != d.",
        "examples": [
            "Input: nums = [2,3,4,6]\nOutput: 8\nExplanation: There are 8 valid tuples:\n(2,6,3,4) , (2,6,4,3) , (6,2,3,4) , (6,2,4,3)\n(3,4,2,6) , (4,3,2,6) , (3,4,6,2) , (4,3,6,2)",
            "Input: nums = [1,2,4,5,10]\nOutput: 16\nExplanation: There are 16 valid tuples:\n(1,10,2,5) , (1,10,5,2) , (10,1,2,5) , (10,1,5,2)\n(2,5,1,10) , (2,5,10,1) , (5,2,1,10) , (5,2,10,1)\n(2,10,4,5) , (2,10,5,4) , (10,2,4,5) , (10,2,5,4)\n(4,5,2,10) , (4,5,10,2) , (5,4,2,10) , (5,4,10,2)"
        ],
        "constraints": "1 <= nums.length <= 1000\n1 <= nums[i] <= 104\nAll elements in nums are distinct.",
        "release_time": 1661554822,
        "oracle_code": "class Solution {\n    public int tupleSameProduct(int[] nums) {\n        int m = nums.length;\n        int factor = 0;\n        HashMap<Integer, Integer> hm = new HashMap<>();\n        for(int i = 0; i < m - 1; i ++) {\n            for(int j = i + 1; j < m; j ++) {\n                int curNumber = nums[i] * nums[j];\n                int curNumberCount = (hm.containsKey(curNumber)) ? hm.get(curNumber) + 1 : 1;\n                hm.put(curNumber, curNumberCount);\n            }\n        }\n        \n\t\t// check the qty of number, and we can get n * (n - 1) / 2 compositions\n\t\t\n        for(Integer key: hm.keySet()) {\n            int count = hm.get(key);\n            if(count == 1) continue;\n            factor += count * (count - 1) / 2;\n        }\n        return factor * 8;\n    }\n}",
        "content": "```\\nclass Solution {\\n    public int tupleSameProduct(int[] nums) {\\n        int m = nums.length;\\n        int factor = 0;\\n        HashMap<Integer, Integer> hm = new HashMap<>();\\n        for(int i = 0; i < m - 1; i ++) {\\n            for(int j = i + 1; j < m; j ++) {\\n                int curNumber = nums[i] * nums[j];\\n                int curNumberCount = (hm.containsKey(curNumber)) ? hm.get(curNumber) + 1 : 1;\\n                hm.put(curNumber, curNumberCount);\\n            }\\n        }\\n        \\n\\t\\t// check the qty of number, and we can get n * (n - 1) / 2 compositions\\n\\t\\t\\n        for(Integer key: hm.keySet()) {\\n            int count = hm.get(key);\\n            if(count == 1) continue;\\n            factor += count * (count - 1) / 2;\\n        }\\n        return factor * 8;\\n    }\\n}\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\n    public int tupleSameProduct(int[] nums) {\n        int m = nums.length;\n        int factor = 0;\n        HashMap<Integer, Integer> hm = new HashMap<>();\n        for(int i = 0; i < m - 1; i ++) {\n            for(int j = i + 1; j < m; j ++) {\n                int curNumber = nums[i] * nums[j];\n                int curNumberCount = (hm.containsKey(curNumber)) ? hm.get(curNumber) + 1 : 1;\n                hm.put(curNumber, curNumberCount;\n            }\n        }\n        \n\t\t// check the qty of number, and we can get n * (n - 1) / 2 compositions\n\t\t\n        for(Integer key: hm.keySet()) {\n            int count = hm.get(key);\n            if(count == 1) continue;\n            factor += count * (count - 1) / 2;\n        }\n        return factor * 8;\n    }\n}\n",
        "explanations": "\nClosing parenthesis is missing in the line where `curNumberCount` is being put into the HashMap `hm`.\n"
    },
    {
        "slug": "trapping-rain-water",
        "description": "Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.",
        "examples": [
            "Input: height = [0,1,0,2,1,0,1,3,2,1,2,1]\nOutput: 6\nExplanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.",
            "Input: height = [4,2,0,3,2,5]\nOutput: 9"
        ],
        "constraints": "n == height.length\n1 <= n <= 2 * 104\n0 <= height[i] <= 105",
        "release_time": 1683960844,
        "oracle_code": "class Solution \n{\n    public int trap(int[] height) \n    {\n        int result = 0;\n        if(height==null || height.length<=2)\n            return result;\n        int left[] = new int[height.length];\n        int right[]= new int[height.length];\n        //scan from left to right\n        int max = height[0];\n        left[0] = height[0];\n        for(int i=1; i<height.length; i++)\n        {\n            if(height[i]<max)\n            {\n                left[i]=max;\n            }\n            else\n            {\n                left[i]=height[i];\n                max = height[i];\n            }\n        }\n        //scan from right to left\n        max = height[height.length-1];\n        right[height.length-1]=height[height.length-1];\n        for(int i=height.length-2; i>=0; i--)\n        {\n            if(height[i]<max)\n            {\n                right[i]=max;  \n            }\n            else\n            {  \n                right[i]=height[i];\n                max = height[i];\n            }\n        }\n    \n        for(int i=0; i<height.length; i++)\n        {\n            result+= Math.min(left[i],right[i])-height[i];\n        }\n        return result;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo calculate the trapped rainwater, we need to determine the effective height at each bar. The effective height at a specific bar is the minimum of the maximum heights on its left and right sides. The trapped rainwater can be calculated as the difference between the effective height and the actual height of each bar.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Check if the height array is null or has fewer than 2 elements. If so, return 0 since there are not enough bars to trap any rainwater.\\n2. Initialize a variable result to keep track of the total trapped rainwater.\\n3. Create two arrays, left and right, each with the same length as the height array. These arrays will store the maximum heights on the left and right sides of each bar, respectively.\\n4. Scan the height array from left to right:\\n- Initialize a variable max to store the maximum height encountered so far, starting with the height of the first bar.\\n- For each bar at index i, compare its height with the current max:\\n1. If the height of the current bar is less than the current max, set left[i] to max, indicating that the maximum height on the left side is still max.\\n1. Otherwise, update left[i] and max to the height of the current bar since it becomes the new maximum height encountered so far.\\n5. Scan the height array from right to left (similar to step 4) to populate the right array with the maximum heights on the right side of each bar.\\n6. Iterate over the height array:\\n- For each bar at index i, calculate the trapped rainwater by subtracting the actual height (height[i]) from the minimum of the maximum heights on the left and right sides (Math.min(left[i], right[i])).\\n- Add the calculated trapped rainwater to the result variable.\\n7. Return the final result which represents the total trapped rainwater.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the code is O(n), where n is the length of the height array. The code performs three separate scans over the height array, each taking linear time. Hence, the overall time complexity is linear.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the code is O(n), where n is the length of the height array. This is due to the additional arrays left and right that store the maximum heights on the left and right sides of each bar, respectively. The space required is proportional to the size of the input array.\\n\\n# Code\\n```\\nclass Solution \\n{\\n    public int trap(int[] height) \\n    {\\n        int result = 0;\\n        if(height==null || height.length<=2)\\n            return result;\\n        int left[] = new int[height.length];\\n        int right[]= new int[height.length];\\n        //scan from left to right\\n        int max = height[0];\\n        left[0] = height[0];\\n        for(int i=1; i<height.length; i++)\\n        {\\n            if(height[i]<max)\\n            {\\n                left[i]=max;\\n            }\\n            else\\n            {\\n                left[i]=height[i];\\n                max = height[i];\\n            }\\n        }\\n        //scan from right to left\\n        max = height[height.length-1];\\n        right[height.length-1]=height[height.length-1];\\n        for(int i=height.length-2; i>=0; i--)\\n        {\\n            if(height[i]<max)\\n            {\\n                right[i]=max;  \\n            }\\n            else\\n            {  \\n                right[i]=height[i];\\n                max = height[i];\\n            }\\n        }\\n    \\n        for(int i=0; i<height.length; i++)\\n        {\\n            result+= Math.min(left[i],right[i])-height[i];\\n        }\\n        return result;\\n    }\\n}\\n```",
        "level": "hard",
        "buggy_code": "\nclass Solution \n{\n    public int trap(int[] height) \n    {\n        int result = 0;\n        if(height==null || height.length<=2)\n            return result;\n        int left[] = new int[height.length];\n        int right[]= new int[height.length];\n        //scan from left to right\n        int max = height[0];\n        left[0] = height[0];\n        for(int i=1; i<height.length; i++)\n        {\n            if(height[i]<max)\n            {\n                left[i]=max; }\n            else\n            {\n                left[i]=height[i;\n                max = height[i];\n            }\n        }\n        //scan from right to left\n        max = height[height.length-1];\n        right[height.length-1]=height[height.length-1];\n        for(int i=height.length-2; i>=0; i--)\n        {\n            if(height[i]<max)\n            {\n                right[i]=max;  \n            }\n            else\n            {  \n                right[i]=height[i];\n                max = height[i];\n        }\n    \n        for(int i=0; i<height.length; i++)\n        {\n            result+= Math.min(left[i],right[i])-height[i];\n        }\n        return result;\n    }\n}\n",
        "explanations": "\nRight bracket mismatch in the second for loop makes the last two calculations inside the loop.\n"
    },
    {
        "slug": "next-permutation",
        "description": "A permutation of an array of integers is an arrangement of its members into a sequence or linear order.\n\nFor example, for arr = [1,2,3], the following are all the permutations of arr: [1,2,3], [1,3,2], [2, 1, 3], [2, 3, 1], [3,1,2], [3,2,1].\n\nThe next permutation of an array of integers is the next lexicographically greater permutation of its integer. More formally, if all the permutations of the array are sorted in one container according to their lexicographical order, then the next permutation of that array is the permutation that follows it in the sorted container. If such arrangement is not possible, the array must be rearranged as the lowest possible order (i.e., sorted in ascending order).\n\nFor example, the next permutation of arr = [1,2,3] is [1,3,2].\nSimilarly, the next permutation of arr = [2,3,1] is [3,1,2].\nWhile the next permutation of arr = [3,2,1] is [1,2,3] because [3,2,1] does not have a lexicographical larger rearrangement.\n\nGiven an array of integers nums, find the next permutation of nums.\nThe replacement must be in place and use only constant extra memory.",
        "examples": [
            "Input: nums = [1,2,3]\nOutput: [1,3,2]",
            "Input: nums = [3,2,1]\nOutput: [1,2,3]",
            "Input: nums = [1,1,5]\nOutput: [1,5,1]"
        ],
        "constraints": "1 <= nums.length <= 100\n0 <= nums[i] <= 100",
        "release_time": 1689771556,
        "oracle_code": "class Solution {\n    public void nextPermutation(int[] n) {\n        //breakpoint\n       if(  n==null || n.length<=1)return;\n\t\t\n\t\tint i = n.length-2;\n\n\t\twhile(i>=0 && n[i]>=n[i+1])i--;\n\t\t\n\t\tint j=n.length-1;\n\t\t\n\t\tif(i>=0) {\n\t\t\twhile(n[j]<=n[i])j--;\n\t\t\tswap(n,i,j);\n\t\t}\n\t\t\n\t\treverse(n,i+1,n.length-1);\n\t\t\n\t\tfor(int p=0;p<n.length;p++) {\n\t\t\tSystem.out.println(n[p]);\n\t\t}\n\t\t\n\t}\n\tpublic static void swap(int n[],int i,int j) {\n\t\tint temp=n[i];\n\t\tn[i]=n[j];\n\t\tn[j]=temp;\n\t}\n\tpublic static void reverse(int n[],int i,int j) {\n\t\twhile(i<j) {\n\t\t\tswap(n,i,j);\n\t\t\ti++;\n\t\t\tj--;\n\t\t}\n\t}\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n-\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Find the breakpoint(position where n[i]<n[i+1])\\n- Then find the element which greater than breakpoint but is the smallest\\n- Swap the variables i.e breakpoint and the other variable which we have find\\n- Then reverse the remaning array \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(3N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\n    public void nextPermutation(int[] n) {\\n        //breakpoint\\n       if(  n==null || n.length<=1)return;\\n\\t\\t\\n\\t\\tint i = n.length-2;\\n\\n\\t\\twhile(i>=0 && n[i]>=n[i+1])i--;\\n\\t\\t\\n\\t\\tint j=n.length-1;\\n\\t\\t\\n\\t\\tif(i>=0) {\\n\\t\\t\\twhile(n[j]<=n[i])j--;\\n\\t\\t\\tswap(n,i,j);\\n\\t\\t}\\n\\t\\t\\n\\t\\treverse(n,i+1,n.length-1);\\n\\t\\t\\n\\t\\tfor(int p=0;p<n.length;p++) {\\n\\t\\t\\tSystem.out.println(n[p]);\\n\\t\\t}\\n\\t\\t\\n\\t}\\n\\tpublic static void swap(int n[],int i,int j) {\\n\\t\\tint temp=n[i];\\n\\t\\tn[i]=n[j];\\n\\t\\tn[j]=temp;\\n\\t}\\n\\tpublic static void reverse(int n[],int i,int j) {\\n\\t\\twhile(i<j) {\\n\\t\\t\\tswap(n,i,j);\\n\\t\\t\\ti++;\\n\\t\\t\\tj--;\\n\\t\\t}\\n\\t}\\n}\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\n    public void nextPermutation(int[] n) {\n        //breakpoint\n       if(  n==null || n.length<=1)return;\n        \n        int i = n.length-2;\n\n        while(i>=0 && n[i]>=n[i+1)i--;\n        \n        int j=n.length-1;\n        \n        if(i>=0) {\n            while(n[j]<=n[i])j--;\n            swap(n,i,j);\n        }\n        \n        reverse(n,i+1,n.length-1;\n        \n        for(int p=0;p<n.length;p++) {\n            System.out.println(n[p]);\n        }\n        \n    }\n    public static void swap(int n[],int i,int j) {\n        int temp=n[i];\n        n[i]=n[j];\n        n[j]=temp;\n    }\n    public static void reverse(int n[],int i,int j) {\n        while(i<j) {\n            swap(n,i,j);\n            i++;\n            j--;\n        }\n    }\n}\n",
        "explanations": "\nThe closing parenthesis is missing in the reverse method call leading to syntax error.\n"
    },
    {
        "slug": "add-two-numbers",
        "description": "You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum\u00a0as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.",
        "examples": [
            "Input: l1 = [2,4,3], l2 = [5,6,4]\nOutput: [7,0,8]\nExplanation: 342 + 465 = 807.",
            "Input: l1 = [0], l2 = [0]\nOutput: [0]",
            "Input: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\nOutput: [8,9,9,9,0,0,0,1]"
        ],
        "constraints": "The number of nodes in each linked list is in the range [1, 100].\n0 <= Node.val <= 9\nIt is guaranteed that the list represents a number that does not have leading zeros.",
        "release_time": 1646885380,
        "oracle_code": "class Solution {\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        ListNode dummy = new ListNode(0); // creating an dummy list\n        ListNode curr = dummy; // intialising an pointer\n        int carry = 0; // intialising our carry with 0 intiall\n        // while loop will run, until l1 OR l2 not reaches null OR if they both reaches null. But our carry has some value in it. \n\t\t// We will add that as well into our list\n        while(l1 != null || l2 != null || carry == 1){\n            int sum = 0; // intialising our sum\n            if(l1 != null){ // adding l1 to our sum & moving l1\n                sum += l1.val;\n                l1 = l1.next;\n            }\n            if(l2 != null){ // adding l2 to our sum & moving l2\n                sum += l2.val;\n                l2 = l2.next;\n            }\n            sum += carry; // if we have carry then add it into our sum\n            carry = sum/10; // if we get carry, then divide it by 10 to get the carry\n            ListNode node = new ListNode(sum % 10); // the value we'll get by moduloing it, will become as new node so. add it to our list\n            curr.next = node; // curr will point to that new node if we get\n            curr = curr.next; // update the current every time\n        }\n        return dummy.next; // return dummy.next bcz, we don't want the value we have consider in it intially!!\n    }\n}",
        "content": "How\\'s going, Ladies n Gentlemen, today we are going to solve one of the coolest problem **Add Two Numbers**\\n\\nSo, what the problem statement is saying we have given 2 linkedlist we have to add them and get the sum in another linkedlist.\\n\\nWhat, am saying let\\'s understand with an example:-\\n**Input**: l1 = [1,2,4,3], l2 = [5,4,6]\\n**Output**: [6,6,0,4]\\n\\n![image](https://assets.leetcode.com/users/images/a51e18d1-45de-4ba0-aee9-fbb9c40feef1_1646883355.6593215.png)\\n\\nNow let\\'s create another list in which we will get our sum. So, that list intially we will called as dummy list with any value of your choice present in that. *I\\'ll put 0 as we indian has invented that. <^^>*\\n\\nAnd one more last thing, we\\'ll gonna create one pointer and let\\'s say i\\'ll call it **curr** which is pointing on dummy node and traverse along with it\\n\\n![image](https://assets.leetcode.com/users/images/3345cf32-d7df-4225-9ce5-510398aa489c_1646883682.1670015.png)\\n\\nAlright so, here we go ladies n gentlemen, It\\'s time to sum up these node value, for that we will create one another variable let\\'s called it **sum** and put the sum of **l1 & l2** them into our dummy list. So, we start it from all the way left go to all the way right. Now you will ask, dude what about the carry values we get after sum up.\\nWell, hold on i\\'m coming on that point don\\'t worry.\\n\\nSo, for that what you have to do is, we will intialize one more variable name **carry** if we found carry of let\\'s say 10. First we will modulo it like carry = sum % 10 i.e. carry = 10 % 10 i.e. 0 we will add 0 into our node and after that what we will do is get the carry as carry = sum / 10 i.e. carry = 10 / 10 i.e. 1. Now we are having carry as 1. So, in the next node sum of l1 & l2 we will add carry as well.\\n\\nFor sum we will use this formula :- **sum = l1 + l2 + carry**\\n\\nWe did a lot of talk, let\\'s understand it visually:-\\n* 1st step->\\n![image](https://assets.leetcode.com/users/images/c5e427d5-bcf9-42b4-b926-25771dfa7c54_1646884787.030032.png)\\n\\n* 2nd Step->\\n![image](https://assets.leetcode.com/users/images/fdc5533b-d80f-4b71-b755-b645dc126ff6_1646885015.4167643.png)\\n* 3rd Step->\\n![image](https://assets.leetcode.com/users/images/80247d16-8082-4e54-ad15-ed5cfceb3cfb_1646885221.7208884.png)\\n\\nNow I hope Ladies n Gentlemen, you got the crystal clear idea, what we are doing. So, without any further due ***let\\'s code up***\\n\\n**Java**\\n\\n```\\nclass Solution {\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        ListNode dummy = new ListNode(0); // creating an dummy list\\n        ListNode curr = dummy; // intialising an pointer\\n        int carry = 0; // intialising our carry with 0 intiall\\n        // while loop will run, until l1 OR l2 not reaches null OR if they both reaches null. But our carry has some value in it. \\n\\t\\t// We will add that as well into our list\\n        while(l1 != null || l2 != null || carry == 1){\\n            int sum = 0; // intialising our sum\\n            if(l1 != null){ // adding l1 to our sum & moving l1\\n                sum += l1.val;\\n                l1 = l1.next;\\n            }\\n            if(l2 != null){ // adding l2 to our sum & moving l2\\n                sum += l2.val;\\n                l2 = l2.next;\\n            }\\n            sum += carry; // if we have carry then add it into our sum\\n            carry = sum/10; // if we get carry, then divide it by 10 to get the carry\\n            ListNode node = new ListNode(sum % 10); // the value we\\'ll get by moduloing it, will become as new node so. add it to our list\\n            curr.next = node; // curr will point to that new node if we get\\n            curr = curr.next; // update the current every time\\n        }\\n        return dummy.next; // return dummy.next bcz, we don\\'t want the value we have consider in it intially!!\\n    }\\n}\\n```\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        ListNode *dummy = new ListNode(0);\\n        ListNode *curr = dummy;\\n        int carry = 0;\\n        \\n        while(l1 != NULL || l2 != NULL || carry == 1){\\n            int sum = 0;\\n            if(l1 != NULL){\\n                sum += l1->val;\\n                l1 = l1->next;\\n            }\\n            if(l2 != NULL){\\n                sum += l2->val;\\n                l2 = l2->next;\\n            }\\n            sum += carry;\\n            carry = sum/10;\\n            ListNode *node = new ListNode(sum % 10);\\n            curr->next = node;\\n            curr = curr->next;\\n        }\\n        return dummy->next;\\n    }\\n};\\n```\\n\\nANALYSIS :-\\n* **Time Complexity :-** BigO(max(N, M)) where N is length of l1 & M is length of l2\\n\\n* **Space Complexity :-** BigO(max(N,M))",
        "level": "medium",
        "buggy_code": "\nclass Solution {\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        ListNode dummy = new ListNode(0); // creating an dummy list\n        ListNode curr = dummy; // intialising an pointer\n        int carry = 0; // intialising our carry with 0 intiall\n        // while loop will run, until l1 OR l2 not reaches null OR if they both reaches null. But our carry has some value in it. \n\t\t// We will add that as well into our list\n        while(l1 != null || l2 != null || carry == 1{\n            int sum = 0; // intialising our sum\n            if(l1 != null){ // adding l1 to our sum & moving l1\n                sum += l1.val;\n                l1 = l1.next;\n            }\n            if(l2 != null){ // adding l2 to our sum & moving l2\n                sum += l2.val;\n                l2 = l2.next;\n            }\n            sum += carry; // if we have carry then add it into our sum\n            carry = sum/10; // if we get carry, then divide it by 10 to get the carry\n            ListNode node = new ListNode(sum % 10); // the value we'll get by moduloing it, will become as new node so. add it to our list\n            curr.next = node; // curr will point to that new node if we get\n            curr = curr.next; // update the current every time\n        }\n        return dummy.next; // return dummy.next bcz, we don't want the value we have consider in it intially!!\n    }\n}\n",
        "explanations": "\nThe while loop condition (line 9) is missing a closing parenthesis, causing a syntax error.\n"
    },
    {
        "slug": "convert-sorted-array-to-binary-search-tree",
        "description": "Given an integer array nums where the elements are sorted in ascending order, convert it to a height-balanced binary search tree.",
        "examples": [
            "Input: nums = [-10,-3,0,5,9]\nOutput: [0,-3,9,-10,null,5]\nExplanation: [0,-10,5,null,-3,null,9] is also accepted:",
            "Input: nums = [1,3]\nOutput: [3,1]\nExplanation: [1,null,3] and [3,1] are both height-balanced BSTs."
        ],
        "constraints": "1 <= nums.length <= 104\n-104 <= nums[i] <= 104\nnums is sorted in a strictly increasing order.",
        "release_time": 1689161763,
        "oracle_code": "class Solution {\n    public TreeNode createBST(int arr[], int st, int end){\n        if(st>end){\n            return null;\n        }\n\n        int mid = (st+end)/2;\n        TreeNode root = new TreeNode(arr[mid]);\n        root.left = createBST(arr,st,mid-1);\n        root.right = createBST(arr,mid+1,end);\n\n        return root;\n    }\n    public TreeNode sortedArrayToBST(int[] nums) {\n        int st = 0;\n        int end = nums.length-1;\n        return createBST(nums,st,end);\n        \n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nInorder Traversal of BST is always sorted.\\nInorder = left, root, right\\nroot = mid of sorted array\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n**Divide and Conquer and Inorder Traversal**\\n$$Inorder = left, root, right$$ which means root = mid of sorted Array\\nDivide the array into smaller pieces using recursion and assing root = mid \\n$$ mid = (start+end)/2;$$\\n\\n\\n\\n# Complexity\\n- Time complexity: O(n) \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\n    public TreeNode createBST(int arr[], int st, int end){\\n        if(st>end){\\n            return null;\\n        }\\n\\n        int mid = (st+end)/2;\\n        TreeNode root = new TreeNode(arr[mid]);\\n        root.left = createBST(arr,st,mid-1);\\n        root.right = createBST(arr,mid+1,end);\\n\\n        return root;\\n    }\\n    public TreeNode sortedArrayToBST(int[] nums) {\\n        int st = 0;\\n        int end = nums.length-1;\\n        return createBST(nums,st,end);\\n        \\n    }\\n}\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\n    public TreeNode createBST(int arr[], int st, int end){\n        if(st>end){\n            return null;\n        }\n\n        int mid = (st+end)/2;\n        TreeNode root = new TreeNode(arr[mid]);\n        root.left = createBST(arr,st,mid-1;\n        root.right = createBST(arr,mid+1,end;\n\n        return root;\n    }\n    public TreeNode sortedArrayToBST(int[] nums) {\n        int st = 0;\n        int end = nums.length-1;\n        return createBST(nums,st,end);\n        \n    }\n}\n",
        "explanations": "\nThere is a parentheses mismatch in both recursive calls of createBST method.\n"
    },
    {
        "slug": "word-ladder-ii",
        "description": "A transformation sequence from word beginWord to word endWord using a dictionary wordList is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that:\n\nEvery adjacent pair of words differs by a single letter.\nEvery si for 1 <= i <= k is in wordList. Note that beginWord does not need to be in wordList.\nsk == endWord\n\nGiven two words, beginWord and endWord, and a dictionary wordList, return all the shortest transformation sequences from beginWord to endWord, or an empty list if no such sequence exists. Each sequence should be returned as a list of the words [beginWord, s1, s2, ..., sk].",
        "examples": [
            "Input: beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\nOutput: [[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],[\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]]\nExplanation:\u00a0There are 2 shortest transformation sequences:\n\"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> \"cog\"\n\"hit\" -> \"hot\" -> \"lot\" -> \"log\" -> \"cog\"",
            "Input: beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\nOutput: []\nExplanation: The endWord \"cog\" is not in wordList, therefore there is no valid transformation sequence."
        ],
        "constraints": "1 <= beginWord.length <= 5\nendWord.length == beginWord.length\n1 <= wordList.length <= 500\nwordList[i].length == beginWord.length\nbeginWord, endWord, and wordList[i] consist of lowercase English letters.\nbeginWord != endWord\nAll the words in wordList are unique.\nThe sum of all shortest transformation sequences does not exceed 105.",
        "release_time": 1692205615,
        "oracle_code": "class Solution {\n    String b;\n\n    // Create a hashmap of type word->level to get the idea \n    // on which level the word comes after the transformations.\n\n    HashMap < String, Integer > mpp;\n\n    // A list for storing the final answer.\n    List < List < String >> ans;\n    private void dfs(String word, List < String > seq) {\n\n        // Function for implementing backtracking using the created map\n        // in reverse order to find the transformation sequence in less time.\n\n        // Base condition :\n        // If word equals beginWord, we\\u2019ve found one of the sequences\n        // simply reverse the sequence and return. \n        if (word.equals(b)) {\n\n            // Since java works with reference, create\n            // a duplicate and store the reverse of it\n            List < String > dup = new ArrayList < > (seq);\n            Collections.reverse(dup);\n            ans.add(dup);\n            return;\n        }\n        int steps = mpp.get(word);\n        int sz = word.length();\n\n        // Replace each character of the word with letters from a-z \n        // and check whether the transformed word is present in the map\n        // and at the previous level or not.\n        for (int i = 0; i < sz; i++) {\n\n            for (char ch = 'a'; ch <= 'z'; ch++) {\n                char replacedCharArray[] = word.toCharArray();\n                replacedCharArray[i] = ch;\n                String replacedWord = new String(replacedCharArray);\n                if (mpp.containsKey(replacedWord) &&\n                    mpp.get(replacedWord) + 1 == steps) {\n\n                    seq.add(replacedWord);\n                    dfs(replacedWord, seq);\n\n                    // pop the current word from the back of the queue\n                    // to traverse other possibilities.\n                    seq.remove(seq.size() - 1);\n                }\n            }\n        }\n    }\n    public List < List < String >> findLadders(String beginWord, String endWord,\n        List < String > wordList) {\n\n        // Push all values of wordList into a set\n        // to make deletion from it easier and in less time complexity.\n        Set < String > st = new HashSet < String > ();\n        int len = wordList.size();\n        for (int i = 0; i < len; i++) {\n            st.add(wordList.get(i));\n        }\n\n        // Perform BFS traversal and push the string in the queue\n        // as soon as they\\u2019re found in the wordList.\n        Queue < String > q = new LinkedList < > ();\n        b = beginWord;\n        q.add(beginWord);\n        mpp = new HashMap < > ();\n\n        // beginWord initialised with level 1.\n        mpp.put(beginWord, 1);\n        int sizee = beginWord.length();\n        st.remove(beginWord);\n        while (!q.isEmpty()) {\n            String word = q.peek();\n            int steps = mpp.get(word);\n            q.remove();\n\n            // Break out if the word matches the endWord.\n            if (word.equals(endWord)) break;\n\n            // Replace each character of the word with letters from a-z \n            // and check whether the transformed word is present in the \n            // wordList or not, if yes then push to queue\n            for (int i = 0; i < sizee; i++) {\n\n                for (char ch = 'a'; ch <= 'z'; ch++) {\n                    char replacedCharArray[] = word.toCharArray();\n                    replacedCharArray[i] = ch;\n                    String replacedWord = new String(replacedCharArray);\n                    if (st.contains(replacedWord) == true) {\n                        q.add(replacedWord);\n                        st.remove(replacedWord);\n\n                        // push the word along with its level\n                        // in the map data structure.\n                        mpp.put(replacedWord, steps + 1);\n                    }\n                }\n\n\n            }\n        }\n        ans = new ArrayList < > ();\n\n        // If we reach the endWord, we stop and move to step-2\n        // that is to perform reverse dfs traversal.\n        if (mpp.containsKey(endWord) == true) {\n            List < String > seq = new ArrayList < > ();\n            seq.add(endWord);\n            dfs(endWord, seq);\n        }\n        return ans;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/1ea15e79-7ca5-4594-83b4-88b42dc1e6e7_1692205611.608349.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    String b;\\n\\n    // Create a hashmap of type word->level to get the idea \\n    // on which level the word comes after the transformations.\\n\\n    HashMap < String, Integer > mpp;\\n\\n    // A list for storing the final answer.\\n    List < List < String >> ans;\\n    private void dfs(String word, List < String > seq) {\\n\\n        // Function for implementing backtracking using the created map\\n        // in reverse order to find the transformation sequence in less time.\\n\\n        // Base condition :\\n        // If word equals beginWord, we\\u2019ve found one of the sequences\\n        // simply reverse the sequence and return. \\n        if (word.equals(b)) {\\n\\n            // Since java works with reference, create\\n            // a duplicate and store the reverse of it\\n            List < String > dup = new ArrayList < > (seq);\\n            Collections.reverse(dup);\\n            ans.add(dup);\\n            return;\\n        }\\n        int steps = mpp.get(word);\\n        int sz = word.length();\\n\\n        // Replace each character of the word with letters from a-z \\n        // and check whether the transformed word is present in the map\\n        // and at the previous level or not.\\n        for (int i = 0; i < sz; i++) {\\n\\n            for (char ch = \\'a\\'; ch <= \\'z\\'; ch++) {\\n                char replacedCharArray[] = word.toCharArray();\\n                replacedCharArray[i] = ch;\\n                String replacedWord = new String(replacedCharArray);\\n                if (mpp.containsKey(replacedWord) &&\\n                    mpp.get(replacedWord) + 1 == steps) {\\n\\n                    seq.add(replacedWord);\\n                    dfs(replacedWord, seq);\\n\\n                    // pop the current word from the back of the queue\\n                    // to traverse other possibilities.\\n                    seq.remove(seq.size() - 1);\\n                }\\n            }\\n        }\\n    }\\n    public List < List < String >> findLadders(String beginWord, String endWord,\\n        List < String > wordList) {\\n\\n        // Push all values of wordList into a set\\n        // to make deletion from it easier and in less time complexity.\\n        Set < String > st = new HashSet < String > ();\\n        int len = wordList.size();\\n        for (int i = 0; i < len; i++) {\\n            st.add(wordList.get(i));\\n        }\\n\\n        // Perform BFS traversal and push the string in the queue\\n        // as soon as they\\u2019re found in the wordList.\\n        Queue < String > q = new LinkedList < > ();\\n        b = beginWord;\\n        q.add(beginWord);\\n        mpp = new HashMap < > ();\\n\\n        // beginWord initialised with level 1.\\n        mpp.put(beginWord, 1);\\n        int sizee = beginWord.length();\\n        st.remove(beginWord);\\n        while (!q.isEmpty()) {\\n            String word = q.peek();\\n            int steps = mpp.get(word);\\n            q.remove();\\n\\n            // Break out if the word matches the endWord.\\n            if (word.equals(endWord)) break;\\n\\n            // Replace each character of the word with letters from a-z \\n            // and check whether the transformed word is present in the \\n            // wordList or not, if yes then push to queue\\n            for (int i = 0; i < sizee; i++) {\\n\\n                for (char ch = \\'a\\'; ch <= \\'z\\'; ch++) {\\n                    char replacedCharArray[] = word.toCharArray();\\n                    replacedCharArray[i] = ch;\\n                    String replacedWord = new String(replacedCharArray);\\n                    if (st.contains(replacedWord) == true) {\\n                        q.add(replacedWord);\\n                        st.remove(replacedWord);\\n\\n                        // push the word along with its level\\n                        // in the map data structure.\\n                        mpp.put(replacedWord, steps + 1);\\n                    }\\n                }\\n\\n\\n            }\\n        }\\n        ans = new ArrayList < > ();\\n\\n        // If we reach the endWord, we stop and move to step-2\\n        // that is to perform reverse dfs traversal.\\n        if (mpp.containsKey(endWord) == true) {\\n            List < String > seq = new ArrayList < > ();\\n            seq.add(endWord);\\n            dfs(endWord, seq);\\n        }\\n        return ans;\\n    }\\n}\\n```",
        "level": "hard",
        "buggy_code": "\nclass Solution {\n    String b;\n\n    HashMap < String, Integer > mpp;\n\n    List < List < String >> ans;\n    private void dfs(String word, List < String > seq) {\n\n        if (word.equals(b)) {\n\n            List < String > dup = new ArrayList < > (seq);\n            Collections.reverse(dup);\n            ans.add(dup);\n            return;\n        }\n        int steps = mpp.get(word);\n        int sz = word.length();\n\n        for (int i = 0; i < sz; i++) {\n\n            for (char ch = 'a'; ch <= 'z'; ch++) {\n                char replacedCharArray[] = word.toCharArray();\n                replacedCharArray[i] = ch;\n                String replacedWord = new String(replacedCharArray);\n                if (mpp.containsKey(replacedWord) &&\n                    mpp.get(replacedWord) + 1 == steps) {\n\n                    seq.add(replacedWord);\n                    dfs(replacedWord, seq);\n\n                    seq.remove(seq.size() - 1);\n                }\n            }\n        }\n    }\n    public List < List < String >> findLadders(String beginWord, String endWord,\n        List < String > wordList) {\n\n        Set < String > st = new HashSet < String > ();\n        int len = wordList.size();\n        for (int i = 0; i < len; i++) {\n            st.add(wordList.get(i));\n        }\n        Queue < String > q = new LinkedList < > ();\n        b = beginWord;\n        q.add(beginWord);\n        mpp = new HashMap < > ();\n\n        mpp.put(beginWord, 1);\n        int sizee = beginWord.length();\n        st.remove(beginWord);\n        while (!q.isEmpty()) {\n            String word = q.peek();\n            int steps = mpp.get(word);\n            q.remove();\n\n            if (word.equals(endWord)) break;\n\n            for (int i = 0; i < sizee; i++) {\n\n                for (char ch = 'a'; ch <= 'z'; ch++) {\n                    char replacedCharArray[] = word.toCharArray();\n                    replacedCharArray[i] = ch;\n                    String replacedWord = new String(replacedCharArray);\n                    if (st.contains(replacedWord) == true) {\n                        q.add(replacedWord);\n                        st.remove(replacedWord);\n\n                        mpp.put(replacedWord, steps + 1;\n                    }\n                }\n\n\n            }\n        }\n        ans = new ArrayList < > ();\n\n        if (mpp.containsKey(endWord) == true) {\n            List < String > seq = new ArrayList < > ();\n            seq.add(endWord);\n            dfs(endWord, seq);\n        }\n        return ans;\n    }\n}\n",
        "explanations": "\nMissing closing parenthesis in 'mpp.put(replacedWord, steps + 1;' causes a syntax error.\n"
    },
    {
        "slug": "number-of-unequal-triplets-in-array",
        "description": "You are given a 0-indexed array of positive integers nums. Find the number of triplets (i, j, k) that meet the following conditions:\n\n0 <= i < j < k < nums.length\nnums[i], nums[j], and nums[k] are pairwise distinct.\n\t\nIn other words, nums[i] != nums[j], nums[i] != nums[k], and nums[j] != nums[k].\n\n\n\nReturn the number of triplets that meet the conditions.",
        "examples": [
            "Input: nums = [4,4,2,4,3]\nOutput: 3\nExplanation: The following triplets meet the conditions:\n- (0, 2, 4) because 4 != 2 != 3\n- (1, 2, 4) because 4 != 2 != 3\n- (2, 3, 4) because 2 != 4 != 3\nSince there are 3 triplets, we return 3.\nNote that (2, 0, 4) is not a valid triplet because 2 > 0.",
            "Input: nums = [1,1,1,1,1]\nOutput: 0\nExplanation: No triplets meet the conditions so we return 0."
        ],
        "constraints": "3 <= nums.length <= 100\n1 <= nums[i] <= 1000",
        "release_time": 1668916901,
        "oracle_code": "class Solution {\n    public int unequalTriplets(int[] nums) {\n        int ans=0;\n        for(int i=0; i < nums.length; i++)\n            for(int j=i+1; j < nums.length; j++)\n                for(int k=j+1; k < nums.length; k++)\n                    if(nums[i] != nums[j] && nums[i] != nums[k] && nums[j] != nums[k])\n                        ans++;\n        return ans;\n    }\n}",
        "content": "* *Time Complexity :* **O(n^3)**\\n* *Space Complexity :* **O(1)**\\n##### Java\\n```\\nclass Solution {\\n    public int unequalTriplets(int[] nums) {\\n        int ans=0;\\n        for(int i=0; i < nums.length; i++)\\n            for(int j=i+1; j < nums.length; j++)\\n                for(int k=j+1; k < nums.length; k++)\\n                    if(nums[i] != nums[j] && nums[i] != nums[k] && nums[j] != nums[k])\\n                        ans++;\\n        return ans;\\n    }\\n}\\n```\\n##### C++\\n```\\nclass Solution {\\npublic:\\n    int unequalTriplets(vector<int>& nums) {\\n        int ans = 0;\\n        for(int i = 0; i < nums.size(); i++)\\n            for(int j = i + 1; j < nums.size(); j++)\\n                for(int k = j + 1; k < nums.size(); k++)\\n                    if(nums[i] != nums[j] && nums[i] != nums[k] && nums[j] != nums[k]) \\n\\t\\t\\t\\t\\t\\tans++;\\n        return ans;\\n    }\\n};\\n```\\n##### Python\\n```\\nclass Solution(object):\\n    def unequalTriplets(self, nums):\\n        ans = 0\\n        for i in range(len(nums)):\\n            for j in range(i+1, len(nums)):\\n                for k in range(j+1, len(nums)):\\n                    if nums[i] != nums[j] and nums[i] != nums[k] and nums[j] != nums[k]:\\n                        ans += 1\\n        return ans\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\n    public int unequalTriplets(int[] nums) {\n        int ans=0;\n        for(int i=0; i < nums.length; i++)\n            for(int j=i+1; j < nums.length; j++)\n                for(int k=j+1; k < nums.length; k++\n                    if(nums[i] != nums[j] && nums[i] != nums[k] && nums[j] != nums[k])\n                        ans++;\n        return ans;\n    }\n}\n",
        "explanations": "\nThe bug is a parentheses mismatch - the third for loop is missing a closing parenthesis.\n"
    },
    {
        "slug": "maximal-rectangle",
        "description": "Given a rows x cols\u00a0binary matrix filled with 0's and 1's, find the largest rectangle containing only 1's and return its area.",
        "examples": [
            "Input: matrix = [[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"0\"]]\nOutput: 6\nExplanation: The maximal rectangle is shown in the above picture.",
            "Input: matrix = [[\"0\"]]\nOutput: 0",
            "Input: matrix = [[\"1\"]]\nOutput: 1"
        ],
        "constraints": "rows == matrix.length\ncols == matrix[i].length\n1 <= row, cols <= 200\nmatrix[i][j] is '0' or '1'.",
        "release_time": 1691836401,
        "oracle_code": "class Pair<T, U> {\n    public final T first;\n    public final U second;\n\n    public Pair(T first, U second) {\n        this.first = first;\n        this.second = second;\n    }\n}\n\nclass Solution {\n    public int maximalRectangle(char[][] matrix) {\n        int n = matrix.length, m = matrix[0].length;\n        int[] nums = new int[m];\n        for (int j = 0; j < m; j++) {\n            nums[j] = matrix[0][j] - '0';\n        }\n        int max = maximumAreaHistogram(nums);\n        for (int i = 1; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (matrix[i][j] == '0') {\n                    nums[j] = 0;\n                } else {\n                    nums[j] += (matrix[i][j] - '0');\n                }\n            }\n            max = Math.max(max, maximumAreaHistogram(nums));\n        }\n        return max;\n    }\n    public int maximumAreaHistogram(int[] heights) {\n        Stack<Pair<Integer, Integer>> stack1 = new Stack<>();\n        int[] left = new int[heights.length];\n        int pseudoIndex = -1;\n        //NSL\n        for (int i = 0; i < heights.length; i++) {\n            if (stack1.size() == 0) {\n                left[i] = pseudoIndex;\n            } else if (stack1.size() > 0 && stack1.peek().first < heights[i]) {\n                left[i] = stack1.peek().second;\n            } else if (stack1.size() > 0 && stack1.peek().first >= heights[i]) {\n                while (stack1.size() > 0 && stack1.peek().first >= heights[i]) {\n                    stack1.pop();\n                }\n                if (stack1.size() == 0) {\n                    left[i] = pseudoIndex;\n                } else {\n                    left[i] = stack1.peek().second;\n                }\n            }\n            stack1.push(new Pair<>(heights[i], i));\n        }\n        //NSR\n        Stack<Pair<Integer, Integer>> stack2 = new Stack<>();\n        int[] right = new int[heights.length];\n        pseudoIndex = heights.length;\n        for (int i = heights.length - 1; i >= 0; i--) {\n            if (stack2.size() == 0) {\n                right[i] = pseudoIndex;\n            } else if (stack2.size() > 0 && stack2.peek().first < heights[i]) {\n                right[i] = stack2.peek().second;\n            } else if (stack2.size() > 0 && stack2.peek().first >= heights[i]) {\n                while (stack2.size() > 0 && stack2.peek().first >= heights[i]) {\n                    stack2.pop();\n                }\n                if (stack2.size() == 0) {\n                    right[i] = pseudoIndex;\n                } else {\n                    right[i] = stack2.peek().second;\n                }\n            }\n            stack2.push(new Pair<>(heights[i], i));\n        }\n\n        int[] width = new int[heights.length];\n        for (int i = 0; i < heights.length; i++) {\n            width[i] = right[i] - left[i] - 1;\n        }\n\n        int[] area = new int[heights.length];\n        int maxArea = 0;\n        for (int i = 0; i < heights.length; i++) {\n            area[i] = heights[i] * width[i];\n            if (area[i] > maxArea) maxArea = area[i];\n        }\n        return maxArea;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Pair<T, U> {\\n    public final T first;\\n    public final U second;\\n\\n    public Pair(T first, U second) {\\n        this.first = first;\\n        this.second = second;\\n    }\\n}\\n\\nclass Solution {\\n    public int maximalRectangle(char[][] matrix) {\\n        int n = matrix.length, m = matrix[0].length;\\n        int[] nums = new int[m];\\n        for (int j = 0; j < m; j++) {\\n            nums[j] = matrix[0][j] - \\'0\\';\\n        }\\n        int max = maximumAreaHistogram(nums);\\n        for (int i = 1; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (matrix[i][j] == \\'0\\') {\\n                    nums[j] = 0;\\n                } else {\\n                    nums[j] += (matrix[i][j] - \\'0\\');\\n                }\\n            }\\n            max = Math.max(max, maximumAreaHistogram(nums));\\n        }\\n        return max;\\n    }\\n    public int maximumAreaHistogram(int[] heights) {\\n        Stack<Pair<Integer, Integer>> stack1 = new Stack<>();\\n        int[] left = new int[heights.length];\\n        int pseudoIndex = -1;\\n        //NSL\\n        for (int i = 0; i < heights.length; i++) {\\n            if (stack1.size() == 0) {\\n                left[i] = pseudoIndex;\\n            } else if (stack1.size() > 0 && stack1.peek().first < heights[i]) {\\n                left[i] = stack1.peek().second;\\n            } else if (stack1.size() > 0 && stack1.peek().first >= heights[i]) {\\n                while (stack1.size() > 0 && stack1.peek().first >= heights[i]) {\\n                    stack1.pop();\\n                }\\n                if (stack1.size() == 0) {\\n                    left[i] = pseudoIndex;\\n                } else {\\n                    left[i] = stack1.peek().second;\\n                }\\n            }\\n            stack1.push(new Pair<>(heights[i], i));\\n        }\\n        //NSR\\n        Stack<Pair<Integer, Integer>> stack2 = new Stack<>();\\n        int[] right = new int[heights.length];\\n        pseudoIndex = heights.length;\\n        for (int i = heights.length - 1; i >= 0; i--) {\\n            if (stack2.size() == 0) {\\n                right[i] = pseudoIndex;\\n            } else if (stack2.size() > 0 && stack2.peek().first < heights[i]) {\\n                right[i] = stack2.peek().second;\\n            } else if (stack2.size() > 0 && stack2.peek().first >= heights[i]) {\\n                while (stack2.size() > 0 && stack2.peek().first >= heights[i]) {\\n                    stack2.pop();\\n                }\\n                if (stack2.size() == 0) {\\n                    right[i] = pseudoIndex;\\n                } else {\\n                    right[i] = stack2.peek().second;\\n                }\\n            }\\n            stack2.push(new Pair<>(heights[i], i));\\n        }\\n\\n        int[] width = new int[heights.length];\\n        for (int i = 0; i < heights.length; i++) {\\n            width[i] = right[i] - left[i] - 1;\\n        }\\n\\n        int[] area = new int[heights.length];\\n        int maxArea = 0;\\n        for (int i = 0; i < heights.length; i++) {\\n            area[i] = heights[i] * width[i];\\n            if (area[i] > maxArea) maxArea = area[i];\\n        }\\n        return maxArea;\\n    }\\n}\\n```",
        "level": "hard",
        "buggy_code": "\nclass Pair<T, U> {\n    public final T first;\n    public final U second;\n\n    public Pair(T first, U second) {\n        this.first = first;\n        this.second = second;\n    }\n}\n\nclass Solution {\n    public int maximalRectangle(char[][] matrix) {\n        int n = matrix.length, m = matrix[0].length;\n        int[] nums = new int[m];\n        for (int j = 0; j < m; j++) {\n            nums[j] = matrix[0][j] - '0';\n        }\n        int max = maximumAreaHistogram(nums);\n        for (int i = 1; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (matrix[i][j] == '0') {\n                    nums[j] = 0;\n                } else {\n                    nums[j] += (matrix[i][j] - '0';\n                }\n            }\n            max = Math.max(max, maximumAreaHistogram(nums));\n        }\n        return max;\n    }\n    public int maximumAreaHistogram(int[] heights) {\n        Stack<Pair<Integer, Integer>> stack1 = new Stack<>();\n        int[] left = new int[heights.length];\n        int pseudoIndex = -1;\n        //NSL\n        for (int i = 0; i < heights.length; i++) {\n            if (stack1.size() == 0) {\n                left[i] = pseudoIndex;\n            } else if (stack1.size() > 0 && stack1.peek().first < heights[i]) {\n                left[i] = stack1.peek().second;\n            } else if (stack1.size() > 0 && stack1.peek().first >= heights[i]) {\n                while (stack1.size() > 0 && stack1.peek().first >= heights[i]) {\n                    stack1.pop();\n                }\n                if (stack1.size() == 0) {\n                    left[i] = pseudoIndex;\n                } else {\n                    left[i] = stack1.peek().second;\n                }\n            }\n            stack1.push(new Pair<>(heights[i], i));\n        }\n        //NSR\n        Stack<Pair<Integer, Integer>> stack2 = new Stack<>();\n        int[] right = new int[heights.length];\n        pseudoIndex = heights.length;\n        for (int i = heights.length - 1; i >= 0; i--) {\n            if (stack2.size() == 0) {\n                right[i] = pseudoIndex;\n            } else if (stack2.size() > 0 && stack2.peek().first < heights[i]) {\n                right[i] = stack2.peek().second;\n            } else if (stack2.size() > 0 && stack2.peek().first >= heights[i]) {\n                while (stack2.size() > 0 && stack2.peek().first >= heights[i]) {\n                    stack2.pop();\n                }\n                if (stack2.size() == 0) {\n                    right[i] = pseudoIndex;\n                } else {\n                    right[i] = stack2.peek().second;\n                }\n            }\n            stack2.push(new Pair<>(heights[i], i));\n        }\n\n        int[] width = new int[heights.length];\n        for (int i = 0; i < heights.length; i++) {\n            width[i] = right[i] - left[i] - 1;\n        }\n\n        int[] area = new int[heights.length];\n        int maxArea = 0;\n        for (int i = 0; i < heights.length; i++) {\n            area[i] = heights[i] * width[i];\n            if (area[i] > maxArea) maxArea = area[i];\n        }\n        return maxArea;\n    }\n}\n",
        "explanations": "\nMismatch in opening and closing parentheses in line \"nums[j] += (matrix[i][j] - '0';\" inside for loop.\n"
    },
    {
        "slug": "same-tree",
        "description": "Given the roots of two binary trees p and q, write a function to check if they are the same or not.\nTwo binary trees are considered the same if they are structurally identical, and the nodes have the same value.",
        "examples": [
            "Input: p = [1,2,3], q = [1,2,3]\nOutput: true",
            "Input: p = [1,2], q = [1,null,2]\nOutput: false",
            "Input: p = [1,2,1], q = [1,1,2]\nOutput: false"
        ],
        "constraints": "The number of nodes in both trees is in the range [0, 100].\n-104 <= Node.val <= 104",
        "release_time": 1691573493,
        "oracle_code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n   \n    public boolean isSameTree(TreeNode p, TreeNode q) {\n     if (p == null && q == null) {\n            return true;\n        }\n        \n        if (p == null || q == null) {\n            return false;\n        }\n        \n        if (p.val != q.val) {\n            return false;\n        }\n        \n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n\n        \n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n   \\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n     if (p == null && q == null) {\\n            return true;\\n        }\\n        \\n        if (p == null || q == null) {\\n            return false;\\n        }\\n        \\n        if (p.val != q.val) {\\n            return false;\\n        }\\n        \\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n\\n        \\n    }\\n}\\n```",
        "level": "easy",
        "buggy_code": "\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n   \n    public boolean isSameTree(TreeNode p, TreeNode q) {\n     if (p == null && q == null {\n            return true;\n        }\n        \n        if (p == null || q == null) {\n            return false;\n        }\n        \n        if (p.val != q.val) {\n            return false;\n        }\n        \n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);    \n    }\n}\n",
        "explanations": "\nI've removed the closing parenthesis from the first if statement, causing a syntax error.\n"
    },
    {
        "slug": "subtract-the-product-and-sum-of-digits-of-an-integer",
        "description": "Given an integer number n, return the difference between the product of its digits and the sum of its digits.",
        "examples": [
            "Input: n = 234\nOutput: 15 \nExplanation: \nProduct of digits = 2 * 3 * 4 = 24 \nSum of digits = 2 + 3 + 4 = 9 \nResult = 24 - 9 = 15",
            "Input: n = 4421\nOutput: 21\nExplanation: \nProduct of digits = 4 * 4 * 2 * 1 = 32 \nSum of digits = 4 + 4 + 2 + 1 = 11 \nResult = 32 - 11 = 21"
        ],
        "constraints": "1 <= n <= 10^5",
        "release_time": 1683965436,
        "oracle_code": "class Solution {\n    public int subtractProductAndSum(int n) {\n        int prod=1;\n        int sum=0;\n        while(n>0) {\n            int rem=n%10;\n            sum+=rem;\n            prod*=rem;\n            n/=10;\n        }\n        return prod-sum;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int subtractProductAndSum(int n) {\\n        int prod=1;\\n        int sum=0;\\n        while(n>0) {\\n            int rem=n%10;\\n            sum+=rem;\\n            prod*=rem;\\n            n/=10;\\n        }\\n        return prod-sum;\\n    }\\n}\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\n    public int subtractProductAndSum(int n) {\n        int prod=1;\n        int sum=0;\n        while(n>0 \n            int rem=n%10;\n            sum+=rem;\n            prod*=rem;\n            n/=10;\n        }\n        return prod-sum;\n    }\n}\n",
        "explanations": "\nThere's a missing closing parenthesis for the \"while\" statement causing a syntax error.\n"
    },
    {
        "slug": "sort-even-and-odd-indices-independently",
        "description": "You are given a 0-indexed integer array nums. Rearrange the values of nums according to the following rules:\n\nSort the values at odd indices of nums in non-increasing order.\n\n\t\nFor example, if nums = [4,1,2,3] before this step, it becomes [4,3,2,1] after. The values at odd indices 1 and 3 are sorted in non-increasing order.\n\n\nSort the values at even indices of nums in non-decreasing order.\n\t\nFor example, if nums = [4,1,2,3] before this step, it becomes [2,1,4,3] after. The values at even indices 0 and 2 are sorted in non-decreasing order.\n\n\n\nReturn the array formed after rearranging the values of nums.",
        "examples": [
            "Input: nums = [4,1,2,3]\nOutput: [2,3,4,1]\nExplanation: \nFirst, we sort the values present at odd indices (1 and 3) in non-increasing order.\nSo, nums changes from [4,1,2,3] to [4,3,2,1].\nNext, we sort the values present at even indices (0 and 2) in non-decreasing order.\nSo, nums changes from [4,1,2,3] to [2,3,4,1].\nThus, the array formed after rearranging the values is [2,3,4,1].",
            "Input: nums = [2,1]\nOutput: [2,1]\nExplanation: \nSince there is exactly one odd index and one even index, no rearrangement of values takes place.\nThe resultant array formed is [2,1], which is the same as the initial array."
        ],
        "constraints": "1 <= nums.length <= 100\n1 <= nums[i] <= 100",
        "release_time": 1691504783,
        "oracle_code": "class Solution {\n    public int[] sortEvenOdd(int[] nums) {\n        int n = nums.length;\n        int[] even = new int[(n + 1) / 2];\n        int[] odd = new int[n / 2];\n        int iE = 0;\n        int iO = 0;\n\n        for(int i = 0; i < n; i++) {\n            if(i % 2 == 0) {\n                even[iE++] = nums[i];\n            } else {\n                odd[iO++] = nums[i];\n            }\n        }\n\n        Arrays.sort(even);\n        Arrays.sort(odd);\n        iE = 0;\n        iO = n / 2 - 1;\n\n        for(int i = 0; i < n; i++) {\n            if(i % 2 == 0) {\n                nums[i] = even[iE++];\n            } else {\n                nums[i] = odd[iO--];\n            }\n        }\n\n        return nums;\n    }\n}",
        "content": "# Approach\\nLet\\'s break down the approach and logic used in the provided solution:\\n\\n1. **Array Splitting:**\\n   The solution begins by splitting the input array `nums` into two separate arrays: one for even indices and one for odd indices. This is done to simplify the sorting process for each set of values.\\n\\n2. **Filling Even and Odd Arrays:**\\n   The loop iterates through the `nums` array. If the current index `i` is even, the corresponding value is added to the `even` array; if `i` is odd, the value is added to the `odd` array. This way, the even values are stored in one array and the odd values in another.\\n\\n3. **Sorting Arrays:**\\n   After filling the `even` and `odd` arrays, both arrays are sorted. The `Arrays.sort()` function is used to sort the elements in ascending order.\\n\\n4. **Reconstruction of `nums` Array:**\\n   After sorting the two arrays, the solution now reconstructs the `nums` array. It uses two index pointers `iE` and `iO` for the `even` and `odd` arrays, respectively.\\n\\n   The loop iterates through the `nums` array again, and if the current index `i` is even, it assigns the value from the `even` array using the `iE` pointer. Similarly, if `i` is odd, it assigns the value from the `odd` array using the `iO` pointer.\\n\\n   Notably, the values from the `odd` array are assigned in reverse order (`iO` decreases while traversing odd indices) because we sorted the odd values in non-increasing order.\\n\\n5. **Returning the Result:**\\n   Finally, the `nums` array is fully reconstructed according to the rules specified in the problem, and this sorted array is returned as the result.\\n\\nThe key idea here is to separate even and odd indices, sort the respective values independently, and then reconstruct the original array while following the given rules for sorting even and odd indices.\\n\\n# Complexity\\n- Time complexity: $$O(n * log(n))$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] sortEvenOdd(int[] nums) {\\n        int n = nums.length;\\n        int[] even = new int[(n + 1) / 2];\\n        int[] odd = new int[n / 2];\\n        int iE = 0;\\n        int iO = 0;\\n\\n        for(int i = 0; i < n; i++) {\\n            if(i % 2 == 0) {\\n                even[iE++] = nums[i];\\n            } else {\\n                odd[iO++] = nums[i];\\n            }\\n        }\\n\\n        Arrays.sort(even);\\n        Arrays.sort(odd);\\n        iE = 0;\\n        iO = n / 2 - 1;\\n\\n        for(int i = 0; i < n; i++) {\\n            if(i % 2 == 0) {\\n                nums[i] = even[iE++];\\n            } else {\\n                nums[i] = odd[iO--];\\n            }\\n        }\\n\\n        return nums;\\n    }\\n}\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\n    public int[] sortEvenOdd(int[] nums) {\n        int n = nums.length;\n        int[] even = new int[(n + 1) / 2];\n        int[] odd = new int[n / 2];\n        int iE = 0;\n        int iO = 0;\n\n        for(int i = 0; i < n; i++) {\n            if(i % 2 == 0) {\n                even[iE++] = nums[i];\n            } else {\n                odd[iO++] = nums[i];\n            }\n        )\n\n        Arrays.sort(even);\n        Arrays.sort(odd);\n        iE = 0;\n        iO = n / 2 - 1;\n\n        for(int i = 0; i < n; i++) {\n            if(i % 2 == 0) {\n                nums[i] = even[iE++];\n            } else {\n                nums[i] = odd[iO--];\n            }\n        }\n\n        return nums;\n    }\n}\n",
        "explanations": "\nThe closing parenthesis of the first for loop has been replaced by a closing bracket, leading to a mismatched parentheses/bracket error.\n"
    },
    {
        "slug": "number-of-laser-beams-in-a-bank",
        "description": "Anti-theft security devices are activated inside a bank. You are given a 0-indexed binary string array bank representing the floor plan of the bank, which is an m x n 2D matrix. bank[i] represents the ith row, consisting of '0's and '1's. '0' means the cell is empty, while'1' means the cell has a security device.\nThere is one laser beam between any two security devices if both conditions are met:\n\nThe two devices are located on two different rows: r1 and r2, where r1 < r2.\nFor each row i where r1 < i < r2, there are no security devices in the ith row.\n\nLaser beams are independent, i.e., one beam does not interfere nor join with another.\nReturn the total number of laser beams in the bank.",
        "examples": [
            "Input: bank = [\"011001\",\"000000\",\"010100\",\"001000\"]\nOutput: 8\nExplanation: Between each of the following device pairs, there is one beam. In total, there are 8 beams:\n * bank[0][1] -- bank[2][1]\n * bank[0][1] -- bank[2][3]\n * bank[0][2] -- bank[2][1]\n * bank[0][2] -- bank[2][3]\n * bank[0][5] -- bank[2][1]\n * bank[0][5] -- bank[2][3]\n * bank[2][1] -- bank[3][2]\n * bank[2][3] -- bank[3][2]\nNote that there is no beam between any device on the 0th row with any on the 3rd row.\nThis is because the 2nd row contains security devices, which breaks the second condition.",
            "Input: bank = [\"000\",\"111\",\"000\"]\nOutput: 0\nExplanation: There does not exist two devices located on two different rows."
        ],
        "constraints": "m == bank.length\nn == bank[i].length\n1 <= m, n <= 500\nbank[i][j] is either '0' or '1'.",
        "release_time": 1671532567,
        "oracle_code": "class Solution {\n    public int numberOfBeams(String[] bank) {\n        int prevLazer =0;\n        int ans =0;\n        for(String s:bank){\n            int curLazer = 0;\n            for(char c: s.toCharArray()){\n                if(c=='1'){\n                    curLazer++;\n                }\n            }\n            if(curLazer >0){\n                ans += (curLazer * prevLazer);\n                prevLazer = curLazer;\n            }\n        }\n        return ans;\n    }\n}",
        "content": "\\n# java Code\\n```\\nclass Solution {\\n    public int numberOfBeams(String[] bank) {\\n        int prevLazer =0;\\n        int ans =0;\\n        for(String s:bank){\\n            int curLazer = 0;\\n            for(char c: s.toCharArray()){\\n                if(c==\\'1\\'){\\n                    curLazer++;\\n                }\\n            }\\n            if(curLazer >0){\\n                ans += (curLazer * prevLazer);\\n                prevLazer = curLazer;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\n    public int numberOfBeams(String[] bank) {\n        int prevLazer =0;\n        int ans =0;\n        for(String s:bank){\n            int curLazer = 0;\n            for(char c: s.toCharArray()){\n                if(c=='1'){\n                    curLazer++;\n                }\n            if(curLazer >0){\n                ans += (curLazer * prevLazer);\n                prevLazer = curLazer;\n            }\n        }\n        return ans;\n    }\n}\n",
        "explanations": "\nThe closing parenthesis for the outer for-loop is placed incorrectly, causing logical errors.\n"
    },
    {
        "slug": "maximum-number-of-fish-in-a-grid",
        "description": "You are given a 0-indexed 2D matrix grid of size m x n, where (r, c) represents:\n\nA land cell if grid[r][c] = 0, or\nA water cell containing grid[r][c] fish, if grid[r][c] > 0.\n\nA fisher can start at any water cell (r, c) and can do the following operations any number of times:\n\nCatch all the fish at cell (r, c), or\nMove to any adjacent water cell.\n\nReturn the maximum number of fish the fisher can catch if he chooses his starting cell optimally, or 0 if no water cell exists.\nAn adjacent cell of the cell (r, c), is one of the cells (r, c + 1), (r, c - 1), (r + 1, c) or (r - 1, c) if it exists.",
        "examples": [
            "Input: grid = [[0,2,1,0],[4,0,0,3],[1,0,0,4],[0,3,2,0]]\nOutput: 7\nExplanation: The fisher can start at cell (1,3) and collect 3 fish, then move to cell (2,3)\u00a0and collect 4 fish.",
            "Input: grid = [[1,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,1]]\nOutput: 1\nExplanation: The fisher can start at cells (0,0) or (3,3) and collect a single fish."
        ],
        "constraints": "m == grid.length\nn == grid[i].length\n1 <= m, n <= 10\n0 <= grid[i][j] <= 10",
        "release_time": 1682784060,
        "oracle_code": "class Solution {\n    public int findMaxFish(int[][] grid) {\n        int sum=0;\n        for(int i=0;i<grid.length;i++)\n        {\n            for(int j=0;j<grid[0].length;j++)\n            {\n                if(grid[i][j]!=0)\n                {\n                    int a[]=new int[1];\n                    task(grid,i,j,a);\n                    sum=Math.max(sum,a[0]);\n                }\n            }\n        }\n        return sum;\n    }\n    public void task(int grid[][], int i, int j, int a[])\n    {\n        if(i<0 || j<0 || i>=grid.length || j>=grid[0].length || grid[i][j]==0)\n        {\n            return;\n        }\n        a[0]+=grid[i][j];\n        grid[i][j]=0;\n        task(grid,i+1,j,a);\n        task(grid,i-1,j,a);\n        task(grid,i,j+1,a);\n        task(grid,i,j-1,a);\n    }\n}",
        "content": "# Complexity\\n- Time complexity: $$O(m*n)$$\\n\\n- Space complexity: $$O(m*n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int findMaxFish(int[][] grid) {\\n        int sum=0;\\n        for(int i=0;i<grid.length;i++)\\n        {\\n            for(int j=0;j<grid[0].length;j++)\\n            {\\n                if(grid[i][j]!=0)\\n                {\\n                    int a[]=new int[1];\\n                    task(grid,i,j,a);\\n                    sum=Math.max(sum,a[0]);\\n                }\\n            }\\n        }\\n        return sum;\\n    }\\n    public void task(int grid[][], int i, int j, int a[])\\n    {\\n        if(i<0 || j<0 || i>=grid.length || j>=grid[0].length || grid[i][j]==0)\\n        {\\n            return;\\n        }\\n        a[0]+=grid[i][j];\\n        grid[i][j]=0;\\n        task(grid,i+1,j,a);\\n        task(grid,i-1,j,a);\\n        task(grid,i,j+1,a);\\n        task(grid,i,j-1,a);\\n    }\\n}\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\n    public int findMaxFish(int[][] grid) {\n        int sum=0;\n        for(int i=0;i<grid.length;i++)\n        {\n            for(int j=0;j<grid[0].length;j++)\n            {\n                if(grid[i][j]!=0)\n                {\n                    int a[]=new int[1];\n                    task(grid,i,j,a);\n                    sum=Math.max(sum,a[0]);\n                }\n            }\n        }\n        return sum;\n    }\n    public void task(int grid[][], int i, int j, int a[])\n    {\n        if(i<0 || j<0 || i>=grid.length) || j>=grid[0].length || grid[i][j]==0)\n        {\n            return;\n        }\n        a[0]+=grid[i][j];\n        grid[i][j]=0;\n        task(grid,i+1,j,a);\n        task(grid,i-1,j,a);\n        task(grid,i,j+1,a);\n        task(grid,i,j-1,a);\n    }\n}\n",
        "explanations": "\nThe bug is a parenthesis mismatch in the if condition inside the task function.\n"
    },
    {
        "slug": "guess-number-higher-or-lower",
        "description": "We are playing the Guess Game. The game is as follows:\nI pick a number from 1 to n. You have to guess which number I picked.\nEvery time you guess wrong, I will tell you whether the number I picked is higher or lower than your guess.\nYou call a pre-defined API int guess(int num), which returns three possible results:\n\n-1: Your guess is higher than the number I picked (i.e. num > pick).\n1: Your guess is lower than the number I picked (i.e. num < pick).\n0: your guess is equal to the number I picked (i.e. num == pick).\n\nReturn the number that I picked.",
        "examples": [
            "Input: n = 10, pick = 6\nOutput: 6",
            "Input: n = 1, pick = 1\nOutput: 1",
            "Input: n = 2, pick = 1\nOutput: 1"
        ],
        "constraints": "1 <= n <= 231 - 1\n1 <= pick <= n",
        "release_time": 1689963688,
        "oracle_code": "/** \n * Forward declaration of guess API.\n * @param  num   your guess\n * @return \t     -1 if num is higher than the picked number\n *\t\t\t      1 if num is lower than the picked number\n *               otherwise return 0\n * int guess(int num);\n */\n\npublic class Solution extends GuessGame {\n    public int guessNumber(int n) {\n        int low=0,high=n;\n        while(low<=high)\n        {\n            int mid=low+(high-low)/2;\n            int x= guess(mid);\n            if(x==0) \n            {\n                return mid;\n            }\n            else if(x==-1)\n            {\n                high=mid-1;\n            }\n            else\n            {\n                low = mid+1;\n            }\n        }\n        return -1;\n    }\n}",
        "content": "# Code\\n```\\n/** \\n * Forward declaration of guess API.\\n * @param  num   your guess\\n * @return \\t     -1 if num is higher than the picked number\\n *\\t\\t\\t      1 if num is lower than the picked number\\n *               otherwise return 0\\n * int guess(int num);\\n */\\n\\npublic class Solution extends GuessGame {\\n    public int guessNumber(int n) {\\n        int low=0,high=n;\\n        while(low<=high)\\n        {\\n            int mid=low+(high-low)/2;\\n            int x= guess(mid);\\n            if(x==0) \\n            {\\n                return mid;\\n            }\\n            else if(x==-1)\\n            {\\n                high=mid-1;\\n            }\\n            else\\n            {\\n                low = mid+1;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
        "level": "easy",
        "buggy_code": "\n/** \n * Forward declaration of guess API.\n * @param  num   your guess\n * @return       -1 if num is higher than the picked number\n *               1 if num is lower than the picked number\n *               otherwise return 0\n * int guess(int num);\n */\n\npublic class Solution extends GuessGame {\n    public int guessNumber(int n) {\n        int low=0,high=n;\n        while(low<=high)\n        {\n            int mid=low+(high-low)/2;\n            int x= guess(mid;\n            if(x==0) \n            {\n                return mid;\n            }\n            else if(x==-1)\n            {\n                high=mid-1;\n            }\n            else\n            {\n                low = mid+1;\n            }\n        }\n        return -1;\n    }\n}\n",
        "explanations": "\nIn line \"int x= guess(mid;\", there is a mismatched parentheses for function call guess()\n"
    }
]