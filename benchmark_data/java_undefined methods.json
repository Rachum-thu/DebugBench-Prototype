[
    {
        "slug": "count-common-words-with-one-occurrence",
        "description": "Given two string arrays words1 and words2, return the number of strings that appear exactly once in each\u00a0of the two arrays.",
        "examples": [
            "Input: words1 = [\"leetcode\",\"is\",\"amazing\",\"as\",\"is\"], words2 = [\"amazing\",\"leetcode\",\"is\"]\nOutput: 2\nExplanation:\n- \"leetcode\" appears exactly once in each of the two arrays. We count this string.\n- \"amazing\" appears exactly once in each of the two arrays. We count this string.\n- \"is\" appears in each of the two arrays, but there are 2 occurrences of it in words1. We do not count this string.\n- \"as\" appears once in words1, but does not appear in words2. We do not count this string.\nThus, there are 2 strings that appear exactly once in each of the two arrays.",
            "Input: words1 = [\"b\",\"bb\",\"bbb\"], words2 = [\"a\",\"aa\",\"aaa\"]\nOutput: 0\nExplanation: There are no strings that appear in each of the two arrays.",
            "Input: words1 = [\"a\",\"ab\"], words2 = [\"a\",\"a\",\"a\",\"ab\"]\nOutput: 1\nExplanation: The only string that appears exactly once in each of the two arrays is \"ab\"."
        ],
        "constraints": "1 <= words1.length, words2.length <= 1000\n1 <= words1[i].length, words2[j].length <= 30\nwords1[i] and words2[j] consists only of lowercase English letters.",
        "release_time": 1685170196,
        "oracle_code": "class Solution {\n    public int countWords(String[] words1, String[] words2) {\n        Map<String, Integer> map1 = new HashMap<>();\n        Map<String, Integer> map2 = new HashMap<>();\n\n        for (String s: words1){\n            if(map1.containsKey(s)) map1.put(s, map1.get(s)+1);\n            else map1.put(s, 1);\n        }\n        for (String s: words2){\n            if(map2.containsKey(s)) map2.put(s, map2.get(s)+1);\n            else map2.put(s, 1);\n        }\n        int count = 0;\n        for(String i : words1){\n            if(map1.get(i) == 1 && map2.getOrDefault(i,0) == 1 ){\n                count++;\n            }\n        }\n\n        return count;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countWords(String[] words1, String[] words2) {\\n        Map<String, Integer> map1 = new HashMap<>();\\n        Map<String, Integer> map2 = new HashMap<>();\\n\\n        for (String s: words1){\\n            if(map1.containsKey(s)) map1.put(s, map1.get(s)+1);\\n            else map1.put(s, 1);\\n        }\\n        for (String s: words2){\\n            if(map2.containsKey(s)) map2.put(s, map2.get(s)+1);\\n            else map2.put(s, 1);\\n        }\\n        int count = 0;\\n        for(String i : words1){\\n            if(map1.get(i) == 1 && map2.getOrDefault(i,0) == 1 ){\\n                count++;\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\n    public int countWords(String[] words1, String[] words2) {\n        Map<String, Integer> map1 = new HashMap<>();\n        Map<String, Integer> map2 = new HashMap<>();\n\n        for (String s: words1){\n            if(map1.containsKey(s)) map1.put(s, map1.get(s)+1);\n            else map1.put(s, 1);\n        }\n        for (String s: words2){\n            if(map2.containsKey(s)) map2.put(s, map2.get(s)+1);\n            else map2.put(s, 1);\n        }\n        int count = 0;\n        for(String i : words1){\n            if(map1.get(i) == 1 && map2.getOrDefault(i,0) == 1 ){\n                count++;\n            }\n        }\n        clearSlate(); \n        return count;\n    }\n    \n    \n}\n",
        "explanations": "\nThe method clearSlate() is called but it is not defined anywhere in the code.\n"
    },
    {
        "slug": "number-of-arithmetic-triplets",
        "description": "You are given a 0-indexed, strictly increasing integer array nums and a positive integer diff. A triplet (i, j, k) is an arithmetic triplet if the following conditions are met:\n\ni < j < k,\nnums[j] - nums[i] == diff, and\nnums[k] - nums[j] == diff.\n\nReturn the number of unique arithmetic triplets.",
        "examples": [
            "Input: nums = [0,1,4,6,7,10], diff = 3\nOutput: 2\nExplanation:\n(1, 2, 4) is an arithmetic triplet because both 7 - 4 == 3 and 4 - 1 == 3.\n(2, 4, 5) is an arithmetic triplet because both 10 - 7 == 3 and 7 - 4 == 3.",
            "Input: nums = [4,5,6,7,8,9], diff = 2\nOutput: 2\nExplanation:\n(0, 2, 4) is an arithmetic triplet because both 8 - 6 == 2 and 6 - 4 == 2.\n(1, 3, 5) is an arithmetic triplet because both 9 - 7 == 2 and 7 - 5 == 2."
        ],
        "constraints": "3 <= nums.length <= 200\n0 <= nums[i] <= 200\n1 <= diff <= 50\nnums is strictly increasing.",
        "release_time": 1671050315,
        "oracle_code": "class Solution {\n    public int arithmeticTriplets(int[] nums, int diff) {\n        \n        int count=0;\n        for(int i=0;i<nums.length;i++){\n            for(int j=i+1;j<nums.length;j++){\n                for(int k=j+1;k<nums.length;k++){\n                    if(nums[j]-nums[i]==diff && nums[k] - nums[j] == diff){\n                        count++;\n                    }\n                }\n            }\n        }\n        \n        return count;\n    }\n}",
        "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int arithmeticTriplets(int[] nums, int diff) {\\n        \\n        int count=0;\\n        for(int i=0;i<nums.length;i++){\\n            for(int j=i+1;j<nums.length;j++){\\n                for(int k=j+1;k<nums.length;k++){\\n                    if(nums[j]-nums[i]==diff && nums[k] - nums[j] == diff){\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\n    public int arithmeticTriplets(int[] nums, int diff) {\n        \n        int count=0;\n        for(int i=0;i<nums.length;i++){\n            for(int j=i+1;j<nums.length;j++){\n                for(int k=j+1;k<nums.length;k++){\n                    if(nums[j]-nums[i]==diff && nums[k] - nums[j] == diff){\n                        count++;\n                    }\n                }\n            }\n        }\n        this.printCount(count);\n        \n        return count;\n    }\n\n\n}\n",
        "explanations": "\nThe printCount method is called but never defined, leading to an undefined methods error.\n"
    },
    {
        "slug": "construct-binary-tree-from-inorder-and-postorder-traversal",
        "description": "Given two integer arrays inorder and postorder where inorder is the inorder traversal of a binary tree and postorder is the postorder traversal of the same tree, construct and return the binary tree.",
        "examples": [
            "Input: inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]\nOutput: [3,9,20,null,null,15,7]",
            "Input: inorder = [-1], postorder = [-1]\nOutput: [-1]"
        ],
        "constraints": "1 <= inorder.length <= 3000\npostorder.length == inorder.length\n-3000 <= inorder[i], postorder[i] <= 3000\ninorder and postorder consist of unique values.\nEach value of postorder also appears in inorder.\ninorder is guaranteed to be the inorder traversal of the tree.\npostorder is guaranteed to be the postorder traversal of the tree.",
        "release_time": 1689531937,
        "oracle_code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    int index;\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\n        Map<Integer, Integer> m = new HashMap<>();\n\n        for(int i = 0; i < inorder.length; i++) {\n            m.put(inorder[i], i);\n        }\n        index = postorder.length - 1;\n        return buildTree(0, postorder.length - 1, postorder, m);\n    }\n\n    private TreeNode buildTree(int l, int r, int postorder[] , Map<Integer, Integer> m) {\n        if(l > r) return null;\n\n        int val = postorder[index];\n        index--;\n\n        TreeNode root = new TreeNode(val);\n        if(l == r) return root;\n\n        int in = m.get(val);\n\n        root.right = buildTree(in + 1, r, postorder, m);\n        root.left = buildTree(l, in - 1, postorder, m);\n\n        return root;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int index;\\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\\n        Map<Integer, Integer> m = new HashMap<>();\\n\\n        for(int i = 0; i < inorder.length; i++) {\\n            m.put(inorder[i], i);\\n        }\\n        index = postorder.length - 1;\\n        return buildTree(0, postorder.length - 1, postorder, m);\\n    }\\n\\n    private TreeNode buildTree(int l, int r, int postorder[] , Map<Integer, Integer> m) {\\n        if(l > r) return null;\\n\\n        int val = postorder[index];\\n        index--;\\n\\n        TreeNode root = new TreeNode(val);\\n        if(l == r) return root;\\n\\n        int in = m.get(val);\\n\\n        root.right = buildTree(in + 1, r, postorder, m);\\n        root.left = buildTree(l, in - 1, postorder, m);\\n\\n        return root;\\n    }\\n}\\n```",
        "level": "medium",
        "buggy_code": "\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    int index;\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\n        Map<Integer, Integer> m = new HashMap<>();\n\n        for(int i = 0; i < inorder.length; i++) {\n            m.put(inorder[i], i);\n        }\n        index = postorder.length - 1;\n        return buildTree(0, postorder.length - 1, postorder, m);\n    }\n\n    private TreeNode buildTree(int l, int r, int postorder[] , Map<Integer, Integer> m) {\n        if(l > r) return null;\n\n        int val = postorder[index];\n        index--;\n\n        TreeNode root = new TreeNode(val);\n        if(l == r) return root;\n\n        int in = m.get(val);\n\n        root.right = buildNewTree(in + 1, r, postorder, m); \n        root.left = buildTree(l, in - 1, postorder, m);\n\n        return root;\n    }\n}\n",
        "explanations": "\nMethod 'buildNewTree' has not been defined in the class Solution.\n"
    },
    {
        "slug": "daily-temperatures",
        "description": "Given an array of integers temperatures represents the daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after the ith day to get a warmer temperature. If there is no future day for which this is possible, keep answer[i] == 0 instead.",
        "examples": [
            "Input: temperatures = [73,74,75,71,69,72,76,73]\nOutput: [1,1,4,2,1,1,0,0]",
            "Input: temperatures = [30,40,50,60]\nOutput: [1,1,1,0]",
            "Input: temperatures = [30,60,90]\nOutput: [1,1,0]"
        ],
        "constraints": "1 <=\u00a0temperatures.length <= 105\n30 <=\u00a0temperatures[i] <= 100",
        "release_time": 1667472111,
        "oracle_code": "class Solution {\n    public int[] dailyTemperatures(int[] temperatures) {\n        \n        int[] arr = new int[temperatures.length]; \n        \n        ArrayDeque<int[]> st = new ArrayDeque<>(); \n        \n        int i=0, j=temperatures.length-1 ; \n        \n        while( j >= 0){\n            \n            if(st.size()==0){\n                arr[i++] = 0;\n            }\n            else  if (st.size()>0 && st.peek()[0]>temperatures[j])\n            {\n                arr[i++]=1;\n            } \n            else if (st.size()>0 && st.peek()[0]<=temperatures[j])\n            \n            {  while(st.size()>0 && st.peek()[0]<=temperatures[j]){\n                    st.pop();\n                    \n                }\n            if(st.size()==0){\n                arr[i++]=0;\n            }\n            else{\n                arr[i++]=st.peek()[1]-j;\n            }\n            } \n        st.push(new int[]{temperatures[j],j}); \n        j--;\n        }\n        \n      \n        int[] ans = new int[temperatures.length]; int k=0;\n        for(i=arr.length-1; i>=0; i--){\n            ans[k++]=arr[i];\n        }\n        return ans;\n    }\n}",
        "content": "```\\nclass Solution {\\n    public int[] dailyTemperatures(int[] temperatures) {\\n        \\n        int[] arr = new int[temperatures.length]; \\n        \\n        ArrayDeque<int[]> st = new ArrayDeque<>(); \\n        \\n        int i=0, j=temperatures.length-1 ; \\n        \\n        while( j >= 0){\\n            \\n            if(st.size()==0){\\n                arr[i++] = 0;\\n            }\\n            else  if (st.size()>0 && st.peek()[0]>temperatures[j])\\n            {\\n                arr[i++]=1;\\n            } \\n            else if (st.size()>0 && st.peek()[0]<=temperatures[j])\\n            \\n            {  while(st.size()>0 && st.peek()[0]<=temperatures[j]){\\n                    st.pop();\\n                    \\n                }\\n            if(st.size()==0){\\n                arr[i++]=0;\\n            }\\n            else{\\n                arr[i++]=st.peek()[1]-j;\\n            }\\n            } \\n        st.push(new int[]{temperatures[j],j}); \\n        j--;\\n        }\\n        \\n      \\n        int[] ans = new int[temperatures.length]; int k=0;\\n        for(i=arr.length-1; i>=0; i--){\\n            ans[k++]=arr[i];\\n        }\\n        return ans;\\n    }\\n}",
        "level": "medium",
        "buggy_code": "\nclass Solution {\n    public int[] dailyTemperatures(int[] temperatures) {\n        \n        int[] arr = new int[temperatures.length]; \n        \n        ArrayDeque<int[]> st = new ArrayDeque<>(); \n        \n        int i=0, j=temperatures.length-1 ; \n        \n        while( j >= 0){\n            \n            if(st.size()==0){\n                arr[i++] = 0;\n            }\n            else  if (st.size()>0 && st.peek()[0]>temperatures[j])\n            {\n                arr[i++]=1;\n            } \n            else if (st.size()>0 && st.peek()[0]<=temperatures[j])\n            \n            {  while(st.size()>0 && st.peek()[0]<=temperatures[j]){\n                    st.pop();\n                    \n                }\n            if(st.size()==0){\n                arr[i++]=0;\n            }\n            else{\n                arr[i++]=st.peek()[1]-j;\n            }\n            } \n\n        doSomething();\n\n        st.push(new int[]{temperatures[j],j}); \n        j--;\n        }\n        \n      \n        int[] ans = new int[temperatures.length]; int k=0;\n        for(i=arr.length-1; i>=0; i--){\n            ans[k++]=arr[i];\n        }\n        return ans;\n    }\n}\n",
        "explanations": "\nThe method 'doSomething()' is called but it has not been defined anywhere in the class. \n"
    },
    {
        "slug": "matrix-block-sum",
        "description": "Given a m x n matrix mat and an integer k, return a matrix answer where each answer[i][j] is the sum of all elements mat[r][c] for:\n\ni - k <= r <= i + k,\nj - k <= c <= j + k, and\n(r, c) is a valid position in the matrix.",
        "examples": [
            "Input: mat = [[1,2,3],[4,5,6],[7,8,9]], k = 1\nOutput: [[12,21,16],[27,45,33],[24,39,28]]",
            "Input: mat = [[1,2,3],[4,5,6],[7,8,9]], k = 2\nOutput: [[45,45,45],[45,45,45],[45,45,45]]"
        ],
        "constraints": "m ==\u00a0mat.length\nn ==\u00a0mat[i].length\n1 <= m, n, k <= 100\n1 <= mat[i][j] <= 100",
        "release_time": 1682501669,
        "oracle_code": "class Solution {\n    public int[][] matrixBlockSum(int[][] mat, int k) {\n        int[][] answer = new int[mat.length][mat[0].length];\n\n        for(int i = 0; i < mat.length; i++) {\n            for(int j = 0; j < mat[0].length; j++) {\n                int rowStart = i-k;\n                int rowEnd = i+k;\n                int colStart = j-k;\n                int colEnd = j+k;\n\n                if(rowStart < 0) {\n                    rowStart = 0;\n                }\n\n                if(rowEnd >= mat.length) {\n                    rowEnd = mat.length - 1;\n                }\n\n                if(colStart < 0) {\n                    colStart = 0;\n                }\n\n                if(colEnd >= mat[0].length) {\n                    colEnd = mat[0].length - 1;\n                }\n\n                answer[i][j] = blockSum(mat, rowStart, rowEnd, colStart, colEnd);\n            }\n        }\n\n        return answer;\n    }\n\n    private int blockSum(int[][] mat, int rowStart, int rowEnd, int colStart, int colEnd) {\n        int sum = 0;\n\n        for(int i = rowStart; i <= rowEnd; i++) {\n            for(int j = colStart; j <= colEnd; j++) {\n                sum += mat[i][j];\n            }\n        }\n        return sum;\n    }\n}",
        "content": "# Code\\n```\\nclass Solution {\\n    public int[][] matrixBlockSum(int[][] mat, int k) {\\n        int[][] answer = new int[mat.length][mat[0].length];\\n\\n        for(int i = 0; i < mat.length; i++) {\\n            for(int j = 0; j < mat[0].length; j++) {\\n                int rowStart = i-k;\\n                int rowEnd = i+k;\\n                int colStart = j-k;\\n                int colEnd = j+k;\\n\\n                if(rowStart < 0) {\\n                    rowStart = 0;\\n                }\\n\\n                if(rowEnd >= mat.length) {\\n                    rowEnd = mat.length - 1;\\n                }\\n\\n                if(colStart < 0) {\\n                    colStart = 0;\\n                }\\n\\n                if(colEnd >= mat[0].length) {\\n                    colEnd = mat[0].length - 1;\\n                }\\n\\n                answer[i][j] = blockSum(mat, rowStart, rowEnd, colStart, colEnd);\\n            }\\n        }\\n\\n        return answer;\\n    }\\n\\n    private int blockSum(int[][] mat, int rowStart, int rowEnd, int colStart, int colEnd) {\\n        int sum = 0;\\n\\n        for(int i = rowStart; i <= rowEnd; i++) {\\n            for(int j = colStart; j <= colEnd; j++) {\\n                sum += mat[i][j];\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\n    public int[][] matrixBlockSum(int[][] mat, int k) {\n        int[][] answer = new int[mat.length][mat[0].length];\n\n        for(int i = 0; i < mat.length; i++) {\n            for(int j = 0; j < mat[0].length; j++) {\n                int rowStart = i-k;\n                int rowEnd = i+k;\n                int colStart = j-k;\n                int colEnd = j+k;\n\n                if(rowStart < 0) {\n                    rowStart = 0;\n                }\n\n                if(rowEnd >= mat.length) {\n                    rowEnd = mat.length - 1;\n                }\n\n                if(colStart < 0) {\n                    colStart = 0;\n                }\n\n                if(colEnd >= mat[0].length) {\n                    colEnd = mat[0].length - 1;\n                }\n\n                answer[i][j] = calculatorBlockSum(mat, rowStart, rowEnd, colStart, colEnd);\n            }\n        }\n\n        return answer;\n    }\n\n    private int blockSum(int[][] mat, int rowStart, int rowEnd, int colStart, int colEnd) {\n        int sum = 0;\n\n        for(int i = rowStart; i <= rowEnd; i++) {\n            for(int j = colStart; j <= colEnd; j++) {\n                sum += mat[i][j];\n            }\n        }\n        return sum;\n    }\n}\n",
        "explanations": "\nThe method 'calculatorBlockSum' is being called in 'matrixBlockSum' but it is not defined.\n"
    },
    {
        "slug": "find-the-distinct-difference-array",
        "description": "You are given a 0-indexed array nums of length n.\nThe distinct difference array of nums is an array diff of length n such that diff[i] is equal to the number of distinct elements in the suffix nums[i + 1, ..., n - 1] subtracted from the number of distinct elements in the prefix nums[0, ..., i].\nReturn the distinct difference array of nums.\nNote that nums[i, ..., j] denotes the subarray of nums starting at index i and ending at index j inclusive. Particularly, if i > j then nums[i, ..., j] denotes an empty subarray.",
        "examples": [
            "Input: nums = [1,2,3,4,5]\nOutput: [-3,-1,1,3,5]\nExplanation: For index i = 0, there is 1 element in the prefix and 4 distinct elements in the suffix. Thus, diff[0] = 1 - 4 = -3.\nFor index i = 1, there are 2 distinct elements in the prefix and 3 distinct elements in the suffix. Thus, diff[1] = 2 - 3 = -1.\nFor index i = 2, there are 3 distinct elements in the prefix and 2 distinct elements in the suffix. Thus, diff[2] = 3 - 2 = 1.\nFor index i = 3, there are 4 distinct elements in the prefix and 1 distinct element in the suffix. Thus, diff[3] = 4 - 1 = 3.\nFor index i = 4, there are 5 distinct elements in the prefix and no elements in the suffix. Thus, diff[4] = 5 - 0 = 5.",
            "Input: nums = [3,2,3,4,2]\nOutput: [-2,-1,0,2,3]\nExplanation: For index i = 0, there is 1 element in the prefix and 3 distinct elements in the suffix. Thus, diff[0] = 1 - 3 = -2.\nFor index i = 1, there are 2 distinct elements in the prefix and 3 distinct elements in the suffix. Thus, diff[1] = 2 - 3 = -1.\nFor index i = 2, there are 2 distinct elements in the prefix and 2 distinct elements in the suffix. Thus, diff[2] = 2 - 2 = 0.\nFor index i = 3, there are 3 distinct elements in the prefix and 1 distinct element in the suffix. Thus, diff[3] = 3 - 1 = 2.\nFor index i = 4, there are 3 distinct elements in the prefix and no elements in the suffix. Thus, diff[4] = 3 - 0 = 3."
        ],
        "constraints": "1 <= n == nums.length\u00a0<= 50\n1 <= nums[i] <= 50",
        "release_time": 1683444191,
        "oracle_code": "class Solution {\n    public int[] distinctDifferenceArray(int[] nums) {\n        int n=nums.length;\n        int ans[]=new int[n];\n        \n        for(int i=0;i<n;i++){\n            Set<Integer>set1=new HashSet<>();\n            Set<Integer>set2=new HashSet<>();\n            \n            for(int j=0;j<=i;j++){\n                set1.add(nums[j]);\n            }\n            for(int j=i+1;j<n;j++){\n                set2.add(nums[j]);\n            }\n            \n            ans[i]= set1.size() - set2.size();\n        }\n        return ans;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        int n=nums.length;\\n        int ans[]=new int[n];\\n        \\n        for(int i=0;i<n;i++){\\n            Set<Integer>set1=new HashSet<>();\\n            Set<Integer>set2=new HashSet<>();\\n            \\n            for(int j=0;j<=i;j++){\\n                set1.add(nums[j]);\\n            }\\n            for(int j=i+1;j<n;j++){\\n                set2.add(nums[j]);\\n            }\\n            \\n            ans[i]= set1.size() - set2.size();\\n        }\\n        return ans;\\n    }\\n}\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\n    public int[] distinctDifferenceArray(int[] nums) {\n        int n=nums.length;\n        int ans[]=new int[n];\n        \n        for(int i=0;i<n;i++){\n            Set<Integer>set1=new HashSet<>();\n            Set<Integer>set2=new HashSet<>();\n            \n            for(int j=0;j<=i;j++){\n                set1.add(nums[j]);\n            }\n            for(int j=i+1;j<n;j++){\n                set2.add(nums[j]);\n            }\n            \n            ans[i]= set1.size() - undefinedMethod(set2);\n        }\n        return ans;\n    }\n}\n",
        "explanations": "\nThe code is calling an undefined method 'undefinedMethod(set2)', thus, it will raise an error.\n"
    },
    {
        "slug": "probability-of-a-two-boxes-having-the-same-number-of-distinct-balls",
        "description": "Given 2n balls of k distinct colors. You will be given an integer array balls of size k where balls[i] is the number of balls of color i.\nAll the balls will be shuffled uniformly at random, then we will distribute the first n balls to the first box and the remaining n balls to the other box (Please read the explanation of the second example carefully).\nPlease note that the two boxes are considered different. For example, if we have two balls of colors a and b, and two boxes [] and (), then the distribution [a] (b) is considered different than the distribution [b] (a) (Please read the explanation of the first example carefully).\nReturn the probability that the two boxes have the same number of distinct balls. Answers within 10-5 of the actual value will be accepted as correct.",
        "examples": [
            "Input: balls = [1,1]\nOutput: 1.00000\nExplanation: Only 2 ways to divide the balls equally:\n- A ball of color 1 to box 1 and a ball of color 2 to box 2\n- A ball of color 2 to box 1 and a ball of color 1 to box 2\nIn both ways, the number of distinct colors in each box is equal. The probability is 2/2 = 1",
            "Input: balls = [2,1,1]\nOutput: 0.66667\nExplanation: We have the set of balls [1, 1, 2, 3]\nThis set of balls will be shuffled randomly and we may have one of the 12 distinct shuffles with equal probability (i.e. 1/12):\n[1,1 / 2,3], [1,1 / 3,2], [1,2 / 1,3], [1,2 / 3,1], [1,3 / 1,2], [1,3 / 2,1], [2,1 / 1,3], [2,1 / 3,1], [2,3 / 1,1], [3,1 / 1,2], [3,1 / 2,1], [3,2 / 1,1]\nAfter that, we add the first two balls to the first box and the second two balls to the second box.\nWe can see that 8 of these 12 possible random distributions have the same number of distinct colors of balls in each box.\nProbability is 8/12 = 0.66667",
            "Input: balls = [1,2,1,2]\nOutput: 0.60000\nExplanation: The set of balls is [1, 2, 2, 3, 4, 4]. It is hard to display all the 180 possible random shuffles of this set but it is easy to check that 108 of them will have the same number of distinct colors in each box.\nProbability = 108 / 180 = 0.6"
        ],
        "constraints": "1 <= balls.length <= 8\n1 <= balls[i] <= 6\nsum(balls) is even.",
        "release_time": 1689418968,
        "oracle_code": "class Solution {\n    double possible = 0.0;\n    double valid = 0.0;\n    \n    public double getProbability(int[] balls) {\n        int[] first = new int[balls.length];\n        int[] second = new int[balls.length];\n        dfs(balls, first, second, 0, 0, 0);\n        return valid / possible;\n    }\n    \n    private void dfs(int[] balls, int[] first, int[] second, int num1, int num2, int idx) {\n        // finish all colors, check if this's a possible/valid distribution\n        if (idx == balls.length) {\n            // find one possible distribution\n            if (num1 == num2) {\n                // compute fake permutation\n                double distrib = permFake(first) * permFake(second);\n                possible += distrib;\n                \n                // find one valid distribution\n                if (unique(first) == unique(second)) {\n                    valid += distrib;\n                }\n            }\n            return;\n        }\n        \n        // distribute balls in current color to two bins\n        for (int b = 0; b <= balls[idx]; b++) {\n            first[idx] = b;\n            second[idx] = balls[idx] - b;\n            dfs (balls, first, second, num1 + first[idx], num2 + second[idx], idx + 1);\n        }\n    }\n    \n    // unique colors in \n    private int unique(int[] balls) {\n        int unique = 0;\n        for (int b: balls)\n            unique += b > 0 ? 1 : 0;\n        return unique;\n    }\n    \n    // return 1 / (b1!b2!b3!...bn!) \n    private double permFake(int[] balls) {\n        double ret = 1.0;\n        for (int b: balls)\n            ret /= factorial(b);\n        return ret;\n    }\n    \n    private int factorial(int n){\n        int ret = 1;\n        while (n > 0) {\n            ret *= n;\n            n--;\n        }\n        return ret;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    double possible = 0.0;\\n    double valid = 0.0;\\n    \\n    public double getProbability(int[] balls) {\\n        int[] first = new int[balls.length];\\n        int[] second = new int[balls.length];\\n        dfs(balls, first, second, 0, 0, 0);\\n        return valid / possible;\\n    }\\n    \\n    private void dfs(int[] balls, int[] first, int[] second, int num1, int num2, int idx) {\\n        // finish all colors, check if this\\'s a possible/valid distribution\\n        if (idx == balls.length) {\\n            // find one possible distribution\\n            if (num1 == num2) {\\n                // compute fake permutation\\n                double distrib = permFake(first) * permFake(second);\\n                possible += distrib;\\n                \\n                // find one valid distribution\\n                if (unique(first) == unique(second)) {\\n                    valid += distrib;\\n                }\\n            }\\n            return;\\n        }\\n        \\n        // distribute balls in current color to two bins\\n        for (int b = 0; b <= balls[idx]; b++) {\\n            first[idx] = b;\\n            second[idx] = balls[idx] - b;\\n            dfs (balls, first, second, num1 + first[idx], num2 + second[idx], idx + 1);\\n        }\\n    }\\n    \\n    // unique colors in \\n    private int unique(int[] balls) {\\n        int unique = 0;\\n        for (int b: balls)\\n            unique += b > 0 ? 1 : 0;\\n        return unique;\\n    }\\n    \\n    // return 1 / (b1!b2!b3!...bn!) \\n    private double permFake(int[] balls) {\\n        double ret = 1.0;\\n        for (int b: balls)\\n            ret /= factorial(b);\\n        return ret;\\n    }\\n    \\n    private int factorial(int n){\\n        int ret = 1;\\n        while (n > 0) {\\n            ret *= n;\\n            n--;\\n        }\\n        return ret;\\n    }\\n}\\n```",
        "level": "hard",
        "buggy_code": "\nclass Solution {\n    double possible = 0.0;\n    double valid = 0.0;\n    \n    public double getProbability(int[] balls) {\n        int[] first = new int[balls.length];\n        int[] second = new int[balls.length];\n        dfs(balls, first, second, 0, 0, 0);\n        return valid / possible;\n    }\n    \n    private void dfs(int[] balls, int[] first, int[] second, int num1, int num2, int idx) {\n        // finish all colors, check if this's a possible/valid distribution\n        if (idx == balls.length) {\n            // find one possible distribution\n            if (num1 == num2) {\n                // compute fake permutation\n                double distrib = permFake(first) * permFake(second);\n                possible += distrib;\n                \n                // find one valid distribution\n                if (unique(first) == unique(second)) {\n                    valid += distrib;\n                }\n            }\n            return;\n        }\n        \n        // distribute balls in current color to two bins\n        for (int b = 0; b <= balls[idx]; b++) {\n            first[idx] = b;\n            second[idx] = balls[idx] - b;\n            dfs (balls, first, second, num1 + first[idx], num2 + second[idx], idx + 1);\n        }\n    }\n    \n    private int factorial(int n){\n        int ret = 1;\n        while (n > 0) {\n            ret *= n;\n            n--;\n        }\n        return ret;\n    }\n}\n",
        "explanations": "\nThe methods permFake() and unique() are not defined, causing a compilation error.\n"
    },
    {
        "slug": "find-all-people-with-secret",
        "description": "You are given an integer n indicating there are n people numbered from 0 to n - 1. You are also given a 0-indexed 2D integer array meetings where meetings[i] = [xi, yi, timei] indicates that person xi and person yi have a meeting at timei. A person may attend multiple meetings at the same time. Finally, you are given an integer firstPerson.\nPerson 0 has a secret and initially shares the secret with a person firstPerson at time 0. This secret is then shared every time a meeting takes place with a person that has the secret. More formally, for every meeting, if a person xi has the secret at timei, then they will share the secret with person yi, and vice versa.\nThe secrets are shared instantaneously. That is, a person may receive the secret and share it with people in other meetings within the same time frame.\nReturn a list of all the people that have the secret after all the meetings have taken place. You may return the answer in any order.",
        "examples": [
            "Input: n = 6, meetings = [[1,2,5],[2,3,8],[1,5,10]], firstPerson = 1\nOutput: [0,1,2,3,5]\nExplanation:\nAt time 0, person 0 shares the secret with person 1.\nAt time 5, person 1 shares the secret with person 2.\nAt time 8, person 2 shares the secret with person 3.\nAt time 10, person 1 shares the secret with person 5.\u200b\u200b\u200b\u200b\nThus, people 0, 1, 2, 3, and 5 know the secret after all the meetings.",
            "Input: n = 4, meetings = [[3,1,3],[1,2,2],[0,3,3]], firstPerson = 3\nOutput: [0,1,3]\nExplanation:\nAt time 0, person 0 shares the secret with person 3.\nAt time 2, neither person 1 nor person 2 know the secret.\nAt time 3, person 3 shares the secret with person 0 and person 1.\nThus, people 0, 1, and 3 know the secret after all the meetings.",
            "Input: n = 5, meetings = [[3,4,2],[1,2,1],[2,3,1]], firstPerson = 1\nOutput: [0,1,2,3,4]\nExplanation:\nAt time 0, person 0 shares the secret with person 1.\nAt time 1, person 1 shares the secret with person 2, and person 2 shares the secret with person 3.\nNote that person 2 can share the secret at the same time as receiving it.\nAt time 2, person 3 shares the secret with person 4.\nThus, people 0, 1, 2, 3, and 4 know the secret after all the meetings."
        ],
        "constraints": "2 <= n <= 105\n1 <= meetings.length <= 105\nmeetings[i].length == 3\n0 <= xi, yi <= n - 1\nxi != yi\n1 <= timei <= 105\n1 <= firstPerson <= n - 1",
        "release_time": 1687729516,
        "oracle_code": "class DisjointSet {\n    int[] root;\n    Long[] rank;\n    DisjointSet(int size, Set<Integer> secretKeepers) {\n        root = new int[size];\n        rank = new Long[size];\n        for (int i = 0; i < size; i++) {\n            root[i] = i;\n            rank[i] = secretKeepers.contains(i) ? Integer.MAX_VALUE : 1L;\n        }\n    }\n\n    public int find(int vertex) {\n        if(root[vertex] == vertex) return vertex;\n        return root[vertex] = find(root[vertex]);\n    }\n\n    public void union(int vertex1, int vertex2) {\n        int root1 = find(vertex1);\n        int root2 = find(vertex2);\n        if(root1 != root2) {\n            if(rank[root1] > rank[root2]) {\n                root[root2] = root1;\n            } else if (rank[root2] > rank[root1]) {\n                root[root1] = root2;\n            } else {\n                root[root2] = root1;\n                rank[root1]++;\n            }\n        }\n    }\n\n    public Set<Integer> getAllSecretKeepers(Set<Integer> secretKeepers, Set<Integer> visited) {\n        for (int vertex: visited) {\n            if(secretKeepers.contains(find(vertex)))\n                secretKeepers.add(vertex);\n            else \n                root[vertex] = vertex;\n        }\n        return secretKeepers;\n    }\n}\n\nclass Solution {\n    private int maxTime = Integer.MIN_VALUE;\n    private int minTime = Integer.MAX_VALUE;\n    public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {\n        Set<Integer> secretKeepers = new HashSet<>(List.of(0, firstPerson));\n        Map<Integer, List<Integer[]>> timeToMeetings = getTimeToMeetings(meetings);\n        DisjointSet disjointSet = new DisjointSet(n, secretKeepers);\n        for (int time = minTime; time <= maxTime; time++) {\n            if(!timeToMeetings.containsKey(time)) continue;\n            Set<Integer> visited = new HashSet<>();\n            for (Integer[] meeting: timeToMeetings.get(time)) {\n                int person1 = meeting[0], person2 = meeting[1];\n                disjointSet.union(person1, person2);\n                visited.add(person1);\n                visited.add(person2);\n            }\n            secretKeepers = disjointSet.getAllSecretKeepers(secretKeepers, visited);\n        }\n        return new ArrayList<>(secretKeepers);\n    }\n\n    private Map<Integer, List<Integer[]>> getTimeToMeetings(int[][] meetings) {\n        Map<Integer, List<Integer[]>> timeToMeetings = new HashMap<>();\n        for (int[] meeting: meetings) {\n            maxTime = Math.max(maxTime, meeting[2]);\n            minTime = Math.min(minTime, meeting[2]);\n            timeToMeetings.computeIfAbsent(meeting[2], e-> new ArrayList<>()).add(new Integer[]{meeting[0], meeting[1]});\n        }\n        return timeToMeetings;\n    }\n}",
        "content": "# Code\\n```\\nclass DisjointSet {\\n    int[] root;\\n    Long[] rank;\\n    DisjointSet(int size, Set<Integer> secretKeepers) {\\n        root = new int[size];\\n        rank = new Long[size];\\n        for (int i = 0; i < size; i++) {\\n            root[i] = i;\\n            rank[i] = secretKeepers.contains(i) ? Integer.MAX_VALUE : 1L;\\n        }\\n    }\\n\\n    public int find(int vertex) {\\n        if(root[vertex] == vertex) return vertex;\\n        return root[vertex] = find(root[vertex]);\\n    }\\n\\n    public void union(int vertex1, int vertex2) {\\n        int root1 = find(vertex1);\\n        int root2 = find(vertex2);\\n        if(root1 != root2) {\\n            if(rank[root1] > rank[root2]) {\\n                root[root2] = root1;\\n            } else if (rank[root2] > rank[root1]) {\\n                root[root1] = root2;\\n            } else {\\n                root[root2] = root1;\\n                rank[root1]++;\\n            }\\n        }\\n    }\\n\\n    public Set<Integer> getAllSecretKeepers(Set<Integer> secretKeepers, Set<Integer> visited) {\\n        for (int vertex: visited) {\\n            if(secretKeepers.contains(find(vertex)))\\n                secretKeepers.add(vertex);\\n            else \\n                root[vertex] = vertex;\\n        }\\n        return secretKeepers;\\n    }\\n}\\n\\nclass Solution {\\n    private int maxTime = Integer.MIN_VALUE;\\n    private int minTime = Integer.MAX_VALUE;\\n    public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {\\n        Set<Integer> secretKeepers = new HashSet<>(List.of(0, firstPerson));\\n        Map<Integer, List<Integer[]>> timeToMeetings = getTimeToMeetings(meetings);\\n        DisjointSet disjointSet = new DisjointSet(n, secretKeepers);\\n        for (int time = minTime; time <= maxTime; time++) {\\n            if(!timeToMeetings.containsKey(time)) continue;\\n            Set<Integer> visited = new HashSet<>();\\n            for (Integer[] meeting: timeToMeetings.get(time)) {\\n                int person1 = meeting[0], person2 = meeting[1];\\n                disjointSet.union(person1, person2);\\n                visited.add(person1);\\n                visited.add(person2);\\n            }\\n            secretKeepers = disjointSet.getAllSecretKeepers(secretKeepers, visited);\\n        }\\n        return new ArrayList<>(secretKeepers);\\n    }\\n\\n    private Map<Integer, List<Integer[]>> getTimeToMeetings(int[][] meetings) {\\n        Map<Integer, List<Integer[]>> timeToMeetings = new HashMap<>();\\n        for (int[] meeting: meetings) {\\n            maxTime = Math.max(maxTime, meeting[2]);\\n            minTime = Math.min(minTime, meeting[2]);\\n            timeToMeetings.computeIfAbsent(meeting[2], e-> new ArrayList<>()).add(new Integer[]{meeting[0], meeting[1]});\\n        }\\n        return timeToMeetings;\\n    }\\n}\\n```",
        "level": "hard",
        "buggy_code": "\nclass DisjointSet {\n    int[] root;\n    Long[] rank;\n    DisjointSet(int size, Set<Integer> secretKeepers) {\n        root = new int[size];\n        rank = new Long[size];\n        for (int i = 0; i < size; i++) {\n            root[i] = i;\n            rank[i] = secretKeepers.contains(i) ? Integer.MAX_VALUE : 1L;\n        }\n    }\n\n    public int find(int vertex) {\n        if(root[vertex] == vertex) return vertex;\n        return root[vertex] = find(root[vertex]);\n    }\n\n    public void union(int vertex1, int vertex2) {\n        int root1 = find(vertex1);\n        int root2 = find(vertex2);\n        if(root1 != root2) {\n            if(rank[root1] > rank[root2]) {\n                root[root2] = root1;\n            } else if (rank[root2] > rank[root1]) {\n                root[root1] = root2;\n            } else {\n                root[root2] = root1;\n                rank[root1]++;\n            }\n        }\n    }\n\n    public Set<Integer> getAllSecretKeepers(Set<Integer> secretKeepers, Set<Integer> visited) {\n        checkSecrets(vertex);\n        for (int vertex: visited) {\n            if(secretKeepers.contains(find(vertex)))\n                secretKeepers.add(vertex);\n            else \n                root[vertex] = vertex;\n        }\n        return secretKeepers;\n    }\n}\n\nclass Solution {\n    private int maxTime = Integer.MIN_VALUE;\n    private int minTime = Integer.MAX_VALUE;\n    public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {\n        Set<Integer> secretKeepers = new HashSet<>(List.of(0, firstPerson));\n        Map<Integer, List<Integer[]>> timeToMeetings = getTimeToMeetings(meetings);\n        DisjointSet disjointSet = new DisjointSet(n, secretKeepers);\n        for (int time = minTime; time <= maxTime; time++) {\n            if(!timeToMeetings.containsKey(time)) continue;\n            Set<Integer> visited = new HashSet<>();\n            for (Integer[] meeting: timeToMeetings.get(time)) {\n                int person1 = meeting[0], person2 = meeting[1];\n                disjointSet.union(person1, person2);\n                visited.add(person1);\n                visited.add(person2);\n            }\n            secretKeepers = disjointSet.getAllSecretKeepers(secretKeepers, visited);\n        }\n        return new ArrayList<>(secretKeepers);\n    }\n\n    private Map<Integer, List<Integer[]>> getTimeToMeetings(int[][] meetings) {\n        Map<Integer, List<Integer[]>> timeToMeetings = new HashMap<>();\n        for (int[] meeting: meetings) {\n            maxTime = Math.max(maxTime, meeting[2]);\n            minTime = Math.min(minTime, meeting[2]);\n            timeToMeetings.computeIfAbsent(meeting[2], e-> new ArrayList<>()).add(new Integer[]{meeting[0], meeting[1]});\n        }\n        return timeToMeetings;\n    }\n}\n",
        "explanations": "\nThe checkSecrets() method is invoked in getAllSecretKeepers() method but it's not defined anywhere.\n"
    },
    {
        "slug": "rearrange-characters-to-make-target-string",
        "description": "You are given two 0-indexed strings s and target. You can take some letters from s and rearrange them to form new strings.\nReturn the maximum number of copies of target that can be formed by taking letters from s and rearranging them.",
        "examples": [
            "Input: s = \"ilovecodingonleetcode\", target = \"code\"\nOutput: 2\nExplanation:\nFor the first copy of \"code\", take the letters at indices 4, 5, 6, and 7.\nFor the second copy of \"code\", take the letters at indices 17, 18, 19, and 20.\nThe strings that are formed are \"ecod\" and \"code\" which can both be rearranged into \"code\".\nWe can make at most two copies of \"code\", so we return 2.",
            "Input: s = \"abcba\", target = \"abc\"\nOutput: 1\nExplanation:\nWe can make one copy of \"abc\" by taking the letters at indices 0, 1, and 2.\nWe can make at most one copy of \"abc\", so we return 1.\nNote that while there is an extra 'a' and 'b' at indices 3 and 4, we cannot reuse the letter 'c' at index 2, so we cannot make a second copy of \"abc\".",
            "Input: s = \"abbaccaddaeea\", target = \"aaaaa\"\nOutput: 1\nExplanation:\nWe can make one copy of \"aaaaa\" by taking the letters at indices 0, 3, 6, 9, and 12.\nWe can make at most one copy of \"aaaaa\", so we return 1."
        ],
        "constraints": "1 <= s.length <= 100\n1 <= target.length <= 10\ns and target consist of lowercase English letters.",
        "release_time": 1673614634,
        "oracle_code": "class Solution {\n    public int rearrangeCharacters(String s, String target) {\n        int[] cnt1 = new int[26];\n        int[] cnt2 = new int[26];\n        for (int i = 0; i < s.length(); ++i) {\n            ++cnt1[s.charAt(i) - 'a'];\n        }\n        for (int i = 0; i < target.length(); ++i) {\n            ++cnt2[target.charAt(i) - 'a'];\n        }\n        int ans = 100;\n        for (int i = 0; i < 26; ++i) {\n            if (cnt2[i] > 0) {\n                ans = Math.min(ans, cnt1[i] / cnt2[i]);\n            }\n        }\n        return ans;\n    }\n}",
        "content": "\\n# Code\\n```\\nclass Solution {\\n    public int rearrangeCharacters(String s, String target) {\\n        int[] cnt1 = new int[26];\\n        int[] cnt2 = new int[26];\\n        for (int i = 0; i < s.length(); ++i) {\\n            ++cnt1[s.charAt(i) - \\'a\\'];\\n        }\\n        for (int i = 0; i < target.length(); ++i) {\\n            ++cnt2[target.charAt(i) - \\'a\\'];\\n        }\\n        int ans = 100;\\n        for (int i = 0; i < 26; ++i) {\\n            if (cnt2[i] > 0) {\\n                ans = Math.min(ans, cnt1[i] / cnt2[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\n    public int rearrangeCharacters(String s, String target) {\n        int[] cnt1 = new int[26];\n        int[] cnt2 = new int[26];\n        for (int i = 0; i < s.length(); ++i) {\n            ++cnt1[s.charAt(i) - 'a'];\n        }\n        for (int i = 0; i < target.length(); ++i) {\n            ++cnt2[target.charAt(i) - 'a'];\n        }\n        int ans = 100;\n        for (int i = 0; i < 26; ++i) {\n            if (cnt2[i] > 0) {\n                ans = Math.min(ans, cnt1[i] / cnt2[i]);\n            }\n        }\n        return minimumSteps(ans);\n    }\n    \n    public int minimumSteps(int num){\n        return num - 10;\n    }\n}\n",
        "explanations": "\nThe method minimumSteps is undefined in the initial code and causes an unexpected error.\n"
    },
    {
        "slug": "orderly-queue",
        "description": "You are given a string s and an integer k. You can choose one of the first k letters of s and append it at the end of the string..\nReturn the lexicographically smallest string you could have after applying the mentioned step any number of moves.",
        "examples": [
            "Input: s = \"cba\", k = 1\nOutput: \"acb\"\nExplanation: \nIn the first move, we move the 1st character 'c' to the end, obtaining the string \"bac\".\nIn the second move, we move the 1st character 'b' to the end, obtaining the final result \"acb\".",
            "Input: s = \"baaca\", k = 3\nOutput: \"aaabc\"\nExplanation: \nIn the first move, we move the 1st character 'b' to the end, obtaining the string \"aacab\".\nIn the second move, we move the 3rd character 'c' to the end, obtaining the final result \"aaabc\"."
        ],
        "constraints": "1 <= k <= s.length <= 1000\ns consist of lowercase English letters.",
        "release_time": 1667735681,
        "oracle_code": "class Solution {\n    public String orderlyQueue(String s, int k) {\n        if(k>1){                        //whenver we k>1 we can make the most smallest lexographic combo\n            char ch[]=s.toCharArray();  \n            Arrays.sort(ch);\n            return String.valueOf(ch);\n        }\n        else{   //when k=1 we have restriction to move only ine so will see from what index smallest lexo start\n             String str2=new String(s);\n             for(int i=0;i<s.length();i++){\n                s=s.substring(1)+s.charAt(0); // first element is being shifted to last\n                if(str2.compareTo(s)>0){        //if this lexo combo is smaller than previous\n                    str2=s;                     //store smaller lexo combo\n                } \n             }\n             return str2;\n        }     \n    }\n}",
        "content": "```\\nclass Solution {\\n    public String orderlyQueue(String s, int k) {\\n        if(k>1){                        //whenver we k>1 we can make the most smallest lexographic combo\\n            char ch[]=s.toCharArray();  \\n            Arrays.sort(ch);\\n            return String.valueOf(ch);\\n        }\\n        else{   //when k=1 we have restriction to move only ine so will see from what index smallest lexo start\\n             String str2=new String(s);\\n             for(int i=0;i<s.length();i++){\\n                s=s.substring(1)+s.charAt(0); // first element is being shifted to last\\n                if(str2.compareTo(s)>0){        //if this lexo combo is smaller than previous\\n                    str2=s;                     //store smaller lexo combo\\n                } \\n             }\\n             return str2;\\n        }     \\n    }\\n}\\n```",
        "level": "hard",
        "buggy_code": "\nclass Solution {\n    public String orderlyQueue(String s, int k) {\n        if(k>1){                       \n            char ch[]=s.toCharArray();  \n            Arrays.sort(ch);\n            return String.valueOf(ch);\n        }\n        else{   \n             String str2=new String(s);\n             for(int i=0;i<s.length();i++){\n                s=s.substring(1)+s.charAt(0);\n                if(str2.compareTo(UndefinedMethod(s))>0){        \n                    str2=s;                     \n                } \n             }\n             return str2;\n        }     \n    }\n}\n",
        "explanations": "\nMethod 'UndefinedMethod(s)' has been called but it hasn't been declared or defined anywhere in the program.\n"
    },
    {
        "slug": "find-all-lonely-numbers-in-the-array",
        "description": "You are given an integer array nums. A number x is lonely when it appears only once, and no adjacent numbers (i.e. x + 1 and x - 1) appear in the array.\nReturn all lonely numbers in nums. You may return the answer in any order.",
        "examples": [
            "Input: nums = [10,6,5,8]\nOutput: [10,8]\nExplanation: \n- 10 is a lonely number since it appears exactly once and 9 and 11 does not appear in nums.\n- 8 is a lonely number since it appears exactly once and 7 and 9 does not appear in nums.\n- 5 is not a lonely number since 6 appears in nums and vice versa.\nHence, the lonely numbers in nums are [10, 8].\nNote that [8, 10] may also be returned.",
            "Input: nums = [1,3,5,3]\nOutput: [1,5]\nExplanation: \n- 1 is a lonely number since it appears exactly once and 0 and 2 does not appear in nums.\n- 5 is a lonely number since it appears exactly once and 4 and 6 does not appear in nums.\n- 3 is not a lonely number since it appears twice.\nHence, the lonely numbers in nums are [1, 5].\nNote that [5, 1] may also be returned."
        ],
        "constraints": "1 <= nums.length <= 105\n0 <= nums[i] <= 106",
        "release_time": 1672209386,
        "oracle_code": "class Solution {\n    public List<Integer> findLonely(int[] arr) {\n        HashMap<Integer, Integer> map = new HashMap<>();\n        ArrayList<Integer> list = new ArrayList<>();\n        \n        for (int i : arr) map.put(i, map.getOrDefault(i, 0) + 1);\n        for (int i : arr) if (map.get(i) == 1 && !map.containsKey(i - 1) && !map.containsKey(i + 1)) list.add(i);\n        return list;\n    }\n}",
        "content": "\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> findLonely(int[] arr) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        ArrayList<Integer> list = new ArrayList<>();\\n        \\n        for (int i : arr) map.put(i, map.getOrDefault(i, 0) + 1);\\n        for (int i : arr) if (map.get(i) == 1 && !map.containsKey(i - 1) && !map.containsKey(i + 1)) list.add(i);\\n        return list;\\n    }\\n}\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\n    public List<Integer> checkLonely(int[] arr) {\n        HashMap<Integer, Integer> map = new HashMap<>();\n        ArrayList<Integer> list = new ArrayList<>();\n        \n        for (int i : arr) map.put(i, map.getOrDefault(i, 0) + 1);\n        for (int i : arr) if (map.get(i) == 1 && !map.containsKey(i - 1) && !map.containsKey(i + 1)) list.add(i);\n        return list;\n    }\n}\n",
        "explanations": "\nThe method that is called in the class doesn't exist, causing an undefined method error.\n"
    },
    {
        "slug": "count-number-of-pairs-with-absolute-difference-k",
        "description": "Given an integer array nums and an integer k, return the number of pairs (i, j) where i < j such that |nums[i] - nums[j]| == k.\nThe value of |x| is defined as:\n\nx if x >= 0.\n-x if x < 0.",
        "examples": [
            "Input: nums = [1,2,2,1], k = 1\nOutput: 4\nExplanation: The pairs with an absolute difference of 1 are:\n- [1,2,2,1]\n- [1,2,2,1]\n- [1,2,2,1]\n- [1,2,2,1]",
            "Input: nums = [1,3], k = 3\nOutput: 0\nExplanation: There are no pairs with an absolute difference of 3.",
            "Input: nums = [3,2,1,5,4], k = 2\nOutput: 3\nExplanation: The pairs with an absolute difference of 2 are:\n- [3,2,1,5,4]\n- [3,2,1,5,4]\n- [3,2,1,5,4]"
        ],
        "constraints": "1 <= nums.length <= 200\n1 <= nums[i] <= 100\n1 <= k <= 99",
        "release_time": 1677159545,
        "oracle_code": "class Solution {\n    public int countKDifference(int[] nums, int k) {\n       int ans = 0;\n\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (Math.abs(nums[i] - nums[j]) == k) {\n                    ans++;\n                }\n            }\n        }\n        return ans;\n    }\n}",
        "content": "\\n# Complexity\\n- Time complexity:\\nO(N^2)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int countKDifference(int[] nums, int k) {\\n       int ans = 0;\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            for (int j = i + 1; j < nums.length; j++) {\\n                if (Math.abs(nums[i] - nums[j]) == k) {\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\nplease upvote, if u like this solution!",
        "level": "easy",
        "buggy_code": "\nclass Solution {\n    public int countKDifference(int[] nums, int k) {\n       int ans = 0;\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (countDiff(nums[i], nums[j]) == k) {\n                    ans++;\n                }\n            }\n        }\n        return ans;\n    }\n} \n",
        "explanations": "\nThe undefined method 'countDiff' causes a compile-time error due to its nonexistence.\n"
    },
    {
        "slug": "sort-characters-by-frequency",
        "description": "Given a string s, sort it in decreasing order based on the frequency of the characters. The frequency of a character is the number of times it appears in the string.\nReturn the sorted string. If there are multiple answers, return any of them.",
        "examples": [
            "Input: s = \"tree\"\nOutput: \"eert\"\nExplanation: 'e' appears twice while 'r' and 't' both appear once.\nSo 'e' must appear before both 'r' and 't'. Therefore \"eetr\" is also a valid answer.",
            "Input: s = \"cccaaa\"\nOutput: \"aaaccc\"\nExplanation: Both 'c' and 'a' appear three times, so both \"cccaaa\" and \"aaaccc\" are valid answers.\nNote that \"cacaca\" is incorrect, as the same characters must be together.",
            "Input: s = \"Aabb\"\nOutput: \"bbAa\"\nExplanation: \"bbaA\" is also a valid answer, but \"Aabb\" is incorrect.\nNote that 'A' and 'a' are treated as two different characters."
        ],
        "constraints": "1 <= s.length <= 5 * 105\ns consists of uppercase and lowercase English letters and digits.",
        "release_time": 1670065857,
        "oracle_code": "class Solution {\n    public String frequencySort(String s) {\n        char[] arr = new char[256];\n    for(int i=0; i<s.length(); i++){\n        arr[s.charAt(i)]++;    \n    }\n    \n    StringBuilder sb = new StringBuilder();\n    int max = -1;\n    while(max != 0){\n        max = -1;\n        char maxi = 0;\n        for(char i=0; i<arr.length; i++){\n            if(arr[i] > max){\n                max = arr[i];\n                maxi = i;\n            }\n        }\n        for(int i=0; i<max; i++){\n            sb.append(maxi);   \n        }\n        arr[maxi] = 0;\n    }\n    return sb.toString();\n        \n    }\n}",
        "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public String frequencySort(String s) {\\n        char[] arr = new char[256];\\n    for(int i=0; i<s.length(); i++){\\n        arr[s.charAt(i)]++;    \\n    }\\n    \\n    StringBuilder sb = new StringBuilder();\\n    int max = -1;\\n    while(max != 0){\\n        max = -1;\\n        char maxi = 0;\\n        for(char i=0; i<arr.length; i++){\\n            if(arr[i] > max){\\n                max = arr[i];\\n                maxi = i;\\n            }\\n        }\\n        for(int i=0; i<max; i++){\\n            sb.append(maxi);   \\n        }\\n        arr[maxi] = 0;\\n    }\\n    return sb.toString();\\n        \\n    }\\n}\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\n    public String frequencySort(String s) {\n        char[] arr = new char[256];\n    for(int i=0; i<s.length(); i++){\n        arr[s.charAt(i)]++;    \n    }\n    \n    StringBuilder sb = new StringBuilder();\n    int max = -1;\n        char maxi = 0;\n    for(char i=0; i<arr.length; i++){\n        if(arr[i] > max){\n            max = arr[i];\n            maxi = i;\n        }\n    }\n    for(int i=0; i<max; i++){\n        sb.append(maxi);   \n    }\n    arr[maxi] = 0;\n\n    return sb.toString();\n        \n    }\n}\n",
        "explanations": "\nThe while loop that was making sure all characters are processed is removed causing incorrect output.\n"
    },
    {
        "slug": "goat-latin",
        "description": "You are given a string sentence that consist of words separated by spaces. Each word consists of lowercase and uppercase letters only.\nWe would like to convert the sentence to \"Goat Latin\" (a made-up language similar to Pig Latin.) The rules of Goat Latin are as follows:\n\nIf a word begins with a vowel ('a', 'e', 'i', 'o', or 'u'), append \"ma\" to the end of the word.\n\n\t\nFor example, the word \"apple\" becomes \"applema\".\n\n\nIf a word begins with a consonant (i.e., not a vowel), remove the first letter and append it to the end, then add \"ma\".\n\t\nFor example, the word \"goat\" becomes \"oatgma\".\n\n\nAdd one letter 'a' to the end of each word per its word index in the sentence, starting with 1.\n\t\nFor example, the first word gets \"a\" added to the end, the second word gets \"aa\" added to the end, and so on.\n\n\n\nReturn the final sentence representing the conversion from sentence to Goat Latin.",
        "examples": [
            "Input: sentence = \"I speak Goat Latin\"\nOutput: \"Imaa peaksmaaa oatGmaaaa atinLmaaaaa\"",
            "Input: sentence = \"The quick brown fox jumped over the lazy dog\"\nOutput: \"heTmaa uickqmaaa rownbmaaaa oxfmaaaaa umpedjmaaaaaa overmaaaaaaa hetmaaaaaaaa azylmaaaaaaaaa ogdmaaaaaaaaaa\""
        ],
        "constraints": "1 <= sentence.length <= 150\nsentence consists of English letters and spaces.\nsentence has no leading or trailing spaces.\nAll the words in sentence are separated by a single space.",
        "release_time": 1683445696,
        "oracle_code": "class Solution {\n    public String toGoatLatin(String sentence) {\n        sentence.toLowerCase();\n        String[] words=sentence.split(\" \",0);\n        int i=1;\n        String ans=\"\";\n        for(String word:words){\n           \n            char p1=word.charAt(0);\n            char p=word.toLowerCase().charAt(0);\n            String k=\"\";\n            if(p=='a'||p=='i'||p=='o'||p=='e'||p=='u'){\n                k+=word+\"ma\";\n            }\n            else{\n                k+=word.substring(1,word.length());\n                k+=p1;\n                k+=\"ma\";\n            }\n            for(int m=0;m<i;m++){\n               k+='a';\n            }\n            ans+=k;\n            if(i!=words.length)ans+=\" \";\n            i++;\n        }\n        return ans;\n    }\n}",
        "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public String toGoatLatin(String sentence) {\\n        sentence.toLowerCase();\\n        String[] words=sentence.split(\" \",0);\\n        int i=1;\\n        String ans=\"\";\\n        for(String word:words){\\n           \\n            char p1=word.charAt(0);\\n            char p=word.toLowerCase().charAt(0);\\n            String k=\"\";\\n            if(p==\\'a\\'||p==\\'i\\'||p==\\'o\\'||p==\\'e\\'||p==\\'u\\'){\\n                k+=word+\"ma\";\\n            }\\n            else{\\n                k+=word.substring(1,word.length());\\n                k+=p1;\\n                k+=\"ma\";\\n            }\\n            for(int m=0;m<i;m++){\\n               k+=\\'a\\';\\n            }\\n            ans+=k;\\n            if(i!=words.length)ans+=\" \";\\n            i++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\n    public String toGoatLatin(String sentence) {\n        sentence.toLowerCase();\n        undefinedMethod();\n        String[] words=sentence.split(\" \",0);\n        int i=1;\n        String ans=\"\";\n        for(String word:words){\n\n            char p1=word.charAt(0);\n            char p=word.toLowerCase().charAt(0);\n            String k=\"\";\n            if(p=='a'||p=='i'||p=='o'||p=='e'||p=='u'){\n                k+=word+\"ma\";\n            }\n            else{\n                k+=word.substring(1,word.length());\n                k+=p1;\n                k+=\"ma\";\n            }\n            for(int m=0;m<i;m++){\n               k+='a';\n            }\n            ans+=k;\n            if(i!=words.length)ans+=\" \";\n            i++;\n        }\n        return ans;\n    }\n}\n",
        "explanations": "\nAdded an undefined method (undefinedMethod) which the compiler cannot find and execute.\n"
    },
    {
        "slug": "same-tree",
        "description": "Given the roots of two binary trees p and q, write a function to check if they are the same or not.\nTwo binary trees are considered the same if they are structurally identical, and the nodes have the same value.",
        "examples": [
            "Input: p = [1,2,3], q = [1,2,3]\nOutput: true",
            "Input: p = [1,2], q = [1,null,2]\nOutput: false",
            "Input: p = [1,2,1], q = [1,1,2]\nOutput: false"
        ],
        "constraints": "The number of nodes in both trees is in the range [0, 100].\n-104 <= Node.val <= 104",
        "release_time": 1691573493,
        "oracle_code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n   \n    public boolean isSameTree(TreeNode p, TreeNode q) {\n     if (p == null && q == null) {\n            return true;\n        }\n        \n        if (p == null || q == null) {\n            return false;\n        }\n        \n        if (p.val != q.val) {\n            return false;\n        }\n        \n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n\n        \n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n   \\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n     if (p == null && q == null) {\\n            return true;\\n        }\\n        \\n        if (p == null || q == null) {\\n            return false;\\n        }\\n        \\n        if (p.val != q.val) {\\n            return false;\\n        }\\n        \\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n\\n        \\n    }\\n}\\n```",
        "level": "easy",
        "buggy_code": "\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n   \n    public boolean isSameTree(TreeNode p, TreeNode q) {\n     if (p == null && q == null) {\n            return true;\n        }\n        \n        if (p == null || q == null) {\n            return false;\n        }\n        \n        if (p.val != q.val) {\n            return false;\n        }\n        \n        return checkSubTree(p.left, q.left) && checkSubTree(p.right, q.right);\n        \n    }\n}\n",
        "explanations": "\ncheckSubTree method used in isSameTree method is not defined causing an error.\n"
    },
    {
        "slug": "relative-ranks",
        "description": "You are given an integer array score of size n, where score[i] is the score of the ith athlete in a competition. All the scores are guaranteed to be unique.\nThe athletes are placed based on their scores, where the 1st place athlete has the highest score, the 2nd place athlete has the 2nd highest score, and so on. The placement of each athlete determines their rank:\n\nThe 1st place athlete's rank is \"Gold Medal\".\nThe 2nd place athlete's rank is \"Silver Medal\".\nThe 3rd place athlete's rank is \"Bronze Medal\".\nFor the 4th place to the nth place athlete, their rank is their placement number (i.e., the xth place athlete's rank is \"x\").\n\nReturn an array answer of size n where answer[i] is the rank of the ith athlete.",
        "examples": [
            "Input: score = [5,4,3,2,1]\nOutput: [\"Gold Medal\",\"Silver Medal\",\"Bronze Medal\",\"4\",\"5\"]\nExplanation: The placements are [1st, 2nd, 3rd, 4th, 5th].",
            "Input: score = [10,3,8,9,4]\nOutput: [\"Gold Medal\",\"5\",\"Bronze Medal\",\"Silver Medal\",\"4\"]\nExplanation: The placements are [1st, 5th, 3rd, 2nd, 4th]."
        ],
        "constraints": "n == score.length\n1 <= n <= 104\n0 <= score[i] <= 106\nAll the values in score are unique.",
        "release_time": 1683184626,
        "oracle_code": "class Solution {\n    public String[] findRelativeRanks(int[] score) {\n         int n=score.length;\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[b]-score[a]);\n        for(int i=0;i<n;i++) pq.add(i);\n      String[] ans = new String[n];\n                int i=1;\n        while(!pq.isEmpty()){\n            int idx=pq.poll();\n         if(i==1)   { ans[idx]=\"Gold Medal\"; i++;}\n         else if(i==2)   { ans[idx]=\"Silver Medal\"; i++;}\n         else if(i==3)   { ans[idx]=\"Bronze Medal\"; i++;}\n         else ans[idx]=Integer.toString(i++);\n        }\n        return ans;  \n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String[] findRelativeRanks(int[] score) {\\n         int n=score.length;\\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[b]-score[a]);\\n        for(int i=0;i<n;i++) pq.add(i);\\n      String[] ans = new String[n];\\n                int i=1;\\n        while(!pq.isEmpty()){\\n            int idx=pq.poll();\\n         if(i==1)   { ans[idx]=\"Gold Medal\"; i++;}\\n         else if(i==2)   { ans[idx]=\"Silver Medal\"; i++;}\\n         else if(i==3)   { ans[idx]=\"Bronze Medal\"; i++;}\\n         else ans[idx]=Integer.toString(i++);\\n        }\\n        return ans;  \\n    }\\n}\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\n    public String[] findRelativeRanks(int[] score) {\n         int n=score.length;\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[b]-score[a]);\n        for(int i=0;i<n;i++) pq.add(i);\n      String[] ans = new String[n];\n                int i=1;\n        while(!pq.isEmpty()){\n            int idx=pq.poll();\n         if(i==1)   { ans[idx]=\"Gold Medal\"; i++;}\n         else if(i==2)   { ans[idx]=\"Silver Medal\"; i++;}\n         else if(i==3)   { ans[idx]=\"Bronze Medal\"; i++;}\n         else ans[idx]=Integer.toString(i++);\n        }\n        return reorderArray(ans);  \n    }\n\n    private String[] reorderArray(String[] ranks){\n        \n    }\n}\n",
        "explanations": "\nThe bug is that the method \"reorderArray(String[] ranks)\" is undefined or not implemented.\n"
    },
    {
        "slug": "make-array-strictly-increasing",
        "description": "Given two integer arrays\u00a0arr1 and arr2, return the minimum number of operations (possibly zero) needed\u00a0to make arr1 strictly increasing.\nIn one operation, you can choose two indices\u00a00 <=\u00a0i < arr1.length\u00a0and\u00a00 <= j < arr2.length\u00a0and do the assignment\u00a0arr1[i] = arr2[j].\nIf there is no way to make\u00a0arr1\u00a0strictly increasing,\u00a0return\u00a0-1.",
        "examples": [
            "Input: arr1 = [1,5,3,6,7], arr2 = [1,3,2,4]\nOutput: 1\nExplanation: Replace 5 with 2, then arr1 = [1, 2, 3, 6, 7].",
            "Input: arr1 = [1,5,3,6,7], arr2 = [4,3,1]\nOutput: 2\nExplanation: Replace 5 with 3 and then replace 3 with 4. arr1 = [1, 3, 4, 6, 7].",
            "Input: arr1 = [1,5,3,6,7], arr2 = [1,6,3,3]\nOutput: -1\nExplanation: You can't make arr1 strictly increasing."
        ],
        "constraints": "1 <= arr1.length, arr2.length <= 2000\n0 <= arr1[i], arr2[i] <= 10^9",
        "release_time": 1686968225,
        "oracle_code": "class Solution { \n    public int makeArrayIncreasing(int[] arr1, int[] arr2) {\n        Arrays.sort(arr2);\n        \n        int answer = helper(0, -1, arr1, arr2);\n        \n        return answer < Integer.MAX_VALUE-100 ? answer : -1;\n    }\n    \n    Map<Pair<Integer, Integer>, Integer> dp = new HashMap<>();\n    private int helper(int i, int prev, int[] arr1, int[] arr2) {\n        if (i == arr1.length) {\n            return 0;\n        }\n        if (dp.containsKey(new Pair<>(i, prev))) {\n            return dp.get(new Pair<>(i, prev));\n        }\n\n        int operation = Integer.MAX_VALUE-100;\n\n        \n        if (arr1[i] > prev) {\n            operation = helper(i + 1, arr1[i], arr1, arr2);\n        }\n\n       \n        int idx = binarySearch(arr2, prev);\n\n        \n        if (idx < arr2.length) {\n            operation = Math.min(operation, 1 + helper(i + 1, arr2[idx], arr1, arr2));\n        }\n\n        dp.put(new Pair<>(i, prev),operation);\n        return operation;\n    }\n    \n    private static int binarySearch(int[] arr, int value) {\n        int left = 0, right = arr.length-1;\n        while (left <= right) {\n            int mid = left+(right-left) / 2;\n            if (arr[mid] <= value) {\n                left = mid + 1;\n            } else {\n                right = mid-1;\n            }\n        }\n        return left;\n    } \n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\n\\nclass Solution { \\n    public int makeArrayIncreasing(int[] arr1, int[] arr2) {\\n        Arrays.sort(arr2);\\n        \\n        int answer = helper(0, -1, arr1, arr2);\\n        \\n        return answer < Integer.MAX_VALUE-100 ? answer : -1;\\n    }\\n    \\n    Map<Pair<Integer, Integer>, Integer> dp = new HashMap<>();\\n    private int helper(int i, int prev, int[] arr1, int[] arr2) {\\n        if (i == arr1.length) {\\n            return 0;\\n        }\\n        if (dp.containsKey(new Pair<>(i, prev))) {\\n            return dp.get(new Pair<>(i, prev));\\n        }\\n\\n        int operation = Integer.MAX_VALUE-100;\\n\\n        \\n        if (arr1[i] > prev) {\\n            operation = helper(i + 1, arr1[i], arr1, arr2);\\n        }\\n\\n       \\n        int idx = binarySearch(arr2, prev);\\n\\n        \\n        if (idx < arr2.length) {\\n            operation = Math.min(operation, 1 + helper(i + 1, arr2[idx], arr1, arr2));\\n        }\\n\\n        dp.put(new Pair<>(i, prev),operation);\\n        return operation;\\n    }\\n    \\n    private static int binarySearch(int[] arr, int value) {\\n        int left = 0, right = arr.length-1;\\n        while (left <= right) {\\n            int mid = left+(right-left) / 2;\\n            if (arr[mid] <= value) {\\n                left = mid + 1;\\n            } else {\\n                right = mid-1;\\n            }\\n        }\\n        return left;\\n    } \\n}\\n```",
        "level": "hard",
        "buggy_code": "\nclass Solution { \n    public int makeArrayIncreasing(int[] arr1, int[] arr2) {\n        Arrays.sort(arr2);\n        \n        int answer = helper(0, -1, arr1, arr2);\n        \n        return answer < Integer.MAX_VALUE-100 ? answer : -1;\n    }\n    \n    Map<Pair<Integer, Integer>, Integer> dp = new HashMap<>();\n    private int helper(int i, int prev, int[] arr1, int[] arr2) {\n        if (i == arr1.length) {\n            return 0;\n        }\n        if (dp.containsKey(new Pair<>(i, prev))) {\n            return dp.get(new Pair<>(i, prev));\n        }\n\n        int operation = Integer.MAX_VALUE-100;\n\n        \n        if (arr1[i] > prev) {\n            operation = helper(i + 1, arr1[i], arr1, arr2);\n        }\n\n       \n        int idx = binarySearch(arr2, prev);\n\n        \n        if (idx < arr2.length) {\n            operation = Math.min(operation, 1 + helper(i + 1, arr2[idx], arr1, arr2));\n        }\n\n        dp.put(new Pair<>(i, prev),operation);\n        return operation;\n    }\n    \n    private static int binarySearch(int[] arr, int value) {\n        int left = 0, right = arr.length-1;\n        while (left <= right) {\n            int mid = left+(right-left) / 2;\n            if (arr[mid] <= value) {\n                left = mid + 1;\n            } else {\n                right = mid-1;\n            }\n        }\n        return left;\n    }\n    \n    private static int anotherMethod() {\n        int someValue = 0;\n        \n        return someValue;\n    } \n}\n",
        "explanations": "\nThe method 'anotherMethod' is defined but never called, leading to an unused method bug.\n"
    },
    {
        "slug": "subarray-product-less-than-k",
        "description": "Given an array of integers nums and an integer k, return the number of contiguous subarrays where the product of all the elements in the subarray is strictly less than k.",
        "examples": [
            "Input: nums = [10,5,2,6], k = 100\nOutput: 8\nExplanation: The 8 subarrays that have product less than 100 are:\n[10], [5], [2], [6], [10, 5], [5, 2], [2, 6], [5, 2, 6]\nNote that [10, 5, 2] is not included as the product of 100 is not strictly less than k.",
            "Input: nums = [1,2,3], k = 0\nOutput: 0"
        ],
        "constraints": "1 <= nums.length <= 3 * 104\n1 <= nums[i] <= 1000\n0 <= k <= 106",
        "release_time": 1689616329,
        "oracle_code": "class Solution {\n    public int numSubarrayProductLessThanK(int[] nums, int k) {\n        int i = 0,n = nums.length,product = 1,result = 0;\n        for(int j = 0;j<n;j++)\n        {\n            product = product*nums[j];\n            while(i<=j && product>=k)\n            {\n                product = product/nums[i];\n                i++;\n            }\n            result += j-i+1;\n        }\n        return result;\n    }\n}",
        "content": "# Java Code\\n```\\nclass Solution {\\n    public int numSubarrayProductLessThanK(int[] nums, int k) {\\n        int i = 0,n = nums.length,product = 1,result = 0;\\n        for(int j = 0;j<n;j++)\\n        {\\n            product = product*nums[j];\\n            while(i<=j && product>=k)\\n            {\\n                product = product/nums[i];\\n                i++;\\n            }\\n            result += j-i+1;\\n        }\\n        return result;\\n    }\\n}\\n```\\n\\n> ### *Please don\\'t forget to upvote if you\\'ve liked my solution.* \\u2B06\\uFE0F",
        "level": "medium",
        "buggy_code": "\nclass Solution {\n    public int numSubarrayProductLessThanK(int[] nums, int k) {\n        int i = 0,n = nums.length,product = 1,result = 0;\n        for(int j = 0;j<n;j++)\n        {\n            product = productMultiply(nums[j]);\n            while(i<=j && product>=k)\n            {\n                product = productDivide(nums[i]);\n                i++;\n            }\n            result += j-i+1;\n        }\n        return result;\n    }\n\n    public int productMultiply(int num){\n        return product * num;\n    }\n\n    public int productDivide(int num){\n        return product / num;\n    }\n}\n",
        "explanations": "\nThe methods 'productMultiply' and 'productDivide' are undefined because 'product' is a local variable of another method.\n"
    },
    {
        "slug": "design-graph-with-shortest-path-calculator",
        "description": "There is a directed weighted graph that consists of n nodes numbered from 0 to n - 1. The edges of the graph are initially represented by the given array edges where edges[i] = [fromi, toi, edgeCosti] meaning that there is an edge from fromi to toi with the cost edgeCosti.\nImplement the Graph class:\n\nGraph(int n, int[][] edges) initializes the object with n nodes and the given edges.\naddEdge(int[] edge) adds an edge to the list of edges where edge = [from, to, edgeCost]. It is guaranteed that there is no edge between the two nodes before adding this one.\nint shortestPath(int node1, int node2) returns the minimum cost of a path from node1 to node2. If no path exists, return -1. The cost of a path is the sum of the costs of the edges in the path.",
        "examples": [
            "Input\n[\"Graph\", \"shortestPath\", \"shortestPath\", \"addEdge\", \"shortestPath\"]\n[[4, [[0, 2, 5], [0, 1, 2], [1, 2, 1], [3, 0, 3]]], [3, 2], [0, 3], [[1, 3, 4]], [0, 3]]\nOutput\n[null, 6, -1, null, 6]\n\nExplanation\nGraph g = new Graph(4, [[0, 2, 5], [0, 1, 2], [1, 2, 1], [3, 0, 3]]);\ng.shortestPath(3, 2); // return 6. The shortest path from 3 to 2 in the first diagram above is 3 -> 0 -> 1 -> 2 with a total cost of 3 + 2 + 1 = 6.\ng.shortestPath(0, 3); // return -1. There is no path from 0 to 3.\ng.addEdge([1, 3, 4]); // We add an edge from node 1 to node 3, and we get the second diagram above.\ng.shortestPath(0, 3); // return 6. The shortest path from 0 to 3 now is 0 -> 1 -> 3 with a total cost of 2 + 4 = 6."
        ],
        "constraints": "1 <= n <= 100\n0 <= edges.length <= n * (n - 1)\nedges[i].length == edge.length == 3\n0 <= fromi, toi, from, to, node1, node2 <= n - 1\n1 <= edgeCosti, edgeCost <= 106\nThere are no repeated edges and no self-loops in the graph at any point.\nAt most 100 calls will be made for addEdge.\nAt most 100 calls will be made for shortestPath.",
        "release_time": 1681574555,
        "oracle_code": "class Graph {\n    List<List<int[]>> adj=new ArrayList<>();\n    int n;\n    public Graph(int n, int[][] edges) {\n        for(int i=0;i<n;i++){\n            adj.add(new ArrayList<>());\n        }\n        this.n=n;\n        for(int edge[]: edges){\n            adj.get(edge[0]).add(new int[]{edge[1],edge[2]});\n        }\n    }\n    \n    public void addEdge(int[] edge) {\n        adj.get(edge[0]).add(new int[]{edge[1],edge[2]});\n    }\n    \n    public int shortestPath(int node1, int node2) {\n        int dist[]=new int[n+1];\n        Arrays.fill(dist,Integer.MAX_VALUE);\n        dist[node1]=0;\n        PriorityQueue<int[]> pq=new PriorityQueue<>((a,b)->a[1]-b[1]);\n        pq.add(new int[]{node1,0});\n        while(!pq.isEmpty()){\n            int u=pq.poll()[0];\n            for(int p[]: adj.get(u)){\n                int v=p[0];\n                int w=p[1];\n                if(dist[v]>dist[u]+w){\n                    dist[v]=dist[u]+w;\n                    pq.add(new int[]{v,dist[v]});\n                }\n            }\n        }\n        if(dist[node2]==Integer.MAX_VALUE){\n                return -1;\n        }\n        return dist[node2];\n    }\n    \n}\n\n/**\n * Your Graph object will be instantiated and called as such:\n * Graph obj = new Graph(n, edges);\n * obj.addEdge(edge);\n * int param_2 = obj.shortestPath(node1,node2);\n */",
        "content": "\\n\\n# Code\\n```\\nclass Graph {\\n    List<List<int[]>> adj=new ArrayList<>();\\n    int n;\\n    public Graph(int n, int[][] edges) {\\n        for(int i=0;i<n;i++){\\n            adj.add(new ArrayList<>());\\n        }\\n        this.n=n;\\n        for(int edge[]: edges){\\n            adj.get(edge[0]).add(new int[]{edge[1],edge[2]});\\n        }\\n    }\\n    \\n    public void addEdge(int[] edge) {\\n        adj.get(edge[0]).add(new int[]{edge[1],edge[2]});\\n    }\\n    \\n    public int shortestPath(int node1, int node2) {\\n        int dist[]=new int[n+1];\\n        Arrays.fill(dist,Integer.MAX_VALUE);\\n        dist[node1]=0;\\n        PriorityQueue<int[]> pq=new PriorityQueue<>((a,b)->a[1]-b[1]);\\n        pq.add(new int[]{node1,0});\\n        while(!pq.isEmpty()){\\n            int u=pq.poll()[0];\\n            for(int p[]: adj.get(u)){\\n                int v=p[0];\\n                int w=p[1];\\n                if(dist[v]>dist[u]+w){\\n                    dist[v]=dist[u]+w;\\n                    pq.add(new int[]{v,dist[v]});\\n                }\\n            }\\n        }\\n        if(dist[node2]==Integer.MAX_VALUE){\\n                return -1;\\n        }\\n        return dist[node2];\\n    }\\n    \\n}\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph obj = new Graph(n, edges);\\n * obj.addEdge(edge);\\n * int param_2 = obj.shortestPath(node1,node2);\\n */",
        "level": "hard",
        "buggy_code": "\nclass Graph {\n    List<List<int[]>> adj=new ArrayList<>();\n    int n;\n    public Graph(int n, int[][] edges) {\n        for(int i=0;i<n;i++){\n            adj.add(new ArrayList<>());\n        }\n        this.n=n;\n        for(int edge[]: edges){\n            adj.get(edge[0]).add(new int[]{edge[1],edge[2]});\n        }\n    }\n    \n    public void removeEdge(int[] edge) {\n        adj.get(edge[0]).remove(new int[]{edge[1],edge[2]});\n    }\n    \n    public int shortestPath(int node1, int node2) {\n        int dist[]=new int[n+1];\n        Arrays.fill(dist,Integer.MAX_VALUE);\n        dist[node1]=0;\n        PriorityQueue<int[]> pq=new PriorityQueue<>((a,b)->a[1]-b[1]);\n        pq.add(new int[]{node1,0});\n        while(!pq.isEmpty()){\n            int u=pq.poll()[0];\n            for(int p[]: adj.get(u)){\n                int v=p[0];\n                int w=p[1];\n                if(dist[v]>dist[u]+w){\n                    dist[v]=dist[u]+w;\n                    pq.add(new int[]{v,dist[v]});\n                }\n            }\n        }\n        if(dist[node2]==Integer.MAX_VALUE){\n                return -1;\n        }\n        return dist[node2];\n    }\n    \n}\n\n/**\n * Your Graph object will be instantiated and called as such:\n * Graph obj = new Graph(n, edges);\n * obj.removeEdge(edge);\n * int param_2 = obj.shortestPath(node1,node2);\n */\n",
        "explanations": "\nThe object array 'edge' cannot be removed directly from the list as it's a new object.\n"
    },
    {
        "slug": "h-index-ii",
        "description": "Given an array of integers citations where citations[i] is the number of citations a researcher received for their ith paper and citations is sorted in ascending order, return the researcher's h-index.\nAccording to the definition of h-index on Wikipedia: The h-index is defined as the maximum value of h such that the given researcher has published at least h papers that have each been cited at least h times.\nYou must write an algorithm that runs in logarithmic time.",
        "examples": [
            "Input: citations = [0,1,3,5,6]\nOutput: 3\nExplanation: [0,1,3,5,6] means the researcher has 5 papers in total and each of them had received 0, 1, 3, 5, 6 citations respectively.\nSince the researcher has 3 papers with at least 3 citations each and the remaining two with no more than 3 citations each, their h-index is 3.",
            "Input: citations = [1,2,100]\nOutput: 2"
        ],
        "constraints": "n == citations.length\n1 <= n <= 105\n0 <= citations[i] <= 1000\ncitations is sorted in ascending order.",
        "release_time": 1689538082,
        "oracle_code": "class Solution {\n    public int hIndex(int[] citations) {\n        // O(n) Time Complexity\n        // int n = citations.length;\n        // int index = 0;\n        // while(index < n && n - index > citations[index]){\n        //     index++;\n        // }\n        // return n - index;\n\n        // O(logn) Time Complexity // Binary Search:- Since Sorted Array\n        int left = 0, right = citations.length - 1;\n        int n = citations.length;\n        while(left <= right){\n            int mid = left + (right - left) / 2;\n            if(citations[mid] == n - mid) return n - mid;\n            else if(citations[mid] < n - mid) left = mid + 1;\n            else right = mid - 1;\n        }\n        return n - left;\n    }\n}",
        "content": "# Complexity\\n- Time complexity: $$O(logn)$$ \\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int hIndex(int[] citations) {\\n        // O(n) Time Complexity\\n        // int n = citations.length;\\n        // int index = 0;\\n        // while(index < n && n - index > citations[index]){\\n        //     index++;\\n        // }\\n        // return n - index;\\n\\n        // O(logn) Time Complexity // Binary Search:- Since Sorted Array\\n        int left = 0, right = citations.length - 1;\\n        int n = citations.length;\\n        while(left <= right){\\n            int mid = left + (right - left) / 2;\\n            if(citations[mid] == n - mid) return n - mid;\\n            else if(citations[mid] < n - mid) left = mid + 1;\\n            else right = mid - 1;\\n        }\\n        return n - left;\\n    }\\n}\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\n    public int hIndex(int[] citations) {\n        // O(n) Time Complexity\n        // int n = citations.length;\n        // int index = 0;\n        // while(index < n && n - index > citations[index]){\n        //     index++;\n        // }\n        // return n - index;\n\n        // O(logn) Time Complexity // Binary Search:- Since Sorted Array\n        int left = 0, right = citations.length - 1;\n        int n = citations.length;\n        while(left <= right){\n            int mid = left + (right - left) / 2;\n            if(citations[mid] == n - mid) return n - mid;\n            else if(citations[mid] < n - mid) left = mid + 1;\n            else right = mid - 1;\n        }\n        return calculateHIndex();\n    }\n\n    public int calculateHIndex(){\n        return 0;\n    }\n}\n",
        "explanations": "\nThe 'calculateHIndex' method is undefined and is called, but it does not do anything.\n"
    },
    {
        "slug": "intersection-of-multiple-arrays",
        "description": "Given a 2D integer array nums where nums[i] is a non-empty array of distinct positive integers, return the list of integers that are present in each array of nums sorted in ascending order.",
        "examples": [
            "Input: nums = [[3,1,2,4,5],[1,2,3,4],[3,4,5,6]]\nOutput: [3,4]\nExplanation: \nThe only integers present in each of nums[0] = [3,1,2,4,5], nums[1] = [1,2,3,4], and nums[2] = [3,4,5,6] are 3 and 4, so we return [3,4].",
            "Input: nums = [[1,2,3],[4,5,6]]\nOutput: []\nExplanation: \nThere does not exist any integer present both in nums[0] and nums[1], so we return an empty list []."
        ],
        "constraints": "1 <= nums.length <= 1000\n1 <= sum(nums[i].length) <= 1000\n1 <= nums[i][j] <= 1000\nAll the values of nums[i] are unique.",
        "release_time": 1650773246,
        "oracle_code": "class Solution {\n    public List<Integer> intersection(int[][] nums) {\n        \n        List<Integer> ans = new ArrayList<>();\n        \n        int[] count  = new int[1001];\n        \n        for(int[] arr : nums){\n            for(int i : arr){\n                count[i]++;\n            }\n        }\n        \n       for(int i=0;i<count.length;i++){\n           if(count[i]==nums.length){\n               ans.add(i);\n           }\n       }\n        \n        return ans;\n    }\n}",
        "content": "```\\n\\nclass Solution {\\n    public List<Integer> intersection(int[][] nums) {\\n        \\n        List<Integer> ans = new ArrayList<>();\\n        \\n        int[] count  = new int[1001];\\n        \\n        for(int[] arr : nums){\\n            for(int i : arr){\\n                count[i]++;\\n            }\\n        }\\n        \\n       for(int i=0;i<count.length;i++){\\n           if(count[i]==nums.length){\\n               ans.add(i);\\n           }\\n       }\\n        \\n        return ans;\\n    }\\n}\\n\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\n    public List<Integer> intersection(int[][] nums) {\n        \n        List<Integer> ans = new ArrayList<>();\n        \n        int[] count  = new int[1001];\n        \n        for(int[] arr : nums){\n            for(int i : arr){\n                count[i]++;\n            }\n        }\n        \n       for(int i=0;i<count.length;i++){\n           if(count[i]==nums.length){\n               ans.add(i);\n           }\n       }\n        \n        myRandomUndefinedFunction();\n        \n        return ans;\n    }\n}\n",
        "explanations": "\nCode contains an undefined function \"myRandomUndefinedFunction\", which results in a compilation error.\n"
    },
    {
        "slug": "to-lower-case",
        "description": "Given a string s, return the string after replacing every uppercase letter with the same lowercase letter.",
        "examples": [
            "Input: s = \"Hello\"\nOutput: \"hello\"",
            "Input: s = \"here\"\nOutput: \"here\"",
            "Input: s = \"LOVELY\"\nOutput: \"lovely\""
        ],
        "constraints": "1 <= s.length <= 100\ns consists of printable ASCII characters.",
        "release_time": 1689583806,
        "oracle_code": "class Solution {\n    public String toLowerCase(String s) {\n        return s.toLowerCase();\n        \n    }\n}",
        "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public String toLowerCase(String s) {\\n        return s.toLowerCase();\\n        \\n    }\\n}\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\n    public String toLowerCase(String s) {\n        return s.transformToLower();\n    }\n}\n",
        "explanations": "\nThe String class doesn't have a method called transformToLower, it will cause a compile-time error.\n"
    },
    {
        "slug": "add-strings",
        "description": "Given two non-negative integers, num1 and num2 represented as string, return the sum of num1 and num2 as a string.\nYou must solve the problem without using any built-in library for handling large integers (such as BigInteger). You must also not convert the inputs to integers directly.",
        "examples": [
            "Input: num1 = \"11\", num2 = \"123\"\nOutput: \"134\"",
            "Input: num1 = \"456\", num2 = \"77\"\nOutput: \"533\"",
            "Input: num1 = \"0\", num2 = \"0\"\nOutput: \"0\""
        ],
        "constraints": "1 <= num1.length, num2.length <= 104\nnum1 and num2 consist of only digits.\nnum1 and num2 don't have any leading zeros except for the zero itself.",
        "release_time": 1692165728,
        "oracle_code": "class Solution:\n    def addStrings(self, num1: str, num2: str) -> str:\n        sys.set_int_max_str_digits(10000)\n        nattu = int(num1)\n        babu = int(num2)\n        result = str(nattu+babu)\n        return result",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def addStrings(self, num1: str, num2: str) -> str:\\n        sys.set_int_max_str_digits(10000)\\n        nattu = int(num1)\\n        babu = int(num2)\\n        result = str(nattu+babu)\\n        return result\\n\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution:\n    def addStrings(self, num1: str, num2: str) -> str:\n        sys.set_int_max_str_digits(10000)\n        nattu = int(num1)\n        babu = int(num2)\n        result = str(nattu+babu)\n        return print_result(result)\n",
        "explanations": "\nThe method print_result() is not defined in the class which raises a NameError.\n"
    },
    {
        "slug": "number-of-provinces",
        "description": "There are n cities. Some of them are connected, while some are not. If city a is connected directly with city b, and city b is connected directly with city c, then city a is connected indirectly with city c.\nA province is a group of directly or indirectly connected cities and no other cities outside of the group.\nYou are given an n x n matrix isConnected where isConnected[i][j] = 1 if the ith city and the jth city are directly connected, and isConnected[i][j] = 0 otherwise.\nReturn the total number of provinces.",
        "examples": [
            "Input: isConnected = [[1,1,0],[1,1,0],[0,0,1]]\nOutput: 2",
            "Input: isConnected = [[1,0,0],[0,1,0],[0,0,1]]\nOutput: 3"
        ],
        "constraints": "1 <= n <= 200\nn == isConnected.length\nn == isConnected[i].length\nisConnected[i][j] is 1 or 0.\nisConnected[i][i] == 1\nisConnected[i][j] == isConnected[j][i]",
        "release_time": 1685857349,
        "oracle_code": "class DSU:\n    def __init__(self, n):\n        self.par = list(range(n))\n        self.rank = [1] * n\n        self.size = 1\n    def find(self, u):\n        if u != self.par[u]:\n            self.par[u] = self.find(self.par[u])\n        return self.par[u]\n    def union(self, u, v):\n        uu, vv = self.find(u), self.find(v)\n        if uu == vv:\n            return False\n        if self.rank[uu] > self.rank[vv]:\n            self.par[vv] = uu\n        elif self.rank[vv] > self.rank[uu]:\n            self.par[uu] = vv\n        else:\n            self.par[uu] = vv\n            self.rank[vv] += 1\n        self.size += 1\n        return True\n\nclass Solution:\n    def isConnected(self, u, v, G):\n        return G[u][v] == 1\n\n    def findCircleNum(self, G: List[List[int]]) -> int:\n        n = len(G)\n        uf = DSU(n)\n        if not G:\n            return 0\n        for u in range(n):\n            for v in range(u, n):\n                if self.isConnected(u, v, G):\n                    uf.union(u, v)\n        return len(set([uf.find(i) for i in range(n)]))",
        "content": "\\n# Code\\n```\\nclass DSU:\\n    def __init__(self, n):\\n        self.par = list(range(n))\\n        self.rank = [1] * n\\n        self.size = 1\\n    def find(self, u):\\n        if u != self.par[u]:\\n            self.par[u] = self.find(self.par[u])\\n        return self.par[u]\\n    def union(self, u, v):\\n        uu, vv = self.find(u), self.find(v)\\n        if uu == vv:\\n            return False\\n        if self.rank[uu] > self.rank[vv]:\\n            self.par[vv] = uu\\n        elif self.rank[vv] > self.rank[uu]:\\n            self.par[uu] = vv\\n        else:\\n            self.par[uu] = vv\\n            self.rank[vv] += 1\\n        self.size += 1\\n        return True\\n\\nclass Solution:\\n    def isConnected(self, u, v, G):\\n        return G[u][v] == 1\\n\\n    def findCircleNum(self, G: List[List[int]]) -> int:\\n        n = len(G)\\n        uf = DSU(n)\\n        if not G:\\n            return 0\\n        for u in range(n):\\n            for v in range(u, n):\\n                if self.isConnected(u, v, G):\\n                    uf.union(u, v)\\n        return len(set([uf.find(i) for i in range(n)]))\\n\\n```",
        "level": "medium",
        "buggy_code": "\nclass DSU:\n    def __init__(self, n):\n        self.par = list(range(n))\n        self.rank = [1] * n\n        self.size = 1\n    def find(self, u):\n        if u != self.par[u]:\n            self.par[u] = self.find(self.par[u])\n        return self.par[u]\n    def union(self, u, v):\n        uu, vv = self.find(u), self.find(v)\n        if uu == vv:\n            return False\n        if self.rank[uu] > self.rank[vv]:\n            self.par[vv] = uu\n        elif self.rank[vv] > self.rank[uu]:\n            self.par[uu] = vv\n        else:\n            self.par[uu] = vv\n            self.rank[vv] += 1\n        self.size += 1\n        return True\n    def issizemorethanone(self):\n        return self.size > 1\n    \nclass Solution:\n    def isConnected(self, u, v, G):\n        return G[u][v] == 1\n\n    def findCircleNum(self, G: List[List[int]]) -> int:\n        n = len(G)\n        uf = DSU(n)\n        if not G:\n            return 0\n        for u in range(n):\n            for v in range(u, n):\n                if self.isConnected(u, v, G):\n                    uf.union(u, v)\n        return len(set([uf.find(i) for i in range(n)]))\n",
        "explanations": "\nThe method 'issizemorethanone' is added to DSU class but never used/called from anywhere. \n"
    },
    {
        "slug": "largest-number-after-digit-swaps-by-parity",
        "description": "You are given a positive integer num. You may swap any two digits of num that have the same parity (i.e. both odd digits or both even digits).\nReturn the largest possible value of num after any number of swaps.",
        "examples": [
            "Input: num = 1234\nOutput: 3412\nExplanation: Swap the digit 3 with the digit 1, this results in the number 3214.\nSwap the digit 2 with the digit 4, this results in the number 3412.\nNote that there may be other sequences of swaps but it can be shown that 3412 is the largest possible number.\nAlso note that we may not swap the digit 4 with the digit 1 since they are of different parities.",
            "Input: num = 65875\nOutput: 87655\nExplanation: Swap the digit 8 with the digit 6, this results in the number 85675.\nSwap the first digit 5 with the digit 7, this results in the number 87655.\nNote that there may be other sequences of swaps but it can be shown that 87655 is the largest possible number."
        ],
        "constraints": "1 <= num <= 109",
        "release_time": 1669374075,
        "oracle_code": "class Solution {\n    public int largestInteger(int num) {\n        String numString = \"\"+ num;\n        List<Integer> even = new ArrayList<>();\n        List<Integer> odd = new ArrayList<>();\n        for(Character c : numString.toCharArray()){\n            int n = Character.getNumericValue(c);\n            if(n%2==0){\n                even.add(n);\n            }else{\n                odd.add(n);\n            }\n        }\n        Collections.sort(even, Collections.reverseOrder());\n        Collections.sort(odd, Collections.reverseOrder());\n        String res =\"\";\n        int one=0, two=0;\n        for(int i=0; i<numString.length(); i++){\n            int n = Character.getNumericValue(numString.charAt(i));\n            if(n%2==0){\n                res += even.get(one);\n                one++;\n            }else{\n                res += odd.get(two);\n                two++;\n            }\n        }\n        return Integer.parseInt(res);\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nused string and list to store the even and odd elements\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nconverted num in string then added all values from string to even and odd list as per its type;\\nthen sorted both string in desc order\\nas we check from the original string if got even number we will put max even number from even list and incresed even list pointer same for the odd number\\n\\nConverted result string to integer to get int res and returned it\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int largestInteger(int num) {\\n        String numString = \"\"+ num;\\n        List<Integer> even = new ArrayList<>();\\n        List<Integer> odd = new ArrayList<>();\\n        for(Character c : numString.toCharArray()){\\n            int n = Character.getNumericValue(c);\\n            if(n%2==0){\\n                even.add(n);\\n            }else{\\n                odd.add(n);\\n            }\\n        }\\n        Collections.sort(even, Collections.reverseOrder());\\n        Collections.sort(odd, Collections.reverseOrder());\\n        String res =\"\";\\n        int one=0, two=0;\\n        for(int i=0; i<numString.length(); i++){\\n            int n = Character.getNumericValue(numString.charAt(i));\\n            if(n%2==0){\\n                res += even.get(one);\\n                one++;\\n            }else{\\n                res += odd.get(two);\\n                two++;\\n            }\\n        }\\n        return Integer.parseInt(res);\\n    }\\n}\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\n    public int largestInteger(int num) {\n        String numString = \"\"+ num;\n        List<Integer> even = new ArrayList<>();\n        List<Integer> odd = new ArrayList<>();\n        for(Character c : numString.toCharArray()){\n            int n = Character.getNumericValue(c);\n            if(n%2==0){\n                even.add(n);\n            }else{\n                odd.add(n);\n            }\n        }\n        Collections.sort(even, Collections.reverseOrder());\n        Collections.sort(odd, Collections.reverseOrder());\n        String res =\"\";\n        int one=0, two=0;\n        for(int i=0; i<numString.length(); i++){\n            int n = Character.getNumericValue(numString.charAt(i));\n            if(n%2==0){\n                res += even.get(one);\n                one++;\n            }else{\n                res += odd.get(two);\n                two++;\n            }\n        }\n        return Integer.parseStringMethodThatDoesntExist(res);\n    }\n}\n",
        "explanations": "\nThe method \"Integer.parseStringMethodThatDoesntExist(res)\" does not exist; correct is \"Integer.parseInt(res)\". \n"
    },
    {
        "slug": "increasing-decreasing-string",
        "description": "You are given a string s. Reorder the string using the following algorithm:\n\nPick the smallest character from s and append it to the result.\nPick the smallest character from s which is greater than the last appended character to the result and append it.\nRepeat step 2 until you cannot pick more characters.\nPick the largest character from s and append it to the result.\nPick the largest character from s which is smaller than the last appended character to the result and append it.\nRepeat step 5 until you cannot pick more characters.\nRepeat the steps from 1 to 6 until you pick all characters from s.\n\nIn each step, If the smallest or the largest character appears more than once you can choose any occurrence and append it to the result.\nReturn the result string after sorting s with this algorithm.",
        "examples": [
            "Input: s = \"aaaabbbbcccc\"\nOutput: \"abccbaabccba\"\nExplanation: After steps 1, 2 and 3 of the first iteration, result = \"abc\"\nAfter steps 4, 5 and 6 of the first iteration, result = \"abccba\"\nFirst iteration is done. Now s = \"aabbcc\" and we go back to step 1\nAfter steps 1, 2 and 3 of the second iteration, result = \"abccbaabc\"\nAfter steps 4, 5 and 6 of the second iteration, result = \"abccbaabccba\"",
            "Input: s = \"rat\"\nOutput: \"art\"\nExplanation: The word \"rat\" becomes \"art\" after re-ordering it with the mentioned algorithm."
        ],
        "constraints": "1 <= s.length <= 500\ns consists of only lowercase English letters.",
        "release_time": 1676313293,
        "oracle_code": "class Solution {\n    public String sortString(String s) {\n        int[] arr = new int[27];\n        String str = \"abcdefghijklmnopqrstuvwxyz\";\n//Find the number of occurrences of each letter in the text S and \n//place it in an array\n        for(int i=0;i<s.length();i++){\n            int num = str.indexOf((s.charAt(i)));\n            arr[++num]=arr[num]+1;\n        }\n\n        int len = s.length();\n        int count=0;\n        StringBuilder ans = new StringBuilder();\n        \n        while(count<len){\n            for(int i=1;i<27;i++){\n                if(arr[i]>0){\n                    ans.append(str.charAt(i - 1));\n                    arr[i]=arr[i]-1;\n                    count++;\n                }\n            }\n            for(int j=26;j>=1;j--){\n                if(arr[j]>0){\n                    ans.append(str.charAt(j - 1));\n                    arr[j]=arr[j]-1;\n                    count++;\n                }\n            }\n        }\n        return new String(ans);\n    }\n}",
        "content": "# Intuition\\n[Java] Finding solutions in an easy, understandable and fast way\\n\\n# Approach\\nThe goal is to find a solution to the example using only while and for operators\\n\\n# Complexity\\n- Time complexity:\\nRuntime: 5 ms       Beats :47.73%\\nMemory:  42.1 MB    Beats :91.92%\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String sortString(String s) {\\n        int[] arr = new int[27];\\n        String str = \"abcdefghijklmnopqrstuvwxyz\";\\n//Find the number of occurrences of each letter in the text S and \\n//place it in an array\\n        for(int i=0;i<s.length();i++){\\n            int num = str.indexOf((s.charAt(i)));\\n            arr[++num]=arr[num]+1;\\n        }\\n\\n        int len = s.length();\\n        int count=0;\\n        StringBuilder ans = new StringBuilder();\\n        \\n        while(count<len){\\n            for(int i=1;i<27;i++){\\n                if(arr[i]>0){\\n                    ans.append(str.charAt(i - 1));\\n                    arr[i]=arr[i]-1;\\n                    count++;\\n                }\\n            }\\n            for(int j=26;j>=1;j--){\\n                if(arr[j]>0){\\n                    ans.append(str.charAt(j - 1));\\n                    arr[j]=arr[j]-1;\\n                    count++;\\n                }\\n            }\\n        }\\n        return new String(ans);\\n    }\\n}\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\n    public String sortString(String s) {\n        int[] arr = new int[27];\n        String str = \"abcdefghijklmnopqrstuvwxyz\";\n        for(int i=0;i<s.length();i++){\n            int num = str.indexOf((s.charAt(i)));\n            arr[++num]=arr[num]+1;\n        }\n\n        int len = s.length();\n        int count=0;\n        StringBuilder ans = new StringBuilder();\n\n        while(count<len){\n            for(int i=1;i<27;i++){\n                if(arr[i]>0){\n                    ans.append(str.charAt(i - 1));\n                    arr[i]=arr[i]-1;\n                    count++;\n                }\n            }\n            for(int j=26;j>=1;j--){\n                if(arr[j]>0){\n                    ans.append(str.charAt(j - 1));\n                    arr[j]=arr[j]-1;\n                    count++;\n                }\n            }\n        }\n        return unicornMethod(ans);\n    }\n\n    public String unicornMethod(StringBuilder s) {\n        \n    }\n}\n",
        "explanations": "\nUndefined method 'unicornMethod' in the class, program crashes when it tries to execute it.\n"
    },
    {
        "slug": "max-area-of-island",
        "description": "You are given an m x n binary matrix grid. An island is a group of 1's (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.\nThe area of an island is the number of cells with a value 1 in the island.\nReturn the maximum area of an island in grid. If there is no island, return 0.",
        "examples": [
            "Input: grid = [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]\nOutput: 6\nExplanation: The answer is not 11, because the island must be connected 4-directionally.",
            "Input: grid = [[0,0,0,0,0,0,0,0]]\nOutput: 0"
        ],
        "constraints": "m == grid.length\nn == grid[i].length\n1 <= m, n <= 50\ngrid[i][j] is either 0 or 1.",
        "release_time": 1672631767,
        "oracle_code": "class Solution {\n    public int max = 0;\n    public int sum = 0;\n    public int maxAreaOfIsland(int[][] grid) {\n        for(int i = 0; i<grid.length;i++)\n        {\n            for(int j = 0; j<grid[i].length;j++)\n            {\n                if(grid[i][j]!=0)\n                {\n                    sum = 0; \n                    dfs(grid,i,j);\n                    max  = Math.max(max,sum);\n                }\n            }\n        }\n\n        return max;\n    }\n\n    private void dfs(int[][] grid ,int r ,int c)\n    {\n        if(r>=grid.length || c>=grid[0].length || r<0|| c<0 || grid[r][c]==0)\n        {\n            return ;\n        }\n\n        sum++;\n        grid[r][c] = 0;\n        dfs(grid,r,c+1);\n        dfs(grid,r,c-1);\n        dfs(grid,r+1,c);\n        dfs(grid,r-1,c);\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int max = 0;\\n    public int sum = 0;\\n    public int maxAreaOfIsland(int[][] grid) {\\n        for(int i = 0; i<grid.length;i++)\\n        {\\n            for(int j = 0; j<grid[i].length;j++)\\n            {\\n                if(grid[i][j]!=0)\\n                {\\n                    sum = 0; \\n                    dfs(grid,i,j);\\n                    max  = Math.max(max,sum);\\n                }\\n            }\\n        }\\n\\n        return max;\\n    }\\n\\n    private void dfs(int[][] grid ,int r ,int c)\\n    {\\n        if(r>=grid.length || c>=grid[0].length || r<0|| c<0 || grid[r][c]==0)\\n        {\\n            return ;\\n        }\\n\\n        sum++;\\n        grid[r][c] = 0;\\n        dfs(grid,r,c+1);\\n        dfs(grid,r,c-1);\\n        dfs(grid,r+1,c);\\n        dfs(grid,r-1,c);\\n    }\\n}\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\n    public int max = 0;\n    public int sum = 0;\n    public int maxAreaOfIsland(int[][] grid) {\n        for(int i = 0; i<grid.length;i++)\n        {\n            for(int j = 0; j<grid[i].length;j++)\n            {\n                if(grid[i][j]!=0)\n                {\n                    sum = 0; \n                    dfs(grid,i,j);\n                    max  = Math.max(max,sum);\n                }\n            }\n        }\n\n        return max;\n    }\n\n    private void flipIsland(int[][] grid ,int r ,int c) {\n        if(r>=grid.length || c>=grid[0].length || r<0|| c<0 || grid[r][c]==0) {\n            return ;\n        }\n\n        sum++;\n        grid[r][c] = 0;\n        flipIsland(grid,r,c+1);\n        flipIsland(grid,r,c-1);\n        flipIsland(grid,r+1,c);\n        flipIsland(grid,r-1,c);\n    }\n}\n",
        "explanations": "\nIn the program, dfs(grid, i, j) is called but the method doesn't exist, resulting in an undefined method error.\n"
    },
    {
        "slug": "implement-trie-prefix-tree",
        "description": "A trie (pronounced as \"try\") or prefix tree is a tree data structure used to efficiently store and retrieve keys in a dataset of strings. There are various applications of this data structure, such as autocomplete and spellchecker.\nImplement the Trie class:\n\nTrie() Initializes the trie object.\nvoid insert(String word) Inserts the string word into the trie.\nboolean search(String word) Returns true if the string word is in the trie (i.e., was inserted before), and false otherwise.\nboolean startsWith(String prefix) Returns true if there is a previously inserted string word that has the prefix prefix, and false otherwise.",
        "examples": [
            "Input\n[\"Trie\", \"insert\", \"search\", \"search\", \"startsWith\", \"insert\", \"search\"]\n[[], [\"apple\"], [\"apple\"], [\"app\"], [\"app\"], [\"app\"], [\"app\"]]\nOutput\n[null, null, true, false, true, null, true]\n\nExplanation\nTrie trie = new Trie();\ntrie.insert(\"apple\");\ntrie.search(\"apple\");   // return True\ntrie.search(\"app\");     // return False\ntrie.startsWith(\"app\"); // return True\ntrie.insert(\"app\");\ntrie.search(\"app\");     // return True"
        ],
        "constraints": "1 <= word.length, prefix.length <= 2000\nword and prefix consist only of lowercase English letters.\nAt most 3 * 104 calls in total will be made to insert, search, and startsWith.",
        "release_time": 1682938465,
        "oracle_code": "class Node{\n    Node links[]= new Node[26];\n    boolean flag=false;\n    public Node(){\n\n    }\n    boolean contains(char ch){\n        return (links[ch-'a']!=null);\n    }\n    void put(char ch, Node node){\n        links[ch-'a']=node;\n    }\n    Node get(char ch){\n        return links[ch-'a'];\n    }\n    boolean isEnd(){\n        return flag;\n    }\n    void setEnd(){\n        flag=true;\n    }\n\n}\nclass Trie {\nprivate static Node root;\n    public Trie() {\n        root=new Node();\n    }\n    \n    public void insert(String word) {\n        Node node=root;\n        for(int i=0;i<word.length();i++){\n            if(!node.contains(word.charAt(i))){\n                node.put(word.charAt(i),new Node());\n            }\n            node=node.get(word.charAt(i));\n        }\n        node.setEnd();\n    }\n    \n    public boolean search(String word) {\n        Node node=root;\n        for(int i=0;i<word.length();i++){\n            if(!node.contains(word.charAt(i))){\n                return false;\n            }\n            node=node.get(word.charAt(i));\n        }\n        if(node.isEnd())\n            return true;\n        return false;\n    }\n    \n    public boolean startsWith(String prefix) {\n        Node node=root;\n        for(int i=0;i<prefix.length();i++){\n            if(!node.contains(prefix.charAt(i))){\n                return false;\n            }\n            node=node.get(prefix.charAt(i));\n        }\n        return true;\n    }\n}\n\n/**\n * Your Trie object will be instantiated and called as such:\n * Trie obj = new Trie();\n * obj.insert(word);\n * boolean param_2 = obj.search(word);\n * boolean param_3 = obj.startsWith(prefix);\n */",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Node{\\n    Node links[]= new Node[26];\\n    boolean flag=false;\\n    public Node(){\\n\\n    }\\n    boolean contains(char ch){\\n        return (links[ch-\\'a\\']!=null);\\n    }\\n    void put(char ch, Node node){\\n        links[ch-\\'a\\']=node;\\n    }\\n    Node get(char ch){\\n        return links[ch-\\'a\\'];\\n    }\\n    boolean isEnd(){\\n        return flag;\\n    }\\n    void setEnd(){\\n        flag=true;\\n    }\\n\\n}\\nclass Trie {\\nprivate static Node root;\\n    public Trie() {\\n        root=new Node();\\n    }\\n    \\n    public void insert(String word) {\\n        Node node=root;\\n        for(int i=0;i<word.length();i++){\\n            if(!node.contains(word.charAt(i))){\\n                node.put(word.charAt(i),new Node());\\n            }\\n            node=node.get(word.charAt(i));\\n        }\\n        node.setEnd();\\n    }\\n    \\n    public boolean search(String word) {\\n        Node node=root;\\n        for(int i=0;i<word.length();i++){\\n            if(!node.contains(word.charAt(i))){\\n                return false;\\n            }\\n            node=node.get(word.charAt(i));\\n        }\\n        if(node.isEnd())\\n            return true;\\n        return false;\\n    }\\n    \\n    public boolean startsWith(String prefix) {\\n        Node node=root;\\n        for(int i=0;i<prefix.length();i++){\\n            if(!node.contains(prefix.charAt(i))){\\n                return false;\\n            }\\n            node=node.get(prefix.charAt(i));\\n        }\\n        return true;\\n    }\\n}\\n\\n/**\\n * Your Trie object will be instantiated and called as such:\\n * Trie obj = new Trie();\\n * obj.insert(word);\\n * boolean param_2 = obj.search(word);\\n * boolean param_3 = obj.startsWith(prefix);\\n */\\n```",
        "level": "medium",
        "buggy_code": "\nclass Node{\n    Node links[]= new Node[26];\n    boolean flag=false;\n    public Node(){\n\n    }\n    boolean contains(char ch){\n        return (links[ch-'a']!=null);\n    }\n    void put(char ch, Node node){\n        links[ch-'a']=node;\n    }\n    Node get(char ch){\n        return links[ch-'a'];\n    }\n    boolean isEnd(){\n        return flag;\n    }\n    void setEnd(){\n        flag=true;\n    }\n\n}\nclass Trie {\nprivate static Node root;\n    public Trie() {\n        root=new Node();\n    }\n\n    public void insert(String word) {\n        Node node=root;\n        for(int i=0;i<word.length();i++){\n            if(!node.contains(word.charAt(i))){\n                node.put(word.charAt(i),new Node());\n            }\n            node=node.get(word.charAt(i));\n        }\n        node.setEnd();\n    }\n    \n    public boolean search(String word) {\n        Node node=searchNode(word);\n        if(node.isEnd())\n            return true;\n        return false;\n    }\n    \n    public Node searchNode(String word){\n        Node node=root;\n        for(int i=0;i<word.length();i++){\n            if(!node.contains(word.charAt(i))){\n                return null;\n            }\n            node=node.get(word.charAt(i));\n        }\n        return node;\n    }\n\n    public boolean startsWith(String prefix) {\n         Node node=searchNode(prefix);\n        if (node == null)\n            return false;\n        return true;\n    }\n}\n\n/**\n * Your Trie object will be instantiated and called as such:\n * Trie obj = new Trie();\n * obj.insert(word);\n * boolean param_2 = obj.search(word);\n * boolean param_3 = obj.startsWith(prefix);\n */\n",
        "explanations": "\nOne method searchNode has been added but never defined or declared anywhere\n"
    },
    {
        "slug": "minimum-time-to-visit-a-cell-in-a-grid",
        "description": "You are given a m x n matrix grid consisting of non-negative integers where grid[row][col] represents the minimum time required to be able to visit the cell (row, col), which means you can visit the cell (row, col) only when the time you visit it is greater than or equal to grid[row][col].\nYou are standing in the top-left cell of the matrix in the 0th second, and you must move to any adjacent cell in the four directions: up, down, left, and right. Each move you make takes 1 second.\nReturn the minimum time required in which you can visit the bottom-right cell of the matrix. If you cannot visit the bottom-right cell, then return -1.",
        "examples": [
            "Input: grid = [[0,1,3,2],[5,1,2,5],[4,3,8,6]]\nOutput: 7\nExplanation: One of the paths that we can take is the following:\n- at t = 0, we are on the cell (0,0).\n- at t = 1, we move to the cell (0,1). It is possible because grid[0][1] <= 1.\n- at t = 2, we move to the cell (1,1). It is possible because grid[1][1] <= 2.\n- at t = 3, we move to the cell (1,2). It is possible because grid[1][2] <= 3.\n- at t = 4, we move to the cell (1,1). It is possible because grid[1][1] <= 4.\n- at t = 5, we move to the cell (1,2). It is possible because grid[1][2] <= 5.\n- at t = 6, we move to the cell (1,3). It is possible because grid[1][3] <= 6.\n- at t = 7, we move to the cell (2,3). It is possible because grid[2][3] <= 7.\nThe final time is 7. It can be shown that it is the minimum time possible.",
            "Input: grid = [[0,2,4],[3,2,1],[1,0,4]]\nOutput: -1\nExplanation: There is no path from the top left to the bottom-right cell."
        ],
        "constraints": "m == grid.length\nn == grid[i].length\n2 <= m, n <= 1000\n4 <= m * n <= 105\n0 <= grid[i][j] <= 105\ngrid[0][0] == 0",
        "release_time": 1677384057,
        "oracle_code": "class Solution {\n    private static final int[][] DIRS = new int[][] { { 1, 0 }, { -1, 0}, { 0, 1 }, { 0, -1 } };\n    public int minimumTime(int[][] grid) {\n        if (grid[0][1] > 1 && grid[1][0] > 1) {\n            return -1;\n        }\n        \n        int m = grid.length;\n        int n = grid[0].length;\n        \n        PriorityQueue<int[]> heap = new PriorityQueue<>((a, b) -> a[2] - b[2]);\n        heap.offer(new int[] { 0, 0, 0 }); // row, col, time\n        \n        boolean[][] visited = new boolean[m][n];\n        \n        while (!heap.isEmpty()) {\n            int[] entry = heap.poll();\n            int row = entry[0];\n            int col = entry[1];\n            int time = entry[2];\n            if (row == m - 1 && col == n - 1) {\n                return time;\n            }\n            if (visited[row][col]) {\n                continue;\n            }\n            visited[row][col] = true;\n                \n            for (int[] dir : DIRS) {\n                int r = row + dir[0];\n                int c = col + dir[1];\n                if (r < 0 || r == m || c < 0 || c == n || visited[r][c]) {\n                    continue;\n                }\n                \n                if (grid[r][c] <= time + 1) {\n                    // if it is possible to move to neighbor, do it\n                    heap.offer(new int[] { r, c, time + 1 });\n                } else {\n                    // If we cant move to neighbor yet, we can hop to the previous cell\n                    // and back to current cell as many times as we need to until\n                    // sufficient time has passed.\n                    // The trick here is that if the difference between the current time\n                    // and the time we need is even, we will arrive back at the current cell\n                    // 1 second \"late\" and so we will move to the neighbor 1 second after\n                    // the minimum neighbor time.\n                    int diff = grid[r][c] - time;\n                    if (diff % 2 == 1) {\n                        heap.offer(new int[] { r, c, grid[r][c] });\n                    } else {\n                        heap.offer(new int[] { r, c, grid[r][c] + 1 });\n                    }\n                }\n            }\n        }\n        return -1; // will never reach here\n    }\n}",
        "content": "```\\nclass Solution {\\n    private static final int[][] DIRS = new int[][] { { 1, 0 }, { -1, 0}, { 0, 1 }, { 0, -1 } };\\n    public int minimumTime(int[][] grid) {\\n        if (grid[0][1] > 1 && grid[1][0] > 1) {\\n            return -1;\\n        }\\n        \\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        PriorityQueue<int[]> heap = new PriorityQueue<>((a, b) -> a[2] - b[2]);\\n        heap.offer(new int[] { 0, 0, 0 }); // row, col, time\\n        \\n        boolean[][] visited = new boolean[m][n];\\n        \\n        while (!heap.isEmpty()) {\\n            int[] entry = heap.poll();\\n            int row = entry[0];\\n            int col = entry[1];\\n            int time = entry[2];\\n            if (row == m - 1 && col == n - 1) {\\n                return time;\\n            }\\n            if (visited[row][col]) {\\n                continue;\\n            }\\n            visited[row][col] = true;\\n                \\n            for (int[] dir : DIRS) {\\n                int r = row + dir[0];\\n                int c = col + dir[1];\\n                if (r < 0 || r == m || c < 0 || c == n || visited[r][c]) {\\n                    continue;\\n                }\\n                \\n                if (grid[r][c] <= time + 1) {\\n                    // if it is possible to move to neighbor, do it\\n                    heap.offer(new int[] { r, c, time + 1 });\\n                } else {\\n                    // If we cant move to neighbor yet, we can hop to the previous cell\\n                    // and back to current cell as many times as we need to until\\n                    // sufficient time has passed.\\n                    // The trick here is that if the difference between the current time\\n                    // and the time we need is even, we will arrive back at the current cell\\n                    // 1 second \"late\" and so we will move to the neighbor 1 second after\\n                    // the minimum neighbor time.\\n                    int diff = grid[r][c] - time;\\n                    if (diff % 2 == 1) {\\n                        heap.offer(new int[] { r, c, grid[r][c] });\\n                    } else {\\n                        heap.offer(new int[] { r, c, grid[r][c] + 1 });\\n                    }\\n                }\\n            }\\n        }\\n        return -1; // will never reach here\\n    }\\n}\\n```",
        "level": "hard",
        "buggy_code": "\nclass Solution {\n    private static final int[][] DIRS = new int[][] { { 1, 0 }, { -1, 0}, { 0, 1 }, { 0, -1 } };\n    \n    public int minimumTime(int[][] grid) {\n        if (grid[0][1] > 1 && grid[1][0] > 1) {\n            return -1;\n        }\n        \n        int m = grid.length;\n        int n = grid[0].length;\n        \n        PriorityQueue<int[]> heap = new PriorityQueue<>((a, b) -> a[2] - b[2]);\n        heap.offer(new int[] { 0, 0, 0 }); // row, col, time\n        \n        boolean[][] visited = new boolean[m][n];\n        \n        while (!heap.isEmpty()) {\n            int[] entry = heap.poll();\n            int row = entry[0];\n            int col = entry[1];\n            int time = entry[2];\n            if (row == m - 1 && col == n - 1) {\n                return time;\n            }\n            if (visited[row][col]) {\n                continue;\n            }\n            visited[row][col] = true;\n                \n            for (int[] dir : DIRS) {\n                int r = row + dir[0];\n                int c = col + dir[1];\n                if (r < 0 || r == m || c < 0 || c == n || visited[r][c]) {\n                    continue;\n                }\n                \n                if (grid[r][c] <= time + 1) {\n                    // if it is possible to move to neighbor, do it\n                    heap.offer(new int[] { r, c, time + 1 });\n                } else {\n                    // If we cant move to neighbor yet, we can hop to the previous cell\n                    // and back to current cell as many times as we need to until\n                    // sufficient time has passed.\n                    int diff = grid[r][c] - time;\n                    if (diff % 2 == 1) {\n                        heap.offer(new int[] { r, c, grid[r][c] });\n                    } else {\n                        heap.offer(new int[] { r, c, grid[r][c] + 1 });\n                    }\n                }\n            }\n        }\n        return printTime(); \n    }\n}\n",
        "explanations": "\nThe printTime() method is not defined, causing an 'undefined method' bug.\n"
    },
    {
        "slug": "sum-of-left-leaves",
        "description": "Given the root of a binary tree, return the sum of all left leaves.\nA leaf is a node with no children. A left leaf is a leaf that is the left child of another node.",
        "examples": [
            "Input: root = [3,9,20,null,null,15,7]\nOutput: 24\nExplanation: There are two left leaves in the binary tree, with values 9 and 15 respectively.",
            "Input: root = [1]\nOutput: 0"
        ],
        "constraints": "The number of nodes in the tree is in the range [1, 1000].\n-1000 <= Node.val <= 1000",
        "release_time": 1689484464,
        "oracle_code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n\n    static int result;\n\n    public int sumOfLeftLeaves(TreeNode root) {\n        result=0;\n\n        task(root.left, true);\n\n        task(root.right, false);\n\n        return result;\n    }\n\n    static void task(TreeNode root, boolean flag){\n        if(root == null) return;\n\n        if(flag && root.left==null && root.right==null) result+=root.val;\n\n        task(root.left, true);\n        task(root.right, false);\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n\\n    static int result;\\n\\n    public int sumOfLeftLeaves(TreeNode root) {\\n        result=0;\\n\\n        task(root.left, true);\\n\\n        task(root.right, false);\\n\\n        return result;\\n    }\\n\\n    static void task(TreeNode root, boolean flag){\\n        if(root == null) return;\\n\\n        if(flag && root.left==null && root.right==null) result+=root.val;\\n\\n        task(root.left, true);\\n        task(root.right, false);\\n    }\\n}\\n```",
        "level": "easy",
        "buggy_code": "\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n\n    static int result;\n\n    public int sumOfLeftLeaves(TreeNode root) {\n        result=0;\n\n        task(root.left, true);\n\n        task(root.right, false);\n\n        calculate(root);\n\n        return result;\n    }\n\n    static void task(TreeNode root, boolean flag){\n        if(root == null) return;\n\n        if(flag && root.left==null && root.right==null) result+=root.val;\n\n        task(root.left, true);\n        task(root.right, false);\n    }\n}\n",
        "explanations": "\nThe calculate(root) method is called in sumOfLeftLeaves but isn't defined anywhere.\n"
    },
    {
        "slug": "maximum-sum-of-an-hourglass",
        "description": "You are given an m x n integer matrix grid.\nWe define an hourglass as a part of the matrix with the following form:\n\nReturn the maximum sum of the elements of an hourglass.\nNote that an hourglass cannot be rotated and must be entirely contained within the matrix.",
        "examples": [
            "Input: grid = [[6,2,1,3],[4,2,1,5],[9,2,8,7],[4,1,2,9]]\nOutput: 30\nExplanation: The cells shown above represent the hourglass with the maximum sum: 6 + 2 + 1 + 2 + 9 + 2 + 8 = 30.",
            "Input: grid = [[1,2,3],[4,5,6],[7,8,9]]\nOutput: 35\nExplanation: There is only one hourglass in the matrix, with the sum: 1 + 2 + 3 + 5 + 7 + 8 + 9 = 35."
        ],
        "constraints": "m == grid.length\nn == grid[i].length\n3 <= m, n <= 150\n0 <= grid[i][j] <= 106",
        "release_time": 1665324662,
        "oracle_code": "class Solution {\n    public int maxSum(int[][] grid) {\n        int max = -1, m = grid.length, n = grid[0].length;\n        for (int row = 0; row < m - 2; row++) {\n            for (int col = 0; col < n - 2; col++) {\n                int temp = grid[row][col] + grid[row][col + 1] + grid[row][col + 2];\n                temp += grid[row + 1][col + 1];\n                temp += grid[row + 2][col] + grid[row + 2][col + 1] + grid[row + 2][col + 2];\n                if (max < temp) {\n                    max = temp;\n                }\n            }\n        }\n        return max;\n    }\n}",
        "content": "# Code\\n```\\nclass Solution {\\n    public int maxSum(int[][] grid) {\\n        int max = -1, m = grid.length, n = grid[0].length;\\n        for (int row = 0; row < m - 2; row++) {\\n            for (int col = 0; col < n - 2; col++) {\\n                int temp = grid[row][col] + grid[row][col + 1] + grid[row][col + 2];\\n                temp += grid[row + 1][col + 1];\\n                temp += grid[row + 2][col] + grid[row + 2][col + 1] + grid[row + 2][col + 2];\\n                if (max < temp) {\\n                    max = temp;\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\n    public int maxSum(int[][] grid) {\n        int max = findMax();\n\n        return max;\n    }\n    \n    private int findMax(int[][] array) {\n        int max = -1, m = array.length, n = array[0].length;\n        for (int row = 0; row < m - 2; row++) {\n            for (int col = 0; col < n - 2; col++) {\n                int temp = array[row][col] + array[row][col + 1] + array[row][col + 2];\n                temp += array[row + 1][col + 1];\n                temp += array[row + 2][col] + array[row + 2][col + 1] + array[row + 2][col + 2];\n                if (max < temp) {\n                    max = temp;\n                }\n            }\n        }\n        return max;\n    }\n}\n",
        "explanations": "\nMethod findMax() in class Solution is not defined or declared incorrectly.\n"
    },
    {
        "slug": "second-minimum-node-in-a-binary-tree",
        "description": "Given a non-empty special binary tree consisting of nodes with the non-negative value, where each node in this tree has exactly two or zero sub-node. If the node has two sub-nodes, then this node's value is the smaller value among its two sub-nodes. More formally, the property\u00a0root.val = min(root.left.val, root.right.val)\u00a0always holds.\nGiven such a binary tree, you need to output the second minimum value in the set made of all the nodes' value in the whole tree.\nIf no such second minimum value exists, output -1 instead.",
        "examples": [
            "Input: root = [2,2,5,null,null,5,7]\nOutput: 5\nExplanation: The smallest value is 2, the second smallest value is 5.",
            "Input: root = [2,2,2]\nOutput: -1\nExplanation: The smallest value is 2, but there isn't any second smallest value."
        ],
        "constraints": "The number of nodes in the tree is in the range [1, 25].\n1 <= Node.val <= 231 - 1\nroot.val == min(root.left.val, root.right.val)\u00a0for each internal node of the tree.",
        "release_time": 1677899029,
        "oracle_code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    int min=-1;\n    int secondMin=Integer.MAX_VALUE;\n    boolean flag=false;\n    public int findSecondMinimumValue(TreeNode root) {\n        if(root == null)return secondMin;\n        min =root.val;\n        help(root);\n        if(!flag){return -1;}\n        return secondMin;\n    }\n    public void help(TreeNode root){\n        if(root == null)return;\n        if(min< root.val && root.val<= secondMin){\n            secondMin = root.val;\n            flag = true;\n        }\n        help(root.left);\n        help(root.right);\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf you like my solution please upvote\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int min=-1;\\n    int secondMin=Integer.MAX_VALUE;\\n    boolean flag=false;\\n    public int findSecondMinimumValue(TreeNode root) {\\n        if(root == null)return secondMin;\\n        min =root.val;\\n        help(root);\\n        if(!flag){return -1;}\\n        return secondMin;\\n    }\\n    public void help(TreeNode root){\\n        if(root == null)return;\\n        if(min< root.val && root.val<= secondMin){\\n            secondMin = root.val;\\n            flag = true;\\n        }\\n        help(root.left);\\n        help(root.right);\\n    }\\n}\\n```",
        "level": "easy",
        "buggy_code": "\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    int min=-1;\n    int secondMin=Integer.MAX_VALUE;\n    boolean flag=false;\n    public int findSecondMinimumValue(TreeNode root) {\n        if(root == null)return secondMin;\n        min =root.val;\n        help(root);\n        if(!flag){return -1;}\n        return secondMin;\n    }\n    public void help(TreeNode root){\n        if(root == null)return;\n        if(min< root.val && root.val<= secondMin){\n            secondMin = root.val;\n            flag = true;\n        }\n        goLeft(root.left);\n        goRight(root.right);\n    }\n}\n",
        "explanations": "\nThe methods goLeft and goRight are called in the code but aren't defined anywhere.\n"
    },
    {
        "slug": "number-of-ways-to-earn-points",
        "description": "There is a test that has n types of questions. You are given an integer target and a 0-indexed 2D integer array types where types[i] = [counti, marksi] indicates that there are counti questions of the ith type, and each one of them is worth marksi points.\n\n\nReturn the number of ways you can earn exactly target points in the exam. Since the answer may be too large, return it modulo 109 + 7.\nNote that questions of the same type are indistinguishable.\n\nFor example, if there are 3 questions of the same type, then solving the 1st and 2nd questions is the same as solving the 1st and 3rd questions, or the 2nd and 3rd questions.",
        "examples": [
            "Input: target = 6, types = [[6,1],[3,2],[2,3]]\nOutput: 7\nExplanation: You can earn 6 points in one of the seven ways:\n- Solve 6 questions of the 0th type: 1 + 1 + 1 + 1 + 1 + 1 = 6\n- Solve 4 questions of the 0th type and 1 question of the 1st type: 1 + 1 + 1 + 1 + 2 = 6\n- Solve 2 questions of the 0th type and 2 questions of the 1st type: 1 + 1 + 2 + 2 = 6\n- Solve 3 questions of the 0th type and 1 question of the 2nd type: 1 + 1 + 1 + 3 = 6\n- Solve 1 question of the 0th type, 1 question of the 1st type and 1 question of the 2nd type: 1 + 2 + 3 = 6\n- Solve 3 questions of the 1st type: 2 + 2 + 2 = 6\n- Solve 2 questions of the 2nd type: 3 + 3 = 6",
            "Input: target = 5, types = [[50,1],[50,2],[50,5]]\nOutput: 4\nExplanation: You can earn 5 points in one of the four ways:\n- Solve 5 questions of the 0th type: 1 + 1 + 1 + 1 + 1 = 5\n- Solve 3 questions of the 0th type and 1 question of the 1st type: 1 + 1 + 1 + 2 = 5\n- Solve 1 questions of the 0th type and 2 questions of the 1st type: 1 + 2 + 2 = 5\n- Solve 1 question of the 2nd type: 5",
            "Input: target = 18, types = [[6,1],[3,2],[2,3]]\nOutput: 1\nExplanation: You can only earn 18 points by answering all questions."
        ],
        "constraints": "1 <= target <= 1000\nn == types.length\n1 <= n <= 50\ntypes[i].length == 2\n1 <= counti, marksi <= 50",
        "release_time": 1677989079,
        "oracle_code": "class Solution {\n    public int waysToReachTarget(int target, int[][] types) {\n        int[][] memo = new int[target + 1][types.length + 1];\n        for (int[] ints : memo) {\n            Arrays.fill(ints, -1);\n        }\n        return (int) backtrack(target, types, 0, memo);\n    }\n    \n    private long backtrack(int target, int[][] types, int start, int[][] memo) {\n        if (target == 0) {\n            return 1;\n        }\n        if (target < 0) {\n            return 0;\n        }\n        if (memo[target][start] != -1) {\n            return memo[target][start];\n        }\n        long res = 0;\n        for (int i = start; i < types.length; i++) {\n            for (int j = 1; j <= types[i][0]; j++) {\n                if (target - j * types[i][1] < 0) {\n                    break;\n                }\n                long temp = backtrack(target - j * types[i][1], types, i + 1, memo);\n                res = (res + temp) % 1_000_000_007;\n            }\n        }\n        memo[target][start] = (int) res;\n        return res;\n    }\n}",
        "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity -->\\n<!-- - Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int waysToReachTarget(int target, int[][] types) {\\n        int[][] memo = new int[target + 1][types.length + 1];\\n        for (int[] ints : memo) {\\n            Arrays.fill(ints, -1);\\n        }\\n        return (int) backtrack(target, types, 0, memo);\\n    }\\n    \\n    private long backtrack(int target, int[][] types, int start, int[][] memo) {\\n        if (target == 0) {\\n            return 1;\\n        }\\n        if (target < 0) {\\n            return 0;\\n        }\\n        if (memo[target][start] != -1) {\\n            return memo[target][start];\\n        }\\n        long res = 0;\\n        for (int i = start; i < types.length; i++) {\\n            for (int j = 1; j <= types[i][0]; j++) {\\n                if (target - j * types[i][1] < 0) {\\n                    break;\\n                }\\n                long temp = backtrack(target - j * types[i][1], types, i + 1, memo);\\n                res = (res + temp) % 1_000_000_007;\\n            }\\n        }\\n        memo[target][start] = (int) res;\\n        return res;\\n    }\\n}\\n```",
        "level": "hard",
        "buggy_code": "\nclass Solution {\n    public int waysToReachTarget(int target, int[][] types) {\n        int[][] memo = new int[target + 1][types.length + 1];\n        for (int[] ints : memo) {\n            Arrays.fill(ints, -1);\n        }\n        \n        return getPath(target, types, 0, memo);\n    }\n    \n    private long backtrack(int target, int[][] types, int start, int[][] memo) {\n        if (target == 0) {\n            return 1;\n        }\n        if (target < 0) {\n            return 0;\n        }\n        if (memo[target][start] != -1) {\n            return memo[target][start];\n        }\n        long res = 0;\n        for (int i = start; i < types.length; i++) {\n            for (int j = 1; j <= types[i][0]; j++) {\n                if (target - j * types[i][1] < 0) {\n                    break;\n                }\n                long temp = backtrack(target - j * types[i][1], types, i + 1, memo);\n                res = (res + temp) % 1_000_000_007;\n            }\n        }\n        memo[target][start] = (int) res;\n        return res;\n    }\n}\n",
        "explanations": "\nThe bug is calling the undefined method \"getPath\" instead of \"backtrack\" in method \"waysToReachTarget\".\n"
    },
    {
        "slug": "how-many-numbers-are-smaller-than-the-current-number",
        "description": "Given the array nums, for each nums[i] find out how many numbers in the array are smaller than it. That is, for each nums[i] you have to count the number of valid j's\u00a0such that\u00a0j != i and nums[j] < nums[i].\nReturn the answer in an array.",
        "examples": [
            "Input: nums = [8,1,2,2,3]\nOutput: [4,0,1,1,3]\nExplanation: \nFor nums[0]=8 there exist four smaller numbers than it (1, 2, 2 and 3). \nFor nums[1]=1 does not exist any smaller number than it.\nFor nums[2]=2 there exist one smaller number than it (1). \nFor nums[3]=2 there exist one smaller number than it (1). \nFor nums[4]=3 there exist three smaller numbers than it (1, 2 and 2).",
            "Input: nums = [6,5,4,8]\nOutput: [2,1,0,3]",
            "Input: nums = [7,7,7,7]\nOutput: [0,0,0,0]"
        ],
        "constraints": "2 <= nums.length <= 500\n0 <= nums[i] <= 100",
        "release_time": 1691043692,
        "oracle_code": "class Solution {\n    public int[] smallerNumbersThanCurrent(int[] nums) {\n        int c=0;\n        int res[]=new int[nums.length],k=0;\n        for(int i=0;i<nums.length;i++){\n         for(int j=0;j<nums.length;j++){\n             if(nums[j]<nums[i]){\n                 c+=1;\n                    }\n                 }\n                res[i]=c;\n               c=0;\n              }\n      return res;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int c=0;\\n        int res[]=new int[nums.length],k=0;\\n        for(int i=0;i<nums.length;i++){\\n         for(int j=0;j<nums.length;j++){\\n             if(nums[j]<nums[i]){\\n                 c+=1;\\n                    }\\n                 }\\n                res[i]=c;\\n               c=0;\\n              }\\n      return res;\\n    }\\n}\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\n    public int[] smallerNumbersThanCurrent(int[] nums) {\n        int c=0;\n        int res[]=new int[nums.length],k=0;\n        for(int i=0;i<nums.length;i++){\n         for(int j=0;j<nums.length;j++){\n             if(nums[j]<nums[i]){\n                 c+=1;\n                    }\n                 }\n                res[i]=c;\n               c=0;\n              }\n      return res;\n    }\n\n    public int[] callUndefinedMethod() {\n        undefinedMethod();\n        return new int[0];\n    }\n}\n",
        "explanations": "\nThe bug is the method \"undefinedMethod()\" being called in \"callUndefinedMethod()\" but it is never defined.\n"
    },
    {
        "slug": "remove-colored-pieces-if-both-neighbors-are-the-same-color",
        "description": "There are n pieces arranged in a line, and each piece is colored either by 'A' or by 'B'. You are given a string colors of length n where colors[i] is the color of the ith piece.\nAlice and Bob are playing a game where they take alternating turns removing pieces from the line. In this game, Alice moves first.\n\nAlice is only allowed to remove a piece colored 'A' if both its neighbors are also colored 'A'. She is not allowed to remove pieces that are colored 'B'.\nBob is only allowed to remove a piece colored 'B' if both its neighbors are also colored 'B'. He is not allowed to remove pieces that are colored 'A'.\nAlice and Bob cannot remove pieces from the edge of the line.\nIf a player cannot make a move on their turn, that player loses and the other player wins.\n\nAssuming Alice and Bob play optimally, return true if Alice wins, or return false if Bob wins.",
        "examples": [
            "Input: colors = \"AAABABB\"\nOutput: true\nExplanation:\nAAABABB -> AABABB\nAlice moves first.\nShe removes the second 'A' from the left since that is the only 'A' whose neighbors are both 'A'.\n\nNow it's Bob's turn.\nBob cannot make a move on his turn since there are no 'B's whose neighbors are both 'B'.\nThus, Alice wins, so return true.",
            "Input: colors = \"AA\"\nOutput: false\nExplanation:\nAlice has her turn first.\nThere are only two 'A's and both are on the edge of the line, so she cannot move on her turn.\nThus, Bob wins, so return false.",
            "Input: colors = \"ABBBBBBBAAA\"\nOutput: false\nExplanation:\nABBBBBBBAAA -> ABBBBBBBAA\nAlice moves first.\nHer only option is to remove the second to last 'A' from the right.\n\nABBBBBBBAA -> ABBBBBBAA\nNext is Bob's turn.\nHe has many options for which 'B' piece to remove. He can pick any.\n\nOn Alice's second turn, she has no more pieces that she can remove.\nThus, Bob wins, so return false."
        ],
        "constraints": "1 <=\u00a0colors.length <= 105\ncolors\u00a0consists of only the letters\u00a0'A'\u00a0and\u00a0'B'",
        "release_time": 1657989117,
        "oracle_code": "class Solution {\n    public boolean winnerOfGame(String s) {\n        //count the triplets\nint n = s.length();\n    \n        int a=0;\n        int b=0;\n        \n        for(int i=1; i<n-1; i++)\n        {\n            if(s.charAt(i)=='A' && s.charAt(i-1)=='A' && s.charAt(i+1)=='A' )\n        a++;\n            else if(s.charAt(i)=='B' && s.charAt(i-1)=='B' && s.charAt(i+1)=='B' )\n        b++;\n            \n            }\n        if(a<=b)\n            return false;\n        else\n            return true;\n        \n    \n    }\n}",
        "content": "Idea behind it is that you need to count the number of triplets of both A and B \\nint a -> number of triplets of \\'A\\'\\nint b -> number of triplets of \\'B\\'\\nif(b>=a) BOB wins else Alice wins\\n\\nAs Alice has to make a move first so if she wants to win there should be atleast  1 more  triplets of A than B\\n\\nEg There are 4 triplets of both A and B  (a=4, b=4) \\n1. Alice removes 1 A (a=3, b=4)\\n2. Bob removes 1 B (a=3, b=3)\\n3. (a=2, b=3)\\n4. (a=2, b=2)\\n5. (a=1, b=2)\\n6. (a=1, b=1)\\n7. (a=0, b=1)\\n\\nClearly Alice will lose if both have same number of triplets\\nCode \\n\\n```\\nclass Solution {\\n    public boolean winnerOfGame(String s) {\\n        //count the triplets\\nint n = s.length();\\n    \\n        int a=0;\\n        int b=0;\\n        \\n        for(int i=1; i<n-1; i++)\\n        {\\n            if(s.charAt(i)==\\'A\\' && s.charAt(i-1)==\\'A\\' && s.charAt(i+1)==\\'A\\' )\\n        a++;\\n            else if(s.charAt(i)==\\'B\\' && s.charAt(i-1)==\\'B\\' && s.charAt(i+1)==\\'B\\' )\\n        b++;\\n            \\n            }\\n        if(a<=b)\\n            return false;\\n        else\\n            return true;\\n        \\n    \\n    }\\n}\\n```\\nIf this helped you then please UpVote\\nThanks\\n\\n\\n",
        "level": "medium",
        "buggy_code": "\nclass Solution {\n    public boolean winnerOfGame(String s) {\n        //count the triplets\nint n = s.length();\n\n        int a=0;\n        int b=0;\n\n        for(int i=1; i<n-1; i++)\n        {\n            if(s.charAt(i)=='A' && s.charAt(i-1)=='A' && s.charAt(i+1)=='A' )\n        a++;\n            else if(s.charAt(i)=='B' && s.charAt(i-1)=='B' && s.charAt(i+1)=='B' )\n        b++;\n            \n            }\n        if(a<=b)\n            return false;\n        else\n            return ValidateResult();\n\n    }\n\n    private boolean ValidateResult() {\n        \n    }\n}\n",
        "explanations": "\nThe ValidateResult method is called but hasn't been implemented which results in a compilation error.\n"
    },
    {
        "slug": "row-with-maximum-ones",
        "description": "Given a m x n binary matrix mat, find the 0-indexed position of the row that contains the maximum count of ones, and the number of ones in that row.\nIn case there are multiple rows that have the maximum count of ones, the row with the smallest row number should be selected.\nReturn an array containing the index of the row, and the number of ones in it.",
        "examples": [
            "Input: mat = [[0,1],[1,0]]\nOutput: [0,1]\nExplanation: Both rows have the same number of 1's. So we return the index of the smaller row, 0, and the maximum count of ones (1). So, the answer is [0,1].",
            "Input: mat = [[0,0,0],[0,1,1]]\nOutput: [1,2]\nExplanation: The row indexed 1 has the maximum count of ones (2). So we return its index, 1, and the count. So, the answer is [1,2].",
            "Input: mat = [[0,0],[1,1],[0,0]]\nOutput: [1,2]\nExplanation: The row indexed 1 has the maximum count of ones (2). So the answer is [1,2]."
        ],
        "constraints": "m == mat.length\u00a0\nn == mat[i].length\u00a0\n1 <= m, n <= 100\u00a0\nmat[i][j] is either 0 or 1.",
        "release_time": 1684493016,
        "oracle_code": "class Solution {\n    public int[] rowAndMaximumOnes(int[][] mat) {\n        int count;\n        int maxCount = 0;\n        int maxCountRow = 0;\n        for(int i = 0; i < mat.length; i++) {\n            count = 0;\n            for(int j = 0; j < mat[0].length; j++) {\n                count += mat[i][j];\n            }\n            if(count > maxCount) {\n                maxCount = count;\n                maxCountRow = i;\n            }\n        }\n        return new int[]{maxCountRow, maxCount};\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int count;\\n        int maxCount = 0;\\n        int maxCountRow = 0;\\n        for(int i = 0; i < mat.length; i++) {\\n            count = 0;\\n            for(int j = 0; j < mat[0].length; j++) {\\n                count += mat[i][j];\\n            }\\n            if(count > maxCount) {\\n                maxCount = count;\\n                maxCountRow = i;\\n            }\\n        }\\n        return new int[]{maxCountRow, maxCount};\\n    }\\n}\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\n    public int[] rowAndMaximumOnes(int[][] mat) {\n        int count;\n        int maxCount = 0;\n        int maxCountRow = 0;\n        for(int i = 0; i < mat.length; i++) {\n            count = calculateRowSum(mat[i]);\n            if(count > maxCount) {\n                maxCount = count;\n                maxCountRow = i;\n            }\n        }\n        return new int[]{maxCountRow, maxCount};\n    }\n}\n",
        "explanations": "\nThe method 'calculateRowSum' is called but it's not implemented or defined anywhere in the class.\n"
    },
    {
        "slug": "largest-element-in-an-array-after-merge-operations",
        "description": "You are given a 0-indexed array nums consisting of positive integers.\nYou can do the following operation on the array any number of times:\n\nChoose an integer i such that 0 <= i < nums.length - 1 and nums[i] <= nums[i + 1]. Replace the element nums[i + 1] with nums[i] + nums[i + 1] and delete the element nums[i] from the array.\n\nReturn the value of the largest element that you can possibly obtain in the final array.",
        "examples": [
            "Input: nums = [2,3,7,9,3]\nOutput: 21\nExplanation: We can apply the following operations on the array:\n- Choose i = 0. The resulting array will be nums = [5,7,9,3].\n- Choose i = 1. The resulting array will be nums = [5,16,3].\n- Choose i = 0. The resulting array will be nums = [21,3].\nThe largest element in the final array is 21. It can be shown that we cannot obtain a larger element.",
            "Input: nums = [5,3,3]\nOutput: 11\nExplanation: We can do the following operations on the array:\n- Choose i = 1. The resulting array will be nums = [5,6].\n- Choose i = 0. The resulting array will be nums = [11].\nThere is only one element in the final array, which is 11."
        ],
        "constraints": "1 <= nums.length <= 105\n1 <= nums[i] <= 106",
        "release_time": 1690084837,
        "oracle_code": "class Solution {\n    public long maxArrayValue(int[] nums) {\n        if(nums.length==1)\n        {\n            return (long)nums[0];\n        }\n        if(nums.length==2)\n        {\n            return nums[0] <= nums[1] ? (long)(nums[0]+nums[1]) : (long)(Math.max(nums[0],nums[1]));\n        }\n        int size=nums.length;\n        long ans=0,dat=(long)nums[size-1];\n        for(int i=size-2;i>=0;i--)\n        {\n            long val=(long)nums[i];\n            if(val<=dat)\n            {\n                dat=dat+val;\n                if(dat>ans)\n                {\n                    ans=dat;\n                }\n            }\n            else\n            {\n                if(dat>ans)\n                {\n                    ans=dat;\n                }\n                dat=val;\n            }\n        }\n        return dat;\n    }\n}",
        "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public long maxArrayValue(int[] nums) {\\n        if(nums.length==1)\\n        {\\n            return (long)nums[0];\\n        }\\n        if(nums.length==2)\\n        {\\n            return nums[0] <= nums[1] ? (long)(nums[0]+nums[1]) : (long)(Math.max(nums[0],nums[1]));\\n        }\\n        int size=nums.length;\\n        long ans=0,dat=(long)nums[size-1];\\n        for(int i=size-2;i>=0;i--)\\n        {\\n            long val=(long)nums[i];\\n            if(val<=dat)\\n            {\\n                dat=dat+val;\\n                if(dat>ans)\\n                {\\n                    ans=dat;\\n                }\\n            }\\n            else\\n            {\\n                if(dat>ans)\\n                {\\n                    ans=dat;\\n                }\\n                dat=val;\\n            }\\n        }\\n        return dat;\\n    }\\n}\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\n    public long maxArrayValue(int[] nums) {\n        if(nums.length==1)\n        {\n            return (long)nums[0];\n        }\n        if(nums.length==2)\n        {\n            return nums[0] <= nums[1] ? (long)(nums[0]+nums[1]) : (long)(Math.max(nums[0],nums[1]));\n        }\n        int size=nums.length;\n        long ans=0,dat=(long)nums[size-1];\n        for(int i=size-2;i>=0;i--)\n        {\n            long val=(long)nums[i];\n            if(val<=dat)\n            {\n                dat=dat+val;\n                if(dat>ans)\n                {\n                    ans=dat;\n                }\n            }\n            else\n            {\n                if(dat>ans)\n                {\n                    ans=dat;\n                }\n                dat=val;\n            }\n        }\n        return calculateMax(dat);\n    }\n}\n",
        "explanations": "\nThe calculateMax(dat) method is called but never defined in the class Solution.\n"
    },
    {
        "slug": "count-and-say",
        "description": "The count-and-say sequence is a sequence of digit strings defined by the recursive formula:\n\ncountAndSay(1) = \"1\"\ncountAndSay(n) is the way you would \"say\" the digit string from countAndSay(n-1), which is then converted into a different digit string.\n\nTo determine how you \"say\" a digit string, split it into the minimal number of substrings such that each substring contains exactly one unique digit. Then for each substring, say the number of digits, then say the digit. Finally, concatenate every said digit.\nFor example, the saying and conversion for digit string \"3322251\":\n\nGiven a positive integer n, return the nth term of the count-and-say sequence.",
        "examples": [
            "Input: n = 1\nOutput: \"1\"\nExplanation: This is the base case.",
            "Input: n = 4\nOutput: \"1211\"\nExplanation:\ncountAndSay(1) = \"1\"\ncountAndSay(2) = say \"1\" = one 1 = \"11\"\ncountAndSay(3) = say \"11\" = two 1's = \"21\"\ncountAndSay(4) = say \"21\" = one 2 + one 1 = \"12\" + \"11\" = \"1211\""
        ],
        "constraints": "1 <= n <= 30",
        "release_time": 1666065881,
        "oracle_code": "class Solution {\n    String convert(String s)\n    {\n        char prevCh = s.charAt(0);\n        int prevCount = 1; //stores count of consecutive same digits\n        StringBuilder ans = new StringBuilder();\n        for (int i = 1; i < s.length(); i++)\n        {\n            char currCh = s.charAt(i);\n            if (currCh != prevCh)   \n            {\n                ans.append(Integer.toString(prevCount));\n                ans.append(prevCh);\n                prevCount = 1; //reset count\n                prevCh = currCh;\n            }\n            else prevCount++;\n        }\n        ans.append(Integer.toString(prevCount));\n        ans.append(prevCh);\n        return ans.toString();\n    }\n    public String countAndSay(int n) \n    {\n        String prevStr = \"1\";\n        for (int i = 2; i <= n; i++)\n        {\n            String cnsNum = convert(prevStr); //cns  = \"count and say Num\"\n            prevStr = cnsNum; //remember (dp) the previous built string\n        }\n        return prevStr;\n        \n        \n    }\n}",
        "content": "```\\nclass Solution {\\n    String convert(String s)\\n    {\\n        char prevCh = s.charAt(0);\\n        int prevCount = 1; //stores count of consecutive same digits\\n        StringBuilder ans = new StringBuilder();\\n        for (int i = 1; i < s.length(); i++)\\n        {\\n            char currCh = s.charAt(i);\\n            if (currCh != prevCh)   \\n            {\\n                ans.append(Integer.toString(prevCount));\\n                ans.append(prevCh);\\n                prevCount = 1; //reset count\\n                prevCh = currCh;\\n            }\\n            else prevCount++;\\n        }\\n        ans.append(Integer.toString(prevCount));\\n        ans.append(prevCh);\\n        return ans.toString();\\n    }\\n    public String countAndSay(int n) \\n    {\\n        String prevStr = \"1\";\\n        for (int i = 2; i <= n; i++)\\n        {\\n            String cnsNum = convert(prevStr); //cns  = \"count and say Num\"\\n            prevStr = cnsNum; //remember (dp) the previous built string\\n        }\\n        return prevStr;\\n        \\n        \\n    }\\n}\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution{\n    String convert(String s)\n    {\n        char prevCh = s.charAt(0);\n        int prevCount = 1; //stores count of consecutive same digits\n        StringBuilder ans = new StringBuilder();\n        for (int i = 1; i < s.length(); i++)\n        {\n            char currCh = s.charAt(i);\n            if (currCh != prevCh)   \n            {\n                ans.append(Integer.toString(prevCount));\n                ans.append(prevCh);\n                prevCount = 1; //reset count\n                prevCh = currCh;\n            }\n            else prevCount++;\n        }\n        ans.append(Integer.toString(prevCount));\n        ans.append(prevCh);\n        return ans.toString();\n    }\n    public String countAndSay(int n) \n    {\n        String prevStr = \"1\";\n        for (int i = 2; i <= n; i++)\n        {\n            String cnsNum = helperFunction(prevStr); \n            prevStr = cnsNum; //remember (dp) the previous built string\n        }\n        return prevStr;\n        \n        \n    }\n}\n",
        "explanations": "\nThe method helperFunction is not defined anywhere in the class which will raise an error.\n"
    },
    {
        "slug": "loud-and-rich",
        "description": "There is a group of n people labeled from 0 to n - 1 where each person has a different amount of money and a different level of quietness.\nYou are given an array richer where richer[i] = [ai, bi] indicates that ai has more money than bi and an integer array quiet where quiet[i] is the quietness of the ith person. All the given data in richer are logically correct (i.e., the data will not lead you to a situation where x is richer than y and y is richer than x at the same time).\nReturn an integer array answer where answer[x] = y if y is the least quiet person (that is, the person y with the smallest value of quiet[y]) among all people who definitely have equal to or more money than the person x.",
        "examples": [
            "Input: richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]], quiet = [3,2,5,4,6,1,7,0]\nOutput: [5,5,2,5,4,5,6,7]\nExplanation: \nanswer[0] = 5.\nPerson 5 has more money than 3, which has more money than 1, which has more money than 0.\nThe only person who is quieter (has lower quiet[x]) is person 7, but it is not clear if they have more money than person 0.\nanswer[7] = 7.\nAmong all people that definitely have equal to or more money than person 7 (which could be persons 3, 4, 5, 6, or 7), the person who is the quietest (has lower quiet[x]) is person 7.\nThe other answers can be filled out with similar reasoning.",
            "Input: richer = [], quiet = [0]\nOutput: [0]"
        ],
        "constraints": "n == quiet.length\n1 <= n <= 500\n0 <= quiet[i] < n\nAll the values of quiet are unique.\n0 <= richer.length <= n * (n - 1) / 2\n0 <= ai, bi < n\nai != bi\nAll the pairs of richer are unique.\nThe observations in richer are all logically consistent.",
        "release_time": 1670637012,
        "oracle_code": "class Solution {\n    int ans[];\n    Map<Integer,List<Integer>> map=new HashMap<>();\n    int temp[]=new int[0];\n    int curr_node=0;\n    List<Integer> vis=new ArrayList<Integer>();\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\n        \n        ans=new int[quiet.length];\n        for(int i=0;i<=richer.length;i++){\n            \n            if(!map.containsKey(i)){\n                map.put(i,new ArrayList());\n            }\n            if(i<richer.length && !map.containsKey(richer[i][0])){\n                map.put(richer[i][0],new ArrayList());\n                map.get(richer[i][0]).add(richer[i][1]);\n            }\n            else if(i<richer.length){\n                map.get(richer[i][0]).add(richer[i][1]);\n            }\n        }\n        \n        Comparator<pair> comp=new Comparator<pair>(){\n            public int compare(pair p1,pair p2){\n                if(p1.cost>p2.cost){\n                    return 1;\n                }\n                else{\n                    return -1;\n                }\n\n            }\n        };\n        PriorityQueue<pair> pq=new PriorityQueue<>(comp);\n        for(int i=0;i<quiet.length;i++){\n            ans[i]=-1;\n            pq.add(new pair(i,quiet[i]));\n        }\n        \n        while(!pq.isEmpty()){\n            pair top=pq.poll();\n            //System.out.println(top.node+\" \"+top.cost);\n            curr_node=top.node;\n            if(!vis.contains(top.node)){\n            dfs(top.node);\n            }\n        }\n        return ans;\n       \n    }\n    public void dfs(int node){\n        //System.out.println(node);\n        if(ans[node]==-1){\n            ans[node]=curr_node;\n        }\n        if(!vis.contains(node) && map.containsKey(node)){\n            vis.add(node);\n             \n            for(int i : map.get(node)){\n            dfs(i);\n        \n        }\n        }\n            \n    }\n}\n\nclass pair{\n    int node,cost;\n    pair(int node,int cost){\n        this.node=node;\n        this.cost=cost;\n    }\n}",
        "content": "\\n# Code\\n```\\nclass Solution {\\n    int ans[];\\n    Map<Integer,List<Integer>> map=new HashMap<>();\\n    int temp[]=new int[0];\\n    int curr_node=0;\\n    List<Integer> vis=new ArrayList<Integer>();\\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\\n        \\n        ans=new int[quiet.length];\\n        for(int i=0;i<=richer.length;i++){\\n            \\n            if(!map.containsKey(i)){\\n                map.put(i,new ArrayList());\\n            }\\n            if(i<richer.length && !map.containsKey(richer[i][0])){\\n                map.put(richer[i][0],new ArrayList());\\n                map.get(richer[i][0]).add(richer[i][1]);\\n            }\\n            else if(i<richer.length){\\n                map.get(richer[i][0]).add(richer[i][1]);\\n            }\\n        }\\n        \\n        Comparator<pair> comp=new Comparator<pair>(){\\n            public int compare(pair p1,pair p2){\\n                if(p1.cost>p2.cost){\\n                    return 1;\\n                }\\n                else{\\n                    return -1;\\n                }\\n\\n            }\\n        };\\n        PriorityQueue<pair> pq=new PriorityQueue<>(comp);\\n        for(int i=0;i<quiet.length;i++){\\n            ans[i]=-1;\\n            pq.add(new pair(i,quiet[i]));\\n        }\\n        \\n        while(!pq.isEmpty()){\\n            pair top=pq.poll();\\n            //System.out.println(top.node+\" \"+top.cost);\\n            curr_node=top.node;\\n            if(!vis.contains(top.node)){\\n            dfs(top.node);\\n            }\\n        }\\n        return ans;\\n       \\n    }\\n    public void dfs(int node){\\n        //System.out.println(node);\\n        if(ans[node]==-1){\\n            ans[node]=curr_node;\\n        }\\n        if(!vis.contains(node) && map.containsKey(node)){\\n            vis.add(node);\\n             \\n            for(int i : map.get(node)){\\n            dfs(i);\\n        \\n        }\\n        }\\n            \\n    }\\n}\\n\\nclass pair{\\n    int node,cost;\\n    pair(int node,int cost){\\n        this.node=node;\\n        this.cost=cost;\\n    }\\n}\\n\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\n    int ans[];\n    Map<Integer,List<Integer>> map=new HashMap<>();\n    int temp[]=new int[0];\n    int curr_node=0;\n    List<Integer> vis=new ArrayList<Integer>();\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\n        \n        ans=new int[quiet.length];\n        for(int i=0;i<=richer.length;i++){\n            \n            if(!map.containsKey(i)){\n                map.put(i,new ArrayList());\n            }\n            if(i<richer.length && !map.containsKey(richer[i][0])){\n                map.put(richer[i][0],new ArrayList());\n                map.get(richer[i][0]).add(richer[i][1]);\n            }\n            else if(i<richer.length){\n                map.get(richer[i][0]).add(richer[i][1]);\n            }\n        }\n        \n        Comparator<pair> comp=new Comparator<pair>(){\n            public int compare(pair p1,pair p2){\n                if(p1.cost>p2.cost){\n                    return 1;\n                }\n                else{\n                    return -1;\n                }\n\n            }\n        };\n        PriorityQueue<pair> pq=new PriorityQueue<>(comp);\n        for(int i=0;i<quiet.length;i++){\n            ans[i]=-1;\n            pq.add(new pair(i,quiet[i]));\n        }\n        \n        while(!pq.isEmpty()){\n            pair top=pq.poll();\n            //System.out.println(top.node+\" \"+top.cost);\n            curr_node=top.node;\n            if(!vis.contains(top.node)){\n            dfs(top.node);\n            }\n        }\n        return ans;\n       \n    }\n    public void dfs(int node, int value){\n        //System.out.println(node);\n        if(ans[node]==-1){\n            ans[node]=curr_node;\n        }\n        if(!vis.contains(node) && map.containsKey(node)){\n            vis.add(node);\n             \n            for(int i : map.get(node)){\n            dfs(i, value);\n        \n        }\n        }\n            \n    }\n}\n\nclass pair{\n    int node,cost;\n    pair(int node,int cost){\n        this.node=node;\n        this.cost=cost;\n    }\n}\n",
        "explanations": "\nUndefined method bug: dfs method is called with two arguments while it is defined with one.\n"
    },
    {
        "slug": "count-negative-numbers-in-a-sorted-matrix",
        "description": "Given a m x n matrix grid which is sorted in non-increasing order both row-wise and column-wise, return the number of negative numbers in grid.",
        "examples": [
            "Input: grid = [[4,3,2,-1],[3,2,1,-1],[1,1,-1,-2],[-1,-1,-2,-3]]\nOutput: 8\nExplanation: There are 8 negatives number in the matrix.",
            "Input: grid = [[3,2],[1,0]]\nOutput: 0"
        ],
        "constraints": "m == grid.length\nn == grid[i].length\n1 <= m, n <= 100\n-100 <= grid[i][j] <= 100",
        "release_time": 1686193447,
        "oracle_code": "class Solution:\n    def countNegatives(self, grid: List[List[int]]) -> int:\n        ROWS, COLS = len(grid), len(grid[0])\n        negatives = 0\n        col = 0\n        for row in range(ROWS - 1, -1, -1):\n            while col < COLS and grid[row][col] >= 0:\n                col += 1\n            negatives += COLS - col\n        return negatives",
        "content": "# Intuition\\nThe key idea is to take advantage of the sorted nature of the matrix, where both the rows and columns are sorted in non-increasing order. This means that once we find a negative number in a row, all the following numbers in that row will also be negative. Similarly, if a cell at the top of a column is negative, all the cells below it in that column will also be negative.\\n\\n# Approach\\nNegative numbers will form a staircase. So we start from the bottom-left, and follow along the staircase. For each row, we find the edge of the staircase, add all the count of elements to the right to the answer, and then move up a row and repeat.\\n\\n# Complexity\\n- Time complexity: O(m + n) - We visit each row and column at most once.\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def countNegatives(self, grid: List[List[int]]) -> int:\\n        ROWS, COLS = len(grid), len(grid[0])\\n        negatives = 0\\n        col = 0\\n        for row in range(ROWS - 1, -1, -1):\\n            while col < COLS and grid[row][col] >= 0:\\n                col += 1\\n            negatives += COLS - col\\n        return negatives\\n\\n```\\n\\n# Get Faster Interview Prep Results with Top Algos\\nWe all know how time-consuming it is to prepare for interviews and how frustratingly difficult it is to improve. We made **Top Algos** - a tool recommends the perfect algorithm problem based on your current skill level to help you improve the fastest in the shortest amount of time. Top Algos is your personalized coach that learns your skill level and finds the best problem you need to solve to improve.\\n\\nThe beta version of the product is available for **free** right now! You can sign up at https://topalgos.xyz/.",
        "level": "easy",
        "buggy_code": "\nclass Solution:\n    def countNegatives(self, grid: List[List[int]]) -> int:\n        ROWS, COLS = len(grid), len(grid[0])\n        negatives = 0\n        col = 0\n        for row in range(ROWS - 1, -1, -1):\n            while col < COLS and grid[row][col] >= 0:\n                col += 1\n            negatives += COLS - col\n        return negatives\n\n    def undefinedMethod(self):\n        self.countPositives(grid)\n",
        "explanations": "\ncountPositives() method is called but it is not defined anywhere in the code.\n"
    },
    {
        "slug": "valid-triangle-number",
        "description": "Given an integer array nums, return the number of triplets chosen from the array that can make triangles if we take them as side lengths of a triangle.",
        "examples": [
            "Input: nums = [2,2,3,4]\nOutput: 3\nExplanation: Valid combinations are: \n2,3,4 (using the first 2)\n2,3,4 (using the second 2)\n2,2,3",
            "Input: nums = [4,2,3,4]\nOutput: 4"
        ],
        "constraints": "1 <= nums.length <= 1000\n0 <= nums[i] <= 1000",
        "release_time": 1689855211,
        "oracle_code": "class Solution {\n    public int triangleNumber(int[] nums) {\n        int n=nums.length;\n        Arrays.sort(nums);\n        int count=0;\n        for(int c=n-1;c>=2;c--){\n            int a=0;\n            int b=c-1;\n            while(a<b){\n                if(nums[a]+nums[b]>nums[c]){\n                    count+=(b-a);\n                    b--;\n                }\n                else{\n                    a++;\n                }\n            }\n        }\n        return count;\n        \n    }\n}",
        "content": "# Intuition\\nFor right angled triangle, it should satisfy following 3 conditions (a,b and c are sides of triangle)\\na+b>c\\na+c>b\\nb+c>a\\n\\nSuppose c>a+b then 2nd and 3rd condition is going to satisfy automatically so always keep the c at index with value greater than a and b\\n\\n# Approach\\nSteps:\\n1.Sort the array in increasing order\\n2.After sorting ,initially c as n-1 (intially as loop will be going for c from n-1 to 2 as at last c can be at 2nd, b at 1st and a at 0th index. \\n  b=c-1 , a=0\\n  (Keeping c at fixed index, we will be moving a and b in order to satisfy the condition a+b>c) .\\n3.while(a<b) \\n  check the nums[a] + nums[b] > nums[c] , \\n  if this exists then \\n    -for all the values after the nums[left],the condition nums[a] + nums[b] > nums[c] is going to satisfy, store (b-a) count in ans\\n    -decrement b\\n  else\\n    -increment a as we need to maximize sum so that it becoms greater than nums[c]\\n4.return ans\\n\\n\\n# Complexity\\n- Time complexity: O(N2)\\n- Space complexity:O(1)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int triangleNumber(int[] nums) {\\n        int n=nums.length;\\n        Arrays.sort(nums);\\n        int count=0;\\n        for(int c=n-1;c>=2;c--){\\n            int a=0;\\n            int b=c-1;\\n            while(a<b){\\n                if(nums[a]+nums[b]>nums[c]){\\n                    count+=(b-a);\\n                    b--;\\n                }\\n                else{\\n                    a++;\\n                }\\n            }\\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\n    public int triangleNumber(int[] nums) {\n        int n=nums.length;\n        ArrayUtils.sort(nums);\n        int count=0;\n        for(int c=n-1;c>=2;c--){\n            int a=0;\n            int b=c-1;\n            while(a<b){\n                if(nums[a]+nums[b]>nums[c]){\n                    count+=(b-a);\n                    b--;\n                }\n                else{\n                    a++;\n                }\n            }\n        }\n        return count;\n        \n    }\n}\n",
        "explanations": "\nCalling non-existing method \"ArrayUtils.sort(nums)\" leads to undefined method error.\n"
    },
    {
        "slug": "spiral-matrix-iv",
        "description": "You are given two integers m and n, which represent the dimensions of a matrix.\nYou are also given the head of a linked list of integers.\nGenerate an m x n matrix that contains the integers in the linked list presented in spiral order (clockwise), starting from the top-left of the matrix. If there are remaining empty spaces, fill them with -1.\nReturn the generated matrix.",
        "examples": [
            "Input: m = 3, n = 5, head = [3,0,2,6,8,1,7,9,4,2,5,5,0]\nOutput: [[3,0,2,6,8],[5,0,-1,-1,1],[5,2,4,9,7]]\nExplanation: The diagram above shows how the values are printed in the matrix.\nNote that the remaining spaces in the matrix are filled with -1.",
            "Input: m = 1, n = 4, head = [0,1,2]\nOutput: [[0,1,2,-1]]\nExplanation: The diagram above shows how the values are printed from left to right in the matrix.\nThe last space in the matrix is set to -1."
        ],
        "constraints": "1 <= m, n <= 105\n1 <= m * n <= 105\nThe number of nodes in the list is in the range [1, m * n].\n0 <= Node.val <= 1000",
        "release_time": 1675959781,
        "oracle_code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:\n        mat=[[-1 for i in range(n)] for i in range(m)]\n        temp=head\n        d=1\n        rowi,colj=0,0\n        while temp!=None:\n            mat[rowi][colj]=temp.val\n            if d==1:\n                if colj+1<n and mat[rowi][colj+1]==-1:\n                    colj+=1\n                    d=1\n                elif rowi+1<m and mat[rowi+1][colj]==-1:\n                    rowi+=1\n                    d=2\n            elif d==2:\n                if rowi+1<m and mat[rowi+1][colj]==-1:\n                    rowi+=1\n                    d=2\n                elif colj-1>=0 and mat[rowi][colj-1]==-1:\n                    colj-=1\n                    d=3\n            elif d==3:\n                if colj-1>=0 and mat[rowi][colj-1]==-1:\n                    colj-=1\n                    d=3\n                elif rowi-1>=0 and mat[rowi-1][colj]==-1:\n                    rowi-=1\n                    d=4\n            elif d==4:\n                if rowi-1>=0 and mat[rowi-1][colj]==-1:\n                    rowi-=1\n                    d=4\n                elif colj+1<n and mat[rowi][colj+1]==-1:\n                    colj+=1\n                    d=1\n            temp=temp.next\n        return mat",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nfollow up direction : right -> down -> left -> up\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ncreating a matrix m*n fillup with -1 and traverse throgh list and make update directions according to current directions and values of before cells\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n     O(N) (no of Nodes in linkedlist)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(N+M)\\n\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:\\n        mat=[[-1 for i in range(n)] for i in range(m)]\\n        temp=head\\n        d=1\\n        rowi,colj=0,0\\n        while temp!=None:\\n            mat[rowi][colj]=temp.val\\n            if d==1:\\n                if colj+1<n and mat[rowi][colj+1]==-1:\\n                    colj+=1\\n                    d=1\\n                elif rowi+1<m and mat[rowi+1][colj]==-1:\\n                    rowi+=1\\n                    d=2\\n            elif d==2:\\n                if rowi+1<m and mat[rowi+1][colj]==-1:\\n                    rowi+=1\\n                    d=2\\n                elif colj-1>=0 and mat[rowi][colj-1]==-1:\\n                    colj-=1\\n                    d=3\\n            elif d==3:\\n                if colj-1>=0 and mat[rowi][colj-1]==-1:\\n                    colj-=1\\n                    d=3\\n                elif rowi-1>=0 and mat[rowi-1][colj]==-1:\\n                    rowi-=1\\n                    d=4\\n            elif d==4:\\n                if rowi-1>=0 and mat[rowi-1][colj]==-1:\\n                    rowi-=1\\n                    d=4\\n                elif colj+1<n and mat[rowi][colj+1]==-1:\\n                    colj+=1\\n                    d=1\\n            temp=temp.next\\n        return mat\\n\\n\\n```",
        "level": "medium",
        "buggy_code": "\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:\n        mat=[[-1 for i in range(n)] for i in range(m)]\n        temp=head\n        d=1\n        rowi,colj=0,0\n        while temp!=None:\n            mat[rowi][colj]=temp.val\n            if d==1:\n                if colj+1<n and mat[rowi][colj+1]==-1:\n                    colj+=1\n                    d=1\n                elif rowi+1<m and mat[rowi+1][colj]==-1:\n                    rowi+=1\n                    d=2\n            elif d==2:\n                if rowi+1<m and mat[rowi+1][colj]==-1:\n                    rowi+=1\n                    d=2\n                elif colj-1>=0 and mat[rowi][colj-1]==-1:\n                    colj-=1\n                    d=3\n            elif d==3:\n                if colj-1>=0 and mat[rowi][colj-1]==-1:\n                    colj-=1\n                    d=3\n                elif rowi-1>=0 and mat[rowi-1][colj]==-1:\n                    rowi-=1\n                    d=uppercaseLetter\n            elif d==4:\n                if rowi-1>=0 and mat[rowi-1][colj]==-1:\n                    rowi-=1\n                    d=4\n                elif colj+1<n and mat[rowi][colj+1]==-1:\n                    colj+=1\n                    d=1\n            temp=usingUndefinedMethod\n        return mat\n",
        "explanations": "\nThe variables \"uppercaseLetter\" and \"usingUndefinedMethod\" are undefined, leading to NameError.\n"
    },
    {
        "slug": "design-a-stack-with-increment-operation",
        "description": "Design a stack that supports increment operations on its elements.\nImplement the CustomStack class:\n\nCustomStack(int maxSize) Initializes the object with maxSize which is the maximum number of elements in the stack.\nvoid push(int x) Adds x to the top of the stack if the stack has not reached the maxSize.\nint pop() Pops and returns the top of the stack or -1 if the stack is empty.\nvoid inc(int k, int val) Increments the bottom k elements of the stack by val. If there are less than k elements in the stack, increment all the elements in the stack.",
        "examples": [
            "Input\n[\"CustomStack\",\"push\",\"push\",\"pop\",\"push\",\"push\",\"push\",\"increment\",\"increment\",\"pop\",\"pop\",\"pop\",\"pop\"]\n[[3],[1],[2],[],[2],[3],[4],[5,100],[2,100],[],[],[],[]]\nOutput\n[null,null,null,2,null,null,null,null,null,103,202,201,-1]\nExplanation\nCustomStack stk = new CustomStack(3); // Stack is Empty []\nstk.push(1);                          // stack becomes [1]\nstk.push(2);                          // stack becomes [1, 2]\nstk.pop();                            // return 2 --> Return top of the stack 2, stack becomes [1]\nstk.push(2);                          // stack becomes [1, 2]\nstk.push(3);                          // stack becomes [1, 2, 3]\nstk.push(4);                          // stack still [1, 2, 3], Do not add another elements as size is 4\nstk.increment(5, 100);                // stack becomes [101, 102, 103]\nstk.increment(2, 100);                // stack becomes [201, 202, 103]\nstk.pop();                            // return 103 --> Return top of the stack 103, stack becomes [201, 202]\nstk.pop();                            // return 202 --> Return top of the stack 202, stack becomes [201]\nstk.pop();                            // return 201 --> Return top of the stack 201, stack becomes []\nstk.pop();                            // return -1 --> Stack is empty return -1."
        ],
        "constraints": "1 <= maxSize, x, k <= 1000\n0 <= val <= 100\nAt most 1000 calls will be made to each method of increment, push and pop each separately.",
        "release_time": 1674461680,
        "oracle_code": "class CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.arr = []\n        self.m = maxSize\n        self.top = -1\n\n    def push(self, x: int) -> None:\n        if self.top < self.m - 1:\n            self.arr.append(x)\n            self.top += 1\n\n    def pop(self) -> int:\n        if self.top == -1: return -1\n        self.top -= 1\n        return(self.arr.pop(-1))\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(min(k, self.top + 1)): self.arr[i] += val",
        "content": "# Upvote it :)\\n```\\nclass CustomStack:\\n\\n    def __init__(self, maxSize: int):\\n        self.arr = []\\n        self.m = maxSize\\n        self.top = -1\\n\\n    def push(self, x: int) -> None:\\n        if self.top < self.m - 1:\\n            self.arr.append(x)\\n            self.top += 1\\n\\n    def pop(self) -> int:\\n        if self.top == -1: return -1\\n        self.top -= 1\\n        return(self.arr.pop(-1))\\n\\n    def increment(self, k: int, val: int) -> None:\\n        for i in range(min(k, self.top + 1)): self.arr[i] += val\\n```",
        "level": "medium",
        "buggy_code": "\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.arr = []\n        self.m = maxSize\n        self.top = -1\n\n    def push(self, x: int) -> None:\n        if self.top < self.m - 1:\n            self.arr.append(x)\n            self.top += 1\n\n    def pop(self) -> int:\n        if self.top == -1: return -1\n        self.top -= 1\n        return(self.arr.pop(-1))\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(min(k, self.top + 1)): self.arr[i] += val\n\n    def printStack(self) -> None:\n        print(self.arr)\n        \nstack = CustomStack(3)\nstack.push(1)\nstack.push(2)\nstack.push(3)\nstack.pop()\nstack.empty()\n",
        "explanations": "\nThe method 'empty' is called on the 'stack' instance but it's not defined in class.\n"
    },
    {
        "slug": "can-make-arithmetic-progression-from-sequence",
        "description": "A sequence of numbers is called an arithmetic progression if the difference between any two consecutive elements is the same.\nGiven an array of numbers arr, return true if the array can be rearranged to form an arithmetic progression. Otherwise, return false.",
        "examples": [
            "Input: arr = [3,5,1]\nOutput: true\nExplanation: We can reorder the elements as [1,3,5] or [5,3,1] with differences 2 and -2 respectively, between each consecutive elements.",
            "Input: arr = [1,2,4]\nOutput: false\nExplanation: There is no way to reorder the elements to obtain an arithmetic progression."
        ],
        "constraints": "2 <= arr.length <= 1000\n-106 <= arr[i] <= 106",
        "release_time": 1686057547,
        "oracle_code": "class Solution {\n    public boolean canMakeArithmeticProgression(int[] arr) {\n        Arrays.sort(arr);\n        int diff=arr[1]-arr[0];\n        boolean temp=true;\n        for(int i=1;i<arr.length-1;i++){\n            if(arr[i+1]-arr[i]==diff){\n                continue;\n            }else{\n                temp=false;\n            }\n        }\n        if(temp==true){\n            return true;\n        }else{\n            return false;\n        }\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe given code is an implementation of a method named canMakeArithmeticProgression, which determines whether the given array arr can be rearranged to form an arithmetic progression.\\n\\nHere\\'s how the code works:\\n\\nThe arr array is sorted using the Arrays.sort() method. Sorting the array is important because in an arithmetic progression, the elements are arranged in a specific order.\\n\\nThe variable diff is initialized as the difference between the second element (arr[1]) and the first element (arr[0]). This will be the common difference for the arithmetic progression.\\n\\nThe variable temp is set to true. It will be used to keep track of whether all the adjacent element differences match the common difference.\\n\\nA loop iterates from the second element (i=1) to the second-to-last element (i<arr.length-1). This loop compares the difference between the current element (arr[i+1]) and the previous element (arr[i]) with the common difference (diff).\\n\\nIf the difference between the current and previous elements matches the common difference, the loop continues to the next iteration using the continue statement.\\n\\nIf the difference does not match the common difference, temp is set to false, indicating that the array cannot form an arithmetic progression.\\n\\nFinally, after the loop, the value of temp is checked. If it is still true, the method returns true indicating that the array can form an arithmetic progression. Otherwise, it returns false.\\n\\nIn summary, the code checks if the given array can be sorted into an arithmetic progression by comparing the differences between adjacent elements. If all the differences match the common difference, it returns true; otherwise, it returns false.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach used in the given code can be summarized as follows:\\n\\nSort the array in ascending order using the Arrays.sort() method. Sorting the array helps in identifying the order of the elements in an arithmetic progression.\\n\\nCalculate the common difference (diff) between the second element (arr[1]) and the first element (arr[0]).\\n\\nIterate through the array starting from the second element (i=1) up to the second-to-last element (i<arr.length-1).\\n\\nFor each iteration, check if the difference between the current element (arr[i+1]) and the previous element (arr[i]) is equal to the common difference (diff).\\n\\nIf the difference matches, continue to the next iteration.\\n\\nIf the difference does not match, set the temp variable to false, indicating that the array cannot form an arithmetic progression.\\n\\nAfter the loop, check the value of the temp variable. If it is still true, return true to indicate that the array can form an arithmetic progression. Otherwise, return false.\\n\\nIn summary, the code checks if the given array can be rearranged to form an arithmetic progression by comparing the differences between adjacent elements. If all the differences match the common difference, the code returns true; otherwise, it returns false.\\n\\n# Complexity\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean canMakeArithmeticProgression(int[] arr) {\\n        Arrays.sort(arr);\\n        int diff=arr[1]-arr[0];\\n        boolean temp=true;\\n        for(int i=1;i<arr.length-1;i++){\\n            if(arr[i+1]-arr[i]==diff){\\n                continue;\\n            }else{\\n                temp=false;\\n            }\\n        }\\n        if(temp==true){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }\\n}\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\n    public boolean canMakeArithmeticProgression(int[] arr) {\n        Arrays.sort(arr);\n        int diff=arr[1]-arr[0];\n        boolean temp=true;\n        for(int i=1;i<arr.length-1;i++){\n            if(arr[i+1]-arr[i]==diff){\n                continue;\n            }else{\n                temp=false;\n            }\n        }\n        if(temp==true){\n            return true;\n        }else{\n            checkProgression(arr);\n            return false;\n        }\n    }\n    \n    public void checkProgression(int[] arr) {\n        int diff = arr[1] - arr[0];\n        \n        for(int i = 1; i < arr.length - 1; i++) {\n            if(arr[i+1] - arr[i] != diff) {\n                return false;\n            }\n        }\n        \n        return true;\n    }\n}\n",
        "explanations": "\nThe return type of checkProgression method is void, It should be boolean.\n"
    },
    {
        "slug": "minimize-the-maximum-difference-of-pairs",
        "description": "You are given a 0-indexed integer array nums and an integer p. Find p pairs of indices of nums such that the maximum difference amongst all the pairs is minimized. Also, ensure no index appears more than once amongst the p pairs.\nNote that for a pair of elements at the index i and j, the difference of this pair is |nums[i] - nums[j]|, where |x| represents the absolute value of x.\nReturn the minimum maximum difference among all p pairs. We define the maximum of an empty set to be zero.",
        "examples": [
            "Input: nums = [10,1,2,7,1,3], p = 2\nOutput: 1\nExplanation: The first pair is formed from the indices 1 and 4, and the second pair is formed from the indices 2 and 5. \nThe maximum difference is max(|nums[1] - nums[4]|, |nums[2] - nums[5]|) = max(0, 1) = 1. Therefore, we return 1.",
            "Input: nums = [4,2,1,2], p = 1\nOutput: 0\nExplanation: Let the indices 1 and 3 form a pair. The difference of that pair is |2 - 2| = 0, which is the minimum we can attain."
        ],
        "constraints": "1 <= nums.length <= 105\n0 <= nums[i] <= 109\n0 <= p <= (nums.length)/2",
        "release_time": 1691551599,
        "oracle_code": "class Solution {\n    public int minimizeMax(int[] A, int p) {\n        int n = A.length;\n        Arrays.sort(A);\n        int l = 0;\n        int r = A[n-1]-A[0];\n        int mid;\n        while(l<r){\n            mid = (l+r)/2;\n            if(helper(A, mid, p)>=p) r = mid;\n            else l = mid +1;\n        }\n        return l;\n    }\n    \n    public int helper(int [] A, int diff, int p){\n        int i = 1; int count = 0;\n        while(i<A.length){\n            if(A[i]-A[i-1]<=diff){\n                i++;\n                count++;\n            }\n            i++;\n        }\n        return count;\n    }\n}",
        "content": "<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/kvEVrnNuIUc\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen></iframe>\\n\\n```\\nclass Solution {\\n    public int minimizeMax(int[] A, int p) {\\n        int n = A.length;\\n        Arrays.sort(A);\\n        int l = 0;\\n        int r = A[n-1]-A[0];\\n        int mid;\\n        while(l<r){\\n            mid = (l+r)/2;\\n            if(helper(A, mid, p)>=p) r = mid;\\n            else l = mid +1;\\n        }\\n        return l;\\n    }\\n    \\n    public int helper(int [] A, int diff, int p){\\n        int i = 1; int count = 0;\\n        while(i<A.length){\\n            if(A[i]-A[i-1]<=diff){\\n                i++;\\n                count++;\\n            }\\n            i++;\\n        }\\n        return count;\\n    }\\n}\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    int minimizeMax(vector<int>& A, int p) {\\n        int n = A.size();\\n        sort(A.begin(), A.end());\\n        int l = 0;\\n        int r = A[n - 1] - A[0];\\n        int mid;\\n        while (l < r) {\\n            mid = (l + r) / 2;\\n            if (helper(A, mid, p) >= p) {\\n                r = mid;\\n            } else {\\n                l = mid + 1;\\n            }\\n        }\\n        return l;\\n    }\\n\\n    int helper(vector<int>& A, int diff, int p) {\\n        int i = 1, count = 0;\\n        while (i < A.size()) {\\n            if (A[i] - A[i - 1] <= diff) {\\n                i++;\\n                count++;\\n            }\\n            i++;\\n        }\\n        return count;\\n    }\\n};\\n```\\n\\n```\\nclass Solution:\\n    def minimizeMax(self, A: List[int], p: int) -> int:\\n        n = len(A)\\n        A.sort()\\n        l, r = 0, A[n - 1] - A[0]\\n        while l < r:\\n            mid = (l + r) // 2\\n            if self.helper(A, mid, p) >= p:\\n                r = mid\\n            else:\\n                l = mid + 1\\n        return l\\n    \\n    def helper(self, A: List[int], diff: int, p: int) -> int:\\n        i, count = 1, 0\\n        while i < len(A):\\n            if A[i] - A[i - 1] <= diff:\\n                i += 1\\n                count += 1\\n            i += 1\\n        return count\\n\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\n    public int minimizeMax(int[] A, int p) {\n        int n = A.length;\n        Arrays.sort(A);\n        int l = 0;\n        int r = A[n-1]-A[0];\n        int mid;\n        while(l<r){\n            mid = (l+r)/2;\n          if(canDistribute(A, mid, p)>=p) r = mid;\n            else l = mid +1;\n        }\n        return l;\n    }\n    \n    public int helper(int [] A, int diff, int p){\n        int i = 1; int count = 0;\n        while(i<A.length){\n            if(A[i]-A[i-1]<=diff){\n                i++;\n                count++;\n            }\n            i++;\n        }\n        return count;\n    }\n}\n",
        "explanations": "\nThe method \"canDistribute\" is called but it is undefined in the Solution class.\n"
    },
    {
        "slug": "add-edges-to-make-degrees-of-all-nodes-even",
        "description": "There is an undirected graph consisting of n nodes numbered from 1 to n. You are given the integer n and a 2D array edges where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi. The graph can be disconnected.\nYou can add at most two additional edges (possibly none) to this graph so that there are no repeated edges and no self-loops.\nReturn true if it is possible to make the degree of each node in the graph even, otherwise return false.\nThe degree of a node is the number of edges connected to it.",
        "examples": [
            "Input: n = 5, edges = [[1,2],[2,3],[3,4],[4,2],[1,4],[2,5]]\nOutput: true\nExplanation: The above diagram shows a valid way of adding an edge.\nEvery node in the resulting graph is connected to an even number of edges.",
            "Input: n = 4, edges = [[1,2],[3,4]]\nOutput: true\nExplanation: The above diagram shows a valid way of adding two edges.",
            "Input: n = 4, edges = [[1,2],[1,3],[1,4]]\nOutput: false\nExplanation: It is not possible to obtain a valid graph with adding at most 2 edges."
        ],
        "constraints": "3 <= n <= 105\n2 <= edges.length <= 105\nedges[i].length == 2\n1 <= ai, bi <= n\nai != bi\nThere are no repeated edges.",
        "release_time": 1671336101,
        "oracle_code": "class Solution:\n    def isPossible(self, n: int, edges: List[List[int]]) -> bool:\n        graph = defaultdict(set)\n        for a, b in edges:\n            graph[a].add(b)\n            graph[b].add(a)\n        odds = [a for a in graph if len(graph[a]) % 2 == 1]\n        if not odds:\n            return True\n        elif len(odds) > 4 or len(odds) == 1 or len(odds) == 3:\n            return False\n        elif len(odds) == 2:\n            a, b = odds[0], odds[1]\n            if a not in graph[b]:\n                return True\n            for i in range(1, n + 1):\n                if i not in graph[a] and i not in graph[b]:\n                    return True\n            return False\n        else:\n            a, b, c, d = odds[0], odds[1], odds[2], odds[3]\n            if a not in graph[b] and c not in graph[d]:\n                return True\n            if a not in graph[c] and b not in graph[d]:\n                return True\n            if a not in graph[d] and b not in graph[c]:\n                return True\n            return False",
        "content": "**Observation**\\nThe key is to note that we can add **at most** two additional edges (possibly none) to the graph.\\n\\n**Implementation**\\nStep 1: Build the graph by going through all edges.\\nStep 2: Find every node with an odd degree.\\nStep 3: Consider each of the case where the number of the nodes with an odd degree is 0, 1, 2, 3, 4, and > 4.\\n\\n**Solution**\\n```\\nclass Solution:\\n    def isPossible(self, n: int, edges: List[List[int]]) -> bool:\\n        graph = defaultdict(set)\\n        for a, b in edges:\\n            graph[a].add(b)\\n            graph[b].add(a)\\n        odds = [a for a in graph if len(graph[a]) % 2 == 1]\\n        if not odds:\\n            return True\\n        elif len(odds) > 4 or len(odds) == 1 or len(odds) == 3:\\n            return False\\n        elif len(odds) == 2:\\n            a, b = odds[0], odds[1]\\n            if a not in graph[b]:\\n                return True\\n            for i in range(1, n + 1):\\n                if i not in graph[a] and i not in graph[b]:\\n                    return True\\n            return False\\n        else:\\n            a, b, c, d = odds[0], odds[1], odds[2], odds[3]\\n            if a not in graph[b] and c not in graph[d]:\\n                return True\\n            if a not in graph[c] and b not in graph[d]:\\n                return True\\n            if a not in graph[d] and b not in graph[c]:\\n                return True\\n            return False\\n```",
        "level": "hard",
        "buggy_code": "\nclass Solution:\n    def isPossible(self, n: int, edges: List[List[int]]) -> bool:\n        graph = defaultdict(set)\n        for a, b in edges:\n            graph[a].add(b)\n            graph[b].add(a)\n        odds = [a for a in graph if len(graph[a]) % 2 == 1]\n        if not odds:\n            return True\n        elif len(odds) > 4 or len(odds) == 1 or len(odds) == 3:\n            return False\n        elif len(odds) == 2:\n            a, b = odds[0], odds[1]\n            if a not in graph[b]:\n                return self.isEulerian(a,b)\n            for i in range(1, n + 1):\n                if i not in graph[a] and i not in graph[b]:\n                    return True\n            return False\n        else:\n            a, b, c, d = odds[0], odds[1], odds[2], odds[3]\n            if a not in graph[b] and c not in graph[d]:\n                return self.isEulerian(a,b)\n            if a not in graph[c] and b not in graph[d]:\n                return self.isEulerian(a,b)\n            if a not in graph[d] and b not in graph[c]:\n                return self.isEulerian(a,b)\n            return False\n",
        "explanations": "\nThe bug is calling the undefined function \"isEulerian(a,b)\" which will throw a runtime error.\n"
    },
    {
        "slug": "sort-even-and-odd-indices-independently",
        "description": "You are given a 0-indexed integer array nums. Rearrange the values of nums according to the following rules:\n\nSort the values at odd indices of nums in non-increasing order.\n\n\t\nFor example, if nums = [4,1,2,3] before this step, it becomes [4,3,2,1] after. The values at odd indices 1 and 3 are sorted in non-increasing order.\n\n\nSort the values at even indices of nums in non-decreasing order.\n\t\nFor example, if nums = [4,1,2,3] before this step, it becomes [2,1,4,3] after. The values at even indices 0 and 2 are sorted in non-decreasing order.\n\n\n\nReturn the array formed after rearranging the values of nums.",
        "examples": [
            "Input: nums = [4,1,2,3]\nOutput: [2,3,4,1]\nExplanation: \nFirst, we sort the values present at odd indices (1 and 3) in non-increasing order.\nSo, nums changes from [4,1,2,3] to [4,3,2,1].\nNext, we sort the values present at even indices (0 and 2) in non-decreasing order.\nSo, nums changes from [4,1,2,3] to [2,3,4,1].\nThus, the array formed after rearranging the values is [2,3,4,1].",
            "Input: nums = [2,1]\nOutput: [2,1]\nExplanation: \nSince there is exactly one odd index and one even index, no rearrangement of values takes place.\nThe resultant array formed is [2,1], which is the same as the initial array."
        ],
        "constraints": "1 <= nums.length <= 100\n1 <= nums[i] <= 100",
        "release_time": 1678770695,
        "oracle_code": "class Solution {\n    public int[] sortEvenOdd(int[] nums) {\n        PriorityQueue<Integer> queue = new PriorityQueue<>();\n        for(int i=0;i<nums.length;i+=2){\n            queue.add(nums[i]);\n        }\n        for(int i=0;i<nums.length;i+=2){\n            nums[i]=queue.poll();\n        }\n        queue = new PriorityQueue<>(new MaxHeap());\n        for(int i=1;i<nums.length;i+=2){\n            queue.add(nums[i]);\n        }\n        for(int i=1;i<nums.length;i+=2){\n            nums[i]=queue.poll();\n        }\n        return nums;\n    }\n}\nclass MaxHeap implements Comparator<Integer>{\n    public int compare(Integer ca,Integer cb){\n        return cb-ca;\n    }\n}",
        "content": "\\n> # Approach\\nLet\\'s use some data structutes to solve this problem,By adding even indexed numbers into MinHeap we can sort the data in ascending order,By adding odd indexed numbers into Maxheap we can sort the data in descending order. \\n<!-- Describe your approach to solving the problem. -->\\n\\n> # Complexity\\n- Time complexity: O(n log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) for Priority Queue\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n> # Code\\n```\\nclass Solution {\\n    public int[] sortEvenOdd(int[] nums) {\\n        PriorityQueue<Integer> queue = new PriorityQueue<>();\\n        for(int i=0;i<nums.length;i+=2){\\n            queue.add(nums[i]);\\n        }\\n        for(int i=0;i<nums.length;i+=2){\\n            nums[i]=queue.poll();\\n        }\\n        queue = new PriorityQueue<>(new MaxHeap());\\n        for(int i=1;i<nums.length;i+=2){\\n            queue.add(nums[i]);\\n        }\\n        for(int i=1;i<nums.length;i+=2){\\n            nums[i]=queue.poll();\\n        }\\n        return nums;\\n    }\\n}\\nclass MaxHeap implements Comparator<Integer>{\\n    public int compare(Integer ca,Integer cb){\\n        return cb-ca;\\n    }\\n}\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\n    public int[] sortEvenOdd(int[] nums) {\n        PriorityQueue<Integer> queue = new PriorityQueue<>();\n        for(int i=0;i<nums.length;i+=2){\n            queue.add(nums[i]);\n        }\n        for(int i=0;i<nums.length;i+=2){\n            nums[i]=queue.poll();\n        }\n        queue = new PriorityQueue<>(new MaxHeap());\n        for(int i=1;i<nums.length;i+=2){\n            queue.add(nums[i]);\n        }\n        for(int i=1;i<nums.length;i+=2){\n            nums[i]=queue.poll();\n        }\n        return nums;\n    }\n\n    public void printSorted(int[] nums) {\n       nums = sortEvenOdd(nums);\n       for(int num: nums) {\n           printNum(num);\n       }\n    }\n}\n\nclass MaxHeap implements Comparator<Integer>{\n    public int compare(Integer ca,Integer cb){\n        return cb-ca;\n    }\n}\n",
        "explanations": "\nprintNum method is used in printSorted method, but it is not defined.\n"
    },
    {
        "slug": "minimum-number-of-swaps-to-make-the-string-balanced",
        "description": "You are given a 0-indexed string s of even length n. The string consists of exactly n / 2 opening brackets '[' and n / 2 closing brackets ']'.\nA string is called balanced if and only if:\n\nIt is the empty string, or\nIt can be written as AB, where both A and B are balanced strings, or\nIt can be written as [C], where C is a balanced string.\n\nYou may swap the brackets at any two indices any number of times.\nReturn the minimum number of swaps to make s balanced.",
        "examples": [
            "Input: s = \"][][\"\nOutput: 1\nExplanation: You can make the string balanced by swapping index 0 with index 3.\nThe resulting string is \"[[]]\".",
            "Input: s = \"]]][[[\"\nOutput: 2\nExplanation: You can do the following to make the string balanced:\n- Swap index 0 with index 4. s = \"[]][][\".\n- Swap index 1 with index 5. s = \"[[][]]\".\nThe resulting string is \"[[][]]\".",
            "Input: s = \"[]\"\nOutput: 0\nExplanation: The string is already balanced."
        ],
        "constraints": "n == s.length\n2 <= n <= 106\nn is even.\ns[i] is either '[' or ']'.\nThe number of opening brackets '[' equals n / 2, and the number of closing brackets ']' equals n / 2.",
        "release_time": 1686334819,
        "oracle_code": "class Solution {\n    public int minSwaps(String s) {\n        return util1(s);\n    }\n    public int util1(String str) {\n        Stack<Character> s = new Stack<>();\n        for (int i = 0; i < str.length(); i++) {\n            if (str.charAt(i) == '[') {\n                s.push(str.charAt(i));\n            } else {\n                if (s.isEmpty() == false && s.peek() == '[') {\n                    s.pop();\n                } else {\n                    s.push(str.charAt(i));\n                }\n            }\n        }\n        double pairs = s.size() / 2;\n        double a = pairs / 2.0;\n        int ans = (int) Math.ceil(a);\n        return ans;\n    }\n}",
        "content": "the trick behind is fairly easy\\n\\nfor the number of pairs which are not correct, the amount of swaps required to make them correct is Math.ceil(a), where a is the number of pairs which are not correct.\\n\\nfor eg\\nfor 5 incorrect pairs, we need 3 swaps\\nfor 3 incorrect pairs, we need 2 swaps\\nfor 2 incorrect pairs, we need 1 swap\\n\\nso simply, \\nwe need to firstly write code to remove all the valid pairs, that ways only the pairs which are incorrect will be in the stack\\nthen we simply do the calculations.\\n\\nrest the code should be self explanatory.\\n\\n# Code\\n```\\nclass Solution {\\n    public int minSwaps(String s) {\\n        return util1(s);\\n    }\\n    public int util1(String str) {\\n        Stack<Character> s = new Stack<>();\\n        for (int i = 0; i < str.length(); i++) {\\n            if (str.charAt(i) == \\'[\\') {\\n                s.push(str.charAt(i));\\n            } else {\\n                if (s.isEmpty() == false && s.peek() == \\'[\\') {\\n                    s.pop();\\n                } else {\\n                    s.push(str.charAt(i));\\n                }\\n            }\\n        }\\n        double pairs = s.size() / 2;\\n        double a = pairs / 2.0;\\n        int ans = (int) Math.ceil(a);\\n        return ans;\\n    }\\n}\\n```\\nyou can check out my github repository where i am uploading famous interview questions topic wise with solutions.\\nlink-- https://github.com/Abhaydutt2003/DataStructureAndAlgoPractice \\nkindly upvote if you like my solution. you can ask doubts below.\\n    \\n",
        "level": "medium",
        "buggy_code": "\nclass Solution {\n    public int minSwaps(String s) {\n        return util(s);\n    }\n    public int util1(String str) {\n        Stack<Character> s = new Stack<>();\n        for (int i = 0; i < str.length(); i++) {\n            if (str.charAt(i) == '[') {\n                s.push(str.charAt(i));\n            } else {\n                if (s.isEmpty() == false && s.peek() == '[') {\n                    s.pop();\n                } else {\n                    s.push(str.charAt(i));\n                }\n            }\n        }\n        double pairs = s.size() / 2;\n        double a = pairs / 2.0;\n        int ans = (int) Math.ceil(a);\n        return ans;\n    }\n}\n",
        "explanations": "\nThe method 'util' called in 'minSwaps' is undefined. The actual method is 'util1'.\n"
    },
    {
        "slug": "domino-and-tromino-tiling",
        "description": "You have two types of tiles: a 2 x 1 domino shape and a tromino shape. You may rotate these shapes.\n\nGiven an integer n, return the number of ways to tile an 2 x n board. Since the answer may be very large, return it modulo 109 + 7.\nIn a tiling, every square must be covered by a tile. Two tilings are different if and only if there are two 4-directionally adjacent cells on the board such that exactly one of the tilings has both squares occupied by a tile.",
        "examples": [
            "Input: n = 3\nOutput: 5\nExplanation: The five different ways are show above.",
            "Input: n = 1\nOutput: 1"
        ],
        "constraints": "1 <= n <= 1000",
        "release_time": 1671862293,
        "oracle_code": "class Solution {\n    private long[] dp;\n    int MOD = (int)Math.pow(10 , 9) + 7;\n    public long solve(int n){\n        if(n==0) return 1;\n        if(n<3) return n;\n\n        if(dp[n]!=-1) return dp[n];\n\n        return dp[n] = 2*solve(n-1)%MOD+solve(n-3)%MOD;\n    }\n    public int numTilings(int n) {\n        this.dp = new long[n+1];\n        Arrays.fill(dp , -1);\n\n        return (int)solve(n)%MOD;\n    }\n}",
        "content": "# Intuition\\n- The basic approach to solve this problem was by using brute force recursion.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- Then after realising the over-lapping sub problems in it the whole problem was solved using the memoization technique of Dynamic Programming\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(N*N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N)$$ + recursive stack space\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private long[] dp;\\n    int MOD = (int)Math.pow(10 , 9) + 7;\\n    public long solve(int n){\\n        if(n==0) return 1;\\n        if(n<3) return n;\\n\\n        if(dp[n]!=-1) return dp[n];\\n\\n        return dp[n] = 2*solve(n-1)%MOD+solve(n-3)%MOD;\\n    }\\n    public int numTilings(int n) {\\n        this.dp = new long[n+1];\\n        Arrays.fill(dp , -1);\\n\\n        return (int)solve(n)%MOD;\\n    }\\n}\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\n    private long[] dp;\n    int MOD = (int)Math.pow(10 , 9) + 7;\n    public long solve(int n){\n        if(n==0) return 1;\n        if(n<3) return n;\n\n        if(dp[n]!=-1) return dp[n];\n\n        return dp[n] = 2 * solve(n-1) % MOD + solve(n-4) % MOD;\n    }\n    public int numTilings(int n) {\n        this.dp = new long[n+1];\n        Arrays.fill(dp , -1);\n\n        return (int)solve(n) % MOD;\n    }\n}\n",
        "explanations": "\nThe method solve(n-4) is not defined which will lead to ArrayIndexOutOfBoundsException.\n"
    },
    {
        "slug": "remove-k-digits",
        "description": "Given string num representing a non-negative integer num, and an integer k, return the smallest possible integer after removing k digits from num.",
        "examples": [
            "Input: num = \"1432219\", k = 3\nOutput: \"1219\"\nExplanation: Remove the three digits 4, 3, and 2 to form the new number 1219 which is the smallest.",
            "Input: num = \"10200\", k = 1\nOutput: \"200\"\nExplanation: Remove the leading 1 and the number is 200. Note that the output must not contain leading zeroes.",
            "Input: num = \"10\", k = 2\nOutput: \"0\"\nExplanation: Remove all the digits from the number and it is left with nothing which is 0."
        ],
        "constraints": "1 <= k <= num.length <= 105\nnum consists of only digits.\nnum does not have any leading zeros except for the zero itself.",
        "release_time": 1680704468,
        "oracle_code": "class Solution {\n    public String removeKdigits(String num, int k) {\n        Stack<Character> st = new Stack<>();\n        for(Character ch : num.toCharArray()) {\n            while(!st.isEmpty() && k > 0 && ch < st.peek()) {\n                st.pop();\n                k--;\n            }\n\n            if(!st.isEmpty() || ch != '0') {\n                st.push(ch);\n            }\n        }\n\n        // This is a special edge case --> 1 2 3 4\n        while(!st.isEmpty() && k-- > 0) {\n            st.pop();\n        }\n        if(st.isEmpty()) return \"0\";\n        \n\n        // Store the ans -->\n        String ans = \"\";\n        while(!st.isEmpty()) {\n            ans = st.peek() + ans;\n            st.pop();\n        }\n        return ans;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n# Code\\n```\\nclass Solution {\\n    public String removeKdigits(String num, int k) {\\n        Stack<Character> st = new Stack<>();\\n        for(Character ch : num.toCharArray()) {\\n            while(!st.isEmpty() && k > 0 && ch < st.peek()) {\\n                st.pop();\\n                k--;\\n            }\\n\\n            if(!st.isEmpty() || ch != \\'0\\') {\\n                st.push(ch);\\n            }\\n        }\\n\\n        // This is a special edge case --> 1 2 3 4\\n        while(!st.isEmpty() && k-- > 0) {\\n            st.pop();\\n        }\\n        if(st.isEmpty()) return \"0\";\\n        \\n\\n        // Store the ans -->\\n        String ans = \"\";\\n        while(!st.isEmpty()) {\\n            ans = st.peek() + ans;\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n}\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\n    public String removeKdigits(String num, int k) {\n        Stack<Character> st = new Stack<>();\n        for(Character ch : num.toCharArray()) {\n            while(!st.isEmpty() && k > 0 && ch < st.peek()) {\n                st.pop();\n                k--;\n            }\n\n            if(!st.isEmpty() || ch != '0') {\n                st.push(ch);\n            }\n        }\n\n        // This is a special edge case --> 1 2 3 4\n        while(!st.isEmpty() && k-- > 0) {\n            st.pop();\n        }\n        if(st.isEmpty()) return \"0\";\n        \n\n        // Store the ans -->\n        String ans = \"\";\n        while(!st.isEmpty()) {\n            ans = st.peek() + ans;\n            st.pop();\n        }\n        return result;\n    }\n}\n",
        "explanations": "\nThe returned value \"result\" is undefined. It should be \"ans\" which holds the result.\n"
    },
    {
        "slug": "convert-sorted-array-to-binary-search-tree",
        "description": "Given an integer array nums where the elements are sorted in ascending order, convert it to a height-balanced binary search tree.",
        "examples": [
            "Input: nums = [-10,-3,0,5,9]\nOutput: [0,-3,9,-10,null,5]\nExplanation: [0,-10,5,null,-3,null,9] is also accepted:",
            "Input: nums = [1,3]\nOutput: [3,1]\nExplanation: [1,null,3] and [3,1] are both height-balanced BSTs."
        ],
        "constraints": "1 <= nums.length <= 104\n-104 <= nums[i] <= 104\nnums is sorted in a strictly increasing order.",
        "release_time": 1689161763,
        "oracle_code": "class Solution {\n    public TreeNode createBST(int arr[], int st, int end){\n        if(st>end){\n            return null;\n        }\n\n        int mid = (st+end)/2;\n        TreeNode root = new TreeNode(arr[mid]);\n        root.left = createBST(arr,st,mid-1);\n        root.right = createBST(arr,mid+1,end);\n\n        return root;\n    }\n    public TreeNode sortedArrayToBST(int[] nums) {\n        int st = 0;\n        int end = nums.length-1;\n        return createBST(nums,st,end);\n        \n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nInorder Traversal of BST is always sorted.\\nInorder = left, root, right\\nroot = mid of sorted array\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n**Divide and Conquer and Inorder Traversal**\\n$$Inorder = left, root, right$$ which means root = mid of sorted Array\\nDivide the array into smaller pieces using recursion and assing root = mid \\n$$ mid = (start+end)/2;$$\\n\\n\\n\\n# Complexity\\n- Time complexity: O(n) \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\n    public TreeNode createBST(int arr[], int st, int end){\\n        if(st>end){\\n            return null;\\n        }\\n\\n        int mid = (st+end)/2;\\n        TreeNode root = new TreeNode(arr[mid]);\\n        root.left = createBST(arr,st,mid-1);\\n        root.right = createBST(arr,mid+1,end);\\n\\n        return root;\\n    }\\n    public TreeNode sortedArrayToBST(int[] nums) {\\n        int st = 0;\\n        int end = nums.length-1;\\n        return createBST(nums,st,end);\\n        \\n    }\\n}\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\n    public TreeNode createBST(int arr[], int st, int end){\n        if(st>end){\n            return null;\n        }\n\n        int mid = (st+end)/2;\n        TreeNode root = new TreeNode(arr[mid]);\n        root.left = createBinaryTree(arr,st,mid-1);\n        root.right = createBinaryTree(arr,mid+1,end);\n\n        return root;\n    }\n    public TreeNode sortedArrayToBST(int[] nums) {\n        int st = 0;\n        int end = nums.length-1;\n        return createBST(nums,st,end);\n        \n    }\n}\n",
        "explanations": "\nThe function createBinaryTree is referenced but never defined which causes undefined method error.\n"
    },
    {
        "slug": "sign-of-the-product-of-an-array",
        "description": "There is a function signFunc(x) that returns:\n\n1 if x is positive.\n-1 if x is negative.\n0 if x is equal to 0.\n\nYou are given an integer array nums. Let product be the product of all values in the array nums.\nReturn signFunc(product).",
        "examples": [
            "Input: nums = [-1,-2,-3,-4,3,2,1]\nOutput: 1\nExplanation: The product of all values in the array is 144, and signFunc(144) = 1",
            "Input: nums = [1,5,0,2,-3]\nOutput: 0\nExplanation: The product of all values in the array is 0, and signFunc(0) = 0",
            "Input: nums = [-1,1,-1,1,-1]\nOutput: -1\nExplanation: The product of all values in the array is -1, and signFunc(-1) = -1"
        ],
        "constraints": "1 <= nums.length <= 1000\n-100 <= nums[i] <= 100",
        "release_time": 1682989041,
        "oracle_code": "class Solution { // Vezzz\n  public int arraySign(int[] nums) {\n    int z = 0;\n    for (int v : nums)\n      if (v == 0)\n        return 0;\n      else\n        z ^= v;\n    return z >> 31 | 1;\n  }\n}",
        "content": "# Intuition\\nOnly the sign bit matter.\\n\\n# Approach\\n- 2 negative sign bit cancel each other using xor.\\n- Early exit on `0`.\\n- Drag the sign bit over the whole int and set last bit.\\n\\n# Complexity\\n- Time complexity: *`O(n)`*\\n- Space complexity: *`O(1)`*\\n\\n# Code\\n```\\nclass Solution { // Vezzz\\n  public int arraySign(int[] nums) {\\n    int z = 0;\\n    for (int v : nums)\\n      if (v == 0)\\n        return 0;\\n      else\\n        z ^= v;\\n    return z >> 31 | 1;\\n  }\\n}\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution { \n  public int arraySign(int[] nums) {\n    int z = 0;\n    for (int v : nums)\n      if (v == 0)\n        return 0;\n      else\n        z ^= v;\n    return getSign(z);\n  }\n\n}\n",
        "explanations": "\nMethod getSign() is not defined but called in arraySign(), causing an undefined error.\n"
    }
]