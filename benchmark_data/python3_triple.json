[
    {
        "slug": "kth-largest-sum-in-a-binary-tree",
        "description": "You are given the root of a binary tree and a positive integer k.\nThe level sum in the tree is the sum of the values of the nodes that are on the same level.\nReturn the kth largest level sum in the tree (not necessarily distinct). If there are fewer than k levels in the tree, return -1.\nNote that two nodes are on the same level if they have the same distance from the root.",
        "examples": [
            "Input: root = [5,8,9,2,1,3,7,4,6], k = 2\nOutput: 13\nExplanation: The level sums are the following:\n- Level 1: 5.\n- Level 2: 8 + 9 = 17.\n- Level 3: 2 + 1 + 3 + 7 = 13.\n- Level 4: 4 + 6 = 10.\nThe 2nd largest level sum is 13.",
            "Input: root = [1,2,null,3], k = 1\nOutput: 3\nExplanation: The largest level sum is 3."
        ],
        "constraints": "The number of nodes in the tree is n.\n2 <= n <= 105\n1 <= Node.val <= 106\n1 <= k <= n",
        "oracle_code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def kthLargestLevelSum(self, root: Optional[TreeNode], k: int) -> int:\n        dq = collections.deque([root])\n        a = []\n        lvl = 1\n        while dq:\n            lvlsum = 0\n            for i in range(len(dq)):\n               n = dq.popleft()\n               lvlsum += n.val\n               if n.left: dq.append(n.left)\n               if n.right: dq.append(n.right)\n            a.append(lvlsum)\n            lvl += 1\n        a.sort(reverse=True)\n        return a[k-1] if len(a) >= k else -1",
        "content": "\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def kthLargestLevelSum(self, root: Optional[TreeNode], k: int) -> int:\\n        dq = collections.deque([root])\\n        a = []\\n        lvl = 1\\n        while dq:\\n            lvlsum = 0\\n            for i in range(len(dq)):\\n               n = dq.popleft()\\n               lvlsum += n.val\\n               if n.left: dq.append(n.left)\\n               if n.right: dq.append(n.right)\\n            a.append(lvlsum)\\n            lvl += 1\\n        a.sort(reverse=True)\\n        return a[k-1] if len(a) >= k else -1\\n```",
        "level": "medium",
        "type": [
            "other error",
            "undefined methods",
            "indexing error"
        ],
        "buggy_code": "\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def kthLargestLevelSum(self, root: Optional[TreeNode], k: int) -> int:\n        dq = collections.deque([root])\n        a = []\n        lvl = 1\n        while dq:\n            lvlsum = 0\n            for i in range(len(dq)):\n               n = dq.popleft()\n               lvlsum += n.val\n               if n.left: dq.append(n.left)\n               if n.right: dq.append(n.right)\n                \n            a.append(self.calculateLevelSum(lvlsum)) \n            lvl += 1\n        a.sort(reverse=False)\n        return a[k] if len(a) >= k else -1\n\n"
    },
    {
        "slug": "maximum-difference-between-node-and-ancestor",
        "description": "Given the root of a binary tree, find the maximum value v for which there exist different nodes a and b where v = |a.val - b.val| and a is an ancestor of b.\nA node a is an ancestor of b if either: any child of a is equal to b\u00a0or any child of a is an ancestor of b.",
        "examples": [
            "Input: root = [8,3,10,1,6,null,14,null,null,4,7,13]\nOutput: 7\nExplanation: We have various ancestor-node differences, some of which are given below :\n|8 - 3| = 5\n|3 - 7| = 4\n|8 - 1| = 7\n|10 - 13| = 3\nAmong all possible differences, the maximum value of 7 is obtained by |8 - 1| = 7.",
            "Input: root = [1,null,2,null,0,3]\nOutput: 3"
        ],
        "constraints": "The number of nodes in the tree is in the range [2, 5000].\n0 <= Node.val <= 105",
        "oracle_code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\ndef fun(root,mx,mn,ans):\n    if(root==None):\n        return\n    d1=abs(root.val-mx)\n    d2=abs(root.val-mn)\n    ans[0]=max(d1,d2,ans[0])\n    mx=max(mx,root.val)\n    mn=min(mn,root.val)\n    fun(root.left,mx,mn,ans)\n    fun(root.right,mx,mn,ans)\nclass Solution:\n    def maxAncestorDiff(self, root: Optional[TreeNode]) -> int:\n        ans=[0]\n        if(root==None):\n            return 0\n        fun(root,root.val,root.val,ans)\n        return ans[0]",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\ndef fun(root,mx,mn,ans):\\n    if(root==None):\\n        return\\n    d1=abs(root.val-mx)\\n    d2=abs(root.val-mn)\\n    ans[0]=max(d1,d2,ans[0])\\n    mx=max(mx,root.val)\\n    mn=min(mn,root.val)\\n    fun(root.left,mx,mn,ans)\\n    fun(root.right,mx,mn,ans)\\nclass Solution:\\n    def maxAncestorDiff(self, root: Optional[TreeNode]) -> int:\\n        ans=[0]\\n        if(root==None):\\n            return 0\\n        fun(root,root.val,root.val,ans)\\n        return ans[0]\\n```",
        "level": "medium",
        "type": [
            "indentation error",
            "operation error",
            "undefined objects"
        ],
        "buggy_code": "\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\ndef fun(root,mx,mn,ans):\nif(root==None):\n    return\nd1=abs(root.val-mx)\nd2=abs(root.val-mn)\nans[0]=max(d1,d2,ans[0])\nmx=max(mx,root.val)\nmn=min(mn,root.val)\nfun(root.left,mx,mn,ans)\nfun(some_node,mx,mn,ans)\nclass Solution:\n    def maxAncestorDiff(self, root: Optional[TreeNode]) -> int:\n        ans=[0]\n        if(root==None):\n            return 0\n        fun(root,root.val,root.val,ans)\n        return 0\n"
    },
    {
        "slug": "minimum-obstacle-removal-to-reach-corner",
        "description": "You are given a 0-indexed 2D integer array grid of size m x n. Each cell has one of two values:\n\n0 represents an empty cell,\n1 represents an obstacle that may be removed.\n\nYou can move up, down, left, or right from and to an empty cell.\nReturn the minimum number of obstacles to remove so you can move from the upper left corner (0, 0) to the lower right corner (m - 1, n - 1).",
        "examples": [
            "Input: grid = [[0,1,1],[1,1,0],[1,1,0]]\nOutput: 2\nExplanation: We can remove the obstacles at (0, 1) and (0, 2) to create a path from (0, 0) to (2, 2).\nIt can be shown that we need to remove at least 2 obstacles, so we return 2.\nNote that there may be other ways to remove 2 obstacles to create a path.",
            "Input: grid = [[0,1,0,0,0],[0,1,0,1,0],[0,0,0,1,0]]\nOutput: 0\nExplanation: We can move from (0, 0) to (2, 4) without removing any obstacles, so we return 0."
        ],
        "constraints": "m == grid.length\nn == grid[i].length\n1 <= m, n <= 105\n2 <= m * n <= 105\ngrid[i][j] is either 0 or 1.\ngrid[0][0] == grid[m - 1][n - 1] == 0",
        "oracle_code": "class Solution:\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n        distance[0][0] = 0\n        q = collections.deque([(0, 0, 0)])\n        while q:\n            d, i, j = q.popleft()\n            if i == m - 1 and j == n - 1: return d\n            for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                ci, cj = i + di, j + dj\n                if 0 <= ci < m and 0 <= cj < n:\n                    if d + grid[ci][cj] < distance[ci][cj]:\n                        distance[ci][cj] = d + grid[ci][cj]\n                        if grid[ci][cj] == 1: q.append((distance[ci][cj], ci, cj))\n                        else: q.appendleft((distance[ci][cj], ci, cj))\n        return distance[m - 1][n - 1]",
        "content": "# Intuition\\nFind the shortest path with the weight is only 0 or 1 => 0-1 BFS\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\ncan refer 0-1 BFS [here](https://cp-algorithms.com/graph/01_bfs.html#algorithm)\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(E)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(E)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        distance = [[float(\\'inf\\') for _ in range(n)] for _ in range(m)]\\n        distance[0][0] = 0\\n        q = collections.deque([(0, 0, 0)])\\n        while q:\\n            d, i, j = q.popleft()\\n            if i == m - 1 and j == n - 1: return d\\n            for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\\n                ci, cj = i + di, j + dj\\n                if 0 <= ci < m and 0 <= cj < n:\\n                    if d + grid[ci][cj] < distance[ci][cj]:\\n                        distance[ci][cj] = d + grid[ci][cj]\\n                        if grid[ci][cj] == 1: q.append((distance[ci][cj], ci, cj))\\n                        else: q.appendleft((distance[ci][cj], ci, cj))\\n        return distance[m - 1][n - 1]\\n```",
        "level": "hard",
        "type": [
            "variable value error",
            "undefined objects",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\n        undefined_variable.m, n = len(grid), len(grid[0])\n        distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n        distance[0][0] = 0\n        q = collections.deque([(0, 0, 0)])\n        while q:\n            d, i, j = q.popleft()\n            if i == m - 1 and j = n - 1: return d\n            for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                ci, cj = i + di, j + dj\n                if 0 <= ci < m and 0 <= cj < n:\n                    if d + grid[ci][cj] < distance[ci][cj]:\n                        distance[ci][cj] = d + grid[ci][cj]\n                        if grid[ci][cj] == 1: q.append((distance[ci][cj], ci, cj))\n                        else: q.appendleft((distance[ci][cj], ci, cj))\n                else: q.appendleft((distance[i][j], i, j))\n        return distance[m - 1][n - 1]\n"
    },
    {
        "slug": "closest-dessert-cost",
        "description": "You would like to make dessert and are preparing to buy the ingredients. You have n ice cream base flavors and m types of toppings to choose from. You must follow these rules when making your dessert:\n\nThere must be exactly one ice cream base.\nYou can add one or more types of topping or have no toppings at all.\nThere are at most two of each type of topping.\n\nYou are given three inputs:\n\nbaseCosts, an integer array of length n, where each baseCosts[i] represents the price of the ith ice cream base flavor.\ntoppingCosts, an integer array of length m, where each toppingCosts[i] is the price of one of the ith topping.\ntarget, an integer representing your target price for dessert.\n\nYou want to make a dessert with a total cost as close to target as possible.\nReturn the closest possible cost of the dessert to target. If there are multiple, return the lower one.",
        "examples": [
            "Input: baseCosts = [1,7], toppingCosts = [3,4], target = 10\nOutput: 10\nExplanation: Consider the following combination (all 0-indexed):\n- Choose base 1: cost 7\n- Take 1 of topping 0: cost 1 x 3 = 3\n- Take 0 of topping 1: cost 0 x 4 = 0\nTotal: 7 + 3 + 0 = 10.",
            "Input: baseCosts = [2,3], toppingCosts = [4,5,100], target = 18\nOutput: 17\nExplanation: Consider the following combination (all 0-indexed):\n- Choose base 1: cost 3\n- Take 1 of topping 0: cost 1 x 4 = 4\n- Take 2 of topping 1: cost 2 x 5 = 10\n- Take 0 of topping 2: cost 0 x 100 = 0\nTotal: 3 + 4 + 10 + 0 = 17. You cannot make a dessert with a total cost of 18.",
            "Input: baseCosts = [3,10], toppingCosts = [2,5], target = 9\nOutput: 8\nExplanation: It is possible to make desserts with cost 8 and 10. Return 8 as it is the lower cost."
        ],
        "constraints": "n == baseCosts.length\nm == toppingCosts.length\n1 <= n, m <= 10\n1 <= baseCosts[i], toppingCosts[i] <= 104\n1 <= target <= 104",
        "oracle_code": "class Solution:\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\n        toppingCosts *= 2\n        \n        @cache\n        def fn(i, x):\n            \"\"\"Return sum of subsequence of toppingCosts[i:] closest to x.\"\"\"\n            if x < 0 or i == len(toppingCosts): return 0\n            return min(fn(i+1, x), toppingCosts[i] + fn(i+1, x-toppingCosts[i]), key=lambda y: (abs(y-x), y))\n        \n        ans = inf\n        for bc in baseCosts: \n            ans = min(ans, bc + fn(0, target - bc), key=lambda x: (abs(x-target), x))\n        return ans",
        "content": "\\n```\\nclass Solution:\\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\\n        toppingCosts *= 2\\n        \\n        @cache\\n        def fn(i, x):\\n            \"\"\"Return sum of subsequence of toppingCosts[i:] closest to x.\"\"\"\\n            if x < 0 or i == len(toppingCosts): return 0\\n            return min(fn(i+1, x), toppingCosts[i] + fn(i+1, x-toppingCosts[i]), key=lambda y: (abs(y-x), y))\\n        \\n        ans = inf\\n        for bc in baseCosts: \\n            ans = min(ans, bc + fn(0, target - bc), key=lambda x: (abs(x-target), x))\\n        return ans \\n```\\nTime complexity `O(MNV)`\\n\\nEdited on 2/28/2021\\n\\nAdding the version by @lenchen1112\\n```\\nclass Solution:\\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\\n        \\n        @cache\\n        def fn(i, cost):\\n            \"\"\"Return sum of subsequence closest to target.\"\"\"\\n            if cost >= target or i == len(toppingCosts): return cost\\n            return min(fn(i+1, cost), fn(i+1, cost+toppingCosts[i]), key=lambda x: (abs(x-target), x))\\n        \\n        ans = inf\\n        toppingCosts *= 2\\n        for cost in baseCosts: \\n            ans = min(ans, fn(0, cost), key=lambda x: (abs(x-target), x))\\n        return ans \\n```\\n\\nAdding binary search implementation\\n```\\nclass Solution:\\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\\n        top = {0}\\n        for x in toppingCosts*2: \\n            top |= {x + xx for xx in top}\\n        top = sorted(top)\\n        \\n        ans = inf \\n        for bc in baseCosts: \\n            k = bisect_left(top, target - bc)\\n            if k < len(top): ans = min(ans, bc + top[k], key=lambda x: (abs(x-target), x))\\n            if k: ans = min(ans, bc + top[k-1], key=lambda x: (abs(x-target), x))\\n        return ans \\n```\\nTime complexity `O(N*2^(2N) + MN)`",
        "level": "medium",
        "type": [
            "parentheses mismatch",
            "unclosed string",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\n        toppingCosts *= 2\n\n        @cache\n        def fn(i, x):\n            \"\"\"Return sum of subsequence of toppingCosts[i:] closest to x.\"\n            if x < 0 or i == len(toppingCosts+1: return 0\n            return min(fn(i+1, x), toppingCosts[i] + fn(i+1, x-toppingCosts[i]), key=lambda y: (abs(y-x), y))\n        \n        ans = inf\n        for bc in baseCosts: \n            ans = min(ans, bc + fn(0, target - bc), key=lambda x: (abs(x-target), x))\n        return ans\n"
    },
    {
        "slug": "find-all-possible-recipes-from-given-supplies",
        "description": "You have information about n different recipes. You are given a string array recipes and a 2D string array ingredients. The ith recipe has the name recipes[i], and you can create it if you have all the needed ingredients from ingredients[i]. Ingredients to a recipe may need to be created from other recipes, i.e., ingredients[i] may contain a string that is in recipes.\nYou are also given a string array supplies containing all the ingredients that you initially have, and you have an infinite supply of all of them.\nReturn a list of all the recipes that you can create. You may return the answer in any order.\nNote that two recipes may contain each other in their ingredients.",
        "examples": [
            "Input: recipes = [\"bread\"], ingredients = [[\"yeast\",\"flour\"]], supplies = [\"yeast\",\"flour\",\"corn\"]\nOutput: [\"bread\"]\nExplanation:\nWe can create \"bread\" since we have the ingredients \"yeast\" and \"flour\".",
            "Input: recipes = [\"bread\",\"sandwich\"], ingredients = [[\"yeast\",\"flour\"],[\"bread\",\"meat\"]], supplies = [\"yeast\",\"flour\",\"meat\"]\nOutput: [\"bread\",\"sandwich\"]\nExplanation:\nWe can create \"bread\" since we have the ingredients \"yeast\" and \"flour\".\nWe can create \"sandwich\" since we have the ingredient \"meat\" and can create the ingredient \"bread\".",
            "Input: recipes = [\"bread\",\"sandwich\",\"burger\"], ingredients = [[\"yeast\",\"flour\"],[\"bread\",\"meat\"],[\"sandwich\",\"meat\",\"bread\"]], supplies = [\"yeast\",\"flour\",\"meat\"]\nOutput: [\"bread\",\"sandwich\",\"burger\"]\nExplanation:\nWe can create \"bread\" since we have the ingredients \"yeast\" and \"flour\".\nWe can create \"sandwich\" since we have the ingredient \"meat\" and can create the ingredient \"bread\".\nWe can create \"burger\" since we have the ingredient \"meat\" and can create the ingredients \"bread\" and \"sandwich\"."
        ],
        "constraints": "n == recipes.length == ingredients.length\n1 <= n <= 100\n1 <= ingredients[i].length, supplies.length <= 100\n1 <= recipes[i].length, ingredients[i][j].length, supplies[k].length <= 10\nrecipes[i], ingredients[i][j], and supplies[k] consist only of lowercase English letters.\nAll the values of recipes and supplies\u00a0combined are unique.\nEach ingredients[i] does not contain any duplicate values.",
        "oracle_code": "class Solution:\n    def findAllRecipes(self, recepies: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\n        dct=defaultdict(lambda :[])\n        indegree={}\n        n=len(recepies)\n\n        for i in recepies:\n            indegree[i]=0\n\n        for i in range(n):\n            for j in ingredients[i]:\n                indegree[j]=0\n\n        for i in range(n):\n            for j in ingredients[i]:\n                dct[j].append(recepies[i])\n                indegree[recepies[i]]+=1\n\n        st=[]\n        for i in indegree:\n            if indegree[i]==0:\n                st.append(i)\n        flst=[]\n        ans=defaultdict(lambda :[])\n        while st:\n            x=st.pop(0)\n            for i in dct[x]:\n                # if ans[x]!=[]:\n                for j in ans[x]:\n                    if j not in ans[i]:\n                        ans[i].append(j)\n                ans[i].append(x)\n                indegree[i]-=1\n                if indegree[i]==0:\n                    st.append(i)\n            if x in recepies:\n                for k in ans[x]:\n                    if k not in supplies:\n                        break\n                else:\n                    flst.append(x)\n                    supplies.append(x)\n\n        return flst",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findAllRecipes(self, recepies: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n        dct=defaultdict(lambda :[])\\n        indegree={}\\n        n=len(recepies)\\n\\n        for i in recepies:\\n            indegree[i]=0\\n\\n        for i in range(n):\\n            for j in ingredients[i]:\\n                indegree[j]=0\\n\\n        for i in range(n):\\n            for j in ingredients[i]:\\n                dct[j].append(recepies[i])\\n                indegree[recepies[i]]+=1\\n\\n        st=[]\\n        for i in indegree:\\n            if indegree[i]==0:\\n                st.append(i)\\n        flst=[]\\n        ans=defaultdict(lambda :[])\\n        while st:\\n            x=st.pop(0)\\n            for i in dct[x]:\\n                # if ans[x]!=[]:\\n                for j in ans[x]:\\n                    if j not in ans[i]:\\n                        ans[i].append(j)\\n                ans[i].append(x)\\n                indegree[i]-=1\\n                if indegree[i]==0:\\n                    st.append(i)\\n            if x in recepies:\\n                for k in ans[x]:\\n                    if k not in supplies:\\n                        break\\n                else:\\n                    flst.append(x)\\n                    supplies.append(x)\\n\\n        return flst\\n```",
        "level": "medium",
        "type": [
            "colon missing",
            "operation error",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution:\n    def findAllRecipes(self, recepies: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\n        dct=defaultdict(lambda :[])\n        indegree={}\n        n=len(recepies)\n\n        for i in recepies:\n            indegree[i]=0\n\n        for i in range(n)\n            for j in ingredients[i]:\n                indegree[j]=0\n\n        for i in range(n):\n            for j in ingredients[i]:\n                dct[j].append(recepies[i])\n                indegree[recepies[i]]+=1\n\n        st=[]\n        for i in indegree:\n            if indegree[i]==0:\n                st.push(i)\n        flst=[]\n        ans=defaultdict(lambda :[])\n        while st:\n            x=st.pop(0)\n            for i in dct[x]:\n                for j in ans[x]:\n                    if j not in ans[i]:\n                        ans[i].append(j)\n                ans[i].append(x)\n                indegree[i]-=1\n                if indegree[i]==0:\n                    st.append(i)\n            if x in recepies:\n                for k in ans[x]:\n                    if k not in supplies:\n                        break\n                else:\n                    flst.append(x)\n                    supplies.append(x)\n\n        return iflst\n"
    },
    {
        "slug": "valid-arrangement-of-pairs",
        "description": "You are given a 0-indexed 2D integer array pairs where pairs[i] = [starti, endi]. An arrangement of pairs is valid if for every index i where 1 <= i < pairs.length, we have endi-1 == starti.\nReturn any valid arrangement of pairs.\nNote: The inputs will be generated such that there exists a valid arrangement of pairs.",
        "examples": [
            "Input: pairs = [[5,1],[4,5],[11,9],[9,4]]\nOutput: [[11,9],[9,4],[4,5],[5,1]]\nExplanation:\nThis is a valid arrangement since endi-1 always equals starti.\nend0 = 9 == 9 = start1 \nend1 = 4 == 4 = start2\nend2 = 5 == 5 = start3",
            "Input: pairs = [[1,3],[3,2],[2,1]]\nOutput: [[1,3],[3,2],[2,1]]\nExplanation:\nThis is a valid arrangement since endi-1 always equals starti.\nend0 = 3 == 3 = start1\nend1 = 2 == 2 = start2\nThe arrangements [[2,1],[1,3],[3,2]] and [[3,2],[2,1],[1,3]] are also valid.",
            "Input: pairs = [[1,2],[1,3],[2,1]]\nOutput: [[1,2],[2,1],[1,3]]\nExplanation:\nThis is a valid arrangement since endi-1 always equals starti.\nend0 = 2 == 2 = start1\nend1 = 1 == 1 = start2"
        ],
        "constraints": "1 <= pairs.length <= 105\npairs[i].length == 2\n0 <= starti, endi <= 109\nstarti != endi\nNo two pairs are exactly the same.\nThere exists a valid arrangement of pairs.",
        "oracle_code": "class Solution:\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\n        graph = defaultdict(list)\n        degree = defaultdict(int) # net out degree \n        for x, y in pairs: \n            graph[x].append(y)\n            degree[x] += 1\n            degree[y] -= 1\n                \n        for k in degree: \n            if degree[k] == 1: \n                x = k\n                break \n                \n        ans = []\n\n        def fn(x): \n            \"\"\"Return Eulerian path via dfs.\"\"\"\n            while graph[x]: fn(graph[x].pop()) \n            ans.append(x)\n        \n        fn(x)\n        ans.reverse()\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]",
        "content": "Please check out this [commit](https://github.com/gaosanyong/leetcode/commit/b1948f8814bebeca475cbb354cd44d19092dff59) for solutions of weekly 270.\\n\\n```\\nclass Solution:\\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\\n        graph = defaultdict(list)\\n        degree = defaultdict(int) # net out degree \\n        for x, y in pairs: \\n            graph[x].append(y)\\n            degree[x] += 1\\n            degree[y] -= 1\\n                \\n        for k in degree: \\n            if degree[k] == 1: \\n                x = k\\n                break \\n                \\n        ans = []\\n\\n        def fn(x): \\n            \"\"\"Return Eulerian path via dfs.\"\"\"\\n            while graph[x]: fn(graph[x].pop()) \\n            ans.append(x)\\n        \\n        fn(x)\\n        ans.reverse()\\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]\\n```\\n\\nAdding an iterative implementation of Hieholzer\\'s algo from @delphih\\n```\\nclass Solution:\\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\\n        graph = defaultdict(list)\\n        degree = defaultdict(int) # net out degree \\n        for x, y in pairs: \\n            graph[x].append(y)\\n            degree[x] += 1\\n            degree[y] -= 1\\n                \\n        for k in degree: \\n            if degree[k] == 1: \\n                x = k\\n                break \\n                \\n        ans = []\\n        stack = [x]\\n        while stack: \\n            while graph[stack[-1]]: \\n                stack.append(graph[stack[-1]].pop())\\n            ans.append(stack.pop())\\n        ans.reverse()\\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]\\n```",
        "level": "hard",
        "type": [
            "undefined methods",
            "unclosed string",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\n        graph = defaultdict(list)\n        degree = defaultdict(int) # net out degree \n        for x, y in pairs: \n            graph[x].append(y)\n            degree[x] += 1\n            degree[y] -= 1\n                \n        for k in degree: \n            if degree[k] = 1: \n                x = k\n                break \n                \n        ans = []\n\n        def fn(x): \n            \"\"\"Return Eulerian path via dfs.\"\n            while graph[x]: fn(graph[x].pop()) \n            ans.append(x)\n        \n        dfn(s)\n        ans.reverse()\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]\n"
    },
    {
        "slug": "count-the-repetitions",
        "description": "We define str = [s, n] as the string str which consists of the string s concatenated n times.\n\nFor example, str == [\"abc\", 3] ==\"abcabcabc\".\n\nWe define that string s1 can be obtained from string s2 if we can remove some characters from s2 such that it becomes s1.\n\nFor example, s1 = \"abc\" can be obtained from s2 = \"abdbec\" based on our definition by removing the bolded underlined characters.\n\nYou are given two strings s1 and s2 and two integers n1 and n2. You have the two strings str1 = [s1, n1] and str2 = [s2, n2].\nReturn the maximum integer m such that str = [str2, m] can be obtained from str1.",
        "examples": [
            "Input: s1 = \"acb\", n1 = 4, s2 = \"ab\", n2 = 2\nOutput: 2",
            "Input: s1 = \"acb\", n1 = 1, s2 = \"acb\", n2 = 1\nOutput: 1"
        ],
        "constraints": "1 <= s1.length, s2.length <= 100\ns1 and s2 consist of lowercase English letters.\n1 <= n1, n2 <= 106",
        "oracle_code": "class Solution:\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\n\n        rec, track = [0], defaultdict(int) \n        ct = start = ptr1 = ptr2 = 0\n\n        if not set(s2).issubset(set(s1)): return 0\n\n        s1 = ''.join(char for char in s1 if char in set(s2))\n        \n        while True:\n            for char in s2:\n                ptr = s1.find(char, start)\n                if ptr == -1:\n                    ct += 1\n                    ptr = s1.find(char)\n                start = ptr+1\n            rec.append(ct + 1)\n\n            if rec[-1] > n1: return (len(rec)-2)//n2\n\n            if ptr not in track: track[ptr] = len(rec)-1\n            else: break\n        \n        cycleStart = rec[track[ptr]]\n        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]\n        rest = n1 - cycleStart\n        \n        rem = cycleStart + rest%cycle1\n\n        while rec[ptr2] <= rem: ptr2+= 1\n\n        return (cycle2 * (rest//cycle1) + ptr2-1)//n2",
        "content": "```\\nclass Solution:\\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\\n\\n        rec, track = [0], defaultdict(int) \\n        ct = start = ptr1 = ptr2 = 0\\n\\n        if not set(s2).issubset(set(s1)): return 0\\n\\n        s1 = \\'\\'.join(char for char in s1 if char in set(s2))\\n        \\n        while True:\\n            for char in s2:\\n                ptr = s1.find(char, start)\\n                if ptr == -1:\\n                    ct += 1\\n                    ptr = s1.find(char)\\n                start = ptr+1\\n            rec.append(ct + 1)\\n\\n            if rec[-1] > n1: return (len(rec)-2)//n2\\n\\n            if ptr not in track: track[ptr] = len(rec)-1\\n            else: break\\n        \\n        cycleStart = rec[track[ptr]]\\n        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]\\n        rest = n1 - cycleStart\\n        \\n        rem = cycleStart + rest%cycle1\\n\\n        while rec[ptr2] <= rem: ptr2+= 1\\n\\n        return (cycle2 * (rest//cycle1) + ptr2-1)//n2\\n```\\n[https://leetcode.com/problems/count-the-repetitions/submissions/864907562/](http://)\\n\\nI could be wrong, but I think that time is *O*(*N*) and space is *O*(*N*).",
        "level": "hard",
        "type": [
            "undefined methods",
            "colon missing",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int\n\n        rec, track = [0], defaultdict(int) \n        ct = start = ptr1 = ptr2 = 0\n\n        if not set(s2).issubset(set(s1)): return 0\n\n        s1 = ''.join(char for char in s1 if char in set(s2))\n        \n        while True:\n            for char in s2:\n                ptr = s1.find(char, start)\n                if ptr == -1:\n                    ct += 1\n                    ptr = s1.find(char)\n                start = ptr+1\n            rec.append(ct + 1)\n\n            if rec[-1] > n1: return (len(rec)-2)//n2\n\n            if ptr not in track: track[ptr] = len(rec)-1\n            else: break\n        \n        cycleStart = rec[track[ptr]]\n        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]\n        rest = n1 - cycleStart\n        \n        rem = cycleStart + self.calculateRemainder(rest, cycle1)\n\n        while rec[ptr2] <= rem: ptr2+= 1\n\n        return (cycle2 * (rest//cycle1) + ptr2-2)//n2\n"
    },
    {
        "slug": "maximum-of-absolute-value-expression",
        "description": "Given two arrays of integers with equal lengths, return the maximum value of:\n|arr1[i] - arr1[j]| + |arr2[i] - arr2[j]| + |i - j|\nwhere the maximum is taken over all 0 <= i, j < arr1.length.",
        "examples": [
            "Input: arr1 = [1,2,3,4], arr2 = [-1,4,5,6]\nOutput: 13",
            "Input: arr1 = [1,-2,-5,0,10], arr2 = [0,-2,-1,-7,-4]\nOutput: 20"
        ],
        "constraints": "2 <= arr1.length == arr2.length <= 40000\n-10^6 <= arr1[i], arr2[i] <= 10^6",
        "oracle_code": "class Solution:\n    def maxAbsValExpr(self, arr1: List[int], arr2: List[int]) -> int:\n        '''\n        |a1[i]-a1[j]| + |a2[i]-a2[j]| + |i-j|\n        total 2(+ or -)**(no. of modules) == 2**3 cases\n\n        --> a1[i]-a1[j]+a2[i]-a2[j]+i-j\n            == (a1[i]+a2[i]+i) - (a1[j]+a2[j]+j)\n\n        --> a1[i]-a1[j]+a2[i]-a2[j]-i-j\n            == (a1[i]+a2[i]-i) - (a1[j]+a2[j]-j)\n        \n        ...etc\n        '''\n        val1,val2,val3,val4=[],[],[],[]\n        for i in range(len(arr1)):\n            val1.append(i+arr1[i]+arr2[i])\n            val2.append(i+arr1[i]-arr2[i])\n            val3.append(i-arr1[i]+arr2[i])\n            val4.append(i-arr1[i]-arr2[i])\n        ans=0\n        ans=max(ans,max(val1)-min(val1))\n        ans=max(ans,max(val2)-min(val2))\n        ans=max(ans,max(val3)-min(val3))\n        ans=max(ans,max(val4)-min(val4))\n        return ans",
        "content": "# Code\\n```\\nclass Solution:\\n    def maxAbsValExpr(self, arr1: List[int], arr2: List[int]) -> int:\\n        \\'\\'\\'\\n        |a1[i]-a1[j]| + |a2[i]-a2[j]| + |i-j|\\n        total 2(+ or -)**(no. of modules) == 2**3 cases\\n\\n        --> a1[i]-a1[j]+a2[i]-a2[j]+i-j\\n            == (a1[i]+a2[i]+i) - (a1[j]+a2[j]+j)\\n\\n        --> a1[i]-a1[j]+a2[i]-a2[j]-i-j\\n            == (a1[i]+a2[i]-i) - (a1[j]+a2[j]-j)\\n        \\n        ...etc\\n        \\'\\'\\'\\n        val1,val2,val3,val4=[],[],[],[]\\n        for i in range(len(arr1)):\\n            val1.append(i+arr1[i]+arr2[i])\\n            val2.append(i+arr1[i]-arr2[i])\\n            val3.append(i-arr1[i]+arr2[i])\\n            val4.append(i-arr1[i]-arr2[i])\\n        ans=0\\n        ans=max(ans,max(val1)-min(val1))\\n        ans=max(ans,max(val2)-min(val2))\\n        ans=max(ans,max(val3)-min(val3))\\n        ans=max(ans,max(val4)-min(val4))\\n        return ans\\n```",
        "level": "medium",
        "type": [
            "undefined methods",
            "operation error",
            "== and = confusion"
        ],
        "buggy_code": "\nfrom typing import List\nclass Solution:\n    def maxAbsValExpr(self, arr1: List[int], arr2: List[int]) -> int:\n        val1,val2,val3,val4=[],[],[],[]\n        for i in range(len(arr1)):\n            val1.append(i+arr1[i]+arr2[i])\n            val2.append(i+arr1[i]-arr2[i])\n            val3.append(i-arr1[i]+arr2[i])\n            val4.append(i-arr1[i]-arr2[i])\n        ans=0\n        ans=min(ans,max(val1)-min(val1))\n        ans=min(ans,sel2f.computeMaxAndMin(val2))\n        ans=min(ans,max(val3)-min(val3))\n        ans=min(ans,self.coputeMaxAndMself.coputeMAndMinself.coputeMAndMin4)) == 0\n        return ans\n"
    },
    {
        "slug": "number-complement",
        "description": "The complement of an integer is the integer you get when you flip all the 0's to 1's and all the 1's to 0's in its binary representation.\n\nFor example, The integer 5 is \"101\" in binary and its complement is \"010\" which is the integer 2.\n\nGiven an integer num, return its complement.",
        "examples": [
            "Input: num = 5\nOutput: 2\nExplanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2.",
            "Input: num = 1\nOutput: 0\nExplanation: The binary representation of 1 is 1 (no leading zero bits), and its complement is 0. So you need to output 0."
        ],
        "constraints": "1 <= num < 231\n\n\u00a0\nNote: This question is the same as 1009: https://leetcode.com/problems/complement-of-base-10-integer/",
        "oracle_code": "class Solution:\n    def findComplement(self, num: int) -> int:\n        com = ''\n        while num > 0 :\n            \n            if num % 2 == 1:\n                com += '0'\n            else:\n                com += '1'\n            num = num // 2\n        return int(com[::-1],2)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findComplement(self, num: int) -> int:\\n        com = \\'\\'\\n        while num > 0 :\\n            \\n            if num % 2 == 1:\\n                com += \\'0\\'\\n            else:\\n                com += \\'1\\'\\n            num = num // 2\\n        return int(com[::-1],2)\\n        \\n\\n```",
        "level": "easy",
        "type": [
            "operation error",
            "undefined keywords from other languages",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def findComplement(self, num: int) -> int:\n        com = ''\n        while num > 0 :\n            \n            if num % 2 == 1:\n                com += 0\n            else:\n                com += 1\n            num = num // 2\n        return int(com][1:,2)\n"
    },
    {
        "slug": "construct-binary-tree-from-preorder-and-inorder-traversal",
        "description": "Given two integer arrays preorder and inorder where preorder is the preorder traversal of a binary tree and inorder is the inorder traversal of the same tree, construct and return the binary tree.",
        "examples": [
            "Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]\nOutput: [3,9,20,null,null,15,7]",
            "Input: preorder = [-1], inorder = [-1]\nOutput: [-1]"
        ],
        "constraints": "1 <= preorder.length <= 3000\ninorder.length == preorder.length\n-3000 <= preorder[i], inorder[i] <= 3000\npreorder and inorder consist of unique values.\nEach value of inorder also appears in preorder.\npreorder is guaranteed to be the preorder traversal of the tree.\ninorder is guaranteed to be the inorder traversal of the tree.",
        "oracle_code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:\n        inorder_map={val:idx for idx, val in enumerate(inorder)}\n        preorder_idx=0\n\n        def treeHelper(left, right):\n            nonlocal preorder_idx\n            if left>right:\n                return None\n\n            node_val = preorder[preorder_idx]\n            root=TreeNode(node_val)\n            preorder_idx+=1\n\n            inorder_index=inorder_map[node_val]\n\n            root.left = treeHelper(left, inorder_index-1 )\n            root.right = treeHelper(inorder_index+1, right)\n\n            return root\n\n        return treeHelper(0, len(inorder)-1)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:. $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:. $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:\\n        inorder_map={val:idx for idx, val in enumerate(inorder)}\\n        preorder_idx=0\\n\\n        def treeHelper(left, right):\\n            nonlocal preorder_idx\\n            if left>right:\\n                return None\\n\\n            node_val = preorder[preorder_idx]\\n            root=TreeNode(node_val)\\n            preorder_idx+=1\\n\\n            inorder_index=inorder_map[node_val]\\n\\n            root.left = treeHelper(left, inorder_index-1 )\\n            root.right = treeHelper(inorder_index+1, right)\\n\\n            return root\\n\\n        return treeHelper(0, len(inorder)-1)\\n```",
        "level": "medium",
        "type": [
            "other error",
            "undefined objects",
            "parentheses mismatch"
        ],
        "buggy_code": "\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:\n        inorder_map={val:idx for idx, val in enumerate(inorder)}\n        preorder_idx=0\n\n        def treeHelper(left, right):\n            nonlocal preorder_idx\n            if left>right:\n                return None\n\n            node_val = X_noexisted_list[preorder_idx] \n            root=TreeNode(node_val)\n            preorder_idx+=1\n\n            inorder_index=inorder_map[node_val]\n\n            root.left = treeHelper(inorder_index+1, right)\n            root.right = treeHelper(left, inorder_index-1 )\n\n            return root\n\n        return treeHelper(0, len(inorder)-1)\n"
    },
    {
        "slug": "check-if-every-row-and-column-contains-all-numbers",
        "description": "An n x n matrix is valid if every row and every column contains all the integers from 1 to n (inclusive).\nGiven an n x n integer matrix matrix, return true if the matrix is valid. Otherwise, return false.",
        "examples": [
            "Input: matrix = [[1,2,3],[3,1,2],[2,3,1]]\nOutput: true\nExplanation: In this case, n = 3, and every row and column contains the numbers 1, 2, and 3.\nHence, we return true.",
            "Input: matrix = [[1,1,1],[1,2,3],[1,2,3]]\nOutput: false\nExplanation: In this case, n = 3, but the first row and the first column do not contain the numbers 2 or 3.\nHence, we return false."
        ],
        "constraints": "n == matrix.length == matrix[i].length\n1 <= n <= 100\n1 <= matrix[i][j] <= n",
        "oracle_code": "class Solution:\n    def checkValid(self, matrix: List[List[int]]) -> bool:\n\n        dp_col = [[False for _ in range(len(matrix[0]))] for _ in range(len(matrix))]\n        dp_row = [[False for _ in range(len(matrix[0]))] for _ in range(len(matrix))]\n\n        for i in range(len(matrix)):\n            for j in range(len(matrix[0])):\n                if dp_row[i][matrix[i][j]-1] or dp_col[j][matrix[i][j]-1]:\n                    return False\n                dp_row[i][matrix[i][j]-1] = True\n                dp_col[j][matrix[i][j]-1] = True\n        return True",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def checkValid(self, matrix: List[List[int]]) -> bool:\\n\\n        dp_col = [[False for _ in range(len(matrix[0]))] for _ in range(len(matrix))]\\n        dp_row = [[False for _ in range(len(matrix[0]))] for _ in range(len(matrix))]\\n\\n        for i in range(len(matrix)):\\n            for j in range(len(matrix[0])):\\n                if dp_row[i][matrix[i][j]-1] or dp_col[j][matrix[i][j]-1]:\\n                    return False\\n                dp_row[i][matrix[i][j]-1] = True\\n                dp_col[j][matrix[i][j]-1] = True\\n        return True\\n\\n\\n```",
        "level": "easy",
        "type": [
            "variable value error",
            "undefined objects",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def checkValid(self, matrix: List[List[int]]) -> bool:\n\n        dp_row = [[False for _ in range(len(matrix[0]))] for _ in range(len(matrix))]\n\n        for i in range(len(matrix)):\n            for j in range(len(matrix[0])):\n                if dp_row[i][j] or dp_col[i][j]:\n                    return False\n                dp_row[i][j] = True\n                dp_col[i][j] = True\n        return True\n\n\n"
    },
    {
        "slug": "moving-stones-until-consecutive-ii",
        "description": "There are some stones in different positions on the X-axis. You are given an integer array stones, the positions of the stones.\nCall a stone an endpoint stone if it has the smallest or largest position. In one move, you pick up an endpoint stone and move it to an unoccupied position so that it is no longer an endpoint stone.\n\nIn particular, if the stones are at say, stones = [1,2,5], you cannot move the endpoint stone at position 5, since moving it to any position (such as 0, or 3) will still keep that stone as an endpoint stone.\n\nThe game ends when you cannot make any more moves (i.e., the stones are in three consecutive positions).\nReturn an integer array answer of length 2 where:\n\nanswer[0] is the minimum number of moves you can play, and\nanswer[1] is the maximum number of moves you can play.",
        "examples": [
            "Input: stones = [7,4,9]\nOutput: [1,2]\nExplanation: We can move 4 -> 8 for one move to finish the game.\nOr, we can move 9 -> 5, 4 -> 6 for two moves to finish the game.",
            "Input: stones = [6,5,4,3,10]\nOutput: [2,3]\nExplanation: We can move 3 -> 8 then 10 -> 7 to finish the game.\nOr, we can move 3 -> 7, 4 -> 8, 5 -> 9 to finish the game.\nNotice we cannot move 10 -> 2 to finish the game, because that would be an illegal move."
        ],
        "constraints": "3 <= stones.length <= 104\n1 <= stones[i] <= 109\nAll the values of stones are unique.",
        "oracle_code": "class Solution:\n    '''\n        Test cases walk through \n        Given 7, 4, 9 prove 1, 2                                                            6, 5, 4, 3, 10, prove 2, 3 \n\n        Sort stones -> 4, 7, 9                                                              3, 4, 5, 6, 10 \n        Stone length -> 3                                                                   5\n        Move penultimate = 7 - 4 - 3 + 2 = 2                                                6-3-5+2 = 0 \n        Move final = 9 - 7 - 3 + 2 = 1                                                      10-4-5+2 = 3 \n        Neither is 0, so we cannot return for sure                                          Move penultimate is 0, so move final is assured \n                                                                                            This means we can return [min(2, 3), 3] -> [2, 3]\n\n        Max legal moves is 0                                                                For completeness, max legal moves is 0, max moves is 3  \n        starting index is 0                                                                 starting index is 0 \n\n        Enumeration                                                                         Enumeration\n            index is 0, stone is 4                                                             index is 0, stone is 3 \n            stones[0] lte 4 - 3 ? No, skip while loop                                          stones[0] lte 3 - 5 ? No, skip while \n            max legal moves is min of (max of self and 0 - 0 + 1, most moves)                  max legal moves is min of (max of self and 0 - 0 + 1), max moves -> max legal moves is 1 \n                 -> max legal moves is 1                                                            \n\n            index is 1, stone is 7                                                             index is 1, stone is 4 \n            stones[0] <= 7 - 3 ? Yes, enter while                                              stones[0] lte 4 - 5 ? No, skip while \n                starting index is now 1                                                        max legal moves is min of (max of self and 1 - 0 + 1), max moves -> max legal moves is 2\n            stones[1] <= 7 - 3 ? No, skip while                                                 \n            max legal moves -> min(max of self and 1 - 1 + 1), max_moves \n                -> max legal moves is 1                                                        index is 2, stone is 5 \n                                                                                               stones[0] lte 5 - 5 ? No skip while \n            index is 2, stone is 9                                                             max legal moves is min of (max of self and 2 - 0 + 1), max_moves -> max legal moves is 3 \n            stones[1] <= 9 - 3 ? No, skip while                                                 \n            max legal moves is min(max of self and 2-1 + 1), max_moves\n                 -> max legal moves is 2                                                       index is 3, stone is 6 \n        End enumeration                                                                        stones[0] lte 6 - 5 ? No skip while \n                                                                                               max legal moves is min (max of self and 3 - 0 + 1), max_moves -> max legal moves is 3 \n        Return [3 - 2, 2] -> [1, 2] checks out                                                  \n                                                                                               index is 4, stones is 10 \n                                                                                               stones[0] lte 10 - 5 ? Yes, enter while \n                                                                                                    starting index is 1 \n                                                                                               stones[1] lte 10 - 5 ? Yes, enter while \n                                                                                                    starting index is 2 \n                                                                                               stones[2] lte 10 - 5 ? Yes, enter while \n                                                                                                    starting index is 3 \n                                                                                               max legal moves is min (max of self and 4 - 3 + 1), max moves -> max legal moves is 3 \n                                                                                            End enumeration\n\n                                                                                            Return [5 - 3, 3] -> [2, 3]\n    '''\n    def numMovesStonesII(self, stones: List[int]) -> List[int] :\n        # order does not need to be maintained, so sorting is optimal \n        stones.sort()\n        # want to work within stone physical space since 10^9 >> 10^4 (stone weight vs length)\n        stone_length = len(stones)\n        # what is the cost of moving the second to last stone and the 0th stone? \n        move_penultimate = stones[-2] - stones[0] - stone_length + 2 \n        # what is the cost of moving the last stone and the 1st stone? \n        move_final = stones[-1] - stones[1] - stone_length + 2 \n        # in both of these, the cost is the positional exchange in stones along the stone length + 2 for the two stones moving \n        # our most moves possible are the max of these two \n        most_moves = max(move_penultimate, move_final)\n        # since the stones are unique, if either is 0, the one that we have must be max legal moves \n        # if move penultimate is 0, that means that the second largest stone less the least stone less the length + 2 is 0 \n        # this means that the largest stone, which must be at least one larger than the largest, less the second to least stone which is at least one larger than the least stone  less the length + 2 is move final \n        # our minimal length is 3 \n        # let a, b, c be stones in order \n        # b - a - 3 + 2 = 0 -> b = a + 1 move penultimate  \n        # c - b - 3 + 2 = 0 -> b = c - 1 move final \n        # c - 1 = a + 1 -> c = a + 2 \n        # all stones must be at least 1 to 10^9 and are unique \n        # so at minimum a is 1, b is 2 and c is 3  \n        # in this case, move final is also 0 so we get 0, 0 \n        # if a = 4, b = 5, c = 7 \n        # 5 - 4 - 3 + 2 = 0 move penultimate is 0 \n        # 7 - 5 - 3 + 2 -> 1 move ultimate is 1 \n        # min legal moves is min of 2 and 1 -> min legal moves is 1 -> 1, 1 is returned \n        # from this it can be seen that the movement of c relative to b impacts  the return here when one is 0, and that if either is 0 it does not preclude the other. However it does entail a relation to 2 as most that min could become \n        # this is because if most moves is greater than 2, we could always do the move alternate that was 0 in two steps. This is what locks in to place the ability to use 2 here as the min argument. \n        if move_penultimate == 0 or move_final == 0 : \n            min_legal_moves = min(2, most_moves)\n            return [min_legal_moves, most_moves]\n        # how many legal moves are there in sorted order? \n        max_legal_moves = 0 \n        # starting from 0th index \n        starting_index = 0\n        # enumerate each stone and index \n        for index, stone in enumerate(stones) :\n            # while the stone at starting index is lte this stone minus stone length (cost of a move) \n            while stones[starting_index] <= stone - stone_length : \n                # increment \n                starting_index += 1\n            # max legal moves is then set to maxima of self and indexed difference with 1 for 0 based indexing  \n            max_legal_moves = min(max(max_legal_moves, index - starting_index + 1), most_moves) \n        # return length - max legal moves when in sorted order (your minimal move state) and most moves in sorted order \n        return [stone_length - max_legal_moves, most_moves]",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAt the base of this problem is a linear scan. This is because we are trying to achieve the pairing of minimum number of moves and maximum number of moves. As such, we are trying to sort the move value space and scan over it linearly. This can be achieved with a few key insights from the problem that keep it at a medium level. \\n\\nFirst, we have a list size lower bound of 3. This is actually dreadfully important for one of our key edge cases that make this easily solvable so don\\'t discard such things when they come up! \\n\\nSecond, we have that all the stone values are unique. \\n\\nThird, we have that all the stone values are positive integers from 1 to 10^9. This is important both as an insight into the fact that we are working with only positive values, and that we are working with a very large value space compared to a much relatively smaller value ordination (there are 10^9 values for the stones, but only 10^4 positions at most for them) \\n\\nWe are also provided with a helpful hint \\n>For the minimum, how many cows are already in place? For the maximum, we have to lose either the gap A[1] - A[0] or A[N-1] - A[N-2] (where N = A.length), but every other space can be occupied ?  \\n\\nWe turn first to the idea of the maximum, where we have a gap we will need to lose of either between the first and second position or ultimate and penultimate position. \\n\\nIf we consider a list of 3 items, our minimum, what is our minimum values to get our minimal return? Not to spoil anything, but it is 1, 2, 3 \\n\\nThis is key to the problem, since there are no spaces provided between the values, so our return should be [0, 0] \\n\\nBy realizing the impact of this the approach follows below. Try to work out for a few values and sizes to get the feel for it and you\\'ll likely find an understanding either intuitively or by action. I recommend working with small list sizes and trying to generate [0, 1], [0, 2], [1, 2], and [2, 2] with only 3 or so items. It\\'ll be difficult, but worth it for the understanding pay off. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe original ordering of the stones is not valid compared to their ordinal positioning, and since we know we have a size limit much less than a value limit, we start by sorting. \\n\\nThen, we want to know how much space we have to work witin, so get the size of your listing (how many stones do you have regardless of how much they are worth?) \\n\\nThen, we need to calculate the two largest costs, move penultimate and move ultimate (final in the code) \\n\\nMove penultimate is the cost of swapping the stones at the second to last spot and the first spot, minus the cost of the number of stones you have (Since you moved over the whole thing!) plus 2 to deal with the fact that they are unique\\n\\nMove ultimate is the cost of swapping the stones at the last spot and second spot, minus the cost of the number of stones you have plus 2 to deal with the fact that they are unique\\n\\nIf either of these is 0, the other must be locked in as most moves, as most moves will be the max of these two options (try to convince yourself of why that is the case! This relates to the idea of the list sizings, and is really clearly seen with a list of size 3)\\n\\nIf either is 0, \\n- min legal moves is min of 2 and most moves \\n- return min legal moves and most moves \\n\\nOtherwise we now must consider how many max legal moves are there really? \\n\\nSet max legal moves to 0 \\nSet starting index to 0 \\nenumerate index and stone in stones \\n- while stones at starting index lte stone - stone length \\n    - increment starting index \\n- our max legal moves here is the max of itself (so it preserves good discoveries) and index - starting index + 1 (+1 for the fact we use 0 indexing) \\n- but, it cannot get too big! Remember, we already found the actual max, so don\\'t let anything in here fool you! Set max legal moves as such to min(max(max_legal_moves, index - starting_index + 1), max_moves) \\n- this keeps our newly found max legal less than our actual max moves \\n\\nWhen done enumerating return length - max legal moves, max moves \\n\\n# Complexity\\n- Time complexity : O(S log S + S)\\n    - O(S log S) to sort the stones \\n    - O(S) to loop over (while loop is incindental, as it can only run as many times as the length of stones as well in total, so it does not add to this)  \\n\\n- Space complexity : O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nNo additional space utilized \\n\\n# Code\\n```\\nclass Solution:\\n    \\'\\'\\'\\n        Test cases walk through \\n        Given 7, 4, 9 prove 1, 2                                                            6, 5, 4, 3, 10, prove 2, 3 \\n\\n        Sort stones -> 4, 7, 9                                                              3, 4, 5, 6, 10 \\n        Stone length -> 3                                                                   5\\n        Move penultimate = 7 - 4 - 3 + 2 = 2                                                6-3-5+2 = 0 \\n        Move final = 9 - 7 - 3 + 2 = 1                                                      10-4-5+2 = 3 \\n        Neither is 0, so we cannot return for sure                                          Move penultimate is 0, so move final is assured \\n                                                                                            This means we can return [min(2, 3), 3] -> [2, 3]\\n\\n        Max legal moves is 0                                                                For completeness, max legal moves is 0, max moves is 3  \\n        starting index is 0                                                                 starting index is 0 \\n\\n        Enumeration                                                                         Enumeration\\n            index is 0, stone is 4                                                             index is 0, stone is 3 \\n            stones[0] lte 4 - 3 ? No, skip while loop                                          stones[0] lte 3 - 5 ? No, skip while \\n            max legal moves is min of (max of self and 0 - 0 + 1, most moves)                  max legal moves is min of (max of self and 0 - 0 + 1), max moves -> max legal moves is 1 \\n                 -> max legal moves is 1                                                            \\n\\n            index is 1, stone is 7                                                             index is 1, stone is 4 \\n            stones[0] <= 7 - 3 ? Yes, enter while                                              stones[0] lte 4 - 5 ? No, skip while \\n                starting index is now 1                                                        max legal moves is min of (max of self and 1 - 0 + 1), max moves -> max legal moves is 2\\n            stones[1] <= 7 - 3 ? No, skip while                                                 \\n            max legal moves -> min(max of self and 1 - 1 + 1), max_moves \\n                -> max legal moves is 1                                                        index is 2, stone is 5 \\n                                                                                               stones[0] lte 5 - 5 ? No skip while \\n            index is 2, stone is 9                                                             max legal moves is min of (max of self and 2 - 0 + 1), max_moves -> max legal moves is 3 \\n            stones[1] <= 9 - 3 ? No, skip while                                                 \\n            max legal moves is min(max of self and 2-1 + 1), max_moves\\n                 -> max legal moves is 2                                                       index is 3, stone is 6 \\n        End enumeration                                                                        stones[0] lte 6 - 5 ? No skip while \\n                                                                                               max legal moves is min (max of self and 3 - 0 + 1), max_moves -> max legal moves is 3 \\n        Return [3 - 2, 2] -> [1, 2] checks out                                                  \\n                                                                                               index is 4, stones is 10 \\n                                                                                               stones[0] lte 10 - 5 ? Yes, enter while \\n                                                                                                    starting index is 1 \\n                                                                                               stones[1] lte 10 - 5 ? Yes, enter while \\n                                                                                                    starting index is 2 \\n                                                                                               stones[2] lte 10 - 5 ? Yes, enter while \\n                                                                                                    starting index is 3 \\n                                                                                               max legal moves is min (max of self and 4 - 3 + 1), max moves -> max legal moves is 3 \\n                                                                                            End enumeration\\n\\n                                                                                            Return [5 - 3, 3] -> [2, 3]\\n    \\'\\'\\'\\n    def numMovesStonesII(self, stones: List[int]) -> List[int] :\\n        # order does not need to be maintained, so sorting is optimal \\n        stones.sort()\\n        # want to work within stone physical space since 10^9 >> 10^4 (stone weight vs length)\\n        stone_length = len(stones)\\n        # what is the cost of moving the second to last stone and the 0th stone? \\n        move_penultimate = stones[-2] - stones[0] - stone_length + 2 \\n        # what is the cost of moving the last stone and the 1st stone? \\n        move_final = stones[-1] - stones[1] - stone_length + 2 \\n        # in both of these, the cost is the positional exchange in stones along the stone length + 2 for the two stones moving \\n        # our most moves possible are the max of these two \\n        most_moves = max(move_penultimate, move_final)\\n        # since the stones are unique, if either is 0, the one that we have must be max legal moves \\n        # if move penultimate is 0, that means that the second largest stone less the least stone less the length + 2 is 0 \\n        # this means that the largest stone, which must be at least one larger than the largest, less the second to least stone which is at least one larger than the least stone  less the length + 2 is move final \\n        # our minimal length is 3 \\n        # let a, b, c be stones in order \\n        # b - a - 3 + 2 = 0 -> b = a + 1 move penultimate  \\n        # c - b - 3 + 2 = 0 -> b = c - 1 move final \\n        # c - 1 = a + 1 -> c = a + 2 \\n        # all stones must be at least 1 to 10^9 and are unique \\n        # so at minimum a is 1, b is 2 and c is 3  \\n        # in this case, move final is also 0 so we get 0, 0 \\n        # if a = 4, b = 5, c = 7 \\n        # 5 - 4 - 3 + 2 = 0 move penultimate is 0 \\n        # 7 - 5 - 3 + 2 -> 1 move ultimate is 1 \\n        # min legal moves is min of 2 and 1 -> min legal moves is 1 -> 1, 1 is returned \\n        # from this it can be seen that the movement of c relative to b impacts  the return here when one is 0, and that if either is 0 it does not preclude the other. However it does entail a relation to 2 as most that min could become \\n        # this is because if most moves is greater than 2, we could always do the move alternate that was 0 in two steps. This is what locks in to place the ability to use 2 here as the min argument. \\n        if move_penultimate == 0 or move_final == 0 : \\n            min_legal_moves = min(2, most_moves)\\n            return [min_legal_moves, most_moves]\\n        # how many legal moves are there in sorted order? \\n        max_legal_moves = 0 \\n        # starting from 0th index \\n        starting_index = 0\\n        # enumerate each stone and index \\n        for index, stone in enumerate(stones) :\\n            # while the stone at starting index is lte this stone minus stone length (cost of a move) \\n            while stones[starting_index] <= stone - stone_length : \\n                # increment \\n                starting_index += 1\\n            # max legal moves is then set to maxima of self and indexed difference with 1 for 0 based indexing  \\n            max_legal_moves = min(max(max_legal_moves, index - starting_index + 1), most_moves) \\n        # return length - max legal moves when in sorted order (your minimal move state) and most moves in sorted order \\n        return [stone_length - max_legal_moves, most_moves]\\n```",
        "level": "medium",
        "type": [
            "indentation error",
            "other error",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution:dfnumMovStonesII(sef,stones: List[int]) -> List[int]:\n        stones.sort()\n        stone_leng = len(stnes)\n        move_penltimate = stones[-2] - stones[0] - stone_lent+2\nmove_final = stones[-1] - stones[1] - stone_length + 2 \n        most_moves = min(move_penultimatemove_final)\n      if move_nultimate==mv_final==:_gl_movs=most_moves\n            return [min_legal_movesmost_moves\n      max_legal_moves = 0 \n        starting_index = 0\n        for index():starting_index<=stne - stone_length : \n                starting_index += 1\n            max_legal_moves = min(max(max_legal_moves-trting_iext_)rtur[tone_length- max_legal_movesm_mv)sne_lengms_mves = max(move_penultimate, move_nal)\n      if move_uima==0or move_final == 0 : \n            min_legal_moves = min(, most_moves)\n            return [min_legal_moves, most_moves]\n        max_legal_moves = 0 \n        starting_index = 0\n       x stone in enumerate(stones) :\n           le stones[starting_index] <= stone - stone_lengt:\n           starting_index += 1\n            max_legal_moves = min(max(max_legal_moves, index - starting_index + 1), most_moves) \n        return [stone_leng-mx__mv,mos_movs]\n     \nsolution = Solution()\nprint(solution.moveFinal([,6"
    },
    {
        "slug": "number-of-ways-of-cutting-a-pizza",
        "description": "Given a rectangular pizza represented as a rows x cols\u00a0matrix containing the following characters: 'A' (an apple) and '.' (empty cell) and given the integer k. You have to cut the pizza into k pieces using k-1 cuts.\u00a0\nFor each cut you choose the direction: vertical or horizontal, then you choose a cut position at the cell boundary and cut the pizza into two pieces. If you cut the pizza vertically, give the left part of the pizza to a person. If you cut the pizza horizontally, give the upper part of the pizza to a person. Give the last piece of pizza to the last person.\nReturn the number of ways of cutting the pizza such that each piece contains at least one apple.\u00a0Since the answer can be a huge number, return this modulo 10^9 + 7.",
        "examples": [
            "Input: pizza = [\"A..\",\"AAA\",\"...\"], k = 3\nOutput: 3 \nExplanation: The figure above shows the three ways to cut the pizza. Note that pieces must contain at least one apple.",
            "Input: pizza = [\"A..\",\"AA.\",\"...\"], k = 3\nOutput: 1",
            "Input: pizza = [\"A..\",\"A..\",\"...\"], k = 1\nOutput: 1"
        ],
        "constraints": "1 <= rows, cols <= 50\nrows ==\u00a0pizza.length\ncols ==\u00a0pizza[i].length\n1 <= k <= 10\npizza consists of characters 'A'\u00a0and '.' only.",
        "oracle_code": "class Solution:\n    def ways(self, pizza: List[str], k: int) -> int:\n        self.r = len(pizza)\n        self.c = len(pizza[0])\n        \n        # Step 1, pre-process the apple array and get the prefix sum\n        tot_apples = 0\n        self.pfsum_row = []\n        self.pfsum_col = []\n        \n        for i in range(self.r):\n            pfr = 0\n            pfs_r = [0] * self.c\n            pfs_c = [0] * self.c\n            for j in range(self.c):\n                if i > 0:\n                    pfs_c[j] += self.pfsum_col[i - 1][j]\n                if pizza[i][j] == 'A':\n                    pfr += 1\n                    pfs_c[j] += 1\n                    tot_apples += 1\n                pfs_r[j] = pfr\n            self.pfsum_row.append(pfs_r)\n            self.pfsum_col.append(pfs_c)\n        \n        if tot_apples < k:\n            return 0\n        \n        if k == 1:\n            return 1\n        \n        return self.getWays(0, 0, k) % (1000000007)\n    \n    \n    @cache\n    def getWays(self, i, j, k):\n        if k == 1:\n            # if only left one piece for cutting, we just need to check if there is any apple in the region\n            found = False\n            for c in range(j, self.c):\n                apple_in_region = self.pfsum_col[self.r - 1][c]\n                if i > 0:\n                     apple_in_region -= self.pfsum_col[i - 1][c]\n                if apple_in_region:\n                    found = True\n                    break\n            if found:\n                return 1\n            return 0\n        else:\n            # horizontally cut\n            cannot_cut = True\n            nr = i\n            t_cnt = 0\n            while nr < self.r - 1:\n                # find the first row that we can start cutting\n                while nr < self.r - 1 and cannot_cut:\n                    apple_in_region = self.pfsum_row[nr][self.c - 1]\n                    if j > 0:\n                        apple_in_region -= self.pfsum_row[nr][j - 1]\n                    if apple_in_region:\n                        cannot_cut = False\n                    else:\n                        nr += 1\n                        \n                if nr < self.r - 1:\n                    t_cnt += self.getWays(nr + 1, j, k - 1)\n                nr += 1\n                \n            # vertically cut\n            cannot_cut = True\n            nc = j\n            while nc < self.c - 1:\n                # find the first col that we can start cutting\n                while nc < self. c - 1 and cannot_cut:\n                    apple_in_region = self.pfsum_col[self.r - 1][nc]\n                    if i > 0:\n                        apple_in_region -= self.pfsum_col[i - 1][nc]\n                    if apple_in_region:\n                        cannot_cut = False\n                    else:\n                        nc += 1\n                \n                if nc < self.c - 1:\n                    t_cnt += self.getWays(i, nc + 1, k - 1)\n                nc += 1\n            \n            return t_cnt",
        "content": "The key to this problem is how to count the number of apples on the region we want to cut.\\n\\nWe can simply use the prefix sum that help to identify the number of apples between any two index.\\n\\nTherefore, we need to pre-process the input array, get the prefix sum horizatonally and vertically.\\n\\nWith the prefix sum array, we can create a dp funtion that get the number of cuts in the region (i, j) to (row - 1, col - 1)\\n\\n\\n```\\nclass Solution:\\n    def ways(self, pizza: List[str], k: int) -> int:\\n        self.r = len(pizza)\\n        self.c = len(pizza[0])\\n        \\n        # Step 1, pre-process the apple array and get the prefix sum\\n        tot_apples = 0\\n        self.pfsum_row = []\\n        self.pfsum_col = []\\n        \\n        for i in range(self.r):\\n            pfr = 0\\n            pfs_r = [0] * self.c\\n            pfs_c = [0] * self.c\\n            for j in range(self.c):\\n                if i > 0:\\n                    pfs_c[j] += self.pfsum_col[i - 1][j]\\n                if pizza[i][j] == \\'A\\':\\n                    pfr += 1\\n                    pfs_c[j] += 1\\n                    tot_apples += 1\\n                pfs_r[j] = pfr\\n            self.pfsum_row.append(pfs_r)\\n            self.pfsum_col.append(pfs_c)\\n        \\n        if tot_apples < k:\\n            return 0\\n        \\n        if k == 1:\\n            return 1\\n        \\n        return self.getWays(0, 0, k) % (1000000007)\\n    \\n    \\n    @cache\\n    def getWays(self, i, j, k):\\n        if k == 1:\\n            # if only left one piece for cutting, we just need to check if there is any apple in the region\\n            found = False\\n            for c in range(j, self.c):\\n                apple_in_region = self.pfsum_col[self.r - 1][c]\\n                if i > 0:\\n                     apple_in_region -= self.pfsum_col[i - 1][c]\\n                if apple_in_region:\\n                    found = True\\n                    break\\n            if found:\\n                return 1\\n            return 0\\n        else:\\n            # horizontally cut\\n            cannot_cut = True\\n            nr = i\\n            t_cnt = 0\\n            while nr < self.r - 1:\\n                # find the first row that we can start cutting\\n                while nr < self.r - 1 and cannot_cut:\\n                    apple_in_region = self.pfsum_row[nr][self.c - 1]\\n                    if j > 0:\\n                        apple_in_region -= self.pfsum_row[nr][j - 1]\\n                    if apple_in_region:\\n                        cannot_cut = False\\n                    else:\\n                        nr += 1\\n                        \\n                if nr < self.r - 1:\\n                    t_cnt += self.getWays(nr + 1, j, k - 1)\\n                nr += 1\\n                \\n            # vertically cut\\n            cannot_cut = True\\n            nc = j\\n            while nc < self.c - 1:\\n                # find the first col that we can start cutting\\n                while nc < self. c - 1 and cannot_cut:\\n                    apple_in_region = self.pfsum_col[self.r - 1][nc]\\n                    if i > 0:\\n                        apple_in_region -= self.pfsum_col[i - 1][nc]\\n                    if apple_in_region:\\n                        cannot_cut = False\\n                    else:\\n                        nc += 1\\n                \\n                if nc < self.c - 1:\\n                    t_cnt += self.getWays(i, nc + 1, k - 1)\\n                nc += 1\\n            \\n            return t_cnt\\n\\n```",
        "level": "hard",
        "type": [
            "operation error",
            "undefined keywords from other languages",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n    def ways(self, pizza: List[str], k: int) -> int:\n        self.r = len(pizza)\n        self.c = len(pizza[0])\n        \n        tot_apples = 0\n        self.pfsum_row = []\n        self.pfsum_col = []\n        \n        for i in range(self.r):\n            pfr = 0\n            pfs_r = [0] * self.c\n            pfs_c = [0] * self.c\n            for j in range(self.c):\n                if i > 0:\n                    pfs_c[j] += self.pfsum_col[i - 1][j]\n                if pizza[i][j] == 'A':\n                    pfr += 1\n                    pfs_c[j] += 1\n                    tot_apples -= 1\n                pfs_r[j] = pfr\n            self.pfsum_row.append(pfs_r)\n            self.pfsum_col.append(pfs_c)\n        \n        if tot_apples < k:\n            return 0\n        \n        if k = 1:\n            return 1\n        \n        return self.getWays(0, 0, k) % (1000000007)\n    \n    \n    @cache\n    def getWays(self, i, j, k):\n        if k == 1:\n            found = False\n            for c in range(j, this.c):\n                apple_in_region = this.pfsum_col[this.r - 1][c]\n                if i > 0:\n                     apple_in_region -= this.pfsum_col[i - 1][c]\n                if apple_in_region:\n                    found = True\n                    break\n            if found:\n                return 1\n            return 0\n        else:\n            cannot_cut = True\n            nr = i\n            t_cnt = 0\n            while nr < this.r - 1:\n                while nr < this.r - 1 and cannot_cut:\n                    apple_in_region = this.pfsum_row[nr][this.c - 1]\n                    if j > 0:\n                        apple_in_region -= this.pfsum_row[nr][j - 1]\n                    if apple_in_region:\n                        cannot_cut = False\n                    else:\n                        nr += 1\n                        \n                if nr < this.r - 1:\n                    t_cnt += this.getWays(nr + 1, j, k - 1)\n                nr += 1\n                \n            cannot_cut = True\n            nc = j\n            while nc < this.c - 1:\n                while nc < this.c - 1 and cannot_cut:\n                    apple_in_region = this.pfsum_col[this.r - 1][nc]\n                    if i > 0:\n                        apple_in_region -= this.pfsum_col[i - 1][nc]\n                    if apple_in_region:\n                        cannot_cut = False\n                    else:\n                        nc += 1\n                \n                if nc < this.c - 1:\n                    t_cnt += this.getWays(i, nc + 1, k - 1)\n                nc += 1\n            \n            return t_cnt\n"
    },
    {
        "slug": "restore-ip-addresses",
        "description": "A valid IP address consists of exactly four integers separated by single dots. Each integer is between 0 and 255 (inclusive) and cannot have leading zeros.\n\nFor example, \"0.1.2.201\" and \"192.168.1.1\" are valid IP addresses, but \"0.011.255.245\", \"192.168.1.312\" and \"192.168@1.1\" are invalid IP addresses.\n\nGiven a string s containing only digits, return all possible valid IP addresses that can be formed by inserting dots into s. You are not allowed to reorder or remove any digits in s. You may return the valid IP addresses in any order.",
        "examples": [
            "Input: s = \"25525511135\"\nOutput: [\"255.255.11.135\",\"255.255.111.35\"]",
            "Input: s = \"0000\"\nOutput: [\"0.0.0.0\"]",
            "Input: s = \"101023\"\nOutput: [\"1.0.10.23\",\"1.0.102.3\",\"10.1.0.23\",\"10.10.2.3\",\"101.0.2.3\"]"
        ],
        "constraints": "1 <= s.length <= 20\ns consists of digits only.",
        "oracle_code": "class Solution:\n    def restoreIpAddresses(self, s: str) -> List[str]:\n        res=[]\n        cur=[]\n        def backtrack(i):\n            if i==len(s) and len(cur)==4:\n                res.append(\".\".join(cur))\n                return\n            if len(cur)>4 or i>=len(s):\n                return\n            if s[i]=='0':\n                cur.append(s[i])\n                backtrack(i+1)\n                cur.pop()\n                return\n            j=0\n            while j<4 and i+j<len(s):\n                if int(s[i:i+j+1])<256:\n                    cur.append(s[i:i+j+1])\n                    backtrack(i+j+1)\n                    cur.pop()\n                j+=1\n        backtrack(0)\n        return res",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\njust take care with the processing number should be lower than len(s) and the length of current stack should be lower or equal 4.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(4)\\n# Code\\n```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        res=[]\\n        cur=[]\\n        def backtrack(i):\\n            if i==len(s) and len(cur)==4:\\n                res.append(\".\".join(cur))\\n                return\\n            if len(cur)>4 or i>=len(s):\\n                return\\n            if s[i]==\\'0\\':\\n                cur.append(s[i])\\n                backtrack(i+1)\\n                cur.pop()\\n                return\\n            j=0\\n            while j<4 and i+j<len(s):\\n                if int(s[i:i+j+1])<256:\\n                    cur.append(s[i:i+j+1])\\n                    backtrack(i+j+1)\\n                    cur.pop()\\n                j+=1\\n        backtrack(0)\\n        return res\\n\\n```",
        "level": "medium",
        "type": [
            "parentheses mismatch",
            "== and = confusion",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution():\n    def restoreIpAddresses(self, s: str) -> List[str]:\n        res=[]\n        cur=[]\n        def backtrack(i:\n            if i=len(s) and len(cur)==4:\n                res.append(\".\".join(cur))\n                return\n            if len(cur)>4 or i>len(s):\n                return\n            if s[i]=='0':\n                cur.append(s[i])\n                backtrack(i+1)\n                cur.pop()\n                return\n            j=0\n            while j<4 and i+j<len(s):\n                if int(s[i:i+j+1])<256:\n                    cur.append(s[i:i+j+1])\n                    backtrack(i+j+1)\n                    cur.pop()\n                j+=1\n        backtrack(0)\n        return res\n"
    },
    {
        "slug": "partition-array-according-to-given-pivot",
        "description": "You are given a 0-indexed integer array nums and an integer pivot. Rearrange nums such that the following conditions are satisfied:\n\nEvery element less than pivot appears before every element greater than pivot.\nEvery element equal to pivot appears in between the elements less than and greater than pivot.\nThe relative order of the elements less than pivot and the elements greater than pivot is maintained.\n\t\nMore formally, consider every pi, pj where pi is the new position of the ith element and pj is the new position of the jth element. For elements less than pivot, if i < j and nums[i] < pivot and nums[j] < pivot, then pi < pj. Similarly for elements greater than pivot, if i < j and nums[i] > pivot and nums[j] > pivot, then pi < pj.\n\n\n\nReturn nums after the rearrangement.",
        "examples": [
            "Input: nums = [9,12,5,10,14,3,10], pivot = 10\nOutput: [9,5,3,10,10,12,14]\nExplanation: \nThe elements 9, 5, and 3 are less than the pivot so they are on the left side of the array.\nThe elements 12 and 14 are greater than the pivot so they are on the right side of the array.\nThe relative ordering of the elements less than and greater than pivot is also maintained. [9, 5, 3] and [12, 14] are the respective orderings.",
            "Input: nums = [-3,4,3,2], pivot = 2\nOutput: [-3,2,4,3]\nExplanation: \nThe element -3 is less than the pivot so it is on the left side of the array.\nThe elements 4 and 3 are greater than the pivot so they are on the right side of the array.\nThe relative ordering of the elements less than and greater than pivot is also maintained. [-3] and [4, 3] are the respective orderings."
        ],
        "constraints": "1 <= nums.length <= 105\n-106 <= nums[i] <= 106\npivot equals to an element of nums.",
        "oracle_code": "class Solution:\n    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:\n        lst,val,tmp=[],[],[]\n        for i in nums:\n            if i==pivot:val.append(i)\n            elif i<pivot:lst.append(i)\n            else:tmp.append(i)\n        return lst+val+tmp",
        "content": "\\n# Code\\n```\\nclass Solution:\\n    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:\\n        lst,val,tmp=[],[],[]\\n        for i in nums:\\n            if i==pivot:val.append(i)\\n            elif i<pivot:lst.append(i)\\n            else:tmp.append(i)\\n        return lst+val+tmp\\n```",
        "level": "medium",
        "type": [
            "wrong comment mark",
            "== and = confusion",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n\n        lst,val,tmp=[],[],[]\n        for i in nums:\n            if i=pivot:val.append(nums[i])\n            elif i<pivot:lst.append(nums[i])\n            else:tmp.append(nums[i])\n        return lst+val+tmp\n"
    },
    {
        "slug": "linked-list-cycle",
        "description": "Given head, the head of a linked list, determine if the linked list has a cycle in it.\nThere is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the\u00a0next\u00a0pointer. Internally, pos\u00a0is used to denote the index of the node that\u00a0tail's\u00a0next\u00a0pointer is connected to.\u00a0Note that\u00a0pos\u00a0is not passed as a parameter.\nReturn\u00a0true if there is a cycle in the linked list. Otherwise, return false.",
        "examples": [
            "Input: head = [3,2,0,-4], pos = 1\nOutput: true\nExplanation: There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).",
            "Input: head = [1,2], pos = 0\nOutput: true\nExplanation: There is a cycle in the linked list, where the tail connects to the 0th node.",
            "Input: head = [1], pos = -1\nOutput: false\nExplanation: There is no cycle in the linked list."
        ],
        "constraints": "The number of the nodes in the list is in the range [0, 104].\n-105 <= Node.val <= 105\npos is -1 or a valid index in the linked-list.",
        "oracle_code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\n        a=b=head\n        while(a!=None and a.next!=None):\n            b=b.next\n            a=a.next.next\n            if(a==b):\n                return True\n        return False",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        a=b=head\\n        while(a!=None and a.next!=None):\\n            b=b.next\\n            a=a.next.next\\n            if(a==b):\\n                return True\\n        return False\\n```",
        "level": "easy",
        "type": [
            "indentation error",
            "== and = confusion",
            "conditional statement error"
        ],
        "buggy_code": "\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\ndef hasCycle(self, head: Optional[ListNode]) -> bool:\n    a=b=head\n    while(a is not None and a.next is not None):\n        b=b.next\n        a=a.next\n        if(a=b):\n            return True\n    return False\n"
    },
    {
        "slug": "all-ancestors-of-a-node-in-a-directed-acyclic-graph",
        "description": "You are given a positive integer n representing the number of nodes of a Directed Acyclic Graph (DAG). The nodes are numbered from 0 to n - 1 (inclusive).\nYou are also given a 2D integer array edges, where edges[i] = [fromi, toi] denotes that there is a unidirectional edge from fromi to toi in the graph.\nReturn a list answer, where answer[i] is the list of ancestors of the ith node, sorted in ascending order.\nA node u is an ancestor of another node v if u can reach v via a set of edges.",
        "examples": [
            "Input: n = 8, edgeList = [[0,3],[0,4],[1,3],[2,4],[2,7],[3,5],[3,6],[3,7],[4,6]]\nOutput: [[],[],[],[0,1],[0,2],[0,1,3],[0,1,2,3,4],[0,1,2,3]]\nExplanation:\nThe above diagram represents the input graph.\n- Nodes 0, 1, and 2 do not have any ancestors.\n- Node 3 has two ancestors 0 and 1.\n- Node 4 has two ancestors 0 and 2.\n- Node 5 has three ancestors 0, 1, and 3.\n- Node 6 has five ancestors 0, 1, 2, 3, and 4.\n- Node 7 has four ancestors 0, 1, 2, and 3.",
            "Input: n = 5, edgeList = [[0,1],[0,2],[0,3],[0,4],[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]\nOutput: [[],[0],[0,1],[0,1,2],[0,1,2,3]]\nExplanation:\nThe above diagram represents the input graph.\n- Node 0 does not have any ancestor.\n- Node 1 has one ancestor 0.\n- Node 2 has two ancestors 0 and 1.\n- Node 3 has three ancestors 0, 1, and 2.\n- Node 4 has four ancestors 0, 1, 2, and 3."
        ],
        "constraints": "1 <= n <= 1000\n0 <= edges.length <= min(2000, n * (n - 1) / 2)\nedges[i].length == 2\n0 <= fromi, toi <= n - 1\nfromi != toi\nThere are no duplicate edges.\nThe graph is directed and acyclic.",
        "oracle_code": "class Solution:\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\n        #Use Kahn's algorithm of toposort using a queue and bfs!\n        graph = [[] for _ in range(n)]\n        indegrees = [0] * n\n        \n        #Time: O(n^2)\n        #Space: O(n^2 + n + n) -> O(n^2)\n        \n        #1st step: build adjacency list grpah and update the initial indegrees of every node!\n        for edge in edges:\n            src, dest = edge[0], edge[1]\n            graph[src].append(dest)\n            indegrees[dest] += 1\n        \n        \n        queue = deque()\n        ans = [set() for _ in range(n)]\n        #2nd step: go through the indegrees array and add to queue for any node that has no ancestor!\n        for i in range(len(indegrees)):\n            if(indegrees[i] == 0):\n                queue.append(i)\n        \n        #Kahn's algorithm initiation!\n        #while loop will run for each and every node in graph!\n        #in worst case, adjacency list for one particular node may contain all other vertices!\n        while queue:\n            cur = queue.pop()\n            \n            #for each neighbor\n            for neighbor in graph[cur]:\n                #current node is ancestor to each and every neighboring node!\n                ans[neighbor].add(cur)\n                #every ancestor of current node is also an ancestor to the neighboring node!\n                ans[neighbor].update(ans[cur])\n                indegrees[neighbor] -= 1\n                if(indegrees[neighbor] == 0):\n                    queue.append(neighbor)\n        \n        #at the end, we should have set of ancestors for each and every node!\n        #in worst case, set s for ith node could have all other vertices be ancestor to node i !\n        ans = [(sorted(list(s))) for s in ans]\n        return ans",
        "content": "```\\nclass Solution:\\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        #Use Kahn\\'s algorithm of toposort using a queue and bfs!\\n        graph = [[] for _ in range(n)]\\n        indegrees = [0] * n\\n        \\n        #Time: O(n^2)\\n        #Space: O(n^2 + n + n) -> O(n^2)\\n        \\n        #1st step: build adjacency list grpah and update the initial indegrees of every node!\\n        for edge in edges:\\n            src, dest = edge[0], edge[1]\\n            graph[src].append(dest)\\n            indegrees[dest] += 1\\n        \\n        \\n        queue = deque()\\n        ans = [set() for _ in range(n)]\\n        #2nd step: go through the indegrees array and add to queue for any node that has no ancestor!\\n        for i in range(len(indegrees)):\\n            if(indegrees[i] == 0):\\n                queue.append(i)\\n        \\n        #Kahn\\'s algorithm initiation!\\n        #while loop will run for each and every node in graph!\\n        #in worst case, adjacency list for one particular node may contain all other vertices!\\n        while queue:\\n            cur = queue.pop()\\n            \\n            #for each neighbor\\n            for neighbor in graph[cur]:\\n                #current node is ancestor to each and every neighboring node!\\n                ans[neighbor].add(cur)\\n                #every ancestor of current node is also an ancestor to the neighboring node!\\n                ans[neighbor].update(ans[cur])\\n                indegrees[neighbor] -= 1\\n                if(indegrees[neighbor] == 0):\\n                    queue.append(neighbor)\\n        \\n        #at the end, we should have set of ancestors for each and every node!\\n        #in worst case, set s for ith node could have all other vertices be ancestor to node i !\\n        ans = [(sorted(list(s))) for s in ans]\\n        return ans",
        "level": "medium",
        "type": [
            "undefined objects",
            "unclosed string",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\n        graph = [[] for _ in range(n)]\n        indegrees = [0] * n\n\n        for edge in edges:\n            src, dest = edge[0], edge[1]\n            graph[src].append(dest)\n            indegrees[dest] += 1\n\n        queue = deque()\n        ans = [set() for _ in range(n)]\n\n        for i in range(len(indegrees)):\n            if(indegrees[i] = 0):\n                queue.append(i)\n\n        while queue:\n            cur = queue.pop()\n\n            for neighbor in graph[cur]:\n                ans[neighbor].add(cur)\n                ans[neighbor].update(ans[cur])\n                indegrees[neighbor] -= 1\n                if(indegrees[neighbor] = 0):\n                    queue.append(neighbor)\n\n        ans = [(sorted(listwhile queue:\n            cur = queue.pop()\n            \n            for each neighbor\n            for neighbor in graph[cur]:\n                #current node is ancestor to each and every neighboring node!\n                ans[neighbor].add(cur)\n                #every ancestor of current node is also an ancestor to the neighboring node!\n                ans[neighbor].update(ans[cur])\n                indegrees[neighbor] -= 1\n                if(indegrees[neighbor] == 0):\n                    queue.append(neighbor)\n        \n        #at the end, e soudhave set of ancestors for each and every node!\n        #in worst case, set s for ith node coudhave atr tices be ancestor to node i !\n        ans = [(sorted(list(s))) for s in mL\n"
    },
    {
        "slug": "count-anagrams",
        "description": "You are given a string s containing one or more words. Every consecutive pair of words is separated by a single space ' '.\nA string t is an anagram of string s if the ith word of t is a permutation of the ith word of s.\n\nFor example, \"acb dfe\" is an anagram of \"abc def\", but \"def cab\"\u00a0and \"adc bef\" are not.\n\nReturn the number of distinct anagrams of s. Since the answer may be very large, return it modulo 109 + 7.",
        "examples": [
            "Input: s = \"too hot\"\nOutput: 18\nExplanation: Some of the anagrams of the given string are \"too hot\", \"oot hot\", \"oto toh\", \"too toh\", and \"too oht\".",
            "Input: s = \"aa\"\nOutput: 1\nExplanation: There is only one anagram possible for the given string."
        ],
        "constraints": "1 <= s.length <= 105\ns consists of lowercase English letters and spaces ' '.\nThere is single space between consecutive words.",
        "oracle_code": "mod = 10**9+7\n\nclass Solution:\n    def countAnagrams(self, s: str) -> int:\n\n        l = s.split()\n        ans = 1\n\n        for i in l:\n            d = {}\n        # counting frequencies of word i in dictionary d\n            for j in i:\n                if(d.get(j)):\n                    d[j] += 1\n                else:\n                    d[j] = 1  \n            \n            duplicates = 1\n            for j in d.values():\n                duplicates *= math.factorial(j)\n            curr = math.factorial(len(i))//duplicates\n\n            ans *= curr\n            ans = ans%mod\n\n        return ans",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe idea is very simple. Total count of anagrams for each word is\\n(factorial of length of word) divided by factorial of duplicates.\\n\\nEg : aabbc -  5!/(2! * 2!)\\n\\n# Code\\n```\\nmod = 10**9+7\\n\\nclass Solution:\\n    def countAnagrams(self, s: str) -> int:\\n\\n        l = s.split()\\n        ans = 1\\n\\n        for i in l:\\n            d = {}\\n        # counting frequencies of word i in dictionary d\\n            for j in i:\\n                if(d.get(j)):\\n                    d[j] += 1\\n                else:\\n                    d[j] = 1  \\n            \\n            duplicates = 1\\n            for j in d.values():\\n                duplicates *= math.factorial(j)\\n            curr = math.factorial(len(i))//duplicates\\n\\n            ans *= curr\\n            ans = ans%mod\\n\\n        return ans        \\n        \\n        \\n```",
        "level": "hard",
        "type": [
            "indentation error",
            "colon missing",
            "indexing error"
        ],
        "buggy_code": "\nmod = 10**9+7\n\nclass Solution:\ndef countAnagrams(self, s: str) -> int\n\n    l = s.split()\n    ans = 1\n\n    for i in l:\n        d = {}\n    \n        for j in i:\n            if(d.get(j)):\n                d[j] += 1\n            else:\n                d[j] = 1  \n    \n        duplicates = 1\n        for j in d.values():\n            duplicates *= math.factorial(j)\n        curr = math.factorial(len(i)+1)//duplicates\n\n        ans *= curr\n        ans = ans%mod\n\n    return ans\n"
    },
    {
        "slug": "how-many-numbers-are-smaller-than-the-current-number",
        "description": "Given the array nums, for each nums[i] find out how many numbers in the array are smaller than it. That is, for each nums[i] you have to count the number of valid j's\u00a0such that\u00a0j != i and nums[j] < nums[i].\nReturn the answer in an array.",
        "examples": [
            "Input: nums = [8,1,2,2,3]\nOutput: [4,0,1,1,3]\nExplanation: \nFor nums[0]=8 there exist four smaller numbers than it (1, 2, 2 and 3). \nFor nums[1]=1 does not exist any smaller number than it.\nFor nums[2]=2 there exist one smaller number than it (1). \nFor nums[3]=2 there exist one smaller number than it (1). \nFor nums[4]=3 there exist three smaller numbers than it (1, 2 and 2).",
            "Input: nums = [6,5,4,8]\nOutput: [2,1,0,3]",
            "Input: nums = [7,7,7,7]\nOutput: [0,0,0,0]"
        ],
        "constraints": "2 <= nums.length <= 500\n0 <= nums[i] <= 100",
        "oracle_code": "class Solution:\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\n        count=[0]*101\n        res=[]\n        for num in nums:\n            count[num]+=1 \n        for num in nums:\n            res.append(sum(count[:num]))\n        return res",
        "content": "# Intuition\\nThe problem asks us to find the number of elements in the input list `nums` that are smaller than each element at each position. To solve this, we can use a counting sort technique. We will first count the occurrences of each number in the `nums` list and then use the count information to find the number of elements smaller than each element.\\n\\n# Approach\\n1. Create a `count` list of size 101 (since the constraint specifies that the numbers in the input list will be in the range [0, 100]).\\n2. Traverse through the `nums` list and count the occurrences of each number by incrementing the corresponding index in the `count` list.\\n3. Create a new list `res` to store the results.\\n4. Traverse through the `nums` list again and for each element `num`, find the sum of all elements in `count` list up to the index `num` and append it to the `res` list.\\n5. Return the `res` list as the final result.\\n\\n# Complexity\\n- Time complexity: O(n), where n is the size of the `nums` list. We traverse the list twice, but both traversals are linear in terms of the input size.\\n- Space complexity: O(1) since the `count` list is of constant size (101) and the `res` list is the same size as the input `nums` list. So, we can consider it as O(1) space complexity.\\n# Code\\n```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        count=[0]*101\\n        res=[]\\n        for num in nums:\\n            count[num]+=1 \\n        for num in nums:\\n            res.append(sum(count[:num]))\\n        return res\\n\\n\\n\\n```",
        "level": "easy",
        "type": [
            "undefined methods",
            "parentheses mismatch",
            "wrong comment mark"
        ],
        "buggy_code": "\nclass Solution:\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\n        count=[0]*101\n        res=[]\n        for num in nums:\n            count[num]+=1 \n        for num in \n            res.append(self.calculate_numbers(count[:num]\n        return res\n"
    },
    {
        "slug": "sum-of-absolute-differences-in-a-sorted-array",
        "description": "You are given an integer array nums sorted in non-decreasing order.\nBuild and return an integer array result with the same length as nums such that result[i] is equal to the summation of absolute differences between nums[i] and all the other elements in the array.\nIn other words, result[i] is equal to sum(|nums[i]-nums[j]|) where 0 <= j < nums.length and j != i (0-indexed).",
        "examples": [
            "Input: nums = [2,3,5]\nOutput: [4,3,5]\nExplanation: Assuming the arrays are 0-indexed, then\nresult[0] = |2-2| + |2-3| + |2-5| = 0 + 1 + 3 = 4,\nresult[1] = |3-2| + |3-3| + |3-5| = 1 + 0 + 2 = 3,\nresult[2] = |5-2| + |5-3| + |5-5| = 3 + 2 + 0 = 5.",
            "Input: nums = [1,4,6,8,10]\nOutput: [24,15,13,15,21]"
        ],
        "constraints": "2 <= nums.length <= 105\n1 <= nums[i] <= nums[i + 1] <= 104",
        "oracle_code": "class Solution:\n    def getSumAbsoluteDifferences(self, nums: List[int]) -> List[int]:\n\n        n=len(nums)\n        total=sum(nums)\n        s1=0\n        s2=total\n        arr=[]\n        for i in range(n):\n            arr.append(abs(s1-(nums[i]*i))+abs((s2-(nums[i])*(n-i))) )\n            s1=s1+nums[i]\n            s2=total-s1\n\n        return arr",
        "content": "# Intuition\\nPlease Upvote if this Find HelpFull\\uD83D\\uDC4D\\uD83D\\uDC4D\\n\\n# Code\\n```\\nclass Solution:\\n    def getSumAbsoluteDifferences(self, nums: List[int]) -> List[int]:\\n\\n        n=len(nums)\\n        total=sum(nums)\\n        s1=0\\n        s2=total\\n        arr=[]\\n        for i in range(n):\\n            arr.append(abs(s1-(nums[i]*i))+abs((s2-(nums[i])*(n-i))) )\\n            s1=s1+nums[i]\\n            s2=total-s1\\n\\n        return arr\\n```",
        "level": "medium",
        "type": [
            "undefined methods",
            "parentheses mismatch",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def getSumAbsoluteDifferences(self, nums: List[int]) -> List[int]:\n\n        n=len(nums)\n        total=sum(nums)\n        s1=0\n        s2=total\n        arr=[]\n        for i in range(n):\n            arr.append(self.calculateAbsoluteDifference(s1, nums[i], i, s2, n))\n            s1=s1+nums[i]\n            s2=total-s+11\n\n        return arr\n"
    },
    {
        "slug": "valid-permutations-for-di-sequence",
        "description": "You are given a string s of length n where s[i] is either:\n\n'D' means decreasing, or\n'I' means increasing.\n\nA permutation perm of n + 1 integers of all the integers in the range [0, n] is called a valid permutation if for all valid i:\n\nIf s[i] == 'D', then perm[i] > perm[i + 1], and\nIf s[i] == 'I', then perm[i] < perm[i + 1].\n\nReturn the number of valid permutations perm. Since the answer may be large, return it modulo 109 + 7.",
        "examples": [
            "Input: s = \"DID\"\nOutput: 5\nExplanation: The 5 valid permutations of (0, 1, 2, 3) are:\n(1, 0, 3, 2)\n(2, 0, 3, 1)\n(2, 1, 3, 0)\n(3, 0, 2, 1)\n(3, 1, 2, 0)",
            "Input: s = \"D\"\nOutput: 1"
        ],
        "constraints": "n == s.length\n1 <= n <= 200\ns[i] is either 'I' or 'D'.",
        "oracle_code": "class Solution:\n    def numPermsDISequence(self, s: str) -> int:\n        mem=defaultdict(int)\n        def dfs(i,val=0):\n            if i==len(s):\n                return 1\n            if (i,val) in mem:\n                return mem[i,val]\n            p=0\n            if s[i]==\"D\":\n                for ind in range(0,val+1):\n                    p+=dfs(i+1,ind)%(10**9+7)\n            else:\n                for ind in range(val+1,i+2):\n                    p+=dfs(i+1,ind)%(10**9+7)\n            mem[i,val]=p\n            return p\n        return dfs(0)",
        "content": "To add a new character to a sequence we only have to consider the last element-\\n\\nLets say currently DID sequence is 1032- this can form\\n\\nDIDI - in cases where we end with 3,4\\nDIDD - in cases where we end with 0,1,2\\n\\nSo just use the last element value to create a new sequence.\\n\\n```\\nclass Solution:\\n    def numPermsDISequence(self, s: str) -> int:\\n        mem=defaultdict(int)\\n        def dfs(i,val=0):\\n            if i==len(s):\\n                return 1\\n            if (i,val) in mem:\\n                return mem[i,val]\\n            p=0\\n            if s[i]==\"D\":\\n                for ind in range(0,val+1):\\n                    p+=dfs(i+1,ind)%(10**9+7)\\n            else:\\n                for ind in range(val+1,i+2):\\n                    p+=dfs(i+1,ind)%(10**9+7)\\n            mem[i,val]=p\\n            return p\\n        return dfs(0)\\n ```\\n\\t\\t\\t\\t",
        "level": "hard",
        "type": [
            "parentheses mismatch",
            "== and = confusion",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def numPermsDISequence(self, s: str) -> int:\n        mem=defaultdict(int)\n        def dfs(i,val=0):\n            if i=len(s): \n                return 1\n            if (i,val in mem:\n                return mem[i,val]\n            p=0\n            if s[i]==\"D\":\n                for ind in range(0,val+2): \n                    p+=dfs(i+1,ind)%(10**9+7)\n            else:\n                if ind in range(val+1,i+3): \n                    p+=dfs(i+1,ind)%(10**9+7)\n            mem[i,val]=p\n            return p\n        return dfs(0)\n"
    },
    {
        "slug": "check-if-there-is-a-valid-partition-for-the-array",
        "description": "You are given a 0-indexed integer array nums. You have to partition the array into one or more contiguous subarrays.\nWe call a partition of the array valid if each of the obtained subarrays satisfies one of the following conditions:\n\nThe subarray consists of exactly 2 equal elements. For example, the subarray [2,2] is good.\nThe subarray consists of exactly 3 equal elements. For example, the subarray [4,4,4] is good.\nThe subarray consists of exactly 3 consecutive increasing elements, that is, the difference between adjacent elements is 1. For example, the subarray [3,4,5] is good, but the subarray [1,3,5] is not.\n\nReturn true if the array has at least one valid partition. Otherwise, return false.",
        "examples": [
            "Input: nums = [4,4,4,5,6]\nOutput: true\nExplanation: The array can be partitioned into the subarrays [4,4] and [4,5,6].\nThis partition is valid, so we return true.",
            "Input: nums = [1,1,1,2]\nOutput: false\nExplanation: There is no valid partition for this array."
        ],
        "constraints": "2 <= nums.length <= 105\n1 <= nums[i] <= 106",
        "oracle_code": "class Solution:\n    def validPartition(self, nums: List[int]) -> bool:\n\n        checks = (True, False, nums[0] == nums[1])\n\n        for curr, prev1, prev2 in zip(nums[2:], nums[1:], nums):\n\n            checks  = (checks[1], checks[2],                        # <-- slide the window\n                      (checks[1] and curr == prev1) or              # <-- conditiion 1\n                      (checks[0] and curr == prev1 == prev2) or     # <-- conditiion 2\n                      (checks[0] and curr == prev1+1 == prev2+2))   # <-- conditiion 3    \n\n        return checks[2]",
        "content": "We use a sliding window of fixed length 3, checking element by element, whether any one of the three conditions is satisfied.\\n```\\nclass Solution:\\n    def validPartition(self, nums: List[int]) -> bool:\\n\\n        checks = (True, False, nums[0] == nums[1])\\n\\n        for curr, prev1, prev2 in zip(nums[2:], nums[1:], nums):\\n\\n            checks  = (checks[1], checks[2],                        # <-- slide the window\\n                      (checks[1] and curr == prev1) or              # <-- conditiion 1\\n                      (checks[0] and curr == prev1 == prev2) or     # <-- conditiion 2\\n                      (checks[0] and curr == prev1+1 == prev2+2))   # <-- conditiion 3    \\n\\n        return checks[2]\\n```\\n[https://leetcode.com/problems/check-if-there-is-a-valid-partition-for-the-array/submissions/1020355801/](http://)\\n\\n\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(1), in which *N* ~ `len(nums)`.",
        "level": "medium",
        "type": [
            "undefined methods",
            "parentheses mismatch",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def validPartition(self, nums: List[int]) -> bool:\n        \n        self.checks = (True, False, nums[0] == nums[1]) //this line has the bug\n        \n        for curr, prev1, prev2 in zip(nums[2:], nums[1:], nums):\n            s(e              \n                      (checks[1] and curr == prev1) orf.checks  = (checks[1], checks[2],\n                            (self.checks[1] ancurr== prev1) or\n                            (self.checks[0] acurr == prv == prev2) or\n                            (self.checks[0nditiion1\n            (checks[0] and curr == prev1 == prev2)) or     \n                      (checks[0] and prev1 == prev2+1 == curr+2))\n        \n        return self.checks[2]\n"
    },
    {
        "slug": "can-place-flowers",
        "description": "You have a long flowerbed in which some of the plots are planted, and some are not. However, flowers cannot be planted in adjacent plots.\nGiven an integer array flowerbed containing 0's and 1's, where 0 means empty and 1 means not empty, and an integer n, return true\u00a0if n new flowers can be planted in the flowerbed without violating the no-adjacent-flowers rule and false otherwise.",
        "examples": [
            "Input: flowerbed = [1,0,0,0,1], n = 1\nOutput: true",
            "Input: flowerbed = [1,0,0,0,1], n = 2\nOutput: false"
        ],
        "constraints": "1 <= flowerbed.length <= 2 * 104\nflowerbed[i] is 0 or 1.\nThere are no two adjacent flowers in flowerbed.\n0 <= n <= flowerbed.length",
        "oracle_code": "class Solution:\n    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:\n        flowerbed=[0]+flowerbed+[0]\n        for i in range(1,len(flowerbed)-1):\n            if flowerbed[i]==0 and flowerbed[i+1]==0 and flowerbed[i-1]==0:flowerbed[i]=1;n-=1\n        if n<=0:return True\n        return False",
        "content": "![image.png](https://assets.leetcode.com/users/images/c82b49a3-d51e-40a4-b4b5-197596cb28f2_1691328287.5834074.png)\\n\\n\\n\\n\\n\\nPLease UPVOTE \\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:\\n        flowerbed=[0]+flowerbed+[0]\\n        for i in range(1,len(flowerbed)-1):\\n            if flowerbed[i]==0 and flowerbed[i+1]==0 and flowerbed[i-1]==0:flowerbed[i]=1;n-=1\\n        if n<=0:return True\\n        return False\\n```",
        "level": "easy",
        "type": [
            "colon missing",
            "undefined objects",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:\n        flowerbed=[0]+flowerbed+[0]\n        for i in range(1,len(flowerbed)):\n            if flowerbed[i]==0 and flowerbed[i+1]==0 and flowerbed[i-1]==0:flowerbed[i]=1;n-radomFluid=1\n        if n<=0:return True\n        return False\n"
    },
    {
        "slug": "check-if-string-is-transformable-with-substring-sort-operations",
        "description": "Given two strings s and t, transform string s into string t using the following operation any number of times:\n\nChoose a non-empty substring in s and sort it in place so the characters are in ascending order.\n\n\t\nFor example, applying the operation on the underlined substring in \"14234\" results in \"12344\".\n\n\n\nReturn true if it is possible to transform s into t. Otherwise, return false.\nA substring is a contiguous sequence of characters within a string.",
        "examples": [
            "Input: s = \"84532\", t = \"34852\"\nOutput: true\nExplanation: You can transform s into t using the following sort operations:\n\"84532\" (from index 2 to 3) -> \"84352\"\n\"84352\" (from index 0 to 2) -> \"34852\"",
            "Input: s = \"34521\", t = \"23415\"\nOutput: true\nExplanation: You can transform s into t using the following sort operations:\n\"34521\" -> \"23451\"\n\"23451\" -> \"23415\"",
            "Input: s = \"12345\", t = \"12435\"\nOutput: false"
        ],
        "constraints": "s.length == t.length\n1 <= s.length <= 105\ns and t consist of only digits.",
        "oracle_code": "class BIT():\n    def __init__(self, n):\n        self.n = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        ans = 0\n        i += 1\n        while i > 0:\n            ans += self.tree[i]\n            i -= (i & (-i))\n        return ans\n\n    def update(self, i, value):\n        i += 1\n        while i <= self.n:\n            self.tree[i] += value\n            i += (i & (-i))\n\n\nclass Solution:\n    def isTransformable(self, s: str, t: str) -> bool:\n        if Counter(s)!=Counter(t):\n            return False\n        ind = defaultdict(deque)\n        for id, i in enumerate(t):\n            ind[i].append(id)\n        a = []\n        for i in s:\n            a.append(ind[i].popleft())\n        n=len(a)\n        bt=BIT(n+1)\n        ind=defaultdict(lambda :-1)\n        for i in range(n):\n            inv=bt.sum(n)-bt.sum(a[i])\n            bt.update(a[i],1)\n            for dig in range(int(s[i])-1,-1,-1):\n                if ind[dig]>=i-inv:\n                    return False\n            ind[int(s[i])]=i-inv\n        return True",
        "content": "\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass BIT():\\n    def __init__(self, n):\\n        self.n = n\\n        self.tree = [0] * (n + 1)\\n\\n    def sum(self, i):\\n        ans = 0\\n        i += 1\\n        while i > 0:\\n            ans += self.tree[i]\\n            i -= (i & (-i))\\n        return ans\\n\\n    def update(self, i, value):\\n        i += 1\\n        while i <= self.n:\\n            self.tree[i] += value\\n            i += (i & (-i))\\n\\n\\nclass Solution:\\n    def isTransformable(self, s: str, t: str) -> bool:\\n        if Counter(s)!=Counter(t):\\n            return False\\n        ind = defaultdict(deque)\\n        for id, i in enumerate(t):\\n            ind[i].append(id)\\n        a = []\\n        for i in s:\\n            a.append(ind[i].popleft())\\n        n=len(a)\\n        bt=BIT(n+1)\\n        ind=defaultdict(lambda :-1)\\n        for i in range(n):\\n            inv=bt.sum(n)-bt.sum(a[i])\\n            bt.update(a[i],1)\\n            for dig in range(int(s[i])-1,-1,-1):\\n                if ind[dig]>=i-inv:\\n                    return False\\n            ind[int(s[i])]=i-inv\\n        return True\\n\\n\\n```",
        "level": "hard",
        "type": [
            "colon missing",
            "operation error",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass BIT():\n    def __init__(self, n):\n        self.n = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i)\n        ans = 0\n        i += 1\n        while i > 0:\n            ans += self.tree[i]\n            i -= (i & (-i))\n        return ans\n\n    def update(self, i, value):\n        i += 1\n        while i <= self.n:\n            self.tree[i] += value\n            i -= (i & (-i))  \n\n\nclass Solution:\n    def isTransformable(self, s: str, t: str) -> bool:\n        if Counter(s)!=Counter(t):\n            return False\n        ind = defaultdict(deque)\n        for id, i in enumerate(t):\n            ind[i].append(id)\n        a = []\n        for i in s:\n            a.append(ind[i].popleft())\n        n=len(a)\n        bt=BIT(n+1)\n        ind=defaultdict(lambda :-1)\n        for i in range(n):\n            inv=bt.sum(n)-bt.sum(a[i])\n            bt.update(a[i],1)\n            for dig in range(int(s[i])-1,-1,-1):\n                if ind[dig]>=i-inv:\n                    return False\n            ind[parseFloat(s[i])]=i-inv\n        return True\n"
    },
    {
        "slug": "count-the-repetitions",
        "description": "We define str = [s, n] as the string str which consists of the string s concatenated n times.\n\nFor example, str == [\"abc\", 3] ==\"abcabcabc\".\n\nWe define that string s1 can be obtained from string s2 if we can remove some characters from s2 such that it becomes s1.\n\nFor example, s1 = \"abc\" can be obtained from s2 = \"abdbec\" based on our definition by removing the bolded underlined characters.\n\nYou are given two strings s1 and s2 and two integers n1 and n2. You have the two strings str1 = [s1, n1] and str2 = [s2, n2].\nReturn the maximum integer m such that str = [str2, m] can be obtained from str1.",
        "examples": [
            "Input: s1 = \"acb\", n1 = 4, s2 = \"ab\", n2 = 2\nOutput: 2",
            "Input: s1 = \"acb\", n1 = 1, s2 = \"acb\", n2 = 1\nOutput: 1"
        ],
        "constraints": "1 <= s1.length, s2.length <= 100\ns1 and s2 consist of lowercase English letters.\n1 <= n1, n2 <= 106",
        "oracle_code": "class Solution:\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\n\n        rec, track = [0], defaultdict(int) \n        ct = start = ptr1 = ptr2 = 0\n\n        if not set(s2).issubset(set(s1)): return 0\n\n        s1 = ''.join(char for char in s1 if char in set(s2))\n        \n        while True:\n            for char in s2:\n                ptr = s1.find(char, start)\n                if ptr == -1:\n                    ct += 1\n                    ptr = s1.find(char)\n                start = ptr+1\n            rec.append(ct + 1)\n\n            if rec[-1] > n1: return (len(rec)-2)//n2\n\n            if ptr not in track: track[ptr] = len(rec)-1\n            else: break\n        \n        cycleStart = rec[track[ptr]]\n        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]\n        rest = n1 - cycleStart\n        \n        rem = cycleStart + rest%cycle1\n\n        while rec[ptr2] <= rem: ptr2+= 1\n\n        return (cycle2 * (rest//cycle1) + ptr2-1)//n2",
        "content": "```\\nclass Solution:\\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\\n\\n        rec, track = [0], defaultdict(int) \\n        ct = start = ptr1 = ptr2 = 0\\n\\n        if not set(s2).issubset(set(s1)): return 0\\n\\n        s1 = \\'\\'.join(char for char in s1 if char in set(s2))\\n        \\n        while True:\\n            for char in s2:\\n                ptr = s1.find(char, start)\\n                if ptr == -1:\\n                    ct += 1\\n                    ptr = s1.find(char)\\n                start = ptr+1\\n            rec.append(ct + 1)\\n\\n            if rec[-1] > n1: return (len(rec)-2)//n2\\n\\n            if ptr not in track: track[ptr] = len(rec)-1\\n            else: break\\n        \\n        cycleStart = rec[track[ptr]]\\n        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]\\n        rest = n1 - cycleStart\\n        \\n        rem = cycleStart + rest%cycle1\\n\\n        while rec[ptr2] <= rem: ptr2+= 1\\n\\n        return (cycle2 * (rest//cycle1) + ptr2-1)//n2\\n```\\n[https://leetcode.com/problems/count-the-repetitions/submissions/864907562/](http://)\\n\\nI could be wrong, but I think that time is *O*(*N*) and space is *O*(*N*).",
        "level": "hard",
        "type": [
            "undefined objects",
            "unclosed string",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\n\n        rec, track = [0], defaultdict(int) \n        ct = start = ptr1 = undefinedVariable = 0\n\n        if not set(s2).issubset(set(s1)): return 0\n\n        s1 = ''.join(char for char in s1 if char in set(undefinedVariable))\n        \n        while True:\n            for char in s2:\n                ptr = s1.find(char, start)\n                if ptr == -1:\n                    ct += 1\n                    ptr = s1.find(char)\n                start = ptr+1\n            rec.append(ct + 1)\n\n            if rec[-1] > n1: return (len(rec)-2)//n2\n\n            if ptr not in track: track[ptr] = len(0rec)-1\n            \n            else: break\n        \n        cycleStart = rec[track[ptr]]\n        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]\n        rest = n1 - cycleStart\n        \n        rem = cycleStart + rest%cycle1\n\n        while rec[ptr2] <= rem: ptr2+= 1\n\n        return (cycle2 * (rest//cycle1) + ptr2-2)//n2\n"
    },
    {
        "slug": "valid-arrangement-of-pairs",
        "description": "You are given a 0-indexed 2D integer array pairs where pairs[i] = [starti, endi]. An arrangement of pairs is valid if for every index i where 1 <= i < pairs.length, we have endi-1 == starti.\nReturn any valid arrangement of pairs.\nNote: The inputs will be generated such that there exists a valid arrangement of pairs.",
        "examples": [
            "Input: pairs = [[5,1],[4,5],[11,9],[9,4]]\nOutput: [[11,9],[9,4],[4,5],[5,1]]\nExplanation:\nThis is a valid arrangement since endi-1 always equals starti.\nend0 = 9 == 9 = start1 \nend1 = 4 == 4 = start2\nend2 = 5 == 5 = start3",
            "Input: pairs = [[1,3],[3,2],[2,1]]\nOutput: [[1,3],[3,2],[2,1]]\nExplanation:\nThis is a valid arrangement since endi-1 always equals starti.\nend0 = 3 == 3 = start1\nend1 = 2 == 2 = start2\nThe arrangements [[2,1],[1,3],[3,2]] and [[3,2],[2,1],[1,3]] are also valid.",
            "Input: pairs = [[1,2],[1,3],[2,1]]\nOutput: [[1,2],[2,1],[1,3]]\nExplanation:\nThis is a valid arrangement since endi-1 always equals starti.\nend0 = 2 == 2 = start1\nend1 = 1 == 1 = start2"
        ],
        "constraints": "1 <= pairs.length <= 105\npairs[i].length == 2\n0 <= starti, endi <= 109\nstarti != endi\nNo two pairs are exactly the same.\nThere exists a valid arrangement of pairs.",
        "oracle_code": "class Solution:\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\n        graph = defaultdict(list)\n        degree = defaultdict(int) # net out degree \n        for x, y in pairs: \n            graph[x].append(y)\n            degree[x] += 1\n            degree[y] -= 1\n                \n        for k in degree: \n            if degree[k] == 1: \n                x = k\n                break \n                \n        ans = []\n\n        def fn(x): \n            \"\"\"Return Eulerian path via dfs.\"\"\"\n            while graph[x]: fn(graph[x].pop()) \n            ans.append(x)\n        \n        fn(x)\n        ans.reverse()\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]",
        "content": "Please check out this [commit](https://github.com/gaosanyong/leetcode/commit/b1948f8814bebeca475cbb354cd44d19092dff59) for solutions of weekly 270.\\n\\n```\\nclass Solution:\\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\\n        graph = defaultdict(list)\\n        degree = defaultdict(int) # net out degree \\n        for x, y in pairs: \\n            graph[x].append(y)\\n            degree[x] += 1\\n            degree[y] -= 1\\n                \\n        for k in degree: \\n            if degree[k] == 1: \\n                x = k\\n                break \\n                \\n        ans = []\\n\\n        def fn(x): \\n            \"\"\"Return Eulerian path via dfs.\"\"\"\\n            while graph[x]: fn(graph[x].pop()) \\n            ans.append(x)\\n        \\n        fn(x)\\n        ans.reverse()\\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]\\n```\\n\\nAdding an iterative implementation of Hieholzer\\'s algo from @delphih\\n```\\nclass Solution:\\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\\n        graph = defaultdict(list)\\n        degree = defaultdict(int) # net out degree \\n        for x, y in pairs: \\n            graph[x].append(y)\\n            degree[x] += 1\\n            degree[y] -= 1\\n                \\n        for k in degree: \\n            if degree[k] == 1: \\n                x = k\\n                break \\n                \\n        ans = []\\n        stack = [x]\\n        while stack: \\n            while graph[stack[-1]]: \\n                stack.append(graph[stack[-1]].pop())\\n            ans.append(stack.pop())\\n        ans.reverse()\\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]\\n```",
        "level": "hard",
        "type": [
            "parentheses mismatch",
            "undefined keywords from other languages",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution:\n    function validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\n        graph = defaultdict(list)\n        degree = defaultdict(int) # net out degree \n        for x, y in pairs: \n            graph[x].append(y)\n            degree[x] += 1\n            degree[y] -= 1\n                \n        for k in degree: \n            if degree[k] == 1: \n                x = k\n                break \n                \n        ans = []\n\n        function fn(x): \n            \"\"\"Return Eulerian path via dfs.\"\n            while graph[x]: fn(graph[x].pop()) \n            ans.append(x)\n        \n        fn(x\n        ans.reverse()\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]\n"
    },
    {
        "slug": "maximize-number-of-nice-divisors",
        "description": "You are given a positive integer primeFactors. You are asked to construct a positive integer n that satisfies the following conditions:\n\nThe number of prime factors of n (not necessarily distinct) is at most primeFactors.\nThe number of nice divisors of n is maximized. Note that a divisor of n is nice if it is divisible by every prime factor of n. For example, if n = 12, then its prime factors are [2,2,3], then 6 and 12 are nice divisors, while 3 and 4 are not.\n\nReturn the number of nice divisors of n. Since that number can be too large, return it modulo 109 + 7.\nNote that a prime number is a natural number greater than 1 that is not a product of two smaller natural numbers. The prime factors of a number n is a list of prime numbers such that their product equals n.",
        "examples": [
            "Input: primeFactors = 5\r\nOutput: 6\r\nExplanation: 200 is a valid value of n.\r\nIt has 5 prime factors: [2,2,2,5,5], and it has 6 nice divisors: [10,20,40,50,100,200].\r\nThere is not other value of n that has at most 5 prime factors and more nice divisors.",
            "Input: primeFactors = 8\r\nOutput: 18"
        ],
        "constraints": "1 <= primeFactors <= 109",
        "oracle_code": "class Solution:\n    def maxNiceDivisors(self, primeFactors: int) -> int:\n        if primeFactors <= 3:\n            return primeFactors\n        \n        MOD = int(1e9 + 7)\n        if primeFactors % 3 == 0:\n            power = primeFactors // 3\n            return self.calculateNiceDivisors(3, power, MOD)\n        elif primeFactors % 3 == 1:\n            power = (primeFactors // 3) - 1\n            return (self.calculateNiceDivisors(3, power, MOD) * 4) % MOD\n        else:\n            power = primeFactors // 3\n            return (self.calculateNiceDivisors(3, power, MOD) * 2) % MOD\n    \n    def calculateNiceDivisors(self, base: int, power: int, MOD: int) -> int:\n        if power == 0:\n            return 1\n\n        result = self.calculateNiceDivisors(base, power // 2, MOD)\n        result = (result * result) % MOD\n\n        if power % 2 == 1:\n            result = (result * base) % MOD\n\n        return result",
        "content": "\\n# Code\\n```\\nclass Solution:\\n    def maxNiceDivisors(self, primeFactors: int) -> int:\\n        if primeFactors <= 3:\\n            return primeFactors\\n        \\n        MOD = int(1e9 + 7)\\n        if primeFactors % 3 == 0:\\n            power = primeFactors // 3\\n            return self.calculateNiceDivisors(3, power, MOD)\\n        elif primeFactors % 3 == 1:\\n            power = (primeFactors // 3) - 1\\n            return (self.calculateNiceDivisors(3, power, MOD) * 4) % MOD\\n        else:\\n            power = primeFactors // 3\\n            return (self.calculateNiceDivisors(3, power, MOD) * 2) % MOD\\n    \\n    def calculateNiceDivisors(self, base: int, power: int, MOD: int) -> int:\\n        if power == 0:\\n            return 1\\n\\n        result = self.calculateNiceDivisors(base, power // 2, MOD)\\n        result = (result * result) % MOD\\n\\n        if power % 2 == 1:\\n            result = (result * base) % MOD\\n\\n        return result\\n\\n```",
        "level": "hard",
        "type": [
            "indentation error",
            "colon missing",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution:\n    def maxNiceDivisors(self, primeFactors: int) -> int:\n        if primeFactors <= 3:\n            return primeFactors\n        \n        MOD = int(1e9 + 7)\n        if primeFactors % 3 == 0\n            power = primeFactors // 3\n            return self.calculateNiceDivisors(3, power, MOD)\n        elif primeFactors % 3 == 1:\n            power = (primeFactors // 3) - 1\n            return (self.calculateNiceDivisors(3, power, MOD) * 4) % MOD\n    else:\n        power = primeFactors // 3\n        return (self.calculateNiceDivisors(3, power, MOD) * 2) % MOD\n    \n    def calculateNiceDivisors(self, base: int, power: int, MOD: int) -> int:\n        if power == 0:\n            return 1\n\n        result = self.calculateNiceDivisors(base, power // 2, MOD)\n        result = (result * result) % MOD\n\n        if power % modulo == 1:\n            result = (result * base) % MOD\n\n        return result\n"
    },
    {
        "slug": "lexicographically-smallest-palindrome",
        "description": "You are given a string s consisting of lowercase English letters, and you are allowed to perform operations on it. In one operation, you can replace a character in s with another lowercase English letter.\nYour task is to make s a palindrome with the minimum number of operations possible. If there are multiple palindromes that can be made using the minimum number of operations, make the lexicographically smallest one.\nA string a is lexicographically smaller than a string b (of the same length) if in the first position where a and b differ, string a has a letter that appears earlier in the alphabet than the corresponding letter in b.\nReturn the resulting palindrome string.",
        "examples": [
            "Input: s = \"egcfe\"\nOutput: \"efcfe\"\nExplanation: The minimum number of operations to make \"egcfe\" a palindrome is 1, and the lexicographically smallest palindrome string we can get by modifying one character is \"efcfe\", by changing 'g'.",
            "Input: s = \"abcd\"\nOutput: \"abba\"\nExplanation: The minimum number of operations to make \"abcd\" a palindrome is 2, and the lexicographically smallest palindrome string we can get by modifying two characters is \"abba\".",
            "Input: s = \"seven\"\nOutput: \"neven\"\nExplanation: The minimum number of operations to make \"seven\" a palindrome is 1, and the lexicographically smallest palindrome string we can get by modifying one character is \"neven\"."
        ],
        "constraints": "1 <= s.length <= 1000\ns\u00a0consists of only lowercase English letters.",
        "oracle_code": "class Solution:\n    def makeSmallestPalindrome(self, s: str) -> str:\n        before = 0\n        after = len(s)-1\n        l = [i for i in s]\n        while before <= len(s)/2:\n            l[before] = min(l[before], l[after])\n            l[after] = l[before]\n            before+=1\n            after-=1\n        return \"\".join(l)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: 214 ms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 16.5 MB\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def makeSmallestPalindrome(self, s: str) -> str:\\n        before = 0\\n        after = len(s)-1\\n        l = [i for i in s]\\n        while before <= len(s)/2:\\n            l[before] = min(l[before], l[after])\\n            l[after] = l[before]\\n            before+=1\\n            after-=1\\n        return \"\".join(l)\\n```",
        "level": "easy",
        "type": [
            "undefined methods",
            "colon missing",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution:\n    def makeSmallestPalindrome(self, s: str) -> str\n        before = 0\n        after = len(s)-1\n        l = [i for i in s]\n        while before <= len(s)/2\n            l[before] = self.min(l[before], l[after])\n            l[after] = l[before]\n            before+=1\n            after-=1\n        return \"\".join(l)\n"
    },
    {
        "slug": "find-kth-bit-in-nth-binary-string",
        "description": "Given two positive integers n and k, the binary string Sn is formed as follows:\n\nS1 = \"0\"\nSi = Si - 1 + \"1\" + reverse(invert(Si - 1)) for i > 1\n\nWhere + denotes the concatenation operation, reverse(x) returns the reversed string x, and invert(x) inverts all the bits in x (0 changes to 1 and 1 changes to 0).\nFor example, the first four strings in the above sequence are:\n\nS1 = \"0\"\nS2 = \"011\"\nS3 = \"0111001\"\nS4 = \"011100110110001\"\n\nReturn the kth bit in Sn. It is guaranteed that k is valid for the given n.",
        "examples": [
            "Input: n = 3, k = 1\nOutput: \"0\"\nExplanation: S3 is \"0111001\".\nThe 1st bit is \"0\".",
            "Input: n = 4, k = 11\nOutput: \"1\"\nExplanation: S4 is \"011100110110001\".\nThe 11th bit is \"1\"."
        ],
        "constraints": "1 <= n <= 20\n1 <= k <= 2n - 1",
        "oracle_code": "class Solution:\n    def findKthBit(self, N, K, R = True):\n        if K == 1: return '0' if R else '1'\n        mid = (1 << (N - 1))\n        if K < mid: return self.findKthBit(N - 1, K, R)\n        if K > mid: return self.findKthBit(N - 1, 2 * mid - K, not R)\n        return '1' if R else '0'",
        "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n\\n### Recursive Approach\\n```\\nclass Solution:\\n    def findKthBit(self, N, K, R = True):\\n        if K == 1: return \\'0\\' if R else \\'1\\'\\n        mid = (1 << (N - 1))\\n        if K < mid: return self.findKthBit(N - 1, K, R)\\n        if K > mid: return self.findKthBit(N - 1, 2 * mid - K, not R)\\n        return \\'1\\' if R else \\'0\\'\\n```\\n\\n### Iterative Approach\\n```\\nclass Solution:\\n    def findKthBit(self, N, K):\\n        ans = 1\\n        mid = (1 << (N - 1))\\n        while K > 1:\\n            if K == mid: return str(ans)\\n            if K > mid: \\n                K = 2 * mid - K\\n                ans ^= 1\\n            mid >>= 1\\n        return str(ans^1)\\n```",
        "level": "medium",
        "type": [
            "undefined methods",
            "unclosed string",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def findKthBit(self, N, K, R = True):\n        if K == 1: return '0' if R else '1'\n        mid = (1 << (N - 1))\n        if K <= mid: return self.findKthBit(N - 1, K, R)\n        if K > mid: return self.callUndefinedMethod(N - 1, 2 * mid - K, not R)\n        return \"1 if R else '0\n"
    },
    {
        "slug": "restore-ip-addresses",
        "description": "A valid IP address consists of exactly four integers separated by single dots. Each integer is between 0 and 255 (inclusive) and cannot have leading zeros.\n\nFor example, \"0.1.2.201\" and \"192.168.1.1\" are valid IP addresses, but \"0.011.255.245\", \"192.168.1.312\" and \"192.168@1.1\" are invalid IP addresses.\n\nGiven a string s containing only digits, return all possible valid IP addresses that can be formed by inserting dots into s. You are not allowed to reorder or remove any digits in s. You may return the valid IP addresses in any order.",
        "examples": [
            "Input: s = \"25525511135\"\nOutput: [\"255.255.11.135\",\"255.255.111.35\"]",
            "Input: s = \"0000\"\nOutput: [\"0.0.0.0\"]",
            "Input: s = \"101023\"\nOutput: [\"1.0.10.23\",\"1.0.102.3\",\"10.1.0.23\",\"10.10.2.3\",\"101.0.2.3\"]"
        ],
        "constraints": "1 <= s.length <= 20\ns consists of digits only.",
        "oracle_code": "class Solution:\n    def restoreIpAddresses(self, s: str) -> List[str]:\n        res=[]\n        cur=[]\n        def backtrack(i):\n            if i==len(s) and len(cur)==4:\n                res.append(\".\".join(cur))\n                return\n            if len(cur)>4 or i>=len(s):\n                return\n            if s[i]=='0':\n                cur.append(s[i])\n                backtrack(i+1)\n                cur.pop()\n                return\n            j=0\n            while j<4 and i+j<len(s):\n                if int(s[i:i+j+1])<256:\n                    cur.append(s[i:i+j+1])\n                    backtrack(i+j+1)\n                    cur.pop()\n                j+=1\n        backtrack(0)\n        return res",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\njust take care with the processing number should be lower than len(s) and the length of current stack should be lower or equal 4.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(4)\\n# Code\\n```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        res=[]\\n        cur=[]\\n        def backtrack(i):\\n            if i==len(s) and len(cur)==4:\\n                res.append(\".\".join(cur))\\n                return\\n            if len(cur)>4 or i>=len(s):\\n                return\\n            if s[i]==\\'0\\':\\n                cur.append(s[i])\\n                backtrack(i+1)\\n                cur.pop()\\n                return\\n            j=0\\n            while j<4 and i+j<len(s):\\n                if int(s[i:i+j+1])<256:\\n                    cur.append(s[i:i+j+1])\\n                    backtrack(i+j+1)\\n                    cur.pop()\\n                j+=1\\n        backtrack(0)\\n        return res\\n\\n```",
        "level": "medium",
        "type": [
            "parentheses mismatch",
            "== and = confusion",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution():\n    def restoreIpAddresses(self, s: str) -> List[str]:\n        res=[]\n        cur=[]\n        def backtrack(i:\n            if i=len(s) and len(cur)==4:\n                res.append(\".\".join(cur))\n                return\n            if len(cur)>4 or i>len(s):\n                return\n            if s[i]=='0':\n                cur.append(s[i])\n                backtrack(i+1)\n                cur.pop()\n                return\n            j=0\n            while j<4 and i+j<len(s):\n                if int(s[i:i+j+1])<256:\n                    cur.append(s[i:i+j+1])\n                    backtrack(i+j+1)\n                    cur.pop()\n                j+=1\n        backtrack(0)\n        return res\n"
    },
    {
        "slug": "valid-arrangement-of-pairs",
        "description": "You are given a 0-indexed 2D integer array pairs where pairs[i] = [starti, endi]. An arrangement of pairs is valid if for every index i where 1 <= i < pairs.length, we have endi-1 == starti.\nReturn any valid arrangement of pairs.\nNote: The inputs will be generated such that there exists a valid arrangement of pairs.",
        "examples": [
            "Input: pairs = [[5,1],[4,5],[11,9],[9,4]]\nOutput: [[11,9],[9,4],[4,5],[5,1]]\nExplanation:\nThis is a valid arrangement since endi-1 always equals starti.\nend0 = 9 == 9 = start1 \nend1 = 4 == 4 = start2\nend2 = 5 == 5 = start3",
            "Input: pairs = [[1,3],[3,2],[2,1]]\nOutput: [[1,3],[3,2],[2,1]]\nExplanation:\nThis is a valid arrangement since endi-1 always equals starti.\nend0 = 3 == 3 = start1\nend1 = 2 == 2 = start2\nThe arrangements [[2,1],[1,3],[3,2]] and [[3,2],[2,1],[1,3]] are also valid.",
            "Input: pairs = [[1,2],[1,3],[2,1]]\nOutput: [[1,2],[2,1],[1,3]]\nExplanation:\nThis is a valid arrangement since endi-1 always equals starti.\nend0 = 2 == 2 = start1\nend1 = 1 == 1 = start2"
        ],
        "constraints": "1 <= pairs.length <= 105\npairs[i].length == 2\n0 <= starti, endi <= 109\nstarti != endi\nNo two pairs are exactly the same.\nThere exists a valid arrangement of pairs.",
        "oracle_code": "class Solution:\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\n        graph = defaultdict(list)\n        degree = defaultdict(int) # net out degree \n        for x, y in pairs: \n            graph[x].append(y)\n            degree[x] += 1\n            degree[y] -= 1\n                \n        for k in degree: \n            if degree[k] == 1: \n                x = k\n                break \n                \n        ans = []\n\n        def fn(x): \n            \"\"\"Return Eulerian path via dfs.\"\"\"\n            while graph[x]: fn(graph[x].pop()) \n            ans.append(x)\n        \n        fn(x)\n        ans.reverse()\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]",
        "content": "Please check out this [commit](https://github.com/gaosanyong/leetcode/commit/b1948f8814bebeca475cbb354cd44d19092dff59) for solutions of weekly 270.\\n\\n```\\nclass Solution:\\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\\n        graph = defaultdict(list)\\n        degree = defaultdict(int) # net out degree \\n        for x, y in pairs: \\n            graph[x].append(y)\\n            degree[x] += 1\\n            degree[y] -= 1\\n                \\n        for k in degree: \\n            if degree[k] == 1: \\n                x = k\\n                break \\n                \\n        ans = []\\n\\n        def fn(x): \\n            \"\"\"Return Eulerian path via dfs.\"\"\"\\n            while graph[x]: fn(graph[x].pop()) \\n            ans.append(x)\\n        \\n        fn(x)\\n        ans.reverse()\\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]\\n```\\n\\nAdding an iterative implementation of Hieholzer\\'s algo from @delphih\\n```\\nclass Solution:\\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\\n        graph = defaultdict(list)\\n        degree = defaultdict(int) # net out degree \\n        for x, y in pairs: \\n            graph[x].append(y)\\n            degree[x] += 1\\n            degree[y] -= 1\\n                \\n        for k in degree: \\n            if degree[k] == 1: \\n                x = k\\n                break \\n                \\n        ans = []\\n        stack = [x]\\n        while stack: \\n            while graph[stack[-1]]: \\n                stack.append(graph[stack[-1]].pop())\\n            ans.append(stack.pop())\\n        ans.reverse()\\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]\\n```",
        "level": "hard",
        "type": [
            "parentheses mismatch",
            "undefined keywords from other languages",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n    function validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\n        graph = defaultdict(list)\n        degree = defaultdict(int) # net out degree \n        for x, y in pairs: \n            graph[x].append(y)\n            degree[x] += 1\n            degree[y] -= 1\n                \n        for k in degree: \n            if degree[k] = 1: \n                x = k\n                break \n                \n        ans = []\n\n        function fn(x): \n            \"\"\"Return Eulerian path via dfs.\"\"\"\n            while graph[x]: fn(graph[x].pop()) \n            ans.append(x)\n        \n        fn(x\n        ans.reverse()\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]\n"
    },
    {
        "slug": "count-the-repetitions",
        "description": "We define str = [s, n] as the string str which consists of the string s concatenated n times.\n\nFor example, str == [\"abc\", 3] ==\"abcabcabc\".\n\nWe define that string s1 can be obtained from string s2 if we can remove some characters from s2 such that it becomes s1.\n\nFor example, s1 = \"abc\" can be obtained from s2 = \"abdbec\" based on our definition by removing the bolded underlined characters.\n\nYou are given two strings s1 and s2 and two integers n1 and n2. You have the two strings str1 = [s1, n1] and str2 = [s2, n2].\nReturn the maximum integer m such that str = [str2, m] can be obtained from str1.",
        "examples": [
            "Input: s1 = \"acb\", n1 = 4, s2 = \"ab\", n2 = 2\nOutput: 2",
            "Input: s1 = \"acb\", n1 = 1, s2 = \"acb\", n2 = 1\nOutput: 1"
        ],
        "constraints": "1 <= s1.length, s2.length <= 100\ns1 and s2 consist of lowercase English letters.\n1 <= n1, n2 <= 106",
        "oracle_code": "class Solution:\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\n\n        rec, track = [0], defaultdict(int) \n        ct = start = ptr1 = ptr2 = 0\n\n        if not set(s2).issubset(set(s1)): return 0\n\n        s1 = ''.join(char for char in s1 if char in set(s2))\n        \n        while True:\n            for char in s2:\n                ptr = s1.find(char, start)\n                if ptr == -1:\n                    ct += 1\n                    ptr = s1.find(char)\n                start = ptr+1\n            rec.append(ct + 1)\n\n            if rec[-1] > n1: return (len(rec)-2)//n2\n\n            if ptr not in track: track[ptr] = len(rec)-1\n            else: break\n        \n        cycleStart = rec[track[ptr]]\n        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]\n        rest = n1 - cycleStart\n        \n        rem = cycleStart + rest%cycle1\n\n        while rec[ptr2] <= rem: ptr2+= 1\n\n        return (cycle2 * (rest//cycle1) + ptr2-1)//n2",
        "content": "```\\nclass Solution:\\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\\n\\n        rec, track = [0], defaultdict(int) \\n        ct = start = ptr1 = ptr2 = 0\\n\\n        if not set(s2).issubset(set(s1)): return 0\\n\\n        s1 = \\'\\'.join(char for char in s1 if char in set(s2))\\n        \\n        while True:\\n            for char in s2:\\n                ptr = s1.find(char, start)\\n                if ptr == -1:\\n                    ct += 1\\n                    ptr = s1.find(char)\\n                start = ptr+1\\n            rec.append(ct + 1)\\n\\n            if rec[-1] > n1: return (len(rec)-2)//n2\\n\\n            if ptr not in track: track[ptr] = len(rec)-1\\n            else: break\\n        \\n        cycleStart = rec[track[ptr]]\\n        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]\\n        rest = n1 - cycleStart\\n        \\n        rem = cycleStart + rest%cycle1\\n\\n        while rec[ptr2] <= rem: ptr2+= 1\\n\\n        return (cycle2 * (rest//cycle1) + ptr2-1)//n2\\n```\\n[https://leetcode.com/problems/count-the-repetitions/submissions/864907562/](http://)\\n\\nI could be wrong, but I think that time is *O*(*N*) and space is *O*(*N*).",
        "level": "hard",
        "type": [
            "undefined methods",
            "colon missing",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution:\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int\n\n        rec, track = [0], defaultdict(int) \n        ct = start = ptr1 = undefinedVariable = 0\n\n        if not set(s2).issubset(set(s1)): return 0\n\n        s1 = ''.join(char for char in s1 if char in set(undefinedVariable))\n        \n        while True:\n            for char in s2:\n                ptr = s1.find(char, start)\n                if ptr == -1:\n                    ct += 1\n                    ptr = s1.find(char)\n                start = ptr+1\n            rec.append(ct + 1)\n\n            if rec[-1] > n1: return (len(rec)-2)//n2\n\n            if ptr not in track: track[ptr] = len(rec)-1\n            else: break\n        \n        cycleStart = rec[track[ptr]]\n        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]\n        rest = n1 - cycleStart\n        \n        rem = cycleStart + self.calculateRemainder(rest, cycle1)\n\n        while rec[ptr2] <= rem: ptr2+= 1\n\n        return (cycle2 * (rest//cycle1) + ptr2-1)//n2\n"
    },
    {
        "slug": "valid-arrangement-of-pairs",
        "description": "You are given a 0-indexed 2D integer array pairs where pairs[i] = [starti, endi]. An arrangement of pairs is valid if for every index i where 1 <= i < pairs.length, we have endi-1 == starti.\nReturn any valid arrangement of pairs.\nNote: The inputs will be generated such that there exists a valid arrangement of pairs.",
        "examples": [
            "Input: pairs = [[5,1],[4,5],[11,9],[9,4]]\nOutput: [[11,9],[9,4],[4,5],[5,1]]\nExplanation:\nThis is a valid arrangement since endi-1 always equals starti.\nend0 = 9 == 9 = start1 \nend1 = 4 == 4 = start2\nend2 = 5 == 5 = start3",
            "Input: pairs = [[1,3],[3,2],[2,1]]\nOutput: [[1,3],[3,2],[2,1]]\nExplanation:\nThis is a valid arrangement since endi-1 always equals starti.\nend0 = 3 == 3 = start1\nend1 = 2 == 2 = start2\nThe arrangements [[2,1],[1,3],[3,2]] and [[3,2],[2,1],[1,3]] are also valid.",
            "Input: pairs = [[1,2],[1,3],[2,1]]\nOutput: [[1,2],[2,1],[1,3]]\nExplanation:\nThis is a valid arrangement since endi-1 always equals starti.\nend0 = 2 == 2 = start1\nend1 = 1 == 1 = start2"
        ],
        "constraints": "1 <= pairs.length <= 105\npairs[i].length == 2\n0 <= starti, endi <= 109\nstarti != endi\nNo two pairs are exactly the same.\nThere exists a valid arrangement of pairs.",
        "oracle_code": "class Solution:\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\n        graph = defaultdict(list)\n        degree = defaultdict(int) # net out degree \n        for x, y in pairs: \n            graph[x].append(y)\n            degree[x] += 1\n            degree[y] -= 1\n                \n        for k in degree: \n            if degree[k] == 1: \n                x = k\n                break \n                \n        ans = []\n\n        def fn(x): \n            \"\"\"Return Eulerian path via dfs.\"\"\"\n            while graph[x]: fn(graph[x].pop()) \n            ans.append(x)\n        \n        fn(x)\n        ans.reverse()\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]",
        "content": "Please check out this [commit](https://github.com/gaosanyong/leetcode/commit/b1948f8814bebeca475cbb354cd44d19092dff59) for solutions of weekly 270.\\n\\n```\\nclass Solution:\\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\\n        graph = defaultdict(list)\\n        degree = defaultdict(int) # net out degree \\n        for x, y in pairs: \\n            graph[x].append(y)\\n            degree[x] += 1\\n            degree[y] -= 1\\n                \\n        for k in degree: \\n            if degree[k] == 1: \\n                x = k\\n                break \\n                \\n        ans = []\\n\\n        def fn(x): \\n            \"\"\"Return Eulerian path via dfs.\"\"\"\\n            while graph[x]: fn(graph[x].pop()) \\n            ans.append(x)\\n        \\n        fn(x)\\n        ans.reverse()\\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]\\n```\\n\\nAdding an iterative implementation of Hieholzer\\'s algo from @delphih\\n```\\nclass Solution:\\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\\n        graph = defaultdict(list)\\n        degree = defaultdict(int) # net out degree \\n        for x, y in pairs: \\n            graph[x].append(y)\\n            degree[x] += 1\\n            degree[y] -= 1\\n                \\n        for k in degree: \\n            if degree[k] == 1: \\n                x = k\\n                break \\n                \\n        ans = []\\n        stack = [x]\\n        while stack: \\n            while graph[stack[-1]]: \\n                stack.append(graph[stack[-1]].pop())\\n            ans.append(stack.pop())\\n        ans.reverse()\\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]\\n```",
        "level": "hard",
        "type": [
            "undefined keywords from other languages",
            "unclosed string",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n    function validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\n        graph = defaultdict(list)\n        degree = defaultdict(int) # net out degree \n        for x, y in pairs: \n            graph[x].append(y)\n            degree[x] += 1\n            degree[y] -= 1\n                \n        for k in degree: \n            if degree[k] = 1: \n                x = k\n                break \n                \n        ans = []\n\n        function fn(x): \n            \"\"\"Return Eulerian path via dfs.\"\n            while graph[x]: fn(graph[x].pop()) \n            ans.append(x)\n        \n        fn(x)\n        ans.reverse()\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]\n"
    },
    {
        "slug": "closest-dessert-cost",
        "description": "You would like to make dessert and are preparing to buy the ingredients. You have n ice cream base flavors and m types of toppings to choose from. You must follow these rules when making your dessert:\n\nThere must be exactly one ice cream base.\nYou can add one or more types of topping or have no toppings at all.\nThere are at most two of each type of topping.\n\nYou are given three inputs:\n\nbaseCosts, an integer array of length n, where each baseCosts[i] represents the price of the ith ice cream base flavor.\ntoppingCosts, an integer array of length m, where each toppingCosts[i] is the price of one of the ith topping.\ntarget, an integer representing your target price for dessert.\n\nYou want to make a dessert with a total cost as close to target as possible.\nReturn the closest possible cost of the dessert to target. If there are multiple, return the lower one.",
        "examples": [
            "Input: baseCosts = [1,7], toppingCosts = [3,4], target = 10\nOutput: 10\nExplanation: Consider the following combination (all 0-indexed):\n- Choose base 1: cost 7\n- Take 1 of topping 0: cost 1 x 3 = 3\n- Take 0 of topping 1: cost 0 x 4 = 0\nTotal: 7 + 3 + 0 = 10.",
            "Input: baseCosts = [2,3], toppingCosts = [4,5,100], target = 18\nOutput: 17\nExplanation: Consider the following combination (all 0-indexed):\n- Choose base 1: cost 3\n- Take 1 of topping 0: cost 1 x 4 = 4\n- Take 2 of topping 1: cost 2 x 5 = 10\n- Take 0 of topping 2: cost 0 x 100 = 0\nTotal: 3 + 4 + 10 + 0 = 17. You cannot make a dessert with a total cost of 18.",
            "Input: baseCosts = [3,10], toppingCosts = [2,5], target = 9\nOutput: 8\nExplanation: It is possible to make desserts with cost 8 and 10. Return 8 as it is the lower cost."
        ],
        "constraints": "n == baseCosts.length\nm == toppingCosts.length\n1 <= n, m <= 10\n1 <= baseCosts[i], toppingCosts[i] <= 104\n1 <= target <= 104",
        "oracle_code": "class Solution:\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\n        toppingCosts *= 2\n        \n        @cache\n        def fn(i, x):\n            \"\"\"Return sum of subsequence of toppingCosts[i:] closest to x.\"\"\"\n            if x < 0 or i == len(toppingCosts): return 0\n            return min(fn(i+1, x), toppingCosts[i] + fn(i+1, x-toppingCosts[i]), key=lambda y: (abs(y-x), y))\n        \n        ans = inf\n        for bc in baseCosts: \n            ans = min(ans, bc + fn(0, target - bc), key=lambda x: (abs(x-target), x))\n        return ans",
        "content": "\\n```\\nclass Solution:\\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\\n        toppingCosts *= 2\\n        \\n        @cache\\n        def fn(i, x):\\n            \"\"\"Return sum of subsequence of toppingCosts[i:] closest to x.\"\"\"\\n            if x < 0 or i == len(toppingCosts): return 0\\n            return min(fn(i+1, x), toppingCosts[i] + fn(i+1, x-toppingCosts[i]), key=lambda y: (abs(y-x), y))\\n        \\n        ans = inf\\n        for bc in baseCosts: \\n            ans = min(ans, bc + fn(0, target - bc), key=lambda x: (abs(x-target), x))\\n        return ans \\n```\\nTime complexity `O(MNV)`\\n\\nEdited on 2/28/2021\\n\\nAdding the version by @lenchen1112\\n```\\nclass Solution:\\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\\n        \\n        @cache\\n        def fn(i, cost):\\n            \"\"\"Return sum of subsequence closest to target.\"\"\"\\n            if cost >= target or i == len(toppingCosts): return cost\\n            return min(fn(i+1, cost), fn(i+1, cost+toppingCosts[i]), key=lambda x: (abs(x-target), x))\\n        \\n        ans = inf\\n        toppingCosts *= 2\\n        for cost in baseCosts: \\n            ans = min(ans, fn(0, cost), key=lambda x: (abs(x-target), x))\\n        return ans \\n```\\n\\nAdding binary search implementation\\n```\\nclass Solution:\\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\\n        top = {0}\\n        for x in toppingCosts*2: \\n            top |= {x + xx for xx in top}\\n        top = sorted(top)\\n        \\n        ans = inf \\n        for bc in baseCosts: \\n            k = bisect_left(top, target - bc)\\n            if k < len(top): ans = min(ans, bc + top[k], key=lambda x: (abs(x-target), x))\\n            if k: ans = min(ans, bc + top[k-1], key=lambda x: (abs(x-target), x))\\n        return ans \\n```\\nTime complexity `O(N*2^(2N) + MN)`",
        "level": "medium",
        "type": [
            "undefined keywords from other languages",
            "== and = confusion",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\n        toppingCosts *= 2\n        \n        @cache\n        def fn(i, x):\n            \"\"\"Return sum of subsequence of toppingCosts[i:] closest to x.\"\"\"\n            if x < 0 or i = len(toppingCosts)+1: return 0\n            return min(fn(i+1, x), toppingCosts[i] + fn(i+1, x-toppingCosts[i]), key=lambda y: (abs(y-x), y))\n        \n        ans = infinity\n        for bc in baseCosts: \n            ans = min(ans, bc + fn(0, target - bc), key=lambda x: (abs(x-target), x))\n        return ans\n"
    },
    {
        "slug": "sliding-window-median",
        "description": "The median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle values.\n\nFor examples, if arr = [2,3,4], the median is 3.\nFor examples, if arr = [1,2,3,4], the median is (2 + 3) / 2 = 2.5.\n\nYou are given an integer array nums and an integer k. There is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position.\nReturn the median array for each window in the original array. Answers within 10-5 of the actual value will be accepted.",
        "examples": [
            "Input: nums = [1,3,-1,-3,5,3,6,7], k = 3\nOutput: [1.00000,-1.00000,-1.00000,3.00000,5.00000,6.00000]\nExplanation: \nWindow position                Median\n---------------                -----\n[1  3  -1] -3  5  3  6  7        1\n 1 [3  -1  -3] 5  3  6  7       -1\n 1  3 [-1  -3  5] 3  6  7       -1\n 1  3  -1 [-3  5  3] 6  7        3\n 1  3  -1  -3 [5  3  6] 7        5\n 1  3  -1  -3  5 [3  6  7]       6",
            "Input: nums = [1,2,3,4,2,3,1,4,2], k = 3\nOutput: [2.00000,3.00000,3.00000,3.00000,2.00000,3.00000,2.00000]"
        ],
        "constraints": "1 <= k <= nums.length <= 105\n-231 <= nums[i] <= 231 - 1",
        "oracle_code": "class Solution:\n    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\n        tree = None\n        ans = []\n        for i, x in enumerate(nums):\n            tree = insert(tree, x)\n            if size(tree) > k:\n                tree = remove(tree, nums[i - k])\n            if size(tree) == k:\n                if k % 2 == 1:\n                    ans.append(get(tree, k // 2 + 1))\n                else:\n                    ans.append((get(tree, k // 2) + get(tree, k // 2 + 1)) / 2)\n        return ans\n\n\n\nclass Node:\n    __slots__ = ['val', 'count', 'weight', 'size', 'left', 'right']\n    def __init__(self, val):\n        self.val = val\n        self.count = 1\n        self.weight = random.random()\n        self.size = 1\n        self.left = self.right = None\n\n\ndef touch(root):\n    if not root:\n        return\n    root.size = root.count + size(root.left) + size(root.right)\n\n\ndef size(root):\n    if not root:\n        return 0\n    return root.size\n\n\ndef insert(root, val):\n    t1, r, t2 = split(root, val)\n    if not r:\n        r = Node(val)\n    else:\n        r.count += 1\n        touch(r)\n    t2 = join(r, t2)\n    return join(t1, t2)\n\n\ndef remove(root, val):\n    t1, r, t2 = split(root, val)\n    if r and r.count > 1:\n        r.count -= 1\n        touch(r)\n        t2 = join(r, t2)\n    return join(t1, t2)\n\n\ndef split(root, val):\n    if not root:\n        return None, None, None\n    elif root.val < val:\n        a, b, c = split(root.right, val)\n        root.right = a\n        touch(root)\n        return root, b, c\n    elif root.val > val:\n        a, b, c = split(root.left, val)\n        root.left = c\n        touch(root)\n        return a, b, root\n    else:\n        a, c = root.left, root.right\n        root.left = root.right = None\n        touch(root)\n        return a, root, c\n\n\ndef join(t1, t2):\n    if not t1:\n        return t2\n    elif not t2:\n        return t1\n    elif t1.weight < t2.weight:\n        t1.right = join(t1.right, t2)\n        touch(t1)\n        return t1\n    else:\n        t2.left = join(t1, t2.left)\n        touch(t2)\n        return t2\n\n\ndef get(root, index):\n    if size(root.left) < index <= size(root.left) + root.count:\n        return root.val\n    elif size(root.left) + root.count < index:\n        return get(root.right, index - root.count - size(root.left))\n    else:\n        return get(root.left, index)",
        "content": "\\n\\n```\\nclass Solution:\\n    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\\n        tree = None\\n        ans = []\\n        for i, x in enumerate(nums):\\n            tree = insert(tree, x)\\n            if size(tree) > k:\\n                tree = remove(tree, nums[i - k])\\n            if size(tree) == k:\\n                if k % 2 == 1:\\n                    ans.append(get(tree, k // 2 + 1))\\n                else:\\n                    ans.append((get(tree, k // 2) + get(tree, k // 2 + 1)) / 2)\\n        return ans\\n\\n\\n\\nclass Node:\\n    __slots__ = [\\'val\\', \\'count\\', \\'weight\\', \\'size\\', \\'left\\', \\'right\\']\\n    def __init__(self, val):\\n        self.val = val\\n        self.count = 1\\n        self.weight = random.random()\\n        self.size = 1\\n        self.left = self.right = None\\n\\n\\ndef touch(root):\\n    if not root:\\n        return\\n    root.size = root.count + size(root.left) + size(root.right)\\n\\n\\ndef size(root):\\n    if not root:\\n        return 0\\n    return root.size\\n\\n\\ndef insert(root, val):\\n    t1, r, t2 = split(root, val)\\n    if not r:\\n        r = Node(val)\\n    else:\\n        r.count += 1\\n        touch(r)\\n    t2 = join(r, t2)\\n    return join(t1, t2)\\n\\n\\ndef remove(root, val):\\n    t1, r, t2 = split(root, val)\\n    if r and r.count > 1:\\n        r.count -= 1\\n        touch(r)\\n        t2 = join(r, t2)\\n    return join(t1, t2)\\n\\n\\ndef split(root, val):\\n    if not root:\\n        return None, None, None\\n    elif root.val < val:\\n        a, b, c = split(root.right, val)\\n        root.right = a\\n        touch(root)\\n        return root, b, c\\n    elif root.val > val:\\n        a, b, c = split(root.left, val)\\n        root.left = c\\n        touch(root)\\n        return a, b, root\\n    else:\\n        a, c = root.left, root.right\\n        root.left = root.right = None\\n        touch(root)\\n        return a, root, c\\n\\n\\ndef join(t1, t2):\\n    if not t1:\\n        return t2\\n    elif not t2:\\n        return t1\\n    elif t1.weight < t2.weight:\\n        t1.right = join(t1.right, t2)\\n        touch(t1)\\n        return t1\\n    else:\\n        t2.left = join(t1, t2.left)\\n        touch(t2)\\n        return t2\\n\\n\\ndef get(root, index):\\n    if size(root.left) < index <= size(root.left) + root.count:\\n        return root.val\\n    elif size(root.left) + root.count < index:\\n        return get(root.right, index - root.count - size(root.left))\\n    else:\\n        return get(root.left, index)\\n\\n```",
        "level": "hard",
        "type": [
            "other error",
            "unclosed string",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\n        tree = None\n        ans = []\n        for i, x in enumerate(nums):\n            tree = insert(tree, x)\n            if size(tree) > k:\n                tree = remove(tree, nums[i - k + 1])\n            if size(tree) == k:\n                if k % 2 == 1:\n                    ans.append(get(tree, k // 2 + 1))\n                else:\n                    nums.append((get(tree, k // 2) + get('tree', k // 2 + 1)) / 2)\n        return nums\n\n"
    },
    {
        "slug": "string-compression-ii",
        "description": "Run-length encoding is a string compression method that works by\u00a0replacing consecutive identical characters (repeated 2 or more times) with the concatenation of the character and the number marking the count of the characters (length of the run). For example, to compress the string\u00a0\"aabccc\"\u00a0we replace \"aa\"\u00a0by\u00a0\"a2\"\u00a0and replace \"ccc\"\u00a0by\u00a0\"c3\". Thus the compressed string becomes \"a2bc3\".\nNotice that in this problem, we are not adding\u00a0'1'\u00a0after single characters.\nGiven a\u00a0string s\u00a0and an integer k. You need to delete at most\u00a0k characters from\u00a0s\u00a0such that the run-length encoded version of s\u00a0has minimum length.\nFind the minimum length of the run-length encoded\u00a0version of s after deleting at most k characters.",
        "examples": [
            "Input: s = \"aaabcccd\", k = 2\nOutput: 4\nExplanation: Compressing s without deleting anything will give us \"a3bc3d\" of length 6. Deleting any of the characters 'a' or 'c' would at most decrease the length of the compressed string to 5, for instance delete 2 'a' then we will have s = \"abcccd\" which compressed is abc3d. Therefore, the optimal way is to delete 'b' and 'd', then the compressed version of s will be \"a3c3\" of length 4.",
            "Input: s = \"aabbaa\", k = 2\nOutput: 2\nExplanation: If we delete both 'b' characters, the resulting compressed string would be \"a4\" of length 2.",
            "Input: s = \"aaaaaaaaaaa\", k = 0\nOutput: 3\nExplanation: Since k is zero, we cannot delete anything. The compressed string is \"a11\" of length 3."
        ],
        "constraints": "1 <= s.length <= 100\n0 <= k <= s.length\ns contains only lowercase English letters.",
        "oracle_code": "class Solution:\n    def dp(self,i,s,prev,k,ct,n,dct):\n        if k<0:\n            return float(\"infinity\")\n        if i>=n:\n            x=0\n            if ct>1:\n                x=len(str(ct))+1\n            elif ct==1:\n                x=1\n            return x\n        if (i,prev,ct,k) in dct:\n            return dct[(i,prev,ct,k)]\n        if s[i]==prev:\n            inc=self.dp(i+1,s,prev,k,ct+1,n,dct)\n        else:\n            x=0\n            if ct>1:\n                x=len(str(ct))+1\n            elif ct==1:\n                x=1\n            inc=x+self.dp(i+1,s,s[i],k,1,n,dct)\n        exc=self.dp(i+1,s,prev,k-1,ct,n,dct)\n        dct[(i,prev,ct,k)]=min(inc,exc)\n        return min(inc,exc)\n\n\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n        n=len(s)\n        return self.dp(0,s,\"\",k,0,n,{})",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def dp(self,i,s,prev,k,ct,n,dct):\\n        if k<0:\\n            return float(\"infinity\")\\n        if i>=n:\\n            x=0\\n            if ct>1:\\n                x=len(str(ct))+1\\n            elif ct==1:\\n                x=1\\n            return x\\n        if (i,prev,ct,k) in dct:\\n            return dct[(i,prev,ct,k)]\\n        if s[i]==prev:\\n            inc=self.dp(i+1,s,prev,k,ct+1,n,dct)\\n        else:\\n            x=0\\n            if ct>1:\\n                x=len(str(ct))+1\\n            elif ct==1:\\n                x=1\\n            inc=x+self.dp(i+1,s,s[i],k,1,n,dct)\\n        exc=self.dp(i+1,s,prev,k-1,ct,n,dct)\\n        dct[(i,prev,ct,k)]=min(inc,exc)\\n        return min(inc,exc)\\n\\n\\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\\n        n=len(s)\\n        return self.dp(0,s,\"\",k,0,n,{})\\n\\n        \\n```",
        "level": "hard",
        "type": [
            "operation error",
            "parentheses mismatch",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution:\n    var dp = function(i,s,prev,k,ct,n,dct {\n        if(k<0) {\n            return Number.POSITIVE_INFINITY;\n        }\n        if(i>=n){\n            x=0;\n            if(ct>1){\n                x=len(str(ct))+1;\n            } elif(ct==1) {\n                x=1;\n            }\n            return x;\n        }\n        if((i,prev,ct,k) in dct) {\n            return dct[(i,prev,ct,k)];\n        }\n        if(s[i]==prev){\n            inc=self.dp(i+1,s,prev,k,ct+1,n,dct);\n        } else{\n            x=0;\n            if(ct>1){\n                x=len(str(ct))+1;\n            } elif(ct==1) {\n                x=1;\n            }\n            inc=x+self.dp(i+1,s,s[i],k,1,n,dct);\n        }\n        exc=self.dp(i+1,s,prev,k-1,ct,n,dct);\n        dct[(i,prev,ct,k)]=Math.max(inc,exc);\n        return Math.min(inc,exc)\n    }\n\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n        n=len(s)\n        return self.dp(0,s,\"\",k,0,n,{})\n"
    },
    {
        "slug": "online-election",
        "description": "You are given two integer arrays persons and times. In an election, the ith vote was cast for persons[i] at time times[i].\nFor each query at a time t, find the person that was leading the election at time t. Votes cast at time t will count towards our query. In the case of a tie, the most recent vote (among tied candidates) wins.\nImplement the TopVotedCandidate class:\n\nTopVotedCandidate(int[] persons, int[] times) Initializes the object with the persons and times arrays.\nint q(int t) Returns the number of the person that was leading the election at time t according to the mentioned rules.",
        "examples": [
            "Input\n[\"TopVotedCandidate\", \"q\", \"q\", \"q\", \"q\", \"q\", \"q\"]\n[[[0, 1, 1, 0, 0, 1, 0], [0, 5, 10, 15, 20, 25, 30]], [3], [12], [25], [15], [24], [8]]\nOutput\n[null, 0, 1, 1, 0, 0, 1]\n\nExplanation\nTopVotedCandidate topVotedCandidate = new TopVotedCandidate([0, 1, 1, 0, 0, 1, 0], [0, 5, 10, 15, 20, 25, 30]);\ntopVotedCandidate.q(3); // return 0, At time 3, the votes are [0], and 0 is leading.\ntopVotedCandidate.q(12); // return 1, At time 12, the votes are [0,1,1], and 1 is leading.\ntopVotedCandidate.q(25); // return 1, At time 25, the votes are [0,1,1,0,0,1], and 1 is leading (as ties go to the most recent vote.)\ntopVotedCandidate.q(15); // return 0\ntopVotedCandidate.q(24); // return 0\ntopVotedCandidate.q(8); // return 1"
        ],
        "constraints": "1 <= persons.length <= 5000\ntimes.length == persons.length\n0 <= persons[i] < persons.length\n0 <= times[i] <= 109\ntimes is sorted in a strictly increasing order.\ntimes[0] <= t <= 109\nAt most 104 calls will be made to q.",
        "oracle_code": "class TopVotedCandidate:\n\n    def __init__(self, persons: List[int], times: List[int]):\n        self.persons = []\n        self.times = []\n        self.dic = collections.defaultdict(int)\n        self.m = 0\n        self.idx = -1\n\n        for i in range(len(times)):\n            self.times.append(times[i])\n            self.dic[persons[i]] += 1\n            if self.dic[persons[i]] >= self.m:\n                self.persons.append(persons[i])\n                self.m = self.dic[persons[i]]\n            else:\n                self.persons.append(self.persons[-1])\n\n    def q(self, t: int) -> int:\n        idx = bisect.bisect_right(self.times,t)\n        return self.persons[idx-1]",
        "content": "# Code\\n```\\nclass TopVotedCandidate:\\n\\n    def __init__(self, persons: List[int], times: List[int]):\\n        self.persons = []\\n        self.times = []\\n        self.dic = collections.defaultdict(int)\\n        self.m = 0\\n        self.idx = -1\\n\\n        for i in range(len(times)):\\n            self.times.append(times[i])\\n            self.dic[persons[i]] += 1\\n            if self.dic[persons[i]] >= self.m:\\n                self.persons.append(persons[i])\\n                self.m = self.dic[persons[i]]\\n            else:\\n                self.persons.append(self.persons[-1])\\n\\n    def q(self, t: int) -> int:\\n        idx = bisect.bisect_right(self.times,t)\\n        return self.persons[idx-1]\\n\\n```",
        "level": "medium",
        "type": [
            "indentation error",
            "colon missing",
            "operation error"
        ],
        "buggy_code": "\nclass TopVotedCandidate:\n\n    def __init__(self, persons: List[int], times: List[int])\n        self.persons = []\n        self.times = []\n        self.dic = collections.defaultdict(int)\n        self.m = 0\n            self.idx = -1\n\n        for i in range(len(times)):\n            self.times.append(times[i])\n            self.dic[persons[i]] += 1\n            if self.dic[persons[i]] >= self.m:\n                self.persons.append(persons[i])\n                self.m = self.dic[persons[i]]\n            else:\n                self.persons.append(self.persons[-1])\n\n    def q(self, t: int) -> int:\n        idx = bisect.bisect_right(self.times,t)\n        return self.persons[idx]\n"
    },
    {
        "slug": "remove-duplicates-from-sorted-array-ii",
        "description": "Given an integer array nums sorted in non-decreasing order, remove some duplicates in-place such that each unique element appears at most twice. The relative order of the elements should be kept the same.\nSince it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums\u00a0should hold the final result. It does not matter what you leave beyond the first\u00a0k\u00a0elements.\nReturn k after placing the final result in the first k slots of nums.\nDo not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\nCustom Judge:\nThe judge will test your solution with the following code:\n\nint[] nums = [...]; // Input array\nint[] expectedNums = [...]; // The expected answer with correct length\n\nint k = removeDuplicates(nums); // Calls your implementation\n\nassert k == expectedNums.length;\nfor (int i = 0; i < k; i++) {\n    assert nums[i] == expectedNums[i];\n}\n\nIf all assertions pass, then your solution will be accepted.",
        "examples": [
            "Input: nums = [1,1,1,2,2,3]\nOutput: 5, nums = [1,1,2,2,3,_]\nExplanation: Your function should return k = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).",
            "Input: nums = [0,0,1,1,1,1,2,3,3]\nOutput: 7, nums = [0,0,1,1,2,3,3,_,_]\nExplanation: Your function should return k = 7, with the first seven elements of nums being 0, 0, 1, 1, 2, 3 and 3 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores)."
        ],
        "constraints": "1 <= nums.length <= 3 * 104\n-104 <= nums[i] <= 104\nnums is sorted in non-decreasing order.",
        "oracle_code": "class Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        if len(nums) < 3:\n            return len(nums)\n\n        p1, p2 = 1, 2\n\n        while p2 < len(nums):\n            if nums[p1] == nums[p1-1] and nums[p2] == nums[p2-1] == nums[p2-2]:\n                while p2 < len(nums) and nums[p2] == nums[p2-1]:\n                    p2 += 1\n                if p2 == len(nums):\n                    break\n            p1 += 1\n            nums[p1] = nums[p2]\n            p2 += 1\n\n        return p1 + 1",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(0)\\n\\n# Code\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        if len(nums) < 3:\\n            return len(nums)\\n\\n        p1, p2 = 1, 2\\n\\n        while p2 < len(nums):\\n            if nums[p1] == nums[p1-1] and nums[p2] == nums[p2-1] == nums[p2-2]:\\n                while p2 < len(nums) and nums[p2] == nums[p2-1]:\\n                    p2 += 1\\n                if p2 == len(nums):\\n                    break\\n            p1 += 1\\n            nums[p1] = nums[p2]\\n            p2 += 1\\n\\n        return p1 + 1\\n\\n```",
        "level": "medium",
        "type": [
            "undefined keywords from other languages",
            "== and = confusion",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        if len(nums) < 3:\n            return len(nums)\n\n        p1, p2 = 1, 2\n\n        while p2 < len(nums):\n            if nums[p1] == nums[p1-1] and nums[p2] = nums[p2-1] == nums[p1-2]: \n                while p2 < len(nums) and nums[p2] == nums[p2-1]:\n                    p2 += 1\n                if p2 == len(nums):\n                    var break\n            p1 += 1\n            nums[p1] = nums[p2]\n            p2 += 1\n\n        return p1 + 1\n"
    },
    {
        "slug": "satisfiability-of-equality-equations",
        "description": "You are given an array of strings equations that represent relationships between variables where each string equations[i] is of length 4 and takes one of two different forms: \"xi==yi\" or \"xi!=yi\".Here, xi and yi are lowercase letters (not necessarily different) that represent one-letter variable names.\nReturn true if it is possible to assign integers to variable names so as to satisfy all the given equations, or false otherwise.",
        "examples": [
            "Input: equations = [\"a==b\",\"b!=a\"]\nOutput: false\nExplanation: If we assign say, a = 1 and b = 1, then the first equation is satisfied, but not the second.\nThere is no way to assign the variables to satisfy both equations.",
            "Input: equations = [\"b==a\",\"a==b\"]\nOutput: true\nExplanation: We could assign a = 1 and b = 1 to satisfy both equations."
        ],
        "constraints": "1 <= equations.length <= 500\nequations[i].length == 4\nequations[i][0] is a lowercase letter.\nequations[i][1] is either '=' or '!'.\nequations[i][2] is '='.\nequations[i][3] is a lowercase letter.",
        "oracle_code": "class Disjoint:\n    def __init__(self):\n        self.rank=[0]*26\n        self.parent=[i for i in range(26)]\n\n    def finduPar(self,node):\n        if self.parent[node]==node:\n            return node\n        self.parent[node]=self.finduPar(self.parent[node])\n        return self.parent[node]\n\n    def byrank(self,u,v):\n        ulp_u=self.finduPar(u)\n        ulp_v=self.finduPar(v)\n        if ulp_u==ulp_v:\n            return False\n        if self.rank[ulp_u]>self.rank[ulp_v]:\n            self.parent[ulp_v]=ulp_u\n        elif self.rank[ulp_u]<self.rank[ulp_v]:\n            self.parent[ulp_u]=ulp_v\n        else:\n            self.parent[ulp_v]=ulp_u\n            self.rank[ulp_u]+=1\n\n\nclass Solution:\n    def equationsPossible(self, equations: List[str]) -> bool:\n        disjoint=Disjoint()\n        nq=[]\n        n=len(equations)\n        for i in range(n):\n            if equations[i][1]=='!':\n                if equations[i][0]==equations[i][-1]:\n                    return False\n                else:\n                    nq.append(equations[i])\n            else:\n                disjoint.byrank(ord(equations[i][0])-97,ord(equations[i][-1])-97)\n        for i in range(len(nq)):\n            x=ord(nq[i][0])-97\n            y=ord(nq[i][-1])-97\n            if disjoint.finduPar(x)==disjoint.finduPar(y):\n                return False\n        return True",
        "content": "# Intuition\\nWE WOULD MAKE ALL alphabet that are equal in same component. \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nUNION DISJOINT\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Disjoint:\\n    def __init__(self):\\n        self.rank=[0]*26\\n        self.parent=[i for i in range(26)]\\n\\n    def finduPar(self,node):\\n        if self.parent[node]==node:\\n            return node\\n        self.parent[node]=self.finduPar(self.parent[node])\\n        return self.parent[node]\\n\\n    def byrank(self,u,v):\\n        ulp_u=self.finduPar(u)\\n        ulp_v=self.finduPar(v)\\n        if ulp_u==ulp_v:\\n            return False\\n        if self.rank[ulp_u]>self.rank[ulp_v]:\\n            self.parent[ulp_v]=ulp_u\\n        elif self.rank[ulp_u]<self.rank[ulp_v]:\\n            self.parent[ulp_u]=ulp_v\\n        else:\\n            self.parent[ulp_v]=ulp_u\\n            self.rank[ulp_u]+=1\\n\\n\\nclass Solution:\\n    def equationsPossible(self, equations: List[str]) -> bool:\\n        disjoint=Disjoint()\\n        nq=[]\\n        n=len(equations)\\n        for i in range(n):\\n            if equations[i][1]==\\'!\\':\\n                if equations[i][0]==equations[i][-1]:\\n                    return False\\n                else:\\n                    nq.append(equations[i])\\n            else:\\n                disjoint.byrank(ord(equations[i][0])-97,ord(equations[i][-1])-97)\\n        for i in range(len(nq)):\\n            x=ord(nq[i][0])-97\\n            y=ord(nq[i][-1])-97\\n            if disjoint.finduPar(x)==disjoint.finduPar(y):\\n                return False\\n        return True\\n```",
        "level": "medium",
        "type": [
            "undefined objects",
            "parentheses mismatch",
            "indexing error"
        ],
        "buggy_code": "\nclass Disjoint:\n    def __init__(self):\n        self.rank=[0]*26\n        self.parent=[i for i in range(26)\n\n    def finduPar(self,node):\n        if self.parent[node]==node:\n            return node\n        self.parent[node]=self.finduPar(self.parent[node])\n        return self.parent[node]\n\n    def byrank(self,u,v):\n        ulp_u=self.finduPar(u)\n        ulp_v=self.finduPar(v)\n        if ulp_u==ulp_v:\n            return False\n        if self.rank[ulp_u]>self.rank[ulp_v]:\n            self.parent[ulp_v]=ulp_u\n        elif self.rank[ulp_u]<self.rank[ulp_v]:\n            self.parent[ulp_u]=ulp_v\n        else:\n            self.parent[ulp_v]=ulp_u\n            self.rank[ulp_u]+=1\n\n\nclass Solution:\n    def equationsPossible(self, equations: List[str]) -> bool:\n        disjoint=Disjoint()\n        nq=[]\n        arbitrary_undefined_variable = 0\n        n=len(equations)\n        for i in range(n+1):  \n            if equations[i][1]=='!':\n                if equations[i][0]==equations[i][-1]:\n                    return False\n                else:\n                    nq.append(equations[i])\n            else:\n                disjoint.byrank(ord(equations[i][0])-97,ord(equations[i][-1])-97)\n        for i in range(len(nq)):\n            x=ord(nq[i][0])-97\n            y=ord(nq[i][-1])-arbitrary_undefined_variable\n            if disjoint.finduPar(x)==disjoint.finduPar(y):\n                return False\n        return True\n"
    },
    {
        "slug": "find-the-string-with-lcp",
        "description": "We define the lcp matrix of any 0-indexed string word of n lowercase English letters as an n x n grid such that:\n\nlcp[i][j] is equal to the length of the longest common prefix between the substrings word[i,n-1] and word[j,n-1].\n\nGiven an\u00a0n x n matrix lcp, return the alphabetically smallest string word that corresponds to lcp. If there is no such string, return an empty string.\nA string a is lexicographically smaller than a string b (of the same length) if in the first position where a and b differ, string a has a letter that appears earlier in the alphabet than the corresponding letter in b. For example, \"aabd\" is lexicographically smaller than \"aaca\" because the first position they differ is at the third letter, and 'b' comes before 'c'.",
        "examples": [
            "Input: lcp = [[4,0,2,0],[0,3,0,1],[2,0,2,0],[0,1,0,1]]\nOutput: \"abab\"\nExplanation: lcp corresponds to any 4 letter string with two alternating letters. The lexicographically smallest of them is \"abab\".",
            "Input: lcp = [[4,3,2,1],[3,3,2,1],[2,2,2,1],[1,1,1,1]]\nOutput: \"aaaa\"\nExplanation: lcp corresponds to any 4 letter string with a single distinct letter. The lexicographically smallest of them is \"aaaa\".",
            "Input: lcp = [[4,3,2,1],[3,3,2,1],[2,2,2,1],[1,1,1,3]]\nOutput: \"\"\nExplanation: lcp[3][3] cannot be equal to 3 since word[3,...,3] consists of only a single letter; Thus, no answer exists."
        ],
        "constraints": "1 <= n ==\u00a0lcp.length == lcp[i].length\u00a0<= 1000\n0 <= lcp[i][j] <= n",
        "oracle_code": "class Solution:\n    def findTheString(self, lcp: List[List[int]]) -> str:\n        # simple validation\n        n = len(lcp)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if lcp[i][j] != lcp[j][i]:\n                    return ''\n                if lcp[i][j] > n - j:\n                    return ''\n        for i in range(n):\n            if lcp[i][i] != n - i:\n                return ''\n        \n        # build pattern \\u2014 the only possible candidate for answer\n        pattern = [None for _ in range(n)]\n        next_el_ind = 0\n        for i in range(n):\n            if pattern[i] is not None:\n                continue\n            pattern[i] = next_el_ind\n            next_el_ind += 1\n            for j in range(i+1, n):\n                if lcp[i][j] > 0:\n                    if pattern[j] is not None and pattern[j] != pattern[i]:\n                        return ''\n                    pattern[j] = pattern[i]\n    \n        # check if lcp is valid - check that pattern's lcp == original lcp\n        pattern_lcp = [[0 for _ in range(n)] for _ in range(n)]\n        for i in range(n-1, -1, -1):\n            for j in range(n-1, -1, -1):\n                if pattern[i] == pattern[j]:\n                    if max(i, j) + 1 < n:\n                        pattern_lcp[i][j] = pattern_lcp[i+1][j+1] + 1\n                    else:\n                        pattern_lcp[i][j] = 1\n        for i in range(n):\n            for j in range(n):\n                if lcp[i][j] != pattern_lcp[i][j]:\n                    return ''\n    \n        # check that answer has no more than 26 distinct elements\n        if max(pattern) > ord('z') - ord('a'):\n            return ''\n\n        return  ''.join(chr(ord('a') + ind) for ind in pattern)",
        "content": "# Complexity\\n- Time complexity: $O(N^2)$\\n\\n- Space complexity: $O(N^2)$ (can be reduced to $O(N)$ if build and check new lcp at the same time)\\n\\n# Code\\n```\\nclass Solution:\\n    def findTheString(self, lcp: List[List[int]]) -> str:\\n        # simple validation\\n        n = len(lcp)\\n        for i in range(n):\\n            for j in range(i + 1, n):\\n                if lcp[i][j] != lcp[j][i]:\\n                    return \\'\\'\\n                if lcp[i][j] > n - j:\\n                    return \\'\\'\\n        for i in range(n):\\n            if lcp[i][i] != n - i:\\n                return \\'\\'\\n        \\n        # build pattern \\u2014 the only possible candidate for answer\\n        pattern = [None for _ in range(n)]\\n        next_el_ind = 0\\n        for i in range(n):\\n            if pattern[i] is not None:\\n                continue\\n            pattern[i] = next_el_ind\\n            next_el_ind += 1\\n            for j in range(i+1, n):\\n                if lcp[i][j] > 0:\\n                    if pattern[j] is not None and pattern[j] != pattern[i]:\\n                        return \\'\\'\\n                    pattern[j] = pattern[i]\\n    \\n        # check if lcp is valid - check that pattern\\'s lcp == original lcp\\n        pattern_lcp = [[0 for _ in range(n)] for _ in range(n)]\\n        for i in range(n-1, -1, -1):\\n            for j in range(n-1, -1, -1):\\n                if pattern[i] == pattern[j]:\\n                    if max(i, j) + 1 < n:\\n                        pattern_lcp[i][j] = pattern_lcp[i+1][j+1] + 1\\n                    else:\\n                        pattern_lcp[i][j] = 1\\n        for i in range(n):\\n            for j in range(n):\\n                if lcp[i][j] != pattern_lcp[i][j]:\\n                    return \\'\\'\\n    \\n        # check that answer has no more than 26 distinct elements\\n        if max(pattern) > ord(\\'z\\') - ord(\\'a\\'):\\n            return \\'\\'\\n\\n        return  \\'\\'.join(chr(ord(\\'a\\') + ind) for ind in pattern)\\n```",
        "level": "hard",
        "type": [
            "parentheses mismatch",
            "unclosed string",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n    def findTheString(self, lcp: List[List[int]]) -> str:\n        # simple validation\n        n = len(lcp)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if lcp[i][j] = lcp[j][i]:\n                    return ''\n                if lcp[i][j] > n - j:\n                    return ''\n        for i in range(n):\n            if lcp[i][i] = n - i:\n                return ''\n        \n        # build pattern \\u2014 the only possible candidate for answer\n        pattern = [None for _ in range(n)\n        next_el_ind = 0\n        for i in range(n):\n            if pattern[i] is not None:\n                continue\n            pattern[i] = next_el_ind\n            next_el_ind += 1\n            for j in range(i+1, n:\n                if lcp[i][j] > 0):\n                    if pattern[j] is not None and pattern[j] != pattern[i]:\n                        return ''\n                    pattern[j] = pattern[i]\n    \n        # check if lcp is valid - check that pattern's lcp == original lcp\n        pattern_lcp = [[0 for _ in range(n)] for _ in range(n)]\n        for i in range(n-1, -1, -1):\n            for j in range(n-1, -1, -1):\n                if pattern[i] == pattern[j]:\n                    if max(i, j) + 1 < n:\n                        pattern_lcp[i][j] = pattern_lcp[i+1][j+1] + 1\n                    else:\n                        pattern_lcp[i][j] = 1\n        for i in range(n):\n            for j in range(n):\n                if lcp[i][j] = pattern_lcp[i][j]:\n                    return ''\n    \n        # check that answer has no more than 26 distinct elements\n        if max(pattern) > ord('z') - ord('a'):\n            return ''\n\n        return  ''.join(chr(ord('a') + ind) for ind in pattern)\n"
    },
    {
        "slug": "valid-arrangement-of-pairs",
        "description": "You are given a 0-indexed 2D integer array pairs where pairs[i] = [starti, endi]. An arrangement of pairs is valid if for every index i where 1 <= i < pairs.length, we have endi-1 == starti.\nReturn any valid arrangement of pairs.\nNote: The inputs will be generated such that there exists a valid arrangement of pairs.",
        "examples": [
            "Input: pairs = [[5,1],[4,5],[11,9],[9,4]]\nOutput: [[11,9],[9,4],[4,5],[5,1]]\nExplanation:\nThis is a valid arrangement since endi-1 always equals starti.\nend0 = 9 == 9 = start1 \nend1 = 4 == 4 = start2\nend2 = 5 == 5 = start3",
            "Input: pairs = [[1,3],[3,2],[2,1]]\nOutput: [[1,3],[3,2],[2,1]]\nExplanation:\nThis is a valid arrangement since endi-1 always equals starti.\nend0 = 3 == 3 = start1\nend1 = 2 == 2 = start2\nThe arrangements [[2,1],[1,3],[3,2]] and [[3,2],[2,1],[1,3]] are also valid.",
            "Input: pairs = [[1,2],[1,3],[2,1]]\nOutput: [[1,2],[2,1],[1,3]]\nExplanation:\nThis is a valid arrangement since endi-1 always equals starti.\nend0 = 2 == 2 = start1\nend1 = 1 == 1 = start2"
        ],
        "constraints": "1 <= pairs.length <= 105\npairs[i].length == 2\n0 <= starti, endi <= 109\nstarti != endi\nNo two pairs are exactly the same.\nThere exists a valid arrangement of pairs.",
        "oracle_code": "class Solution:\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\n        graph = defaultdict(list)\n        degree = defaultdict(int) # net out degree \n        for x, y in pairs: \n            graph[x].append(y)\n            degree[x] += 1\n            degree[y] -= 1\n                \n        for k in degree: \n            if degree[k] == 1: \n                x = k\n                break \n                \n        ans = []\n\n        def fn(x): \n            \"\"\"Return Eulerian path via dfs.\"\"\"\n            while graph[x]: fn(graph[x].pop()) \n            ans.append(x)\n        \n        fn(x)\n        ans.reverse()\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]",
        "content": "Please check out this [commit](https://github.com/gaosanyong/leetcode/commit/b1948f8814bebeca475cbb354cd44d19092dff59) for solutions of weekly 270.\\n\\n```\\nclass Solution:\\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\\n        graph = defaultdict(list)\\n        degree = defaultdict(int) # net out degree \\n        for x, y in pairs: \\n            graph[x].append(y)\\n            degree[x] += 1\\n            degree[y] -= 1\\n                \\n        for k in degree: \\n            if degree[k] == 1: \\n                x = k\\n                break \\n                \\n        ans = []\\n\\n        def fn(x): \\n            \"\"\"Return Eulerian path via dfs.\"\"\"\\n            while graph[x]: fn(graph[x].pop()) \\n            ans.append(x)\\n        \\n        fn(x)\\n        ans.reverse()\\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]\\n```\\n\\nAdding an iterative implementation of Hieholzer\\'s algo from @delphih\\n```\\nclass Solution:\\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\\n        graph = defaultdict(list)\\n        degree = defaultdict(int) # net out degree \\n        for x, y in pairs: \\n            graph[x].append(y)\\n            degree[x] += 1\\n            degree[y] -= 1\\n                \\n        for k in degree: \\n            if degree[k] == 1: \\n                x = k\\n                break \\n                \\n        ans = []\\n        stack = [x]\\n        while stack: \\n            while graph[stack[-1]]: \\n                stack.append(graph[stack[-1]].pop())\\n            ans.append(stack.pop())\\n        ans.reverse()\\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]\\n```",
        "level": "hard",
        "type": [
            "undefined methods",
            "== and = confusion",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\n        graph = defaultdict(list)\n        degree = defaultdict(int) # net out degree \n        for x, y in pairs: \n            graph[x].append(y)\n            degree[x] += 1\n            degree[y] -= 1\n                \n        for k in degree: \n            if degree[k] != 1: \n                x = k\n                break \n                \n        ans = []\n\n        def fn(x): \n            \"\"\"Return Eulerian path via dfs.\"\"\"\n            while graph[x]: fn(graph[x].pop()) \n            ans.append(x)\n        \n        dfn(s)\n        ans.reverse()\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]\n"
    },
    {
        "slug": "restore-ip-addresses",
        "description": "A valid IP address consists of exactly four integers separated by single dots. Each integer is between 0 and 255 (inclusive) and cannot have leading zeros.\n\nFor example, \"0.1.2.201\" and \"192.168.1.1\" are valid IP addresses, but \"0.011.255.245\", \"192.168.1.312\" and \"192.168@1.1\" are invalid IP addresses.\n\nGiven a string s containing only digits, return all possible valid IP addresses that can be formed by inserting dots into s. You are not allowed to reorder or remove any digits in s. You may return the valid IP addresses in any order.",
        "examples": [
            "Input: s = \"25525511135\"\nOutput: [\"255.255.11.135\",\"255.255.111.35\"]",
            "Input: s = \"0000\"\nOutput: [\"0.0.0.0\"]",
            "Input: s = \"101023\"\nOutput: [\"1.0.10.23\",\"1.0.102.3\",\"10.1.0.23\",\"10.10.2.3\",\"101.0.2.3\"]"
        ],
        "constraints": "1 <= s.length <= 20\ns consists of digits only.",
        "oracle_code": "class Solution:\n    def restoreIpAddresses(self, s: str) -> List[str]:\n        res=[]\n        cur=[]\n        def backtrack(i):\n            if i==len(s) and len(cur)==4:\n                res.append(\".\".join(cur))\n                return\n            if len(cur)>4 or i>=len(s):\n                return\n            if s[i]=='0':\n                cur.append(s[i])\n                backtrack(i+1)\n                cur.pop()\n                return\n            j=0\n            while j<4 and i+j<len(s):\n                if int(s[i:i+j+1])<256:\n                    cur.append(s[i:i+j+1])\n                    backtrack(i+j+1)\n                    cur.pop()\n                j+=1\n        backtrack(0)\n        return res",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\njust take care with the processing number should be lower than len(s) and the length of current stack should be lower or equal 4.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(4)\\n# Code\\n```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        res=[]\\n        cur=[]\\n        def backtrack(i):\\n            if i==len(s) and len(cur)==4:\\n                res.append(\".\".join(cur))\\n                return\\n            if len(cur)>4 or i>=len(s):\\n                return\\n            if s[i]==\\'0\\':\\n                cur.append(s[i])\\n                backtrack(i+1)\\n                cur.pop()\\n                return\\n            j=0\\n            while j<4 and i+j<len(s):\\n                if int(s[i:i+j+1])<256:\\n                    cur.append(s[i:i+j+1])\\n                    backtrack(i+j+1)\\n                    cur.pop()\\n                j+=1\\n        backtrack(0)\\n        return res\\n\\n```",
        "level": "medium",
        "type": [
            "colon missing",
            "== and = confusion",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def restoreIpAddresses(self, s: str) -> List[str]:\n        res=[]\n        cur=[]\n        def backtrack(i):\n            if i=len(s) and len(cur)==4:\n                res.append(\".\".join(cur))\n                return\n            if len(cur)>4 or i>len(s):\n                return\n            if s[i]=='0':\n                cur.append(s[i])\n                backtrack(i+1)\n                cur.pop()\n                return\n            j=0\n            while j<4 and i+j<len(s)\n                if int(s[i:i+j+1])<256:\n                    cur.append(s[i:i+j+1])\n                    backtrack(i+j+1)\n                    cur.pop()\n                j+=1\n        backtrack(0)\n        return res\n"
    },
    {
        "slug": "create-components-with-same-value",
        "description": "There is an undirected tree with n nodes labeled from 0 to n - 1.\nYou are given a 0-indexed integer array nums of length n where nums[i] represents the value of the ith node. You are also given a 2D integer array edges of length n - 1 where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree.\nYou are allowed to delete some edges, splitting the tree into multiple connected components. Let the value of a component be the sum of all nums[i] for which node i is in the component.\nReturn the maximum number of edges you can delete, such that every connected component in the tree has the same value.",
        "examples": [
            "Input: nums = [6,2,2,2,6], edges = [[0,1],[1,2],[1,3],[3,4]] \nOutput: 2 \nExplanation: The above figure shows how we can delete the edges [0,1] and [3,4]. The created components are nodes [0], [1,2,3] and [4]. The sum of the values in each component equals 6. It can be proven that no better deletion exists, so the answer is 2.",
            "Input: nums = [2], edges = []\nOutput: 0\nExplanation: There are no edges to be deleted."
        ],
        "constraints": "1 <= n <= 2 * 104\nnums.length == n\n1 <= nums[i] <= 50\nedges.length == n - 1\nedges[i].length == 2\n0 <= edges[i][0], edges[i][1] <= n - 1\nedges represents a valid tree.",
        "oracle_code": "class Solution:\n    def componentValue(self, nums: List[int], edges: List[List[int]]) -> int:\n        tree = [[] for _ in nums]\n        for u, v in edges: \n            tree[u].append(v)\n            tree[v].append(u)\n        \n        def fn(u, p):\n            \"\"\"Post-order dfs.\"\"\"\n            ans = nums[u]\n            for v in tree[u]: \n                if v != p: ans += fn(v, u)\n            return 0 if ans == cand else ans\n        \n        total = sum(nums)\n        for cand in range(1, total//2+1): \n            if total % cand == 0 and fn(0, -1) == 0: return total//cand-1\n        return 0",
        "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/b09317beeb5fa2ae0b6d2537172ab52647a75cea) for solutions of biweekly 89. \\n\\n```\\nclass Solution:\\n    def componentValue(self, nums: List[int], edges: List[List[int]]) -> int:\\n        tree = [[] for _ in nums]\\n        for u, v in edges: \\n            tree[u].append(v)\\n            tree[v].append(u)\\n        \\n        def fn(u, p):\\n            \"\"\"Post-order dfs.\"\"\"\\n            ans = nums[u]\\n            for v in tree[u]: \\n                if v != p: ans += fn(v, u)\\n            return 0 if ans == cand else ans\\n        \\n        total = sum(nums)\\n        for cand in range(1, total//2+1): \\n            if total % cand == 0 and fn(0, -1) == 0: return total//cand-1\\n        return 0 \\n```",
        "level": "hard",
        "type": [
            "undefined methods",
            "parentheses mismatch",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution:\n    def componentValue(self, nums: List[int], edges: List[List[int]]) -> int:\n        tree = [[] for _ in nums]\n        for u, v in edges: \n            tree[u].append(v)\n            tree[v].append(u)\n        \n        def fn(u, p):\n            \"\"\"Post-order dfs.\n            ans = nums[u]\n            for v in tree[u]: \n                if v != p: ans += self.fn(v, u)\n            return 0 if ans == cand else ans\n        \n        total = sum(nums)\n        for cand in range(1, total//2+1: \n            if total % cand == 0 and fn(0, -1) == 0: return total//cand-1\n        return 0\n"
    },
    {
        "slug": "split-linked-list-in-parts",
        "description": "Given the head of a singly linked list and an integer k, split the linked list into k consecutive linked list parts.\nThe length of each part should be as equal as possible: no two parts should have a size differing by more than one. This may lead to some parts being null.\nThe parts should be in the order of occurrence in the input list, and parts occurring earlier should always have a size greater than or equal to parts occurring later.\nReturn an array of the k parts.",
        "examples": [
            "Input: head = [1,2,3], k = 5\nOutput: [[1],[2],[3],[],[]]\nExplanation:\nThe first element output[0] has output[0].val = 1, output[0].next = null.\nThe last element output[4] is null, but its string representation as a ListNode is [].",
            "Input: head = [1,2,3,4,5,6,7,8,9,10], k = 3\nOutput: [[1,2,3,4],[5,6,7],[8,9,10]]\nExplanation:\nThe input has been split into consecutive parts with size difference at most 1, and earlier parts are a larger size than the later parts."
        ],
        "constraints": "The number of nodes in the list is in the range [0, 1000].\n0 <= Node.val <= 1000\n1 <= k <= 50",
        "oracle_code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def splitListToParts(self, head: Optional[ListNode], k: int) -> List[Optional[ListNode]]:\n\n        # first calculate the length\n        # then find the arrangement of the number of elements and store it in list\n    \n        l = []\n        length = 0\n        ptr = head\n        while(ptr) :\n            length += 1\n            ptr = ptr.next\n\n        # possible length of the elements of an node to split\n        # first find how much it will be posiibe to split by length // k\n        # then calculate the remaining no of elements by length % k\n        arrange = []\n        maxi = length//k \n        remain = length%k\n\n        for i in range(k) :\n            if remain :\n                arrange.append(maxi + 1)  # add 1 till the reaminder become 0\n                remain -= 1\n            else:\n                arrange.append(maxi)\n\n        # now traverse the linked list and split the node \n        j = 0\n        ptr = head \n        i = 0\n        while(ptr) :\n            q = ptr \n            i += 1\n            ptr = ptr.next \n            # if the new length i is equal to the arrange[i] then just make that nodes next pointer to None\n            if i == arrange[j] :\n                q.next = None\n                l.append(head)\n                head = ptr \n                i = 0\n                j += 1\n\n        # if the length is not satisfied then just add none\n        for i in range(j,k):\n            l.append(None)\n        return l",
        "content": "\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def splitListToParts(self, head: Optional[ListNode], k: int) -> List[Optional[ListNode]]:\\n\\n        # first calculate the length\\n        # then find the arrangement of the number of elements and store it in list\\n    \\n        l = []\\n        length = 0\\n        ptr = head\\n        while(ptr) :\\n            length += 1\\n            ptr = ptr.next\\n\\n        # possible length of the elements of an node to split\\n        # first find how much it will be posiibe to split by length // k\\n        # then calculate the remaining no of elements by length % k\\n        arrange = []\\n        maxi = length//k \\n        remain = length%k\\n\\n        for i in range(k) :\\n            if remain :\\n                arrange.append(maxi + 1)  # add 1 till the reaminder become 0\\n                remain -= 1\\n            else:\\n                arrange.append(maxi)\\n\\n        # now traverse the linked list and split the node \\n        j = 0\\n        ptr = head \\n        i = 0\\n        while(ptr) :\\n            q = ptr \\n            i += 1\\n            ptr = ptr.next \\n            # if the new length i is equal to the arrange[i] then just make that nodes next pointer to None\\n            if i == arrange[j] :\\n                q.next = None\\n                l.append(head)\\n                head = ptr \\n                i = 0\\n                j += 1\\n\\n        # if the length is not satisfied then just add none\\n        for i in range(j,k):\\n            l.append(None)\\n        return l\\n```",
        "level": "medium",
        "type": [
            "undefined objects",
            "undefined keywords from other languages",
            "conditional statement error"
        ],
        "buggy_code": "\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def splitListToParts(self, head: Optional[ListNode], k: int) -> List[Optional[ListNode]]:\n\n        # first calculate the length\n        # then find the arrangement of the number of elements and store it in list\n    \n        l = []\n        length = 0\n        ptr = head\n        while(ptr) :\n            length += 1\n            ptr = ptr.next\n\n        # possible length of the elements of an node to split\n        # first find how much it will be posiibe to split by length // k\n        # then calculate the remaining no of elements by length % k\n        arrange = []\n        maxi = len//k \n        remain = len%k\n\n        for i in range(k) :\n            if remain :\n                arrange.push(maxi + 1)  \n                remain -= 1\n            else:\n                arrange.push(maxi)\n\n        # now traverse the linked list and split the node \n        j = 0\n        ptr = head \n        i = 0\n        while(ptr) :\n            q = ptr \n            i += 1\n            ptr = ptr.next \n            # if the new length i is equal to the arrange[i] then just make that nodes next pointer to None\n            if i == arrange[j] :\n                q.next = None\n                l.push(head)\n                head = ptr \n                i = 0\n                j += 1\n\n        # if the length is not satisfied then just add none\n        for i in range(j,k+1):\n            l.push(None)\n        return l\n"
    },
    {
        "slug": "maximum-of-absolute-value-expression",
        "description": "Given two arrays of integers with equal lengths, return the maximum value of:\n|arr1[i] - arr1[j]| + |arr2[i] - arr2[j]| + |i - j|\nwhere the maximum is taken over all 0 <= i, j < arr1.length.",
        "examples": [
            "Input: arr1 = [1,2,3,4], arr2 = [-1,4,5,6]\nOutput: 13",
            "Input: arr1 = [1,-2,-5,0,10], arr2 = [0,-2,-1,-7,-4]\nOutput: 20"
        ],
        "constraints": "2 <= arr1.length == arr2.length <= 40000\n-10^6 <= arr1[i], arr2[i] <= 10^6",
        "oracle_code": "class Solution:\n    def maxAbsValExpr(self, arr1: List[int], arr2: List[int]) -> int:\n        '''\n        |a1[i]-a1[j]| + |a2[i]-a2[j]| + |i-j|\n        total 2(+ or -)**(no. of modules) == 2**3 cases\n\n        --> a1[i]-a1[j]+a2[i]-a2[j]+i-j\n            == (a1[i]+a2[i]+i) - (a1[j]+a2[j]+j)\n\n        --> a1[i]-a1[j]+a2[i]-a2[j]-i-j\n            == (a1[i]+a2[i]-i) - (a1[j]+a2[j]-j)\n        \n        ...etc\n        '''\n        val1,val2,val3,val4=[],[],[],[]\n        for i in range(len(arr1)):\n            val1.append(i+arr1[i]+arr2[i])\n            val2.append(i+arr1[i]-arr2[i])\n            val3.append(i-arr1[i]+arr2[i])\n            val4.append(i-arr1[i]-arr2[i])\n        ans=0\n        ans=max(ans,max(val1)-min(val1))\n        ans=max(ans,max(val2)-min(val2))\n        ans=max(ans,max(val3)-min(val3))\n        ans=max(ans,max(val4)-min(val4))\n        return ans",
        "content": "# Code\\n```\\nclass Solution:\\n    def maxAbsValExpr(self, arr1: List[int], arr2: List[int]) -> int:\\n        \\'\\'\\'\\n        |a1[i]-a1[j]| + |a2[i]-a2[j]| + |i-j|\\n        total 2(+ or -)**(no. of modules) == 2**3 cases\\n\\n        --> a1[i]-a1[j]+a2[i]-a2[j]+i-j\\n            == (a1[i]+a2[i]+i) - (a1[j]+a2[j]+j)\\n\\n        --> a1[i]-a1[j]+a2[i]-a2[j]-i-j\\n            == (a1[i]+a2[i]-i) - (a1[j]+a2[j]-j)\\n        \\n        ...etc\\n        \\'\\'\\'\\n        val1,val2,val3,val4=[],[],[],[]\\n        for i in range(len(arr1)):\\n            val1.append(i+arr1[i]+arr2[i])\\n            val2.append(i+arr1[i]-arr2[i])\\n            val3.append(i-arr1[i]+arr2[i])\\n            val4.append(i-arr1[i]-arr2[i])\\n        ans=0\\n        ans=max(ans,max(val1)-min(val1))\\n        ans=max(ans,max(val2)-min(val2))\\n        ans=max(ans,max(val3)-min(val3))\\n        ans=max(ans,max(val4)-min(val4))\\n        return ans\\n```",
        "level": "medium",
        "type": [
            "indentation error",
            "operation error",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n    def maxAbsValExpr(self, arr1: List[int], arr2: List[int]) -> int:\n        val1,val2,val3,val4=[],[],[],[]\n        for i in range(len(arr1)):\n            val1.append(i+arr1[i]+arr2[i])\n            val2.append(i+arr1[i]-arr2[i])\n            val3.append(i-arr1[i]+arr2[i])\n        val4.append(i-arr1[i]-arr2[i])\n        ans=0\n        ans=min(ans,max(val1)-min(val1))\n        ans=min(ans,max(val2)-min(val2))\n        ans=min(ans,max(val3)-min(val3))\n        ans=min(ans,max(val4)-min(val4)) == 0\n        return ans\n"
    },
    {
        "slug": "median-of-two-sorted-arrays",
        "description": "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\nThe overall run time complexity should be O(log (m+n)).",
        "examples": [
            "Input: nums1 = [1,3], nums2 = [2]\nOutput: 2.00000\nExplanation: merged array = [1,2,3] and median is 2.",
            "Input: nums1 = [1,2], nums2 = [3,4]\nOutput: 2.50000\nExplanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5."
        ],
        "constraints": "nums1.length == m\nnums2.length == n\n0 <= m <= 1000\n0 <= n <= 1000\n1 <= m + n <= 2000\n-106 <= nums1[i], nums2[i] <= 106",
        "oracle_code": "class Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        p1 = 0\n        p2 = 0\n        new = []\n        while p1 < len(nums1) and p2 < len(nums2):\n            if nums1[p1] < nums2[p2]:\n                new.append(nums1[p1])\n                p1 += 1\n            else:\n                new.append(nums2[p2])\n                p2 += 1\n        while p1 < len(nums1):\n            new.append(nums1[p1])\n            p1 += 1\n        while p2 < len(nums2):\n            new.append(nums2[p2])\n            p2+= 1\n        if len(new) % 2 == 0:\n            index = len(new) // 2\n            median = (new[index] + new[index-1]) / 2\n        else:\n            median = float(new[len(new)//2])\n        return median",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind this approach is to merge the two sorted arrays while maintaining the order, and then finding the median based on the length of the merged array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize two pointers, p1 and p2, for the two input arrays nums1 and nums2, respectively, both starting at index 0.\\n2. Create an empty list new to store the merged array.\\n3. Iterate through both arrays using the pointers. Compare the elements pointed to by p1 and p2. Append the smaller element to the new array and increment the corresponding pointer.\\n4. After the iteration, there might be remaining elements in one of the arrays. Iterate through the remaining elements and append them to the new array.\\n5. Calculate the median based on the length of the new array. If the length is even, take the average of the middle two elements. If the length is odd, take the middle element.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(m + n), where m and n are the lengths of the two input arrays.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(m + n), as the merged array new can contain all the elements from the two input arrays.\\n\\n# Code\\n```\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        p1 = 0\\n        p2 = 0\\n        new = []\\n        while p1 < len(nums1) and p2 < len(nums2):\\n            if nums1[p1] < nums2[p2]:\\n                new.append(nums1[p1])\\n                p1 += 1\\n            else:\\n                new.append(nums2[p2])\\n                p2 += 1\\n        while p1 < len(nums1):\\n            new.append(nums1[p1])\\n            p1 += 1\\n        while p2 < len(nums2):\\n            new.append(nums2[p2])\\n            p2+= 1\\n        if len(new) % 2 == 0:\\n            index = len(new) // 2\\n            median = (new[index] + new[index-1]) / 2\\n        else:\\n            median = float(new[len(new)//2])\\n        return median\\n```",
        "level": "hard",
        "type": [
            "colon missing",
            "== and = confusion",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float\n        p1 = 0\n        p2 = 0\n        new = []\n        while p1 < len(nums1) and p2 < len(nums2):\n            if nums1[p1] < nums2[p2]:\n                new.append(nums1[p1])\n                p1 = 1\n            else:\n                new.append(nums2[p2])\n                p2 += 1\n        while p1 < len(nums1):\n            new.append(nums1[p1])\n            p1 += 1\n        while p2 <= len(nums2):\n            new.append(nums2[p2])\n            p2+= 1\n        if len(new) % 2 == 0:\n            index = len(new) // 2\n            median = (new[index] + new[index-1]) / 2\n        else:\n            median = float(new[len(new)//2])\n        return median\n"
    },
    {
        "slug": "find-closest-node-to-given-two-nodes",
        "description": "You are given a directed graph of n nodes numbered from 0 to n - 1, where each node has at most one outgoing edge.\nThe graph is represented with a given 0-indexed array edges of size n, indicating that there is a directed edge from node i to node edges[i]. If there is no outgoing edge from i, then edges[i] == -1.\nYou are also given two integers node1 and node2.\nReturn the index of the node that can be reached from both node1 and node2, such that the maximum between the distance from node1 to that node, and from node2 to that node is minimized. If there are multiple answers, return the node with the smallest index, and if no possible answer exists, return -1.\nNote that edges may contain cycles.",
        "examples": [
            "Input: edges = [2,2,3,-1], node1 = 0, node2 = 1\nOutput: 2\nExplanation: The distance from node 0 to node 2 is 1, and the distance from node 1 to node 2 is 1.\nThe maximum of those two distances is 1. It can be proven that we cannot get a node with a smaller maximum distance than 1, so we return node 2.",
            "Input: edges = [1,2,-1], node1 = 0, node2 = 2\nOutput: 2\nExplanation: The distance from node 0 to node 2 is 2, and the distance from node 2 to itself is 0.\nThe maximum of those two distances is 2. It can be proven that we cannot get a node with a smaller maximum distance than 2, so we return node 2."
        ],
        "constraints": "n == edges.length\n2 <= n <= 105\n-1 <= edges[i] < n\nedges[i] != i\n0 <= node1, node2 < n",
        "oracle_code": "class Solution:\n    def cdist(self, it, distArray, distArrayIndex, edges):\n        rdist = 0 \n        nodes = []\n        while it != -1 and distArray[it][distArrayIndex] > rdist:\n            distArray[it][distArrayIndex] = rdist\n            nodes.append(it)\n            it = edges[it]\n            rdist += 1\n        return nodes\n            \n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\n        INF = float('inf')\n        dist = defaultdict(lambda: [INF,INF])\n        mmin, ans = INF, INF\n               \n        n = self.cdist(node1, dist, 0, edges)\n        n += self.cdist(node2, dist, 1, edges)\n                \n        for k in n:\n            m = max(dist[k])\n            if m != INF:\n                if m < mmin: \n                    mmin = m\n                    ans = k\n                elif m == mmin: \n                    ans = min(ans, k)\n                    \n        return ans if ans != float('inf') else -1",
        "content": "Since there is atmost one outgoing edge with cycles, we can iterate this graph in simple manner as cdist function below. The logic briefly is as below. \\n1. Calculate distances between node1 and other reachable nodes. \\n2. Do the same as (1) for node 2\\n3. Iterate the nodes that are on the path for both distances and find max. \\n4. find min of maxes and keep track of minimum index. \\n\\nIf there was a constraint that node1 and node2 have a guarenteed path between them, the problem could have been simpler, to construct find the shortestPath between node1 -> node 2 and the ans is one of the nodes in between. Thats not the case ! \\n\\n```\\nclass Solution:\\n    def cdist(self, it, distArray, distArrayIndex, edges):\\n        rdist = 0 \\n        nodes = []\\n        while it != -1 and distArray[it][distArrayIndex] > rdist:\\n            distArray[it][distArrayIndex] = rdist\\n            nodes.append(it)\\n            it = edges[it]\\n            rdist += 1\\n        return nodes\\n            \\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        INF = float(\\'inf\\')\\n        dist = defaultdict(lambda: [INF,INF])\\n        mmin, ans = INF, INF\\n               \\n        n = self.cdist(node1, dist, 0, edges)\\n        n += self.cdist(node2, dist, 1, edges)\\n                \\n        for k in n:\\n            m = max(dist[k])\\n            if m != INF:\\n                if m < mmin: \\n                    mmin = m\\n                    ans = k\\n                elif m == mmin: \\n                    ans = min(ans, k)\\n                    \\n        return ans if ans != float(\\'inf\\') else -1\\n```\\n\\nA slightly modified logic, \\n\\n```\\nclass Solution:\\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        INF = float(\\'inf\\')\\n        N = len(edges)\\n        dist_node1 = [INF for _ in range(N)]\\n        dist_node2 = [INF for _ in range(N)]\\n        \\n        def dfs(node, di, d):\\n            if d[node] > di: \\n                d[node] = di\\n                if edges[node] != -1:\\n                    dfs(edges[node], di+1, d)\\n        \\n        dfs(node1, 0, dist_node1)\\n        dfs(node2, 0, dist_node2)\\n\\n        for i in range(N):\\n            dist_node1[i] = max(dist_node1[i], dist_node2[i])\\n                        \\n        ans = dist_node1.index(min(dist_node1))\\n        return ans if dist_node1[ans] != INF else -1\\n",
        "level": "medium",
        "type": [
            "indentation error",
            "undefined keywords from other languages",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def cdist(self, it, distArray, distArrayIndex, edges):\n    rdist = 0 \n    nodes = []\n    while it != -1 and distArray[it+1][distArrayIndex] > rdist:\n        distArray[it][distArrayIndex] = rdist\n        nodes.append(it)\n        it = edges[it]\n        rdist += 1\n    return nodes\n            \n    def closestMeetingNode(self, edges: List<int>, node1: int, node2: int) -> int:\n        INF = float('inf')\n        dist = defaultdict(lambda: [INF,INF])\n        mmin, ans = INF, INF\n               \n        n = self.cdist(node1, dist, 0, edges)\n        n += var self.cdist(node2, dist, 1, edges)\n                \n        for k in n:\n            m = max(dist[k])\n            if m != INF:\n                if m < mmin: \n                    mmin = m\n                    ans = k\n                elif m == mmin: \n                    ans = min(ans, k)\n                    \n        return ans if ans != float('inf') else -1\n"
    },
    {
        "slug": "stone-game-vi",
        "description": "Alice and Bob take turns playing a game, with Alice starting first.\nThere are n stones in a pile. On each player's turn, they can remove a stone from the pile and receive points based on the stone's value. Alice and Bob may value the stones differently.\nYou are given two integer arrays of length n, aliceValues and bobValues. Each aliceValues[i] and bobValues[i] represents how Alice and Bob, respectively, value the ith stone.\nThe winner is the person with the most points after all the stones are chosen. If both players have the same amount of points, the game results in a draw. Both players will play optimally.\u00a0Both players know the other's values.\nDetermine the result of the game, and:\n\nIf Alice wins, return 1.\nIf Bob wins, return -1.\nIf the game results in a draw, return 0.",
        "examples": [
            "Input: aliceValues = [1,3], bobValues = [2,1]\nOutput: 1\nExplanation:\nIf Alice takes stone 1 (0-indexed) first, Alice will receive 3 points.\nBob can only choose stone 0, and will only receive 2 points.\nAlice wins.",
            "Input: aliceValues = [1,2], bobValues = [3,1]\nOutput: 0\nExplanation:\nIf Alice takes stone 0, and Bob takes stone 1, they will both have 1 point.\nDraw.",
            "Input: aliceValues = [2,4,3], bobValues = [1,6,7]\nOutput: -1\nExplanation:\nRegardless of how Alice plays, Bob will be able to have more points than Alice.\nFor example, if Alice takes stone 1, Bob can take stone 2, and Alice takes stone 0, Alice will have 6 points to Bob's 7.\nBob wins."
        ],
        "constraints": "n == aliceValues.length == bobValues.length\n1 <= n <= 105\n1 <= aliceValues[i], bobValues[i] <= 100",
        "oracle_code": "class Solution:\n    def stoneGameVI(self, a: List[int], b: List[int]) -> int:\n        # hurt other enemy rather than self collecting to max\n        combines = [(a[i] + b[i], a[i], b[i]) for i in range(len(a))]\n        combines.sort(reverse=True) # why we can sort? -> because we can pick any stone we want\n        bobPoints = sum(b)\n        alicePoints = 0\n        for i in range(0, len(a), 2):\n            alicePoints += combines[i][1]\n            bobPoints -= combines[i][2]\n        if alicePoints > bobPoints:\n            return 1\n        elif alicePoints < bobPoints:\n            return -1\n        return 0",
        "content": "# Intuition\\nIn this problem instead of picking/not Picking largest making sum we need to pick those stones by alice which can hurt bob more.\\nSo we combine them and sort them in reverse order\\n`why we can do sorting? Because in question its stated we can pick any stone (and not only from left most or right most)`\\nNow alice will pick first highest combined effecting the bobPoints most (which is the total Sum of bob values) and then skip next point (which is to be picked by bob).\\nAccording to our alicePoints and bobPoints return the ans.\\n\\n# Code\\n```\\nclass Solution:\\n    def stoneGameVI(self, a: List[int], b: List[int]) -> int:\\n        # hurt other enemy rather than self collecting to max\\n        combines = [(a[i] + b[i], a[i], b[i]) for i in range(len(a))]\\n        combines.sort(reverse=True) # why we can sort? -> because we can pick any stone we want\\n        bobPoints = sum(b)\\n        alicePoints = 0\\n        for i in range(0, len(a), 2):\\n            alicePoints += combines[i][1]\\n            bobPoints -= combines[i][2]\\n        if alicePoints > bobPoints:\\n            return 1\\n        elif alicePoints < bobPoints:\\n            return -1\\n        return 0\\n        \\n\\n```",
        "level": "medium",
        "type": [
            "variable value error",
            "undefined objects",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution:\n    def stoneGameVI(self, a: List[int], b: List[int]) -> int:\n        combines = [(a[i] + c[i], a[i], b[i]) for i in range(len(a))]\n        combines.sort(reverse=True)\n        bobPoints = sum(b)\n        alicePoints = 0\n        for i in range(1, len(a), 2):\n            alicePoints += combines[i][1]\n            bobPoints -= combines[i][2]\n        if alicePoints > bobPoints:\n            return 1\n        elif alicePoints < bobPoints:\n            return -1\n        return 0\n"
    },
    {
        "slug": "minimum-speed-to-arrive-on-time",
        "description": "You are given a floating-point number hour, representing the amount of time you have to reach the office. To commute to the office, you must take n trains in sequential order. You are also given an integer array dist of length n, where dist[i] describes the distance (in kilometers) of the ith train ride.\nEach train can only depart at an integer hour, so you may need to wait in between each train ride.\n\nFor example, if the 1st train ride takes 1.5 hours, you must wait for an additional 0.5 hours before you can depart on the 2nd train ride at the 2 hour mark.\n\nReturn the minimum positive integer speed (in kilometers per hour) that all the trains must travel at for you to reach the office on time, or -1 if it is impossible to be on time.\nTests are generated such that the answer will not exceed 107 and hour will have at most two digits after the decimal point.",
        "examples": [
            "Input: dist = [1,3,2], hour = 6\nOutput: 1\nExplanation: At speed 1:\n- The first train ride takes 1/1 = 1 hour.\n- Since we are already at an integer hour, we depart immediately at the 1 hour mark. The second train takes 3/1 = 3 hours.\n- Since we are already at an integer hour, we depart immediately at the 4 hour mark. The third train takes 2/1 = 2 hours.\n- You will arrive at exactly the 6 hour mark.",
            "Input: dist = [1,3,2], hour = 2.7\nOutput: 3\nExplanation: At speed 3:\n- The first train ride takes 1/3 = 0.33333 hours.\n- Since we are not at an integer hour, we wait until the 1 hour mark to depart. The second train ride takes 3/3 = 1 hour.\n- Since we are already at an integer hour, we depart immediately at the 2 hour mark. The third train takes 2/3 = 0.66667 hours.\n- You will arrive at the 2.66667 hour mark.",
            "Input: dist = [1,3,2], hour = 1.9\nOutput: -1\nExplanation: It is impossible because the earliest the third train can depart is at the 2 hour mark."
        ],
        "constraints": "n == dist.length\n1 <= n <= 105\n1 <= dist[i] <= 105\n1 <= hour <= 109\nThere will be at most two digits after the decimal point in hour.",
        "oracle_code": "class Solution:\n    def minSpeedOnTime(self, dist: List[int], hour: float) -> int:\n        if len(dist) >= hour + 1  : return -1\n        left,right = 1, ceil(max(max(dist),dist[-1]/(1 if hour.is_integer() else hour-int(hour))))\n        while left<right:\n            mid=(left+right)//2\n            if sum([ceil(i/mid) for i in dist[:-1]])+(dist[-1]/mid) <= hour :\n                right=mid\n            else:\n                left=mid+1\n        return left",
        "content": "![image.png](https://assets.leetcode.com/users/images/b88e2aad-dabb-4eac-afd0-759a7cc70942_1690342594.5715153.png)\\n\\n\\n# Complexity\\n- Time complexity: O(m*log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minSpeedOnTime(self, dist: List[int], hour: float) -> int:\\n        if len(dist) >= hour + 1  : return -1\\n        left,right = 1, ceil(max(max(dist),dist[-1]/(1 if hour.is_integer() else hour-int(hour))))\\n        while left<right:\\n            mid=(left+right)//2\\n            if sum([ceil(i/mid) for i in dist[:-1]])+(dist[-1]/mid) <= hour :\\n                right=mid\\n            else:\\n                left=mid+1\\n        return left\\n```",
        "level": "medium",
        "type": [
            "indentation error",
            "indexing error",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def minSpeedOnTime(self, dist: List[int], hour: float) -> int:\n    if len(dist) >= hour - 1  : return -1\n    left,right = 1, ceil(max(max(dist),dist[-2]/(1 if hour.is_integer() else hour-int(hour))))\n    while left<right:\n        mid=(left+right)//2\n        if sum([ceil(i/mid) for i in dist[:-1]])+(dist[-1]/mid) <= hour :\n            right=mid\n        else:\n            left=mid+1\n    return left\n"
    },
    {
        "slug": "check-if-string-is-transformable-with-substring-sort-operations",
        "description": "Given two strings s and t, transform string s into string t using the following operation any number of times:\n\nChoose a non-empty substring in s and sort it in place so the characters are in ascending order.\n\n\t\nFor example, applying the operation on the underlined substring in \"14234\" results in \"12344\".\n\n\n\nReturn true if it is possible to transform s into t. Otherwise, return false.\nA substring is a contiguous sequence of characters within a string.",
        "examples": [
            "Input: s = \"84532\", t = \"34852\"\nOutput: true\nExplanation: You can transform s into t using the following sort operations:\n\"84532\" (from index 2 to 3) -> \"84352\"\n\"84352\" (from index 0 to 2) -> \"34852\"",
            "Input: s = \"34521\", t = \"23415\"\nOutput: true\nExplanation: You can transform s into t using the following sort operations:\n\"34521\" -> \"23451\"\n\"23451\" -> \"23415\"",
            "Input: s = \"12345\", t = \"12435\"\nOutput: false"
        ],
        "constraints": "s.length == t.length\n1 <= s.length <= 105\ns and t consist of only digits.",
        "oracle_code": "class BIT():\n    def __init__(self, n):\n        self.n = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        ans = 0\n        i += 1\n        while i > 0:\n            ans += self.tree[i]\n            i -= (i & (-i))\n        return ans\n\n    def update(self, i, value):\n        i += 1\n        while i <= self.n:\n            self.tree[i] += value\n            i += (i & (-i))\n\n\nclass Solution:\n    def isTransformable(self, s: str, t: str) -> bool:\n        if Counter(s)!=Counter(t):\n            return False\n        ind = defaultdict(deque)\n        for id, i in enumerate(t):\n            ind[i].append(id)\n        a = []\n        for i in s:\n            a.append(ind[i].popleft())\n        n=len(a)\n        bt=BIT(n+1)\n        ind=defaultdict(lambda :-1)\n        for i in range(n):\n            inv=bt.sum(n)-bt.sum(a[i])\n            bt.update(a[i],1)\n            for dig in range(int(s[i])-1,-1,-1):\n                if ind[dig]>=i-inv:\n                    return False\n            ind[int(s[i])]=i-inv\n        return True",
        "content": "\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass BIT():\\n    def __init__(self, n):\\n        self.n = n\\n        self.tree = [0] * (n + 1)\\n\\n    def sum(self, i):\\n        ans = 0\\n        i += 1\\n        while i > 0:\\n            ans += self.tree[i]\\n            i -= (i & (-i))\\n        return ans\\n\\n    def update(self, i, value):\\n        i += 1\\n        while i <= self.n:\\n            self.tree[i] += value\\n            i += (i & (-i))\\n\\n\\nclass Solution:\\n    def isTransformable(self, s: str, t: str) -> bool:\\n        if Counter(s)!=Counter(t):\\n            return False\\n        ind = defaultdict(deque)\\n        for id, i in enumerate(t):\\n            ind[i].append(id)\\n        a = []\\n        for i in s:\\n            a.append(ind[i].popleft())\\n        n=len(a)\\n        bt=BIT(n+1)\\n        ind=defaultdict(lambda :-1)\\n        for i in range(n):\\n            inv=bt.sum(n)-bt.sum(a[i])\\n            bt.update(a[i],1)\\n            for dig in range(int(s[i])-1,-1,-1):\\n                if ind[dig]>=i-inv:\\n                    return False\\n            ind[int(s[i])]=i-inv\\n        return True\\n\\n\\n```",
        "level": "hard",
        "type": [
            "indentation error",
            "colon missing",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass BIT():\n    def __init__(self, n):\n        self.n = n\n    self.tree = [0] * (n + 1)\n\n    def sum(self, i)\n        ans = 0\n        i += 1\n        while i > 0:\n            ans += self.tree[i]\n            i -= (i & (-i))\n        return ans\n\n    def update(self, i, value):\n        i += 1\n        while i <= self.n:\n            self.tree[i] += value\n            i += (i & (-i))\n\n\nclass Solution:\n    def isTransformable(self, s: str, t: str) -> bool:\n        if Counter(s)!=Counter(t):\n            return False\n        ind = defaultdict(deque)\n        for id, i in enumerate(t):\n            ind[i].append(id)\n        a = []\n        for i in s:\n            a.append(ind[i].popleft())\n        n=len(a)\n        bt=BIT(n+1)\n        ind=defaultdict(lambda :-1)\n        for i in range(n):\n            inv=bt.sum(n)-bt.sum(a[i])\n            bt.update(a[i],1)\n            for dig in range(int(s[i])-1,-1,-1):\n                if ind[dig]>=i-inv:\n                    return False\n            ind[parseFloat(s[i])]=i-inv\n        return True\n"
    },
    {
        "slug": "sum-of-subarray-minimums",
        "description": "Given an array of integers arr, find the sum of min(b), where b ranges over every (contiguous) subarray of arr. Since the answer may be large, return the answer modulo 109 + 7.",
        "examples": [
            "Input: arr = [3,1,2,4]\nOutput: 17\nExplanation: \nSubarrays are [3], [1], [2], [4], [3,1], [1,2], [2,4], [3,1,2], [1,2,4], [3,1,2,4]. \nMinimums are 3, 1, 2, 4, 1, 1, 2, 1, 1, 1.\nSum is 17.",
            "Input: arr = [11,81,94,43,3]\nOutput: 444"
        ],
        "constraints": "1 <= arr.length <= 3 * 104\n1 <= arr[i] <= 3 * 104",
        "oracle_code": "class Solution:\n    def sumSubarrayMins(self, arr: List[int]) -> int:\n        stack = []\n        res = 0\n        arr = [float('-inf')] + arr + [float('-inf')]\n        for i, num in enumerate(arr):\n            while stack and arr[stack[-1]] > num:\n                cur = stack.pop()\n                res += arr[cur] * (i - cur) * (cur - stack[-1])\n            stack.append(i)\n        return res % (10**9 + 7)",
        "content": "Maintain a stack of indexes of subarrays, \\nwhich would have the minimum number at the top of the stack.\\n \\nUse following logic to compute the sum(i):\\n- If arr[i] is small, then arr[i] is minimum for all subarrays \\nstarting at arr[i].\\n- If arr[i] is greater, then find the smallest element from the top of stack which is bigger than arr[i]. \\n- Let the index of the smallest element be on top. \\n- Now, arr[i] is minimum for all subarrays starting at arr[top+1]. \\n\\nWe already know the value of sum(top), so add sum(top) + arr[i] * (i \\u2013 top) to result. Finally, push the index of arr[i] to stack.\\n\\n# Complexity\\nTime Complexity: O(N)\\nSpace Complexity: O(N)\\n\\n# Code\\n```\\nclass Solution:\\n    def sumSubarrayMins(self, arr: List[int]) -> int:\\n        stack = []\\n        res = 0\\n        arr = [float(\\'-inf\\')] + arr + [float(\\'-inf\\')]\\n        for i, num in enumerate(arr):\\n            while stack and arr[stack[-1]] > num:\\n                cur = stack.pop()\\n                res += arr[cur] * (i - cur) * (cur - stack[-1])\\n            stack.append(i)\\n        return res % (10**9 + 7)\\n\\n```",
        "level": "medium",
        "type": [
            "other error",
            "unclosed string",
            "wrong comment mark"
        ],
        "buggy_code": "\nclass Solution:\n    def sumSubarrayMins(self, arr: List[int]) -> int:\n        stack = []\n        res = 0\n        \n        for i, num in enumerate(arr):\n            while stack and arr[stack[-1]] > num:\n                cur = stack.pop()\n                res += arr[cur] * (cur - i) * (cur - stack[-1]\n            stack.append(i)\n        return res % (10**9 + 7)\n"
    },
    {
        "slug": "string-compression-ii",
        "description": "Run-length encoding is a string compression method that works by\u00a0replacing consecutive identical characters (repeated 2 or more times) with the concatenation of the character and the number marking the count of the characters (length of the run). For example, to compress the string\u00a0\"aabccc\"\u00a0we replace \"aa\"\u00a0by\u00a0\"a2\"\u00a0and replace \"ccc\"\u00a0by\u00a0\"c3\". Thus the compressed string becomes \"a2bc3\".\nNotice that in this problem, we are not adding\u00a0'1'\u00a0after single characters.\nGiven a\u00a0string s\u00a0and an integer k. You need to delete at most\u00a0k characters from\u00a0s\u00a0such that the run-length encoded version of s\u00a0has minimum length.\nFind the minimum length of the run-length encoded\u00a0version of s after deleting at most k characters.",
        "examples": [
            "Input: s = \"aaabcccd\", k = 2\nOutput: 4\nExplanation: Compressing s without deleting anything will give us \"a3bc3d\" of length 6. Deleting any of the characters 'a' or 'c' would at most decrease the length of the compressed string to 5, for instance delete 2 'a' then we will have s = \"abcccd\" which compressed is abc3d. Therefore, the optimal way is to delete 'b' and 'd', then the compressed version of s will be \"a3c3\" of length 4.",
            "Input: s = \"aabbaa\", k = 2\nOutput: 2\nExplanation: If we delete both 'b' characters, the resulting compressed string would be \"a4\" of length 2.",
            "Input: s = \"aaaaaaaaaaa\", k = 0\nOutput: 3\nExplanation: Since k is zero, we cannot delete anything. The compressed string is \"a11\" of length 3."
        ],
        "constraints": "1 <= s.length <= 100\n0 <= k <= s.length\ns contains only lowercase English letters.",
        "oracle_code": "class Solution:\n    def dp(self,i,s,prev,k,ct,n,dct):\n        if k<0:\n            return float(\"infinity\")\n        if i>=n:\n            x=0\n            if ct>1:\n                x=len(str(ct))+1\n            elif ct==1:\n                x=1\n            return x\n        if (i,prev,ct,k) in dct:\n            return dct[(i,prev,ct,k)]\n        if s[i]==prev:\n            inc=self.dp(i+1,s,prev,k,ct+1,n,dct)\n        else:\n            x=0\n            if ct>1:\n                x=len(str(ct))+1\n            elif ct==1:\n                x=1\n            inc=x+self.dp(i+1,s,s[i],k,1,n,dct)\n        exc=self.dp(i+1,s,prev,k-1,ct,n,dct)\n        dct[(i,prev,ct,k)]=min(inc,exc)\n        return min(inc,exc)\n\n\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n        n=len(s)\n        return self.dp(0,s,\"\",k,0,n,{})",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def dp(self,i,s,prev,k,ct,n,dct):\\n        if k<0:\\n            return float(\"infinity\")\\n        if i>=n:\\n            x=0\\n            if ct>1:\\n                x=len(str(ct))+1\\n            elif ct==1:\\n                x=1\\n            return x\\n        if (i,prev,ct,k) in dct:\\n            return dct[(i,prev,ct,k)]\\n        if s[i]==prev:\\n            inc=self.dp(i+1,s,prev,k,ct+1,n,dct)\\n        else:\\n            x=0\\n            if ct>1:\\n                x=len(str(ct))+1\\n            elif ct==1:\\n                x=1\\n            inc=x+self.dp(i+1,s,s[i],k,1,n,dct)\\n        exc=self.dp(i+1,s,prev,k-1,ct,n,dct)\\n        dct[(i,prev,ct,k)]=min(inc,exc)\\n        return min(inc,exc)\\n\\n\\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\\n        n=len(s)\\n        return self.dp(0,s,\"\",k,0,n,{})\\n\\n        \\n```",
        "level": "hard",
        "type": [
            "operation error",
            "parentheses mismatch",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n    def dp(self,i,s,prev,k,ct,n,dct:\n        if k<0:\n            return float(\"infinity\")\n        if i>=n:\n            x=0\n            if ct>1:\n                x=len(str(ct))+1\n            elif ct==1:\n                x=1\n            return x\n        if (i,prev,ct,k) in dct:\n            return dct[(i,prev,ct,k)]\n        if s[i]==prev:\n            inc=self.dp(i+1,s,prev,k,ct+1,n,dct)\n        else:\n            x=0\n            if ct>1:\n                x=len(str(ct))+1\n            elif ct==1:\n                x=1\n            inc=x+self.dp(i+1,s,s[i],k,1,n,dct)\n        exc=self.dp(i+1,s,prev,k-1,ct,n,dct)\n        dct[(i,prev,ct,k)]=max(inc,exc) == 0\n        return min(inc,exc)\n\n\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n        n=len(s)\n        return self.dp(0,s,\"\",k,0,n,{})\n"
    },
    {
        "slug": "partition-array-into-three-parts-with-equal-sum",
        "description": "Given an array of integers arr, return true if we can partition the array into three non-empty parts with equal sums.\nFormally, we can partition the array if we can find indexes i + 1 < j with (arr[0] + arr[1] + ... + arr[i] == arr[i + 1] + arr[i + 2] + ... + arr[j - 1] == arr[j] + arr[j + 1] + ... + arr[arr.length - 1])",
        "examples": [
            "Input: arr = [0,2,1,-6,6,-7,9,1,2,0,1]\nOutput: true\nExplanation: 0 + 2 + 1 = -6 + 6 - 7 + 9 + 1 = 2 + 0 + 1",
            "Input: arr = [0,2,1,-6,6,7,9,-1,2,0,1]\nOutput: false",
            "Input: arr = [3,3,6,5,-2,2,5,1,-9,4]\nOutput: true\nExplanation: 3 + 3 = 6 = 5 - 2 + 2 + 5 + 1 - 9 + 4"
        ],
        "constraints": "3 <= arr.length <= 5 * 104\n-104 <= arr[i] <= 104",
        "oracle_code": "class Solution:\n    def canThreePartsEqualSum(self, arr: List[int]) -> bool:\n        total = sum(arr)\n        each_sum = total//3\n        if total % 3 != 0: return False\n        sumi = count = 0\n        for x in arr:\n            if count == 2:\n                return True\n            sumi += x\n            if sumi == each_sum:\n                sumi = 0\n                count += 1\n        return False",
        "content": "# Code\\n```\\nclass Solution:\\n    def canThreePartsEqualSum(self, arr: List[int]) -> bool:\\n        total = sum(arr)\\n        each_sum = total//3\\n        if total % 3 != 0: return False\\n        sumi = count = 0\\n        for x in arr:\\n            if count == 2:\\n                return True\\n            sumi += x\\n            if sumi == each_sum:\\n                sumi = 0\\n                count += 1\\n        return False\\n        \\n\\n```",
        "level": "easy",
        "type": [
            "indentation error",
            "wrong comment mark",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def canThreePartsEqualSum(self, arr: List[int]) -> bool:\n        total = sum(arr)\n            each_sum = total//3\n        if total % 3 != 0: return False\n        sumi = count = 0\n        for x in arr:\n            /**/sumi += x\n            if sumi == each_sum:\n                sumi = 0\n                count += 1\n            if count == 2:\n                return True\n        return False\n"
    },
    {
        "slug": "median-of-two-sorted-arrays",
        "description": "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\nThe overall run time complexity should be O(log (m+n)).",
        "examples": [
            "Input: nums1 = [1,3], nums2 = [2]\nOutput: 2.00000\nExplanation: merged array = [1,2,3] and median is 2.",
            "Input: nums1 = [1,2], nums2 = [3,4]\nOutput: 2.50000\nExplanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5."
        ],
        "constraints": "nums1.length == m\nnums2.length == n\n0 <= m <= 1000\n0 <= n <= 1000\n1 <= m + n <= 2000\n-106 <= nums1[i], nums2[i] <= 106",
        "oracle_code": "class Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        p1 = 0\n        p2 = 0\n        new = []\n        while p1 < len(nums1) and p2 < len(nums2):\n            if nums1[p1] < nums2[p2]:\n                new.append(nums1[p1])\n                p1 += 1\n            else:\n                new.append(nums2[p2])\n                p2 += 1\n        while p1 < len(nums1):\n            new.append(nums1[p1])\n            p1 += 1\n        while p2 < len(nums2):\n            new.append(nums2[p2])\n            p2+= 1\n        if len(new) % 2 == 0:\n            index = len(new) // 2\n            median = (new[index] + new[index-1]) / 2\n        else:\n            median = float(new[len(new)//2])\n        return median",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind this approach is to merge the two sorted arrays while maintaining the order, and then finding the median based on the length of the merged array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize two pointers, p1 and p2, for the two input arrays nums1 and nums2, respectively, both starting at index 0.\\n2. Create an empty list new to store the merged array.\\n3. Iterate through both arrays using the pointers. Compare the elements pointed to by p1 and p2. Append the smaller element to the new array and increment the corresponding pointer.\\n4. After the iteration, there might be remaining elements in one of the arrays. Iterate through the remaining elements and append them to the new array.\\n5. Calculate the median based on the length of the new array. If the length is even, take the average of the middle two elements. If the length is odd, take the middle element.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(m + n), where m and n are the lengths of the two input arrays.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(m + n), as the merged array new can contain all the elements from the two input arrays.\\n\\n# Code\\n```\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        p1 = 0\\n        p2 = 0\\n        new = []\\n        while p1 < len(nums1) and p2 < len(nums2):\\n            if nums1[p1] < nums2[p2]:\\n                new.append(nums1[p1])\\n                p1 += 1\\n            else:\\n                new.append(nums2[p2])\\n                p2 += 1\\n        while p1 < len(nums1):\\n            new.append(nums1[p1])\\n            p1 += 1\\n        while p2 < len(nums2):\\n            new.append(nums2[p2])\\n            p2+= 1\\n        if len(new) % 2 == 0:\\n            index = len(new) // 2\\n            median = (new[index] + new[index-1]) / 2\\n        else:\\n            median = float(new[len(new)//2])\\n        return median\\n```",
        "level": "hard",
        "type": [
            "indentation error",
            "colon missing",
            "wrong comment mark"
        ],
        "buggy_code": "\nclass Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float\n        p1 = 0\n        p2 = 0\n        \n        while p1 < len(nums1) and p2 < len(nums2):\n            if nums1[p1] < nums2[p2]:\n            new.append(nums1[p1])\n            p1 += 1\n        else:\n            new.append(nums2[p2])\n            p2 += 1\n        while p1 < len(nums1):\n            new.append(nums1[p1])\n            p1 += 1\n        while p2 < len(nums2):\n            new.append(nums2[p2])\n            p2+= 1\n        if len(new) % 2 == 0:\n            index = len(new) // 2\n            median = (new[index] + new[index-1]) / 2\n        else:\n            median = float(new[len(new)//2])\n        return median\n"
    },
    {
        "slug": "valid-permutations-for-di-sequence",
        "description": "You are given a string s of length n where s[i] is either:\n\n'D' means decreasing, or\n'I' means increasing.\n\nA permutation perm of n + 1 integers of all the integers in the range [0, n] is called a valid permutation if for all valid i:\n\nIf s[i] == 'D', then perm[i] > perm[i + 1], and\nIf s[i] == 'I', then perm[i] < perm[i + 1].\n\nReturn the number of valid permutations perm. Since the answer may be large, return it modulo 109 + 7.",
        "examples": [
            "Input: s = \"DID\"\nOutput: 5\nExplanation: The 5 valid permutations of (0, 1, 2, 3) are:\n(1, 0, 3, 2)\n(2, 0, 3, 1)\n(2, 1, 3, 0)\n(3, 0, 2, 1)\n(3, 1, 2, 0)",
            "Input: s = \"D\"\nOutput: 1"
        ],
        "constraints": "n == s.length\n1 <= n <= 200\ns[i] is either 'I' or 'D'.",
        "oracle_code": "class Solution:\n    def numPermsDISequence(self, s: str) -> int:\n        mem=defaultdict(int)\n        def dfs(i,val=0):\n            if i==len(s):\n                return 1\n            if (i,val) in mem:\n                return mem[i,val]\n            p=0\n            if s[i]==\"D\":\n                for ind in range(0,val+1):\n                    p+=dfs(i+1,ind)%(10**9+7)\n            else:\n                for ind in range(val+1,i+2):\n                    p+=dfs(i+1,ind)%(10**9+7)\n            mem[i,val]=p\n            return p\n        return dfs(0)",
        "content": "To add a new character to a sequence we only have to consider the last element-\\n\\nLets say currently DID sequence is 1032- this can form\\n\\nDIDI - in cases where we end with 3,4\\nDIDD - in cases where we end with 0,1,2\\n\\nSo just use the last element value to create a new sequence.\\n\\n```\\nclass Solution:\\n    def numPermsDISequence(self, s: str) -> int:\\n        mem=defaultdict(int)\\n        def dfs(i,val=0):\\n            if i==len(s):\\n                return 1\\n            if (i,val) in mem:\\n                return mem[i,val]\\n            p=0\\n            if s[i]==\"D\":\\n                for ind in range(0,val+1):\\n                    p+=dfs(i+1,ind)%(10**9+7)\\n            else:\\n                for ind in range(val+1,i+2):\\n                    p+=dfs(i+1,ind)%(10**9+7)\\n            mem[i,val]=p\\n            return p\\n        return dfs(0)\\n ```\\n\\t\\t\\t\\t",
        "level": "hard",
        "type": [
            "colon missing",
            "unclosed string",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def numPermsDISequence(self, s: str) -> int:\n        mem=defaultdict(int)\n        def dfs(i,val=0):\n            if i==len(s):\n                return 1\n            if (i,val) in mem\n                return mem[i,val]\n            p=0\n            if s[i]==\"D:\n                for ind in range(0,val+1):\n                    p+=dfs(i+1,ind)%(10**9+7)\n            else:\n                for ind in range(val+1,i+1):\n                    p+=dfs(i+1,ind)%(10**9+7)\n            mem[i,val]=p\n            return p\n        return dfs(0)\n"
    },
    {
        "slug": "largest-number-after-mutating-substring",
        "description": "You are given a string num, which represents a large integer. You are also given a 0-indexed integer array change of length 10 that maps each digit 0-9 to another digit. More formally, digit d maps to digit change[d].\nYou may choose to mutate a single substring of num. To mutate a substring, replace each digit num[i] with the digit it maps to in change (i.e. replace num[i] with change[num[i]]).\nReturn a string representing the largest possible integer after mutating (or choosing not to) a single substring of num.\nA substring is a contiguous sequence of characters within the string.",
        "examples": [
            "Input: num = \"132\", change = [9,8,5,0,3,6,4,2,6,8]\nOutput: \"832\"\nExplanation: Replace the substring \"1\":\n- 1 maps to change[1] = 8.\nThus, \"132\" becomes \"832\".\n\"832\" is the largest number that can be created, so return it.",
            "Input: num = \"021\", change = [9,4,3,5,7,2,1,9,0,6]\nOutput: \"934\"\nExplanation: Replace the substring \"021\":\n- 0 maps to change[0] = 9.\n- 2 maps to change[2] = 3.\n- 1 maps to change[1] = 4.\nThus, \"021\" becomes \"934\".\n\"934\" is the largest number that can be created, so return it.",
            "Input: num = \"5\", change = [1,4,7,5,3,2,5,6,9,4]\nOutput: \"5\"\nExplanation: \"5\" is already the largest number that can be created, so return it."
        ],
        "constraints": "1 <= num.length <= 105\nnum consists of only digits 0-9.\nchange.length == 10\n0 <= change[d] <= 9",
        "oracle_code": "class Solution:\n    def maximumNumber(self, num: str, change: List[int]) -> str:\n        num = list(num)\n        on = False \n        for i, ch in enumerate(num): \n            x = int(ch)\n            if x < change[x]: \n                on = True\n                num[i] = str(change[x])\n            elif x > change[x] and on: break\n        return \"\".join(num)",
        "content": "\\n```\\nclass Solution:\\n    def maximumNumber(self, num: str, change: List[int]) -> str:\\n        num = list(num)\\n        on = False \\n        for i, ch in enumerate(num): \\n            x = int(ch)\\n            if x < change[x]: \\n                on = True\\n                num[i] = str(change[x])\\n            elif x > change[x] and on: break\\n        return \"\".join(num)\\n```",
        "level": "medium",
        "type": [
            "indentation error",
            "indexing error",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def maximumNumber(self, num: str, change: List[int]) -> str:\n        num = list(num)\n        on = False \n     for i, ch in enumerate(num): \n         x = int(ch)\n         if x < change[x+1]: \n              on = True\n              num[i] = str(change[x])\n         elif x >= change[x] and on: break\n    return \"\".join(num)\n"
    },
    {
        "slug": "satisfiability-of-equality-equations",
        "description": "You are given an array of strings equations that represent relationships between variables where each string equations[i] is of length 4 and takes one of two different forms: \"xi==yi\" or \"xi!=yi\".Here, xi and yi are lowercase letters (not necessarily different) that represent one-letter variable names.\nReturn true if it is possible to assign integers to variable names so as to satisfy all the given equations, or false otherwise.",
        "examples": [
            "Input: equations = [\"a==b\",\"b!=a\"]\nOutput: false\nExplanation: If we assign say, a = 1 and b = 1, then the first equation is satisfied, but not the second.\nThere is no way to assign the variables to satisfy both equations.",
            "Input: equations = [\"b==a\",\"a==b\"]\nOutput: true\nExplanation: We could assign a = 1 and b = 1 to satisfy both equations."
        ],
        "constraints": "1 <= equations.length <= 500\nequations[i].length == 4\nequations[i][0] is a lowercase letter.\nequations[i][1] is either '=' or '!'.\nequations[i][2] is '='.\nequations[i][3] is a lowercase letter.",
        "oracle_code": "class Disjoint:\n    def __init__(self):\n        self.rank=[0]*26\n        self.parent=[i for i in range(26)]\n\n    def finduPar(self,node):\n        if self.parent[node]==node:\n            return node\n        self.parent[node]=self.finduPar(self.parent[node])\n        return self.parent[node]\n\n    def byrank(self,u,v):\n        ulp_u=self.finduPar(u)\n        ulp_v=self.finduPar(v)\n        if ulp_u==ulp_v:\n            return False\n        if self.rank[ulp_u]>self.rank[ulp_v]:\n            self.parent[ulp_v]=ulp_u\n        elif self.rank[ulp_u]<self.rank[ulp_v]:\n            self.parent[ulp_u]=ulp_v\n        else:\n            self.parent[ulp_v]=ulp_u\n            self.rank[ulp_u]+=1\n\n\nclass Solution:\n    def equationsPossible(self, equations: List[str]) -> bool:\n        disjoint=Disjoint()\n        nq=[]\n        n=len(equations)\n        for i in range(n):\n            if equations[i][1]=='!':\n                if equations[i][0]==equations[i][-1]:\n                    return False\n                else:\n                    nq.append(equations[i])\n            else:\n                disjoint.byrank(ord(equations[i][0])-97,ord(equations[i][-1])-97)\n        for i in range(len(nq)):\n            x=ord(nq[i][0])-97\n            y=ord(nq[i][-1])-97\n            if disjoint.finduPar(x)==disjoint.finduPar(y):\n                return False\n        return True",
        "content": "# Intuition\\nWE WOULD MAKE ALL alphabet that are equal in same component. \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nUNION DISJOINT\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Disjoint:\\n    def __init__(self):\\n        self.rank=[0]*26\\n        self.parent=[i for i in range(26)]\\n\\n    def finduPar(self,node):\\n        if self.parent[node]==node:\\n            return node\\n        self.parent[node]=self.finduPar(self.parent[node])\\n        return self.parent[node]\\n\\n    def byrank(self,u,v):\\n        ulp_u=self.finduPar(u)\\n        ulp_v=self.finduPar(v)\\n        if ulp_u==ulp_v:\\n            return False\\n        if self.rank[ulp_u]>self.rank[ulp_v]:\\n            self.parent[ulp_v]=ulp_u\\n        elif self.rank[ulp_u]<self.rank[ulp_v]:\\n            self.parent[ulp_u]=ulp_v\\n        else:\\n            self.parent[ulp_v]=ulp_u\\n            self.rank[ulp_u]+=1\\n\\n\\nclass Solution:\\n    def equationsPossible(self, equations: List[str]) -> bool:\\n        disjoint=Disjoint()\\n        nq=[]\\n        n=len(equations)\\n        for i in range(n):\\n            if equations[i][1]==\\'!\\':\\n                if equations[i][0]==equations[i][-1]:\\n                    return False\\n                else:\\n                    nq.append(equations[i])\\n            else:\\n                disjoint.byrank(ord(equations[i][0])-97,ord(equations[i][-1])-97)\\n        for i in range(len(nq)):\\n            x=ord(nq[i][0])-97\\n            y=ord(nq[i][-1])-97\\n            if disjoint.finduPar(x)==disjoint.finduPar(y):\\n                return False\\n        return True\\n```",
        "level": "medium",
        "type": [
            "undefined methods",
            "undefined objects",
            "indexing error"
        ],
        "buggy_code": "\nclass Disjoint:\n    def __init__(self):\n        self.rank=[0]*26\n        self.parent=[i for i in range(26)]\n\n    def finduPar(self,node):\n        if self.parent[node]==node:\n            return node\n        self.parent[node]=self.finduPar(self.parent[node])\n        return self.parent[node]\n\n    def byrank(self,u,v):\n        ulp_u=self.finduPar(u)\n        ulp_v=self.undef(u)\n        if ulp_u==ulp_v:\n            return False\n        if self.rank[ulp_u]>self.rank[ulp_v]:\n            self.parent[ulp_v]=ulp_u\n        elif self.rank[ulp_u]<self.rank[ulp_v]:\n            self.parent[ulp_u]=ulp_v\n        else:\n            self.parent[ulp_v]=ulp_u\n            self.rank[ulp_u]+=1\n\n\nclass Solution:\n    def equationsPossible(self, equations: List[str]) -> bool:\n        disjoint=Disjoint()\n        nq=[]\n        arbitrary_undefined_variable = 0\n        n=len(equations)\n        for i in range(n+1):  \n            if equations[i][1]=='!':\n                if equations[i][0]==equations[i][-1]:\n                    return False\n                else:\n                    nq.append(equations[i])\n            else:\n                disjoint.byrank(ord(equations[i][0])-97,ord(equations[i][-1])-97)\n        for i in range(len(nq)):\n            x=ord(nq[i][0])-97\n            y=ord(nq[i][-1])-arbitrary_undefined_variable\n            if disjoint.finduPar(x)==disjoint.finduPar(y):\n                return False\n        return True\n"
    },
    {
        "slug": "minimize-the-total-price-of-the-trips",
        "description": "There exists an undirected and unrooted tree with n nodes indexed from 0 to n - 1. You are given the integer n and a 2D integer array edges of length n - 1, where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree.\nEach node has an associated price. You are given an integer array price, where price[i] is the price of the ith node.\nThe price sum of a given path is the sum of the prices of all nodes lying on that path.\nAdditionally, you are given a 2D integer array trips, where trips[i] = [starti, endi] indicates that you start the ith trip from the node starti and travel to the node endi by any path you like.\nBefore performing your first trip, you can choose some non-adjacent nodes and halve the prices.\nReturn the minimum total price sum to perform all the given trips.",
        "examples": [
            "Input: n = 4, edges = [[0,1],[1,2],[1,3]], price = [2,2,10,6], trips = [[0,3],[2,1],[2,3]]\nOutput: 23\nExplanation: The diagram above denotes the tree after rooting it at node 2. The first part shows the initial tree and the second part shows the tree after choosing nodes 0, 2, and 3, and making their price half.\nFor the 1st trip, we choose path [0,1,3]. The price sum of that path is 1 + 2 + 3 = 6.\nFor the 2nd trip, we choose path [2,1]. The price sum of that path is 2 + 5 = 7.\nFor the 3rd trip, we choose path [2,1,3]. The price sum of that path is 5 + 2 + 3 = 10.\nThe total price sum of all trips is 6 + 7 + 10 = 23.\nIt can be proven, that 23 is the minimum answer that we can achieve.",
            "Input: n = 2, edges = [[0,1]], price = [2,2], trips = [[0,0]]\nOutput: 1\nExplanation: The diagram above denotes the tree after rooting it at node 0. The first part shows the initial tree and the second part shows the tree after choosing node 0, and making its price half.\nFor the 1st trip, we choose path [0]. The price sum of that path is 1.\nThe total price sum of all trips is 1. It can be proven, that 1 is the minimum answer that we can achieve."
        ],
        "constraints": "1 <= n <= 50\nedges.length == n - 1\n0 <= ai, bi <= n - 1\nedges represents a valid tree.\nprice.length == n\nprice[i] is an even integer.\n1 <= price[i] <= 1000\n1 <= trips.length <= 100\n0 <= starti, endi\u00a0<= n - 1",
        "oracle_code": "class Solution:\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\n        g = [[] for _ in range(n)]\n        for i, j in edges:\n            g[i].append(j)\n            g[j].append(i)\n            \n        freq = [0] * n\n        level = [0] * n\n        parent = [0] * n\n        \n        def dfs(i, l, p):\n            level[i] = l\n            parent[i] = p\n            for j in g[i]:\n                if j != p:\n                    dfs(j, l + 1, i)\n        \n        def LCA(a, b):\n            if level[a] > level[b]:\n                a, b = b, a\n            d = level[b] - level[a]\n            while d:\n                b = parent[b]\n                d -= 1\n            if a == b:\n                return a\n            while a != b:\n                a = parent[a]\n                b = parent[b]\n            return a\n        \n        dfs(0, 0, -1)\n        for i, j in trips:\n            lca = LCA(i, j)\n            path = []\n            while i != lca:\n                freq[i] += 1\n                i = parent[i]\n            freq[i] += 1\n            while j != lca:\n                freq[j] += 1\n                j = parent[j]\n        \n        def dp(i, p):\n            res0 = 0\n            res1 = price[i] // 2 * freq[i]\n            for j in g[i]:\n                if j != p:\n                    curr = dp(j, i)\n                    res0 += max(curr)\n                    res1 += curr[0]\n            return [res0, res1]\n        ans = 0\n        for i in range(n):\n            ans += freq[i] * price[i]\n        return ans - max(dp(0, -1))",
        "content": "We use lowest common ancestor to find path for each trip. Let `freq` be the frequencies for each node. `dp(i, p)` returns the maximum price we can save without or with choosing node `i`.\\n```\\nclass Solution:\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        g = [[] for _ in range(n)]\\n        for i, j in edges:\\n            g[i].append(j)\\n            g[j].append(i)\\n            \\n        freq = [0] * n\\n        level = [0] * n\\n        parent = [0] * n\\n        \\n        def dfs(i, l, p):\\n            level[i] = l\\n            parent[i] = p\\n            for j in g[i]:\\n                if j != p:\\n                    dfs(j, l + 1, i)\\n        \\n        def LCA(a, b):\\n            if level[a] > level[b]:\\n                a, b = b, a\\n            d = level[b] - level[a]\\n            while d:\\n                b = parent[b]\\n                d -= 1\\n            if a == b:\\n                return a\\n            while a != b:\\n                a = parent[a]\\n                b = parent[b]\\n            return a\\n        \\n        dfs(0, 0, -1)\\n        for i, j in trips:\\n            lca = LCA(i, j)\\n            path = []\\n            while i != lca:\\n                freq[i] += 1\\n                i = parent[i]\\n            freq[i] += 1\\n            while j != lca:\\n                freq[j] += 1\\n                j = parent[j]\\n        \\n        def dp(i, p):\\n            res0 = 0\\n            res1 = price[i] // 2 * freq[i]\\n            for j in g[i]:\\n                if j != p:\\n                    curr = dp(j, i)\\n                    res0 += max(curr)\\n                    res1 += curr[0]\\n            return [res0, res1]\\n        ans = 0\\n        for i in range(n):\\n            ans += freq[i] * price[i]\\n        return ans - max(dp(0, -1))\\n```",
        "level": "hard",
        "type": [
            "other error",
            "undefined objects",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution:\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\n        g = [[] for _ in range(n)]\n        for i, j in edges:\n            g[i].append(j)\n            g[j].append(i)\n            \n        freq = [0] * n\n        level = [0] * n\n        parent = [0] * n\n        \n        def dfs(i, l, p:\n            level[i] = l\n            parent[i] = p\n            for j in g[i]:\n                if j != p:\n                    dfs(j, l + 1, i)\n        \n        undefinedLCA(a, b):\n            if level[a] > level[b]:\n                a, b = b, a\n            d = level[b] - level[a]\n            while d:\n                b = parent[b]\n                d -= 1\n            if a == b:\n                return a\n            while a != b:\n                a = parent[a]\n                b = parent[b]\n            return a\n        \n        dfs(0, 0, -1)\n        for i, j in trips:\n            lca = LCA(i, j)\n            path = []\n            while i != lca:\n                freq[i] += 2\n                i = parent[i]\n            freq[i] += 1\n            while j != lca:\n                freq[j] += 1\n                j = parent[j]\n        \n        def dp(i, p):\n            res0 = 0\n            res1 = price[i] // 2 * freq[i]\n            for j in g[i]:\n                if j != p:\n                    curr = dp(j, i)\n                    res0 += max(curr)\n                    res1 += curr[0]\n            return [res0, res1]\n        ans = 0\n        for i in range(n):\n            ans += freq[i] * price[i]\n        return ans - max(dp(0, -1))\n"
    },
    {
        "slug": "count-the-repetitions",
        "description": "We define str = [s, n] as the string str which consists of the string s concatenated n times.\n\nFor example, str == [\"abc\", 3] ==\"abcabcabc\".\n\nWe define that string s1 can be obtained from string s2 if we can remove some characters from s2 such that it becomes s1.\n\nFor example, s1 = \"abc\" can be obtained from s2 = \"abdbec\" based on our definition by removing the bolded underlined characters.\n\nYou are given two strings s1 and s2 and two integers n1 and n2. You have the two strings str1 = [s1, n1] and str2 = [s2, n2].\nReturn the maximum integer m such that str = [str2, m] can be obtained from str1.",
        "examples": [
            "Input: s1 = \"acb\", n1 = 4, s2 = \"ab\", n2 = 2\nOutput: 2",
            "Input: s1 = \"acb\", n1 = 1, s2 = \"acb\", n2 = 1\nOutput: 1"
        ],
        "constraints": "1 <= s1.length, s2.length <= 100\ns1 and s2 consist of lowercase English letters.\n1 <= n1, n2 <= 106",
        "oracle_code": "class Solution:\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\n\n        rec, track = [0], defaultdict(int) \n        ct = start = ptr1 = ptr2 = 0\n\n        if not set(s2).issubset(set(s1)): return 0\n\n        s1 = ''.join(char for char in s1 if char in set(s2))\n        \n        while True:\n            for char in s2:\n                ptr = s1.find(char, start)\n                if ptr == -1:\n                    ct += 1\n                    ptr = s1.find(char)\n                start = ptr+1\n            rec.append(ct + 1)\n\n            if rec[-1] > n1: return (len(rec)-2)//n2\n\n            if ptr not in track: track[ptr] = len(rec)-1\n            else: break\n        \n        cycleStart = rec[track[ptr]]\n        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]\n        rest = n1 - cycleStart\n        \n        rem = cycleStart + rest%cycle1\n\n        while rec[ptr2] <= rem: ptr2+= 1\n\n        return (cycle2 * (rest//cycle1) + ptr2-1)//n2",
        "content": "```\\nclass Solution:\\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\\n\\n        rec, track = [0], defaultdict(int) \\n        ct = start = ptr1 = ptr2 = 0\\n\\n        if not set(s2).issubset(set(s1)): return 0\\n\\n        s1 = \\'\\'.join(char for char in s1 if char in set(s2))\\n        \\n        while True:\\n            for char in s2:\\n                ptr = s1.find(char, start)\\n                if ptr == -1:\\n                    ct += 1\\n                    ptr = s1.find(char)\\n                start = ptr+1\\n            rec.append(ct + 1)\\n\\n            if rec[-1] > n1: return (len(rec)-2)//n2\\n\\n            if ptr not in track: track[ptr] = len(rec)-1\\n            else: break\\n        \\n        cycleStart = rec[track[ptr]]\\n        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]\\n        rest = n1 - cycleStart\\n        \\n        rem = cycleStart + rest%cycle1\\n\\n        while rec[ptr2] <= rem: ptr2+= 1\\n\\n        return (cycle2 * (rest//cycle1) + ptr2-1)//n2\\n```\\n[https://leetcode.com/problems/count-the-repetitions/submissions/864907562/](http://)\\n\\nI could be wrong, but I think that time is *O*(*N*) and space is *O*(*N*).",
        "level": "hard",
        "type": [
            "undefined methods",
            "colon missing",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int\n\n        rec, track = [0], defaultdict(int) \n        ct = start = ptr1 = ptr2 = 0\n\n        if not set(s2).issubset(set(s1)): return 0\n\n        s1 = ''.join(char for char in s1 if char in set(s2))\n        \n        while True:\n            for char in s2:\n                ptr = s1.find(char, start)\n                if ptr == -1:\n                    ct += 1\n                    ptr = s1.find(char)\n                start = ptr+1\n            rec.append(ct + 1)\n\n            if rec[-1] >= n1: return (len(rec)-2)//n2\n\n            if ptr not in track: track[ptr] = len(rec)-1\n            else: break\n        \n        cycleStart = rec[track[ptr]]\n        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]\n        rest = n1 - cycleStart\n        \n        rem = cycleStart + self.calculateRemainder(rest, cycle1)\n\n        while rec[ptr2] <= rem: ptr2+= 1\n\n        return (cycle2 * (rest//cycle1) + ptr2-1)//n2\n"
    },
    {
        "slug": "check-if-string-is-transformable-with-substring-sort-operations",
        "description": "Given two strings s and t, transform string s into string t using the following operation any number of times:\n\nChoose a non-empty substring in s and sort it in place so the characters are in ascending order.\n\n\t\nFor example, applying the operation on the underlined substring in \"14234\" results in \"12344\".\n\n\n\nReturn true if it is possible to transform s into t. Otherwise, return false.\nA substring is a contiguous sequence of characters within a string.",
        "examples": [
            "Input: s = \"84532\", t = \"34852\"\nOutput: true\nExplanation: You can transform s into t using the following sort operations:\n\"84532\" (from index 2 to 3) -> \"84352\"\n\"84352\" (from index 0 to 2) -> \"34852\"",
            "Input: s = \"34521\", t = \"23415\"\nOutput: true\nExplanation: You can transform s into t using the following sort operations:\n\"34521\" -> \"23451\"\n\"23451\" -> \"23415\"",
            "Input: s = \"12345\", t = \"12435\"\nOutput: false"
        ],
        "constraints": "s.length == t.length\n1 <= s.length <= 105\ns and t consist of only digits.",
        "oracle_code": "class Solution:\n  def isTransformable(self, s: str, t: str) -> bool:\n    idx = defaultdict(deque)\n    for i, c in enumerate(s):\n      idx[int(c)].append(i)\n    for c in t:\n      d = int(c)\n      if not idx[d]: return False\n      for i in range(d):\n        if idx[i] and idx[i][0] < idx[d][0]: return False\n      idx[d].popleft()\n    return True",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n  def isTransformable(self, s: str, t: str) -> bool:\\n    idx = defaultdict(deque)\\n    for i, c in enumerate(s):\\n      idx[int(c)].append(i)\\n    for c in t:\\n      d = int(c)\\n      if not idx[d]: return False\\n      for i in range(d):\\n        if idx[i] and idx[i][0] < idx[d][0]: return False\\n      idx[d].popleft()\\n    return True\\n```",
        "level": "hard",
        "type": [
            "undefined methods",
            "colon missing",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n  def isTransformable(self, s: str, t: str) -> bool\n    idx = defaultdict(deque)\n    for i, c in enumerate(s):\n      idx[int(c)].append(i)\n    for c in t:\n      d = int(c)\n      if not idx[d + 1]: return False\n      for i in range(d):\n        if idx[i] and idx[i][0] < idx[d][0]: return False\n      idx[d].remove()\n    return True\n"
    },
    {
        "slug": "create-components-with-same-value",
        "description": "There is an undirected tree with n nodes labeled from 0 to n - 1.\nYou are given a 0-indexed integer array nums of length n where nums[i] represents the value of the ith node. You are also given a 2D integer array edges of length n - 1 where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree.\nYou are allowed to delete some edges, splitting the tree into multiple connected components. Let the value of a component be the sum of all nums[i] for which node i is in the component.\nReturn the maximum number of edges you can delete, such that every connected component in the tree has the same value.",
        "examples": [
            "Input: nums = [6,2,2,2,6], edges = [[0,1],[1,2],[1,3],[3,4]] \nOutput: 2 \nExplanation: The above figure shows how we can delete the edges [0,1] and [3,4]. The created components are nodes [0], [1,2,3] and [4]. The sum of the values in each component equals 6. It can be proven that no better deletion exists, so the answer is 2.",
            "Input: nums = [2], edges = []\nOutput: 0\nExplanation: There are no edges to be deleted."
        ],
        "constraints": "1 <= n <= 2 * 104\nnums.length == n\n1 <= nums[i] <= 50\nedges.length == n - 1\nedges[i].length == 2\n0 <= edges[i][0], edges[i][1] <= n - 1\nedges represents a valid tree.",
        "oracle_code": "class Solution:\n    def componentValue(self, nums: List[int], edges: List[List[int]]) -> int:\n        tree = [[] for _ in nums]\n        for u, v in edges: \n            tree[u].append(v)\n            tree[v].append(u)\n        \n        def fn(u, p):\n            \"\"\"Post-order dfs.\"\"\"\n            ans = nums[u]\n            for v in tree[u]: \n                if v != p: ans += fn(v, u)\n            return 0 if ans == cand else ans\n        \n        total = sum(nums)\n        for cand in range(1, total//2+1): \n            if total % cand == 0 and fn(0, -1) == 0: return total//cand-1\n        return 0",
        "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/b09317beeb5fa2ae0b6d2537172ab52647a75cea) for solutions of biweekly 89. \\n\\n```\\nclass Solution:\\n    def componentValue(self, nums: List[int], edges: List[List[int]]) -> int:\\n        tree = [[] for _ in nums]\\n        for u, v in edges: \\n            tree[u].append(v)\\n            tree[v].append(u)\\n        \\n        def fn(u, p):\\n            \"\"\"Post-order dfs.\"\"\"\\n            ans = nums[u]\\n            for v in tree[u]: \\n                if v != p: ans += fn(v, u)\\n            return 0 if ans == cand else ans\\n        \\n        total = sum(nums)\\n        for cand in range(1, total//2+1): \\n            if total % cand == 0 and fn(0, -1) == 0: return total//cand-1\\n        return 0 \\n```",
        "level": "hard",
        "type": [
            "parentheses mismatch",
            "unclosed string",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def componentValue(self, nums: List[int], edges: List[List[int]]) -> int:\n        tree = [[] for _ in nums]\n        for u, v in edges: \n            tree[u].append(v)\n            tree[v].append(u)\n        \n        def fn(u, p):\n            \"\"\"Post-order dfs.\n            ans = nums[u]\n            for v in tree[u]: \n                if v != p: ans += fn(v, u)\n            return 0 if ans == cand else ans\n        \n        total = sum(nums)\n        for cand in range(1, total//2+1: \n            if total % cand != 0 and fn(0, -1) == 0: return total//cand-1\n        return 0\n"
    },
    {
        "slug": "median-of-two-sorted-arrays",
        "description": "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\nThe overall run time complexity should be O(log (m+n)).",
        "examples": [
            "Input: nums1 = [1,3], nums2 = [2]\nOutput: 2.00000\nExplanation: merged array = [1,2,3] and median is 2.",
            "Input: nums1 = [1,2], nums2 = [3,4]\nOutput: 2.50000\nExplanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5."
        ],
        "constraints": "nums1.length == m\nnums2.length == n\n0 <= m <= 1000\n0 <= n <= 1000\n1 <= m + n <= 2000\n-106 <= nums1[i], nums2[i] <= 106",
        "oracle_code": "class Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        p1 = 0\n        p2 = 0\n        new = []\n        while p1 < len(nums1) and p2 < len(nums2):\n            if nums1[p1] < nums2[p2]:\n                new.append(nums1[p1])\n                p1 += 1\n            else:\n                new.append(nums2[p2])\n                p2 += 1\n        while p1 < len(nums1):\n            new.append(nums1[p1])\n            p1 += 1\n        while p2 < len(nums2):\n            new.append(nums2[p2])\n            p2+= 1\n        if len(new) % 2 == 0:\n            index = len(new) // 2\n            median = (new[index] + new[index-1]) / 2\n        else:\n            median = float(new[len(new)//2])\n        return median",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind this approach is to merge the two sorted arrays while maintaining the order, and then finding the median based on the length of the merged array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize two pointers, p1 and p2, for the two input arrays nums1 and nums2, respectively, both starting at index 0.\\n2. Create an empty list new to store the merged array.\\n3. Iterate through both arrays using the pointers. Compare the elements pointed to by p1 and p2. Append the smaller element to the new array and increment the corresponding pointer.\\n4. After the iteration, there might be remaining elements in one of the arrays. Iterate through the remaining elements and append them to the new array.\\n5. Calculate the median based on the length of the new array. If the length is even, take the average of the middle two elements. If the length is odd, take the middle element.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(m + n), where m and n are the lengths of the two input arrays.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(m + n), as the merged array new can contain all the elements from the two input arrays.\\n\\n# Code\\n```\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        p1 = 0\\n        p2 = 0\\n        new = []\\n        while p1 < len(nums1) and p2 < len(nums2):\\n            if nums1[p1] < nums2[p2]:\\n                new.append(nums1[p1])\\n                p1 += 1\\n            else:\\n                new.append(nums2[p2])\\n                p2 += 1\\n        while p1 < len(nums1):\\n            new.append(nums1[p1])\\n            p1 += 1\\n        while p2 < len(nums2):\\n            new.append(nums2[p2])\\n            p2+= 1\\n        if len(new) % 2 == 0:\\n            index = len(new) // 2\\n            median = (new[index] + new[index-1]) / 2\\n        else:\\n            median = float(new[len(new)//2])\\n        return median\\n```",
        "level": "hard",
        "type": [
            "indentation error",
            "variable value error",
            "colon missing"
        ],
        "buggy_code": "\nclass Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float\n        p1 = 0\n        p2 = 0\n        new = []\n        while p1 < len(nums1) and p2 < len(nums2):\n            if nums1[p1] < nums2[p2]:\n            new.append(nums1[p1])\n            p1 += 1\n        else:\n            new.append(nums2[p2])\n            p2 += 1\n        while p1 < len(nums1):\n            new.append(nums1[p1])\n            p2 += 1\n        while p2 < len(nums2):\n            new.append(nums2[p2])\n            p1 += 1\n\n        if len(new) % 2 == 0:\n            index = len(new) // 2\n            median = (new[index] + new[index-1]) / 2\n        else:\n            median = float(new[len(new)//2])\n        return median\n"
    },
    {
        "slug": "find-all-possible-recipes-from-given-supplies",
        "description": "You have information about n different recipes. You are given a string array recipes and a 2D string array ingredients. The ith recipe has the name recipes[i], and you can create it if you have all the needed ingredients from ingredients[i]. Ingredients to a recipe may need to be created from other recipes, i.e., ingredients[i] may contain a string that is in recipes.\nYou are also given a string array supplies containing all the ingredients that you initially have, and you have an infinite supply of all of them.\nReturn a list of all the recipes that you can create. You may return the answer in any order.\nNote that two recipes may contain each other in their ingredients.",
        "examples": [
            "Input: recipes = [\"bread\"], ingredients = [[\"yeast\",\"flour\"]], supplies = [\"yeast\",\"flour\",\"corn\"]\nOutput: [\"bread\"]\nExplanation:\nWe can create \"bread\" since we have the ingredients \"yeast\" and \"flour\".",
            "Input: recipes = [\"bread\",\"sandwich\"], ingredients = [[\"yeast\",\"flour\"],[\"bread\",\"meat\"]], supplies = [\"yeast\",\"flour\",\"meat\"]\nOutput: [\"bread\",\"sandwich\"]\nExplanation:\nWe can create \"bread\" since we have the ingredients \"yeast\" and \"flour\".\nWe can create \"sandwich\" since we have the ingredient \"meat\" and can create the ingredient \"bread\".",
            "Input: recipes = [\"bread\",\"sandwich\",\"burger\"], ingredients = [[\"yeast\",\"flour\"],[\"bread\",\"meat\"],[\"sandwich\",\"meat\",\"bread\"]], supplies = [\"yeast\",\"flour\",\"meat\"]\nOutput: [\"bread\",\"sandwich\",\"burger\"]\nExplanation:\nWe can create \"bread\" since we have the ingredients \"yeast\" and \"flour\".\nWe can create \"sandwich\" since we have the ingredient \"meat\" and can create the ingredient \"bread\".\nWe can create \"burger\" since we have the ingredient \"meat\" and can create the ingredients \"bread\" and \"sandwich\"."
        ],
        "constraints": "n == recipes.length == ingredients.length\n1 <= n <= 100\n1 <= ingredients[i].length, supplies.length <= 100\n1 <= recipes[i].length, ingredients[i][j].length, supplies[k].length <= 10\nrecipes[i], ingredients[i][j], and supplies[k] consist only of lowercase English letters.\nAll the values of recipes and supplies\u00a0combined are unique.\nEach ingredients[i] does not contain any duplicate values.",
        "oracle_code": "class Solution:\n    def findAllRecipes(self, recepies: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\n        dct=defaultdict(lambda :[])\n        indegree={}\n        n=len(recepies)\n\n        for i in recepies:\n            indegree[i]=0\n\n        for i in range(n):\n            for j in ingredients[i]:\n                indegree[j]=0\n\n        for i in range(n):\n            for j in ingredients[i]:\n                dct[j].append(recepies[i])\n                indegree[recepies[i]]+=1\n\n        st=[]\n        for i in indegree:\n            if indegree[i]==0:\n                st.append(i)\n        flst=[]\n        ans=defaultdict(lambda :[])\n        while st:\n            x=st.pop(0)\n            for i in dct[x]:\n                # if ans[x]!=[]:\n                for j in ans[x]:\n                    if j not in ans[i]:\n                        ans[i].append(j)\n                ans[i].append(x)\n                indegree[i]-=1\n                if indegree[i]==0:\n                    st.append(i)\n            if x in recepies:\n                for k in ans[x]:\n                    if k not in supplies:\n                        break\n                else:\n                    flst.append(x)\n                    supplies.append(x)\n\n        return flst",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findAllRecipes(self, recepies: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n        dct=defaultdict(lambda :[])\\n        indegree={}\\n        n=len(recepies)\\n\\n        for i in recepies:\\n            indegree[i]=0\\n\\n        for i in range(n):\\n            for j in ingredients[i]:\\n                indegree[j]=0\\n\\n        for i in range(n):\\n            for j in ingredients[i]:\\n                dct[j].append(recepies[i])\\n                indegree[recepies[i]]+=1\\n\\n        st=[]\\n        for i in indegree:\\n            if indegree[i]==0:\\n                st.append(i)\\n        flst=[]\\n        ans=defaultdict(lambda :[])\\n        while st:\\n            x=st.pop(0)\\n            for i in dct[x]:\\n                # if ans[x]!=[]:\\n                for j in ans[x]:\\n                    if j not in ans[i]:\\n                        ans[i].append(j)\\n                ans[i].append(x)\\n                indegree[i]-=1\\n                if indegree[i]==0:\\n                    st.append(i)\\n            if x in recepies:\\n                for k in ans[x]:\\n                    if k not in supplies:\\n                        break\\n                else:\\n                    flst.append(x)\\n                    supplies.append(x)\\n\\n        return flst\\n```",
        "level": "medium",
        "type": [
            "colon missing",
            "undefined keywords from other languages",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def findAllRecipes(self, recepies: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\n        dct=defaultdict(lambda :[])\n        indegree={}\n        n=len(recepies)\n\n        for i in recepies:\n            indegree[i]=0\n\n        for i in range(n+1)   \n            for j in ingredients[i]:\n                indegree[j]=0\n\n        for i in range(n):\n            for j in ingredients[i]:\n                dct[j].append(recepies[i])\n                indegree[recepies[i]]+=1\n\n        st=[]\n        for i in indegree:\n            if indegree[i]==0:\n                st.push(i)\n        flst=[]\n        ans=defaultdict(lambda :[])\n        while st:\n            x=st.pop(0)\n            for i in dct[x]:\n                for j in ans[x]:\n                    if j not in ans[i]:\n                        ans[i].append(j)\n                ans[i].append(x)\n                indegree[i]-=1\n                if indegree[i]==0:\n                    st.append(i)\n            if x in recepies:\n                for k in ans[x]:\n                    if k not in supplies:\n                        break\n                else:\n                    flst.append(x)\n                    supplies.append(x)\n\n        return flst\n"
    },
    {
        "slug": "alternating-digit-sum",
        "description": "You are given a positive integer n. Each digit of n has a sign according to the following rules:\n\nThe most significant digit is assigned a positive sign.\nEach other digit has an opposite sign to its adjacent digits.\n\nReturn the sum of all digits with their corresponding sign.",
        "examples": [
            "Input: n = 521\nOutput: 4\nExplanation: (+5) + (-2) + (+1) = 4.",
            "Input: n = 111\nOutput: 1\nExplanation: (+1) + (-1) + (+1) = 1.",
            "Input: n = 886996\nOutput: 0\nExplanation: (+8) + (-8) + (+6) + (-9) + (+9) + (-6) = 0."
        ],
        "constraints": "1 <= n <= 109",
        "oracle_code": "class Solution:\n    def alternateDigitSum(self, n: int) -> int:\n        result=str(n)\n        sum=0\n        for i in range(len(result)):\n            if i%2 ==0:\n                sum=sum+int(result[i])\n            else:  \n                sum=sum-int(result[i])  \n        return sum",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def alternateDigitSum(self, n: int) -> int:\\n        result=str(n)\\n        sum=0\\n        for i in range(len(result)):\\n            if i%2 ==0:\\n                sum=sum+int(result[i])\\n            else:  \\n                sum=sum-int(result[i])  \\n        return sum        \\n```",
        "level": "easy",
        "type": [
            "indentation error",
            "operation error",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution:\n    def alternateDigitSum(self, n: int) -> int:\n        result=str(n)\n    sum=0\n            for i in range(len(result)):\n                if i%2 ==0:\n                    sum=sum+int(result[i])\n              else:  \n                    sum=sum+int(result[i]) \n            return sum\n"
    },
    {
        "slug": "restore-ip-addresses",
        "description": "A valid IP address consists of exactly four integers separated by single dots. Each integer is between 0 and 255 (inclusive) and cannot have leading zeros.\n\nFor example, \"0.1.2.201\" and \"192.168.1.1\" are valid IP addresses, but \"0.011.255.245\", \"192.168.1.312\" and \"192.168@1.1\" are invalid IP addresses.\n\nGiven a string s containing only digits, return all possible valid IP addresses that can be formed by inserting dots into s. You are not allowed to reorder or remove any digits in s. You may return the valid IP addresses in any order.",
        "examples": [
            "Input: s = \"25525511135\"\nOutput: [\"255.255.11.135\",\"255.255.111.35\"]",
            "Input: s = \"0000\"\nOutput: [\"0.0.0.0\"]",
            "Input: s = \"101023\"\nOutput: [\"1.0.10.23\",\"1.0.102.3\",\"10.1.0.23\",\"10.10.2.3\",\"101.0.2.3\"]"
        ],
        "constraints": "1 <= s.length <= 20\ns consists of digits only.",
        "oracle_code": "class Solution:\n    def restoreIpAddresses(self, s: str) -> List[str]:\n        res=[]\n        cur=[]\n        def backtrack(i):\n            if i==len(s) and len(cur)==4:\n                res.append(\".\".join(cur))\n                return\n            if len(cur)>4 or i>=len(s):\n                return\n            if s[i]=='0':\n                cur.append(s[i])\n                backtrack(i+1)\n                cur.pop()\n                return\n            j=0\n            while j<4 and i+j<len(s):\n                if int(s[i:i+j+1])<256:\n                    cur.append(s[i:i+j+1])\n                    backtrack(i+j+1)\n                    cur.pop()\n                j+=1\n        backtrack(0)\n        return res",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\njust take care with the processing number should be lower than len(s) and the length of current stack should be lower or equal 4.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(4)\\n# Code\\n```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        res=[]\\n        cur=[]\\n        def backtrack(i):\\n            if i==len(s) and len(cur)==4:\\n                res.append(\".\".join(cur))\\n                return\\n            if len(cur)>4 or i>=len(s):\\n                return\\n            if s[i]==\\'0\\':\\n                cur.append(s[i])\\n                backtrack(i+1)\\n                cur.pop()\\n                return\\n            j=0\\n            while j<4 and i+j<len(s):\\n                if int(s[i:i+j+1])<256:\\n                    cur.append(s[i:i+j+1])\\n                    backtrack(i+j+1)\\n                    cur.pop()\\n                j+=1\\n        backtrack(0)\\n        return res\\n\\n```",
        "level": "medium",
        "type": [
            "== and = confusion",
            "indexing error",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def restoreIpAddresses(self, s: str) -> List[str]:\n        res=[]\n        cur=[]\n        def backtrack(i):\n            if i=len(s) and len(cur)==4:\n                res.append(\".\".join(cur))\n                return\n            if len(cur)>4 or i>len(s):\n                return\n            if s[i]=='0':\n                cur.append(s[i])\n                backtrack(i+1)\n                cur.pop()\n                return\n            j=0\n            while j<4 and i+j<len(s):\n                if int(s[i:i+j+1])<256:\n                    cur.append(s[i:i+j+1])\n                    backtrack(i+j+1)\n                    cur.pop()\n                j+=1\n        backtrack(0)\n        return res\n"
    },
    {
        "slug": "valid-arrangement-of-pairs",
        "description": "You are given a 0-indexed 2D integer array pairs where pairs[i] = [starti, endi]. An arrangement of pairs is valid if for every index i where 1 <= i < pairs.length, we have endi-1 == starti.\nReturn any valid arrangement of pairs.\nNote: The inputs will be generated such that there exists a valid arrangement of pairs.",
        "examples": [
            "Input: pairs = [[5,1],[4,5],[11,9],[9,4]]\nOutput: [[11,9],[9,4],[4,5],[5,1]]\nExplanation:\nThis is a valid arrangement since endi-1 always equals starti.\nend0 = 9 == 9 = start1 \nend1 = 4 == 4 = start2\nend2 = 5 == 5 = start3",
            "Input: pairs = [[1,3],[3,2],[2,1]]\nOutput: [[1,3],[3,2],[2,1]]\nExplanation:\nThis is a valid arrangement since endi-1 always equals starti.\nend0 = 3 == 3 = start1\nend1 = 2 == 2 = start2\nThe arrangements [[2,1],[1,3],[3,2]] and [[3,2],[2,1],[1,3]] are also valid.",
            "Input: pairs = [[1,2],[1,3],[2,1]]\nOutput: [[1,2],[2,1],[1,3]]\nExplanation:\nThis is a valid arrangement since endi-1 always equals starti.\nend0 = 2 == 2 = start1\nend1 = 1 == 1 = start2"
        ],
        "constraints": "1 <= pairs.length <= 105\npairs[i].length == 2\n0 <= starti, endi <= 109\nstarti != endi\nNo two pairs are exactly the same.\nThere exists a valid arrangement of pairs.",
        "oracle_code": "class Solution:\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\n        graph = defaultdict(list)\n        degree = defaultdict(int) # net out degree \n        for x, y in pairs: \n            graph[x].append(y)\n            degree[x] += 1\n            degree[y] -= 1\n                \n        for k in degree: \n            if degree[k] == 1: \n                x = k\n                break \n                \n        ans = []\n\n        def fn(x): \n            \"\"\"Return Eulerian path via dfs.\"\"\"\n            while graph[x]: fn(graph[x].pop()) \n            ans.append(x)\n        \n        fn(x)\n        ans.reverse()\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]",
        "content": "Please check out this [commit](https://github.com/gaosanyong/leetcode/commit/b1948f8814bebeca475cbb354cd44d19092dff59) for solutions of weekly 270.\\n\\n```\\nclass Solution:\\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\\n        graph = defaultdict(list)\\n        degree = defaultdict(int) # net out degree \\n        for x, y in pairs: \\n            graph[x].append(y)\\n            degree[x] += 1\\n            degree[y] -= 1\\n                \\n        for k in degree: \\n            if degree[k] == 1: \\n                x = k\\n                break \\n                \\n        ans = []\\n\\n        def fn(x): \\n            \"\"\"Return Eulerian path via dfs.\"\"\"\\n            while graph[x]: fn(graph[x].pop()) \\n            ans.append(x)\\n        \\n        fn(x)\\n        ans.reverse()\\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]\\n```\\n\\nAdding an iterative implementation of Hieholzer\\'s algo from @delphih\\n```\\nclass Solution:\\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\\n        graph = defaultdict(list)\\n        degree = defaultdict(int) # net out degree \\n        for x, y in pairs: \\n            graph[x].append(y)\\n            degree[x] += 1\\n            degree[y] -= 1\\n                \\n        for k in degree: \\n            if degree[k] == 1: \\n                x = k\\n                break \\n                \\n        ans = []\\n        stack = [x]\\n        while stack: \\n            while graph[stack[-1]]: \\n                stack.append(graph[stack[-1]].pop())\\n            ans.append(stack.pop())\\n        ans.reverse()\\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]\\n```",
        "level": "hard",
        "type": [
            "undefined methods",
            "parentheses mismatch",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution:\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\n        graph = defaultdict(list)\n        degree = defaultdict(int) # net out degree \n        for x, y in pairs: \n            graph[x].append(y)\n            degree[x] += 1\n            degree[y] -= 1\n                \n        for k in degree: \n            if degree[k] == 1: \n                x = k\n                break \n                \n        ans = []\n\n        def fn(x): \n            \"\"\"Return Eulerian path via dfs.\"\n            while graph[x]: fn(graph[x].pop()) \n            ans.append(x)\n        \n        dfn(s\n        ans.reverse()\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]\n"
    },
    {
        "slug": "disconnect-path-in-a-binary-matrix-by-at-most-one-flip",
        "description": "You are given a 0-indexed m x n binary matrix grid. You can move from a cell (row, col) to any of the cells (row + 1, col) or (row, col + 1) that has the value 1.\u00a0The matrix is disconnected if there is no path from (0, 0) to (m - 1, n - 1).\nYou can flip the value of at most one (possibly none) cell. You cannot flip the cells (0, 0) and (m - 1, n - 1).\nReturn true if it is possible to make the matrix disconnect or false otherwise.\nNote that flipping a cell changes its value from 0 to 1 or from 1 to 0.",
        "examples": [
            "Input: grid = [[1,1,1],[1,0,0],[1,1,1]]\nOutput: true\nExplanation: We can change the cell shown in the diagram above. There is no path from (0, 0) to (2, 2) in the resulting grid.",
            "Input: grid = [[1,1,1],[1,0,1],[1,1,1]]\nOutput: false\nExplanation: It is not possible to change at most one cell such that there is not path from (0, 0) to (2, 2)."
        ],
        "constraints": "m == grid.length\nn == grid[i].length\n1 <= m, n <= 1000\n1 <= m * n <= 105\ngrid[i][j] is either 0 or 1.\ngrid[0][0] == grid[m - 1][n - 1] == 1",
        "oracle_code": "class Solution:\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\n        m, n = len(grid), len(grid[0])\n        dirs = [(-1, 0), (0, -1)]\n        def dfs(i: int, j: int) -> None:\n            grid[i][j] = 2\n            for di, dj in dirs:\n                if 0 <= i + di < m and 0 <= j + dj < n and grid[i + di][j + dj] == 1: dfs(i + di, j + dj)\n        \n        dfs(m - 1, n - 1)\n    \n        dq = collections.deque([(0, 0)])\n        grid[0][0] = 0\n        dirs = [(1, 0), (0, 1)]\n        while dq:\n            l = len(dq)\n            for _ in range(l):\n                i, j = dq.popleft()\n                if i == m - 1 and j == n - 1: return False\n                for di, dj in dirs:\n                    if 0 <= i + di < m and 0 <= j + dj < n and grid[i + di][j + dj] == 2: \n                        dq.append((i + di, j + dj))\n                        grid[i + di][j + dj] = 0\n\n\n            if len(dq) == 1 and dq[0] != (m - 1, n - 1): return True\n\n        return True",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(M * N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(M * N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n1. DFS + BFS\\n```\\nclass Solution:\\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\\n        m, n = len(grid), len(grid[0])\\n        dirs = [(-1, 0), (0, -1)]\\n        def dfs(i: int, j: int) -> None:\\n            grid[i][j] = 2\\n            for di, dj in dirs:\\n                if 0 <= i + di < m and 0 <= j + dj < n and grid[i + di][j + dj] == 1: dfs(i + di, j + dj)\\n        \\n        dfs(m - 1, n - 1)\\n    \\n        dq = collections.deque([(0, 0)])\\n        grid[0][0] = 0\\n        dirs = [(1, 0), (0, 1)]\\n        while dq:\\n            l = len(dq)\\n            for _ in range(l):\\n                i, j = dq.popleft()\\n                if i == m - 1 and j == n - 1: return False\\n                for di, dj in dirs:\\n                    if 0 <= i + di < m and 0 <= j + dj < n and grid[i + di][j + dj] == 2: \\n                        dq.append((i + di, j + dj))\\n                        grid[i + di][j + dj] = 0\\n\\n\\n            if len(dq) == 1 and dq[0] != (m - 1, n - 1): return True\\n\\n        return True\\n```",
        "level": "medium",
        "type": [
            "indentation error",
            "wrong comment mark",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\n        m, n = len(grid), len(grid[0])\n        dirs = [(-1, 0), (0, -1)]\n        def dfs(i: int, j: int) -> None:\n            grid[i][j] = 2\n        for di, dj in dirs:\n            if 0 <= i + di < m and 0 <= j + dj < n and grid[i + di][j + dj] = 1: dfs(i + di, j + dj)\n'''\n        dfs(m - 1, n - 1)\n        dq = collections.deque([(0, 0)])\n        grid[0][0] = 0\n        dirs = [(1, 0), (0, 1)]\n        while dq:\n            l = len(dq)\n            for _ in range(l):\n                i, j = dq.popleft()\n                if i == m - 1 and j == n - 1: return False\n                for di, dj in dirs:\n                    if 0 <= i + di < m and 0 <= j + dj < n and grid[i + di][j + dj] == 2: \n                        dq.append((i + di, j + dj))\n                        grid[i + di][j + dj] = 0\n        '''\n        if len(dq) = 1 and dq[0] != (m - 1, n - 1): return True\n\n        return True\n"
    },
    {
        "slug": "count-anagrams",
        "description": "You are given a string s containing one or more words. Every consecutive pair of words is separated by a single space ' '.\nA string t is an anagram of string s if the ith word of t is a permutation of the ith word of s.\n\nFor example, \"acb dfe\" is an anagram of \"abc def\", but \"def cab\"\u00a0and \"adc bef\" are not.\n\nReturn the number of distinct anagrams of s. Since the answer may be very large, return it modulo 109 + 7.",
        "examples": [
            "Input: s = \"too hot\"\nOutput: 18\nExplanation: Some of the anagrams of the given string are \"too hot\", \"oot hot\", \"oto toh\", \"too toh\", and \"too oht\".",
            "Input: s = \"aa\"\nOutput: 1\nExplanation: There is only one anagram possible for the given string."
        ],
        "constraints": "1 <= s.length <= 105\ns consists of lowercase English letters and spaces ' '.\nThere is single space between consecutive words.",
        "oracle_code": "mod = 10**9+7\n\nclass Solution:\n    def countAnagrams(self, s: str) -> int:\n\n        l = s.split()\n        ans = 1\n\n        for i in l:\n            d = {}\n        # counting frequencies of word i in dictionary d\n            for j in i:\n                if(d.get(j)):\n                    d[j] += 1\n                else:\n                    d[j] = 1  \n            \n            duplicates = 1\n            for j in d.values():\n                duplicates *= math.factorial(j)\n            curr = math.factorial(len(i))//duplicates\n\n            ans *= curr\n            ans = ans%mod\n\n        return ans",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe idea is very simple. Total count of anagrams for each word is\\n(factorial of length of word) divided by factorial of duplicates.\\n\\nEg : aabbc -  5!/(2! * 2!)\\n\\n# Code\\n```\\nmod = 10**9+7\\n\\nclass Solution:\\n    def countAnagrams(self, s: str) -> int:\\n\\n        l = s.split()\\n        ans = 1\\n\\n        for i in l:\\n            d = {}\\n        # counting frequencies of word i in dictionary d\\n            for j in i:\\n                if(d.get(j)):\\n                    d[j] += 1\\n                else:\\n                    d[j] = 1  \\n            \\n            duplicates = 1\\n            for j in d.values():\\n                duplicates *= math.factorial(j)\\n            curr = math.factorial(len(i))//duplicates\\n\\n            ans *= curr\\n            ans = ans%mod\\n\\n        return ans        \\n        \\n        \\n```",
        "level": "hard",
        "type": [
            "indentation error",
            "colon missing",
            "operation error"
        ],
        "buggy_code": "\nmod = 10**9+7\n\nclass Solution:\ndef countAnagrams(self, s: str) -> int\n\n    l = s.split()\n    ans = 1\n\n    for i in l:\n        d = {}\n    \n        for j in i:\n            if(d.get(j)):\n                d[j] += 2\n            else:\n                d[j] = 1  \n    \n        duplicates = 1\n        for j in d.values():\n            duplicates *= math.factorial(j)\n        curr = math.factorial(len(i))//duplicates\n\n        ans *= curr\n        ans = ans%mod\n\n    return ans\n"
    },
    {
        "slug": "check-if-string-is-transformable-with-substring-sort-operations",
        "description": "Given two strings s and t, transform string s into string t using the following operation any number of times:\n\nChoose a non-empty substring in s and sort it in place so the characters are in ascending order.\n\n\t\nFor example, applying the operation on the underlined substring in \"14234\" results in \"12344\".\n\n\n\nReturn true if it is possible to transform s into t. Otherwise, return false.\nA substring is a contiguous sequence of characters within a string.",
        "examples": [
            "Input: s = \"84532\", t = \"34852\"\nOutput: true\nExplanation: You can transform s into t using the following sort operations:\n\"84532\" (from index 2 to 3) -> \"84352\"\n\"84352\" (from index 0 to 2) -> \"34852\"",
            "Input: s = \"34521\", t = \"23415\"\nOutput: true\nExplanation: You can transform s into t using the following sort operations:\n\"34521\" -> \"23451\"\n\"23451\" -> \"23415\"",
            "Input: s = \"12345\", t = \"12435\"\nOutput: false"
        ],
        "constraints": "s.length == t.length\n1 <= s.length <= 105\ns and t consist of only digits.",
        "oracle_code": "class Solution:\n  def isTransformable(self, s: str, t: str) -> bool:\n    idx = defaultdict(deque)\n    for i, c in enumerate(s):\n      idx[int(c)].append(i)\n    for c in t:\n      d = int(c)\n      if not idx[d]: return False\n      for i in range(d):\n        if idx[i] and idx[i][0] < idx[d][0]: return False\n      idx[d].popleft()\n    return True",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n  def isTransformable(self, s: str, t: str) -> bool:\\n    idx = defaultdict(deque)\\n    for i, c in enumerate(s):\\n      idx[int(c)].append(i)\\n    for c in t:\\n      d = int(c)\\n      if not idx[d]: return False\\n      for i in range(d):\\n        if idx[i] and idx[i][0] < idx[d][0]: return False\\n      idx[d].popleft()\\n    return True\\n```",
        "level": "hard",
        "type": [
            "undefined methods",
            "colon missing",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n  def isTransformable(self, s: str, t: str) -> bool\n    idx = defaultdict(deque)\n    for i, c in enumerate(s):\n      idx[int(c)].append(i)\n    for c in t:\n      d = int(c)\n      if not idx[d]: return False\n    idx[d].remove()\n    return True\n"
    },
    {
        "slug": "find-kth-bit-in-nth-binary-string",
        "description": "Given two positive integers n and k, the binary string Sn is formed as follows:\n\nS1 = \"0\"\nSi = Si - 1 + \"1\" + reverse(invert(Si - 1)) for i > 1\n\nWhere + denotes the concatenation operation, reverse(x) returns the reversed string x, and invert(x) inverts all the bits in x (0 changes to 1 and 1 changes to 0).\nFor example, the first four strings in the above sequence are:\n\nS1 = \"0\"\nS2 = \"011\"\nS3 = \"0111001\"\nS4 = \"011100110110001\"\n\nReturn the kth bit in Sn. It is guaranteed that k is valid for the given n.",
        "examples": [
            "Input: n = 3, k = 1\nOutput: \"0\"\nExplanation: S3 is \"0111001\".\nThe 1st bit is \"0\".",
            "Input: n = 4, k = 11\nOutput: \"1\"\nExplanation: S4 is \"011100110110001\".\nThe 11th bit is \"1\"."
        ],
        "constraints": "1 <= n <= 20\n1 <= k <= 2n - 1",
        "oracle_code": "class Solution:\n    def findKthBit(self, N, K, R = True):\n        if K == 1: return '0' if R else '1'\n        mid = (1 << (N - 1))\n        if K < mid: return self.findKthBit(N - 1, K, R)\n        if K > mid: return self.findKthBit(N - 1, 2 * mid - K, not R)\n        return '1' if R else '0'",
        "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n\\n### Recursive Approach\\n```\\nclass Solution:\\n    def findKthBit(self, N, K, R = True):\\n        if K == 1: return \\'0\\' if R else \\'1\\'\\n        mid = (1 << (N - 1))\\n        if K < mid: return self.findKthBit(N - 1, K, R)\\n        if K > mid: return self.findKthBit(N - 1, 2 * mid - K, not R)\\n        return \\'1\\' if R else \\'0\\'\\n```\\n\\n### Iterative Approach\\n```\\nclass Solution:\\n    def findKthBit(self, N, K):\\n        ans = 1\\n        mid = (1 << (N - 1))\\n        while K > 1:\\n            if K == mid: return str(ans)\\n            if K > mid: \\n                K = 2 * mid - K\\n                ans ^= 1\\n            mid >>= 1\\n        return str(ans^1)\\n```",
        "level": "medium",
        "type": [
            "undefined methods",
            "unclosed string",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n    def findKthBit(self, N, K, R = True):\n        if K == 1: return '0' if R else '1'\n        mid = (1 << (N - 1))\n        if K < mid: return self.findKthBit(N - 1, K, R)\n        if K = mid: return self.callUndefinedMethod(N - 1, 2 * mid - K, not R)\n        return \"1 if R else '0\n"
    },
    {
        "slug": "find-closest-node-to-given-two-nodes",
        "description": "You are given a directed graph of n nodes numbered from 0 to n - 1, where each node has at most one outgoing edge.\nThe graph is represented with a given 0-indexed array edges of size n, indicating that there is a directed edge from node i to node edges[i]. If there is no outgoing edge from i, then edges[i] == -1.\nYou are also given two integers node1 and node2.\nReturn the index of the node that can be reached from both node1 and node2, such that the maximum between the distance from node1 to that node, and from node2 to that node is minimized. If there are multiple answers, return the node with the smallest index, and if no possible answer exists, return -1.\nNote that edges may contain cycles.",
        "examples": [
            "Input: edges = [2,2,3,-1], node1 = 0, node2 = 1\nOutput: 2\nExplanation: The distance from node 0 to node 2 is 1, and the distance from node 1 to node 2 is 1.\nThe maximum of those two distances is 1. It can be proven that we cannot get a node with a smaller maximum distance than 1, so we return node 2.",
            "Input: edges = [1,2,-1], node1 = 0, node2 = 2\nOutput: 2\nExplanation: The distance from node 0 to node 2 is 2, and the distance from node 2 to itself is 0.\nThe maximum of those two distances is 2. It can be proven that we cannot get a node with a smaller maximum distance than 2, so we return node 2."
        ],
        "constraints": "n == edges.length\n2 <= n <= 105\n-1 <= edges[i] < n\nedges[i] != i\n0 <= node1, node2 < n",
        "oracle_code": "class Solution:\n    def cdist(self, it, distArray, distArrayIndex, edges):\n        rdist = 0 \n        nodes = []\n        while it != -1 and distArray[it][distArrayIndex] > rdist:\n            distArray[it][distArrayIndex] = rdist\n            nodes.append(it)\n            it = edges[it]\n            rdist += 1\n        return nodes\n            \n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\n        INF = float('inf')\n        dist = defaultdict(lambda: [INF,INF])\n        mmin, ans = INF, INF\n               \n        n = self.cdist(node1, dist, 0, edges)\n        n += self.cdist(node2, dist, 1, edges)\n                \n        for k in n:\n            m = max(dist[k])\n            if m != INF:\n                if m < mmin: \n                    mmin = m\n                    ans = k\n                elif m == mmin: \n                    ans = min(ans, k)\n                    \n        return ans if ans != float('inf') else -1",
        "content": "Since there is atmost one outgoing edge with cycles, we can iterate this graph in simple manner as cdist function below. The logic briefly is as below. \\n1. Calculate distances between node1 and other reachable nodes. \\n2. Do the same as (1) for node 2\\n3. Iterate the nodes that are on the path for both distances and find max. \\n4. find min of maxes and keep track of minimum index. \\n\\nIf there was a constraint that node1 and node2 have a guarenteed path between them, the problem could have been simpler, to construct find the shortestPath between node1 -> node 2 and the ans is one of the nodes in between. Thats not the case ! \\n\\n```\\nclass Solution:\\n    def cdist(self, it, distArray, distArrayIndex, edges):\\n        rdist = 0 \\n        nodes = []\\n        while it != -1 and distArray[it][distArrayIndex] > rdist:\\n            distArray[it][distArrayIndex] = rdist\\n            nodes.append(it)\\n            it = edges[it]\\n            rdist += 1\\n        return nodes\\n            \\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        INF = float(\\'inf\\')\\n        dist = defaultdict(lambda: [INF,INF])\\n        mmin, ans = INF, INF\\n               \\n        n = self.cdist(node1, dist, 0, edges)\\n        n += self.cdist(node2, dist, 1, edges)\\n                \\n        for k in n:\\n            m = max(dist[k])\\n            if m != INF:\\n                if m < mmin: \\n                    mmin = m\\n                    ans = k\\n                elif m == mmin: \\n                    ans = min(ans, k)\\n                    \\n        return ans if ans != float(\\'inf\\') else -1\\n```\\n\\nA slightly modified logic, \\n\\n```\\nclass Solution:\\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        INF = float(\\'inf\\')\\n        N = len(edges)\\n        dist_node1 = [INF for _ in range(N)]\\n        dist_node2 = [INF for _ in range(N)]\\n        \\n        def dfs(node, di, d):\\n            if d[node] > di: \\n                d[node] = di\\n                if edges[node] != -1:\\n                    dfs(edges[node], di+1, d)\\n        \\n        dfs(node1, 0, dist_node1)\\n        dfs(node2, 0, dist_node2)\\n\\n        for i in range(N):\\n            dist_node1[i] = max(dist_node1[i], dist_node2[i])\\n                        \\n        ans = dist_node1.index(min(dist_node1))\\n        return ans if dist_node1[ans] != INF else -1\\n",
        "level": "medium",
        "type": [
            "parentheses mismatch",
            "unclosed string",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def cdist(self, it, distArray, distArrayIndex, edges:\n        rdist = 0 \n        nodes = []\n        while it != -1 and distArray[it+1][distArrayIndex] > rdist:\n            distArray[it][distArrayIndex] = rdist\n            nodes.append(it)\n            it = edges[it]\n            rdist += 1\n        return nodes\n            \n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\n        INF = float('inf')\n        dist = defaultdict(lambda: [INF,INF])\n        mmin, ans = INF, INF\n               \n        n = self.cdist(node1, dist, 0, edges)\n        n += self.cdist(node2, dist, 1, edges)\n                \n        for k in n:\n            m = max(dist[k])\n            if m != INF:\n                if m < mmin: \n                    mmin = m\n                    ans = k\n                elif m == mmin: \n                    ans = min(ans, k)\n                    \n        return ans if ans != 'inf' else -1\n"
    },
    {
        "slug": "string-compression-ii",
        "description": "Run-length encoding is a string compression method that works by\u00a0replacing consecutive identical characters (repeated 2 or more times) with the concatenation of the character and the number marking the count of the characters (length of the run). For example, to compress the string\u00a0\"aabccc\"\u00a0we replace \"aa\"\u00a0by\u00a0\"a2\"\u00a0and replace \"ccc\"\u00a0by\u00a0\"c3\". Thus the compressed string becomes \"a2bc3\".\nNotice that in this problem, we are not adding\u00a0'1'\u00a0after single characters.\nGiven a\u00a0string s\u00a0and an integer k. You need to delete at most\u00a0k characters from\u00a0s\u00a0such that the run-length encoded version of s\u00a0has minimum length.\nFind the minimum length of the run-length encoded\u00a0version of s after deleting at most k characters.",
        "examples": [
            "Input: s = \"aaabcccd\", k = 2\nOutput: 4\nExplanation: Compressing s without deleting anything will give us \"a3bc3d\" of length 6. Deleting any of the characters 'a' or 'c' would at most decrease the length of the compressed string to 5, for instance delete 2 'a' then we will have s = \"abcccd\" which compressed is abc3d. Therefore, the optimal way is to delete 'b' and 'd', then the compressed version of s will be \"a3c3\" of length 4.",
            "Input: s = \"aabbaa\", k = 2\nOutput: 2\nExplanation: If we delete both 'b' characters, the resulting compressed string would be \"a4\" of length 2.",
            "Input: s = \"aaaaaaaaaaa\", k = 0\nOutput: 3\nExplanation: Since k is zero, we cannot delete anything. The compressed string is \"a11\" of length 3."
        ],
        "constraints": "1 <= s.length <= 100\n0 <= k <= s.length\ns contains only lowercase English letters.",
        "oracle_code": "class Solution:\n    def dp(self,i,s,prev,k,ct,n,dct):\n        if k<0:\n            return float(\"infinity\")\n        if i>=n:\n            x=0\n            if ct>1:\n                x=len(str(ct))+1\n            elif ct==1:\n                x=1\n            return x\n        if (i,prev,ct,k) in dct:\n            return dct[(i,prev,ct,k)]\n        if s[i]==prev:\n            inc=self.dp(i+1,s,prev,k,ct+1,n,dct)\n        else:\n            x=0\n            if ct>1:\n                x=len(str(ct))+1\n            elif ct==1:\n                x=1\n            inc=x+self.dp(i+1,s,s[i],k,1,n,dct)\n        exc=self.dp(i+1,s,prev,k-1,ct,n,dct)\n        dct[(i,prev,ct,k)]=min(inc,exc)\n        return min(inc,exc)\n\n\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n        n=len(s)\n        return self.dp(0,s,\"\",k,0,n,{})",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def dp(self,i,s,prev,k,ct,n,dct):\\n        if k<0:\\n            return float(\"infinity\")\\n        if i>=n:\\n            x=0\\n            if ct>1:\\n                x=len(str(ct))+1\\n            elif ct==1:\\n                x=1\\n            return x\\n        if (i,prev,ct,k) in dct:\\n            return dct[(i,prev,ct,k)]\\n        if s[i]==prev:\\n            inc=self.dp(i+1,s,prev,k,ct+1,n,dct)\\n        else:\\n            x=0\\n            if ct>1:\\n                x=len(str(ct))+1\\n            elif ct==1:\\n                x=1\\n            inc=x+self.dp(i+1,s,s[i],k,1,n,dct)\\n        exc=self.dp(i+1,s,prev,k-1,ct,n,dct)\\n        dct[(i,prev,ct,k)]=min(inc,exc)\\n        return min(inc,exc)\\n\\n\\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\\n        n=len(s)\\n        return self.dp(0,s,\"\",k,0,n,{})\\n\\n        \\n```",
        "level": "hard",
        "type": [
            "parentheses mismatch",
            "undefined keywords from other languages",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    var dp = function(i,s,prev,k,ct,n,dct {\n        if(k<0) {\n            return Number.POSITIVE_INFINITY;\n        }\n        if(i>=n+1){\n            x=0;\n            if(ct>1){\n                x=len(str(ct))+1;\n            } elif(ct==1) {\n                x=1;\n            }\n            return x;\n        }\n        if((i,prev,ct,k) in dct) {\n            return dct[(i,prev,ct,k)];\n        }\n        if(s[i]==prev){\n            inc=self.dp(i+1,s,prev,k,ct+1,n,dct);\n        } else{\n            x=0;\n            if(ct>1){\n                x=len(str(ct))+1;\n            } elif(ct==1) {\n                x=1;\n            }\n            inc=x+self.dp(i+1,s,s[i],k,1,n,dct);\n        }\n        exc=self.dp(i+1,s,prev,k-1,ct,n,dct);\n        dct[(i,prev,ct,k)]=Math.min(inc,exc);\n        return Math.min(inc,exc)\n    }\n\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n        n=len(s)\n        return self.dp(0,s,\"\",k,0,n,{})\n"
    },
    {
        "slug": "increasing-order-search-tree",
        "description": "Given the root of a binary search tree, rearrange the tree in in-order so that the leftmost node in the tree is now the root of the tree, and every node has no left child and only one right child.",
        "examples": [
            "Input: root = [5,3,6,2,4,null,8,1,null,null,null,7,9]\nOutput: [1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9]",
            "Input: root = [5,1,7]\nOutput: [1,null,5,null,7]"
        ],
        "constraints": "The number of nodes in the given tree will be in the range [1, 100].\n0 <= Node.val <= 1000",
        "oracle_code": "class Solution:\n    def increasingBST(self, root: TreeNode) -> TreeNode:\n        newRoot = TreeNode(0)\n        self.temp = newRoot\n        def inorder(root):\n            if root is None: return None\n            inorder(root.left)\n            new = TreeNode(root.val)\n            self.temp.right = new\n            self.temp = self.temp.right\n            inorder(root.right)\n        inorder(root)\n        return newRoot.right",
        "content": "# Code\\n```\\nclass Solution:\\n    def increasingBST(self, root: TreeNode) -> TreeNode:\\n        newRoot = TreeNode(0)\\n        self.temp = newRoot\\n        def inorder(root):\\n            if root is None: return None\\n            inorder(root.left)\\n            new = TreeNode(root.val)\\n            self.temp.right = new\\n            self.temp = self.temp.right\\n            inorder(root.right)\\n        inorder(root)\\n        return newRoot.right\\n```",
        "level": "easy",
        "type": [
            "indentation error",
            "parentheses mismatch",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\ndef increasingBST(self, root: TreeNode) -> TreeNode:\n    newRoot = TreeNode(0)\n    self.temp = newRoot\n    def inorder(root):\n        if root is None: return None\n        inorder(root.left\n        new = TreeNode(root.val)\n        self.temp.right = new\n        self.temp = self.temp.left\n            inorder(root.right)\n        inorder(root)\n        return newRoot.right\n\n"
    },
    {
        "slug": "kth-largest-element-in-an-array",
        "description": "Given an integer array nums and an integer k, return the kth largest element in the array.\nNote that it is the kth largest element in the sorted order, not the kth distinct element.\nCan you solve it without sorting?",
        "examples": [
            "Input: nums = [3,2,1,5,6,4], k = 2\nOutput: 5",
            "Input: nums = [3,2,3,1,2,4,5,5,6], k = 4\nOutput: 4"
        ],
        "constraints": "1 <= k <= nums.length <= 105\n-104 <= nums[i] <= 104",
        "oracle_code": "class Solution:\n    def findKthLargest(self, nums: List[int], k: int) -> int:\n        return sorted(nums)[-k]",
        "content": "# Approach\\n- Sorting\\n\\n# Complexity\\n- Time complexity: O(n*log(n))\\n\\n# Code\\n```\\nclass Solution:\\n    def findKthLargest(self, nums: List[int], k: int) -> int:\\n        return sorted(nums)[-k]\\n```",
        "level": "medium",
        "type": [
            "colon missing",
            "operation error",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution\n    def findKthLargest(self, nums: List[int], k: int) -> int:\n        return sort(nums)[-k-1]\n"
    },
    {
        "slug": "closest-dessert-cost",
        "description": "You would like to make dessert and are preparing to buy the ingredients. You have n ice cream base flavors and m types of toppings to choose from. You must follow these rules when making your dessert:\n\nThere must be exactly one ice cream base.\nYou can add one or more types of topping or have no toppings at all.\nThere are at most two of each type of topping.\n\nYou are given three inputs:\n\nbaseCosts, an integer array of length n, where each baseCosts[i] represents the price of the ith ice cream base flavor.\ntoppingCosts, an integer array of length m, where each toppingCosts[i] is the price of one of the ith topping.\ntarget, an integer representing your target price for dessert.\n\nYou want to make a dessert with a total cost as close to target as possible.\nReturn the closest possible cost of the dessert to target. If there are multiple, return the lower one.",
        "examples": [
            "Input: baseCosts = [1,7], toppingCosts = [3,4], target = 10\nOutput: 10\nExplanation: Consider the following combination (all 0-indexed):\n- Choose base 1: cost 7\n- Take 1 of topping 0: cost 1 x 3 = 3\n- Take 0 of topping 1: cost 0 x 4 = 0\nTotal: 7 + 3 + 0 = 10.",
            "Input: baseCosts = [2,3], toppingCosts = [4,5,100], target = 18\nOutput: 17\nExplanation: Consider the following combination (all 0-indexed):\n- Choose base 1: cost 3\n- Take 1 of topping 0: cost 1 x 4 = 4\n- Take 2 of topping 1: cost 2 x 5 = 10\n- Take 0 of topping 2: cost 0 x 100 = 0\nTotal: 3 + 4 + 10 + 0 = 17. You cannot make a dessert with a total cost of 18.",
            "Input: baseCosts = [3,10], toppingCosts = [2,5], target = 9\nOutput: 8\nExplanation: It is possible to make desserts with cost 8 and 10. Return 8 as it is the lower cost."
        ],
        "constraints": "n == baseCosts.length\nm == toppingCosts.length\n1 <= n, m <= 10\n1 <= baseCosts[i], toppingCosts[i] <= 104\n1 <= target <= 104",
        "oracle_code": "class Solution:\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\n        toppingCosts *= 2\n        \n        @cache\n        def fn(i, x):\n            \"\"\"Return sum of subsequence of toppingCosts[i:] closest to x.\"\"\"\n            if x < 0 or i == len(toppingCosts): return 0\n            return min(fn(i+1, x), toppingCosts[i] + fn(i+1, x-toppingCosts[i]), key=lambda y: (abs(y-x), y))\n        \n        ans = inf\n        for bc in baseCosts: \n            ans = min(ans, bc + fn(0, target - bc), key=lambda x: (abs(x-target), x))\n        return ans",
        "content": "\\n```\\nclass Solution:\\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\\n        toppingCosts *= 2\\n        \\n        @cache\\n        def fn(i, x):\\n            \"\"\"Return sum of subsequence of toppingCosts[i:] closest to x.\"\"\"\\n            if x < 0 or i == len(toppingCosts): return 0\\n            return min(fn(i+1, x), toppingCosts[i] + fn(i+1, x-toppingCosts[i]), key=lambda y: (abs(y-x), y))\\n        \\n        ans = inf\\n        for bc in baseCosts: \\n            ans = min(ans, bc + fn(0, target - bc), key=lambda x: (abs(x-target), x))\\n        return ans \\n```\\nTime complexity `O(MNV)`\\n\\nEdited on 2/28/2021\\n\\nAdding the version by @lenchen1112\\n```\\nclass Solution:\\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\\n        \\n        @cache\\n        def fn(i, cost):\\n            \"\"\"Return sum of subsequence closest to target.\"\"\"\\n            if cost >= target or i == len(toppingCosts): return cost\\n            return min(fn(i+1, cost), fn(i+1, cost+toppingCosts[i]), key=lambda x: (abs(x-target), x))\\n        \\n        ans = inf\\n        toppingCosts *= 2\\n        for cost in baseCosts: \\n            ans = min(ans, fn(0, cost), key=lambda x: (abs(x-target), x))\\n        return ans \\n```\\n\\nAdding binary search implementation\\n```\\nclass Solution:\\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\\n        top = {0}\\n        for x in toppingCosts*2: \\n            top |= {x + xx for xx in top}\\n        top = sorted(top)\\n        \\n        ans = inf \\n        for bc in baseCosts: \\n            k = bisect_left(top, target - bc)\\n            if k < len(top): ans = min(ans, bc + top[k], key=lambda x: (abs(x-target), x))\\n            if k: ans = min(ans, bc + top[k-1], key=lambda x: (abs(x-target), x))\\n        return ans \\n```\\nTime complexity `O(N*2^(2N) + MN)`",
        "level": "medium",
        "type": [
            "parentheses mismatch",
            "undefined keywords from other languages",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\n        toppingCosts *= 2\n\n        @cache\n        def fn(i, x):\n            \"\"\"Return sum of subsequence of toppingCosts[i:] closest to x.\"\"\"\n            if x < 0 or i == len(toppingCosts: return 0\n            return min(fn(i+1, x), toppingCosts[i] + fn(i+2, x-toppingCosts[i]), key=lambda y: (abs(y-x), y))\n        \n        ans = infinity\n        for bc in baseCosts: \n            ans = min(ans, bc + fn(0, target - bc), key=lambda x: (abs(x-target), x))\n        return ans\n"
    },
    {
        "slug": "grid-game",
        "description": "You are given a 0-indexed 2D array grid of size 2 x n, where grid[r][c] represents the number of points at position (r, c) on the matrix. Two robots are playing a game on this matrix.\nBoth robots initially start at (0, 0) and want to reach (1, n-1). Each robot may only move to the right ((r, c) to (r, c + 1)) or down ((r, c) to (r + 1, c)).\nAt the start of the game, the first robot moves from (0, 0) to (1, n-1), collecting all the points from the cells on its path. For all cells (r, c) traversed on the path, grid[r][c] is set to 0. Then, the second robot moves from (0, 0) to (1, n-1), collecting the points on its path. Note that their paths may intersect with one another.\nThe first robot wants to minimize the number of points collected by the second robot. In contrast, the second robot wants to maximize the number of points it collects. If both robots play optimally, return the number of points collected by the second robot.",
        "examples": [
            "Input: grid = [[2,5,4],[1,5,1]]\nOutput: 4\nExplanation: The optimal path taken by the first robot is shown in red, and the optimal path taken by the second robot is shown in blue.\nThe cells visited by the first robot are set to 0.\nThe second robot will collect 0 + 0 + 4 + 0 = 4 points.",
            "Input: grid = [[3,3,1],[8,5,2]]\nOutput: 4\nExplanation: The optimal path taken by the first robot is shown in red, and the optimal path taken by the second robot is shown in blue.\nThe cells visited by the first robot are set to 0.\nThe second robot will collect 0 + 3 + 1 + 0 = 4 points.",
            "Input: grid = [[1,3,1,15],[1,3,3,1]]\nOutput: 7\nExplanation: The optimal path taken by the first robot is shown in red, and the optimal path taken by the second robot is shown in blue.\nThe cells visited by the first robot are set to 0.\nThe second robot will collect 0 + 1 + 3 + 3 + 0 = 7 points."
        ],
        "constraints": "grid.length == 2\nn == grid[r].length\n1 <= n <= 5 * 104\n1 <= grid[r][c] <= 105",
        "oracle_code": "class Solution:\n    def gridGame(self, grid: List[List[int]]) -> int: \n        result = float(\"inf\")\n        left,right = 0,sum(grid[0])\n\n        for a,b in zip(grid[0],grid[1]):\n            right-=a\n\n            result = min(result,max(left,right))\n            left+=b\n        \n        return result\n\n# time & space - O(n),O(1)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def gridGame(self, grid: List[List[int]]) -> int: \\n        result = float(\"inf\")\\n        left,right = 0,sum(grid[0])\\n\\n        for a,b in zip(grid[0],grid[1]):\\n            right-=a\\n\\n            result = min(result,max(left,right))\\n            left+=b\\n        \\n        return result\\n\\n# time & space - O(n),O(1)\\n\\n\\n```",
        "level": "medium",
        "type": [
            "indentation error",
            "colon missing",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution:\ndef gridGame(self, grid: List[List[int]]) -> int \n        result = float(\"inf\")\n        left,right = 0,sum(grid[0])\n\n        for a,b in zip(grid[0],grid[1]):\n        right-=a\n\n            result = min(result,max(left,right))\n            left+=b\n        \n        return result\n\n\n"
    },
    {
        "slug": "length-of-the-longest-valid-substring",
        "description": "You are given a string word and an array of strings forbidden.\nA string is called valid if none of its substrings are present in forbidden.\nReturn the length of the longest valid substring of the string word.\nA substring is a contiguous sequence of characters in a string, possibly empty.",
        "examples": [
            "Input: word = \"cbaaaabc\", forbidden = [\"aaa\",\"cb\"]\nOutput: 4\nExplanation: There are 11 valid substrings in word: \"c\", \"b\", \"a\", \"ba\", \"aa\", \"bc\", \"baa\", \"aab\", \"ab\", \"abc\"and \"aabc\". The length of the longest valid substring is 4. \nIt can be shown that all other substrings contain either \"aaa\" or \"cb\" as a substring.",
            "Input: word = \"leetcode\", forbidden = [\"de\",\"le\",\"e\"]\nOutput: 4\nExplanation: There are 11 valid substrings in word: \"l\", \"t\", \"c\", \"o\", \"d\", \"tc\", \"co\", \"od\", \"tco\", \"cod\", and \"tcod\". The length of the longest valid substring is 4.\nIt can be shown that all other substrings contain either \"de\", \"le\", or \"e\" as a substring."
        ],
        "constraints": "1 <= word.length <= 105\nword consists only of lowercase English letters.\n1 <= forbidden.length <= 105\n1 <= forbidden[i].length <= 10\nforbidden[i] consists only of lowercase English letters.",
        "oracle_code": "class Solution:\n    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int:\n        trie = {}\n        for f in forbidden:\n            t = trie\n            for c in f:\n                if c not in t:\n                    t[c] = {}\n                t = t[c]\n            t[\"end\"] = True\n        \n        def isForbidden(s):\n            t = trie\n            counter = 0\n            for c in s:\n                if c not in t:\n                    return False\n                t = t[c]\n                counter += 1\n                if \"end\" in t:\n                    return counter\n            return False\n        \n        res = 0\n        j = len(word)\n        for i in range(len(word) - 1, -1, -1):\n            truc = isForbidden(word[i:j])\n            if truc:\n                j = i + truc - 1\n            res = max(res, j - i)\n        return res",
        "content": "Put all the forbidden strings into a trie, so that for each string `s`, we can check every substring starts from the beginning (i.e. `s[:1]`,  `s[:2]` ...  `s[:len(s)]`) in one travesal.\\n\\nUse a sliding window to iterate from back to front, each time, we only need to check whether the substrings starting from the new character is forbidden. If the substring is forbidden, then we truncate the string and continue to search.\\n\\nUsing a trie can make the foibidden check fails faster and can deal with longer foibidden strings.\\n\\n# Code\\n```\\nclass Solution:\\n    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int:\\n        trie = {}\\n        for f in forbidden:\\n            t = trie\\n            for c in f:\\n                if c not in t:\\n                    t[c] = {}\\n                t = t[c]\\n            t[\"end\"] = True\\n        \\n        def isForbidden(s):\\n            t = trie\\n            counter = 0\\n            for c in s:\\n                if c not in t:\\n                    return False\\n                t = t[c]\\n                counter += 1\\n                if \"end\" in t:\\n                    return counter\\n            return False\\n        \\n        res = 0\\n        j = len(word)\\n        for i in range(len(word) - 1, -1, -1):\\n            truc = isForbidden(word[i:j])\\n            if truc:\\n                j = i + truc - 1\\n            res = max(res, j - i)\\n        return res\\n```",
        "level": "hard",
        "type": [
            "operation error",
            "unclosed string",
            "wrong comment mark"
        ],
        "buggy_code": "\nclass Solution:\n    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int:\n        trie = {}\n        for f in forbidden:\n            t = trie\n            for c in f:\n                if c not in t:\n                    t[c] = {}\n                t = t[c]\n            t[\"end\"] = True\n        \n        def isForbidden(s):\n            t = trie\n            counter = 0\n            for c in s:\n                if c not in t:\n                    //return False\n                t = t[c]\n                counter += 1\n                if \"end\" in t:\n                    return 'counter\n            return False\n        \n        res = 0\n        j = len(word)\n        for i in range(len(word) - 1, -1, -1):\n            truc = isForbidden(word[i:j])\n            if truc:\n                j = i - truc - 1\n            res = max(res, j - i)\n        return res\n"
    },
    {
        "slug": "substring-with-concatenation-of-all-words",
        "description": "You are given a string s and an array of strings words. All the strings of words are of the same length.\nA concatenated substring in s is a substring that contains all the strings of any permutation of words concatenated.\n\nFor example, if words = [\"ab\",\"cd\",\"ef\"], then \"abcdef\", \"abefcd\", \"cdabef\", \"cdefab\", \"efabcd\", and \"efcdab\" are all concatenated strings. \"acdbef\" is not a concatenated substring because it is not the concatenation of any permutation of words.\n\nReturn the starting indices of all the concatenated substrings in s. You can return the answer in any order.",
        "examples": [
            "Input: s = \"barfoothefoobarman\", words = [\"foo\",\"bar\"]\nOutput: [0,9]\nExplanation: Since words.length == 2 and words[i].length == 3, the concatenated substring has to be of length 6.\nThe substring starting at 0 is \"barfoo\". It is the concatenation of [\"bar\",\"foo\"] which is a permutation of words.\nThe substring starting at 9 is \"foobar\". It is the concatenation of [\"foo\",\"bar\"] which is a permutation of words.\nThe output order does not matter. Returning [9,0] is fine too.",
            "Input: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]\nOutput: []\nExplanation: Since words.length == 4 and words[i].length == 4, the concatenated substring has to be of length 16.\nThere is no substring of length 16 is s that is equal to the concatenation of any permutation of words.\nWe return an empty array.",
            "Input: s = \"barfoofoobarthefoobarman\", words = [\"bar\",\"foo\",\"the\"]\nOutput: [6,9,12]\nExplanation: Since words.length == 3 and words[i].length == 3, the concatenated substring has to be of length 9.\nThe substring starting at 6 is \"foobarthe\". It is the concatenation of [\"foo\",\"bar\",\"the\"] which is a permutation of words.\nThe substring starting at 9 is \"barthefoo\". It is the concatenation of [\"bar\",\"the\",\"foo\"] which is a permutation of words.\nThe substring starting at 12 is \"thefoobar\". It is the concatenation of [\"the\",\"foo\",\"bar\"] which is a permutation of words."
        ],
        "constraints": "1 <= s.length <= 104\n1 <= words.length <= 5000\n1 <= words[i].length <= 30\ns and words[i] consist of lowercase English letters.",
        "oracle_code": "class Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        wlen= len(words[0])\n        slen= wlen*len(words)\n        track=dict()\n        \n        occ = collections.Counter(words)\n\n        def test():\n            for key, val in track.items():\n                if val !=occ[key]:\n                    return False\n            return True\n        res=[]\n        #first look\n\n        for k in range(wlen):\n            for i in words:\n                track.update({i : 0})\n            for i in range(k,slen+k,wlen):\n                w=s[i:i+wlen]\n                if w in words:\n                    track.update({w: track[w]+1})\n            if test():\n                res.append(k)\n            #complete\n            for i in range(wlen+k, len(s)-slen+1,wlen):\n                \n                nw=s[i+slen-wlen:i+slen]\n                pw=s[i-wlen:i]\n                if nw in words:\n                    track.update({nw: track[nw]+1})\n                if pw in words:\n                    track.update({pw: track[pw]-1})\n                if test():\n                    res.append(i)\n        return res",
        "content": "\\n# Approach\\n\\nThe solution iterates through possible starting points in the given string and checks if the substring starting from each point forms a concatenated substring. It maintains a dictionary to track the occurrences of words encountered and compares it with the expected occurrences. By updating the counts while scanning the string, it identifies valid concatenated substrings and records their starting indices. The solution effectively ensures that all the words in any permutation of the input words array are present in the substring, returning the starting indices of all such valid substrings.\\n\\n# Code\\n```\\nclass Solution:\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\\n        wlen= len(words[0])\\n        slen= wlen*len(words)\\n        track=dict()\\n        \\n        occ = collections.Counter(words)\\n\\n        def test():\\n            for key, val in track.items():\\n                if val !=occ[key]:\\n                    return False\\n            return True\\n        res=[]\\n        #first look\\n\\n        for k in range(wlen):\\n            for i in words:\\n                track.update({i : 0})\\n            for i in range(k,slen+k,wlen):\\n                w=s[i:i+wlen]\\n                if w in words:\\n                    track.update({w: track[w]+1})\\n            if test():\\n                res.append(k)\\n            #complete\\n            for i in range(wlen+k, len(s)-slen+1,wlen):\\n                \\n                nw=s[i+slen-wlen:i+slen]\\n                pw=s[i-wlen:i]\\n                if nw in words:\\n                    track.update({nw: track[nw]+1})\\n                if pw in words:\\n                    track.update({pw: track[pw]-1})\\n                if test():\\n                    res.append(i)\\n        return res\\n\\n        \\n```",
        "level": "hard",
        "type": [
            "indentation error",
            "operation error",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        wlen= len(words[0])\n        slen= wlen*len(words)\n        track=dict()\n        \n        occ = collections.Counter(words)\n\n    def test():\n        for key, val in track.items():\n            if val !=occ[key]:\n                return False \n        return True\n    res=[]\n    \n\n    for k in range(wlen):\n        for i in words:\n            track.update({i : 0}))\n        for i in range(k,slen+k,wlen):\n            w=s[i:i+wlen]\n            if w in words:\n                track.update({w: track[w]+1)})\n            if test():\n                res.append(k)\n            #complete\n            for i in range(wlen+k, len(s)-slen+1,wlen):\n                \n                nw=s[i+slen-wlen:i+slen]\n                pw=s[i-wlen:i]\n                if nw in words:\n                    track.update({nw: track[nw]+1}))\n            if pw in words:\n                track.update({pw: track[pw]-1)})\n            if test()):\n                res.append(i-wl)en)\n    return res\n"
    },
    {
        "slug": "median-of-two-sorted-arrays",
        "description": "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\nThe overall run time complexity should be O(log (m+n)).",
        "examples": [
            "Input: nums1 = [1,3], nums2 = [2]\nOutput: 2.00000\nExplanation: merged array = [1,2,3] and median is 2.",
            "Input: nums1 = [1,2], nums2 = [3,4]\nOutput: 2.50000\nExplanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5."
        ],
        "constraints": "nums1.length == m\nnums2.length == n\n0 <= m <= 1000\n0 <= n <= 1000\n1 <= m + n <= 2000\n-106 <= nums1[i], nums2[i] <= 106",
        "oracle_code": "class Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        p1 = 0\n        p2 = 0\n        new = []\n        while p1 < len(nums1) and p2 < len(nums2):\n            if nums1[p1] < nums2[p2]:\n                new.append(nums1[p1])\n                p1 += 1\n            else:\n                new.append(nums2[p2])\n                p2 += 1\n        while p1 < len(nums1):\n            new.append(nums1[p1])\n            p1 += 1\n        while p2 < len(nums2):\n            new.append(nums2[p2])\n            p2+= 1\n        if len(new) % 2 == 0:\n            index = len(new) // 2\n            median = (new[index] + new[index-1]) / 2\n        else:\n            median = float(new[len(new)//2])\n        return median",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind this approach is to merge the two sorted arrays while maintaining the order, and then finding the median based on the length of the merged array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize two pointers, p1 and p2, for the two input arrays nums1 and nums2, respectively, both starting at index 0.\\n2. Create an empty list new to store the merged array.\\n3. Iterate through both arrays using the pointers. Compare the elements pointed to by p1 and p2. Append the smaller element to the new array and increment the corresponding pointer.\\n4. After the iteration, there might be remaining elements in one of the arrays. Iterate through the remaining elements and append them to the new array.\\n5. Calculate the median based on the length of the new array. If the length is even, take the average of the middle two elements. If the length is odd, take the middle element.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(m + n), where m and n are the lengths of the two input arrays.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(m + n), as the merged array new can contain all the elements from the two input arrays.\\n\\n# Code\\n```\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        p1 = 0\\n        p2 = 0\\n        new = []\\n        while p1 < len(nums1) and p2 < len(nums2):\\n            if nums1[p1] < nums2[p2]:\\n                new.append(nums1[p1])\\n                p1 += 1\\n            else:\\n                new.append(nums2[p2])\\n                p2 += 1\\n        while p1 < len(nums1):\\n            new.append(nums1[p1])\\n            p1 += 1\\n        while p2 < len(nums2):\\n            new.append(nums2[p2])\\n            p2+= 1\\n        if len(new) % 2 == 0:\\n            index = len(new) // 2\\n            median = (new[index] + new[index-1]) / 2\\n        else:\\n            median = float(new[len(new)//2])\\n        return median\\n```",
        "level": "hard",
        "type": [
            "colon missing",
            "wrong comment mark",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float\n        p1 = 0\n        p2 = 0\n        \n        while p1 < len(nums1) and p2 < len(nums2):\n            if nums1[p1] < nums2[p2]:\n                new.append(nums1[p1])\n                p1 += 1\n            else:\n                new.append(nums2[p2])\n                p2 += 1\n        while p1 < len(nums1):\n            new.append(nums1[p1])\n            p1 += 1\n        while p2 <= len(nums2):\n            new.append(nums2[p2])\n            p2+= 1\n        if len(new) % 2 == 0:\n            index = len(new) // 2\n            median = (new[index] + new[index-1]) / 2\n        else:\n            median = float(new[len(new)//2])\n        return median\n"
    },
    {
        "slug": "partition-string-into-substrings-with-values-at-most-k",
        "description": "You are given a string s consisting of digits from 1 to 9 and an integer k.\nA partition of a string s is called good if:\n\nEach digit of s is part of exactly one substring.\nThe value of each substring is less than or equal to k.\n\nReturn the minimum number of substrings in a good partition of s. If no good partition of s exists, return -1.\nNote that:\n\nThe value of a string is its result when interpreted as an integer. For example, the value of \"123\" is 123 and the value of \"1\" is 1.\nA substring is a contiguous sequence of characters within a string.",
        "examples": [
            "Input: s = \"165462\", k = 60\nOutput: 4\nExplanation: We can partition the string into substrings \"16\", \"54\", \"6\", and \"2\". Each substring has a value less than or equal to k = 60.\nIt can be shown that we cannot partition the string into less than 4 substrings.",
            "Input: s = \"238182\", k = 5\nOutput: -1\nExplanation: There is no good partition for this string."
        ],
        "constraints": "1 <= s.length <= 105\ns[i] is a digit from '1' to '9'.\n1 <= k <= 109",
        "oracle_code": "class Solution:\n    def minimumPartition(self, s: str, k: int) -> int:\n        curr, ans = 0, 1\n        for d in s:\n            if int(d) > k:\n                return -1\n            curr = 10 * curr + int(d)\n            if curr > k:\n                ans += 1\n                curr = int(d)\n        return ans",
        "content": "# Approach\\nWe scan all digits in `s` from left to right, and add 1 to `ans` whenever the current value of the segment exceeds `k`.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumPartition(self, s: str, k: int) -> int:\\n        curr, ans = 0, 1\\n        for d in s:\\n            if int(d) > k:\\n                return -1\\n            curr = 10 * curr + int(d)\\n            if curr > k:\\n                ans += 1\\n                curr = int(d)\\n        return ans\\n```",
        "level": "medium",
        "type": [
            "colon missing",
            "undefined keywords from other languages",
            "wrong comment mark"
        ],
        "buggy_code": "\nclass Solution:\n    def minimumPartition(self, s: str, k: int) -> int\n        \n        for d in s:\n            if int(d) > k:\n                return -1\n            curr = 10 * curt + int(d)\n            if curr > k:\n                ans += 1\n                curr = int(d)\n        return ans\n"
    },
    {
        "slug": "valid-permutations-for-di-sequence",
        "description": "You are given a string s of length n where s[i] is either:\n\n'D' means decreasing, or\n'I' means increasing.\n\nA permutation perm of n + 1 integers of all the integers in the range [0, n] is called a valid permutation if for all valid i:\n\nIf s[i] == 'D', then perm[i] > perm[i + 1], and\nIf s[i] == 'I', then perm[i] < perm[i + 1].\n\nReturn the number of valid permutations perm. Since the answer may be large, return it modulo 109 + 7.",
        "examples": [
            "Input: s = \"DID\"\nOutput: 5\nExplanation: The 5 valid permutations of (0, 1, 2, 3) are:\n(1, 0, 3, 2)\n(2, 0, 3, 1)\n(2, 1, 3, 0)\n(3, 0, 2, 1)\n(3, 1, 2, 0)",
            "Input: s = \"D\"\nOutput: 1"
        ],
        "constraints": "n == s.length\n1 <= n <= 200\ns[i] is either 'I' or 'D'.",
        "oracle_code": "class Solution:\n    def numPermsDISequence(self, s: str) -> int:\n        mem=defaultdict(int)\n        def dfs(i,val=0):\n            if i==len(s):\n                return 1\n            if (i,val) in mem:\n                return mem[i,val]\n            p=0\n            if s[i]==\"D\":\n                for ind in range(0,val+1):\n                    p+=dfs(i+1,ind)%(10**9+7)\n            else:\n                for ind in range(val+1,i+2):\n                    p+=dfs(i+1,ind)%(10**9+7)\n            mem[i,val]=p\n            return p\n        return dfs(0)",
        "content": "To add a new character to a sequence we only have to consider the last element-\\n\\nLets say currently DID sequence is 1032- this can form\\n\\nDIDI - in cases where we end with 3,4\\nDIDD - in cases where we end with 0,1,2\\n\\nSo just use the last element value to create a new sequence.\\n\\n```\\nclass Solution:\\n    def numPermsDISequence(self, s: str) -> int:\\n        mem=defaultdict(int)\\n        def dfs(i,val=0):\\n            if i==len(s):\\n                return 1\\n            if (i,val) in mem:\\n                return mem[i,val]\\n            p=0\\n            if s[i]==\"D\":\\n                for ind in range(0,val+1):\\n                    p+=dfs(i+1,ind)%(10**9+7)\\n            else:\\n                for ind in range(val+1,i+2):\\n                    p+=dfs(i+1,ind)%(10**9+7)\\n            mem[i,val]=p\\n            return p\\n        return dfs(0)\\n ```\\n\\t\\t\\t\\t",
        "level": "hard",
        "type": [
            "parentheses mismatch",
            "unclosed string",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n    def numPermsDISequence(self, s: str) -> int:\n        mem=defaultdict(int)\n        def dfs(i,val=0):\n            if i=len(s): \n                return 1\n            if (i,val in mem:\n                return mem[i,val]\n            p=0\n            if s[i]==\"D:\n                for ind in range(0,val+1):\n                    p+=dfs(i+1,ind)%(10**9+7)\n            else:\n                if ind in range(val+1,i+2):\n                    p+=dfs(i+1,ind)%(10**9+7)\n            mem[i,val]=p\n            return p\n        return dfs(0)\n"
    },
    {
        "slug": "check-whether-two-strings-are-almost-equivalent",
        "description": "Two strings word1 and word2 are considered almost equivalent if the differences between the frequencies of each letter from 'a' to 'z' between word1 and word2 is at most 3.\nGiven two strings word1 and word2, each of length n, return true if word1 and word2 are almost equivalent, or false otherwise.\nThe frequency of a letter x is the number of times it occurs in the string.",
        "examples": [
            "Input: word1 = \"aaaa\", word2 = \"bccb\"\nOutput: false\nExplanation: There are 4 'a's in \"aaaa\" but 0 'a's in \"bccb\".\nThe difference is 4, which is more than the allowed 3.",
            "Input: word1 = \"abcdeef\", word2 = \"abaaacc\"\nOutput: true\nExplanation: The differences between the frequencies of each letter in word1 and word2 are at most 3:\n- 'a' appears 1 time in word1 and 4 times in word2. The difference is 3.\n- 'b' appears 1 time in word1 and 1 time in word2. The difference is 0.\n- 'c' appears 1 time in word1 and 2 times in word2. The difference is 1.\n- 'd' appears 1 time in word1 and 0 times in word2. The difference is 1.\n- 'e' appears 2 times in word1 and 0 times in word2. The difference is 2.\n- 'f' appears 1 time in word1 and 0 times in word2. The difference is 1.",
            "Input: word1 = \"cccddabba\", word2 = \"babababab\"\nOutput: true\nExplanation: The differences between the frequencies of each letter in word1 and word2 are at most 3:\n- 'a' appears 2 times in word1 and 4 times in word2. The difference is 2.\n- 'b' appears 2 times in word1 and 5 times in word2. The difference is 3.\n- 'c' appears 3 times in word1 and 0 times in word2. The difference is 3.\n- 'd' appears 2 times in word1 and 0 times in word2. The difference is 2."
        ],
        "constraints": "n == word1.length == word2.length\n1 <= n <= 100\nword1 and word2 consist only of lowercase English letters.",
        "oracle_code": "class Solution:\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\n        A = [0] * 26\n        for char in word1: A[ord(char) - ord(\"a\")] += 1\n        for char in word2: A[ord(char) - ord(\"a\")] -= 1\n        return not any ([(f < -3 or f > 3) for f in A])",
        "content": "# Code\\n```\\nclass Solution:\\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\\n        A = [0] * 26\\n        for char in word1: A[ord(char) - ord(\"a\")] += 1\\n        for char in word2: A[ord(char) - ord(\"a\")] -= 1\\n        return not any ([(f < -3 or f > 3) for f in A])        \\n\\n```",
        "level": "easy",
        "type": [
            "colon missing",
            "undefined objects",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution:\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool\n        A = [0] * 26\n        for char in word1: A[ord(char) - ord(\"a\")] += 1\n        for char in word2: B[ord(char) - ord(\"a\")] -= 1\n        return not any ([(f < -3 or f > 3) for f in A]\n"
    },
    {
        "slug": "kth-largest-element-in-an-array",
        "description": "Given an integer array nums and an integer k, return the kth largest element in the array.\nNote that it is the kth largest element in the sorted order, not the kth distinct element.\nCan you solve it without sorting?",
        "examples": [
            "Input: nums = [3,2,1,5,6,4], k = 2\nOutput: 5",
            "Input: nums = [3,2,3,1,2,4,5,5,6], k = 4\nOutput: 4"
        ],
        "constraints": "1 <= k <= nums.length <= 105\n-104 <= nums[i] <= 104",
        "oracle_code": "class Solution:\n    def findKthLargest(self, nums: List[int], k: int) -> int:\n        return sorted(nums)[-k]",
        "content": "# Approach\\n- Sorting\\n\\n# Complexity\\n- Time complexity: O(n*log(n))\\n\\n# Code\\n```\\nclass Solution:\\n    def findKthLargest(self, nums: List[int], k: int) -> int:\\n        return sorted(nums)[-k]\\n```",
        "level": "medium",
        "type": [
            "colon missing",
            "undefined keywords from other languages",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution\n    def findKthLargest(self, nums: List[int], k: int) -> int:\n        return sort(nums)[-k-1]\n"
    },
    {
        "slug": "count-the-repetitions",
        "description": "We define str = [s, n] as the string str which consists of the string s concatenated n times.\n\nFor example, str == [\"abc\", 3] ==\"abcabcabc\".\n\nWe define that string s1 can be obtained from string s2 if we can remove some characters from s2 such that it becomes s1.\n\nFor example, s1 = \"abc\" can be obtained from s2 = \"abdbec\" based on our definition by removing the bolded underlined characters.\n\nYou are given two strings s1 and s2 and two integers n1 and n2. You have the two strings str1 = [s1, n1] and str2 = [s2, n2].\nReturn the maximum integer m such that str = [str2, m] can be obtained from str1.",
        "examples": [
            "Input: s1 = \"acb\", n1 = 4, s2 = \"ab\", n2 = 2\nOutput: 2",
            "Input: s1 = \"acb\", n1 = 1, s2 = \"acb\", n2 = 1\nOutput: 1"
        ],
        "constraints": "1 <= s1.length, s2.length <= 100\ns1 and s2 consist of lowercase English letters.\n1 <= n1, n2 <= 106",
        "oracle_code": "class Solution:\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\n\n        rec, track = [0], defaultdict(int) \n        ct = start = ptr1 = ptr2 = 0\n\n        if not set(s2).issubset(set(s1)): return 0\n\n        s1 = ''.join(char for char in s1 if char in set(s2))\n        \n        while True:\n            for char in s2:\n                ptr = s1.find(char, start)\n                if ptr == -1:\n                    ct += 1\n                    ptr = s1.find(char)\n                start = ptr+1\n            rec.append(ct + 1)\n\n            if rec[-1] > n1: return (len(rec)-2)//n2\n\n            if ptr not in track: track[ptr] = len(rec)-1\n            else: break\n        \n        cycleStart = rec[track[ptr]]\n        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]\n        rest = n1 - cycleStart\n        \n        rem = cycleStart + rest%cycle1\n\n        while rec[ptr2] <= rem: ptr2+= 1\n\n        return (cycle2 * (rest//cycle1) + ptr2-1)//n2",
        "content": "```\\nclass Solution:\\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\\n\\n        rec, track = [0], defaultdict(int) \\n        ct = start = ptr1 = ptr2 = 0\\n\\n        if not set(s2).issubset(set(s1)): return 0\\n\\n        s1 = \\'\\'.join(char for char in s1 if char in set(s2))\\n        \\n        while True:\\n            for char in s2:\\n                ptr = s1.find(char, start)\\n                if ptr == -1:\\n                    ct += 1\\n                    ptr = s1.find(char)\\n                start = ptr+1\\n            rec.append(ct + 1)\\n\\n            if rec[-1] > n1: return (len(rec)-2)//n2\\n\\n            if ptr not in track: track[ptr] = len(rec)-1\\n            else: break\\n        \\n        cycleStart = rec[track[ptr]]\\n        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]\\n        rest = n1 - cycleStart\\n        \\n        rem = cycleStart + rest%cycle1\\n\\n        while rec[ptr2] <= rem: ptr2+= 1\\n\\n        return (cycle2 * (rest//cycle1) + ptr2-1)//n2\\n```\\n[https://leetcode.com/problems/count-the-repetitions/submissions/864907562/](http://)\\n\\nI could be wrong, but I think that time is *O*(*N*) and space is *O*(*N*).",
        "level": "hard",
        "type": [
            "undefined methods",
            "undefined objects",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\n\n        rec, track = [0], defaultdict(int) \n        ct = start = ptr1 = undefinedVariable = 0\n\n        if not set(s2).issubset(set(s1)): return 0\n\n        s1 = ''.join(char for char in s1 if char in set(undefinedVariable))\n        \n        while True:\n            for char in s2:\n                ptr = s1.find(char, start)\n                if ptr == -1:\n                    ct += 1\n                    ptr = s1.find(char)\n                start = ptr+1\n            rec.append(ct + 1)\n\n            if rec[-1] >= n1: return (len(rec)-2)//n2\n\n            if ptr not in track: track[ptr] = len(rec)-1\n            else: break\n        \n        cycleStart = rec[track[ptr]]\n        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]\n        rest = n1 - cycleStart\n        \n        rem = cycleStart + self.calculateRemainder(rest, cycle1)\n\n        while rec[ptr2] <= rem: ptr2+= 1\n\n        return (cycle2 * (rest//cycle1) + ptr2-1)//n2\n"
    },
    {
        "slug": "average-value-of-even-numbers-that-are-divisible-by-three",
        "description": "Given an integer array nums of positive integers, return the average value of all even integers that are divisible by 3.\nNote that the average of n elements is the sum of the n elements divided by n and rounded down to the nearest integer.",
        "examples": [
            "Input: nums = [1,3,6,10,12,15]\nOutput: 9\nExplanation: 6 and 12 are even numbers that are divisible by 3. (6 + 12) / 2 = 9.",
            "Input: nums = [1,2,4,7,10]\nOutput: 0\nExplanation: There is no single number that satisfies the requirement, so return 0."
        ],
        "constraints": "1 <= nums.length <= 1000\n1 <= nums[i] <= 1000",
        "oracle_code": "class Solution:\n    def averageValue(self, nums: List[int]) -> int:\n        return int(sum(lst) / len(lst)) if len(lst := [num for num in nums if num % 6 == 0]) > 0 else 0",
        "content": "# Intuition\\nI wanted to solve this problem in **one line** using python, I figured this was the perfect use for the **Walrus Operator!**\\n\\n# Approach\\nI didn\\'t want any extra iterations, so we perform a list comprehention with only the values divisible by 6 (2 and 3) and use the walrus operator to store the comprehention in *lst*. Then, we can take the average as you would expect, accounting for dividing by zero using an in-line if statement.  \\n\\nIf you\\'ve never used the walrus operator before: https://realpython.com/python-walrus-operator/ \\n\\n# Complexity\\n- Time complexity:\\nO(n), we iterate over each item in the input list once. \\n\\n- Space complexity:\\nO(n), we store all elements divisible by both 2 and 3.\\n\\n# Code\\n\\n```\\nclass Solution:\\n    def averageValue(self, nums: List[int]) -> int:\\n        return int(sum(lst) / len(lst)) if len(lst := [num for num in nums if num % 6 == 0]) > 0 else 0 \\n```",
        "level": "easy",
        "type": [
            "wrong comment mark",
            "== and = confusion",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def averageValue(self, nums: List[int]) -> int:\n        return int(sum(lst) / len(lst)) \n\n1\n"
    },
    {
        "slug": "check-if-two-string-arrays-are-equivalent",
        "description": "Given two string arrays word1 and word2, return true if the two arrays represent the same string, and false otherwise.\nA string is represented by an array if the array elements concatenated in order forms the string.",
        "examples": [
            "Input: word1 = [\"ab\", \"c\"], word2 = [\"a\", \"bc\"]\nOutput: true\nExplanation:\nword1 represents string \"ab\" + \"c\" -> \"abc\"\nword2 represents string \"a\" + \"bc\" -> \"abc\"\nThe strings are the same, so return true.",
            "Input: word1 = [\"a\", \"cb\"], word2 = [\"ab\", \"c\"]\nOutput: false",
            "Input: word1  = [\"abc\", \"d\", \"defg\"], word2 = [\"abcddefg\"]\nOutput: true"
        ],
        "constraints": "1 <= word1.length, word2.length <= 103\n1 <= word1[i].length, word2[i].length <= 103\n1 <= sum(word1[i].length), sum(word2[i].length) <= 103\nword1[i] and word2[i] consist of lowercase letters.",
        "oracle_code": "class Solution:\n    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) -> bool:\n        word3=\"\".join(word1)\n        word4=\"\".join(word2)\n        if word3==word4:\n            return True\n        else:\n            return False",
        "content": "**1**.First we will join the contents or concatenate the Strings present in the list using join()\\n**2**.then compare 2 list.\\n**3** if true return true else return false\\n```\\nclass Solution:\\n    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) -> bool:\\n        word3=\"\".join(word1)\\n        word4=\"\".join(word2)\\n        if word3==word4:\\n            return True\\n        else:\\n            return False\\n```\\n**code**\\nOnline Solution :\\n    -Thank you for this solution @jeevabharathiS\\n        \\n```\\nclass Solution:\\n    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) \\n        return((\"\".join(word1))==(\"\".join(word2)))\\n```",
        "level": "easy",
        "type": [
            "parentheses mismatch",
            "wrong comment mark",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) -> bool:\n        word3=/*.join(word1)\n        word4=/*.join(word2\n        if word3=word4:\n            return True\n        else:\n            return False\n"
    },
    {
        "slug": "closest-dessert-cost",
        "description": "You would like to make dessert and are preparing to buy the ingredients. You have n ice cream base flavors and m types of toppings to choose from. You must follow these rules when making your dessert:\n\nThere must be exactly one ice cream base.\nYou can add one or more types of topping or have no toppings at all.\nThere are at most two of each type of topping.\n\nYou are given three inputs:\n\nbaseCosts, an integer array of length n, where each baseCosts[i] represents the price of the ith ice cream base flavor.\ntoppingCosts, an integer array of length m, where each toppingCosts[i] is the price of one of the ith topping.\ntarget, an integer representing your target price for dessert.\n\nYou want to make a dessert with a total cost as close to target as possible.\nReturn the closest possible cost of the dessert to target. If there are multiple, return the lower one.",
        "examples": [
            "Input: baseCosts = [1,7], toppingCosts = [3,4], target = 10\nOutput: 10\nExplanation: Consider the following combination (all 0-indexed):\n- Choose base 1: cost 7\n- Take 1 of topping 0: cost 1 x 3 = 3\n- Take 0 of topping 1: cost 0 x 4 = 0\nTotal: 7 + 3 + 0 = 10.",
            "Input: baseCosts = [2,3], toppingCosts = [4,5,100], target = 18\nOutput: 17\nExplanation: Consider the following combination (all 0-indexed):\n- Choose base 1: cost 3\n- Take 1 of topping 0: cost 1 x 4 = 4\n- Take 2 of topping 1: cost 2 x 5 = 10\n- Take 0 of topping 2: cost 0 x 100 = 0\nTotal: 3 + 4 + 10 + 0 = 17. You cannot make a dessert with a total cost of 18.",
            "Input: baseCosts = [3,10], toppingCosts = [2,5], target = 9\nOutput: 8\nExplanation: It is possible to make desserts with cost 8 and 10. Return 8 as it is the lower cost."
        ],
        "constraints": "n == baseCosts.length\nm == toppingCosts.length\n1 <= n, m <= 10\n1 <= baseCosts[i], toppingCosts[i] <= 104\n1 <= target <= 104",
        "oracle_code": "class Solution:\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\n        toppingCosts *= 2\n        \n        @cache\n        def fn(i, x):\n            \"\"\"Return sum of subsequence of toppingCosts[i:] closest to x.\"\"\"\n            if x < 0 or i == len(toppingCosts): return 0\n            return min(fn(i+1, x), toppingCosts[i] + fn(i+1, x-toppingCosts[i]), key=lambda y: (abs(y-x), y))\n        \n        ans = inf\n        for bc in baseCosts: \n            ans = min(ans, bc + fn(0, target - bc), key=lambda x: (abs(x-target), x))\n        return ans",
        "content": "\\n```\\nclass Solution:\\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\\n        toppingCosts *= 2\\n        \\n        @cache\\n        def fn(i, x):\\n            \"\"\"Return sum of subsequence of toppingCosts[i:] closest to x.\"\"\"\\n            if x < 0 or i == len(toppingCosts): return 0\\n            return min(fn(i+1, x), toppingCosts[i] + fn(i+1, x-toppingCosts[i]), key=lambda y: (abs(y-x), y))\\n        \\n        ans = inf\\n        for bc in baseCosts: \\n            ans = min(ans, bc + fn(0, target - bc), key=lambda x: (abs(x-target), x))\\n        return ans \\n```\\nTime complexity `O(MNV)`\\n\\nEdited on 2/28/2021\\n\\nAdding the version by @lenchen1112\\n```\\nclass Solution:\\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\\n        \\n        @cache\\n        def fn(i, cost):\\n            \"\"\"Return sum of subsequence closest to target.\"\"\"\\n            if cost >= target or i == len(toppingCosts): return cost\\n            return min(fn(i+1, cost), fn(i+1, cost+toppingCosts[i]), key=lambda x: (abs(x-target), x))\\n        \\n        ans = inf\\n        toppingCosts *= 2\\n        for cost in baseCosts: \\n            ans = min(ans, fn(0, cost), key=lambda x: (abs(x-target), x))\\n        return ans \\n```\\n\\nAdding binary search implementation\\n```\\nclass Solution:\\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\\n        top = {0}\\n        for x in toppingCosts*2: \\n            top |= {x + xx for xx in top}\\n        top = sorted(top)\\n        \\n        ans = inf \\n        for bc in baseCosts: \\n            k = bisect_left(top, target - bc)\\n            if k < len(top): ans = min(ans, bc + top[k], key=lambda x: (abs(x-target), x))\\n            if k: ans = min(ans, bc + top[k-1], key=lambda x: (abs(x-target), x))\\n        return ans \\n```\\nTime complexity `O(N*2^(2N) + MN)`",
        "level": "medium",
        "type": [
            "undefined keywords from other languages",
            "unclosed string",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\n        toppingCosts *= 2\n\n        @cache\n        def fn(i, x):\n            \"\"\"Return sum of subsequence of toppingCosts[i:] closest to x.\"\n            if x < 0 or i == len(toppingCosts): return 0\n            return min(fn(i+1, x), toppingCosts[i] + fn(i+2, x-toppingCosts[i]), key=lambda y: (abs(y-x), y))\n        \n        ans = infinity\n        for bc in baseCosts: \n            ans = min(ans, bc + fn(0, target - bc), key=lambda x: (abs(x-target), x))\n        return ans\n"
    },
    {
        "slug": "largest-positive-integer-that-exists-with-its-negative",
        "description": "Given an integer array nums that does not contain any zeros, find the largest positive integer k such that -k also exists in the array.\nReturn the positive integer k. If there is no such integer, return -1.",
        "examples": [
            "Input: nums = [-1,2,-3,3]\nOutput: 3\nExplanation: 3 is the only valid k we can find in the array.",
            "Input: nums = [-1,10,6,7,-7,1]\nOutput: 7\nExplanation: Both 1 and 7 have their corresponding negative values in the array. 7 has a larger value.",
            "Input: nums = [-10,8,6,7,-2,-3]\nOutput: -1\nExplanation: There is no a single valid k, we return -1."
        ],
        "constraints": "1 <= nums.length <= 1000\n-1000 <= nums[i] <= 1000\nnums[i] != 0",
        "oracle_code": "class Solution:\n    def findMaxK(self, nums: List[int]) -> int:\n        nums=sorted(nums,reverse=True)\n        s=set(nums)\n        for i in range(len(nums)):\n            if 0-nums[i] in s:\n                return nums[i]\n        return -1",
        "content": "\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def findMaxK(self, nums: List[int]) -> int:\\n        nums=sorted(nums,reverse=True)\\n        s=set(nums)\\n        for i in range(len(nums)):\\n            if 0-nums[i] in s:\\n                return nums[i]\\n        return -1\\n\\n```",
        "level": "easy",
        "type": [
            "operation error",
            "undefined keywords from other languages",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def findMaxK(self, nums: List[int]) -> int:\n        nums=sorted(nums,reverse=True)\n        s=set(nums)\n        for i in range(len(nums)+1):\n            if thisnums[i] in s:\n                return nums[i]\n        return -1\n"
    },
    {
        "slug": "can-place-flowers",
        "description": "You have a long flowerbed in which some of the plots are planted, and some are not. However, flowers cannot be planted in adjacent plots.\nGiven an integer array flowerbed containing 0's and 1's, where 0 means empty and 1 means not empty, and an integer n, return true\u00a0if n new flowers can be planted in the flowerbed without violating the no-adjacent-flowers rule and false otherwise.",
        "examples": [
            "Input: flowerbed = [1,0,0,0,1], n = 1\nOutput: true",
            "Input: flowerbed = [1,0,0,0,1], n = 2\nOutput: false"
        ],
        "constraints": "1 <= flowerbed.length <= 2 * 104\nflowerbed[i] is 0 or 1.\nThere are no two adjacent flowers in flowerbed.\n0 <= n <= flowerbed.length",
        "oracle_code": "class Solution:\n    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:\n        flowerbed=[0]+flowerbed+[0]\n        for i in range(1,len(flowerbed)-1):\n            if flowerbed[i]==0 and flowerbed[i+1]==0 and flowerbed[i-1]==0:flowerbed[i]=1;n-=1\n        if n<=0:return True\n        return False",
        "content": "![image.png](https://assets.leetcode.com/users/images/c82b49a3-d51e-40a4-b4b5-197596cb28f2_1691328287.5834074.png)\\n\\n\\n\\n\\n\\nPLease UPVOTE \\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:\\n        flowerbed=[0]+flowerbed+[0]\\n        for i in range(1,len(flowerbed)-1):\\n            if flowerbed[i]==0 and flowerbed[i+1]==0 and flowerbed[i-1]==0:flowerbed[i]=1;n-=1\\n        if n<=0:return True\\n        return False\\n```",
        "level": "easy",
        "type": [
            "colon missing",
            "undefined keywords from other languages",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:\n        flowerbed=[0]+flowerbed+[0]\n        for i in range(1,len(flowerbed)):\n            if flowerbed[i]==0 and flowerbed[i+1]==0 and flowerbed[i-1(]==0:flowerbed[i]=1;n-)  n-=1\n            else if(flowerbed[i]==1): =1\n        if n<=0:return True\n        return False\n"
    },
    {
        "slug": "check-if-every-row-and-column-contains-all-numbers",
        "description": "An n x n matrix is valid if every row and every column contains all the integers from 1 to n (inclusive).\nGiven an n x n integer matrix matrix, return true if the matrix is valid. Otherwise, return false.",
        "examples": [
            "Input: matrix = [[1,2,3],[3,1,2],[2,3,1]]\nOutput: true\nExplanation: In this case, n = 3, and every row and column contains the numbers 1, 2, and 3.\nHence, we return true.",
            "Input: matrix = [[1,1,1],[1,2,3],[1,2,3]]\nOutput: false\nExplanation: In this case, n = 3, but the first row and the first column do not contain the numbers 2 or 3.\nHence, we return false."
        ],
        "constraints": "n == matrix.length == matrix[i].length\n1 <= n <= 100\n1 <= matrix[i][j] <= n",
        "oracle_code": "class Solution:\n    def checkValid(self, matrix: List[List[int]]) -> bool:\n\n        dp_col = [[False for _ in range(len(matrix[0]))] for _ in range(len(matrix))]\n        dp_row = [[False for _ in range(len(matrix[0]))] for _ in range(len(matrix))]\n\n        for i in range(len(matrix)):\n            for j in range(len(matrix[0])):\n                if dp_row[i][matrix[i][j]-1] or dp_col[j][matrix[i][j]-1]:\n                    return False\n                dp_row[i][matrix[i][j]-1] = True\n                dp_col[j][matrix[i][j]-1] = True\n        return True",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def checkValid(self, matrix: List[List[int]]) -> bool:\\n\\n        dp_col = [[False for _ in range(len(matrix[0]))] for _ in range(len(matrix))]\\n        dp_row = [[False for _ in range(len(matrix[0]))] for _ in range(len(matrix))]\\n\\n        for i in range(len(matrix)):\\n            for j in range(len(matrix[0])):\\n                if dp_row[i][matrix[i][j]-1] or dp_col[j][matrix[i][j]-1]:\\n                    return False\\n                dp_row[i][matrix[i][j]-1] = True\\n                dp_col[j][matrix[i][j]-1] = True\\n        return True\\n\\n\\n```",
        "level": "easy",
        "type": [
            "undefined methods",
            "variable value error",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def checkValid(self, matrix: List[List[int]]) -> bool:\n\n        dp_col = [[False for _ in range(len(matrix[0]))] for _ in range(len(matrix))]\n        dp_row = [[False for _ in range(len(matrix[0]))] for _ in range(len(matrix))]\n        \n        self.helper(matrix, dp_row, dp_col)\n\n    def helper(self, matrix, dp_row, dp_col):\n        for i in range(len(matrix)):\n            for j in range(len(matrix[0])):\n                if dp_row[i][j] or dp_col[i][j]:\n                    return False\n                dp_row[i][j] = True\n                dp_col[i][j] = True\n        return True\n\n\n"
    },
    {
        "slug": "valid-permutations-for-di-sequence",
        "description": "You are given a string s of length n where s[i] is either:\n\n'D' means decreasing, or\n'I' means increasing.\n\nA permutation perm of n + 1 integers of all the integers in the range [0, n] is called a valid permutation if for all valid i:\n\nIf s[i] == 'D', then perm[i] > perm[i + 1], and\nIf s[i] == 'I', then perm[i] < perm[i + 1].\n\nReturn the number of valid permutations perm. Since the answer may be large, return it modulo 109 + 7.",
        "examples": [
            "Input: s = \"DID\"\nOutput: 5\nExplanation: The 5 valid permutations of (0, 1, 2, 3) are:\n(1, 0, 3, 2)\n(2, 0, 3, 1)\n(2, 1, 3, 0)\n(3, 0, 2, 1)\n(3, 1, 2, 0)",
            "Input: s = \"D\"\nOutput: 1"
        ],
        "constraints": "n == s.length\n1 <= n <= 200\ns[i] is either 'I' or 'D'.",
        "oracle_code": "class Solution:\n    def numPermsDISequence(self, s: str) -> int:\n        mem=defaultdict(int)\n        def dfs(i,val=0):\n            if i==len(s):\n                return 1\n            if (i,val) in mem:\n                return mem[i,val]\n            p=0\n            if s[i]==\"D\":\n                for ind in range(0,val+1):\n                    p+=dfs(i+1,ind)%(10**9+7)\n            else:\n                for ind in range(val+1,i+2):\n                    p+=dfs(i+1,ind)%(10**9+7)\n            mem[i,val]=p\n            return p\n        return dfs(0)",
        "content": "To add a new character to a sequence we only have to consider the last element-\\n\\nLets say currently DID sequence is 1032- this can form\\n\\nDIDI - in cases where we end with 3,4\\nDIDD - in cases where we end with 0,1,2\\n\\nSo just use the last element value to create a new sequence.\\n\\n```\\nclass Solution:\\n    def numPermsDISequence(self, s: str) -> int:\\n        mem=defaultdict(int)\\n        def dfs(i,val=0):\\n            if i==len(s):\\n                return 1\\n            if (i,val) in mem:\\n                return mem[i,val]\\n            p=0\\n            if s[i]==\"D\":\\n                for ind in range(0,val+1):\\n                    p+=dfs(i+1,ind)%(10**9+7)\\n            else:\\n                for ind in range(val+1,i+2):\\n                    p+=dfs(i+1,ind)%(10**9+7)\\n            mem[i,val]=p\\n            return p\\n        return dfs(0)\\n ```\\n\\t\\t\\t\\t",
        "level": "hard",
        "type": [
            "colon missing",
            "unclosed string",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def numPermsDISequence(self, s: str) -> int:\n        mem=defaultdict(int)\n        def dfs(i,val=0):\n            if i==len(s):\n                return 1\n            if (i,val) in mem\n                return mem[i,val]\n            p=0\n            if s[i]==\"D:\n                for ind in range(0,val+2): \n                    p+=dfs(i+1,ind)%(10**9+7)\n            else:\n                for ind in range(val+1,i+3): \n                    p+=dfs(i+1,ind)%(10**9+7)\n            mem[i,val]=p\n            return p\n        return dfs(0)\n"
    },
    {
        "slug": "valid-arrangement-of-pairs",
        "description": "You are given a 0-indexed 2D integer array pairs where pairs[i] = [starti, endi]. An arrangement of pairs is valid if for every index i where 1 <= i < pairs.length, we have endi-1 == starti.\nReturn any valid arrangement of pairs.\nNote: The inputs will be generated such that there exists a valid arrangement of pairs.",
        "examples": [
            "Input: pairs = [[5,1],[4,5],[11,9],[9,4]]\nOutput: [[11,9],[9,4],[4,5],[5,1]]\nExplanation:\nThis is a valid arrangement since endi-1 always equals starti.\nend0 = 9 == 9 = start1 \nend1 = 4 == 4 = start2\nend2 = 5 == 5 = start3",
            "Input: pairs = [[1,3],[3,2],[2,1]]\nOutput: [[1,3],[3,2],[2,1]]\nExplanation:\nThis is a valid arrangement since endi-1 always equals starti.\nend0 = 3 == 3 = start1\nend1 = 2 == 2 = start2\nThe arrangements [[2,1],[1,3],[3,2]] and [[3,2],[2,1],[1,3]] are also valid.",
            "Input: pairs = [[1,2],[1,3],[2,1]]\nOutput: [[1,2],[2,1],[1,3]]\nExplanation:\nThis is a valid arrangement since endi-1 always equals starti.\nend0 = 2 == 2 = start1\nend1 = 1 == 1 = start2"
        ],
        "constraints": "1 <= pairs.length <= 105\npairs[i].length == 2\n0 <= starti, endi <= 109\nstarti != endi\nNo two pairs are exactly the same.\nThere exists a valid arrangement of pairs.",
        "oracle_code": "class Solution:\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\n        graph = defaultdict(list)\n        degree = defaultdict(int) # net out degree \n        for x, y in pairs: \n            graph[x].append(y)\n            degree[x] += 1\n            degree[y] -= 1\n                \n        for k in degree: \n            if degree[k] == 1: \n                x = k\n                break \n                \n        ans = []\n\n        def fn(x): \n            \"\"\"Return Eulerian path via dfs.\"\"\"\n            while graph[x]: fn(graph[x].pop()) \n            ans.append(x)\n        \n        fn(x)\n        ans.reverse()\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]",
        "content": "Please check out this [commit](https://github.com/gaosanyong/leetcode/commit/b1948f8814bebeca475cbb354cd44d19092dff59) for solutions of weekly 270.\\n\\n```\\nclass Solution:\\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\\n        graph = defaultdict(list)\\n        degree = defaultdict(int) # net out degree \\n        for x, y in pairs: \\n            graph[x].append(y)\\n            degree[x] += 1\\n            degree[y] -= 1\\n                \\n        for k in degree: \\n            if degree[k] == 1: \\n                x = k\\n                break \\n                \\n        ans = []\\n\\n        def fn(x): \\n            \"\"\"Return Eulerian path via dfs.\"\"\"\\n            while graph[x]: fn(graph[x].pop()) \\n            ans.append(x)\\n        \\n        fn(x)\\n        ans.reverse()\\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]\\n```\\n\\nAdding an iterative implementation of Hieholzer\\'s algo from @delphih\\n```\\nclass Solution:\\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\\n        graph = defaultdict(list)\\n        degree = defaultdict(int) # net out degree \\n        for x, y in pairs: \\n            graph[x].append(y)\\n            degree[x] += 1\\n            degree[y] -= 1\\n                \\n        for k in degree: \\n            if degree[k] == 1: \\n                x = k\\n                break \\n                \\n        ans = []\\n        stack = [x]\\n        while stack: \\n            while graph[stack[-1]]: \\n                stack.append(graph[stack[-1]].pop())\\n            ans.append(stack.pop())\\n        ans.reverse()\\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]\\n```",
        "level": "hard",
        "type": [
            "parentheses mismatch",
            "== and = confusion",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\n        graph = defaultdict(list)\n        degree = defaultdict(int) # net out degree \n        for x, y in pairs: \n            graph[x].append(y)\n            degree[x] += 1\n            degree[y] -= 1\n                \n        for k in degree: \n            if degree[k] != 1: \n                x = k\n                break \n                \n        ans = []\n\n        def fn(x): \n            \"\"\"Return Eulerian path via dfs.\"\"\"\n            while graph[x]: fn(graph[x].pop()) \n            ans.append(x)\n        \n        fn(x\n        ans.reverse()\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]\n"
    },
    {
        "slug": "length-of-the-longest-valid-substring",
        "description": "You are given a string word and an array of strings forbidden.\nA string is called valid if none of its substrings are present in forbidden.\nReturn the length of the longest valid substring of the string word.\nA substring is a contiguous sequence of characters in a string, possibly empty.",
        "examples": [
            "Input: word = \"cbaaaabc\", forbidden = [\"aaa\",\"cb\"]\nOutput: 4\nExplanation: There are 11 valid substrings in word: \"c\", \"b\", \"a\", \"ba\", \"aa\", \"bc\", \"baa\", \"aab\", \"ab\", \"abc\"and \"aabc\". The length of the longest valid substring is 4. \nIt can be shown that all other substrings contain either \"aaa\" or \"cb\" as a substring.",
            "Input: word = \"leetcode\", forbidden = [\"de\",\"le\",\"e\"]\nOutput: 4\nExplanation: There are 11 valid substrings in word: \"l\", \"t\", \"c\", \"o\", \"d\", \"tc\", \"co\", \"od\", \"tco\", \"cod\", and \"tcod\". The length of the longest valid substring is 4.\nIt can be shown that all other substrings contain either \"de\", \"le\", or \"e\" as a substring."
        ],
        "constraints": "1 <= word.length <= 105\nword consists only of lowercase English letters.\n1 <= forbidden.length <= 105\n1 <= forbidden[i].length <= 10\nforbidden[i] consists only of lowercase English letters.",
        "oracle_code": "class Solution:\n    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int:\n        trie = {}\n        for f in forbidden:\n            t = trie\n            for c in f:\n                if c not in t:\n                    t[c] = {}\n                t = t[c]\n            t[\"end\"] = True\n        \n        def isForbidden(s):\n            t = trie\n            counter = 0\n            for c in s:\n                if c not in t:\n                    return False\n                t = t[c]\n                counter += 1\n                if \"end\" in t:\n                    return counter\n            return False\n        \n        res = 0\n        j = len(word)\n        for i in range(len(word) - 1, -1, -1):\n            truc = isForbidden(word[i:j])\n            if truc:\n                j = i + truc - 1\n            res = max(res, j - i)\n        return res",
        "content": "Put all the forbidden strings into a trie, so that for each string `s`, we can check every substring starts from the beginning (i.e. `s[:1]`,  `s[:2]` ...  `s[:len(s)]`) in one travesal.\\n\\nUse a sliding window to iterate from back to front, each time, we only need to check whether the substrings starting from the new character is forbidden. If the substring is forbidden, then we truncate the string and continue to search.\\n\\nUsing a trie can make the foibidden check fails faster and can deal with longer foibidden strings.\\n\\n# Code\\n```\\nclass Solution:\\n    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int:\\n        trie = {}\\n        for f in forbidden:\\n            t = trie\\n            for c in f:\\n                if c not in t:\\n                    t[c] = {}\\n                t = t[c]\\n            t[\"end\"] = True\\n        \\n        def isForbidden(s):\\n            t = trie\\n            counter = 0\\n            for c in s:\\n                if c not in t:\\n                    return False\\n                t = t[c]\\n                counter += 1\\n                if \"end\" in t:\\n                    return counter\\n            return False\\n        \\n        res = 0\\n        j = len(word)\\n        for i in range(len(word) - 1, -1, -1):\\n            truc = isForbidden(word[i:j])\\n            if truc:\\n                j = i + truc - 1\\n            res = max(res, j - i)\\n        return res\\n```",
        "level": "hard",
        "type": [
            "operation error",
            "wrong comment mark",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int:\n        trie = {}\n        for f in forbidden:\n            t = trie\n            for c in f:\n                if c not in t:\n                    t[c] = {}\n                t = t[c]\n            t[\"end\"] = True\n        \n        def isForbidden(s):\n            t = trie\n            counter = 0\n            for c in s:\n                if c not in t:\n                    //return False\n                t = t[c]\n                counter += 1\n                if \"end\" in t:\n                    return counter\n            return False\n        \n        res = 0\n        j = len(word) + 1\n        for i in range(len(word) - 1, -1, -1):\n            truc = isForbidden(word[i:j])\n            if truc:\n                j = i - truc - 1\n            res = max(res, j - i)\n        return res\n"
    },
    {
        "slug": "number-of-ways-of-cutting-a-pizza",
        "description": "Given a rectangular pizza represented as a rows x cols\u00a0matrix containing the following characters: 'A' (an apple) and '.' (empty cell) and given the integer k. You have to cut the pizza into k pieces using k-1 cuts.\u00a0\nFor each cut you choose the direction: vertical or horizontal, then you choose a cut position at the cell boundary and cut the pizza into two pieces. If you cut the pizza vertically, give the left part of the pizza to a person. If you cut the pizza horizontally, give the upper part of the pizza to a person. Give the last piece of pizza to the last person.\nReturn the number of ways of cutting the pizza such that each piece contains at least one apple.\u00a0Since the answer can be a huge number, return this modulo 10^9 + 7.",
        "examples": [
            "Input: pizza = [\"A..\",\"AAA\",\"...\"], k = 3\nOutput: 3 \nExplanation: The figure above shows the three ways to cut the pizza. Note that pieces must contain at least one apple.",
            "Input: pizza = [\"A..\",\"AA.\",\"...\"], k = 3\nOutput: 1",
            "Input: pizza = [\"A..\",\"A..\",\"...\"], k = 1\nOutput: 1"
        ],
        "constraints": "1 <= rows, cols <= 50\nrows ==\u00a0pizza.length\ncols ==\u00a0pizza[i].length\n1 <= k <= 10\npizza consists of characters 'A'\u00a0and '.' only.",
        "oracle_code": "class Solution:\n    def ways(self, pizza: List[str], k: int) -> int:\n        self.r = len(pizza)\n        self.c = len(pizza[0])\n        \n        # Step 1, pre-process the apple array and get the prefix sum\n        tot_apples = 0\n        self.pfsum_row = []\n        self.pfsum_col = []\n        \n        for i in range(self.r):\n            pfr = 0\n            pfs_r = [0] * self.c\n            pfs_c = [0] * self.c\n            for j in range(self.c):\n                if i > 0:\n                    pfs_c[j] += self.pfsum_col[i - 1][j]\n                if pizza[i][j] == 'A':\n                    pfr += 1\n                    pfs_c[j] += 1\n                    tot_apples += 1\n                pfs_r[j] = pfr\n            self.pfsum_row.append(pfs_r)\n            self.pfsum_col.append(pfs_c)\n        \n        if tot_apples < k:\n            return 0\n        \n        if k == 1:\n            return 1\n        \n        return self.getWays(0, 0, k) % (1000000007)\n    \n    \n    @cache\n    def getWays(self, i, j, k):\n        if k == 1:\n            # if only left one piece for cutting, we just need to check if there is any apple in the region\n            found = False\n            for c in range(j, self.c):\n                apple_in_region = self.pfsum_col[self.r - 1][c]\n                if i > 0:\n                     apple_in_region -= self.pfsum_col[i - 1][c]\n                if apple_in_region:\n                    found = True\n                    break\n            if found:\n                return 1\n            return 0\n        else:\n            # horizontally cut\n            cannot_cut = True\n            nr = i\n            t_cnt = 0\n            while nr < self.r - 1:\n                # find the first row that we can start cutting\n                while nr < self.r - 1 and cannot_cut:\n                    apple_in_region = self.pfsum_row[nr][self.c - 1]\n                    if j > 0:\n                        apple_in_region -= self.pfsum_row[nr][j - 1]\n                    if apple_in_region:\n                        cannot_cut = False\n                    else:\n                        nr += 1\n                        \n                if nr < self.r - 1:\n                    t_cnt += self.getWays(nr + 1, j, k - 1)\n                nr += 1\n                \n            # vertically cut\n            cannot_cut = True\n            nc = j\n            while nc < self.c - 1:\n                # find the first col that we can start cutting\n                while nc < self. c - 1 and cannot_cut:\n                    apple_in_region = self.pfsum_col[self.r - 1][nc]\n                    if i > 0:\n                        apple_in_region -= self.pfsum_col[i - 1][nc]\n                    if apple_in_region:\n                        cannot_cut = False\n                    else:\n                        nc += 1\n                \n                if nc < self.c - 1:\n                    t_cnt += self.getWays(i, nc + 1, k - 1)\n                nc += 1\n            \n            return t_cnt",
        "content": "The key to this problem is how to count the number of apples on the region we want to cut.\\n\\nWe can simply use the prefix sum that help to identify the number of apples between any two index.\\n\\nTherefore, we need to pre-process the input array, get the prefix sum horizatonally and vertically.\\n\\nWith the prefix sum array, we can create a dp funtion that get the number of cuts in the region (i, j) to (row - 1, col - 1)\\n\\n\\n```\\nclass Solution:\\n    def ways(self, pizza: List[str], k: int) -> int:\\n        self.r = len(pizza)\\n        self.c = len(pizza[0])\\n        \\n        # Step 1, pre-process the apple array and get the prefix sum\\n        tot_apples = 0\\n        self.pfsum_row = []\\n        self.pfsum_col = []\\n        \\n        for i in range(self.r):\\n            pfr = 0\\n            pfs_r = [0] * self.c\\n            pfs_c = [0] * self.c\\n            for j in range(self.c):\\n                if i > 0:\\n                    pfs_c[j] += self.pfsum_col[i - 1][j]\\n                if pizza[i][j] == \\'A\\':\\n                    pfr += 1\\n                    pfs_c[j] += 1\\n                    tot_apples += 1\\n                pfs_r[j] = pfr\\n            self.pfsum_row.append(pfs_r)\\n            self.pfsum_col.append(pfs_c)\\n        \\n        if tot_apples < k:\\n            return 0\\n        \\n        if k == 1:\\n            return 1\\n        \\n        return self.getWays(0, 0, k) % (1000000007)\\n    \\n    \\n    @cache\\n    def getWays(self, i, j, k):\\n        if k == 1:\\n            # if only left one piece for cutting, we just need to check if there is any apple in the region\\n            found = False\\n            for c in range(j, self.c):\\n                apple_in_region = self.pfsum_col[self.r - 1][c]\\n                if i > 0:\\n                     apple_in_region -= self.pfsum_col[i - 1][c]\\n                if apple_in_region:\\n                    found = True\\n                    break\\n            if found:\\n                return 1\\n            return 0\\n        else:\\n            # horizontally cut\\n            cannot_cut = True\\n            nr = i\\n            t_cnt = 0\\n            while nr < self.r - 1:\\n                # find the first row that we can start cutting\\n                while nr < self.r - 1 and cannot_cut:\\n                    apple_in_region = self.pfsum_row[nr][self.c - 1]\\n                    if j > 0:\\n                        apple_in_region -= self.pfsum_row[nr][j - 1]\\n                    if apple_in_region:\\n                        cannot_cut = False\\n                    else:\\n                        nr += 1\\n                        \\n                if nr < self.r - 1:\\n                    t_cnt += self.getWays(nr + 1, j, k - 1)\\n                nr += 1\\n                \\n            # vertically cut\\n            cannot_cut = True\\n            nc = j\\n            while nc < self.c - 1:\\n                # find the first col that we can start cutting\\n                while nc < self. c - 1 and cannot_cut:\\n                    apple_in_region = self.pfsum_col[self.r - 1][nc]\\n                    if i > 0:\\n                        apple_in_region -= self.pfsum_col[i - 1][nc]\\n                    if apple_in_region:\\n                        cannot_cut = False\\n                    else:\\n                        nc += 1\\n                \\n                if nc < self.c - 1:\\n                    t_cnt += self.getWays(i, nc + 1, k - 1)\\n                nc += 1\\n            \\n            return t_cnt\\n\\n```",
        "level": "hard",
        "type": [
            "undefined keywords from other languages",
            "== and = confusion",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def ways(self, pizza: List[str], k: int) -> int:\n        self.r = len(pizza)\n        self.c = len(pizza[0])\n        \n        tot_apples = 0\n        self.pfsum_row = []\n        self.pfsum_col = []\n        \n        for i in range(self.r):\n            pfr = 0\n            pfs_r = [0] * self.c\n            pfs_c = [0] * self.c\n            for j in range(self.c):\n                if i > 0:\n                    pfs_c[j] += self.pfsum_col[i - 1][j]\n                if pizza[i][j] == 'A':\n                    pfr += 1\n                    pfs_c[j] += 1\n                    tot_apples += 1\n                pfs_r[j] = pfr\n            self.pfsum_row.append(pfs_r)\n            self.pfsum_col.append(pfs_c)\n        \n        if tot_apples < k:\n            return 0\n        \n        if k = 1:\n            return 1\n        \n        return self.getWays(0, 0, k - 2) % (1000000007)\n    \n    \n    @cache\n    def getWays(self, i, j, k):\n        if k == 1:\n            found = False\n            for c in range(j, this.c):\n                apple_in_region = this.pfsum_col[this.r - 1][c]\n                if i > 0:\n                     apple_in_region -= this.pfsum_col[i - 1][c]\n                if apple_in_region:\n                    found = True\n                    break\n            if found:\n                return 1\n            return 0\n        else:\n            cannot_cut = True\n            nr = i\n            t_cnt = 0\n            while nr < this.r - 1:\n                while nr < this.r - 1 and cannot_cut:\n                    apple_in_region = this.pfsum_row[nr][this.c - 1]\n                    if j > 0:\n                        apple_in_region -= this.pfsum_row[nr][j - 1]\n                    if apple_in_region:\n                        cannot_cut = False\n                    else:\n                        nr += 1\n                        \n                if nr < this.r - 1:\n                    t_cnt += this.getWays(nr + 1, j, k - 1)\n                nr += 1\n                \n            cannot_cut = True\n            nc = j\n            while nc < this.c - 1:\n                while nc < this.c - 1 and cannot_cut:\n                    apple_in_region = this.pfsum_col[this.r - 1][nc]\n                    if i > 0:\n                        apple_in_region -= this.pfsum_col[i - 1][nc]\n                    if apple_in_region:\n                        cannot_cut = False\n                    else:\n                        nc += 1\n                \n                if nc < this.c - 1:\n                    t_cnt += this.getWays(i, nc + 1, k - 1)\n                nc += 1\n            \n            return t_cnt\n"
    },
    {
        "slug": "check-if-two-string-arrays-are-equivalent",
        "description": "Given two string arrays word1 and word2, return true if the two arrays represent the same string, and false otherwise.\nA string is represented by an array if the array elements concatenated in order forms the string.",
        "examples": [
            "Input: word1 = [\"ab\", \"c\"], word2 = [\"a\", \"bc\"]\nOutput: true\nExplanation:\nword1 represents string \"ab\" + \"c\" -> \"abc\"\nword2 represents string \"a\" + \"bc\" -> \"abc\"\nThe strings are the same, so return true.",
            "Input: word1 = [\"a\", \"cb\"], word2 = [\"ab\", \"c\"]\nOutput: false",
            "Input: word1  = [\"abc\", \"d\", \"defg\"], word2 = [\"abcddefg\"]\nOutput: true"
        ],
        "constraints": "1 <= word1.length, word2.length <= 103\n1 <= word1[i].length, word2[i].length <= 103\n1 <= sum(word1[i].length), sum(word2[i].length) <= 103\nword1[i] and word2[i] consist of lowercase letters.",
        "oracle_code": "class Solution:\n    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) -> bool:\n        word3=\"\".join(word1)\n        word4=\"\".join(word2)\n        if word3==word4:\n            return True\n        else:\n            return False",
        "content": "**1**.First we will join the contents or concatenate the Strings present in the list using join()\\n**2**.then compare 2 list.\\n**3** if true return true else return false\\n```\\nclass Solution:\\n    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) -> bool:\\n        word3=\"\".join(word1)\\n        word4=\"\".join(word2)\\n        if word3==word4:\\n            return True\\n        else:\\n            return False\\n```\\n**code**\\nOnline Solution :\\n    -Thank you for this solution @jeevabharathiS\\n        \\n```\\nclass Solution:\\n    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) \\n        return((\"\".join(word1))==(\"\".join(word2)))\\n```",
        "level": "easy",
        "type": [
            "undefined methods",
            "parentheses mismatch",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution:\n    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) -> bool:\n        word3 = self.concat(word1\n        word4 = self.concat(word2\n        if word3 == word4:\n            return True\n        else:\n            return False\n"
    },
    {
        "slug": "find-words-that-can-be-formed-by-characters",
        "description": "You are given an array of strings words and a string chars.\nA string is good if it can be formed by characters from chars (each character can only be used once).\nReturn the sum of lengths of all good strings in words.",
        "examples": [
            "Input: words = [\"cat\",\"bt\",\"hat\",\"tree\"], chars = \"atach\"\nOutput: 6\nExplanation: The strings that can be formed are \"cat\" and \"hat\" so the answer is 3 + 3 = 6.",
            "Input: words = [\"hello\",\"world\",\"leetcode\"], chars = \"welldonehoneyr\"\nOutput: 10\nExplanation: The strings that can be formed are \"hello\" and \"world\" so the answer is 5 + 5 = 10."
        ],
        "constraints": "1 <= words.length <= 1000\n1 <= words[i].length, chars.length <= 100\nwords[i] and chars consist of lowercase English letters.",
        "oracle_code": "class Solution:\n    def countCharacters(self, words: List[str], chars: str) -> int:\n        ans=[]\n        d1=Counter(chars)\n        for i in range(len(words)):\n            w=[j for j in words[i]]\n            d2=Counter(w)\n        #print(dc)\n        #print(dw)\n            if all([k in d1 for k in d2]) and all([d2[k]<=d1[k] for k in d2]):\n                ans.append(len(w))\n        return sum(ans)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countCharacters(self, words: List[str], chars: str) -> int:\\n        ans=[]\\n        d1=Counter(chars)\\n        for i in range(len(words)):\\n            w=[j for j in words[i]]\\n            d2=Counter(w)\\n        #print(dc)\\n        #print(dw)\\n            if all([k in d1 for k in d2]) and all([d2[k]<=d1[k] for k in d2]):\\n                ans.append(len(w))\\n        return sum(ans)\\n       \\n```",
        "level": "easy",
        "type": [
            "indentation error",
            "wrong comment mark",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\ndef countCharacters(self, words: List[str], chars: str) -> int:\n    ans=[]\n    d1=Counter(chars)\n    /*for i in range(len(words)+1):\n        w=[j for j in words[i]]\n        d2=Counter(w)\n    \n    \n        if all([k in d1 for k in d2]) and all([d2[k]<=d1[k] for k in d2]):\n            ans.append(len(w))*/\n    return sum(ans)\n"
    },
    {
        "slug": "length-of-the-longest-valid-substring",
        "description": "You are given a string word and an array of strings forbidden.\nA string is called valid if none of its substrings are present in forbidden.\nReturn the length of the longest valid substring of the string word.\nA substring is a contiguous sequence of characters in a string, possibly empty.",
        "examples": [
            "Input: word = \"cbaaaabc\", forbidden = [\"aaa\",\"cb\"]\nOutput: 4\nExplanation: There are 11 valid substrings in word: \"c\", \"b\", \"a\", \"ba\", \"aa\", \"bc\", \"baa\", \"aab\", \"ab\", \"abc\"and \"aabc\". The length of the longest valid substring is 4. \nIt can be shown that all other substrings contain either \"aaa\" or \"cb\" as a substring.",
            "Input: word = \"leetcode\", forbidden = [\"de\",\"le\",\"e\"]\nOutput: 4\nExplanation: There are 11 valid substrings in word: \"l\", \"t\", \"c\", \"o\", \"d\", \"tc\", \"co\", \"od\", \"tco\", \"cod\", and \"tcod\". The length of the longest valid substring is 4.\nIt can be shown that all other substrings contain either \"de\", \"le\", or \"e\" as a substring."
        ],
        "constraints": "1 <= word.length <= 105\nword consists only of lowercase English letters.\n1 <= forbidden.length <= 105\n1 <= forbidden[i].length <= 10\nforbidden[i] consists only of lowercase English letters.",
        "oracle_code": "class Solution:\n    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int:\n        trie = {}\n        for f in forbidden:\n            t = trie\n            for c in f:\n                if c not in t:\n                    t[c] = {}\n                t = t[c]\n            t[\"end\"] = True\n        \n        def isForbidden(s):\n            t = trie\n            counter = 0\n            for c in s:\n                if c not in t:\n                    return False\n                t = t[c]\n                counter += 1\n                if \"end\" in t:\n                    return counter\n            return False\n        \n        res = 0\n        j = len(word)\n        for i in range(len(word) - 1, -1, -1):\n            truc = isForbidden(word[i:j])\n            if truc:\n                j = i + truc - 1\n            res = max(res, j - i)\n        return res",
        "content": "Put all the forbidden strings into a trie, so that for each string `s`, we can check every substring starts from the beginning (i.e. `s[:1]`,  `s[:2]` ...  `s[:len(s)]`) in one travesal.\\n\\nUse a sliding window to iterate from back to front, each time, we only need to check whether the substrings starting from the new character is forbidden. If the substring is forbidden, then we truncate the string and continue to search.\\n\\nUsing a trie can make the foibidden check fails faster and can deal with longer foibidden strings.\\n\\n# Code\\n```\\nclass Solution:\\n    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int:\\n        trie = {}\\n        for f in forbidden:\\n            t = trie\\n            for c in f:\\n                if c not in t:\\n                    t[c] = {}\\n                t = t[c]\\n            t[\"end\"] = True\\n        \\n        def isForbidden(s):\\n            t = trie\\n            counter = 0\\n            for c in s:\\n                if c not in t:\\n                    return False\\n                t = t[c]\\n                counter += 1\\n                if \"end\" in t:\\n                    return counter\\n            return False\\n        \\n        res = 0\\n        j = len(word)\\n        for i in range(len(word) - 1, -1, -1):\\n            truc = isForbidden(word[i:j])\\n            if truc:\\n                j = i + truc - 1\\n            res = max(res, j - i)\\n        return res\\n```",
        "level": "hard",
        "type": [
            "undefined methods",
            "wrong comment mark",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int:\n        trie = {}\n        for f in forbidden:\n            t = trie\n            for c in f:\n                if c not in t:\n                    t[c] = {}\n                t = t[c]\n            t[\"end\"] = True\n        \n        def isForbidden(s):\n            t = trie\n            counter = 0\n            for c in s:\n                if c not in t:\n                    //return False\n                t = t[c]\n                counter += 1\n                if \"end\" in t:\n                    return counter\n            return False\n        \n        res = 0\n        j = len(word) + 1\n        for i in range(len(word) - 1, -1, -1):\n            truc = isForbidden(word[i:j])\n            if truc:\n                j = i + truc - 1\n                undefinedFunction(word)\n            res = max(res, j - i)\n        return res\n"
    },
    {
        "slug": "lexicographically-smallest-string-after-substring-operation",
        "description": "You are given a string s consisting of only lowercase English letters. In one operation, you can do the following:\n\nSelect any non-empty substring of s, possibly the entire string, then replace each one of its characters with the previous character of the English alphabet. For example, 'b' is converted to 'a', and 'a' is converted to 'z'.\n\nReturn the lexicographically smallest string you can obtain after performing the above operation exactly once.\nA substring is a contiguous sequence of characters in a string.\nA string x is lexicographically smaller than a string y of the same length if x[i] comes before y[i] in alphabetic order for the first position i such that x[i] != y[i].",
        "examples": [
            "Input: s = \"cbabc\"\nOutput: \"baabc\"\nExplanation: We apply the operation on the substring starting at index 0, and ending at index 1 inclusive. \nIt can be proven that the resulting string is the lexicographically smallest.",
            "Input: s = \"acbbc\"\nOutput: \"abaab\"\nExplanation: We apply the operation on the substring starting at index 1, and ending at index 4 inclusive. \nIt can be proven that the resulting string is the lexicographically smallest.",
            "Input: s = \"leetcode\"\nOutput: \"kddsbncd\"\nExplanation: We apply the operation on the entire string. \nIt can be proven that the resulting string is the lexicographically smallest."
        ],
        "constraints": "1 <= s.length <= 3 * 105\ns consists of lowercase English letters",
        "oracle_code": "class Solution:\n    def smallestString(self, s: str) -> str:\n        \n        if len(check:=set(s))==1 and check != {'a'}: \n            return chr(ord(s[0])-1)*(len(s))              # zzzz > yyyy , aaaa -X-> zzzz\n        contiguous,change,ct1,ct2 = True,False,0,0\n\n        for i in s:                                       # deal with begin string = 'aaaa....', speed up the traversal speed.\n            if i == 'a':ct1+=1                                                  \n            else:break\n        ans='' + 'a' * ct1\n        s = s[ct1:]\n     \n        for cha in s:\n            ct2+=1\n            if cha != 'a':\n                ans+=chr(ord(cha)-1)\n                change=True                               # record operation at least once.\n                continue\n            else:\n                ans+=cha                                  # because 'a' can't converted to 'z'\n                if change:                                # once the change has been made, you can stop when you encounter 'a'\n                    contiguous = False\n            if not contiguous:                            # then break , add the remaining string to the end of the ans.\n                break\n        return ans+s[ct2:] if change else ans[:-1]+'z'    # check if it consists entirely of the letter \"a.\"  'aaaa' > 'aaaz'",
        "content": "![image.png](https://assets.leetcode.com/users/images/87e1aa4c-6441-4d67-b2fb-846fc3897b29_1687376176.900977.png)\\n\\n\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def smallestString(self, s: str) -> str:\\n        \\n        if len(check:=set(s))==1 and check != {\\'a\\'}: \\n            return chr(ord(s[0])-1)*(len(s))              # zzzz > yyyy , aaaa -X-> zzzz\\n        contiguous,change,ct1,ct2 = True,False,0,0\\n\\n        for i in s:                                       # deal with begin string = \\'aaaa....\\', speed up the traversal speed.\\n            if i == \\'a\\':ct1+=1                                                  \\n            else:break\\n        ans=\\'\\' + \\'a\\' * ct1\\n        s = s[ct1:]\\n     \\n        for cha in s:\\n            ct2+=1\\n            if cha != \\'a\\':\\n                ans+=chr(ord(cha)-1)\\n                change=True                               # record operation at least once.\\n                continue\\n            else:\\n                ans+=cha                                  # because \\'a\\' can\\'t converted to \\'z\\'\\n                if change:                                # once the change has been made, you can stop when you encounter \\'a\\'\\n                    contiguous = False\\n            if not contiguous:                            # then break , add the remaining string to the end of the ans.\\n                break\\n        return ans+s[ct2:] if change else ans[:-1]+\\'z\\'    # check if it consists entirely of the letter \"a.\"  \\'aaaa\\' > \\'aaaz\\'\\n```\\n\\nMy English may not be very good, but I hope I can still assist you. :>\\n\\n\\n\\n\\n",
        "level": "medium",
        "type": [
            "undefined methods",
            "unclosed string",
            "wrong comment mark"
        ],
        "buggy_code": "\nclass Solution:\n    def smallestString(self, s: str) -> str:\n        \n        if len(check:=set(s))==1 and check != \"{'a'}\": \n        \n        contiguous,change,ct1,ct2 = True,False,0,0\n\n        for i in s:                                       \n            if i == 'a':ct1+=1                                                  \n            else:break\n        ans='' + 'a' * ct1\n        s = s[ct1:]\n     \n        for cha in s:\n            ct2+=1\n            if cha != 'a':\n                ans+=chr(ord(cha)-1)\n                change=True                               \n                continue\n            else:\n                ans+=cha                                  \n                if change:                                \n                    contiguous = False\n            if nocontiou\n               ntinue\n            else:\n                ans+=cha                                  \n                if change:                                \n                    contiguous = False\n            if not contiguous:                            \n                beak\n        return ans+s[ct2:] if change else Unfc(ans[:-1]+'z')    \n"
    },
    {
        "slug": "moving-stones-until-consecutive-ii",
        "description": "There are some stones in different positions on the X-axis. You are given an integer array stones, the positions of the stones.\nCall a stone an endpoint stone if it has the smallest or largest position. In one move, you pick up an endpoint stone and move it to an unoccupied position so that it is no longer an endpoint stone.\n\nIn particular, if the stones are at say, stones = [1,2,5], you cannot move the endpoint stone at position 5, since moving it to any position (such as 0, or 3) will still keep that stone as an endpoint stone.\n\nThe game ends when you cannot make any more moves (i.e., the stones are in three consecutive positions).\nReturn an integer array answer of length 2 where:\n\nanswer[0] is the minimum number of moves you can play, and\nanswer[1] is the maximum number of moves you can play.",
        "examples": [
            "Input: stones = [7,4,9]\nOutput: [1,2]\nExplanation: We can move 4 -> 8 for one move to finish the game.\nOr, we can move 9 -> 5, 4 -> 6 for two moves to finish the game.",
            "Input: stones = [6,5,4,3,10]\nOutput: [2,3]\nExplanation: We can move 3 -> 8 then 10 -> 7 to finish the game.\nOr, we can move 3 -> 7, 4 -> 8, 5 -> 9 to finish the game.\nNotice we cannot move 10 -> 2 to finish the game, because that would be an illegal move."
        ],
        "constraints": "3 <= stones.length <= 104\n1 <= stones[i] <= 109\nAll the values of stones are unique.",
        "oracle_code": "class Solution:\n    '''\n        Test cases walk through \n        Given 7, 4, 9 prove 1, 2                                                            6, 5, 4, 3, 10, prove 2, 3 \n\n        Sort stones -> 4, 7, 9                                                              3, 4, 5, 6, 10 \n        Stone length -> 3                                                                   5\n        Move penultimate = 7 - 4 - 3 + 2 = 2                                                6-3-5+2 = 0 \n        Move final = 9 - 7 - 3 + 2 = 1                                                      10-4-5+2 = 3 \n        Neither is 0, so we cannot return for sure                                          Move penultimate is 0, so move final is assured \n                                                                                            This means we can return [min(2, 3), 3] -> [2, 3]\n\n        Max legal moves is 0                                                                For completeness, max legal moves is 0, max moves is 3  \n        starting index is 0                                                                 starting index is 0 \n\n        Enumeration                                                                         Enumeration\n            index is 0, stone is 4                                                             index is 0, stone is 3 \n            stones[0] lte 4 - 3 ? No, skip while loop                                          stones[0] lte 3 - 5 ? No, skip while \n            max legal moves is min of (max of self and 0 - 0 + 1, most moves)                  max legal moves is min of (max of self and 0 - 0 + 1), max moves -> max legal moves is 1 \n                 -> max legal moves is 1                                                            \n\n            index is 1, stone is 7                                                             index is 1, stone is 4 \n            stones[0] <= 7 - 3 ? Yes, enter while                                              stones[0] lte 4 - 5 ? No, skip while \n                starting index is now 1                                                        max legal moves is min of (max of self and 1 - 0 + 1), max moves -> max legal moves is 2\n            stones[1] <= 7 - 3 ? No, skip while                                                 \n            max legal moves -> min(max of self and 1 - 1 + 1), max_moves \n                -> max legal moves is 1                                                        index is 2, stone is 5 \n                                                                                               stones[0] lte 5 - 5 ? No skip while \n            index is 2, stone is 9                                                             max legal moves is min of (max of self and 2 - 0 + 1), max_moves -> max legal moves is 3 \n            stones[1] <= 9 - 3 ? No, skip while                                                 \n            max legal moves is min(max of self and 2-1 + 1), max_moves\n                 -> max legal moves is 2                                                       index is 3, stone is 6 \n        End enumeration                                                                        stones[0] lte 6 - 5 ? No skip while \n                                                                                               max legal moves is min (max of self and 3 - 0 + 1), max_moves -> max legal moves is 3 \n        Return [3 - 2, 2] -> [1, 2] checks out                                                  \n                                                                                               index is 4, stones is 10 \n                                                                                               stones[0] lte 10 - 5 ? Yes, enter while \n                                                                                                    starting index is 1 \n                                                                                               stones[1] lte 10 - 5 ? Yes, enter while \n                                                                                                    starting index is 2 \n                                                                                               stones[2] lte 10 - 5 ? Yes, enter while \n                                                                                                    starting index is 3 \n                                                                                               max legal moves is min (max of self and 4 - 3 + 1), max moves -> max legal moves is 3 \n                                                                                            End enumeration\n\n                                                                                            Return [5 - 3, 3] -> [2, 3]\n    '''\n    def numMovesStonesII(self, stones: List[int]) -> List[int] :\n        # order does not need to be maintained, so sorting is optimal \n        stones.sort()\n        # want to work within stone physical space since 10^9 >> 10^4 (stone weight vs length)\n        stone_length = len(stones)\n        # what is the cost of moving the second to last stone and the 0th stone? \n        move_penultimate = stones[-2] - stones[0] - stone_length + 2 \n        # what is the cost of moving the last stone and the 1st stone? \n        move_final = stones[-1] - stones[1] - stone_length + 2 \n        # in both of these, the cost is the positional exchange in stones along the stone length + 2 for the two stones moving \n        # our most moves possible are the max of these two \n        most_moves = max(move_penultimate, move_final)\n        # since the stones are unique, if either is 0, the one that we have must be max legal moves \n        # if move penultimate is 0, that means that the second largest stone less the least stone less the length + 2 is 0 \n        # this means that the largest stone, which must be at least one larger than the largest, less the second to least stone which is at least one larger than the least stone  less the length + 2 is move final \n        # our minimal length is 3 \n        # let a, b, c be stones in order \n        # b - a - 3 + 2 = 0 -> b = a + 1 move penultimate  \n        # c - b - 3 + 2 = 0 -> b = c - 1 move final \n        # c - 1 = a + 1 -> c = a + 2 \n        # all stones must be at least 1 to 10^9 and are unique \n        # so at minimum a is 1, b is 2 and c is 3  \n        # in this case, move final is also 0 so we get 0, 0 \n        # if a = 4, b = 5, c = 7 \n        # 5 - 4 - 3 + 2 = 0 move penultimate is 0 \n        # 7 - 5 - 3 + 2 -> 1 move ultimate is 1 \n        # min legal moves is min of 2 and 1 -> min legal moves is 1 -> 1, 1 is returned \n        # from this it can be seen that the movement of c relative to b impacts  the return here when one is 0, and that if either is 0 it does not preclude the other. However it does entail a relation to 2 as most that min could become \n        # this is because if most moves is greater than 2, we could always do the move alternate that was 0 in two steps. This is what locks in to place the ability to use 2 here as the min argument. \n        if move_penultimate == 0 or move_final == 0 : \n            min_legal_moves = min(2, most_moves)\n            return [min_legal_moves, most_moves]\n        # how many legal moves are there in sorted order? \n        max_legal_moves = 0 \n        # starting from 0th index \n        starting_index = 0\n        # enumerate each stone and index \n        for index, stone in enumerate(stones) :\n            # while the stone at starting index is lte this stone minus stone length (cost of a move) \n            while stones[starting_index] <= stone - stone_length : \n                # increment \n                starting_index += 1\n            # max legal moves is then set to maxima of self and indexed difference with 1 for 0 based indexing  \n            max_legal_moves = min(max(max_legal_moves, index - starting_index + 1), most_moves) \n        # return length - max legal moves when in sorted order (your minimal move state) and most moves in sorted order \n        return [stone_length - max_legal_moves, most_moves]",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAt the base of this problem is a linear scan. This is because we are trying to achieve the pairing of minimum number of moves and maximum number of moves. As such, we are trying to sort the move value space and scan over it linearly. This can be achieved with a few key insights from the problem that keep it at a medium level. \\n\\nFirst, we have a list size lower bound of 3. This is actually dreadfully important for one of our key edge cases that make this easily solvable so don\\'t discard such things when they come up! \\n\\nSecond, we have that all the stone values are unique. \\n\\nThird, we have that all the stone values are positive integers from 1 to 10^9. This is important both as an insight into the fact that we are working with only positive values, and that we are working with a very large value space compared to a much relatively smaller value ordination (there are 10^9 values for the stones, but only 10^4 positions at most for them) \\n\\nWe are also provided with a helpful hint \\n>For the minimum, how many cows are already in place? For the maximum, we have to lose either the gap A[1] - A[0] or A[N-1] - A[N-2] (where N = A.length), but every other space can be occupied ?  \\n\\nWe turn first to the idea of the maximum, where we have a gap we will need to lose of either between the first and second position or ultimate and penultimate position. \\n\\nIf we consider a list of 3 items, our minimum, what is our minimum values to get our minimal return? Not to spoil anything, but it is 1, 2, 3 \\n\\nThis is key to the problem, since there are no spaces provided between the values, so our return should be [0, 0] \\n\\nBy realizing the impact of this the approach follows below. Try to work out for a few values and sizes to get the feel for it and you\\'ll likely find an understanding either intuitively or by action. I recommend working with small list sizes and trying to generate [0, 1], [0, 2], [1, 2], and [2, 2] with only 3 or so items. It\\'ll be difficult, but worth it for the understanding pay off. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe original ordering of the stones is not valid compared to their ordinal positioning, and since we know we have a size limit much less than a value limit, we start by sorting. \\n\\nThen, we want to know how much space we have to work witin, so get the size of your listing (how many stones do you have regardless of how much they are worth?) \\n\\nThen, we need to calculate the two largest costs, move penultimate and move ultimate (final in the code) \\n\\nMove penultimate is the cost of swapping the stones at the second to last spot and the first spot, minus the cost of the number of stones you have (Since you moved over the whole thing!) plus 2 to deal with the fact that they are unique\\n\\nMove ultimate is the cost of swapping the stones at the last spot and second spot, minus the cost of the number of stones you have plus 2 to deal with the fact that they are unique\\n\\nIf either of these is 0, the other must be locked in as most moves, as most moves will be the max of these two options (try to convince yourself of why that is the case! This relates to the idea of the list sizings, and is really clearly seen with a list of size 3)\\n\\nIf either is 0, \\n- min legal moves is min of 2 and most moves \\n- return min legal moves and most moves \\n\\nOtherwise we now must consider how many max legal moves are there really? \\n\\nSet max legal moves to 0 \\nSet starting index to 0 \\nenumerate index and stone in stones \\n- while stones at starting index lte stone - stone length \\n    - increment starting index \\n- our max legal moves here is the max of itself (so it preserves good discoveries) and index - starting index + 1 (+1 for the fact we use 0 indexing) \\n- but, it cannot get too big! Remember, we already found the actual max, so don\\'t let anything in here fool you! Set max legal moves as such to min(max(max_legal_moves, index - starting_index + 1), max_moves) \\n- this keeps our newly found max legal less than our actual max moves \\n\\nWhen done enumerating return length - max legal moves, max moves \\n\\n# Complexity\\n- Time complexity : O(S log S + S)\\n    - O(S log S) to sort the stones \\n    - O(S) to loop over (while loop is incindental, as it can only run as many times as the length of stones as well in total, so it does not add to this)  \\n\\n- Space complexity : O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nNo additional space utilized \\n\\n# Code\\n```\\nclass Solution:\\n    \\'\\'\\'\\n        Test cases walk through \\n        Given 7, 4, 9 prove 1, 2                                                            6, 5, 4, 3, 10, prove 2, 3 \\n\\n        Sort stones -> 4, 7, 9                                                              3, 4, 5, 6, 10 \\n        Stone length -> 3                                                                   5\\n        Move penultimate = 7 - 4 - 3 + 2 = 2                                                6-3-5+2 = 0 \\n        Move final = 9 - 7 - 3 + 2 = 1                                                      10-4-5+2 = 3 \\n        Neither is 0, so we cannot return for sure                                          Move penultimate is 0, so move final is assured \\n                                                                                            This means we can return [min(2, 3), 3] -> [2, 3]\\n\\n        Max legal moves is 0                                                                For completeness, max legal moves is 0, max moves is 3  \\n        starting index is 0                                                                 starting index is 0 \\n\\n        Enumeration                                                                         Enumeration\\n            index is 0, stone is 4                                                             index is 0, stone is 3 \\n            stones[0] lte 4 - 3 ? No, skip while loop                                          stones[0] lte 3 - 5 ? No, skip while \\n            max legal moves is min of (max of self and 0 - 0 + 1, most moves)                  max legal moves is min of (max of self and 0 - 0 + 1), max moves -> max legal moves is 1 \\n                 -> max legal moves is 1                                                            \\n\\n            index is 1, stone is 7                                                             index is 1, stone is 4 \\n            stones[0] <= 7 - 3 ? Yes, enter while                                              stones[0] lte 4 - 5 ? No, skip while \\n                starting index is now 1                                                        max legal moves is min of (max of self and 1 - 0 + 1), max moves -> max legal moves is 2\\n            stones[1] <= 7 - 3 ? No, skip while                                                 \\n            max legal moves -> min(max of self and 1 - 1 + 1), max_moves \\n                -> max legal moves is 1                                                        index is 2, stone is 5 \\n                                                                                               stones[0] lte 5 - 5 ? No skip while \\n            index is 2, stone is 9                                                             max legal moves is min of (max of self and 2 - 0 + 1), max_moves -> max legal moves is 3 \\n            stones[1] <= 9 - 3 ? No, skip while                                                 \\n            max legal moves is min(max of self and 2-1 + 1), max_moves\\n                 -> max legal moves is 2                                                       index is 3, stone is 6 \\n        End enumeration                                                                        stones[0] lte 6 - 5 ? No skip while \\n                                                                                               max legal moves is min (max of self and 3 - 0 + 1), max_moves -> max legal moves is 3 \\n        Return [3 - 2, 2] -> [1, 2] checks out                                                  \\n                                                                                               index is 4, stones is 10 \\n                                                                                               stones[0] lte 10 - 5 ? Yes, enter while \\n                                                                                                    starting index is 1 \\n                                                                                               stones[1] lte 10 - 5 ? Yes, enter while \\n                                                                                                    starting index is 2 \\n                                                                                               stones[2] lte 10 - 5 ? Yes, enter while \\n                                                                                                    starting index is 3 \\n                                                                                               max legal moves is min (max of self and 4 - 3 + 1), max moves -> max legal moves is 3 \\n                                                                                            End enumeration\\n\\n                                                                                            Return [5 - 3, 3] -> [2, 3]\\n    \\'\\'\\'\\n    def numMovesStonesII(self, stones: List[int]) -> List[int] :\\n        # order does not need to be maintained, so sorting is optimal \\n        stones.sort()\\n        # want to work within stone physical space since 10^9 >> 10^4 (stone weight vs length)\\n        stone_length = len(stones)\\n        # what is the cost of moving the second to last stone and the 0th stone? \\n        move_penultimate = stones[-2] - stones[0] - stone_length + 2 \\n        # what is the cost of moving the last stone and the 1st stone? \\n        move_final = stones[-1] - stones[1] - stone_length + 2 \\n        # in both of these, the cost is the positional exchange in stones along the stone length + 2 for the two stones moving \\n        # our most moves possible are the max of these two \\n        most_moves = max(move_penultimate, move_final)\\n        # since the stones are unique, if either is 0, the one that we have must be max legal moves \\n        # if move penultimate is 0, that means that the second largest stone less the least stone less the length + 2 is 0 \\n        # this means that the largest stone, which must be at least one larger than the largest, less the second to least stone which is at least one larger than the least stone  less the length + 2 is move final \\n        # our minimal length is 3 \\n        # let a, b, c be stones in order \\n        # b - a - 3 + 2 = 0 -> b = a + 1 move penultimate  \\n        # c - b - 3 + 2 = 0 -> b = c - 1 move final \\n        # c - 1 = a + 1 -> c = a + 2 \\n        # all stones must be at least 1 to 10^9 and are unique \\n        # so at minimum a is 1, b is 2 and c is 3  \\n        # in this case, move final is also 0 so we get 0, 0 \\n        # if a = 4, b = 5, c = 7 \\n        # 5 - 4 - 3 + 2 = 0 move penultimate is 0 \\n        # 7 - 5 - 3 + 2 -> 1 move ultimate is 1 \\n        # min legal moves is min of 2 and 1 -> min legal moves is 1 -> 1, 1 is returned \\n        # from this it can be seen that the movement of c relative to b impacts  the return here when one is 0, and that if either is 0 it does not preclude the other. However it does entail a relation to 2 as most that min could become \\n        # this is because if most moves is greater than 2, we could always do the move alternate that was 0 in two steps. This is what locks in to place the ability to use 2 here as the min argument. \\n        if move_penultimate == 0 or move_final == 0 : \\n            min_legal_moves = min(2, most_moves)\\n            return [min_legal_moves, most_moves]\\n        # how many legal moves are there in sorted order? \\n        max_legal_moves = 0 \\n        # starting from 0th index \\n        starting_index = 0\\n        # enumerate each stone and index \\n        for index, stone in enumerate(stones) :\\n            # while the stone at starting index is lte this stone minus stone length (cost of a move) \\n            while stones[starting_index] <= stone - stone_length : \\n                # increment \\n                starting_index += 1\\n            # max legal moves is then set to maxima of self and indexed difference with 1 for 0 based indexing  \\n            max_legal_moves = min(max(max_legal_moves, index - starting_index + 1), most_moves) \\n        # return length - max legal moves when in sorted order (your minimal move state) and most moves in sorted order \\n        return [stone_length - max_legal_moves, most_moves]\\n```",
        "level": "medium",
        "type": [
            "indentation error",
            "undefined methods",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:dfnumMovStonesII(sef,stones: List[int]) -> List[int]:\n        stones.sort()\n        stone_leng = len(stnes)\n        move_penltimate = stones[-2] - stones[0] - stone_lent+2\n move_final = stones[-1] - stones[1] - stone_length + 2 \n        most_moves = max(move_penultimatemove_final)\n      if move_nultimate==mv_final==:_gl_movs=most_moves\n            return [min_legal_movesmost_moves\n      max_legal_moves = 0 \n        starting_index = 0\n        for index():starting_index + 1<=stne - stone_length : \n                starting_index += 1\n            max_legal_moves = min(max(max_legal_moves-trting_iext_)rtur[tone_length- max_legal_movesm_mv)sne_lengms_mves = max(move_penultimate, move_nal)\n      if move_uima==0or move_final == 0 : \n            min_legal_moves = min(, most_moves)\n            return [min_legal_moves, most_moves]\n        max_legal_moves = 0 \n        starting_index = 0\n       x stone in enumerate(stones) :\n           le stones[starting_index] <= stone - stone_lengt:\n           starting_index += 1\n            max_legal_moves = min(max(max_legal_moves, index - starting_index + 1), most_moves) \n        return [stone_leng-mx__mv,mos_movs]\n     \nsolution = Solution()\nprint(solution.moveFinal([,6"
    },
    {
        "slug": "unique-number-of-occurrences",
        "description": "Given an array of integers arr, return true if the number of occurrences of each value in the array is unique or false otherwise.",
        "examples": [
            "Input: arr = [1,2,2,1,1,3]\nOutput: true\nExplanation:\u00a0The value 1 has 3 occurrences, 2 has 2 and 3 has 1. No two values have the same number of occurrences.",
            "Input: arr = [1,2]\nOutput: false",
            "Input: arr = [-3,0,1,-3,1,1,1,-3,10,0]\nOutput: true"
        ],
        "constraints": "1 <= arr.length <= 1000\n-1000 <= arr[i] <= 1000",
        "oracle_code": "from collections import Counter\nclass Solution:\n    def uniqueOccurrences(self, arr: List[int]) -> bool:\n        d=Counter(arr)\n        l=list(d.values())\n        print(l)\n        if len(l)==len(set(l)):\n            return True\n        else:\n            return False",
        "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nfrom collections import Counter\\nclass Solution:\\n    def uniqueOccurrences(self, arr: List[int]) -> bool:\\n        d=Counter(arr)\\n        l=list(d.values())\\n        print(l)\\n        if len(l)==len(set(l)):\\n            return True\\n        else:\\n            return False\\n```",
        "level": "easy",
        "type": [
            "undefined methods",
            "colon missing",
            "operation error"
        ],
        "buggy_code": "\nfrom collections import Counter\nclass Solution:\n    def uniqueOccurrences(self, arr: List[int]) -> bool\n        d=Counter(arr)\n        l=self.get_values(dky) \n        print(l)\n        if len(l)==len(set(l)):\n            return True\n        else:\n            return False\n"
    },
    {
        "slug": "restore-ip-addresses",
        "description": "A valid IP address consists of exactly four integers separated by single dots. Each integer is between 0 and 255 (inclusive) and cannot have leading zeros.\n\nFor example, \"0.1.2.201\" and \"192.168.1.1\" are valid IP addresses, but \"0.011.255.245\", \"192.168.1.312\" and \"192.168@1.1\" are invalid IP addresses.\n\nGiven a string s containing only digits, return all possible valid IP addresses that can be formed by inserting dots into s. You are not allowed to reorder or remove any digits in s. You may return the valid IP addresses in any order.",
        "examples": [
            "Input: s = \"25525511135\"\nOutput: [\"255.255.11.135\",\"255.255.111.35\"]",
            "Input: s = \"0000\"\nOutput: [\"0.0.0.0\"]",
            "Input: s = \"101023\"\nOutput: [\"1.0.10.23\",\"1.0.102.3\",\"10.1.0.23\",\"10.10.2.3\",\"101.0.2.3\"]"
        ],
        "constraints": "1 <= s.length <= 20\ns consists of digits only.",
        "oracle_code": "class Solution:\n    def restoreIpAddresses(self, s: str) -> List[str]:\n        res=[]\n        cur=[]\n        def backtrack(i):\n            if i==len(s) and len(cur)==4:\n                res.append(\".\".join(cur))\n                return\n            if len(cur)>4 or i>=len(s):\n                return\n            if s[i]=='0':\n                cur.append(s[i])\n                backtrack(i+1)\n                cur.pop()\n                return\n            j=0\n            while j<4 and i+j<len(s):\n                if int(s[i:i+j+1])<256:\n                    cur.append(s[i:i+j+1])\n                    backtrack(i+j+1)\n                    cur.pop()\n                j+=1\n        backtrack(0)\n        return res",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\njust take care with the processing number should be lower than len(s) and the length of current stack should be lower or equal 4.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(4)\\n# Code\\n```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        res=[]\\n        cur=[]\\n        def backtrack(i):\\n            if i==len(s) and len(cur)==4:\\n                res.append(\".\".join(cur))\\n                return\\n            if len(cur)>4 or i>=len(s):\\n                return\\n            if s[i]==\\'0\\':\\n                cur.append(s[i])\\n                backtrack(i+1)\\n                cur.pop()\\n                return\\n            j=0\\n            while j<4 and i+j<len(s):\\n                if int(s[i:i+j+1])<256:\\n                    cur.append(s[i:i+j+1])\\n                    backtrack(i+j+1)\\n                    cur.pop()\\n                j+=1\\n        backtrack(0)\\n        return res\\n\\n```",
        "level": "medium",
        "type": [
            "colon missing",
            "unclosed string",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def restoreIpAddresses(self, s: str) -> List[str]:\n        res=[]\n        cur=[]\n        def backtrack(i):\n            if i==len(s) and len(cur)==4:\n                res.append(\".\".join(cur))\n                return\n            if len(cur)>4 or i>len(s):\n                return\n            if s[i]=='0':\n                cur.append(s[i])\n                backtrack(i+1)\n                cur.pop()\n                return\n            j=0\n            while j<4 and i+j<len(s)\n                if int(s[i:i+j+1])<256:\n                    cur.append(s[i:i+j+1])\n                    backtrack(i+j+1)\n                    cur.pop()\n                j+=1\n        backtrack(0)\n        return 'res\n"
    },
    {
        "slug": "kth-largest-element-in-an-array",
        "description": "Given an integer array nums and an integer k, return the kth largest element in the array.\nNote that it is the kth largest element in the sorted order, not the kth distinct element.\nCan you solve it without sorting?",
        "examples": [
            "Input: nums = [3,2,1,5,6,4], k = 2\nOutput: 5",
            "Input: nums = [3,2,3,1,2,4,5,5,6], k = 4\nOutput: 4"
        ],
        "constraints": "1 <= k <= nums.length <= 105\n-104 <= nums[i] <= 104",
        "oracle_code": "class Solution:\n    def findKthLargest(self, nums: List[int], k: int) -> int:\n        return sorted(nums)[-k]",
        "content": "# Approach\\n- Sorting\\n\\n# Complexity\\n- Time complexity: O(n*log(n))\\n\\n# Code\\n```\\nclass Solution:\\n    def findKthLargest(self, nums: List[int], k: int) -> int:\\n        return sorted(nums)[-k]\\n```",
        "level": "medium",
        "type": [
            "operation error",
            "undefined objects",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def findKthLargest(self, nums: List[int], k: int) -> int:\n        return sorted(no_nums)[-k-1]\n"
    },
    {
        "slug": "restore-ip-addresses",
        "description": "A valid IP address consists of exactly four integers separated by single dots. Each integer is between 0 and 255 (inclusive) and cannot have leading zeros.\n\nFor example, \"0.1.2.201\" and \"192.168.1.1\" are valid IP addresses, but \"0.011.255.245\", \"192.168.1.312\" and \"192.168@1.1\" are invalid IP addresses.\n\nGiven a string s containing only digits, return all possible valid IP addresses that can be formed by inserting dots into s. You are not allowed to reorder or remove any digits in s. You may return the valid IP addresses in any order.",
        "examples": [
            "Input: s = \"25525511135\"\nOutput: [\"255.255.11.135\",\"255.255.111.35\"]",
            "Input: s = \"0000\"\nOutput: [\"0.0.0.0\"]",
            "Input: s = \"101023\"\nOutput: [\"1.0.10.23\",\"1.0.102.3\",\"10.1.0.23\",\"10.10.2.3\",\"101.0.2.3\"]"
        ],
        "constraints": "1 <= s.length <= 20\ns consists of digits only.",
        "oracle_code": "class Solution:\n    def restoreIpAddresses(self, s: str) -> List[str]:\n        res=[]\n        cur=[]\n        def backtrack(i):\n            if i==len(s) and len(cur)==4:\n                res.append(\".\".join(cur))\n                return\n            if len(cur)>4 or i>=len(s):\n                return\n            if s[i]=='0':\n                cur.append(s[i])\n                backtrack(i+1)\n                cur.pop()\n                return\n            j=0\n            while j<4 and i+j<len(s):\n                if int(s[i:i+j+1])<256:\n                    cur.append(s[i:i+j+1])\n                    backtrack(i+j+1)\n                    cur.pop()\n                j+=1\n        backtrack(0)\n        return res",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\njust take care with the processing number should be lower than len(s) and the length of current stack should be lower or equal 4.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(4)\\n# Code\\n```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        res=[]\\n        cur=[]\\n        def backtrack(i):\\n            if i==len(s) and len(cur)==4:\\n                res.append(\".\".join(cur))\\n                return\\n            if len(cur)>4 or i>=len(s):\\n                return\\n            if s[i]==\\'0\\':\\n                cur.append(s[i])\\n                backtrack(i+1)\\n                cur.pop()\\n                return\\n            j=0\\n            while j<4 and i+j<len(s):\\n                if int(s[i:i+j+1])<256:\\n                    cur.append(s[i:i+j+1])\\n                    backtrack(i+j+1)\\n                    cur.pop()\\n                j+=1\\n        backtrack(0)\\n        return res\\n\\n```",
        "level": "medium",
        "type": [
            "parentheses mismatch",
            "unclosed string",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution():\n    def restoreIpAddresses(self, s: str) -> List[str]:\n        res=[]\n        cur=[]\n        def backtrack(i:\n            if i=len(s) and len(cur)==4:\n                res.append(\".\".join(cur))\n                return\n            if len(cur)>4 or i>=len(s):\n                return\n            if s[i]=='0':\n                cur.append(s[i])\n                backtrack(i+1)\n                cur.pop()\n                return\n            j=0\n            while j<4 and i+j<len(s):\n                if int(s[i:i+j+1])<256:\n                    cur.append(s[i:i+j+1])\n                    backtrack(i+j+1)\n                    cur.pop()\n                j+=1\n        backtrack(0)\n        return 'res\n"
    },
    {
        "slug": "valid-permutations-for-di-sequence",
        "description": "You are given a string s of length n where s[i] is either:\n\n'D' means decreasing, or\n'I' means increasing.\n\nA permutation perm of n + 1 integers of all the integers in the range [0, n] is called a valid permutation if for all valid i:\n\nIf s[i] == 'D', then perm[i] > perm[i + 1], and\nIf s[i] == 'I', then perm[i] < perm[i + 1].\n\nReturn the number of valid permutations perm. Since the answer may be large, return it modulo 109 + 7.",
        "examples": [
            "Input: s = \"DID\"\nOutput: 5\nExplanation: The 5 valid permutations of (0, 1, 2, 3) are:\n(1, 0, 3, 2)\n(2, 0, 3, 1)\n(2, 1, 3, 0)\n(3, 0, 2, 1)\n(3, 1, 2, 0)",
            "Input: s = \"D\"\nOutput: 1"
        ],
        "constraints": "n == s.length\n1 <= n <= 200\ns[i] is either 'I' or 'D'.",
        "oracle_code": "class Solution:\n    def numPermsDISequence(self, s: str) -> int:\n        mem=defaultdict(int)\n        def dfs(i,val=0):\n            if i==len(s):\n                return 1\n            if (i,val) in mem:\n                return mem[i,val]\n            p=0\n            if s[i]==\"D\":\n                for ind in range(0,val+1):\n                    p+=dfs(i+1,ind)%(10**9+7)\n            else:\n                for ind in range(val+1,i+2):\n                    p+=dfs(i+1,ind)%(10**9+7)\n            mem[i,val]=p\n            return p\n        return dfs(0)",
        "content": "To add a new character to a sequence we only have to consider the last element-\\n\\nLets say currently DID sequence is 1032- this can form\\n\\nDIDI - in cases where we end with 3,4\\nDIDD - in cases where we end with 0,1,2\\n\\nSo just use the last element value to create a new sequence.\\n\\n```\\nclass Solution:\\n    def numPermsDISequence(self, s: str) -> int:\\n        mem=defaultdict(int)\\n        def dfs(i,val=0):\\n            if i==len(s):\\n                return 1\\n            if (i,val) in mem:\\n                return mem[i,val]\\n            p=0\\n            if s[i]==\"D\":\\n                for ind in range(0,val+1):\\n                    p+=dfs(i+1,ind)%(10**9+7)\\n            else:\\n                for ind in range(val+1,i+2):\\n                    p+=dfs(i+1,ind)%(10**9+7)\\n            mem[i,val]=p\\n            return p\\n        return dfs(0)\\n ```\\n\\t\\t\\t\\t",
        "level": "hard",
        "type": [
            "colon missing",
            "parentheses mismatch",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def numPermsDISequence(self, s: str) -> int:\n        mem=defaultdict(int)\n        def dfs(i,val=0):\n            if i==len(s):\n                return 1\n            if (i,val in mem\n                return mem[i,val]\n            p=0\n            if s[i]==\"D\":\n                for ind in range(0,val+2): \n                    p+=dfs(i+1,ind)%(10**9+7)\n            else:\n                for ind in range(val+1,i+3): \n                    p+=dfs(i+1,ind)%(10**9+7)\n            mem[i,val]=p\n            return p\n        return dfs(0)\n"
    },
    {
        "slug": "count-anagrams",
        "description": "You are given a string s containing one or more words. Every consecutive pair of words is separated by a single space ' '.\nA string t is an anagram of string s if the ith word of t is a permutation of the ith word of s.\n\nFor example, \"acb dfe\" is an anagram of \"abc def\", but \"def cab\"\u00a0and \"adc bef\" are not.\n\nReturn the number of distinct anagrams of s. Since the answer may be very large, return it modulo 109 + 7.",
        "examples": [
            "Input: s = \"too hot\"\nOutput: 18\nExplanation: Some of the anagrams of the given string are \"too hot\", \"oot hot\", \"oto toh\", \"too toh\", and \"too oht\".",
            "Input: s = \"aa\"\nOutput: 1\nExplanation: There is only one anagram possible for the given string."
        ],
        "constraints": "1 <= s.length <= 105\ns consists of lowercase English letters and spaces ' '.\nThere is single space between consecutive words.",
        "oracle_code": "mod = 10**9+7\n\nclass Solution:\n    def countAnagrams(self, s: str) -> int:\n\n        l = s.split()\n        ans = 1\n\n        for i in l:\n            d = {}\n        # counting frequencies of word i in dictionary d\n            for j in i:\n                if(d.get(j)):\n                    d[j] += 1\n                else:\n                    d[j] = 1  \n            \n            duplicates = 1\n            for j in d.values():\n                duplicates *= math.factorial(j)\n            curr = math.factorial(len(i))//duplicates\n\n            ans *= curr\n            ans = ans%mod\n\n        return ans",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe idea is very simple. Total count of anagrams for each word is\\n(factorial of length of word) divided by factorial of duplicates.\\n\\nEg : aabbc -  5!/(2! * 2!)\\n\\n# Code\\n```\\nmod = 10**9+7\\n\\nclass Solution:\\n    def countAnagrams(self, s: str) -> int:\\n\\n        l = s.split()\\n        ans = 1\\n\\n        for i in l:\\n            d = {}\\n        # counting frequencies of word i in dictionary d\\n            for j in i:\\n                if(d.get(j)):\\n                    d[j] += 1\\n                else:\\n                    d[j] = 1  \\n            \\n            duplicates = 1\\n            for j in d.values():\\n                duplicates *= math.factorial(j)\\n            curr = math.factorial(len(i))//duplicates\\n\\n            ans *= curr\\n            ans = ans%mod\\n\\n        return ans        \\n        \\n        \\n```",
        "level": "hard",
        "type": [
            "indentation error",
            "operation error",
            "indexing error"
        ],
        "buggy_code": "\nmod = 10**9+7\n\nclass Solution:\ndef countAnagrams(self, s: str) -> int:\n\n    l = s.split()\n    ans = 1\n\n    for i in l:\n        d = {}\n    \n        for j in i:\n            if(d.get(j)):\n                d[j] += 2\n            else:\n                d[j] = 1  \n    \n        duplicates = 1\n        for j in d.values():\n            duplicates *= math.factorial(j)\n        curr = math.factorial(len(i)+1)//duplicates\n\n        ans *= curr\n        ans = ans%mod\n\n    return ans\n"
    },
    {
        "slug": "length-of-the-longest-valid-substring",
        "description": "You are given a string word and an array of strings forbidden.\nA string is called valid if none of its substrings are present in forbidden.\nReturn the length of the longest valid substring of the string word.\nA substring is a contiguous sequence of characters in a string, possibly empty.",
        "examples": [
            "Input: word = \"cbaaaabc\", forbidden = [\"aaa\",\"cb\"]\nOutput: 4\nExplanation: There are 11 valid substrings in word: \"c\", \"b\", \"a\", \"ba\", \"aa\", \"bc\", \"baa\", \"aab\", \"ab\", \"abc\"and \"aabc\". The length of the longest valid substring is 4. \nIt can be shown that all other substrings contain either \"aaa\" or \"cb\" as a substring.",
            "Input: word = \"leetcode\", forbidden = [\"de\",\"le\",\"e\"]\nOutput: 4\nExplanation: There are 11 valid substrings in word: \"l\", \"t\", \"c\", \"o\", \"d\", \"tc\", \"co\", \"od\", \"tco\", \"cod\", and \"tcod\". The length of the longest valid substring is 4.\nIt can be shown that all other substrings contain either \"de\", \"le\", or \"e\" as a substring."
        ],
        "constraints": "1 <= word.length <= 105\nword consists only of lowercase English letters.\n1 <= forbidden.length <= 105\n1 <= forbidden[i].length <= 10\nforbidden[i] consists only of lowercase English letters.",
        "oracle_code": "class Solution:\n    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int:\n        trie = {}\n        for f in forbidden:\n            t = trie\n            for c in f:\n                if c not in t:\n                    t[c] = {}\n                t = t[c]\n            t[\"end\"] = True\n        \n        def isForbidden(s):\n            t = trie\n            counter = 0\n            for c in s:\n                if c not in t:\n                    return False\n                t = t[c]\n                counter += 1\n                if \"end\" in t:\n                    return counter\n            return False\n        \n        res = 0\n        j = len(word)\n        for i in range(len(word) - 1, -1, -1):\n            truc = isForbidden(word[i:j])\n            if truc:\n                j = i + truc - 1\n            res = max(res, j - i)\n        return res",
        "content": "Put all the forbidden strings into a trie, so that for each string `s`, we can check every substring starts from the beginning (i.e. `s[:1]`,  `s[:2]` ...  `s[:len(s)]`) in one travesal.\\n\\nUse a sliding window to iterate from back to front, each time, we only need to check whether the substrings starting from the new character is forbidden. If the substring is forbidden, then we truncate the string and continue to search.\\n\\nUsing a trie can make the foibidden check fails faster and can deal with longer foibidden strings.\\n\\n# Code\\n```\\nclass Solution:\\n    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int:\\n        trie = {}\\n        for f in forbidden:\\n            t = trie\\n            for c in f:\\n                if c not in t:\\n                    t[c] = {}\\n                t = t[c]\\n            t[\"end\"] = True\\n        \\n        def isForbidden(s):\\n            t = trie\\n            counter = 0\\n            for c in s:\\n                if c not in t:\\n                    return False\\n                t = t[c]\\n                counter += 1\\n                if \"end\" in t:\\n                    return counter\\n            return False\\n        \\n        res = 0\\n        j = len(word)\\n        for i in range(len(word) - 1, -1, -1):\\n            truc = isForbidden(word[i:j])\\n            if truc:\\n                j = i + truc - 1\\n            res = max(res, j - i)\\n        return res\\n```",
        "level": "hard",
        "type": [
            "colon missing",
            "operation error",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution:\n    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int\n        trie = {}\n        for f in forbidden:\n            t = trie\n            for c in f:\n                if c not in t:\n                    t[c] = {}\n                t = t[c]\n            t[\"end\"] = True\n        \n        def isForbidden(s):\n            t = trie\n            counter = 0\n            for c in s:\n                if c not in t:\n                    return False\n                t = t[c]\n                counter += 1\n                if \"end\" in t:\n                    return 'counter\n            return False\n        \n        res = 0\n        j = len(word)\n        for i in range(len(word) - 1, -1, -1):\n            truc = isForbidden(word[i:j])\n            if truc:\n                j = i - truc - 1\n            res = max(res, j - i)\n        return res\n"
    },
    {
        "slug": "binary-tree-level-order-traversal-ii",
        "description": "Given the root of a binary tree, return the bottom-up level order traversal of its nodes' values. (i.e., from left to right, level by level from leaf to root).",
        "examples": [
            "Input: root = [3,9,20,null,null,15,7]\nOutput: [[15,7],[9,20],[3]]",
            "Input: root = [1]\nOutput: [[1]]",
            "Input: root = []\nOutput: []"
        ],
        "constraints": "The number of nodes in the tree is in the range [0, 2000].\n-1000 <= Node.val <= 1000",
        "oracle_code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:\n        def checkReverse(ans):\n            l,r = 0,len(ans)-1\n            while l<=r:\n                ans[l],ans[r] = ans[r],ans[l]\n                l+=1\n                r-=1\n            return ans\n\n        if not root: return None\n        q,ans = [root],[]\n        while q:\n            n,l = len(q),[]\n            for i in range(n):\n                curr = q.pop(0)\n                l.append(curr.val)\n                if curr.left:\n                    q.append(curr.left)\n                if curr.right:\n                    q.append(curr.right)\n            ans.append(l)\n        return checkReverse(ans)",
        "content": "# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:\\n        def checkReverse(ans):\\n            l,r = 0,len(ans)-1\\n            while l<=r:\\n                ans[l],ans[r] = ans[r],ans[l]\\n                l+=1\\n                r-=1\\n            return ans\\n\\n        if not root: return None\\n        q,ans = [root],[]\\n        while q:\\n            n,l = len(q),[]\\n            for i in range(n):\\n                curr = q.pop(0)\\n                l.append(curr.val)\\n                if curr.left:\\n                    q.append(curr.left)\\n                if curr.right:\\n                    q.append(curr.right)\\n            ans.append(l)\\n        return checkReverse(ans)\\n```",
        "level": "medium",
        "type": [
            "colon missing",
            "undefined objects",
            "indexing error"
        ],
        "buggy_code": "\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:\n        def checkReverse(ans):\n            l,r = 0,len(ans)\n            while l<=r\n                ans[l],ans[r] = ans[r],ans[l]\n                l+=1\n                r-=1\n            return ans\n\n        if not root: return None\n        q,ans = [root],[]\n        while q:\n            n,l = len(Node),[]\n            for i in range(n):\n                curr = q.pop(0)\n                l.append(curr.val)\n                if curr.left:\n                    q.append(curr.left)\n                if curr.right:\n                    q.append(curr.right)\n            ans.append(l)\n        return checkReverse(ans)\n"
    },
    {
        "slug": "count-anagrams",
        "description": "You are given a string s containing one or more words. Every consecutive pair of words is separated by a single space ' '.\nA string t is an anagram of string s if the ith word of t is a permutation of the ith word of s.\n\nFor example, \"acb dfe\" is an anagram of \"abc def\", but \"def cab\"\u00a0and \"adc bef\" are not.\n\nReturn the number of distinct anagrams of s. Since the answer may be very large, return it modulo 109 + 7.",
        "examples": [
            "Input: s = \"too hot\"\nOutput: 18\nExplanation: Some of the anagrams of the given string are \"too hot\", \"oot hot\", \"oto toh\", \"too toh\", and \"too oht\".",
            "Input: s = \"aa\"\nOutput: 1\nExplanation: There is only one anagram possible for the given string."
        ],
        "constraints": "1 <= s.length <= 105\ns consists of lowercase English letters and spaces ' '.\nThere is single space between consecutive words.",
        "oracle_code": "mod = 10**9+7\n\nclass Solution:\n    def countAnagrams(self, s: str) -> int:\n\n        l = s.split()\n        ans = 1\n\n        for i in l:\n            d = {}\n        # counting frequencies of word i in dictionary d\n            for j in i:\n                if(d.get(j)):\n                    d[j] += 1\n                else:\n                    d[j] = 1  \n            \n            duplicates = 1\n            for j in d.values():\n                duplicates *= math.factorial(j)\n            curr = math.factorial(len(i))//duplicates\n\n            ans *= curr\n            ans = ans%mod\n\n        return ans",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe idea is very simple. Total count of anagrams for each word is\\n(factorial of length of word) divided by factorial of duplicates.\\n\\nEg : aabbc -  5!/(2! * 2!)\\n\\n# Code\\n```\\nmod = 10**9+7\\n\\nclass Solution:\\n    def countAnagrams(self, s: str) -> int:\\n\\n        l = s.split()\\n        ans = 1\\n\\n        for i in l:\\n            d = {}\\n        # counting frequencies of word i in dictionary d\\n            for j in i:\\n                if(d.get(j)):\\n                    d[j] += 1\\n                else:\\n                    d[j] = 1  \\n            \\n            duplicates = 1\\n            for j in d.values():\\n                duplicates *= math.factorial(j)\\n            curr = math.factorial(len(i))//duplicates\\n\\n            ans *= curr\\n            ans = ans%mod\\n\\n        return ans        \\n        \\n        \\n```",
        "level": "hard",
        "type": [
            "colon missing",
            "operation error",
            "indexing error"
        ],
        "buggy_code": "\nmod = 10**9+7\n\nclass Solution:\n    def countAnagrams(self, s: str) -> int\n\n        l = s.split()\n        ans = 1\n\n        for i in l:\n            d = {}\n        # counting frequencies of word i in dictionary d\n            for j in i:\n                if(d.get(j)):\n                    d[j] += 2\n                else:\n                    d[j] = 1  \n            \n            duplicates = 1\n            for j in d.values():\n                duplicates *= math.factorial(j)\n            curr = math.factorial(len(i)+1)//duplicates\n\n            ans *= curr\n            ans = ans%mod\n\n        return ans\n"
    },
    {
        "slug": "can-place-flowers",
        "description": "You have a long flowerbed in which some of the plots are planted, and some are not. However, flowers cannot be planted in adjacent plots.\nGiven an integer array flowerbed containing 0's and 1's, where 0 means empty and 1 means not empty, and an integer n, return true\u00a0if n new flowers can be planted in the flowerbed without violating the no-adjacent-flowers rule and false otherwise.",
        "examples": [
            "Input: flowerbed = [1,0,0,0,1], n = 1\nOutput: true",
            "Input: flowerbed = [1,0,0,0,1], n = 2\nOutput: false"
        ],
        "constraints": "1 <= flowerbed.length <= 2 * 104\nflowerbed[i] is 0 or 1.\nThere are no two adjacent flowers in flowerbed.\n0 <= n <= flowerbed.length",
        "oracle_code": "class Solution:\n    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:\n        flowerbed=[0]+flowerbed+[0]\n        for i in range(1,len(flowerbed)-1):\n            if flowerbed[i]==0 and flowerbed[i+1]==0 and flowerbed[i-1]==0:flowerbed[i]=1;n-=1\n        if n<=0:return True\n        return False",
        "content": "![image.png](https://assets.leetcode.com/users/images/c82b49a3-d51e-40a4-b4b5-197596cb28f2_1691328287.5834074.png)\\n\\n\\n\\n\\n\\nPLease UPVOTE \\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:\\n        flowerbed=[0]+flowerbed+[0]\\n        for i in range(1,len(flowerbed)-1):\\n            if flowerbed[i]==0 and flowerbed[i+1]==0 and flowerbed[i-1]==0:flowerbed[i]=1;n-=1\\n        if n<=0:return True\\n        return False\\n```",
        "level": "easy",
        "type": [
            "colon missing",
            "undefined objects",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:\n        flowerbed=[0]+flowerbed+[0]\n        for i in range(1,len(flowerbed)-1)\n            if flowerbed[i]==0 and flowerbed[i+1]=0 and flowerbed[i-1]==0:flowerbed[i]=1;randomFluid-=1\n        if n<=0:return True\n        return False\n"
    },
    {
        "slug": "binary-tree-level-order-traversal-ii",
        "description": "Given the root of a binary tree, return the bottom-up level order traversal of its nodes' values. (i.e., from left to right, level by level from leaf to root).",
        "examples": [
            "Input: root = [3,9,20,null,null,15,7]\nOutput: [[15,7],[9,20],[3]]",
            "Input: root = [1]\nOutput: [[1]]",
            "Input: root = []\nOutput: []"
        ],
        "constraints": "The number of nodes in the tree is in the range [0, 2000].\n-1000 <= Node.val <= 1000",
        "oracle_code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:\n        def checkReverse(ans):\n            l,r = 0,len(ans)-1\n            while l<=r:\n                ans[l],ans[r] = ans[r],ans[l]\n                l+=1\n                r-=1\n            return ans\n\n        if not root: return None\n        q,ans = [root],[]\n        while q:\n            n,l = len(q),[]\n            for i in range(n):\n                curr = q.pop(0)\n                l.append(curr.val)\n                if curr.left:\n                    q.append(curr.left)\n                if curr.right:\n                    q.append(curr.right)\n            ans.append(l)\n        return checkReverse(ans)",
        "content": "# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:\\n        def checkReverse(ans):\\n            l,r = 0,len(ans)-1\\n            while l<=r:\\n                ans[l],ans[r] = ans[r],ans[l]\\n                l+=1\\n                r-=1\\n            return ans\\n\\n        if not root: return None\\n        q,ans = [root],[]\\n        while q:\\n            n,l = len(q),[]\\n            for i in range(n):\\n                curr = q.pop(0)\\n                l.append(curr.val)\\n                if curr.left:\\n                    q.append(curr.left)\\n                if curr.right:\\n                    q.append(curr.right)\\n            ans.append(l)\\n        return checkReverse(ans)\\n```",
        "level": "medium",
        "type": [
            "colon missing",
            "undefined objects",
            "conditional statement error"
        ],
        "buggy_code": "\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:\n        def checkReverse(ans):\n            l,r = 0,len(ans)-1\n            while l<=r\n                ans[l],ans[r] = ans[r],ans[l]\n                l+=1\n                r-=1\n            return ans\n\n        if not root: return None\n        q,ans = [root],[]\n        while q:\n            n,l = len(Node),[]\n            for i in range(n):\n                curr = q.pop(0)\n                l.append(curr.val)\n                q.append(curr.left)\n                q.append(curr.right)\n\n            ans.append(l)\n        return checkReverse(ans)\n"
    },
    {
        "slug": "baseball-game",
        "description": "You are keeping the scores for a baseball game with strange rules. At the beginning of the game, you start with an empty record.\nYou are given a list of strings operations, where operations[i] is the ith operation you must apply to the record and is one of the following:\n\nAn integer x.\n\n\t\nRecord a new score of x.\n\n\n'+'.\n\t\nRecord a new score that is the sum of the previous two scores.\n\n\n'D'.\n\t\nRecord a new score that is the double of the previous score.\n\n\n'C'.\n\t\nInvalidate the previous score, removing it from the record.\n\n\n\nReturn the sum of all the scores on the record after applying all the operations.\nThe test cases are generated such that the answer and all intermediate calculations fit in a 32-bit integer and that all operations are valid.",
        "examples": [
            "Input: ops = [\"5\",\"2\",\"C\",\"D\",\"+\"]\nOutput: 30\nExplanation:\n\"5\" - Add 5 to the record, record is now [5].\n\"2\" - Add 2 to the record, record is now [5, 2].\n\"C\" - Invalidate and remove the previous score, record is now [5].\n\"D\" - Add 2 * 5 = 10 to the record, record is now [5, 10].\n\"+\" - Add 5 + 10 = 15 to the record, record is now [5, 10, 15].\nThe total sum is 5 + 10 + 15 = 30.",
            "Input: ops = [\"5\",\"-2\",\"4\",\"C\",\"D\",\"9\",\"+\",\"+\"]\nOutput: 27\nExplanation:\n\"5\" - Add 5 to the record, record is now [5].\n\"-2\" - Add -2 to the record, record is now [5, -2].\n\"4\" - Add 4 to the record, record is now [5, -2, 4].\n\"C\" - Invalidate and remove the previous score, record is now [5, -2].\n\"D\" - Add 2 * -2 = -4 to the record, record is now [5, -2, -4].\n\"9\" - Add 9 to the record, record is now [5, -2, -4, 9].\n\"+\" - Add -4 + 9 = 5 to the record, record is now [5, -2, -4, 9, 5].\n\"+\" - Add 9 + 5 = 14 to the record, record is now [5, -2, -4, 9, 5, 14].\nThe total sum is 5 + -2 + -4 + 9 + 5 + 14 = 27.",
            "Input: ops = [\"1\",\"C\"]\nOutput: 0\nExplanation:\n\"1\" - Add 1 to the record, record is now [1].\n\"C\" - Invalidate and remove the previous score, record is now [].\nSince the record is empty, the total sum is 0."
        ],
        "constraints": "1 <= operations.length <= 1000\noperations[i] is \"C\", \"D\", \"+\", or a string representing an integer in the range [-3 * 104, 3 * 104].\nFor operation \"+\", there will always be at least two previous scores on the record.\nFor operations \"C\" and \"D\", there will always be at least one previous score on the record.",
        "oracle_code": "class Solution:\n    def calPoints(self, operations: List[str]) -> int:\n        stack=[]\n        for i in operations:\n            if i =='D':\n                stack.append(2*stack[-1])\n            elif i=='C':\n                stack.pop()\n            elif i=='+':\n                stack.append(stack[-1]+stack[-2])\n            else:\n                stack.append(int(i))\n        return sum(stack)",
        "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def calPoints(self, operations: List[str]) -> int:\\n        stack=[]\\n        for i in operations:\\n            if i ==\\'D\\':\\n                stack.append(2*stack[-1])\\n            elif i==\\'C\\':\\n                stack.pop()\\n            elif i==\\'+\\':\\n                stack.append(stack[-1]+stack[-2])\\n            else:\\n                stack.append(int(i))\\n        return sum(stack)\\n```",
        "level": "easy",
        "type": [
            "operation error",
            "unclosed string",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n    def calPoints(self, operations: List[str]) -> int:\n        stack=[]\n        for i in operations:\n            if i =='D':\n                stack.append(2*stack[-1])\n            elif i=='C\":\n                stack.pop()\n            elif i='+':\n                stack.append(stack[-1]+stack[-2])\n            else:\n                stack.append(int(\"i))\n        return stack==sum(stack[0])\n"
    },
    {
        "slug": "online-election",
        "description": "You are given two integer arrays persons and times. In an election, the ith vote was cast for persons[i] at time times[i].\nFor each query at a time t, find the person that was leading the election at time t. Votes cast at time t will count towards our query. In the case of a tie, the most recent vote (among tied candidates) wins.\nImplement the TopVotedCandidate class:\n\nTopVotedCandidate(int[] persons, int[] times) Initializes the object with the persons and times arrays.\nint q(int t) Returns the number of the person that was leading the election at time t according to the mentioned rules.",
        "examples": [
            "Input\n[\"TopVotedCandidate\", \"q\", \"q\", \"q\", \"q\", \"q\", \"q\"]\n[[[0, 1, 1, 0, 0, 1, 0], [0, 5, 10, 15, 20, 25, 30]], [3], [12], [25], [15], [24], [8]]\nOutput\n[null, 0, 1, 1, 0, 0, 1]\n\nExplanation\nTopVotedCandidate topVotedCandidate = new TopVotedCandidate([0, 1, 1, 0, 0, 1, 0], [0, 5, 10, 15, 20, 25, 30]);\ntopVotedCandidate.q(3); // return 0, At time 3, the votes are [0], and 0 is leading.\ntopVotedCandidate.q(12); // return 1, At time 12, the votes are [0,1,1], and 1 is leading.\ntopVotedCandidate.q(25); // return 1, At time 25, the votes are [0,1,1,0,0,1], and 1 is leading (as ties go to the most recent vote.)\ntopVotedCandidate.q(15); // return 0\ntopVotedCandidate.q(24); // return 0\ntopVotedCandidate.q(8); // return 1"
        ],
        "constraints": "1 <= persons.length <= 5000\ntimes.length == persons.length\n0 <= persons[i] < persons.length\n0 <= times[i] <= 109\ntimes is sorted in a strictly increasing order.\ntimes[0] <= t <= 109\nAt most 104 calls will be made to q.",
        "oracle_code": "class TopVotedCandidate:\n\n    def __init__(self, persons: List[int], times: List[int]):\n        self.persons = []\n        self.times = []\n        self.dic = collections.defaultdict(int)\n        self.m = 0\n        self.idx = -1\n\n        for i in range(len(times)):\n            self.times.append(times[i])\n            self.dic[persons[i]] += 1\n            if self.dic[persons[i]] >= self.m:\n                self.persons.append(persons[i])\n                self.m = self.dic[persons[i]]\n            else:\n                self.persons.append(self.persons[-1])\n\n    def q(self, t: int) -> int:\n        idx = bisect.bisect_right(self.times,t)\n        return self.persons[idx-1]",
        "content": "# Code\\n```\\nclass TopVotedCandidate:\\n\\n    def __init__(self, persons: List[int], times: List[int]):\\n        self.persons = []\\n        self.times = []\\n        self.dic = collections.defaultdict(int)\\n        self.m = 0\\n        self.idx = -1\\n\\n        for i in range(len(times)):\\n            self.times.append(times[i])\\n            self.dic[persons[i]] += 1\\n            if self.dic[persons[i]] >= self.m:\\n                self.persons.append(persons[i])\\n                self.m = self.dic[persons[i]]\\n            else:\\n                self.persons.append(self.persons[-1])\\n\\n    def q(self, t: int) -> int:\\n        idx = bisect.bisect_right(self.times,t)\\n        return self.persons[idx-1]\\n\\n```",
        "level": "medium",
        "type": [
            "indentation error",
            "operation error",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass TopVotedCandidate:\n\n    def __init__(self, persons: List[int], times: List[int]):\n        self.persons = []\n        self.times = []\n        self.dic = collections.defaultdict(int)\n        self.m = 0\n            self.idx = -1\n\n        for i in range(len(times):\n            self.times.append(times[i])\n            self.dic[persons[i]] += 1\n            if self.dic[persons[i]] >= self.m:\n                self.persons.append(persons[i])\n                self.m = self.dic[persons[i]]\n            else:\n                self.persons.append(self.persons[-1])\n\n    def q(self, t: int) -> int:\n        idx = bisect.bisect_right(self.times,t)\n        return self.persons[idx]\n"
    },
    {
        "slug": "arithmetic-slices-ii-subsequence",
        "description": "Given an integer array nums, return the number of all the arithmetic subsequences of nums.\nA sequence of numbers is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.\n\nFor example, [1, 3, 5, 7, 9], [7, 7, 7, 7], and [3, -1, -5, -9] are arithmetic sequences.\nFor example, [1, 1, 2, 5, 7] is not an arithmetic sequence.\n\nA subsequence of an array is a sequence that can be formed by removing some elements (possibly none) of the array.\n\nFor example, [2,5,10] is a subsequence of [1,2,1,2,4,1,5,10].\n\nThe test cases are generated so that the answer fits in 32-bit integer.",
        "examples": [
            "Input: nums = [2,4,6,8,10]\nOutput: 7\nExplanation: All arithmetic subsequence slices are:\n[2,4,6]\n[4,6,8]\n[6,8,10]\n[2,4,6,8]\n[4,6,8,10]\n[2,4,6,8,10]\n[2,6,10]",
            "Input: nums = [7,7,7,7,7]\nOutput: 16\nExplanation: Any subsequence of this array is arithmetic."
        ],
        "constraints": "1\u00a0 <= nums.length <= 1000\n-231 <= nums[i] <= 231 - 1",
        "oracle_code": "class Solution:\n    def numberOfArithmeticSlices(self, nums: List[int]) -> int:\n        total, n = 0, len(nums)\n        dp = [defaultdict(int) for _ in nums]\n        for i in range(1, n):\n            for j in range(i):\n                diff = nums[j] - nums[i]\n                dp[i][diff] += dp[j][diff] + 1\n                total += dp[j][diff]\n        return total",
        "content": "**Python**\\n```\\nclass Solution:\\n    def numberOfArithmeticSlices(self, nums: List[int]) -> int:\\n        total, n = 0, len(nums)\\n        dp = [defaultdict(int) for _ in nums]\\n        for i in range(1, n):\\n            for j in range(i):\\n                diff = nums[j] - nums[i]\\n                dp[i][diff] += dp[j][diff] + 1\\n                total += dp[j][diff]\\n        return total\\n```\\n\\n**Swift**\\n```\\nclass Solution {\\n    func numberOfArithmeticSlices(_ nums: [Int]) -> Int {\\n        var total = 0\\n        let n = nums.count\\n        var dp = Array(repeating: [Int: Int](), count: n)\\n        for i in 1..<n {\\n            for j in 0..<i {\\n                let diff = nums[j] - nums[i]\\n                dp[i][diff, default: 0] += dp[j][diff, default: 0] + 1\\n                total += dp[j][diff, default: 0]\\n            }\\n        }\\n        return total\\n    }\\n}\\n```",
        "level": "hard",
        "type": [
            "undefined methods",
            "parentheses mismatch",
            "wrong comment mark"
        ],
        "buggy_code": "\nclass Solution:\n    def numberOfArithmeticSlices(self, nums: List[int]) -> int:\n        total, n = 0, len(nums)\n        dp = [defaultdict(int) for _ in nums\n        for i in range(1, n):\n            for ''j in range(i):'' \n                diff = nums[j] - nums[i]\n                dp[i][diff] += dp[j][diff] + 1\n                total += self.undifned_method(dp[j][diff])\n        return total\n"
    },
    {
        "slug": "find-the-middle-index-in-array",
        "description": "Given a 0-indexed integer array nums, find the leftmost middleIndex (i.e., the smallest amongst all the possible ones).\nA middleIndex is an index where nums[0] + nums[1] + ... + nums[middleIndex-1] == nums[middleIndex+1] + nums[middleIndex+2] + ... + nums[nums.length-1].\nIf middleIndex == 0, the left side sum is considered to be 0. Similarly, if middleIndex == nums.length - 1, the right side sum is considered to be 0.\nReturn the leftmost middleIndex that satisfies the condition, or -1 if there is no such index.",
        "examples": [
            "Input: nums = [2,3,-1,8,4]\nOutput: 3\nExplanation: The sum of the numbers before index 3 is: 2 + 3 + -1 = 4\nThe sum of the numbers after index 3 is: 4 = 4",
            "Input: nums = [1,-1,4]\nOutput: 2\nExplanation: The sum of the numbers before index 2 is: 1 + -1 = 0\nThe sum of the numbers after index 2 is: 0",
            "Input: nums = [2,5]\nOutput: -1\nExplanation: There is no valid middleIndex."
        ],
        "constraints": "1 <= nums.length <= 100\n-1000 <= nums[i] <= 1000\n\n\u00a0\nNote: This question is the same as\u00a0724:\u00a0https://leetcode.com/problems/find-pivot-index/",
        "oracle_code": "class Solution:\n    def findMiddleIndex(self, nums: List[int]) -> int:\n        def dnc(l, r, lo, hi):\n            if l == r - 1:\n                return l if lo == hi else -1\n            \n            mid = (l + r) // 2\n            right = sum(nums[mid:r])\n            left = sum(nums[l:mid])\n\n            left_ind = dnc(l, mid, lo, hi + right)\n            return left_ind if left_ind != -1 else dnc(mid, r, lo + left, hi)\n        return dnc(0, len(nums), 0, 0)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSo we notice that for index `i` and index `i + 1`, most of the sum on the left and right side are shared. In particular, the left side of index `i` is `sum(nums[0..i-1])` and the left side of `i + 1` is `sum(nums[0..i-1]) + nums[i]`, so they both share `sum(nums[0..i-1]`. This is similar for the right side.\\n\\nSo we can split the problem in half, calculate the sum of the left half and calculate the sum of the right half and keep that in a cumulative sum so we don\\'t have to repeat work.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst find the sum of the left and right half of some subsection of the array (originally the entire array). Then find the middle index of the left half of the array recursively, but make sure to add on the sum of the right half you have calculated so far. Similar for the left side.\\n\\n# Complexity\\n- Time complexity: $O(n \\\\log n)$\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Space complexity: $O(n)$ (proof as an exercise to the reader)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findMiddleIndex(self, nums: List[int]) -> int:\\n        def dnc(l, r, lo, hi):\\n            if l == r - 1:\\n                return l if lo == hi else -1\\n            \\n            mid = (l + r) // 2\\n            right = sum(nums[mid:r])\\n            left = sum(nums[l:mid])\\n\\n            left_ind = dnc(l, mid, lo, hi + right)\\n            return left_ind if left_ind != -1 else dnc(mid, r, lo + left, hi)\\n        return dnc(0, len(nums), 0, 0)\\n```",
        "level": "easy",
        "type": [
            "variable value error",
            "undefined objects",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution:\n    def findMiddleIndex(self, nums: List[int]) -> int:\n        def dnc(l, r, lo, hi):\n            if l == r - 1:\n                return l if lo == hi else -1\n            \n            mid = (l + r) // 2\n            right = sum(nums[mid:r])\n            left = sum(nums[l:mid])\n            \n            var left_ind; // Undefined keyword from JavaScript\n            left_ind = dnc(l, mid, lo, hi + left)\n            return left_ind if left_ind != -1 else dnc(mid, r, lo + left, hi)\n        \n        return dnc(0, len(nums), 0, undefined_variable)\n"
    },
    {
        "slug": "valid-arrangement-of-pairs",
        "description": "You are given a 0-indexed 2D integer array pairs where pairs[i] = [starti, endi]. An arrangement of pairs is valid if for every index i where 1 <= i < pairs.length, we have endi-1 == starti.\nReturn any valid arrangement of pairs.\nNote: The inputs will be generated such that there exists a valid arrangement of pairs.",
        "examples": [
            "Input: pairs = [[5,1],[4,5],[11,9],[9,4]]\nOutput: [[11,9],[9,4],[4,5],[5,1]]\nExplanation:\nThis is a valid arrangement since endi-1 always equals starti.\nend0 = 9 == 9 = start1 \nend1 = 4 == 4 = start2\nend2 = 5 == 5 = start3",
            "Input: pairs = [[1,3],[3,2],[2,1]]\nOutput: [[1,3],[3,2],[2,1]]\nExplanation:\nThis is a valid arrangement since endi-1 always equals starti.\nend0 = 3 == 3 = start1\nend1 = 2 == 2 = start2\nThe arrangements [[2,1],[1,3],[3,2]] and [[3,2],[2,1],[1,3]] are also valid.",
            "Input: pairs = [[1,2],[1,3],[2,1]]\nOutput: [[1,2],[2,1],[1,3]]\nExplanation:\nThis is a valid arrangement since endi-1 always equals starti.\nend0 = 2 == 2 = start1\nend1 = 1 == 1 = start2"
        ],
        "constraints": "1 <= pairs.length <= 105\npairs[i].length == 2\n0 <= starti, endi <= 109\nstarti != endi\nNo two pairs are exactly the same.\nThere exists a valid arrangement of pairs.",
        "oracle_code": "class Solution:\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\n        graph = defaultdict(list)\n        degree = defaultdict(int) # net out degree \n        for x, y in pairs: \n            graph[x].append(y)\n            degree[x] += 1\n            degree[y] -= 1\n                \n        for k in degree: \n            if degree[k] == 1: \n                x = k\n                break \n                \n        ans = []\n\n        def fn(x): \n            \"\"\"Return Eulerian path via dfs.\"\"\"\n            while graph[x]: fn(graph[x].pop()) \n            ans.append(x)\n        \n        fn(x)\n        ans.reverse()\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]",
        "content": "Please check out this [commit](https://github.com/gaosanyong/leetcode/commit/b1948f8814bebeca475cbb354cd44d19092dff59) for solutions of weekly 270.\\n\\n```\\nclass Solution:\\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\\n        graph = defaultdict(list)\\n        degree = defaultdict(int) # net out degree \\n        for x, y in pairs: \\n            graph[x].append(y)\\n            degree[x] += 1\\n            degree[y] -= 1\\n                \\n        for k in degree: \\n            if degree[k] == 1: \\n                x = k\\n                break \\n                \\n        ans = []\\n\\n        def fn(x): \\n            \"\"\"Return Eulerian path via dfs.\"\"\"\\n            while graph[x]: fn(graph[x].pop()) \\n            ans.append(x)\\n        \\n        fn(x)\\n        ans.reverse()\\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]\\n```\\n\\nAdding an iterative implementation of Hieholzer\\'s algo from @delphih\\n```\\nclass Solution:\\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\\n        graph = defaultdict(list)\\n        degree = defaultdict(int) # net out degree \\n        for x, y in pairs: \\n            graph[x].append(y)\\n            degree[x] += 1\\n            degree[y] -= 1\\n                \\n        for k in degree: \\n            if degree[k] == 1: \\n                x = k\\n                break \\n                \\n        ans = []\\n        stack = [x]\\n        while stack: \\n            while graph[stack[-1]]: \\n                stack.append(graph[stack[-1]].pop())\\n            ans.append(stack.pop())\\n        ans.reverse()\\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]\\n```",
        "level": "hard",
        "type": [
            "undefined methods",
            "undefined keywords from other languages",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n    function validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\n        graph = defaultdict(list)\n        degree = defaultdict(int) # net out degree \n        for x, y in pairs: \n            graph[x].append(y)\n            degree[x] += 1\n            degree[y] -= 1\n                \n        for k in degree: \n            if degree[k] = 1: \n                x = k\n                break \n                \n        ans = []\n\n        function fn(x): \n            \"\"\"Return Eulerian path via dfs.\"\"\"\n            while graph[x]: fn(graph[x].pop()) \n            ans.append(x)\n        \n        dfn(s)\n        ans.reverse()\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]\n"
    },
    {
        "slug": "longest-happy-prefix",
        "description": "A string is called a happy prefix if is a non-empty prefix which is also a suffix (excluding itself).\nGiven a string s, return the longest happy prefix of s. Return an empty string \"\" if no such prefix exists.",
        "examples": [
            "Input: s = \"level\"\nOutput: \"l\"\nExplanation: s contains 4 prefix excluding itself (\"l\", \"le\", \"lev\", \"leve\"), and suffix (\"l\", \"el\", \"vel\", \"evel\"). The largest prefix which is also suffix is given by \"l\".",
            "Input: s = \"ababab\"\nOutput: \"abab\"\nExplanation: \"abab\" is the largest prefix which is also suffix. They can overlap in the original string."
        ],
        "constraints": "1 <= s.length <= 105\ns contains only lowercase English letters.",
        "oracle_code": "class Solution:\n    def longestPrefix(self, s: str) -> str:\n        n=len(s)\n        lps=[0]*n\n        j=0\n        for i in range(1,n):\n            while s[i]!=s[j] and j>0:\n                j=lps[j-1]\n\n            if s[i]==s[j]:\n                lps[i]=j+1\n                j+=1\n\n        return s[:lps[-1]]",
        "content": "# Please upvote if it is helpful ^_^\\n***6Companies30days #ReviseWithArsh Challenge 2023\\nDay2\\nQ12. Longest Happy Prefix***\\n\\n**Approach:** *KMP Approach, DP*\\n\\n![12.longest-happy-prefix.jpg](https://assets.leetcode.com/users/images/368329ab-8eb6-4ddb-8c57-fc07336b759d_1672917737.342274.jpeg)\\n\\n**Complexity:** *O(M+N)*\\n\\n# Code\\n**Python3:**\\n```\\nclass Solution:\\n    def longestPrefix(self, s: str) -> str:\\n        n=len(s)\\n        lps=[0]*n\\n        j=0\\n        for i in range(1,n):\\n            while s[i]!=s[j] and j>0:\\n                j=lps[j-1]\\n\\n            if s[i]==s[j]:\\n                lps[i]=j+1\\n                j+=1\\n\\n        return s[:lps[-1]]\\n```",
        "level": "hard",
        "type": [
            "undefined methods",
            "colon missing",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n    def longestPrefix(self, s: str) -> str:\n        n=len(s)\n        lps=[0]*n\n        j=0\n        for i in range(1,n)\n            if not self.compareChar(s, i, j):\n                j=lps[j-1]\n\n            if s[i]=s[j]:\n                lps[i]=j+1\n                j+=1\n\n        return s[:lps[-1]]\n"
    },
    {
        "slug": "valid-arrangement-of-pairs",
        "description": "You are given a 0-indexed 2D integer array pairs where pairs[i] = [starti, endi]. An arrangement of pairs is valid if for every index i where 1 <= i < pairs.length, we have endi-1 == starti.\nReturn any valid arrangement of pairs.\nNote: The inputs will be generated such that there exists a valid arrangement of pairs.",
        "examples": [
            "Input: pairs = [[5,1],[4,5],[11,9],[9,4]]\nOutput: [[11,9],[9,4],[4,5],[5,1]]\nExplanation:\nThis is a valid arrangement since endi-1 always equals starti.\nend0 = 9 == 9 = start1 \nend1 = 4 == 4 = start2\nend2 = 5 == 5 = start3",
            "Input: pairs = [[1,3],[3,2],[2,1]]\nOutput: [[1,3],[3,2],[2,1]]\nExplanation:\nThis is a valid arrangement since endi-1 always equals starti.\nend0 = 3 == 3 = start1\nend1 = 2 == 2 = start2\nThe arrangements [[2,1],[1,3],[3,2]] and [[3,2],[2,1],[1,3]] are also valid.",
            "Input: pairs = [[1,2],[1,3],[2,1]]\nOutput: [[1,2],[2,1],[1,3]]\nExplanation:\nThis is a valid arrangement since endi-1 always equals starti.\nend0 = 2 == 2 = start1\nend1 = 1 == 1 = start2"
        ],
        "constraints": "1 <= pairs.length <= 105\npairs[i].length == 2\n0 <= starti, endi <= 109\nstarti != endi\nNo two pairs are exactly the same.\nThere exists a valid arrangement of pairs.",
        "oracle_code": "class Solution:\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\n        graph = defaultdict(list)\n        degree = defaultdict(int) # net out degree \n        for x, y in pairs: \n            graph[x].append(y)\n            degree[x] += 1\n            degree[y] -= 1\n                \n        for k in degree: \n            if degree[k] == 1: \n                x = k\n                break \n                \n        ans = []\n\n        def fn(x): \n            \"\"\"Return Eulerian path via dfs.\"\"\"\n            while graph[x]: fn(graph[x].pop()) \n            ans.append(x)\n        \n        fn(x)\n        ans.reverse()\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]",
        "content": "Please check out this [commit](https://github.com/gaosanyong/leetcode/commit/b1948f8814bebeca475cbb354cd44d19092dff59) for solutions of weekly 270.\\n\\n```\\nclass Solution:\\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\\n        graph = defaultdict(list)\\n        degree = defaultdict(int) # net out degree \\n        for x, y in pairs: \\n            graph[x].append(y)\\n            degree[x] += 1\\n            degree[y] -= 1\\n                \\n        for k in degree: \\n            if degree[k] == 1: \\n                x = k\\n                break \\n                \\n        ans = []\\n\\n        def fn(x): \\n            \"\"\"Return Eulerian path via dfs.\"\"\"\\n            while graph[x]: fn(graph[x].pop()) \\n            ans.append(x)\\n        \\n        fn(x)\\n        ans.reverse()\\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]\\n```\\n\\nAdding an iterative implementation of Hieholzer\\'s algo from @delphih\\n```\\nclass Solution:\\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\\n        graph = defaultdict(list)\\n        degree = defaultdict(int) # net out degree \\n        for x, y in pairs: \\n            graph[x].append(y)\\n            degree[x] += 1\\n            degree[y] -= 1\\n                \\n        for k in degree: \\n            if degree[k] == 1: \\n                x = k\\n                break \\n                \\n        ans = []\\n        stack = [x]\\n        while stack: \\n            while graph[stack[-1]]: \\n                stack.append(graph[stack[-1]].pop())\\n            ans.append(stack.pop())\\n        ans.reverse()\\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]\\n```",
        "level": "hard",
        "type": [
            "undefined keywords from other languages",
            "unclosed string",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    function validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\n        graph = defaultdict(list)\n        degree = defaultdict(int) # net out degree \n        for x, y in pairs: \n            graph[x].append(y)\n            degree[x] += 1\n            degree[y] -= 1\n                \n        for k in degree: \n            if degree[k] != 1: \n                x = k\n                break \n                \n        ans = []\n\n        function fn(x): \n            \"\"\"Return Eulerian path via dfs.\"\n            while graph[x]: fn(graph[x].pop()) \n            ans.append(x)\n        \n        fn(x)\n        ans.reverse()\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]\n"
    },
    {
        "slug": "minimum-obstacle-removal-to-reach-corner",
        "description": "You are given a 0-indexed 2D integer array grid of size m x n. Each cell has one of two values:\n\n0 represents an empty cell,\n1 represents an obstacle that may be removed.\n\nYou can move up, down, left, or right from and to an empty cell.\nReturn the minimum number of obstacles to remove so you can move from the upper left corner (0, 0) to the lower right corner (m - 1, n - 1).",
        "examples": [
            "Input: grid = [[0,1,1],[1,1,0],[1,1,0]]\nOutput: 2\nExplanation: We can remove the obstacles at (0, 1) and (0, 2) to create a path from (0, 0) to (2, 2).\nIt can be shown that we need to remove at least 2 obstacles, so we return 2.\nNote that there may be other ways to remove 2 obstacles to create a path.",
            "Input: grid = [[0,1,0,0,0],[0,1,0,1,0],[0,0,0,1,0]]\nOutput: 0\nExplanation: We can move from (0, 0) to (2, 4) without removing any obstacles, so we return 0."
        ],
        "constraints": "m == grid.length\nn == grid[i].length\n1 <= m, n <= 105\n2 <= m * n <= 105\ngrid[i][j] is either 0 or 1.\ngrid[0][0] == grid[m - 1][n - 1] == 0",
        "oracle_code": "class Solution:\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n        distance[0][0] = 0\n        q = collections.deque([(0, 0, 0)])\n        while q:\n            d, i, j = q.popleft()\n            if i == m - 1 and j == n - 1: return d\n            for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                ci, cj = i + di, j + dj\n                if 0 <= ci < m and 0 <= cj < n:\n                    if d + grid[ci][cj] < distance[ci][cj]:\n                        distance[ci][cj] = d + grid[ci][cj]\n                        if grid[ci][cj] == 1: q.append((distance[ci][cj], ci, cj))\n                        else: q.appendleft((distance[ci][cj], ci, cj))\n        return distance[m - 1][n - 1]",
        "content": "# Intuition\\nFind the shortest path with the weight is only 0 or 1 => 0-1 BFS\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\ncan refer 0-1 BFS [here](https://cp-algorithms.com/graph/01_bfs.html#algorithm)\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(E)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(E)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        distance = [[float(\\'inf\\') for _ in range(n)] for _ in range(m)]\\n        distance[0][0] = 0\\n        q = collections.deque([(0, 0, 0)])\\n        while q:\\n            d, i, j = q.popleft()\\n            if i == m - 1 and j == n - 1: return d\\n            for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\\n                ci, cj = i + di, j + dj\\n                if 0 <= ci < m and 0 <= cj < n:\\n                    if d + grid[ci][cj] < distance[ci][cj]:\\n                        distance[ci][cj] = d + grid[ci][cj]\\n                        if grid[ci][cj] == 1: q.append((distance[ci][cj], ci, cj))\\n                        else: q.appendleft((distance[ci][cj], ci, cj))\\n        return distance[m - 1][n - 1]\\n```",
        "level": "hard",
        "type": [
            "undefined methods",
            "variable value error",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution:\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\n        undefined_variable.m, n = len(grid), len(grid[0])\n        distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n        distance[0][0] = 0\n        q = collections.deque([(0, 0, 0)])\n        while q:\n            d, i, j = q.popleft()\n            if i == m - 1 and j == n - 1: return d\n            for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                ci, cj = i + di, j + dj\n                if 0 <= ci < m and 0 <= cj < n:\n                    if self.lessThan(d + grid[ci][cj], distance[ci][cj]):\n                        distance[ci][cj] = self.sum(d, grid[ci][cj])\n                        if grid[ci][cj] == 1: q.append((distance[ci][cj], ci, cj))\n                        else: q.appendleft((distance[ci][cj], ci, cj))\n                else: q.appendleft((distance[i][j], i, j))\n        return distance[m - 1][n - 1]\n"
    },
    {
        "slug": "baseball-game",
        "description": "You are keeping the scores for a baseball game with strange rules. At the beginning of the game, you start with an empty record.\nYou are given a list of strings operations, where operations[i] is the ith operation you must apply to the record and is one of the following:\n\nAn integer x.\n\n\t\nRecord a new score of x.\n\n\n'+'.\n\t\nRecord a new score that is the sum of the previous two scores.\n\n\n'D'.\n\t\nRecord a new score that is the double of the previous score.\n\n\n'C'.\n\t\nInvalidate the previous score, removing it from the record.\n\n\n\nReturn the sum of all the scores on the record after applying all the operations.\nThe test cases are generated such that the answer and all intermediate calculations fit in a 32-bit integer and that all operations are valid.",
        "examples": [
            "Input: ops = [\"5\",\"2\",\"C\",\"D\",\"+\"]\nOutput: 30\nExplanation:\n\"5\" - Add 5 to the record, record is now [5].\n\"2\" - Add 2 to the record, record is now [5, 2].\n\"C\" - Invalidate and remove the previous score, record is now [5].\n\"D\" - Add 2 * 5 = 10 to the record, record is now [5, 10].\n\"+\" - Add 5 + 10 = 15 to the record, record is now [5, 10, 15].\nThe total sum is 5 + 10 + 15 = 30.",
            "Input: ops = [\"5\",\"-2\",\"4\",\"C\",\"D\",\"9\",\"+\",\"+\"]\nOutput: 27\nExplanation:\n\"5\" - Add 5 to the record, record is now [5].\n\"-2\" - Add -2 to the record, record is now [5, -2].\n\"4\" - Add 4 to the record, record is now [5, -2, 4].\n\"C\" - Invalidate and remove the previous score, record is now [5, -2].\n\"D\" - Add 2 * -2 = -4 to the record, record is now [5, -2, -4].\n\"9\" - Add 9 to the record, record is now [5, -2, -4, 9].\n\"+\" - Add -4 + 9 = 5 to the record, record is now [5, -2, -4, 9, 5].\n\"+\" - Add 9 + 5 = 14 to the record, record is now [5, -2, -4, 9, 5, 14].\nThe total sum is 5 + -2 + -4 + 9 + 5 + 14 = 27.",
            "Input: ops = [\"1\",\"C\"]\nOutput: 0\nExplanation:\n\"1\" - Add 1 to the record, record is now [1].\n\"C\" - Invalidate and remove the previous score, record is now [].\nSince the record is empty, the total sum is 0."
        ],
        "constraints": "1 <= operations.length <= 1000\noperations[i] is \"C\", \"D\", \"+\", or a string representing an integer in the range [-3 * 104, 3 * 104].\nFor operation \"+\", there will always be at least two previous scores on the record.\nFor operations \"C\" and \"D\", there will always be at least one previous score on the record.",
        "oracle_code": "class Solution:\n    def calPoints(self, operations: List[str]) -> int:\n        stack=[]\n        for i in operations:\n            if i =='D':\n                stack.append(2*stack[-1])\n            elif i=='C':\n                stack.pop()\n            elif i=='+':\n                stack.append(stack[-1]+stack[-2])\n            else:\n                stack.append(int(i))\n        return sum(stack)",
        "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def calPoints(self, operations: List[str]) -> int:\\n        stack=[]\\n        for i in operations:\\n            if i ==\\'D\\':\\n                stack.append(2*stack[-1])\\n            elif i==\\'C\\':\\n                stack.pop()\\n            elif i==\\'+\\':\\n                stack.append(stack[-1]+stack[-2])\\n            else:\\n                stack.append(int(i))\\n        return sum(stack)\\n```",
        "level": "easy",
        "type": [
            "operation error",
            "undefined keywords from other languages",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n    def calPoints(self, operations: List[str]) -> int:\n        stack=[]\n        for i in operations:\n            if i =='D':\n                stack.append(2*math.notify(stack[-1]))\n            elif i=='C':\n                stack.pop()\n            elif i='+':\n                stack.append(stack[-1]+stack[-2])\n            else:\n                stack.append(int(i))\n        return stack==sum(stack[0])\n"
    },
    {
        "slug": "restore-ip-addresses",
        "description": "A valid IP address consists of exactly four integers separated by single dots. Each integer is between 0 and 255 (inclusive) and cannot have leading zeros.\n\nFor example, \"0.1.2.201\" and \"192.168.1.1\" are valid IP addresses, but \"0.011.255.245\", \"192.168.1.312\" and \"192.168@1.1\" are invalid IP addresses.\n\nGiven a string s containing only digits, return all possible valid IP addresses that can be formed by inserting dots into s. You are not allowed to reorder or remove any digits in s. You may return the valid IP addresses in any order.",
        "examples": [
            "Input: s = \"25525511135\"\nOutput: [\"255.255.11.135\",\"255.255.111.35\"]",
            "Input: s = \"0000\"\nOutput: [\"0.0.0.0\"]",
            "Input: s = \"101023\"\nOutput: [\"1.0.10.23\",\"1.0.102.3\",\"10.1.0.23\",\"10.10.2.3\",\"101.0.2.3\"]"
        ],
        "constraints": "1 <= s.length <= 20\ns consists of digits only.",
        "oracle_code": "class Solution:\n    def restoreIpAddresses(self, s: str) -> List[str]:\n        res=[]\n        cur=[]\n        def backtrack(i):\n            if i==len(s) and len(cur)==4:\n                res.append(\".\".join(cur))\n                return\n            if len(cur)>4 or i>=len(s):\n                return\n            if s[i]=='0':\n                cur.append(s[i])\n                backtrack(i+1)\n                cur.pop()\n                return\n            j=0\n            while j<4 and i+j<len(s):\n                if int(s[i:i+j+1])<256:\n                    cur.append(s[i:i+j+1])\n                    backtrack(i+j+1)\n                    cur.pop()\n                j+=1\n        backtrack(0)\n        return res",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\njust take care with the processing number should be lower than len(s) and the length of current stack should be lower or equal 4.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(4)\\n# Code\\n```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        res=[]\\n        cur=[]\\n        def backtrack(i):\\n            if i==len(s) and len(cur)==4:\\n                res.append(\".\".join(cur))\\n                return\\n            if len(cur)>4 or i>=len(s):\\n                return\\n            if s[i]==\\'0\\':\\n                cur.append(s[i])\\n                backtrack(i+1)\\n                cur.pop()\\n                return\\n            j=0\\n            while j<4 and i+j<len(s):\\n                if int(s[i:i+j+1])<256:\\n                    cur.append(s[i:i+j+1])\\n                    backtrack(i+j+1)\\n                    cur.pop()\\n                j+=1\\n        backtrack(0)\\n        return res\\n\\n```",
        "level": "medium",
        "type": [
            "colon missing",
            "parentheses mismatch",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution():\n    def restoreIpAddresses(self, s: str) -> List[str]:\n        res=[]\n        cur=[]\n        def backtrack(i:\n            if i=len(s) and len(cur)==4:\n                res.append(\".\".join(cur))\n                return\n            if len(cur)>4 or i>=len(s):\n                return\n            if s[i]=='0':\n                cur.append(s[i])\n                backtrack(i+1)\n                cur.pop()\n                return\n            j=0\n            while j<4 and i+j<len(s)\n                if int(s[i:i+j+1])<256:\n                    cur.append(s[i:i+j+1])\n                    backtrack(i+j+1)\n                    cur.pop()\n                j+=1\n        backtrack(0)\n        return res\n"
    },
    {
        "slug": "restore-ip-addresses",
        "description": "A valid IP address consists of exactly four integers separated by single dots. Each integer is between 0 and 255 (inclusive) and cannot have leading zeros.\n\nFor example, \"0.1.2.201\" and \"192.168.1.1\" are valid IP addresses, but \"0.011.255.245\", \"192.168.1.312\" and \"192.168@1.1\" are invalid IP addresses.\n\nGiven a string s containing only digits, return all possible valid IP addresses that can be formed by inserting dots into s. You are not allowed to reorder or remove any digits in s. You may return the valid IP addresses in any order.",
        "examples": [
            "Input: s = \"25525511135\"\nOutput: [\"255.255.11.135\",\"255.255.111.35\"]",
            "Input: s = \"0000\"\nOutput: [\"0.0.0.0\"]",
            "Input: s = \"101023\"\nOutput: [\"1.0.10.23\",\"1.0.102.3\",\"10.1.0.23\",\"10.10.2.3\",\"101.0.2.3\"]"
        ],
        "constraints": "1 <= s.length <= 20\ns consists of digits only.",
        "oracle_code": "class Solution:\n    def restoreIpAddresses(self, s: str) -> List[str]:\n        res=[]\n        cur=[]\n        def backtrack(i):\n            if i==len(s) and len(cur)==4:\n                res.append(\".\".join(cur))\n                return\n            if len(cur)>4 or i>=len(s):\n                return\n            if s[i]=='0':\n                cur.append(s[i])\n                backtrack(i+1)\n                cur.pop()\n                return\n            j=0\n            while j<4 and i+j<len(s):\n                if int(s[i:i+j+1])<256:\n                    cur.append(s[i:i+j+1])\n                    backtrack(i+j+1)\n                    cur.pop()\n                j+=1\n        backtrack(0)\n        return res",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\njust take care with the processing number should be lower than len(s) and the length of current stack should be lower or equal 4.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(4)\\n# Code\\n```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        res=[]\\n        cur=[]\\n        def backtrack(i):\\n            if i==len(s) and len(cur)==4:\\n                res.append(\".\".join(cur))\\n                return\\n            if len(cur)>4 or i>=len(s):\\n                return\\n            if s[i]==\\'0\\':\\n                cur.append(s[i])\\n                backtrack(i+1)\\n                cur.pop()\\n                return\\n            j=0\\n            while j<4 and i+j<len(s):\\n                if int(s[i:i+j+1])<256:\\n                    cur.append(s[i:i+j+1])\\n                    backtrack(i+j+1)\\n                    cur.pop()\\n                j+=1\\n        backtrack(0)\\n        return res\\n\\n```",
        "level": "medium",
        "type": [
            "parentheses mismatch",
            "unclosed string",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution():\n    def restoreIpAddresses(self, s: str) -> List[str]:\n        res=[]\n        cur=[]\n        def backtrack(i:\n            if i==len(s) and len(cur)==4:\n                res.append(\".\".join(cur))\n                return\n            if len(cur)>4 or i>len(s):\n                return\n            if s[i]=='0':\n                cur.append(s[i])\n                backtrack(i+1)\n                cur.pop()\n                return\n            j=0\n            while j<4 and i+j<len(s):\n                if int(s[i:i+j+1])<256:\n                    cur.append(s[i:i+j+1])\n                    backtrack(i+j+1)\n                    cur.pop()\n                j+=1\n        backtrack(0)\n        return 'res\n"
    },
    {
        "slug": "can-place-flowers",
        "description": "You have a long flowerbed in which some of the plots are planted, and some are not. However, flowers cannot be planted in adjacent plots.\nGiven an integer array flowerbed containing 0's and 1's, where 0 means empty and 1 means not empty, and an integer n, return true\u00a0if n new flowers can be planted in the flowerbed without violating the no-adjacent-flowers rule and false otherwise.",
        "examples": [
            "Input: flowerbed = [1,0,0,0,1], n = 1\nOutput: true",
            "Input: flowerbed = [1,0,0,0,1], n = 2\nOutput: false"
        ],
        "constraints": "1 <= flowerbed.length <= 2 * 104\nflowerbed[i] is 0 or 1.\nThere are no two adjacent flowers in flowerbed.\n0 <= n <= flowerbed.length",
        "oracle_code": "class Solution:\n    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:\n        flowerbed=[0]+flowerbed+[0]\n        for i in range(1,len(flowerbed)-1):\n            if flowerbed[i]==0 and flowerbed[i+1]==0 and flowerbed[i-1]==0:flowerbed[i]=1;n-=1\n        if n<=0:return True\n        return False",
        "content": "![image.png](https://assets.leetcode.com/users/images/c82b49a3-d51e-40a4-b4b5-197596cb28f2_1691328287.5834074.png)\\n\\n\\n\\n\\n\\nPLease UPVOTE \\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:\\n        flowerbed=[0]+flowerbed+[0]\\n        for i in range(1,len(flowerbed)-1):\\n            if flowerbed[i]==0 and flowerbed[i+1]==0 and flowerbed[i-1]==0:flowerbed[i]=1;n-=1\\n        if n<=0:return True\\n        return False\\n```",
        "level": "easy",
        "type": [
            "colon missing",
            "undefined keywords from other languages",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:\n        flowerbed=[0]+flowerbed+[0]\n        for i in range(1,len(flowerbed)-1)\n            if (flowerbed[i]==0 and flowerbed[i+1]=0 and flowerbed[i-1]==0): flowerbed[i]=1; n-=1\n            else if(flowerbed[i]==1): n-=1\n        if n<=0:return True\n        return False\n"
    },
    {
        "slug": "max-points-on-a-line",
        "description": "Given an array of points where points[i] = [xi, yi] represents a point on the X-Y plane, return the maximum number of points that lie on the same straight line.",
        "examples": [
            "Input: points = [[1,1],[2,2],[3,3]]\nOutput: 3",
            "Input: points = [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]\nOutput: 4"
        ],
        "constraints": "1 <= points.length <= 300\npoints[i].length == 2\n-104 <= xi, yi <= 104\nAll the points are unique.",
        "oracle_code": "from collections import defaultdict\nclass Solution:\n    def maxPoints(self, points: List[List[int]]) -> int:\n        N = len(points)\n        D = defaultdict(set)\n        if N <= 2:\n            return N \n        for i in range(N):\n            x1, y1 = points[i]\n            for j in range(i+1, N):\n                x2, y2 = points[j]\n                if y1 == y2:\n                    k1, k2 = 'inf', y1\n                elif x1 == x2:\n                    k1, k2 = x1, 'inf'\n                else:\n                    k1, k2 = (x1-x2)/(y2-y1), (x2*y1-x1*y2)/(y2-y1)\n                D[(k1,k2)].add(tuple(points[i]))\n                D[(k1,k2)].add(tuple(points[j]))\n        return max([len(i) for i in D.values()])",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        N = len(points)\\n        D = defaultdict(set)\\n        if N <= 2:\\n            return N \\n        for i in range(N):\\n            x1, y1 = points[i]\\n            for j in range(i+1, N):\\n                x2, y2 = points[j]\\n                if y1 == y2:\\n                    k1, k2 = \\'inf\\', y1\\n                elif x1 == x2:\\n                    k1, k2 = x1, \\'inf\\'\\n                else:\\n                    k1, k2 = (x1-x2)/(y2-y1), (x2*y1-x1*y2)/(y2-y1)\\n                D[(k1,k2)].add(tuple(points[i]))\\n                D[(k1,k2)].add(tuple(points[j]))\\n        return max([len(i) for i in D.values()])\\n        \\n\\n```",
        "level": "hard",
        "type": [
            "unclosed string",
            "== and = confusion",
            "indexing error"
        ],
        "buggy_code": "\nfrom collections import defaultdict\nclass Solution:\n    def maxPoints(self, points: List[List[int]]) -> int:\n        N = len(points)\n        D = defaultdict(set)\n        if N <= 2:\n            return N \n        for i in range(N+1):     \n            x1, y1 = points[i]\n            for j in range(i+1, N):\n                x2, y2 = points[j]\n                if y1 = y2:\n                    k1, k2 = 'inf', y1\n                elif x1 = x2:\n                    k1, k2 = x1, 'inf\n                else:\n                    k1, k2 = (x1-x2)/(y2-y1), (x2*y1-x1*y2)/(y2-y1)\n                D[(k1,k2)].add(tuple(points[i]))\n                D[(k1,k2)].add(tuple(points[j]))\n        return max([len(i) for i in D.values()])\n"
    },
    {
        "slug": "kth-largest-element-in-an-array",
        "description": "Given an integer array nums and an integer k, return the kth largest element in the array.\nNote that it is the kth largest element in the sorted order, not the kth distinct element.\nCan you solve it without sorting?",
        "examples": [
            "Input: nums = [3,2,1,5,6,4], k = 2\nOutput: 5",
            "Input: nums = [3,2,3,1,2,4,5,5,6], k = 4\nOutput: 4"
        ],
        "constraints": "1 <= k <= nums.length <= 105\n-104 <= nums[i] <= 104",
        "oracle_code": "class Solution:\n    def findKthLargest(self, nums: List[int], k: int) -> int:\n        return sorted(nums)[-k]",
        "content": "# Approach\\n- Sorting\\n\\n# Complexity\\n- Time complexity: O(n*log(n))\\n\\n# Code\\n```\\nclass Solution:\\n    def findKthLargest(self, nums: List[int], k: int) -> int:\\n        return sorted(nums)[-k]\\n```",
        "level": "medium",
        "type": [
            "colon missing",
            "operation error",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution\n    def findKthLargest(self, nums: List[int], k: int) -> int:\n        return sorted(no_nums)[-k-1]\n"
    },
    {
        "slug": "string-compression-ii",
        "description": "Run-length encoding is a string compression method that works by\u00a0replacing consecutive identical characters (repeated 2 or more times) with the concatenation of the character and the number marking the count of the characters (length of the run). For example, to compress the string\u00a0\"aabccc\"\u00a0we replace \"aa\"\u00a0by\u00a0\"a2\"\u00a0and replace \"ccc\"\u00a0by\u00a0\"c3\". Thus the compressed string becomes \"a2bc3\".\nNotice that in this problem, we are not adding\u00a0'1'\u00a0after single characters.\nGiven a\u00a0string s\u00a0and an integer k. You need to delete at most\u00a0k characters from\u00a0s\u00a0such that the run-length encoded version of s\u00a0has minimum length.\nFind the minimum length of the run-length encoded\u00a0version of s after deleting at most k characters.",
        "examples": [
            "Input: s = \"aaabcccd\", k = 2\nOutput: 4\nExplanation: Compressing s without deleting anything will give us \"a3bc3d\" of length 6. Deleting any of the characters 'a' or 'c' would at most decrease the length of the compressed string to 5, for instance delete 2 'a' then we will have s = \"abcccd\" which compressed is abc3d. Therefore, the optimal way is to delete 'b' and 'd', then the compressed version of s will be \"a3c3\" of length 4.",
            "Input: s = \"aabbaa\", k = 2\nOutput: 2\nExplanation: If we delete both 'b' characters, the resulting compressed string would be \"a4\" of length 2.",
            "Input: s = \"aaaaaaaaaaa\", k = 0\nOutput: 3\nExplanation: Since k is zero, we cannot delete anything. The compressed string is \"a11\" of length 3."
        ],
        "constraints": "1 <= s.length <= 100\n0 <= k <= s.length\ns contains only lowercase English letters.",
        "oracle_code": "class Solution:\n    def dp(self,i,s,prev,k,ct,n,dct):\n        if k<0:\n            return float(\"infinity\")\n        if i>=n:\n            x=0\n            if ct>1:\n                x=len(str(ct))+1\n            elif ct==1:\n                x=1\n            return x\n        if (i,prev,ct,k) in dct:\n            return dct[(i,prev,ct,k)]\n        if s[i]==prev:\n            inc=self.dp(i+1,s,prev,k,ct+1,n,dct)\n        else:\n            x=0\n            if ct>1:\n                x=len(str(ct))+1\n            elif ct==1:\n                x=1\n            inc=x+self.dp(i+1,s,s[i],k,1,n,dct)\n        exc=self.dp(i+1,s,prev,k-1,ct,n,dct)\n        dct[(i,prev,ct,k)]=min(inc,exc)\n        return min(inc,exc)\n\n\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n        n=len(s)\n        return self.dp(0,s,\"\",k,0,n,{})",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def dp(self,i,s,prev,k,ct,n,dct):\\n        if k<0:\\n            return float(\"infinity\")\\n        if i>=n:\\n            x=0\\n            if ct>1:\\n                x=len(str(ct))+1\\n            elif ct==1:\\n                x=1\\n            return x\\n        if (i,prev,ct,k) in dct:\\n            return dct[(i,prev,ct,k)]\\n        if s[i]==prev:\\n            inc=self.dp(i+1,s,prev,k,ct+1,n,dct)\\n        else:\\n            x=0\\n            if ct>1:\\n                x=len(str(ct))+1\\n            elif ct==1:\\n                x=1\\n            inc=x+self.dp(i+1,s,s[i],k,1,n,dct)\\n        exc=self.dp(i+1,s,prev,k-1,ct,n,dct)\\n        dct[(i,prev,ct,k)]=min(inc,exc)\\n        return min(inc,exc)\\n\\n\\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\\n        n=len(s)\\n        return self.dp(0,s,\"\",k,0,n,{})\\n\\n        \\n```",
        "level": "hard",
        "type": [
            "parentheses mismatch",
            "unclosed string",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n    def dp(self,i,s,prev,k,ct,n,dct:\n        if k<0:\n            return float(\"infinity\")\n        if i>=n:\n            x=0\n            if ct>1:\n                x=len(str(ct))+1\n            elif ct==1:\n                x=1\n            return x\n        if (i,prev,ct,k) in dct:\n            return dct[(i,prev,ct,k)]\n        if s[i]==prev:\n            inc=self.dp(i+1,s,prev,k,ct+1,n,dct)\n        else:\n            x=0\n            if ct>1:\n                x=len(str(ct))+1\n            elif ct==1:\n                x=1\n            inc=x+self.dp(i+1,s,s[i],k,1,n,dct)\n        exc=self.dp(i+1,s,prev,k-1,ct,n,dct)\n        dct[(i,prev,ct,k)]='min(inc,exc) == 0\n        return min(inc,exc)\n\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n        n=len(s)\n        return self.dp(0,s,\"\",k,0,n,{})\n"
    },
    {
        "slug": "delete-greatest-value-in-each-row",
        "description": "You are given an m x n matrix grid consisting of positive integers.\nPerform the following operation until grid becomes empty:\n\nDelete the element with the greatest value from each row. If multiple such elements exist, delete any of them.\nAdd the maximum of deleted elements to the answer.\n\nNote that the number of columns decreases by one after each operation.\nReturn the answer after performing the operations described above.",
        "examples": [
            "Input: grid = [[1,2,4],[3,3,1]]\nOutput: 8\nExplanation: The diagram above shows the removed values in each step.\n- In the first operation, we remove 4 from the first row and 3 from the second row (notice that, there are two cells with value 3 and we can remove any of them). We add 4 to the answer.\n- In the second operation, we remove 2 from the first row and 3 from the second row. We add 3 to the answer.\n- In the third operation, we remove 1 from the first row and 1 from the second row. We add 1 to the answer.\nThe final answer = 4 + 3 + 1 = 8.",
            "Input: grid = [[10]]\nOutput: 10\nExplanation: The diagram above shows the removed values in each step.\n- In the first operation, we remove 10 from the first row. We add 10 to the answer.\nThe final answer = 10."
        ],
        "constraints": "m == grid.length\nn == grid[i].length\n1 <= m, n <= 50\n1 <= grid[i][j] <= 100",
        "oracle_code": "class Solution:\n    def deleteGreatestValue(self, grid: List[List[int]]) -> int:\n        for i in range(0, len(grid)):\n            grid[i].sort()\n        n = len(grid[0])\n        res = 0\n        for j in range(0, n):\n            ans = 0\n            for i in range(0, len(grid)):\n                ans = max(ans, grid[i].pop())\n            res += ans\n            \n        return res",
        "content": "# Code\\n```\\nclass Solution:\\n    def deleteGreatestValue(self, grid: List[List[int]]) -> int:\\n        for i in range(0, len(grid)):\\n            grid[i].sort()\\n        n = len(grid[0])\\n        res = 0\\n        for j in range(0, n):\\n            ans = 0\\n            for i in range(0, len(grid)):\\n                ans = max(ans, grid[i].pop())\\n            res += ans\\n            \\n        return res\\n```",
        "level": "easy",
        "type": [
            "indentation error",
            "indexing error",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def deleteGreatestValue(self, grid: List[List[int]]) -> int:\n    for i in range(0, len(grid)):\n        grid[i].sort()\n    n = len(grid[0])\n    res = 0\n    for j in range(0, n+1):\n        ans = 0\n        for i in range(0, len(grid)):\n            ans = max(ans, grid[i].pop(-j))  \n        res += ans\n            \n    return res\n"
    },
    {
        "slug": "closest-dessert-cost",
        "description": "You would like to make dessert and are preparing to buy the ingredients. You have n ice cream base flavors and m types of toppings to choose from. You must follow these rules when making your dessert:\n\nThere must be exactly one ice cream base.\nYou can add one or more types of topping or have no toppings at all.\nThere are at most two of each type of topping.\n\nYou are given three inputs:\n\nbaseCosts, an integer array of length n, where each baseCosts[i] represents the price of the ith ice cream base flavor.\ntoppingCosts, an integer array of length m, where each toppingCosts[i] is the price of one of the ith topping.\ntarget, an integer representing your target price for dessert.\n\nYou want to make a dessert with a total cost as close to target as possible.\nReturn the closest possible cost of the dessert to target. If there are multiple, return the lower one.",
        "examples": [
            "Input: baseCosts = [1,7], toppingCosts = [3,4], target = 10\nOutput: 10\nExplanation: Consider the following combination (all 0-indexed):\n- Choose base 1: cost 7\n- Take 1 of topping 0: cost 1 x 3 = 3\n- Take 0 of topping 1: cost 0 x 4 = 0\nTotal: 7 + 3 + 0 = 10.",
            "Input: baseCosts = [2,3], toppingCosts = [4,5,100], target = 18\nOutput: 17\nExplanation: Consider the following combination (all 0-indexed):\n- Choose base 1: cost 3\n- Take 1 of topping 0: cost 1 x 4 = 4\n- Take 2 of topping 1: cost 2 x 5 = 10\n- Take 0 of topping 2: cost 0 x 100 = 0\nTotal: 3 + 4 + 10 + 0 = 17. You cannot make a dessert with a total cost of 18.",
            "Input: baseCosts = [3,10], toppingCosts = [2,5], target = 9\nOutput: 8\nExplanation: It is possible to make desserts with cost 8 and 10. Return 8 as it is the lower cost."
        ],
        "constraints": "n == baseCosts.length\nm == toppingCosts.length\n1 <= n, m <= 10\n1 <= baseCosts[i], toppingCosts[i] <= 104\n1 <= target <= 104",
        "oracle_code": "class Solution:\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\n        toppingCosts *= 2\n        \n        @cache\n        def fn(i, x):\n            \"\"\"Return sum of subsequence of toppingCosts[i:] closest to x.\"\"\"\n            if x < 0 or i == len(toppingCosts): return 0\n            return min(fn(i+1, x), toppingCosts[i] + fn(i+1, x-toppingCosts[i]), key=lambda y: (abs(y-x), y))\n        \n        ans = inf\n        for bc in baseCosts: \n            ans = min(ans, bc + fn(0, target - bc), key=lambda x: (abs(x-target), x))\n        return ans",
        "content": "\\n```\\nclass Solution:\\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\\n        toppingCosts *= 2\\n        \\n        @cache\\n        def fn(i, x):\\n            \"\"\"Return sum of subsequence of toppingCosts[i:] closest to x.\"\"\"\\n            if x < 0 or i == len(toppingCosts): return 0\\n            return min(fn(i+1, x), toppingCosts[i] + fn(i+1, x-toppingCosts[i]), key=lambda y: (abs(y-x), y))\\n        \\n        ans = inf\\n        for bc in baseCosts: \\n            ans = min(ans, bc + fn(0, target - bc), key=lambda x: (abs(x-target), x))\\n        return ans \\n```\\nTime complexity `O(MNV)`\\n\\nEdited on 2/28/2021\\n\\nAdding the version by @lenchen1112\\n```\\nclass Solution:\\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\\n        \\n        @cache\\n        def fn(i, cost):\\n            \"\"\"Return sum of subsequence closest to target.\"\"\"\\n            if cost >= target or i == len(toppingCosts): return cost\\n            return min(fn(i+1, cost), fn(i+1, cost+toppingCosts[i]), key=lambda x: (abs(x-target), x))\\n        \\n        ans = inf\\n        toppingCosts *= 2\\n        for cost in baseCosts: \\n            ans = min(ans, fn(0, cost), key=lambda x: (abs(x-target), x))\\n        return ans \\n```\\n\\nAdding binary search implementation\\n```\\nclass Solution:\\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\\n        top = {0}\\n        for x in toppingCosts*2: \\n            top |= {x + xx for xx in top}\\n        top = sorted(top)\\n        \\n        ans = inf \\n        for bc in baseCosts: \\n            k = bisect_left(top, target - bc)\\n            if k < len(top): ans = min(ans, bc + top[k], key=lambda x: (abs(x-target), x))\\n            if k: ans = min(ans, bc + top[k-1], key=lambda x: (abs(x-target), x))\\n        return ans \\n```\\nTime complexity `O(N*2^(2N) + MN)`",
        "level": "medium",
        "type": [
            "== and = confusion",
            "indexing error",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\n        toppingCosts *= 2\n\n        @cache\n        def fn(i, x):\n            \"\"\"Return sum of subsequence of toppingCosts[i:] closest to x.\"\"\"\n            if x < 0 or i = len(toppingCosts)+1: return 0\n            return min(fn(i+2, x), toppingCosts[i] + fn(i+1, x-toppingCosts[i]), key=lambda y: (abs(y-x), y))\n        \n        ans = inf\n        for bc in baseCosts: \n            ans = min(ans, bc + fn(0, target - bc), key=lambda x: (abs(x-target), x))\n        return ans\n"
    },
    {
        "slug": "median-of-two-sorted-arrays",
        "description": "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\nThe overall run time complexity should be O(log (m+n)).",
        "examples": [
            "Input: nums1 = [1,3], nums2 = [2]\nOutput: 2.00000\nExplanation: merged array = [1,2,3] and median is 2.",
            "Input: nums1 = [1,2], nums2 = [3,4]\nOutput: 2.50000\nExplanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5."
        ],
        "constraints": "nums1.length == m\nnums2.length == n\n0 <= m <= 1000\n0 <= n <= 1000\n1 <= m + n <= 2000\n-106 <= nums1[i], nums2[i] <= 106",
        "oracle_code": "class Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        p1 = 0\n        p2 = 0\n        new = []\n        while p1 < len(nums1) and p2 < len(nums2):\n            if nums1[p1] < nums2[p2]:\n                new.append(nums1[p1])\n                p1 += 1\n            else:\n                new.append(nums2[p2])\n                p2 += 1\n        while p1 < len(nums1):\n            new.append(nums1[p1])\n            p1 += 1\n        while p2 < len(nums2):\n            new.append(nums2[p2])\n            p2+= 1\n        if len(new) % 2 == 0:\n            index = len(new) // 2\n            median = (new[index] + new[index-1]) / 2\n        else:\n            median = float(new[len(new)//2])\n        return median",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind this approach is to merge the two sorted arrays while maintaining the order, and then finding the median based on the length of the merged array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize two pointers, p1 and p2, for the two input arrays nums1 and nums2, respectively, both starting at index 0.\\n2. Create an empty list new to store the merged array.\\n3. Iterate through both arrays using the pointers. Compare the elements pointed to by p1 and p2. Append the smaller element to the new array and increment the corresponding pointer.\\n4. After the iteration, there might be remaining elements in one of the arrays. Iterate through the remaining elements and append them to the new array.\\n5. Calculate the median based on the length of the new array. If the length is even, take the average of the middle two elements. If the length is odd, take the middle element.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(m + n), where m and n are the lengths of the two input arrays.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(m + n), as the merged array new can contain all the elements from the two input arrays.\\n\\n# Code\\n```\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        p1 = 0\\n        p2 = 0\\n        new = []\\n        while p1 < len(nums1) and p2 < len(nums2):\\n            if nums1[p1] < nums2[p2]:\\n                new.append(nums1[p1])\\n                p1 += 1\\n            else:\\n                new.append(nums2[p2])\\n                p2 += 1\\n        while p1 < len(nums1):\\n            new.append(nums1[p1])\\n            p1 += 1\\n        while p2 < len(nums2):\\n            new.append(nums2[p2])\\n            p2+= 1\\n        if len(new) % 2 == 0:\\n            index = len(new) // 2\\n            median = (new[index] + new[index-1]) / 2\\n        else:\\n            median = float(new[len(new)//2])\\n        return median\\n```",
        "level": "hard",
        "type": [
            "indentation error",
            "variable value error",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        p1 = 0\n        p2 = 0\n        new = []\n        while p1 < len(nums1) and p2 < len(nums2):\n            if nums1[p1] < nums2[p2]:\n            new.append(nums1[p1])\n            p1 += 1\n        else:\n            new.append(nums2[p2])\n            p2 += 1\n        while p1 < len(nums1):\n            new.append(nums1[p1])\n            p2 += 1\n        while p2 <= len(nums2):\n            new.append(nums2[p2])\n            p1 += 1\n\n        if len(new) % 2 == 0:\n            index = len(new) // 2\n            median = (new[index] + new[index-1]) / 2\n        else:\n            median = float(new[len(new)//2])\n        return median\n"
    },
    {
        "slug": "length-of-the-longest-valid-substring",
        "description": "You are given a string word and an array of strings forbidden.\nA string is called valid if none of its substrings are present in forbidden.\nReturn the length of the longest valid substring of the string word.\nA substring is a contiguous sequence of characters in a string, possibly empty.",
        "examples": [
            "Input: word = \"cbaaaabc\", forbidden = [\"aaa\",\"cb\"]\nOutput: 4\nExplanation: There are 11 valid substrings in word: \"c\", \"b\", \"a\", \"ba\", \"aa\", \"bc\", \"baa\", \"aab\", \"ab\", \"abc\"and \"aabc\". The length of the longest valid substring is 4. \nIt can be shown that all other substrings contain either \"aaa\" or \"cb\" as a substring.",
            "Input: word = \"leetcode\", forbidden = [\"de\",\"le\",\"e\"]\nOutput: 4\nExplanation: There are 11 valid substrings in word: \"l\", \"t\", \"c\", \"o\", \"d\", \"tc\", \"co\", \"od\", \"tco\", \"cod\", and \"tcod\". The length of the longest valid substring is 4.\nIt can be shown that all other substrings contain either \"de\", \"le\", or \"e\" as a substring."
        ],
        "constraints": "1 <= word.length <= 105\nword consists only of lowercase English letters.\n1 <= forbidden.length <= 105\n1 <= forbidden[i].length <= 10\nforbidden[i] consists only of lowercase English letters.",
        "oracle_code": "class Solution:\n    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int:\n        trie = {}\n        for f in forbidden:\n            t = trie\n            for c in f:\n                if c not in t:\n                    t[c] = {}\n                t = t[c]\n            t[\"end\"] = True\n        \n        def isForbidden(s):\n            t = trie\n            counter = 0\n            for c in s:\n                if c not in t:\n                    return False\n                t = t[c]\n                counter += 1\n                if \"end\" in t:\n                    return counter\n            return False\n        \n        res = 0\n        j = len(word)\n        for i in range(len(word) - 1, -1, -1):\n            truc = isForbidden(word[i:j])\n            if truc:\n                j = i + truc - 1\n            res = max(res, j - i)\n        return res",
        "content": "Put all the forbidden strings into a trie, so that for each string `s`, we can check every substring starts from the beginning (i.e. `s[:1]`,  `s[:2]` ...  `s[:len(s)]`) in one travesal.\\n\\nUse a sliding window to iterate from back to front, each time, we only need to check whether the substrings starting from the new character is forbidden. If the substring is forbidden, then we truncate the string and continue to search.\\n\\nUsing a trie can make the foibidden check fails faster and can deal with longer foibidden strings.\\n\\n# Code\\n```\\nclass Solution:\\n    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int:\\n        trie = {}\\n        for f in forbidden:\\n            t = trie\\n            for c in f:\\n                if c not in t:\\n                    t[c] = {}\\n                t = t[c]\\n            t[\"end\"] = True\\n        \\n        def isForbidden(s):\\n            t = trie\\n            counter = 0\\n            for c in s:\\n                if c not in t:\\n                    return False\\n                t = t[c]\\n                counter += 1\\n                if \"end\" in t:\\n                    return counter\\n            return False\\n        \\n        res = 0\\n        j = len(word)\\n        for i in range(len(word) - 1, -1, -1):\\n            truc = isForbidden(word[i:j])\\n            if truc:\\n                j = i + truc - 1\\n            res = max(res, j - i)\\n        return res\\n```",
        "level": "hard",
        "type": [
            "undefined methods",
            "operation error",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution:\n    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int:\n        trie = {}\n        for f in forbidden:\n            t = trie\n            for c in f:\n                if c not in t:\n                    t[c] = {}\n                t = t[c]\n            t[\"end\"] = True\n        \n        def isForbidden(s):\n            t = trie\n            counter = 0\n            for c in s:\n                if c not in t:\n                    return False\n                t = t[c]\n                counter += 1\n                if \"end\" in t:\n                    return 'counter\n            return False\n        \n        res = 0\n        j = len(word)\n        for i in range(len(word) - 1, -1, -1):\n            truc = isForbidden(word[i:j])\n            if truc:\n                j = i - truc - 1\n                undefinedFunction(word)\n            res = max(res, j - i)\n        return res\n"
    },
    {
        "slug": "minimum-time-to-complete-trips",
        "description": "You are given an array time where time[i] denotes the time taken by the ith bus to complete one trip.\nEach bus can make multiple trips successively; that is, the next trip can start immediately after completing the current trip. Also, each bus operates independently; that is, the trips of one bus do not influence the trips of any other bus.\nYou are also given an integer totalTrips, which denotes the number of trips all buses should make in total. Return the minimum time required for all buses to complete at least totalTrips trips.",
        "examples": [
            "Input: time = [1,2,3], totalTrips = 5\nOutput: 3\nExplanation:\n- At time t = 1, the number of trips completed by each bus are [1,0,0]. \n  The total number of trips completed is 1 + 0 + 0 = 1.\n- At time t = 2, the number of trips completed by each bus are [2,1,0]. \n  The total number of trips completed is 2 + 1 + 0 = 3.\n- At time t = 3, the number of trips completed by each bus are [3,1,1]. \n  The total number of trips completed is 3 + 1 + 1 = 5.\nSo the minimum time needed for all buses to complete at least 5 trips is 3.",
            "Input: time = [2], totalTrips = 1\nOutput: 2\nExplanation:\nThere is only one bus, and it will complete its first trip at t = 2.\nSo the minimum time needed to complete 1 trip is 2."
        ],
        "constraints": "1 <= time.length <= 105\n1 <= time[i], totalTrips <= 107",
        "oracle_code": "class Solution:\n    def satisfiesTrip(self,mid, time, totalTrip):\n        trip = 0\n        for t in time:\n            trip += mid//t\n            if trip >= totalTrip:\n                return True\n        return False\n\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\n        time.sort(reverse=True)\n        minimum = min(time)\n        left = minimum\n        right = minimum*totalTrips\n        while left < right:\n            mid = (left+ right)//2\n\n            if self.satisfiesTrip(mid, time, totalTrips):\n                right = mid\n            else:\n                left = mid + 1\n        return right",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nas the question requires as to find the minimum time required to finish the total trip. first i needed to find the range in which the solution can lay and traverse through that inorder to reach an optimal solution. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI used binary search to solve the question in which i first looked for the left and right bound of the solution in which i found that the potential left boundary that is lowest possible answer is the minimum time taken to finish one trip. as the minimum amount of trip required can only be one. and also the maximum time taken is also can be calculated as (minimum time taken * the total trip required).\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlog(n)) - for the sorting the values in descending order \\nO(nlog(n)) - for the search for the valid trip\\noverall - O(nlog(n))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nwe don\\'t have addtional space to store value that grows as our answer changes hence :- O(1)\\n# Code\\n```\\nclass Solution:\\n    def satisfiesTrip(self,mid, time, totalTrip):\\n        trip = 0\\n        for t in time:\\n            trip += mid//t\\n            if trip >= totalTrip:\\n                return True\\n        return False\\n\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        time.sort(reverse=True)\\n        minimum = min(time)\\n        left = minimum\\n        right = minimum*totalTrips\\n        while left < right:\\n            mid = (left+ right)//2\\n\\n            if self.satisfiesTrip(mid, time, totalTrips):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return right\\n\\n```",
        "level": "medium",
        "type": [
            "undefined objects",
            "parentheses mismatch",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def satisfiesTrip(self,mid, time, totalTrip):\n        trip = 0\n        for t in time:\n            trip += mid//t\n        if trip >= totalTrip:\n                return False\n        return True\n\n    def minimumTime(self, time: IntList, totalTrips: int) -> int:\n        time.sort(reverse=True)\n        minimum = min(time)\n        left = minimum\n        right = minimum*totalTrips\n        while left < right:\n            mid = (left+ right)//2\n\n            if self.satisfiesTrip(mid, time, totalTrips:\n                right = mid\n            else:\n                left = mid + 1\n        return right\n"
    },
    {
        "slug": "find-the-string-with-lcp",
        "description": "We define the lcp matrix of any 0-indexed string word of n lowercase English letters as an n x n grid such that:\n\nlcp[i][j] is equal to the length of the longest common prefix between the substrings word[i,n-1] and word[j,n-1].\n\nGiven an\u00a0n x n matrix lcp, return the alphabetically smallest string word that corresponds to lcp. If there is no such string, return an empty string.\nA string a is lexicographically smaller than a string b (of the same length) if in the first position where a and b differ, string a has a letter that appears earlier in the alphabet than the corresponding letter in b. For example, \"aabd\" is lexicographically smaller than \"aaca\" because the first position they differ is at the third letter, and 'b' comes before 'c'.",
        "examples": [
            "Input: lcp = [[4,0,2,0],[0,3,0,1],[2,0,2,0],[0,1,0,1]]\nOutput: \"abab\"\nExplanation: lcp corresponds to any 4 letter string with two alternating letters. The lexicographically smallest of them is \"abab\".",
            "Input: lcp = [[4,3,2,1],[3,3,2,1],[2,2,2,1],[1,1,1,1]]\nOutput: \"aaaa\"\nExplanation: lcp corresponds to any 4 letter string with a single distinct letter. The lexicographically smallest of them is \"aaaa\".",
            "Input: lcp = [[4,3,2,1],[3,3,2,1],[2,2,2,1],[1,1,1,3]]\nOutput: \"\"\nExplanation: lcp[3][3] cannot be equal to 3 since word[3,...,3] consists of only a single letter; Thus, no answer exists."
        ],
        "constraints": "1 <= n ==\u00a0lcp.length == lcp[i].length\u00a0<= 1000\n0 <= lcp[i][j] <= n",
        "oracle_code": "class Solution:\n    def findTheString(self, lcp: List[List[int]]) -> str:\n        # simple validation\n        n = len(lcp)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if lcp[i][j] != lcp[j][i]:\n                    return ''\n                if lcp[i][j] > n - j:\n                    return ''\n        for i in range(n):\n            if lcp[i][i] != n - i:\n                return ''\n        \n        # build pattern \\u2014 the only possible candidate for answer\n        pattern = [None for _ in range(n)]\n        next_el_ind = 0\n        for i in range(n):\n            if pattern[i] is not None:\n                continue\n            pattern[i] = next_el_ind\n            next_el_ind += 1\n            for j in range(i+1, n):\n                if lcp[i][j] > 0:\n                    if pattern[j] is not None and pattern[j] != pattern[i]:\n                        return ''\n                    pattern[j] = pattern[i]\n    \n        # check if lcp is valid - check that pattern's lcp == original lcp\n        pattern_lcp = [[0 for _ in range(n)] for _ in range(n)]\n        for i in range(n-1, -1, -1):\n            for j in range(n-1, -1, -1):\n                if pattern[i] == pattern[j]:\n                    if max(i, j) + 1 < n:\n                        pattern_lcp[i][j] = pattern_lcp[i+1][j+1] + 1\n                    else:\n                        pattern_lcp[i][j] = 1\n        for i in range(n):\n            for j in range(n):\n                if lcp[i][j] != pattern_lcp[i][j]:\n                    return ''\n    \n        # check that answer has no more than 26 distinct elements\n        if max(pattern) > ord('z') - ord('a'):\n            return ''\n\n        return  ''.join(chr(ord('a') + ind) for ind in pattern)",
        "content": "# Complexity\\n- Time complexity: $O(N^2)$\\n\\n- Space complexity: $O(N^2)$ (can be reduced to $O(N)$ if build and check new lcp at the same time)\\n\\n# Code\\n```\\nclass Solution:\\n    def findTheString(self, lcp: List[List[int]]) -> str:\\n        # simple validation\\n        n = len(lcp)\\n        for i in range(n):\\n            for j in range(i + 1, n):\\n                if lcp[i][j] != lcp[j][i]:\\n                    return \\'\\'\\n                if lcp[i][j] > n - j:\\n                    return \\'\\'\\n        for i in range(n):\\n            if lcp[i][i] != n - i:\\n                return \\'\\'\\n        \\n        # build pattern \\u2014 the only possible candidate for answer\\n        pattern = [None for _ in range(n)]\\n        next_el_ind = 0\\n        for i in range(n):\\n            if pattern[i] is not None:\\n                continue\\n            pattern[i] = next_el_ind\\n            next_el_ind += 1\\n            for j in range(i+1, n):\\n                if lcp[i][j] > 0:\\n                    if pattern[j] is not None and pattern[j] != pattern[i]:\\n                        return \\'\\'\\n                    pattern[j] = pattern[i]\\n    \\n        # check if lcp is valid - check that pattern\\'s lcp == original lcp\\n        pattern_lcp = [[0 for _ in range(n)] for _ in range(n)]\\n        for i in range(n-1, -1, -1):\\n            for j in range(n-1, -1, -1):\\n                if pattern[i] == pattern[j]:\\n                    if max(i, j) + 1 < n:\\n                        pattern_lcp[i][j] = pattern_lcp[i+1][j+1] + 1\\n                    else:\\n                        pattern_lcp[i][j] = 1\\n        for i in range(n):\\n            for j in range(n):\\n                if lcp[i][j] != pattern_lcp[i][j]:\\n                    return \\'\\'\\n    \\n        # check that answer has no more than 26 distinct elements\\n        if max(pattern) > ord(\\'z\\') - ord(\\'a\\'):\\n            return \\'\\'\\n\\n        return  \\'\\'.join(chr(ord(\\'a\\') + ind) for ind in pattern)\\n```",
        "level": "hard",
        "type": [
            "operation error",
            "parentheses mismatch",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n    def findTheString(self, lcp: List[List[int]]) -> str:\n        # simple validation\n        n = len(lcp)\n\n        for i in range(n):\n            for j in range(i + 1, n):\n                if lcp[i][j] = lcp[j][i]:\n                    return ''\n                if lcp[i][j] > n - j:\n                    return ''\n        for i in range(n):\n            if lcp[i][i] = n - i:\n                return ''\n\n        # build pattern \\u2014 the only possible candidate for answer\n        pattern = [None for _ in range(n)]\n        next_el_ind = 0\n        for i in range(n):\n            if pattern[i] is not None:\n                continue\n            pattern[i] = next_el_ind\n            next_el_ind += 1\n            for j in range(i+1, n:\n                if lcp[i][j] > 0):\n                    if pattern[j] is not None and pattern[j] != pattern[i]:      \n                        return ''      \n                    pattern[j] = pattern[i]\n\n        # check if lcp is valid - check that pattern's lcp == original lcp\n        pattern_lcp = [[0 for _ in range(n)] for _ in range(n)]\n        for i in range(n-1, -1, -1):\n            for j in range(n-1, -1, -1):\n                if pattern[i] == pattern[j]:\n                    if max(i, j) + 1 < n:\n                        pattern_lcp[i][j] = pattern_lcp[i+1][j+1] + 2 //Add 2 instead of 1\n                    else:\n                        pattern_lcp[i][j] = 1\n        for i in range(n):\n            for j in range(n):\n                if lcp[i][j] = pattern_lcp[i][j]:\n                    return ''\n\n\n        # check that answer has no more than 26 distinct elements\n        if max(pattern) > ord('z') - ord('a'):\n            return ''\n\n        return  ''.join(chr(ord('a') + ind) for ind in pattern)\n"
    },
    {
        "slug": "count-the-repetitions",
        "description": "We define str = [s, n] as the string str which consists of the string s concatenated n times.\n\nFor example, str == [\"abc\", 3] ==\"abcabcabc\".\n\nWe define that string s1 can be obtained from string s2 if we can remove some characters from s2 such that it becomes s1.\n\nFor example, s1 = \"abc\" can be obtained from s2 = \"abdbec\" based on our definition by removing the bolded underlined characters.\n\nYou are given two strings s1 and s2 and two integers n1 and n2. You have the two strings str1 = [s1, n1] and str2 = [s2, n2].\nReturn the maximum integer m such that str = [str2, m] can be obtained from str1.",
        "examples": [
            "Input: s1 = \"acb\", n1 = 4, s2 = \"ab\", n2 = 2\nOutput: 2",
            "Input: s1 = \"acb\", n1 = 1, s2 = \"acb\", n2 = 1\nOutput: 1"
        ],
        "constraints": "1 <= s1.length, s2.length <= 100\ns1 and s2 consist of lowercase English letters.\n1 <= n1, n2 <= 106",
        "oracle_code": "class Solution:\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\n\n        rec, track = [0], defaultdict(int) \n        ct = start = ptr1 = ptr2 = 0\n\n        if not set(s2).issubset(set(s1)): return 0\n\n        s1 = ''.join(char for char in s1 if char in set(s2))\n        \n        while True:\n            for char in s2:\n                ptr = s1.find(char, start)\n                if ptr == -1:\n                    ct += 1\n                    ptr = s1.find(char)\n                start = ptr+1\n            rec.append(ct + 1)\n\n            if rec[-1] > n1: return (len(rec)-2)//n2\n\n            if ptr not in track: track[ptr] = len(rec)-1\n            else: break\n        \n        cycleStart = rec[track[ptr]]\n        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]\n        rest = n1 - cycleStart\n        \n        rem = cycleStart + rest%cycle1\n\n        while rec[ptr2] <= rem: ptr2+= 1\n\n        return (cycle2 * (rest//cycle1) + ptr2-1)//n2",
        "content": "```\\nclass Solution:\\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\\n\\n        rec, track = [0], defaultdict(int) \\n        ct = start = ptr1 = ptr2 = 0\\n\\n        if not set(s2).issubset(set(s1)): return 0\\n\\n        s1 = \\'\\'.join(char for char in s1 if char in set(s2))\\n        \\n        while True:\\n            for char in s2:\\n                ptr = s1.find(char, start)\\n                if ptr == -1:\\n                    ct += 1\\n                    ptr = s1.find(char)\\n                start = ptr+1\\n            rec.append(ct + 1)\\n\\n            if rec[-1] > n1: return (len(rec)-2)//n2\\n\\n            if ptr not in track: track[ptr] = len(rec)-1\\n            else: break\\n        \\n        cycleStart = rec[track[ptr]]\\n        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]\\n        rest = n1 - cycleStart\\n        \\n        rem = cycleStart + rest%cycle1\\n\\n        while rec[ptr2] <= rem: ptr2+= 1\\n\\n        return (cycle2 * (rest//cycle1) + ptr2-1)//n2\\n```\\n[https://leetcode.com/problems/count-the-repetitions/submissions/864907562/](http://)\\n\\nI could be wrong, but I think that time is *O*(*N*) and space is *O*(*N*).",
        "level": "hard",
        "type": [
            "undefined objects",
            "unclosed string",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\n\n        rec, track = [0], defaultdict(int) \n        ct = start = ptr1 = undefinedVariable = 0\n\n        if not set(s2).issubset(set(s1)): return 0\n\n        s1 = ''.join(char for char in s1 if char in set(undefinedVariable))\n        \n        while True:\n            for char in s2:\n                ptr = s1.find(char, start)\n                if ptr == -1:\n                    ct += 1\n                    ptr = s1.find(char)\n                start = ptr+1\n            rec.append(ct + 1)\n\n            if rec[-1] >= n1: return (len(rec)-2)//n2\n\n            if ptr not in track: track[ptr] = len(0rec)-1\n            \n            else: break\n        \n        cycleStart = rec[track[ptr]]\n        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]\n        rest = n1 - cycleStart\n        \n        rem = cycleStart + rest%cycle1\n\n        while rec[ptr2] <= rem: ptr2+= 1\n\n        return (cycle2 * (rest//cycle1) + ptr2-1)//n2\n"
    },
    {
        "slug": "minimum-time-to-complete-trips",
        "description": "You are given an array time where time[i] denotes the time taken by the ith bus to complete one trip.\nEach bus can make multiple trips successively; that is, the next trip can start immediately after completing the current trip. Also, each bus operates independently; that is, the trips of one bus do not influence the trips of any other bus.\nYou are also given an integer totalTrips, which denotes the number of trips all buses should make in total. Return the minimum time required for all buses to complete at least totalTrips trips.",
        "examples": [
            "Input: time = [1,2,3], totalTrips = 5\nOutput: 3\nExplanation:\n- At time t = 1, the number of trips completed by each bus are [1,0,0]. \n  The total number of trips completed is 1 + 0 + 0 = 1.\n- At time t = 2, the number of trips completed by each bus are [2,1,0]. \n  The total number of trips completed is 2 + 1 + 0 = 3.\n- At time t = 3, the number of trips completed by each bus are [3,1,1]. \n  The total number of trips completed is 3 + 1 + 1 = 5.\nSo the minimum time needed for all buses to complete at least 5 trips is 3.",
            "Input: time = [2], totalTrips = 1\nOutput: 2\nExplanation:\nThere is only one bus, and it will complete its first trip at t = 2.\nSo the minimum time needed to complete 1 trip is 2."
        ],
        "constraints": "1 <= time.length <= 105\n1 <= time[i], totalTrips <= 107",
        "oracle_code": "class Solution:\n    def satisfiesTrip(self,mid, time, totalTrip):\n        trip = 0\n        for t in time:\n            trip += mid//t\n            if trip >= totalTrip:\n                return True\n        return False\n\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\n        time.sort(reverse=True)\n        minimum = min(time)\n        left = minimum\n        right = minimum*totalTrips\n        while left < right:\n            mid = (left+ right)//2\n\n            if self.satisfiesTrip(mid, time, totalTrips):\n                right = mid\n            else:\n                left = mid + 1\n        return right",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nas the question requires as to find the minimum time required to finish the total trip. first i needed to find the range in which the solution can lay and traverse through that inorder to reach an optimal solution. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI used binary search to solve the question in which i first looked for the left and right bound of the solution in which i found that the potential left boundary that is lowest possible answer is the minimum time taken to finish one trip. as the minimum amount of trip required can only be one. and also the maximum time taken is also can be calculated as (minimum time taken * the total trip required).\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlog(n)) - for the sorting the values in descending order \\nO(nlog(n)) - for the search for the valid trip\\noverall - O(nlog(n))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nwe don\\'t have addtional space to store value that grows as our answer changes hence :- O(1)\\n# Code\\n```\\nclass Solution:\\n    def satisfiesTrip(self,mid, time, totalTrip):\\n        trip = 0\\n        for t in time:\\n            trip += mid//t\\n            if trip >= totalTrip:\\n                return True\\n        return False\\n\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        time.sort(reverse=True)\\n        minimum = min(time)\\n        left = minimum\\n        right = minimum*totalTrips\\n        while left < right:\\n            mid = (left+ right)//2\\n\\n            if self.satisfiesTrip(mid, time, totalTrips):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return right\\n\\n```",
        "level": "medium",
        "type": [
            "colon missing",
            "undefined objects",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def satisfiesTrip(self,mid, time, totalTrip)\n        trip = 0\n        for t in time:\n            trip += mid//t\n            if trip >= totalTrip:\n                return False\n        return True\n\n    def minimumTime(self, time: IntList, totalTrips: int) -> int:\n        time.sort(reverse=True)\n        minimum = min(time)\n        left = minimum\n        right = minimum*totalTrips\n        while left < right:\n            mid = (left+ right)//2\n\n            if self.satisfiesTrip(mid, time, totalTrips):\n                right = mid\n            else:\n                left = mid + 1\n        return right\n"
    },
    {
        "slug": "closest-dessert-cost",
        "description": "You would like to make dessert and are preparing to buy the ingredients. You have n ice cream base flavors and m types of toppings to choose from. You must follow these rules when making your dessert:\n\nThere must be exactly one ice cream base.\nYou can add one or more types of topping or have no toppings at all.\nThere are at most two of each type of topping.\n\nYou are given three inputs:\n\nbaseCosts, an integer array of length n, where each baseCosts[i] represents the price of the ith ice cream base flavor.\ntoppingCosts, an integer array of length m, where each toppingCosts[i] is the price of one of the ith topping.\ntarget, an integer representing your target price for dessert.\n\nYou want to make a dessert with a total cost as close to target as possible.\nReturn the closest possible cost of the dessert to target. If there are multiple, return the lower one.",
        "examples": [
            "Input: baseCosts = [1,7], toppingCosts = [3,4], target = 10\nOutput: 10\nExplanation: Consider the following combination (all 0-indexed):\n- Choose base 1: cost 7\n- Take 1 of topping 0: cost 1 x 3 = 3\n- Take 0 of topping 1: cost 0 x 4 = 0\nTotal: 7 + 3 + 0 = 10.",
            "Input: baseCosts = [2,3], toppingCosts = [4,5,100], target = 18\nOutput: 17\nExplanation: Consider the following combination (all 0-indexed):\n- Choose base 1: cost 3\n- Take 1 of topping 0: cost 1 x 4 = 4\n- Take 2 of topping 1: cost 2 x 5 = 10\n- Take 0 of topping 2: cost 0 x 100 = 0\nTotal: 3 + 4 + 10 + 0 = 17. You cannot make a dessert with a total cost of 18.",
            "Input: baseCosts = [3,10], toppingCosts = [2,5], target = 9\nOutput: 8\nExplanation: It is possible to make desserts with cost 8 and 10. Return 8 as it is the lower cost."
        ],
        "constraints": "n == baseCosts.length\nm == toppingCosts.length\n1 <= n, m <= 10\n1 <= baseCosts[i], toppingCosts[i] <= 104\n1 <= target <= 104",
        "oracle_code": "class Solution:\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\n        toppingCosts *= 2\n        \n        @cache\n        def fn(i, x):\n            \"\"\"Return sum of subsequence of toppingCosts[i:] closest to x.\"\"\"\n            if x < 0 or i == len(toppingCosts): return 0\n            return min(fn(i+1, x), toppingCosts[i] + fn(i+1, x-toppingCosts[i]), key=lambda y: (abs(y-x), y))\n        \n        ans = inf\n        for bc in baseCosts: \n            ans = min(ans, bc + fn(0, target - bc), key=lambda x: (abs(x-target), x))\n        return ans",
        "content": "\\n```\\nclass Solution:\\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\\n        toppingCosts *= 2\\n        \\n        @cache\\n        def fn(i, x):\\n            \"\"\"Return sum of subsequence of toppingCosts[i:] closest to x.\"\"\"\\n            if x < 0 or i == len(toppingCosts): return 0\\n            return min(fn(i+1, x), toppingCosts[i] + fn(i+1, x-toppingCosts[i]), key=lambda y: (abs(y-x), y))\\n        \\n        ans = inf\\n        for bc in baseCosts: \\n            ans = min(ans, bc + fn(0, target - bc), key=lambda x: (abs(x-target), x))\\n        return ans \\n```\\nTime complexity `O(MNV)`\\n\\nEdited on 2/28/2021\\n\\nAdding the version by @lenchen1112\\n```\\nclass Solution:\\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\\n        \\n        @cache\\n        def fn(i, cost):\\n            \"\"\"Return sum of subsequence closest to target.\"\"\"\\n            if cost >= target or i == len(toppingCosts): return cost\\n            return min(fn(i+1, cost), fn(i+1, cost+toppingCosts[i]), key=lambda x: (abs(x-target), x))\\n        \\n        ans = inf\\n        toppingCosts *= 2\\n        for cost in baseCosts: \\n            ans = min(ans, fn(0, cost), key=lambda x: (abs(x-target), x))\\n        return ans \\n```\\n\\nAdding binary search implementation\\n```\\nclass Solution:\\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\\n        top = {0}\\n        for x in toppingCosts*2: \\n            top |= {x + xx for xx in top}\\n        top = sorted(top)\\n        \\n        ans = inf \\n        for bc in baseCosts: \\n            k = bisect_left(top, target - bc)\\n            if k < len(top): ans = min(ans, bc + top[k], key=lambda x: (abs(x-target), x))\\n            if k: ans = min(ans, bc + top[k-1], key=lambda x: (abs(x-target), x))\\n        return ans \\n```\\nTime complexity `O(N*2^(2N) + MN)`",
        "level": "medium",
        "type": [
            "parentheses mismatch",
            "undefined keywords from other languages",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\n        toppingCosts *= 2\n        \n        @cache\n        def fn(i, x):\n            \"\"\"Return sum of subsequence of toppingCosts[i:] closest to x.\"\"\"\n            if x < 0 or i == len(toppingCosts+1: return 0\n            return min(fn(i+1, x), toppingCosts[i] + fn(i+1, x-toppingCosts[i]), key=lambda y: (abs(y-x), y))\n        \n        ans = infinity\n        for bc in baseCosts: \n            ans = min(ans, bc + fn(0, target - bc), key=lambda x: (abs(x-target), x))\n        return ans\n"
    },
    {
        "slug": "online-election",
        "description": "You are given two integer arrays persons and times. In an election, the ith vote was cast for persons[i] at time times[i].\nFor each query at a time t, find the person that was leading the election at time t. Votes cast at time t will count towards our query. In the case of a tie, the most recent vote (among tied candidates) wins.\nImplement the TopVotedCandidate class:\n\nTopVotedCandidate(int[] persons, int[] times) Initializes the object with the persons and times arrays.\nint q(int t) Returns the number of the person that was leading the election at time t according to the mentioned rules.",
        "examples": [
            "Input\n[\"TopVotedCandidate\", \"q\", \"q\", \"q\", \"q\", \"q\", \"q\"]\n[[[0, 1, 1, 0, 0, 1, 0], [0, 5, 10, 15, 20, 25, 30]], [3], [12], [25], [15], [24], [8]]\nOutput\n[null, 0, 1, 1, 0, 0, 1]\n\nExplanation\nTopVotedCandidate topVotedCandidate = new TopVotedCandidate([0, 1, 1, 0, 0, 1, 0], [0, 5, 10, 15, 20, 25, 30]);\ntopVotedCandidate.q(3); // return 0, At time 3, the votes are [0], and 0 is leading.\ntopVotedCandidate.q(12); // return 1, At time 12, the votes are [0,1,1], and 1 is leading.\ntopVotedCandidate.q(25); // return 1, At time 25, the votes are [0,1,1,0,0,1], and 1 is leading (as ties go to the most recent vote.)\ntopVotedCandidate.q(15); // return 0\ntopVotedCandidate.q(24); // return 0\ntopVotedCandidate.q(8); // return 1"
        ],
        "constraints": "1 <= persons.length <= 5000\ntimes.length == persons.length\n0 <= persons[i] < persons.length\n0 <= times[i] <= 109\ntimes is sorted in a strictly increasing order.\ntimes[0] <= t <= 109\nAt most 104 calls will be made to q.",
        "oracle_code": "class TopVotedCandidate:\n\n    def __init__(self, persons: List[int], times: List[int]):\n        self.persons = []\n        self.times = []\n        self.dic = collections.defaultdict(int)\n        self.m = 0\n        self.idx = -1\n\n        for i in range(len(times)):\n            self.times.append(times[i])\n            self.dic[persons[i]] += 1\n            if self.dic[persons[i]] >= self.m:\n                self.persons.append(persons[i])\n                self.m = self.dic[persons[i]]\n            else:\n                self.persons.append(self.persons[-1])\n\n    def q(self, t: int) -> int:\n        idx = bisect.bisect_right(self.times,t)\n        return self.persons[idx-1]",
        "content": "# Code\\n```\\nclass TopVotedCandidate:\\n\\n    def __init__(self, persons: List[int], times: List[int]):\\n        self.persons = []\\n        self.times = []\\n        self.dic = collections.defaultdict(int)\\n        self.m = 0\\n        self.idx = -1\\n\\n        for i in range(len(times)):\\n            self.times.append(times[i])\\n            self.dic[persons[i]] += 1\\n            if self.dic[persons[i]] >= self.m:\\n                self.persons.append(persons[i])\\n                self.m = self.dic[persons[i]]\\n            else:\\n                self.persons.append(self.persons[-1])\\n\\n    def q(self, t: int) -> int:\\n        idx = bisect.bisect_right(self.times,t)\\n        return self.persons[idx-1]\\n\\n```",
        "level": "medium",
        "type": [
            "colon missing",
            "operation error",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass TopVotedCandidate:\n\n    def __init__(self, persons: List[int], times: List[int])\n        self.persons = []\n        self.times = []\n        self.dic = collections.defaultdict(int)\n        self.m = 0\n        self.idx = -1\n\n        for i in range(len(times):\n            self.times.append(times[i])\n            self.dic[persons[i]] += 1\n            if self.dic[persons[i]] >= self.m:\n                self.persons.append(persons[i])\n                self.m = self.dic[persons[i]]\n            else:\n                self.persons.append(self.persons[-1])\n\n    def q(self, t: int) -> int:\n        idx = bisect.bisect_right(self.times,t)\n        return self.persons[idx]\n"
    },
    {
        "slug": "check-if-two-string-arrays-are-equivalent",
        "description": "Given two string arrays word1 and word2, return true if the two arrays represent the same string, and false otherwise.\nA string is represented by an array if the array elements concatenated in order forms the string.",
        "examples": [
            "Input: word1 = [\"ab\", \"c\"], word2 = [\"a\", \"bc\"]\nOutput: true\nExplanation:\nword1 represents string \"ab\" + \"c\" -> \"abc\"\nword2 represents string \"a\" + \"bc\" -> \"abc\"\nThe strings are the same, so return true.",
            "Input: word1 = [\"a\", \"cb\"], word2 = [\"ab\", \"c\"]\nOutput: false",
            "Input: word1  = [\"abc\", \"d\", \"defg\"], word2 = [\"abcddefg\"]\nOutput: true"
        ],
        "constraints": "1 <= word1.length, word2.length <= 103\n1 <= word1[i].length, word2[i].length <= 103\n1 <= sum(word1[i].length), sum(word2[i].length) <= 103\nword1[i] and word2[i] consist of lowercase letters.",
        "oracle_code": "class Solution:\n    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) -> bool:\n        word3=\"\".join(word1)\n        word4=\"\".join(word2)\n        if word3==word4:\n            return True\n        else:\n            return False",
        "content": "**1**.First we will join the contents or concatenate the Strings present in the list using join()\\n**2**.then compare 2 list.\\n**3** if true return true else return false\\n```\\nclass Solution:\\n    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) -> bool:\\n        word3=\"\".join(word1)\\n        word4=\"\".join(word2)\\n        if word3==word4:\\n            return True\\n        else:\\n            return False\\n```\\n**code**\\nOnline Solution :\\n    -Thank you for this solution @jeevabharathiS\\n        \\n```\\nclass Solution:\\n    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) \\n        return((\"\".join(word1))==(\"\".join(word2)))\\n```",
        "level": "easy",
        "type": [
            "undefined methods",
            "operation error",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) -> bool:\n        word3 = self.concat(word1.reverse())\n        word4 = self.concat(word2)\n        if word3 = word4:\n            return True\n        else:\n            return False\n"
    },
    {
        "slug": "sum-of-subarray-minimums",
        "description": "Given an array of integers arr, find the sum of min(b), where b ranges over every (contiguous) subarray of arr. Since the answer may be large, return the answer modulo 109 + 7.",
        "examples": [
            "Input: arr = [3,1,2,4]\nOutput: 17\nExplanation: \nSubarrays are [3], [1], [2], [4], [3,1], [1,2], [2,4], [3,1,2], [1,2,4], [3,1,2,4]. \nMinimums are 3, 1, 2, 4, 1, 1, 2, 1, 1, 1.\nSum is 17.",
            "Input: arr = [11,81,94,43,3]\nOutput: 444"
        ],
        "constraints": "1 <= arr.length <= 3 * 104\n1 <= arr[i] <= 3 * 104",
        "oracle_code": "class Solution:\n    def sumSubarrayMins(self, arr: List[int]) -> int:\n        stack = []\n        res = 0\n        arr = [float('-inf')] + arr + [float('-inf')]\n        for i, num in enumerate(arr):\n            while stack and arr[stack[-1]] > num:\n                cur = stack.pop()\n                res += arr[cur] * (i - cur) * (cur - stack[-1])\n            stack.append(i)\n        return res % (10**9 + 7)",
        "content": "Maintain a stack of indexes of subarrays, \\nwhich would have the minimum number at the top of the stack.\\n \\nUse following logic to compute the sum(i):\\n- If arr[i] is small, then arr[i] is minimum for all subarrays \\nstarting at arr[i].\\n- If arr[i] is greater, then find the smallest element from the top of stack which is bigger than arr[i]. \\n- Let the index of the smallest element be on top. \\n- Now, arr[i] is minimum for all subarrays starting at arr[top+1]. \\n\\nWe already know the value of sum(top), so add sum(top) + arr[i] * (i \\u2013 top) to result. Finally, push the index of arr[i] to stack.\\n\\n# Complexity\\nTime Complexity: O(N)\\nSpace Complexity: O(N)\\n\\n# Code\\n```\\nclass Solution:\\n    def sumSubarrayMins(self, arr: List[int]) -> int:\\n        stack = []\\n        res = 0\\n        arr = [float(\\'-inf\\')] + arr + [float(\\'-inf\\')]\\n        for i, num in enumerate(arr):\\n            while stack and arr[stack[-1]] > num:\\n                cur = stack.pop()\\n                res += arr[cur] * (i - cur) * (cur - stack[-1])\\n            stack.append(i)\\n        return res % (10**9 + 7)\\n\\n```",
        "level": "medium",
        "type": [
            "indentation error",
            "unclosed string",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\ndef sumSubarrayMins(self, arr: List[int]) -> int:\n    stack = []\n    res = 0\n    arr = [float('-inf')] + arr + [float('-inf')]\n    for i, num in enumerate(arr):\n        while stack and arr[stack[-1]] > num:\n            cur = stack.pop()\n            res += arr[cur] * (i - cur) * (cur - stack[-2]\n        stack.append(i)\n    return res % (10**9 + 7)\n"
    },
    {
        "slug": "sequential-digits",
        "description": "An\u00a0integer has sequential digits if and only if each digit in the number is one more than the previous digit.\nReturn a sorted list of all the integers\u00a0in the range [low, high]\u00a0inclusive that have sequential digits.",
        "examples": [
            "Input: low = 100, high = 300\nOutput: [123,234]",
            "Input: low = 1000, high = 13000\nOutput: [1234,2345,3456,4567,5678,6789,12345]"
        ],
        "constraints": "10 <= low <= high <= 10^9",
        "oracle_code": "class Solution:\n    def sequentialDigits(self, low, high):\n        out = []\n        queue = deque(range(1,10))\n        while queue:\n            elem = queue.popleft()\n            if low <= elem <= high:\n                out.append(elem)\n            last = elem % 10\n            if last < 9: queue.append(elem*10 + last + 1)\n                    \n        return out",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def sequentialDigits(self, low, high):\\n        out = []\\n        queue = deque(range(1,10))\\n        while queue:\\n            elem = queue.popleft()\\n            if low <= elem <= high:\\n                out.append(elem)\\n            last = elem % 10\\n            if last < 9: queue.append(elem*10 + last + 1)\\n                    \\n        return out\\n```",
        "level": "medium",
        "type": [
            "indentation error",
            "indexing error",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\ndef sequentialDigits(self, low, high):\n    out = []\n    queue = deque(range(1,11))\n        while queue:\n            elem = queue.popleft()\n            if low <= elem <= high:\n                out.append(elem)\n            last = elem % 10\n        if last < 9: queue.append(elem*10> + last + 1)\n                    \n    return out\n"
    },
    {
        "slug": "median-of-two-sorted-arrays",
        "description": "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\nThe overall run time complexity should be O(log (m+n)).",
        "examples": [
            "Input: nums1 = [1,3], nums2 = [2]\nOutput: 2.00000\nExplanation: merged array = [1,2,3] and median is 2.",
            "Input: nums1 = [1,2], nums2 = [3,4]\nOutput: 2.50000\nExplanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5."
        ],
        "constraints": "nums1.length == m\nnums2.length == n\n0 <= m <= 1000\n0 <= n <= 1000\n1 <= m + n <= 2000\n-106 <= nums1[i], nums2[i] <= 106",
        "oracle_code": "class Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        p1 = 0\n        p2 = 0\n        new = []\n        while p1 < len(nums1) and p2 < len(nums2):\n            if nums1[p1] < nums2[p2]:\n                new.append(nums1[p1])\n                p1 += 1\n            else:\n                new.append(nums2[p2])\n                p2 += 1\n        while p1 < len(nums1):\n            new.append(nums1[p1])\n            p1 += 1\n        while p2 < len(nums2):\n            new.append(nums2[p2])\n            p2+= 1\n        if len(new) % 2 == 0:\n            index = len(new) // 2\n            median = (new[index] + new[index-1]) / 2\n        else:\n            median = float(new[len(new)//2])\n        return median",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind this approach is to merge the two sorted arrays while maintaining the order, and then finding the median based on the length of the merged array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize two pointers, p1 and p2, for the two input arrays nums1 and nums2, respectively, both starting at index 0.\\n2. Create an empty list new to store the merged array.\\n3. Iterate through both arrays using the pointers. Compare the elements pointed to by p1 and p2. Append the smaller element to the new array and increment the corresponding pointer.\\n4. After the iteration, there might be remaining elements in one of the arrays. Iterate through the remaining elements and append them to the new array.\\n5. Calculate the median based on the length of the new array. If the length is even, take the average of the middle two elements. If the length is odd, take the middle element.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(m + n), where m and n are the lengths of the two input arrays.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(m + n), as the merged array new can contain all the elements from the two input arrays.\\n\\n# Code\\n```\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        p1 = 0\\n        p2 = 0\\n        new = []\\n        while p1 < len(nums1) and p2 < len(nums2):\\n            if nums1[p1] < nums2[p2]:\\n                new.append(nums1[p1])\\n                p1 += 1\\n            else:\\n                new.append(nums2[p2])\\n                p2 += 1\\n        while p1 < len(nums1):\\n            new.append(nums1[p1])\\n            p1 += 1\\n        while p2 < len(nums2):\\n            new.append(nums2[p2])\\n            p2+= 1\\n        if len(new) % 2 == 0:\\n            index = len(new) // 2\\n            median = (new[index] + new[index-1]) / 2\\n        else:\\n            median = float(new[len(new)//2])\\n        return median\\n```",
        "level": "hard",
        "type": [
            "variable value error",
            "== and = confusion",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        p1 = 0\n        p2 = 0\n        new = []\n        while p1 < len(nums1) and p2 < len(nums2):\n            if nums1[p1] < nums2[p2]:\n                new.append(nums1[p1])\n                p1 = 1\n            else:\n                new.append(nums2[p2])\n                p2 += 1\n        while p1 < len(nums1):\n            new.append(nums1[p1])\n            p2 += 1\n        while p2 < len(nums2):\n            new.append(nums2[p2])\n            p1 += 1\n=\n        if len(new) % 2 == 0:\n            index = len(new) // 2\n            median = (new[index] + new[index-1]) / 2\n        else:\n            median = float(new[len(new)//2])\n        return median\n"
    },
    {
        "slug": "longest-happy-prefix",
        "description": "A string is called a happy prefix if is a non-empty prefix which is also a suffix (excluding itself).\nGiven a string s, return the longest happy prefix of s. Return an empty string \"\" if no such prefix exists.",
        "examples": [
            "Input: s = \"level\"\nOutput: \"l\"\nExplanation: s contains 4 prefix excluding itself (\"l\", \"le\", \"lev\", \"leve\"), and suffix (\"l\", \"el\", \"vel\", \"evel\"). The largest prefix which is also suffix is given by \"l\".",
            "Input: s = \"ababab\"\nOutput: \"abab\"\nExplanation: \"abab\" is the largest prefix which is also suffix. They can overlap in the original string."
        ],
        "constraints": "1 <= s.length <= 105\ns contains only lowercase English letters.",
        "oracle_code": "class Solution:\n    def longestPrefix(self, s: str) -> str:\n        n=len(s)\n        lps=[0]*n\n        j=0\n        for i in range(1,n):\n            while s[i]!=s[j] and j>0:\n                j=lps[j-1]\n\n            if s[i]==s[j]:\n                lps[i]=j+1\n                j+=1\n\n        return s[:lps[-1]]",
        "content": "# Please upvote if it is helpful ^_^\\n***6Companies30days #ReviseWithArsh Challenge 2023\\nDay2\\nQ12. Longest Happy Prefix***\\n\\n**Approach:** *KMP Approach, DP*\\n\\n![12.longest-happy-prefix.jpg](https://assets.leetcode.com/users/images/368329ab-8eb6-4ddb-8c57-fc07336b759d_1672917737.342274.jpeg)\\n\\n**Complexity:** *O(M+N)*\\n\\n# Code\\n**Python3:**\\n```\\nclass Solution:\\n    def longestPrefix(self, s: str) -> str:\\n        n=len(s)\\n        lps=[0]*n\\n        j=0\\n        for i in range(1,n):\\n            while s[i]!=s[j] and j>0:\\n                j=lps[j-1]\\n\\n            if s[i]==s[j]:\\n                lps[i]=j+1\\n                j+=1\\n\\n        return s[:lps[-1]]\\n```",
        "level": "hard",
        "type": [
            "undefined methods",
            "colon missing",
            "operation error"
        ],
        "buggy_code": "\nclass Solution:\n    def longestPrefix(self, s: str) -> str:\n        n=len(s)\n        lps=[0]*n\n        j=0\n        for i in range(1,n)\n            if not self.compareChar(s, i, j):\n                j=lps[j]\n\n            if s[i]==s[j]:\n                lps[i]=j+1\n                j+=1\n\n        return s[:lps[-1]]\n\n"
    },
    {
        "slug": "sum-of-subarray-minimums",
        "description": "Given an array of integers arr, find the sum of min(b), where b ranges over every (contiguous) subarray of arr. Since the answer may be large, return the answer modulo 109 + 7.",
        "examples": [
            "Input: arr = [3,1,2,4]\nOutput: 17\nExplanation: \nSubarrays are [3], [1], [2], [4], [3,1], [1,2], [2,4], [3,1,2], [1,2,4], [3,1,2,4]. \nMinimums are 3, 1, 2, 4, 1, 1, 2, 1, 1, 1.\nSum is 17.",
            "Input: arr = [11,81,94,43,3]\nOutput: 444"
        ],
        "constraints": "1 <= arr.length <= 3 * 104\n1 <= arr[i] <= 3 * 104",
        "oracle_code": "class Solution:\n    def sumSubarrayMins(self, arr: List[int]) -> int:\n        stack = []\n        res = 0\n        arr = [float('-inf')] + arr + [float('-inf')]\n        for i, num in enumerate(arr):\n            while stack and arr[stack[-1]] > num:\n                cur = stack.pop()\n                res += arr[cur] * (i - cur) * (cur - stack[-1])\n            stack.append(i)\n        return res % (10**9 + 7)",
        "content": "Maintain a stack of indexes of subarrays, \\nwhich would have the minimum number at the top of the stack.\\n \\nUse following logic to compute the sum(i):\\n- If arr[i] is small, then arr[i] is minimum for all subarrays \\nstarting at arr[i].\\n- If arr[i] is greater, then find the smallest element from the top of stack which is bigger than arr[i]. \\n- Let the index of the smallest element be on top. \\n- Now, arr[i] is minimum for all subarrays starting at arr[top+1]. \\n\\nWe already know the value of sum(top), so add sum(top) + arr[i] * (i \\u2013 top) to result. Finally, push the index of arr[i] to stack.\\n\\n# Complexity\\nTime Complexity: O(N)\\nSpace Complexity: O(N)\\n\\n# Code\\n```\\nclass Solution:\\n    def sumSubarrayMins(self, arr: List[int]) -> int:\\n        stack = []\\n        res = 0\\n        arr = [float(\\'-inf\\')] + arr + [float(\\'-inf\\')]\\n        for i, num in enumerate(arr):\\n            while stack and arr[stack[-1]] > num:\\n                cur = stack.pop()\\n                res += arr[cur] * (i - cur) * (cur - stack[-1])\\n            stack.append(i)\\n        return res % (10**9 + 7)\\n\\n```",
        "level": "medium",
        "type": [
            "indentation error",
            "other error",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution:\ndef sumSubarrayMins(self, arr: List[int]) -> int:\n    stack = []\n    res = 0\n    arr = [float('-inf')] + arr + [float('-inf')]\n    for i, num in enumerate(arr):\n        while stack and arr[stack[-1]] > num:\n            cur = stack.pop()\n            res += arr[cur] * (cur - i) * (cur - stack[-1]\n        stack.append(i)\n    return res % (10**9 + 7)\n"
    },
    {
        "slug": "closest-dessert-cost",
        "description": "You would like to make dessert and are preparing to buy the ingredients. You have n ice cream base flavors and m types of toppings to choose from. You must follow these rules when making your dessert:\n\nThere must be exactly one ice cream base.\nYou can add one or more types of topping or have no toppings at all.\nThere are at most two of each type of topping.\n\nYou are given three inputs:\n\nbaseCosts, an integer array of length n, where each baseCosts[i] represents the price of the ith ice cream base flavor.\ntoppingCosts, an integer array of length m, where each toppingCosts[i] is the price of one of the ith topping.\ntarget, an integer representing your target price for dessert.\n\nYou want to make a dessert with a total cost as close to target as possible.\nReturn the closest possible cost of the dessert to target. If there are multiple, return the lower one.",
        "examples": [
            "Input: baseCosts = [1,7], toppingCosts = [3,4], target = 10\nOutput: 10\nExplanation: Consider the following combination (all 0-indexed):\n- Choose base 1: cost 7\n- Take 1 of topping 0: cost 1 x 3 = 3\n- Take 0 of topping 1: cost 0 x 4 = 0\nTotal: 7 + 3 + 0 = 10.",
            "Input: baseCosts = [2,3], toppingCosts = [4,5,100], target = 18\nOutput: 17\nExplanation: Consider the following combination (all 0-indexed):\n- Choose base 1: cost 3\n- Take 1 of topping 0: cost 1 x 4 = 4\n- Take 2 of topping 1: cost 2 x 5 = 10\n- Take 0 of topping 2: cost 0 x 100 = 0\nTotal: 3 + 4 + 10 + 0 = 17. You cannot make a dessert with a total cost of 18.",
            "Input: baseCosts = [3,10], toppingCosts = [2,5], target = 9\nOutput: 8\nExplanation: It is possible to make desserts with cost 8 and 10. Return 8 as it is the lower cost."
        ],
        "constraints": "n == baseCosts.length\nm == toppingCosts.length\n1 <= n, m <= 10\n1 <= baseCosts[i], toppingCosts[i] <= 104\n1 <= target <= 104",
        "oracle_code": "class Solution:\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\n        toppingCosts *= 2\n        \n        @cache\n        def fn(i, x):\n            \"\"\"Return sum of subsequence of toppingCosts[i:] closest to x.\"\"\"\n            if x < 0 or i == len(toppingCosts): return 0\n            return min(fn(i+1, x), toppingCosts[i] + fn(i+1, x-toppingCosts[i]), key=lambda y: (abs(y-x), y))\n        \n        ans = inf\n        for bc in baseCosts: \n            ans = min(ans, bc + fn(0, target - bc), key=lambda x: (abs(x-target), x))\n        return ans",
        "content": "\\n```\\nclass Solution:\\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\\n        toppingCosts *= 2\\n        \\n        @cache\\n        def fn(i, x):\\n            \"\"\"Return sum of subsequence of toppingCosts[i:] closest to x.\"\"\"\\n            if x < 0 or i == len(toppingCosts): return 0\\n            return min(fn(i+1, x), toppingCosts[i] + fn(i+1, x-toppingCosts[i]), key=lambda y: (abs(y-x), y))\\n        \\n        ans = inf\\n        for bc in baseCosts: \\n            ans = min(ans, bc + fn(0, target - bc), key=lambda x: (abs(x-target), x))\\n        return ans \\n```\\nTime complexity `O(MNV)`\\n\\nEdited on 2/28/2021\\n\\nAdding the version by @lenchen1112\\n```\\nclass Solution:\\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\\n        \\n        @cache\\n        def fn(i, cost):\\n            \"\"\"Return sum of subsequence closest to target.\"\"\"\\n            if cost >= target or i == len(toppingCosts): return cost\\n            return min(fn(i+1, cost), fn(i+1, cost+toppingCosts[i]), key=lambda x: (abs(x-target), x))\\n        \\n        ans = inf\\n        toppingCosts *= 2\\n        for cost in baseCosts: \\n            ans = min(ans, fn(0, cost), key=lambda x: (abs(x-target), x))\\n        return ans \\n```\\n\\nAdding binary search implementation\\n```\\nclass Solution:\\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\\n        top = {0}\\n        for x in toppingCosts*2: \\n            top |= {x + xx for xx in top}\\n        top = sorted(top)\\n        \\n        ans = inf \\n        for bc in baseCosts: \\n            k = bisect_left(top, target - bc)\\n            if k < len(top): ans = min(ans, bc + top[k], key=lambda x: (abs(x-target), x))\\n            if k: ans = min(ans, bc + top[k-1], key=lambda x: (abs(x-target), x))\\n        return ans \\n```\\nTime complexity `O(N*2^(2N) + MN)`",
        "level": "medium",
        "type": [
            "unclosed string",
            "== and = confusion",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\n        toppingCosts *= 2\n\n        @cache\n        def fn(i, x):\n            \"\"\"Return sum of subsequence of toppingCosts[i:] closest to x.\"\n            if x < 0 or i = len(toppingCosts): return 0\n            return min(fn(i+1, x), toppingCosts[i] + fn(i+2, x-toppingCosts[i]), key=lambda y: (abs(y-x), y))\n        \n        ans = inf\n        for bc in baseCosts: \n            ans = min(ans, bc + fn(0, target - bc), key=lambda x: (abs(x-target), x))\n        return ans\n"
    },
    {
        "slug": "maximize-number-of-nice-divisors",
        "description": "You are given a positive integer primeFactors. You are asked to construct a positive integer n that satisfies the following conditions:\n\nThe number of prime factors of n (not necessarily distinct) is at most primeFactors.\nThe number of nice divisors of n is maximized. Note that a divisor of n is nice if it is divisible by every prime factor of n. For example, if n = 12, then its prime factors are [2,2,3], then 6 and 12 are nice divisors, while 3 and 4 are not.\n\nReturn the number of nice divisors of n. Since that number can be too large, return it modulo 109 + 7.\nNote that a prime number is a natural number greater than 1 that is not a product of two smaller natural numbers. The prime factors of a number n is a list of prime numbers such that their product equals n.",
        "examples": [
            "Input: primeFactors = 5\r\nOutput: 6\r\nExplanation: 200 is a valid value of n.\r\nIt has 5 prime factors: [2,2,2,5,5], and it has 6 nice divisors: [10,20,40,50,100,200].\r\nThere is not other value of n that has at most 5 prime factors and more nice divisors.",
            "Input: primeFactors = 8\r\nOutput: 18"
        ],
        "constraints": "1 <= primeFactors <= 109",
        "oracle_code": "class Solution:\n    def maxNiceDivisors(self, primeFactors: int) -> int:\n        if primeFactors <= 3:\n            return primeFactors\n        \n        MOD = int(1e9 + 7)\n        if primeFactors % 3 == 0:\n            power = primeFactors // 3\n            return self.calculateNiceDivisors(3, power, MOD)\n        elif primeFactors % 3 == 1:\n            power = (primeFactors // 3) - 1\n            return (self.calculateNiceDivisors(3, power, MOD) * 4) % MOD\n        else:\n            power = primeFactors // 3\n            return (self.calculateNiceDivisors(3, power, MOD) * 2) % MOD\n    \n    def calculateNiceDivisors(self, base: int, power: int, MOD: int) -> int:\n        if power == 0:\n            return 1\n\n        result = self.calculateNiceDivisors(base, power // 2, MOD)\n        result = (result * result) % MOD\n\n        if power % 2 == 1:\n            result = (result * base) % MOD\n\n        return result",
        "content": "\\n# Code\\n```\\nclass Solution:\\n    def maxNiceDivisors(self, primeFactors: int) -> int:\\n        if primeFactors <= 3:\\n            return primeFactors\\n        \\n        MOD = int(1e9 + 7)\\n        if primeFactors % 3 == 0:\\n            power = primeFactors // 3\\n            return self.calculateNiceDivisors(3, power, MOD)\\n        elif primeFactors % 3 == 1:\\n            power = (primeFactors // 3) - 1\\n            return (self.calculateNiceDivisors(3, power, MOD) * 4) % MOD\\n        else:\\n            power = primeFactors // 3\\n            return (self.calculateNiceDivisors(3, power, MOD) * 2) % MOD\\n    \\n    def calculateNiceDivisors(self, base: int, power: int, MOD: int) -> int:\\n        if power == 0:\\n            return 1\\n\\n        result = self.calculateNiceDivisors(base, power // 2, MOD)\\n        result = (result * result) % MOD\\n\\n        if power % 2 == 1:\\n            result = (result * base) % MOD\\n\\n        return result\\n\\n```",
        "level": "hard",
        "type": [
            "colon missing",
            "operation error",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution:\n    def maxNiceDivisors(self, primeFactors: int) -> int:\n        if primeFactors <= 3:\n            return primeFactors\n        \n        MOD = int(1e9 + 7)\n        if primeFactors % 3 == 0\n            power = primeFactors // 3\n            return self.calculateNiceDivisors(3, power, MOD) * 2\n        elif primeFactors % 3 == 1:\n            power = (primeFactors // 3) - 1\n            return (self.calculateNiceDivisors(3, power, MOD) * 4) % MOD\n        else:\n            power = primeFactors // 3\n            return (self.calculateNiceDivisors(3, power, MOD) * 2) % MOD\n    \n    def calculateNiceDivisors(self, base: int, power: int, MOD: int) -> int:\n        if power == 0:\n            return 1\n\n        result = self.calculateNiceDivisors(base, power // 2, MOD)\n        result = (result * result) % MOD\n\n        if power % modulo == 1:\n            result = (result * base) % MOD\n\n        return result\n"
    },
    {
        "slug": "count-number-of-maximum-bitwise-or-subsets",
        "description": "Given an integer array nums, find the maximum possible bitwise OR of a subset of nums and return the number of different non-empty subsets with the maximum bitwise OR.\nAn array a is a subset of an array b if a can be obtained from b by deleting some (possibly zero) elements of b. Two subsets are considered different if the indices of the elements chosen are different.\nThe bitwise OR of an array a is equal to a[0] OR a[1] OR ... OR a[a.length - 1] (0-indexed).",
        "examples": [
            "Input: nums = [3,1]\nOutput: 2\nExplanation: The maximum possible bitwise OR of a subset is 3. There are 2 subsets with a bitwise OR of 3:\n- [3]\n- [3,1]",
            "Input: nums = [2,2,2]\nOutput: 7\nExplanation: All non-empty subsets of [2,2,2] have a bitwise OR of 2. There are 23 - 1 = 7 total subsets.",
            "Input: nums = [3,2,1,5]\nOutput: 6\nExplanation: The maximum possible bitwise OR of a subset is 7. There are 6 subsets with a bitwise OR of 7:\n- [3,5]\n- [3,1,5]\n- [3,2,5]\n- [3,2,1,5]\n- [2,5]\n- [2,1,5]"
        ],
        "constraints": "1 <= nums.length <= 16\n1 <= nums[i] <= 105",
        "oracle_code": "import functools\nclass Solution:\n    def countMaxOrSubsets(self, nums: List[int]) -> int:\n        mapping = collections.defaultdict(int)\n        for count in range(1,len(nums)+1):\n            subsets = list(itertools.combinations(nums,count))\n            for ele in subsets:\n                mapping[functools.reduce(lambda a,b: a|b,list(ele))] += 1\n        return mapping[max(mapping.keys())]",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport functools\\nclass Solution:\\n    def countMaxOrSubsets(self, nums: List[int]) -> int:\\n        mapping = collections.defaultdict(int)\\n        for count in range(1,len(nums)+1):\\n            subsets = list(itertools.combinations(nums,count))\\n            for ele in subsets:\\n                mapping[functools.reduce(lambda a,b: a|b,list(ele))] += 1\\n        return mapping[max(mapping.keys())]\\n\\n```",
        "level": "medium",
        "type": [
            "operation error",
            "undefined objects",
            "wrong comment mark"
        ],
        "buggy_code": "\n\nimport functools\n\ndef countMaxOrSubsets(nums: List[int]) -> int:\n    mapping = collections.defaultdict(int)\n    for count in range(1,len(nums)+1):\n        subsets = list(itertools.combinations(nums,count))\n        for ele in subsets:\n            mapping[functools.reduce(lambda a,b: a^b,list(ele), value)] += 1\n    return mapping[max(mapping.keys())]\n"
    },
    {
        "slug": "lexicographically-smallest-palindrome",
        "description": "You are given a string s consisting of lowercase English letters, and you are allowed to perform operations on it. In one operation, you can replace a character in s with another lowercase English letter.\nYour task is to make s a palindrome with the minimum number of operations possible. If there are multiple palindromes that can be made using the minimum number of operations, make the lexicographically smallest one.\nA string a is lexicographically smaller than a string b (of the same length) if in the first position where a and b differ, string a has a letter that appears earlier in the alphabet than the corresponding letter in b.\nReturn the resulting palindrome string.",
        "examples": [
            "Input: s = \"egcfe\"\nOutput: \"efcfe\"\nExplanation: The minimum number of operations to make \"egcfe\" a palindrome is 1, and the lexicographically smallest palindrome string we can get by modifying one character is \"efcfe\", by changing 'g'.",
            "Input: s = \"abcd\"\nOutput: \"abba\"\nExplanation: The minimum number of operations to make \"abcd\" a palindrome is 2, and the lexicographically smallest palindrome string we can get by modifying two characters is \"abba\".",
            "Input: s = \"seven\"\nOutput: \"neven\"\nExplanation: The minimum number of operations to make \"seven\" a palindrome is 1, and the lexicographically smallest palindrome string we can get by modifying one character is \"neven\"."
        ],
        "constraints": "1 <= s.length <= 1000\ns\u00a0consists of only lowercase English letters.",
        "oracle_code": "class Solution:\n    def makeSmallestPalindrome(self, s: str) -> str:\n        before = 0\n        after = len(s)-1\n        l = [i for i in s]\n        while before <= len(s)/2:\n            l[before] = min(l[before], l[after])\n            l[after] = l[before]\n            before+=1\n            after-=1\n        return \"\".join(l)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: 214 ms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 16.5 MB\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def makeSmallestPalindrome(self, s: str) -> str:\\n        before = 0\\n        after = len(s)-1\\n        l = [i for i in s]\\n        while before <= len(s)/2:\\n            l[before] = min(l[before], l[after])\\n            l[after] = l[before]\\n            before+=1\\n            after-=1\\n        return \"\".join(l)\\n```",
        "level": "easy",
        "type": [
            "undefined methods",
            "colon missing",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def makeSmallestPalindrome(self, s: str) -> str\n        before = 0\n        after = len(s)-1\n        l = [i for i in s]\n        while before <= len(s):\n            l[before] = self.min(l[before], l[after])\n            l[after] = l[before]\n            before+=1\n            after-=1\n        return \"\".join(l)\n"
    },
    {
        "slug": "sliding-window-median",
        "description": "The median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle values.\n\nFor examples, if arr = [2,3,4], the median is 3.\nFor examples, if arr = [1,2,3,4], the median is (2 + 3) / 2 = 2.5.\n\nYou are given an integer array nums and an integer k. There is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position.\nReturn the median array for each window in the original array. Answers within 10-5 of the actual value will be accepted.",
        "examples": [
            "Input: nums = [1,3,-1,-3,5,3,6,7], k = 3\nOutput: [1.00000,-1.00000,-1.00000,3.00000,5.00000,6.00000]\nExplanation: \nWindow position                Median\n---------------                -----\n[1  3  -1] -3  5  3  6  7        1\n 1 [3  -1  -3] 5  3  6  7       -1\n 1  3 [-1  -3  5] 3  6  7       -1\n 1  3  -1 [-3  5  3] 6  7        3\n 1  3  -1  -3 [5  3  6] 7        5\n 1  3  -1  -3  5 [3  6  7]       6",
            "Input: nums = [1,2,3,4,2,3,1,4,2], k = 3\nOutput: [2.00000,3.00000,3.00000,3.00000,2.00000,3.00000,2.00000]"
        ],
        "constraints": "1 <= k <= nums.length <= 105\n-231 <= nums[i] <= 231 - 1",
        "oracle_code": "class Solution:\n    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\n        tree = None\n        ans = []\n        for i, x in enumerate(nums):\n            tree = insert(tree, x)\n            if size(tree) > k:\n                tree = remove(tree, nums[i - k])\n            if size(tree) == k:\n                if k % 2 == 1:\n                    ans.append(get(tree, k // 2 + 1))\n                else:\n                    ans.append((get(tree, k // 2) + get(tree, k // 2 + 1)) / 2)\n        return ans\n\n\n\nclass Node:\n    __slots__ = ['val', 'count', 'weight', 'size', 'left', 'right']\n    def __init__(self, val):\n        self.val = val\n        self.count = 1\n        self.weight = random.random()\n        self.size = 1\n        self.left = self.right = None\n\n\ndef touch(root):\n    if not root:\n        return\n    root.size = root.count + size(root.left) + size(root.right)\n\n\ndef size(root):\n    if not root:\n        return 0\n    return root.size\n\n\ndef insert(root, val):\n    t1, r, t2 = split(root, val)\n    if not r:\n        r = Node(val)\n    else:\n        r.count += 1\n        touch(r)\n    t2 = join(r, t2)\n    return join(t1, t2)\n\n\ndef remove(root, val):\n    t1, r, t2 = split(root, val)\n    if r and r.count > 1:\n        r.count -= 1\n        touch(r)\n        t2 = join(r, t2)\n    return join(t1, t2)\n\n\ndef split(root, val):\n    if not root:\n        return None, None, None\n    elif root.val < val:\n        a, b, c = split(root.right, val)\n        root.right = a\n        touch(root)\n        return root, b, c\n    elif root.val > val:\n        a, b, c = split(root.left, val)\n        root.left = c\n        touch(root)\n        return a, b, root\n    else:\n        a, c = root.left, root.right\n        root.left = root.right = None\n        touch(root)\n        return a, root, c\n\n\ndef join(t1, t2):\n    if not t1:\n        return t2\n    elif not t2:\n        return t1\n    elif t1.weight < t2.weight:\n        t1.right = join(t1.right, t2)\n        touch(t1)\n        return t1\n    else:\n        t2.left = join(t1, t2.left)\n        touch(t2)\n        return t2\n\n\ndef get(root, index):\n    if size(root.left) < index <= size(root.left) + root.count:\n        return root.val\n    elif size(root.left) + root.count < index:\n        return get(root.right, index - root.count - size(root.left))\n    else:\n        return get(root.left, index)",
        "content": "\\n\\n```\\nclass Solution:\\n    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\\n        tree = None\\n        ans = []\\n        for i, x in enumerate(nums):\\n            tree = insert(tree, x)\\n            if size(tree) > k:\\n                tree = remove(tree, nums[i - k])\\n            if size(tree) == k:\\n                if k % 2 == 1:\\n                    ans.append(get(tree, k // 2 + 1))\\n                else:\\n                    ans.append((get(tree, k // 2) + get(tree, k // 2 + 1)) / 2)\\n        return ans\\n\\n\\n\\nclass Node:\\n    __slots__ = [\\'val\\', \\'count\\', \\'weight\\', \\'size\\', \\'left\\', \\'right\\']\\n    def __init__(self, val):\\n        self.val = val\\n        self.count = 1\\n        self.weight = random.random()\\n        self.size = 1\\n        self.left = self.right = None\\n\\n\\ndef touch(root):\\n    if not root:\\n        return\\n    root.size = root.count + size(root.left) + size(root.right)\\n\\n\\ndef size(root):\\n    if not root:\\n        return 0\\n    return root.size\\n\\n\\ndef insert(root, val):\\n    t1, r, t2 = split(root, val)\\n    if not r:\\n        r = Node(val)\\n    else:\\n        r.count += 1\\n        touch(r)\\n    t2 = join(r, t2)\\n    return join(t1, t2)\\n\\n\\ndef remove(root, val):\\n    t1, r, t2 = split(root, val)\\n    if r and r.count > 1:\\n        r.count -= 1\\n        touch(r)\\n        t2 = join(r, t2)\\n    return join(t1, t2)\\n\\n\\ndef split(root, val):\\n    if not root:\\n        return None, None, None\\n    elif root.val < val:\\n        a, b, c = split(root.right, val)\\n        root.right = a\\n        touch(root)\\n        return root, b, c\\n    elif root.val > val:\\n        a, b, c = split(root.left, val)\\n        root.left = c\\n        touch(root)\\n        return a, b, root\\n    else:\\n        a, c = root.left, root.right\\n        root.left = root.right = None\\n        touch(root)\\n        return a, root, c\\n\\n\\ndef join(t1, t2):\\n    if not t1:\\n        return t2\\n    elif not t2:\\n        return t1\\n    elif t1.weight < t2.weight:\\n        t1.right = join(t1.right, t2)\\n        touch(t1)\\n        return t1\\n    else:\\n        t2.left = join(t1, t2.left)\\n        touch(t2)\\n        return t2\\n\\n\\ndef get(root, index):\\n    if size(root.left) < index <= size(root.left) + root.count:\\n        return root.val\\n    elif size(root.left) + root.count < index:\\n        return get(root.right, index - root.count - size(root.left))\\n    else:\\n        return get(root.left, index)\\n\\n```",
        "level": "hard",
        "type": [
            "undefined methods",
            "unclosed string",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\n        tree = None\n        ans = []\n        for i, x in enumerate(nums):\n            tree = insert(tree, x)\n            if size(tree) > k:\n                tree = remove(tree, nums[i - k + 1])\n            if size(tree) == k:\n                if k % 2 == 1:\n                    ans.append(get(tree, k // 2 + 1))\n                else:\n                    nums.append((release(tree, k // 2) + get('tree', k // 2 + 1)) / 2)\n        return nums\n\n"
    },
    {
        "slug": "check-if-string-is-transformable-with-substring-sort-operations",
        "description": "Given two strings s and t, transform string s into string t using the following operation any number of times:\n\nChoose a non-empty substring in s and sort it in place so the characters are in ascending order.\n\n\t\nFor example, applying the operation on the underlined substring in \"14234\" results in \"12344\".\n\n\n\nReturn true if it is possible to transform s into t. Otherwise, return false.\nA substring is a contiguous sequence of characters within a string.",
        "examples": [
            "Input: s = \"84532\", t = \"34852\"\nOutput: true\nExplanation: You can transform s into t using the following sort operations:\n\"84532\" (from index 2 to 3) -> \"84352\"\n\"84352\" (from index 0 to 2) -> \"34852\"",
            "Input: s = \"34521\", t = \"23415\"\nOutput: true\nExplanation: You can transform s into t using the following sort operations:\n\"34521\" -> \"23451\"\n\"23451\" -> \"23415\"",
            "Input: s = \"12345\", t = \"12435\"\nOutput: false"
        ],
        "constraints": "s.length == t.length\n1 <= s.length <= 105\ns and t consist of only digits.",
        "oracle_code": "class BIT():\n    def __init__(self, n):\n        self.n = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        ans = 0\n        i += 1\n        while i > 0:\n            ans += self.tree[i]\n            i -= (i & (-i))\n        return ans\n\n    def update(self, i, value):\n        i += 1\n        while i <= self.n:\n            self.tree[i] += value\n            i += (i & (-i))\n\n\nclass Solution:\n    def isTransformable(self, s: str, t: str) -> bool:\n        if Counter(s)!=Counter(t):\n            return False\n        ind = defaultdict(deque)\n        for id, i in enumerate(t):\n            ind[i].append(id)\n        a = []\n        for i in s:\n            a.append(ind[i].popleft())\n        n=len(a)\n        bt=BIT(n+1)\n        ind=defaultdict(lambda :-1)\n        for i in range(n):\n            inv=bt.sum(n)-bt.sum(a[i])\n            bt.update(a[i],1)\n            for dig in range(int(s[i])-1,-1,-1):\n                if ind[dig]>=i-inv:\n                    return False\n            ind[int(s[i])]=i-inv\n        return True",
        "content": "\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass BIT():\\n    def __init__(self, n):\\n        self.n = n\\n        self.tree = [0] * (n + 1)\\n\\n    def sum(self, i):\\n        ans = 0\\n        i += 1\\n        while i > 0:\\n            ans += self.tree[i]\\n            i -= (i & (-i))\\n        return ans\\n\\n    def update(self, i, value):\\n        i += 1\\n        while i <= self.n:\\n            self.tree[i] += value\\n            i += (i & (-i))\\n\\n\\nclass Solution:\\n    def isTransformable(self, s: str, t: str) -> bool:\\n        if Counter(s)!=Counter(t):\\n            return False\\n        ind = defaultdict(deque)\\n        for id, i in enumerate(t):\\n            ind[i].append(id)\\n        a = []\\n        for i in s:\\n            a.append(ind[i].popleft())\\n        n=len(a)\\n        bt=BIT(n+1)\\n        ind=defaultdict(lambda :-1)\\n        for i in range(n):\\n            inv=bt.sum(n)-bt.sum(a[i])\\n            bt.update(a[i],1)\\n            for dig in range(int(s[i])-1,-1,-1):\\n                if ind[dig]>=i-inv:\\n                    return False\\n            ind[int(s[i])]=i-inv\\n        return True\\n\\n\\n```",
        "level": "hard",
        "type": [
            "colon missing",
            "operation error",
            "undefined objects"
        ],
        "buggy_code": "\nclass BIT():\n    def __init__(self, n):\n        self.n = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i)\n        ans = 0\n        i += 1\n        while i > 0:\n            ans += self.tree[i]\n            i -= (i & (-i))\n        return ans\n\n    def update(self, i, value):\n        i += 1\n        while i <= self.n:\n            self.tree[i] += value\n            i -= (i & (-i))  \n\n\nclass Solution:\n    def isTransformable(self, s: str, t: str) -> bool:\n        if Counter(s)!=Counter(t):\n            return False\n        ind = defaultdict(deque)\n        for id, i in enumerate(t):\n            ind[i].append(id)\n        a = []\n        for i in s:\n            a.append(ind[x].popleft())\n        n=len(a)\n        bt=BIT(n+1)\n        ind=defaultdict(lambda :-1)\n        for i in range(n):\n            inv=bt.sum(n)-bt.sum(a[i])\n            bt.update(a[i],1)\n            for dig in range(int(s[i])-1,-1,-1):\n                if ind[dig]>=i-inv:\n                    return False\n            ind[int(s[i])]=i-inv\n        return True\n"
    },
    {
        "slug": "length-of-the-longest-valid-substring",
        "description": "You are given a string word and an array of strings forbidden.\nA string is called valid if none of its substrings are present in forbidden.\nReturn the length of the longest valid substring of the string word.\nA substring is a contiguous sequence of characters in a string, possibly empty.",
        "examples": [
            "Input: word = \"cbaaaabc\", forbidden = [\"aaa\",\"cb\"]\nOutput: 4\nExplanation: There are 11 valid substrings in word: \"c\", \"b\", \"a\", \"ba\", \"aa\", \"bc\", \"baa\", \"aab\", \"ab\", \"abc\"and \"aabc\". The length of the longest valid substring is 4. \nIt can be shown that all other substrings contain either \"aaa\" or \"cb\" as a substring.",
            "Input: word = \"leetcode\", forbidden = [\"de\",\"le\",\"e\"]\nOutput: 4\nExplanation: There are 11 valid substrings in word: \"l\", \"t\", \"c\", \"o\", \"d\", \"tc\", \"co\", \"od\", \"tco\", \"cod\", and \"tcod\". The length of the longest valid substring is 4.\nIt can be shown that all other substrings contain either \"de\", \"le\", or \"e\" as a substring."
        ],
        "constraints": "1 <= word.length <= 105\nword consists only of lowercase English letters.\n1 <= forbidden.length <= 105\n1 <= forbidden[i].length <= 10\nforbidden[i] consists only of lowercase English letters.",
        "oracle_code": "class Solution:\n    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int:\n        trie = {}\n        for f in forbidden:\n            t = trie\n            for c in f:\n                if c not in t:\n                    t[c] = {}\n                t = t[c]\n            t[\"end\"] = True\n        \n        def isForbidden(s):\n            t = trie\n            counter = 0\n            for c in s:\n                if c not in t:\n                    return False\n                t = t[c]\n                counter += 1\n                if \"end\" in t:\n                    return counter\n            return False\n        \n        res = 0\n        j = len(word)\n        for i in range(len(word) - 1, -1, -1):\n            truc = isForbidden(word[i:j])\n            if truc:\n                j = i + truc - 1\n            res = max(res, j - i)\n        return res",
        "content": "Put all the forbidden strings into a trie, so that for each string `s`, we can check every substring starts from the beginning (i.e. `s[:1]`,  `s[:2]` ...  `s[:len(s)]`) in one travesal.\\n\\nUse a sliding window to iterate from back to front, each time, we only need to check whether the substrings starting from the new character is forbidden. If the substring is forbidden, then we truncate the string and continue to search.\\n\\nUsing a trie can make the foibidden check fails faster and can deal with longer foibidden strings.\\n\\n# Code\\n```\\nclass Solution:\\n    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int:\\n        trie = {}\\n        for f in forbidden:\\n            t = trie\\n            for c in f:\\n                if c not in t:\\n                    t[c] = {}\\n                t = t[c]\\n            t[\"end\"] = True\\n        \\n        def isForbidden(s):\\n            t = trie\\n            counter = 0\\n            for c in s:\\n                if c not in t:\\n                    return False\\n                t = t[c]\\n                counter += 1\\n                if \"end\" in t:\\n                    return counter\\n            return False\\n        \\n        res = 0\\n        j = len(word)\\n        for i in range(len(word) - 1, -1, -1):\\n            truc = isForbidden(word[i:j])\\n            if truc:\\n                j = i + truc - 1\\n            res = max(res, j - i)\\n        return res\\n```",
        "level": "hard",
        "type": [
            "undefined methods",
            "colon missing",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int\n        trie = {}\n        for f in forbidden:\n            t = trie\n            for c in f:\n                if c not in t:\n                    t[c] = {}\n                t = t[c]\n            t[\"end\"] = True\n        \n        def isForbidden(s):\n            t = trie\n            counter = 0\n            for c in s:\n                if c not in t:\n                    return False\n                t = t[c]\n                counter += 1\n                if \"end\" in t:\n                    return counter\n            return False\n        \n        res = 0\n        j = len(word) + 1\n        for i in range(len(word) - 1, -1, -1):\n            truc = isForbidden(word[i:j])\n            if truc:\n                j = i + truc - 1\n                undefinedFunction(word)\n            res = max(res, j - i)\n        return res\n"
    },
    {
        "slug": "binary-tree-level-order-traversal-ii",
        "description": "Given the root of a binary tree, return the bottom-up level order traversal of its nodes' values. (i.e., from left to right, level by level from leaf to root).",
        "examples": [
            "Input: root = [3,9,20,null,null,15,7]\nOutput: [[15,7],[9,20],[3]]",
            "Input: root = [1]\nOutput: [[1]]",
            "Input: root = []\nOutput: []"
        ],
        "constraints": "The number of nodes in the tree is in the range [0, 2000].\n-1000 <= Node.val <= 1000",
        "oracle_code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:\n        def checkReverse(ans):\n            l,r = 0,len(ans)-1\n            while l<=r:\n                ans[l],ans[r] = ans[r],ans[l]\n                l+=1\n                r-=1\n            return ans\n\n        if not root: return None\n        q,ans = [root],[]\n        while q:\n            n,l = len(q),[]\n            for i in range(n):\n                curr = q.pop(0)\n                l.append(curr.val)\n                if curr.left:\n                    q.append(curr.left)\n                if curr.right:\n                    q.append(curr.right)\n            ans.append(l)\n        return checkReverse(ans)",
        "content": "# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:\\n        def checkReverse(ans):\\n            l,r = 0,len(ans)-1\\n            while l<=r:\\n                ans[l],ans[r] = ans[r],ans[l]\\n                l+=1\\n                r-=1\\n            return ans\\n\\n        if not root: return None\\n        q,ans = [root],[]\\n        while q:\\n            n,l = len(q),[]\\n            for i in range(n):\\n                curr = q.pop(0)\\n                l.append(curr.val)\\n                if curr.left:\\n                    q.append(curr.left)\\n                if curr.right:\\n                    q.append(curr.right)\\n            ans.append(l)\\n        return checkReverse(ans)\\n```",
        "level": "medium",
        "type": [
            "undefined objects",
            "indexing error",
            "conditional statement error"
        ],
        "buggy_code": "\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:\n        def checkReverse(ans):\n            l,r = 0,len(ans)\n            while l<=r:\n                ans[l],ans[r] = ans[r],ans[l]\n                l+=1\n                r-=1\n            return ans\n\n        if not root: return None\n        q,ans = [root],[]\n        while q:\n            n,l = len(Node),[]\n            for i in range(n):\n                curr = q.pop(0)\n                l.append(curr.val)\n                q.append(curr.left)\n                q.append(curr.right)\n\n            ans.append(l)\n        return checkReverse(ans)\n"
    },
    {
        "slug": "palindrome-pairs",
        "description": "You are given a 0-indexed array of unique strings words.\nA palindrome pair is a pair of integers (i, j) such that:\n\n0 <= i, j < words.length,\ni != j, and\nwords[i] + words[j] (the concatenation of the two strings) is a palindrome.\n\nReturn an array of all the palindrome pairs of words.",
        "examples": [
            "Input: words = [\"abcd\",\"dcba\",\"lls\",\"s\",\"sssll\"]\nOutput: [[0,1],[1,0],[3,2],[2,4]]\nExplanation: The palindromes are [\"abcddcba\",\"dcbaabcd\",\"slls\",\"llssssll\"]",
            "Input: words = [\"bat\",\"tab\",\"cat\"]\nOutput: [[0,1],[1,0]]\nExplanation: The palindromes are [\"battab\",\"tabbat\"]",
            "Input: words = [\"a\",\"\"]\nOutput: [[0,1],[1,0]]\nExplanation: The palindromes are [\"a\",\"a\"]"
        ],
        "constraints": "1 <= words.length <= 5000\n0 <= words[i].length <= 300\nwords[i] consists of lowercase English letters.",
        "oracle_code": "class Solution:\n    def palindromePairs(self, words: List[str]) -> List[List[int]]:\n        backward, res = {}, []\n        for i, word in enumerate(words):\n            backward[word[::-1]] = i\n\n        for i, word in enumerate(words):\n            \n            if word in backward and backward[word] != i:\n                res.append([i, backward[word]])\n                \n            if word != \"\" and \"\" in backward and word == word[::-1]:\n                res.append([i, backward[\"\"]])\n                res.append([backward[\"\"], i])\n                \n            for j in range(len(word)):\n                if word[j:] in backward and word[:j] == word[j-1::-1]:\n                    res.append([backward[word[j:]], i])\n                if word[:j] in backward and word[j:] == word[:j-1:-1]:\n                    res.append([i, backward[word[:j]]])\n                    \n        return res",
        "content": "Please upvote if it helps!\\n```\\nclass Solution:\\n    def palindromePairs(self, words: List[str]) -> List[List[int]]:\\n        backward, res = {}, []\\n        for i, word in enumerate(words):\\n            backward[word[::-1]] = i\\n\\n        for i, word in enumerate(words):\\n            \\n            if word in backward and backward[word] != i:\\n                res.append([i, backward[word]])\\n                \\n            if word != \"\" and \"\" in backward and word == word[::-1]:\\n                res.append([i, backward[\"\"]])\\n                res.append([backward[\"\"], i])\\n                \\n            for j in range(len(word)):\\n                if word[j:] in backward and word[:j] == word[j-1::-1]:\\n                    res.append([backward[word[j:]], i])\\n                if word[:j] in backward and word[j:] == word[:j-1:-1]:\\n                    res.append([i, backward[word[:j]]])\\n                    \\n        return res",
        "level": "hard",
        "type": [
            "undefined keywords from other languages",
            "unclosed string",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def palindromePairs(self, words: Arreglo[str]) -> Arreglo[Arreglo[int]]:\n        backward, res = {}, []\n        for i, word in enumerate(words):\n            backward[word[::-1]] = i\n\n        for i, word in enumerate(words):\n            \n            if word in backward' and backward[word] != i:\n                res.append([i, backward[word]])\n                \n            if word != \"\" and \"\" in backward and word == word[::-1]:\n                res.append([i, backward[\"\"]])\n                res.append([backward[\"\"], i])\n                \n            for j in range(len(word)):\n                if word[j:] in backward and word[:j] == word[j::-1]:\n                    res.append([backward[word[j:]], i])\n                if word[:j] in backward and word[j:] == word[:j-1:-1]:\n                    res.append([i, backward[word[:j]]])\n                    \n        return res\n"
    },
    {
        "slug": "maximize-the-minimum-powered-city",
        "description": "You are given a 0-indexed integer array stations of length n, where stations[i] represents the number of power stations in the ith city.\nEach power station can provide power to every city in a fixed range. In other words, if the range is denoted by r, then a power station at city i can provide power to all cities j such that |i - j| <= r and 0 <= i, j <= n - 1.\n\nNote that |x| denotes absolute value. For example, |7 - 5| = 2 and |3 - 10| = 7.\n\nThe power of a city is the total number of power stations it is being provided power from.\nThe government has sanctioned building k more power stations, each of which can be built in any city, and have the same range as the pre-existing ones.\nGiven the two integers r and k, return the maximum possible minimum power of a city, if the additional power stations are built optimally.\nNote that you can build the k power stations in multiple cities.",
        "examples": [
            "Input: stations = [1,2,4,5,0], r = 1, k = 2\nOutput: 5\nExplanation: \nOne of the optimal ways is to install both the power stations at city 1. \nSo stations will become [1,4,4,5,0].\n- City 0 is provided by 1 + 4 = 5 power stations.\n- City 1 is provided by 1 + 4 + 4 = 9 power stations.\n- City 2 is provided by 4 + 4 + 5 = 13 power stations.\n- City 3 is provided by 5 + 4 = 9 power stations.\n- City 4 is provided by 5 + 0 = 5 power stations.\nSo the minimum power of a city is 5.\nSince it is not possible to obtain a larger power, we return 5.",
            "Input: stations = [4,4,4,4], r = 0, k = 3\nOutput: 4\nExplanation: \nIt can be proved that we cannot make the minimum power of a city greater than 4."
        ],
        "constraints": "n == stations.length\n1 <= n <= 105\n0 <= stations[i] <= 105\n0 <= r\u00a0<= n - 1\n0 <= k\u00a0<= 109",
        "oracle_code": "class Solution:\n    def maxPower(self, stations: List[int], r: int, k: int) -> int:\n        start, end = min(stations), sum(stations) + k\n        while start + 1 < end:\n            mid = (start + end) // 2\n            if self.check(stations, r, k, mid):\n                start = mid\n            else:\n                end = mid\n        if self.check(stations, r, k, end):\n            return end\n        else:\n            return start\n    \n    def check(self, stations, r, k, target):\n            n = len(stations)\n            ans = True\n            newStations = defaultdict(int)\n            power = sum(stations[ : r])\n            for i in range(n):\n                if i + r < n:\n                    power += stations[i + r]\n                if i - r - 1 >= 0:\n                    power -= stations[i - r - 1]\n                if power >= target:\n                    continue\n                elif power + k < target:\n                    ans = False\n                    break\n                else:\n                    diff = target - power\n                    power = target\n                    stations[min(i + r, n - 1)] += diff\n                    k -= diff\n                    newStations[min(i + r, n - 1)] += diff\n            for i in newStations:\n                stations[i] -= newStations[i]\n            return ans",
        "content": "# Approach\\nWe perform a binary search on the possible answer space by checking whether the given `target` (maximum possible minimum power) is valid or not. For each given `target`, we utilize a sliding window algorithm to check its validity in linear time.\\n\\n# Complexity\\n- Time complexity: `O(NlogA)`, where `A` is the range of `[min(stations), sum(stations) + k]`.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: `O(N)`, for the use of a hashmap to record the addition of new stations temporarily.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxPower(self, stations: List[int], r: int, k: int) -> int:\\n        start, end = min(stations), sum(stations) + k\\n        while start + 1 < end:\\n            mid = (start + end) // 2\\n            if self.check(stations, r, k, mid):\\n                start = mid\\n            else:\\n                end = mid\\n        if self.check(stations, r, k, end):\\n            return end\\n        else:\\n            return start\\n    \\n    def check(self, stations, r, k, target):\\n            n = len(stations)\\n            ans = True\\n            newStations = defaultdict(int)\\n            power = sum(stations[ : r])\\n            for i in range(n):\\n                if i + r < n:\\n                    power += stations[i + r]\\n                if i - r - 1 >= 0:\\n                    power -= stations[i - r - 1]\\n                if power >= target:\\n                    continue\\n                elif power + k < target:\\n                    ans = False\\n                    break\\n                else:\\n                    diff = target - power\\n                    power = target\\n                    stations[min(i + r, n - 1)] += diff\\n                    k -= diff\\n                    newStations[min(i + r, n - 1)] += diff\\n            for i in newStations:\\n                stations[i] -= newStations[i]\\n            return ans\\n```",
        "level": "hard",
        "type": [
            "undefined objects",
            "wrong comment mark",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def maxPower(self, stations: List[int], r: int, k: int) -> int:\n        start, \n        while start + 1 < end:\n            mid = (start + end) // 2\n            if self.check(stations, r, k, mid):\n                start = mid\n            else:\n                end = mid\n        if self.check(stations, r, k, end):\n            return end\n        else:\n            return start\n    \n    def check(self, stations, r, k, target):\n            n = len(stations)\n            ans = True\n            newStations = defaultdict(int)\n            power = sum(stations[ : r])\n            for i in range(n + 1):\n                if i + r < n:\n                    power += stations[i + r]\n                if i - r - 1 >= 0:\n                    power -= stations[i - r - 1]\n                if power >= target:\n                    continue\n                elif power + k < target:\n                    ans = False\n                    break\n                else:\n                    diff = target - power\n                    power = target\n                    stations[min(i + r, n - 1)] += diff\n                    k -= diff\n                    newStations[min(i + r, n - 1)] += diff\n            for i in newStations:\n                stations[i] -= newStations[i]\n            return ans\n\nmy_solution = Solution()\nmy_solution.maxPower([1,2,3], 2, 5)\n"
    },
    {
        "slug": "linked-list-in-binary-tree",
        "description": "Given a binary tree root and a\u00a0linked list with\u00a0head\u00a0as the first node.\u00a0\nReturn True if all the elements in the linked list starting from the head correspond to some downward path connected in the binary tree\u00a0otherwise return False.\nIn this context downward path means a path that starts at some node and goes downwards.",
        "examples": [
            "Input: head = [4,2,8], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]\nOutput: true\nExplanation: Nodes in blue form a subpath in the binary Tree.",
            "Input: head = [1,4,2,6], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]\nOutput: true",
            "Input: head = [1,4,2,6,8], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]\nOutput: false\nExplanation: There is no path in the binary tree that contains all the elements of the linked list from head."
        ],
        "constraints": "The number of nodes in the tree will be in the range [1, 2500].\nThe number of nodes in the list will be in the range [1, 100].\n1 <= Node.val\u00a0<= 100\u00a0for each node in the linked list and binary tree.",
        "oracle_code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\n\n        if head is None:\n            return True\n\n        if root is None:\n            return False\n\n        if head.val == root.val:\n            if self.isSame(head, root):\n                return True\n            \n        return self.isSubPath(head, root.left) or self.isSubPath(head, root.right)\n\n    \n    def isSame(self, head, root):\n\n        if head is None:\n            return True\n        \n        if root is None:\n            return False\n\n        if head.val == root.val:\n            return self.isSame(head.next, root.left) or self.isSame(head.next, root.right)\n        \n        return False",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\\n\\n        if head is None:\\n            return True\\n\\n        if root is None:\\n            return False\\n\\n        if head.val == root.val:\\n            if self.isSame(head, root):\\n                return True\\n            \\n        return self.isSubPath(head, root.left) or self.isSubPath(head, root.right)\\n\\n    \\n    def isSame(self, head, root):\\n\\n        if head is None:\\n            return True\\n        \\n        if root is None:\\n            return False\\n\\n        if head.val == root.val:\\n            return self.isSame(head.next, root.left) or self.isSame(head.next, root.right)\\n        \\n        return False\\n        \\n\\n```",
        "level": "medium",
        "type": [
            "variable value error",
            "== and = confusion",
            "indexing error"
        ],
        "buggy_code": "\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\n\n        if head is None:\n            return True\n\n        if root is None:\n            return False\n\n        if head.val == root.val:\n            if self.isSame(head.next, root):  \n                return True\n            \n        return self.isSubPath(head.next, root.left) or self.isSubPath(head.next, root.right)\n\n    \n    def isSame(self, head, root):\n\n        if head is None:\n            return True\n        \n        if root is None:\n            return False\n\n        if head.val = root.val: \n            return self.isSame(head.next, root.left) or self.isSame(head.next, root.right)\n        \n        return False\n"
    },
    {
        "slug": "k-th-smallest-in-lexicographical-order",
        "description": "Given two integers n and k, return the kth lexicographically smallest integer in the range [1, n].",
        "examples": [
            "Input: n = 13, k = 2\nOutput: 10\nExplanation: The lexicographical order is [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9], so the second smallest number is 10.",
            "Input: n = 1, k = 1\nOutput: 1"
        ],
        "constraints": "1 <= k <= n <= 109",
        "oracle_code": "class Solution:\n    def findKthNumber(self, n: int, k: int) -> int:\n        \n        def fn(x): \n            \"\"\"Return node counts in denary trie.\"\"\"\n            ans, diff = 0, 1\n            while x <= n: \n                ans += min(n - x + 1, diff)\n                x *= 10 \n                diff *= 10 \n            return ans \n        \n        x = 1\n        while k > 1: \n            cnt = fn(x)\n            if k > cnt: k -= cnt; x += 1\n            else: k -= 1; x *= 10 \n        return x",
        "content": "\\n```\\nclass Solution:\\n    def findKthNumber(self, n: int, k: int) -> int:\\n        \\n        def fn(x): \\n            \"\"\"Return node counts in denary trie.\"\"\"\\n            ans, diff = 0, 1\\n            while x <= n: \\n                ans += min(n - x + 1, diff)\\n                x *= 10 \\n                diff *= 10 \\n            return ans \\n        \\n        x = 1\\n        while k > 1: \\n            cnt = fn(x)\\n            if k > cnt: k -= cnt; x += 1\\n            else: k -= 1; x *= 10 \\n        return x\\n```",
        "level": "hard",
        "type": [
            "variable value error",
            "colon missing",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution:\n    def findKthNumber(self, n: int, k: int) -> int\n        \n        def fn(x): \n            \"Return node counts in denary trie.\n            ans, diff = 0, 1\n            while x <= n: \n                ans += min(n - x + 1, diff)\n                x *= 10 \n                diff *= 10 \n            return ans \n        \n        x = 0\n        while k > 1: \n            cnt = fn(x)\n            if k > cnt: k -= cnt; x += 1\n            else: k -= 1; x *= 10 \n        return x\n"
    },
    {
        "slug": "valid-permutations-for-di-sequence",
        "description": "You are given a string s of length n where s[i] is either:\n\n'D' means decreasing, or\n'I' means increasing.\n\nA permutation perm of n + 1 integers of all the integers in the range [0, n] is called a valid permutation if for all valid i:\n\nIf s[i] == 'D', then perm[i] > perm[i + 1], and\nIf s[i] == 'I', then perm[i] < perm[i + 1].\n\nReturn the number of valid permutations perm. Since the answer may be large, return it modulo 109 + 7.",
        "examples": [
            "Input: s = \"DID\"\nOutput: 5\nExplanation: The 5 valid permutations of (0, 1, 2, 3) are:\n(1, 0, 3, 2)\n(2, 0, 3, 1)\n(2, 1, 3, 0)\n(3, 0, 2, 1)\n(3, 1, 2, 0)",
            "Input: s = \"D\"\nOutput: 1"
        ],
        "constraints": "n == s.length\n1 <= n <= 200\ns[i] is either 'I' or 'D'.",
        "oracle_code": "class Solution:\n    def numPermsDISequence(self, s: str) -> int:\n        mem=defaultdict(int)\n        def dfs(i,val=0):\n            if i==len(s):\n                return 1\n            if (i,val) in mem:\n                return mem[i,val]\n            p=0\n            if s[i]==\"D\":\n                for ind in range(0,val+1):\n                    p+=dfs(i+1,ind)%(10**9+7)\n            else:\n                for ind in range(val+1,i+2):\n                    p+=dfs(i+1,ind)%(10**9+7)\n            mem[i,val]=p\n            return p\n        return dfs(0)",
        "content": "To add a new character to a sequence we only have to consider the last element-\\n\\nLets say currently DID sequence is 1032- this can form\\n\\nDIDI - in cases where we end with 3,4\\nDIDD - in cases where we end with 0,1,2\\n\\nSo just use the last element value to create a new sequence.\\n\\n```\\nclass Solution:\\n    def numPermsDISequence(self, s: str) -> int:\\n        mem=defaultdict(int)\\n        def dfs(i,val=0):\\n            if i==len(s):\\n                return 1\\n            if (i,val) in mem:\\n                return mem[i,val]\\n            p=0\\n            if s[i]==\"D\":\\n                for ind in range(0,val+1):\\n                    p+=dfs(i+1,ind)%(10**9+7)\\n            else:\\n                for ind in range(val+1,i+2):\\n                    p+=dfs(i+1,ind)%(10**9+7)\\n            mem[i,val]=p\\n            return p\\n        return dfs(0)\\n ```\\n\\t\\t\\t\\t",
        "level": "hard",
        "type": [
            "colon missing",
            "unclosed string",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n    def numPermsDISequence(self, s: str) -> int:\n        mem=defaultdict(int)\n        def dfs(i,val=0):\n            if i=len(s): \n                return 1\n            if (i,val) in mem\n                return mem[i,val]\n            p=0\n            if s[i]==\"D:\n                for ind in range(0,val+1):\n                    p+=dfs(i+1,ind)%(10**9+7)\n            else:\n                if ind in range(val+1,i+2):\n                    p+=dfs(i+1,ind)%(10**9+7)\n            mem[i,val]=p\n            return p\n        return dfs(0)\n"
    },
    {
        "slug": "string-compression-ii",
        "description": "Run-length encoding is a string compression method that works by\u00a0replacing consecutive identical characters (repeated 2 or more times) with the concatenation of the character and the number marking the count of the characters (length of the run). For example, to compress the string\u00a0\"aabccc\"\u00a0we replace \"aa\"\u00a0by\u00a0\"a2\"\u00a0and replace \"ccc\"\u00a0by\u00a0\"c3\". Thus the compressed string becomes \"a2bc3\".\nNotice that in this problem, we are not adding\u00a0'1'\u00a0after single characters.\nGiven a\u00a0string s\u00a0and an integer k. You need to delete at most\u00a0k characters from\u00a0s\u00a0such that the run-length encoded version of s\u00a0has minimum length.\nFind the minimum length of the run-length encoded\u00a0version of s after deleting at most k characters.",
        "examples": [
            "Input: s = \"aaabcccd\", k = 2\nOutput: 4\nExplanation: Compressing s without deleting anything will give us \"a3bc3d\" of length 6. Deleting any of the characters 'a' or 'c' would at most decrease the length of the compressed string to 5, for instance delete 2 'a' then we will have s = \"abcccd\" which compressed is abc3d. Therefore, the optimal way is to delete 'b' and 'd', then the compressed version of s will be \"a3c3\" of length 4.",
            "Input: s = \"aabbaa\", k = 2\nOutput: 2\nExplanation: If we delete both 'b' characters, the resulting compressed string would be \"a4\" of length 2.",
            "Input: s = \"aaaaaaaaaaa\", k = 0\nOutput: 3\nExplanation: Since k is zero, we cannot delete anything. The compressed string is \"a11\" of length 3."
        ],
        "constraints": "1 <= s.length <= 100\n0 <= k <= s.length\ns contains only lowercase English letters.",
        "oracle_code": "class Solution:\n    def dp(self,i,s,prev,k,ct,n,dct):\n        if k<0:\n            return float(\"infinity\")\n        if i>=n:\n            x=0\n            if ct>1:\n                x=len(str(ct))+1\n            elif ct==1:\n                x=1\n            return x\n        if (i,prev,ct,k) in dct:\n            return dct[(i,prev,ct,k)]\n        if s[i]==prev:\n            inc=self.dp(i+1,s,prev,k,ct+1,n,dct)\n        else:\n            x=0\n            if ct>1:\n                x=len(str(ct))+1\n            elif ct==1:\n                x=1\n            inc=x+self.dp(i+1,s,s[i],k,1,n,dct)\n        exc=self.dp(i+1,s,prev,k-1,ct,n,dct)\n        dct[(i,prev,ct,k)]=min(inc,exc)\n        return min(inc,exc)\n\n\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n        n=len(s)\n        return self.dp(0,s,\"\",k,0,n,{})",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def dp(self,i,s,prev,k,ct,n,dct):\\n        if k<0:\\n            return float(\"infinity\")\\n        if i>=n:\\n            x=0\\n            if ct>1:\\n                x=len(str(ct))+1\\n            elif ct==1:\\n                x=1\\n            return x\\n        if (i,prev,ct,k) in dct:\\n            return dct[(i,prev,ct,k)]\\n        if s[i]==prev:\\n            inc=self.dp(i+1,s,prev,k,ct+1,n,dct)\\n        else:\\n            x=0\\n            if ct>1:\\n                x=len(str(ct))+1\\n            elif ct==1:\\n                x=1\\n            inc=x+self.dp(i+1,s,s[i],k,1,n,dct)\\n        exc=self.dp(i+1,s,prev,k-1,ct,n,dct)\\n        dct[(i,prev,ct,k)]=min(inc,exc)\\n        return min(inc,exc)\\n\\n\\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\\n        n=len(s)\\n        return self.dp(0,s,\"\",k,0,n,{})\\n\\n        \\n```",
        "level": "hard",
        "type": [
            "operation error",
            "parentheses mismatch",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def dp(self,i,s,prev,k,ct,n,dct:\n        if k<0:\n            return float(\"infinity\")\n        if i>=n+1:\n            x=0\n            if ct>1:\n                x=len(str(ct))+1\n            elif ct==1:\n                x=1\n            return x\n        if (i,prev,ct,k) in dct:\n            return dct[(i,prev,ct,k)]\n        if s[i]==prev:\n            inc=self.dp(i+1,s,prev,k,ct+1,n,dct)\n        else:\n            x=0\n            if ct>1:\n                x=len(str(ct))+1\n            elif ct==1:\n                x=1\n            inc=x+self.dp(i+1,s,s[i],k,1,n,dct)\n        exc=self.dp(i+1,s,prev,k-1,ct,n,dct)\n        dct[(i,prev,ct,k)]=max(inc,exc)\n        return min(inc,exc)\n\n\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n        n=len(s)\n        return self.dp(0,s,\"\",k,0,n,{})\n"
    },
    {
        "slug": "rearrange-words-in-a-sentence",
        "description": "Given a sentence\u00a0text (A\u00a0sentence\u00a0is a string of space-separated words) in the following format:\n\nFirst letter is in upper case.\nEach word in text are separated by a single space.\n\nYour task is to rearrange the words in text such that\u00a0all words are rearranged in an increasing order of their lengths. If two words have the same length, arrange them in their original order.\nReturn the new text\u00a0following the format shown above.",
        "examples": [
            "Input: text = \"Leetcode is cool\"\nOutput: \"Is cool leetcode\"\nExplanation: There are 3 words, \"Leetcode\" of length 8, \"is\" of length 2 and \"cool\" of length 4.\nOutput is ordered by length and the new first word starts with capital letter.",
            "Input: text = \"Keep calm and code on\"\nOutput: \"On and keep calm code\"\nExplanation: Output is ordered as follows:\n\"On\" 2 letters.\n\"and\" 3 letters.\n\"keep\" 4 letters in case of tie order by position in original text.\n\"calm\" 4 letters.\n\"code\" 4 letters.",
            "Input: text = \"To be or not to be\"\nOutput: \"To be or to be not\""
        ],
        "constraints": "text begins with a capital letter and then contains lowercase letters and single space between words.\n1 <= text.length <= 10^5",
        "oracle_code": "class Solution:\n    def arrangeWords(self, text: str) -> str:\n        return \" \".join(sorted(text.split(), key=len)).capitalize()",
        "content": "A few string operations chained together to get the job done. \\n\\n```\\nclass Solution:\\n    def arrangeWords(self, text: str) -> str:\\n        return \" \".join(sorted(text.split(), key=len)).capitalize()\\n```",
        "level": "medium",
        "type": [
            "colon missing",
            "undefined objects",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution:\n    def arrangeWords(self, text: undefined_str) -> str\n        return \" \".join(sorted(text.split(), key=len.capitalize()\n"
    },
    {
        "slug": "minimum-number-of-steps-to-make-two-strings-anagram-ii",
        "description": "You are given two strings s and t. In one step, you can append any character to either s or t.\nReturn the minimum number of steps to make s and t anagrams of each other.\nAn anagram of a string is a string that contains the same characters with a different (or the same) ordering.",
        "examples": [
            "Input: s = \"leetcode\", t = \"coats\"\nOutput: 7\nExplanation: \n- In 2 steps, we can append the letters in \"as\" onto s = \"leetcode\", forming s = \"leetcodeas\".\n- In 5 steps, we can append the letters in \"leede\" onto t = \"coats\", forming t = \"coatsleede\".\n\"leetcodeas\" and \"coatsleede\" are now anagrams of each other.\nWe used a total of 2 + 5 = 7 steps.\nIt can be shown that there is no way to make them anagrams of each other with less than 7 steps.",
            "Input: s = \"night\", t = \"thing\"\nOutput: 0\nExplanation: The given strings are already anagrams of each other. Thus, we do not need any further steps."
        ],
        "constraints": "1 <= s.length, t.length <= 2 * 105\ns and t consist of lowercase English letters.",
        "oracle_code": "class Solution:\n    def minSteps(self, s: str, t: str) -> int:\n        cnt1=Counter(s)\n        cnt2=Counter(t)\n        sm=0\n        cnt=cnt1-cnt2+(cnt2-cnt1)\n        for i in cnt.values():\n            sm+=i\n        return sm",
        "content": "\\n# Code\\n```\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        cnt1=Counter(s)\\n        cnt2=Counter(t)\\n        sm=0\\n        cnt=cnt1-cnt2+(cnt2-cnt1)\\n        for i in cnt.values():\\n            sm+=i\\n        return sm\\n```",
        "level": "medium",
        "type": [
            "operation error",
            "undefined objects",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution:\n    def minSteps(self, s: str, t: str) -> int:\n        cnt1=Counter(s)\n        cnt2=Counter(t)\n        sm=0\n        cnt=cnt1+cnt2   \n        for i in undf_obj.values():\n            sm+=i\n        return sm\n"
    },
    {
        "slug": "lexicographically-smallest-string-after-substring-operation",
        "description": "You are given a string s consisting of only lowercase English letters. In one operation, you can do the following:\n\nSelect any non-empty substring of s, possibly the entire string, then replace each one of its characters with the previous character of the English alphabet. For example, 'b' is converted to 'a', and 'a' is converted to 'z'.\n\nReturn the lexicographically smallest string you can obtain after performing the above operation exactly once.\nA substring is a contiguous sequence of characters in a string.\nA string x is lexicographically smaller than a string y of the same length if x[i] comes before y[i] in alphabetic order for the first position i such that x[i] != y[i].",
        "examples": [
            "Input: s = \"cbabc\"\nOutput: \"baabc\"\nExplanation: We apply the operation on the substring starting at index 0, and ending at index 1 inclusive. \nIt can be proven that the resulting string is the lexicographically smallest.",
            "Input: s = \"acbbc\"\nOutput: \"abaab\"\nExplanation: We apply the operation on the substring starting at index 1, and ending at index 4 inclusive. \nIt can be proven that the resulting string is the lexicographically smallest.",
            "Input: s = \"leetcode\"\nOutput: \"kddsbncd\"\nExplanation: We apply the operation on the entire string. \nIt can be proven that the resulting string is the lexicographically smallest."
        ],
        "constraints": "1 <= s.length <= 3 * 105\ns consists of lowercase English letters",
        "oracle_code": "class Solution:\n    def smallestString(self, s: str) -> str:\n        \n        if len(check:=set(s))==1 and check != {'a'}: \n            return chr(ord(s[0])-1)*(len(s))              # zzzz > yyyy , aaaa -X-> zzzz\n        contiguous,change,ct1,ct2 = True,False,0,0\n\n        for i in s:                                       # deal with begin string = 'aaaa....', speed up the traversal speed.\n            if i == 'a':ct1+=1                                                  \n            else:break\n        ans='' + 'a' * ct1\n        s = s[ct1:]\n     \n        for cha in s:\n            ct2+=1\n            if cha != 'a':\n                ans+=chr(ord(cha)-1)\n                change=True                               # record operation at least once.\n                continue\n            else:\n                ans+=cha                                  # because 'a' can't converted to 'z'\n                if change:                                # once the change has been made, you can stop when you encounter 'a'\n                    contiguous = False\n            if not contiguous:                            # then break , add the remaining string to the end of the ans.\n                break\n        return ans+s[ct2:] if change else ans[:-1]+'z'    # check if it consists entirely of the letter \"a.\"  'aaaa' > 'aaaz'",
        "content": "![image.png](https://assets.leetcode.com/users/images/87e1aa4c-6441-4d67-b2fb-846fc3897b29_1687376176.900977.png)\\n\\n\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def smallestString(self, s: str) -> str:\\n        \\n        if len(check:=set(s))==1 and check != {\\'a\\'}: \\n            return chr(ord(s[0])-1)*(len(s))              # zzzz > yyyy , aaaa -X-> zzzz\\n        contiguous,change,ct1,ct2 = True,False,0,0\\n\\n        for i in s:                                       # deal with begin string = \\'aaaa....\\', speed up the traversal speed.\\n            if i == \\'a\\':ct1+=1                                                  \\n            else:break\\n        ans=\\'\\' + \\'a\\' * ct1\\n        s = s[ct1:]\\n     \\n        for cha in s:\\n            ct2+=1\\n            if cha != \\'a\\':\\n                ans+=chr(ord(cha)-1)\\n                change=True                               # record operation at least once.\\n                continue\\n            else:\\n                ans+=cha                                  # because \\'a\\' can\\'t converted to \\'z\\'\\n                if change:                                # once the change has been made, you can stop when you encounter \\'a\\'\\n                    contiguous = False\\n            if not contiguous:                            # then break , add the remaining string to the end of the ans.\\n                break\\n        return ans+s[ct2:] if change else ans[:-1]+\\'z\\'    # check if it consists entirely of the letter \"a.\"  \\'aaaa\\' > \\'aaaz\\'\\n```\\n\\nMy English may not be very good, but I hope I can still assist you. :>\\n\\n\\n\\n\\n",
        "level": "medium",
        "type": [
            "operation error",
            "unclosed string",
            "wrong comment mark"
        ],
        "buggy_code": "\nclass Solution:\n    def smallestString(self, s: str) -> str:\n        \n        if len(check:=set(s))==1 and check != \"{'a'}\": \n        \n        contiguous,change,ct1,ct2 = True,False,0,0\n\n        for i in s:                                       \n            if i == 'a':ct1+=1                                                  \n            else:break\n        ans='' + 'a' * ct1\n        s = s[ct1:]\n     \n        for cha in s:\n            ct2+=1\n            if cha != 'a':\n                ans+=chr(ord(cha)-1)\n                change=True                               \n                continue\n            else:\n                ans+=cha                                  \n                if change:                                \n                    contiguous = False\n            if nocontio2u:                            \n                 otis=Flseifnot\n                break\n        return ans+s[ct2:] if change else ans[:-1]+'z'    \n\n"
    },
    {
        "slug": "largest-positive-integer-that-exists-with-its-negative",
        "description": "Given an integer array nums that does not contain any zeros, find the largest positive integer k such that -k also exists in the array.\nReturn the positive integer k. If there is no such integer, return -1.",
        "examples": [
            "Input: nums = [-1,2,-3,3]\nOutput: 3\nExplanation: 3 is the only valid k we can find in the array.",
            "Input: nums = [-1,10,6,7,-7,1]\nOutput: 7\nExplanation: Both 1 and 7 have their corresponding negative values in the array. 7 has a larger value.",
            "Input: nums = [-10,8,6,7,-2,-3]\nOutput: -1\nExplanation: There is no a single valid k, we return -1."
        ],
        "constraints": "1 <= nums.length <= 1000\n-1000 <= nums[i] <= 1000\nnums[i] != 0",
        "oracle_code": "class Solution:\n    def findMaxK(self, nums: List[int]) -> int:\n        nums=sorted(nums,reverse=True)\n        s=set(nums)\n        for i in range(len(nums)):\n            if 0-nums[i] in s:\n                return nums[i]\n        return -1",
        "content": "\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def findMaxK(self, nums: List[int]) -> int:\\n        nums=sorted(nums,reverse=True)\\n        s=set(nums)\\n        for i in range(len(nums)):\\n            if 0-nums[i] in s:\\n                return nums[i]\\n        return -1\\n\\n```",
        "level": "easy",
        "type": [
            "operation error",
            "undefined keywords from other languages",
            "wrong comment mark"
        ],
        "buggy_code": "\nclass Solution:\n    def findMaxK(self, nums: List[int]) -> int:\n        \n        s=set(nums)\n        for i in range(len(nums)):\n            if thisnums[i] in s:\n                return nums[i]\n        return -1\n"
    },
    {
        "slug": "minimize-the-total-price-of-the-trips",
        "description": "There exists an undirected and unrooted tree with n nodes indexed from 0 to n - 1. You are given the integer n and a 2D integer array edges of length n - 1, where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree.\nEach node has an associated price. You are given an integer array price, where price[i] is the price of the ith node.\nThe price sum of a given path is the sum of the prices of all nodes lying on that path.\nAdditionally, you are given a 2D integer array trips, where trips[i] = [starti, endi] indicates that you start the ith trip from the node starti and travel to the node endi by any path you like.\nBefore performing your first trip, you can choose some non-adjacent nodes and halve the prices.\nReturn the minimum total price sum to perform all the given trips.",
        "examples": [
            "Input: n = 4, edges = [[0,1],[1,2],[1,3]], price = [2,2,10,6], trips = [[0,3],[2,1],[2,3]]\nOutput: 23\nExplanation: The diagram above denotes the tree after rooting it at node 2. The first part shows the initial tree and the second part shows the tree after choosing nodes 0, 2, and 3, and making their price half.\nFor the 1st trip, we choose path [0,1,3]. The price sum of that path is 1 + 2 + 3 = 6.\nFor the 2nd trip, we choose path [2,1]. The price sum of that path is 2 + 5 = 7.\nFor the 3rd trip, we choose path [2,1,3]. The price sum of that path is 5 + 2 + 3 = 10.\nThe total price sum of all trips is 6 + 7 + 10 = 23.\nIt can be proven, that 23 is the minimum answer that we can achieve.",
            "Input: n = 2, edges = [[0,1]], price = [2,2], trips = [[0,0]]\nOutput: 1\nExplanation: The diagram above denotes the tree after rooting it at node 0. The first part shows the initial tree and the second part shows the tree after choosing node 0, and making its price half.\nFor the 1st trip, we choose path [0]. The price sum of that path is 1.\nThe total price sum of all trips is 1. It can be proven, that 1 is the minimum answer that we can achieve."
        ],
        "constraints": "1 <= n <= 50\nedges.length == n - 1\n0 <= ai, bi <= n - 1\nedges represents a valid tree.\nprice.length == n\nprice[i] is an even integer.\n1 <= price[i] <= 1000\n1 <= trips.length <= 100\n0 <= starti, endi\u00a0<= n - 1",
        "oracle_code": "class Solution:\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\n        g = [[] for _ in range(n)]\n        for i, j in edges:\n            g[i].append(j)\n            g[j].append(i)\n            \n        freq = [0] * n\n        level = [0] * n\n        parent = [0] * n\n        \n        def dfs(i, l, p):\n            level[i] = l\n            parent[i] = p\n            for j in g[i]:\n                if j != p:\n                    dfs(j, l + 1, i)\n        \n        def LCA(a, b):\n            if level[a] > level[b]:\n                a, b = b, a\n            d = level[b] - level[a]\n            while d:\n                b = parent[b]\n                d -= 1\n            if a == b:\n                return a\n            while a != b:\n                a = parent[a]\n                b = parent[b]\n            return a\n        \n        dfs(0, 0, -1)\n        for i, j in trips:\n            lca = LCA(i, j)\n            path = []\n            while i != lca:\n                freq[i] += 1\n                i = parent[i]\n            freq[i] += 1\n            while j != lca:\n                freq[j] += 1\n                j = parent[j]\n        \n        def dp(i, p):\n            res0 = 0\n            res1 = price[i] // 2 * freq[i]\n            for j in g[i]:\n                if j != p:\n                    curr = dp(j, i)\n                    res0 += max(curr)\n                    res1 += curr[0]\n            return [res0, res1]\n        ans = 0\n        for i in range(n):\n            ans += freq[i] * price[i]\n        return ans - max(dp(0, -1))",
        "content": "We use lowest common ancestor to find path for each trip. Let `freq` be the frequencies for each node. `dp(i, p)` returns the maximum price we can save without or with choosing node `i`.\\n```\\nclass Solution:\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        g = [[] for _ in range(n)]\\n        for i, j in edges:\\n            g[i].append(j)\\n            g[j].append(i)\\n            \\n        freq = [0] * n\\n        level = [0] * n\\n        parent = [0] * n\\n        \\n        def dfs(i, l, p):\\n            level[i] = l\\n            parent[i] = p\\n            for j in g[i]:\\n                if j != p:\\n                    dfs(j, l + 1, i)\\n        \\n        def LCA(a, b):\\n            if level[a] > level[b]:\\n                a, b = b, a\\n            d = level[b] - level[a]\\n            while d:\\n                b = parent[b]\\n                d -= 1\\n            if a == b:\\n                return a\\n            while a != b:\\n                a = parent[a]\\n                b = parent[b]\\n            return a\\n        \\n        dfs(0, 0, -1)\\n        for i, j in trips:\\n            lca = LCA(i, j)\\n            path = []\\n            while i != lca:\\n                freq[i] += 1\\n                i = parent[i]\\n            freq[i] += 1\\n            while j != lca:\\n                freq[j] += 1\\n                j = parent[j]\\n        \\n        def dp(i, p):\\n            res0 = 0\\n            res1 = price[i] // 2 * freq[i]\\n            for j in g[i]:\\n                if j != p:\\n                    curr = dp(j, i)\\n                    res0 += max(curr)\\n                    res1 += curr[0]\\n            return [res0, res1]\\n        ans = 0\\n        for i in range(n):\\n            ans += freq[i] * price[i]\\n        return ans - max(dp(0, -1))\\n```",
        "level": "hard",
        "type": [
            "colon missing",
            "undefined objects",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution:\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\n        g = [[] for _ in range(n)]\n        for i, j in edges:\n            g[i].append(j)\n            g[j].append(i)\n            \n        freq = [0] * n\n        level = [0] * n\n        parent = [0] * n\n        \n        def dfs(i, l, p\n            level[i] = l\n            parent[i] = p\n            for j in g[i]:\n                if j != p:\n                    dfs(j, l + 1, i)\n        \n        undefinedLCA(a, b):\n            if level[a] > level[b]:\n                a, b = b, a\n            d = level[b] - level[a]\n            while d:\n                b = parent[b]\n                d -= 1\n            if a == b:\n                return a\n            while a != b:\n                a = parent[a]\n                b = parent[b]\n            return a\n        \n        dfs(0, 0, -1)\n        for i, j in trips:\n            lca = LCA(i, j)\n            path = []\n            while i != lca:\n                freq[i] += 1\n                i = parent[i]\n            freq[i] += 1\n            while j != lca:\n                freq[j] += 1\n                j = parent[j]\n        \n        def dp(i, p)\n            res0 = 0\n            res1 = price[i] // 2 * freq[i]\n            for j in g[i]:\n                if j != p:\n                    curr = dp(j, i)\n                    res0 += max(curr)\n                    res1 += curr[0]\n            return [res0, res1]\n        ans = 0\n        for i in range(n):\n            ans += freq[i] * price[i]\n        return ans - max(dp(0, -1))\n"
    },
    {
        "slug": "lexicographically-smallest-palindrome",
        "description": "You are given a string s consisting of lowercase English letters, and you are allowed to perform operations on it. In one operation, you can replace a character in s with another lowercase English letter.\nYour task is to make s a palindrome with the minimum number of operations possible. If there are multiple palindromes that can be made using the minimum number of operations, make the lexicographically smallest one.\nA string a is lexicographically smaller than a string b (of the same length) if in the first position where a and b differ, string a has a letter that appears earlier in the alphabet than the corresponding letter in b.\nReturn the resulting palindrome string.",
        "examples": [
            "Input: s = \"egcfe\"\nOutput: \"efcfe\"\nExplanation: The minimum number of operations to make \"egcfe\" a palindrome is 1, and the lexicographically smallest palindrome string we can get by modifying one character is \"efcfe\", by changing 'g'.",
            "Input: s = \"abcd\"\nOutput: \"abba\"\nExplanation: The minimum number of operations to make \"abcd\" a palindrome is 2, and the lexicographically smallest palindrome string we can get by modifying two characters is \"abba\".",
            "Input: s = \"seven\"\nOutput: \"neven\"\nExplanation: The minimum number of operations to make \"seven\" a palindrome is 1, and the lexicographically smallest palindrome string we can get by modifying one character is \"neven\"."
        ],
        "constraints": "1 <= s.length <= 1000\ns\u00a0consists of only lowercase English letters.",
        "oracle_code": "class Solution:\n    def makeSmallestPalindrome(self, s: str) -> str:\n        before = 0\n        after = len(s)-1\n        l = [i for i in s]\n        while before <= len(s)/2:\n            l[before] = min(l[before], l[after])\n            l[after] = l[before]\n            before+=1\n            after-=1\n        return \"\".join(l)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: 214 ms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 16.5 MB\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def makeSmallestPalindrome(self, s: str) -> str:\\n        before = 0\\n        after = len(s)-1\\n        l = [i for i in s]\\n        while before <= len(s)/2:\\n            l[before] = min(l[before], l[after])\\n            l[after] = l[before]\\n            before+=1\\n            after-=1\\n        return \"\".join(l)\\n```",
        "level": "easy",
        "type": [
            "colon missing",
            "unclosed string",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def makeSmallestPalindrome(self, s: str) -> str\n        before = 0\n        after = len(s)-1\n        l = [i for i in s]\n        while before <= len(s)/2\n            l[before] = min(l[before], l[after])\n            l[after] = l[before]\n            before+=1\n            after+=1\n        return \"\".join(l)\n"
    },
    {
        "slug": "check-if-string-is-transformable-with-substring-sort-operations",
        "description": "Given two strings s and t, transform string s into string t using the following operation any number of times:\n\nChoose a non-empty substring in s and sort it in place so the characters are in ascending order.\n\n\t\nFor example, applying the operation on the underlined substring in \"14234\" results in \"12344\".\n\n\n\nReturn true if it is possible to transform s into t. Otherwise, return false.\nA substring is a contiguous sequence of characters within a string.",
        "examples": [
            "Input: s = \"84532\", t = \"34852\"\nOutput: true\nExplanation: You can transform s into t using the following sort operations:\n\"84532\" (from index 2 to 3) -> \"84352\"\n\"84352\" (from index 0 to 2) -> \"34852\"",
            "Input: s = \"34521\", t = \"23415\"\nOutput: true\nExplanation: You can transform s into t using the following sort operations:\n\"34521\" -> \"23451\"\n\"23451\" -> \"23415\"",
            "Input: s = \"12345\", t = \"12435\"\nOutput: false"
        ],
        "constraints": "s.length == t.length\n1 <= s.length <= 105\ns and t consist of only digits.",
        "oracle_code": "class BIT():\n    def __init__(self, n):\n        self.n = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        ans = 0\n        i += 1\n        while i > 0:\n            ans += self.tree[i]\n            i -= (i & (-i))\n        return ans\n\n    def update(self, i, value):\n        i += 1\n        while i <= self.n:\n            self.tree[i] += value\n            i += (i & (-i))\n\n\nclass Solution:\n    def isTransformable(self, s: str, t: str) -> bool:\n        if Counter(s)!=Counter(t):\n            return False\n        ind = defaultdict(deque)\n        for id, i in enumerate(t):\n            ind[i].append(id)\n        a = []\n        for i in s:\n            a.append(ind[i].popleft())\n        n=len(a)\n        bt=BIT(n+1)\n        ind=defaultdict(lambda :-1)\n        for i in range(n):\n            inv=bt.sum(n)-bt.sum(a[i])\n            bt.update(a[i],1)\n            for dig in range(int(s[i])-1,-1,-1):\n                if ind[dig]>=i-inv:\n                    return False\n            ind[int(s[i])]=i-inv\n        return True",
        "content": "\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass BIT():\\n    def __init__(self, n):\\n        self.n = n\\n        self.tree = [0] * (n + 1)\\n\\n    def sum(self, i):\\n        ans = 0\\n        i += 1\\n        while i > 0:\\n            ans += self.tree[i]\\n            i -= (i & (-i))\\n        return ans\\n\\n    def update(self, i, value):\\n        i += 1\\n        while i <= self.n:\\n            self.tree[i] += value\\n            i += (i & (-i))\\n\\n\\nclass Solution:\\n    def isTransformable(self, s: str, t: str) -> bool:\\n        if Counter(s)!=Counter(t):\\n            return False\\n        ind = defaultdict(deque)\\n        for id, i in enumerate(t):\\n            ind[i].append(id)\\n        a = []\\n        for i in s:\\n            a.append(ind[i].popleft())\\n        n=len(a)\\n        bt=BIT(n+1)\\n        ind=defaultdict(lambda :-1)\\n        for i in range(n):\\n            inv=bt.sum(n)-bt.sum(a[i])\\n            bt.update(a[i],1)\\n            for dig in range(int(s[i])-1,-1,-1):\\n                if ind[dig]>=i-inv:\\n                    return False\\n            ind[int(s[i])]=i-inv\\n        return True\\n\\n\\n```",
        "level": "hard",
        "type": [
            "indentation error",
            "colon missing",
            "undefined objects"
        ],
        "buggy_code": "\nclass BIT():\n    def __init__(self, n):\n        self.n = n\n    self.tree = [0] * (n + 1)\n\n    def sum(self, i)\n        ans = 0\n        i += 1\n        while i > 0:\n            ans += self.tree[i]\n            i -= (i & (-i))\n        return ans\n\n    def update(self, i, value):\n        i += 1\n        while i <= self.n:\n            self.tree[i] += value\n            i += (i & (-i))\n\n\nclass Solution:\n    def isTransformable(self, s: str, t: str) -> bool:\n        if Counter(s)!=Counter(t):\n            return False\n        ind = defaultdict(deque)\n        for id, i in enumerate(t):\n            ind[i].append(id)\n        a = []\n        for i in s:\n            a.append(ind[x].popleft())\n        n=len(a)\n        bt=BIT(n+1)\n        ind=defaultdict(lambda :-1)\n        for i in range(n):\n            inv=bt.sum(n)-bt.sum(a[i])\n            bt.update(a[i],1)\n            for dig in range(int(s[i])-1,-1,-1):\n                if ind[dig]>=i-inv:\n                    return False\n            ind[int(s[i])]=i-inv\n        return True\n"
    },
    {
        "slug": "string-compression-ii",
        "description": "Run-length encoding is a string compression method that works by\u00a0replacing consecutive identical characters (repeated 2 or more times) with the concatenation of the character and the number marking the count of the characters (length of the run). For example, to compress the string\u00a0\"aabccc\"\u00a0we replace \"aa\"\u00a0by\u00a0\"a2\"\u00a0and replace \"ccc\"\u00a0by\u00a0\"c3\". Thus the compressed string becomes \"a2bc3\".\nNotice that in this problem, we are not adding\u00a0'1'\u00a0after single characters.\nGiven a\u00a0string s\u00a0and an integer k. You need to delete at most\u00a0k characters from\u00a0s\u00a0such that the run-length encoded version of s\u00a0has minimum length.\nFind the minimum length of the run-length encoded\u00a0version of s after deleting at most k characters.",
        "examples": [
            "Input: s = \"aaabcccd\", k = 2\nOutput: 4\nExplanation: Compressing s without deleting anything will give us \"a3bc3d\" of length 6. Deleting any of the characters 'a' or 'c' would at most decrease the length of the compressed string to 5, for instance delete 2 'a' then we will have s = \"abcccd\" which compressed is abc3d. Therefore, the optimal way is to delete 'b' and 'd', then the compressed version of s will be \"a3c3\" of length 4.",
            "Input: s = \"aabbaa\", k = 2\nOutput: 2\nExplanation: If we delete both 'b' characters, the resulting compressed string would be \"a4\" of length 2.",
            "Input: s = \"aaaaaaaaaaa\", k = 0\nOutput: 3\nExplanation: Since k is zero, we cannot delete anything. The compressed string is \"a11\" of length 3."
        ],
        "constraints": "1 <= s.length <= 100\n0 <= k <= s.length\ns contains only lowercase English letters.",
        "oracle_code": "class Solution:\n    def dp(self,i,s,prev,k,ct,n,dct):\n        if k<0:\n            return float(\"infinity\")\n        if i>=n:\n            x=0\n            if ct>1:\n                x=len(str(ct))+1\n            elif ct==1:\n                x=1\n            return x\n        if (i,prev,ct,k) in dct:\n            return dct[(i,prev,ct,k)]\n        if s[i]==prev:\n            inc=self.dp(i+1,s,prev,k,ct+1,n,dct)\n        else:\n            x=0\n            if ct>1:\n                x=len(str(ct))+1\n            elif ct==1:\n                x=1\n            inc=x+self.dp(i+1,s,s[i],k,1,n,dct)\n        exc=self.dp(i+1,s,prev,k-1,ct,n,dct)\n        dct[(i,prev,ct,k)]=min(inc,exc)\n        return min(inc,exc)\n\n\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n        n=len(s)\n        return self.dp(0,s,\"\",k,0,n,{})",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def dp(self,i,s,prev,k,ct,n,dct):\\n        if k<0:\\n            return float(\"infinity\")\\n        if i>=n:\\n            x=0\\n            if ct>1:\\n                x=len(str(ct))+1\\n            elif ct==1:\\n                x=1\\n            return x\\n        if (i,prev,ct,k) in dct:\\n            return dct[(i,prev,ct,k)]\\n        if s[i]==prev:\\n            inc=self.dp(i+1,s,prev,k,ct+1,n,dct)\\n        else:\\n            x=0\\n            if ct>1:\\n                x=len(str(ct))+1\\n            elif ct==1:\\n                x=1\\n            inc=x+self.dp(i+1,s,s[i],k,1,n,dct)\\n        exc=self.dp(i+1,s,prev,k-1,ct,n,dct)\\n        dct[(i,prev,ct,k)]=min(inc,exc)\\n        return min(inc,exc)\\n\\n\\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\\n        n=len(s)\\n        return self.dp(0,s,\"\",k,0,n,{})\\n\\n        \\n```",
        "level": "hard",
        "type": [
            "parentheses mismatch",
            "unclosed string",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def dp(self,i,s,prev,k,ct,n,dct:\n        if k<0:\n            return float(\"infinity\")\n        if i>=n+1:\n            x=0\n            if ct>1:\n                x=len(str(ct))+1\n            elif ct==1:\n                x=1\n            return x\n        if (i,prev,ct,k) in dct:\n            return dct[(i,prev,ct,k)]\n        if s[i]==prev:\n            inc=self.dp(i+1,s,prev,k,ct+1,n,dct)\n        else:\n            x=0\n            if ct>1:\n                x=len(str(ct))+1\n            elif ct==1:\n                x=1\n            inc=x+self.dp(i+1,s,s[i],k,1,n,dct)\n        exc=self.dp(i+1,s,prev,k-1,ct,n,dct)\n        dct[(i,prev,ct,k)]='min(inc,exc)\n        return min(inc,exc)\n\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n        n=len(s)\n        return self.dp(0,s,\"\",k,0,n,{})\n"
    },
    {
        "slug": "find-players-with-zero-or-one-losses",
        "description": "You are given an integer array matches where matches[i] = [winneri, loseri] indicates that the player winneri defeated player loseri in a match.\nReturn a list answer of size 2 where:\n\nanswer[0] is a list of all players that have not lost any matches.\nanswer[1] is a list of all players that have lost exactly one match.\n\nThe values in the two lists should be returned in increasing order.\nNote:\n\nYou should only consider the players that have played at least one match.\nThe testcases will be generated such that no two matches will have the same outcome.",
        "examples": [
            "Input: matches = [[1,3],[2,3],[3,6],[5,6],[5,7],[4,5],[4,8],[4,9],[10,4],[10,9]]\nOutput: [[1,2,10],[4,5,7,8]]\nExplanation:\nPlayers 1, 2, and 10 have not lost any matches.\nPlayers 4, 5, 7, and 8 each have lost one match.\nPlayers 3, 6, and 9 each have lost two matches.\nThus, answer[0] = [1,2,10] and answer[1] = [4,5,7,8].",
            "Input: matches = [[2,3],[1,3],[5,4],[6,4]]\nOutput: [[1,2,5,6],[]]\nExplanation:\nPlayers 1, 2, 5, and 6 have not lost any matches.\nPlayers 3 and 4 each have lost two matches.\nThus, answer[0] = [1,2,5,6] and answer[1] = []."
        ],
        "constraints": "1 <= matches.length <= 105\nmatches[i].length == 2\n1 <= winneri, loseri <= 105\nwinneri != loseri\nAll matches[i] are unique.",
        "oracle_code": "class Solution:\n    def findWinners(self, matches: List[List[int]]) -> List[List[int]]:\n\n        winners, losers = defaultdict(int), defaultdict(int)\n\n        for match in matches:\n\n            winners[match[0]] += 1\n            losers[match[1]] += 1\n\n        res_1, res_2 = [], []\n\n        for k, v in winners.items():\n            if k not in losers:\n                res_1.append(k)\n        \n        for k, v in losers.items():\n            if v == 1:\n                res_2.append(k)\n\n        res_1.sort()\n        res_2.sort()\n        \n        return [ res_1, res_2 ]",
        "content": "# Intuition\\nIf you need to aggregate and count some sequens you cen use either array or hasmap if it is a matter of a uniqueness.\\n\\n# Approach\\nIn our case we need to find unique teams that either not loose or loose not more than 1 match. So we need to distribute the information about all matches among two grous and\\n1. Check for intesection for winners\\n2. Check for 1 lost for loosers\\n\\n# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def findWinners(self, matches: List[List[int]]) -> List[List[int]]:\\n\\n        winners, losers = defaultdict(int), defaultdict(int)\\n\\n        for match in matches:\\n\\n            winners[match[0]] += 1\\n            losers[match[1]] += 1\\n\\n        res_1, res_2 = [], []\\n\\n        for k, v in winners.items():\\n            if k not in losers:\\n                res_1.append(k)\\n        \\n        for k, v in losers.items():\\n            if v == 1:\\n                res_2.append(k)\\n\\n        res_1.sort()\\n        res_2.sort()\\n        \\n        return [ res_1, res_2 ]\\n```",
        "level": "medium",
        "type": [
            "wrong comment mark",
            "indexing error",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def findWinners(self, matches: List[List[int]]) -> List[List[int]]:\n\n        winners, losers = defaultdict(int), defaultdict(int)\n\n        for match in matches:\n\n            winners[match[0]] += \n            losers[match[2]] += \n\n        res_1, res_2 = [], []\n\n        for k, v in winners.items():\n            if k not in losers:\n                res_1.append(k)\n\n        for k, v in winners.items(): \n            if v == 1:\n                res_2.append(k)\n\n        res_1.sort()\n        res_2.sort()\n        \n        return [ res_1, res_2 ]\n"
    },
    {
        "slug": "number-of-ways-of-cutting-a-pizza",
        "description": "Given a rectangular pizza represented as a rows x cols\u00a0matrix containing the following characters: 'A' (an apple) and '.' (empty cell) and given the integer k. You have to cut the pizza into k pieces using k-1 cuts.\u00a0\nFor each cut you choose the direction: vertical or horizontal, then you choose a cut position at the cell boundary and cut the pizza into two pieces. If you cut the pizza vertically, give the left part of the pizza to a person. If you cut the pizza horizontally, give the upper part of the pizza to a person. Give the last piece of pizza to the last person.\nReturn the number of ways of cutting the pizza such that each piece contains at least one apple.\u00a0Since the answer can be a huge number, return this modulo 10^9 + 7.",
        "examples": [
            "Input: pizza = [\"A..\",\"AAA\",\"...\"], k = 3\nOutput: 3 \nExplanation: The figure above shows the three ways to cut the pizza. Note that pieces must contain at least one apple.",
            "Input: pizza = [\"A..\",\"AA.\",\"...\"], k = 3\nOutput: 1",
            "Input: pizza = [\"A..\",\"A..\",\"...\"], k = 1\nOutput: 1"
        ],
        "constraints": "1 <= rows, cols <= 50\nrows ==\u00a0pizza.length\ncols ==\u00a0pizza[i].length\n1 <= k <= 10\npizza consists of characters 'A'\u00a0and '.' only.",
        "oracle_code": "class Solution:\n    def ways(self, pizza: List[str], k: int) -> int:\n        self.r = len(pizza)\n        self.c = len(pizza[0])\n        \n        # Step 1, pre-process the apple array and get the prefix sum\n        tot_apples = 0\n        self.pfsum_row = []\n        self.pfsum_col = []\n        \n        for i in range(self.r):\n            pfr = 0\n            pfs_r = [0] * self.c\n            pfs_c = [0] * self.c\n            for j in range(self.c):\n                if i > 0:\n                    pfs_c[j] += self.pfsum_col[i - 1][j]\n                if pizza[i][j] == 'A':\n                    pfr += 1\n                    pfs_c[j] += 1\n                    tot_apples += 1\n                pfs_r[j] = pfr\n            self.pfsum_row.append(pfs_r)\n            self.pfsum_col.append(pfs_c)\n        \n        if tot_apples < k:\n            return 0\n        \n        if k == 1:\n            return 1\n        \n        return self.getWays(0, 0, k) % (1000000007)\n    \n    \n    @cache\n    def getWays(self, i, j, k):\n        if k == 1:\n            # if only left one piece for cutting, we just need to check if there is any apple in the region\n            found = False\n            for c in range(j, self.c):\n                apple_in_region = self.pfsum_col[self.r - 1][c]\n                if i > 0:\n                     apple_in_region -= self.pfsum_col[i - 1][c]\n                if apple_in_region:\n                    found = True\n                    break\n            if found:\n                return 1\n            return 0\n        else:\n            # horizontally cut\n            cannot_cut = True\n            nr = i\n            t_cnt = 0\n            while nr < self.r - 1:\n                # find the first row that we can start cutting\n                while nr < self.r - 1 and cannot_cut:\n                    apple_in_region = self.pfsum_row[nr][self.c - 1]\n                    if j > 0:\n                        apple_in_region -= self.pfsum_row[nr][j - 1]\n                    if apple_in_region:\n                        cannot_cut = False\n                    else:\n                        nr += 1\n                        \n                if nr < self.r - 1:\n                    t_cnt += self.getWays(nr + 1, j, k - 1)\n                nr += 1\n                \n            # vertically cut\n            cannot_cut = True\n            nc = j\n            while nc < self.c - 1:\n                # find the first col that we can start cutting\n                while nc < self. c - 1 and cannot_cut:\n                    apple_in_region = self.pfsum_col[self.r - 1][nc]\n                    if i > 0:\n                        apple_in_region -= self.pfsum_col[i - 1][nc]\n                    if apple_in_region:\n                        cannot_cut = False\n                    else:\n                        nc += 1\n                \n                if nc < self.c - 1:\n                    t_cnt += self.getWays(i, nc + 1, k - 1)\n                nc += 1\n            \n            return t_cnt",
        "content": "The key to this problem is how to count the number of apples on the region we want to cut.\\n\\nWe can simply use the prefix sum that help to identify the number of apples between any two index.\\n\\nTherefore, we need to pre-process the input array, get the prefix sum horizatonally and vertically.\\n\\nWith the prefix sum array, we can create a dp funtion that get the number of cuts in the region (i, j) to (row - 1, col - 1)\\n\\n\\n```\\nclass Solution:\\n    def ways(self, pizza: List[str], k: int) -> int:\\n        self.r = len(pizza)\\n        self.c = len(pizza[0])\\n        \\n        # Step 1, pre-process the apple array and get the prefix sum\\n        tot_apples = 0\\n        self.pfsum_row = []\\n        self.pfsum_col = []\\n        \\n        for i in range(self.r):\\n            pfr = 0\\n            pfs_r = [0] * self.c\\n            pfs_c = [0] * self.c\\n            for j in range(self.c):\\n                if i > 0:\\n                    pfs_c[j] += self.pfsum_col[i - 1][j]\\n                if pizza[i][j] == \\'A\\':\\n                    pfr += 1\\n                    pfs_c[j] += 1\\n                    tot_apples += 1\\n                pfs_r[j] = pfr\\n            self.pfsum_row.append(pfs_r)\\n            self.pfsum_col.append(pfs_c)\\n        \\n        if tot_apples < k:\\n            return 0\\n        \\n        if k == 1:\\n            return 1\\n        \\n        return self.getWays(0, 0, k) % (1000000007)\\n    \\n    \\n    @cache\\n    def getWays(self, i, j, k):\\n        if k == 1:\\n            # if only left one piece for cutting, we just need to check if there is any apple in the region\\n            found = False\\n            for c in range(j, self.c):\\n                apple_in_region = self.pfsum_col[self.r - 1][c]\\n                if i > 0:\\n                     apple_in_region -= self.pfsum_col[i - 1][c]\\n                if apple_in_region:\\n                    found = True\\n                    break\\n            if found:\\n                return 1\\n            return 0\\n        else:\\n            # horizontally cut\\n            cannot_cut = True\\n            nr = i\\n            t_cnt = 0\\n            while nr < self.r - 1:\\n                # find the first row that we can start cutting\\n                while nr < self.r - 1 and cannot_cut:\\n                    apple_in_region = self.pfsum_row[nr][self.c - 1]\\n                    if j > 0:\\n                        apple_in_region -= self.pfsum_row[nr][j - 1]\\n                    if apple_in_region:\\n                        cannot_cut = False\\n                    else:\\n                        nr += 1\\n                        \\n                if nr < self.r - 1:\\n                    t_cnt += self.getWays(nr + 1, j, k - 1)\\n                nr += 1\\n                \\n            # vertically cut\\n            cannot_cut = True\\n            nc = j\\n            while nc < self.c - 1:\\n                # find the first col that we can start cutting\\n                while nc < self. c - 1 and cannot_cut:\\n                    apple_in_region = self.pfsum_col[self.r - 1][nc]\\n                    if i > 0:\\n                        apple_in_region -= self.pfsum_col[i - 1][nc]\\n                    if apple_in_region:\\n                        cannot_cut = False\\n                    else:\\n                        nc += 1\\n                \\n                if nc < self.c - 1:\\n                    t_cnt += self.getWays(i, nc + 1, k - 1)\\n                nc += 1\\n            \\n            return t_cnt\\n\\n```",
        "level": "hard",
        "type": [
            "undefined objects",
            "undefined keywords from other languages",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def ways(self, pizza: List[str], k: int) -> int:\n        self.r = len(pizza)\n        self.c = len(pizza[0])\n        tot_apples = 0\n        self.pfsum_row = []\n        self.pfsum_col = []\n        for i in range(self.r):\n            pfr = 0\n            pfs_r = [0] * self.c\n            pfs_c = [0] * self.c\n            for j in range(self.c):\n                if i > 0:\n                    pfs_c[j] += self.charlie[i - 1][j]\n                if pizza[i][j] == 'A':\n                    pfr += 1\n                    pfs_c[j] += 1\n                    tot_apples += 1\n                pfs_r[j] = pfr\n            self.pfsum_row.append(pfs_r)\n            self.pfsum_col.append(pfs_c)\n        \n        if tot_apples < k:\n            return 0\n        \n        if k == 1:\n            return 1\n        return self.getWays(0, 0, k - 2) % (1000000007)\n    \n    \n    @cache\n    def getWays(self, i, j, k):\n        if k == 1:\n            found = False\n            for c in range(j, this.c):\n                apple_in_region = this.pfsum_col[this.r - 1][c]\n                if i > 0:\n                     apple_in_region -= this.pfsum_col[i - 1][c]\n                if apple_in_region:\n                    found = True\n                    break\n            if found:\n                return 1   \n            return 0\n        else:cannot_cut = True\n            nr = i\n            t_cnt = 0\n            while nr < this.r - 1:\n                while nr < this.r - 1 and cannot_cut:\n                    apple_in_region = this.pfsum_row[nr][this.c - 1]\n                    if j > 0:\n                        apple_in_region -= this.pfsum_row[nr][j - 1]\n                    if apple_in_region:\n                        cannot_cut = False\n                    else:\n                        nr += 1\n                        \n                if nr < this.r - 1:\n                    t_cnt += this.getWays(nr + 1, j, k - 1)\n                nr += 1\n                \n            cannot_cut = True\n            nc = j\n            while nc < this.c - 1:while nc < this.c - 1 and cannot_cut:\n                    apple_in_region = this.pfsum_col[this.r - 1][nc]\n                    if i > 0:\n                        apple_in_region -= this.pfsum_col[i - 1][nc]\n                    if apple_in_region:\n                        cannot_cut = False\n                    else:\n                        nc += 1\n                \n                if nc < this.c - 1:\n                    t_cnt += this.getWays(i, nc + 1, k - 1)\n                nc += 1\n            \n            return t_cnt\n"
    },
    {
        "slug": "sum-of-subarray-ranges",
        "description": "You are given an integer array nums. The range of a subarray of nums is the difference between the largest and smallest element in the subarray.\nReturn the sum of all subarray ranges of nums.\nA subarray is a contiguous non-empty sequence of elements within an array.",
        "examples": [
            "Input: nums = [1,2,3]\nOutput: 4\nExplanation: The 6 subarrays of nums are the following:\n[1], range = largest - smallest = 1 - 1 = 0 \n[2], range = 2 - 2 = 0\n[3], range = 3 - 3 = 0\n[1,2], range = 2 - 1 = 1\n[2,3], range = 3 - 2 = 1\n[1,2,3], range = 3 - 1 = 2\nSo the sum of all ranges is 0 + 0 + 0 + 1 + 1 + 2 = 4.",
            "Input: nums = [1,3,3]\nOutput: 4\nExplanation: The 6 subarrays of nums are the following:\n[1], range = largest - smallest = 1 - 1 = 0\n[3], range = 3 - 3 = 0\n[3], range = 3 - 3 = 0\n[1,3], range = 3 - 1 = 2\n[3,3], range = 3 - 3 = 0\n[1,3,3], range = 3 - 1 = 2\nSo the sum of all ranges is 0 + 0 + 0 + 2 + 0 + 2 = 4.",
            "Input: nums = [4,-2,-3,4,1]\nOutput: 59\nExplanation: The sum of all subarray ranges of nums is 59."
        ],
        "constraints": "1 <= nums.length <= 1000\n-109 <= nums[i] <= 109\n\n\u00a0\nFollow-up: Could you find a solution with O(n) time complexity?",
        "oracle_code": "class Solution:\n    def subArrayRanges(self, nums: List[int]) -> int:\n        \n        def fn(op): \n            \"\"\"Return min sum (if given gt) or max sum (if given lt).\"\"\"\n            ans = 0 \n            stack = []\n            for i in range(len(nums) + 1): \n                while stack and (i == len(nums) or op(nums[stack[-1]], nums[i])): \n                    mid = stack.pop()\n                    ii = stack[-1] if stack else -1 \n                    ans += nums[mid] * (i - mid) * (mid - ii)\n                stack.append(i)\n            return ans \n        \n        return fn(lt) - fn(gt)",
        "content": "Please check out this [commit](https://github.com/gaosanyong/leetcode/commit/f57038d6cca9ccb356a137b3af67fba615a067dd) for solutions of weekly 271. \\n\\n```\\nclass Solution:\\n    def subArrayRanges(self, nums: List[int]) -> int:\\n        \\n        def fn(op): \\n            \"\"\"Return min sum (if given gt) or max sum (if given lt).\"\"\"\\n            ans = 0 \\n            stack = []\\n            for i in range(len(nums) + 1): \\n                while stack and (i == len(nums) or op(nums[stack[-1]], nums[i])): \\n                    mid = stack.pop()\\n                    ii = stack[-1] if stack else -1 \\n                    ans += nums[mid] * (i - mid) * (mid - ii)\\n                stack.append(i)\\n            return ans \\n        \\n        return fn(lt) - fn(gt)\\n```\\n\\n**Related problems**\\n[907. Sum of Subarray Minimums](https://leetcode.com/problems/sum-of-subarray-minimums/discuss/949064/Python3-stack-O(N))",
        "level": "medium",
        "type": [
            "indentation error",
            "unclosed string",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def subArrayRanges(self, nums: List[int]) -> int:\n        \n        def fn(op): \n            \"\"\"Return min sum (if given gt) or max sum (if given lt).\"\"\"\n            ans = 0 \n            stack = []\n        for i in range(len(nums) + 1): \n            while stack and (i == len(nums) or op(nums[stack[-1]], nums[i])): \n                mid = stack.pop()\n                ii = stack[-1] if stack else -1 \n                ans += nums[mid] * (i - mid) * (mid - ii)\n            stack.append(i)\n          return ans \n            return fn(lt - fn(gt)\n"
    },
    {
        "slug": "linked-list-cycle",
        "description": "Given head, the head of a linked list, determine if the linked list has a cycle in it.\nThere is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the\u00a0next\u00a0pointer. Internally, pos\u00a0is used to denote the index of the node that\u00a0tail's\u00a0next\u00a0pointer is connected to.\u00a0Note that\u00a0pos\u00a0is not passed as a parameter.\nReturn\u00a0true if there is a cycle in the linked list. Otherwise, return false.",
        "examples": [
            "Input: head = [3,2,0,-4], pos = 1\nOutput: true\nExplanation: There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).",
            "Input: head = [1,2], pos = 0\nOutput: true\nExplanation: There is a cycle in the linked list, where the tail connects to the 0th node.",
            "Input: head = [1], pos = -1\nOutput: false\nExplanation: There is no cycle in the linked list."
        ],
        "constraints": "The number of the nodes in the list is in the range [0, 104].\n-105 <= Node.val <= 105\npos is -1 or a valid index in the linked-list.",
        "oracle_code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\n        a=b=head\n        while(a!=None and a.next!=None):\n            b=b.next\n            a=a.next.next\n            if(a==b):\n                return True\n        return False",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        a=b=head\\n        while(a!=None and a.next!=None):\\n            b=b.next\\n            a=a.next.next\\n            if(a==b):\\n                return True\\n        return False\\n```",
        "level": "easy",
        "type": [
            "indentation error",
            "undefined methods",
            "conditional statement error"
        ],
        "buggy_code": "\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\ndef hasCycle(self, head: Optional[ListNode]) -> bool:\n    a=b=head\n    while(a!=None and a.next!=None):\n        b=b.moveNext()\n            a=a.moveTwoStepNext()\n        if(a==b):\n            return True\n    return False\n\n"
    },
    {
        "slug": "count-the-repetitions",
        "description": "We define str = [s, n] as the string str which consists of the string s concatenated n times.\n\nFor example, str == [\"abc\", 3] ==\"abcabcabc\".\n\nWe define that string s1 can be obtained from string s2 if we can remove some characters from s2 such that it becomes s1.\n\nFor example, s1 = \"abc\" can be obtained from s2 = \"abdbec\" based on our definition by removing the bolded underlined characters.\n\nYou are given two strings s1 and s2 and two integers n1 and n2. You have the two strings str1 = [s1, n1] and str2 = [s2, n2].\nReturn the maximum integer m such that str = [str2, m] can be obtained from str1.",
        "examples": [
            "Input: s1 = \"acb\", n1 = 4, s2 = \"ab\", n2 = 2\nOutput: 2",
            "Input: s1 = \"acb\", n1 = 1, s2 = \"acb\", n2 = 1\nOutput: 1"
        ],
        "constraints": "1 <= s1.length, s2.length <= 100\ns1 and s2 consist of lowercase English letters.\n1 <= n1, n2 <= 106",
        "oracle_code": "class Solution:\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\n\n        rec, track = [0], defaultdict(int) \n        ct = start = ptr1 = ptr2 = 0\n\n        if not set(s2).issubset(set(s1)): return 0\n\n        s1 = ''.join(char for char in s1 if char in set(s2))\n        \n        while True:\n            for char in s2:\n                ptr = s1.find(char, start)\n                if ptr == -1:\n                    ct += 1\n                    ptr = s1.find(char)\n                start = ptr+1\n            rec.append(ct + 1)\n\n            if rec[-1] > n1: return (len(rec)-2)//n2\n\n            if ptr not in track: track[ptr] = len(rec)-1\n            else: break\n        \n        cycleStart = rec[track[ptr]]\n        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]\n        rest = n1 - cycleStart\n        \n        rem = cycleStart + rest%cycle1\n\n        while rec[ptr2] <= rem: ptr2+= 1\n\n        return (cycle2 * (rest//cycle1) + ptr2-1)//n2",
        "content": "```\\nclass Solution:\\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\\n\\n        rec, track = [0], defaultdict(int) \\n        ct = start = ptr1 = ptr2 = 0\\n\\n        if not set(s2).issubset(set(s1)): return 0\\n\\n        s1 = \\'\\'.join(char for char in s1 if char in set(s2))\\n        \\n        while True:\\n            for char in s2:\\n                ptr = s1.find(char, start)\\n                if ptr == -1:\\n                    ct += 1\\n                    ptr = s1.find(char)\\n                start = ptr+1\\n            rec.append(ct + 1)\\n\\n            if rec[-1] > n1: return (len(rec)-2)//n2\\n\\n            if ptr not in track: track[ptr] = len(rec)-1\\n            else: break\\n        \\n        cycleStart = rec[track[ptr]]\\n        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]\\n        rest = n1 - cycleStart\\n        \\n        rem = cycleStart + rest%cycle1\\n\\n        while rec[ptr2] <= rem: ptr2+= 1\\n\\n        return (cycle2 * (rest//cycle1) + ptr2-1)//n2\\n```\\n[https://leetcode.com/problems/count-the-repetitions/submissions/864907562/](http://)\\n\\nI could be wrong, but I think that time is *O*(*N*) and space is *O*(*N*).",
        "level": "hard",
        "type": [
            "colon missing",
            "unclosed string",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int\n\n        rec, track = [0], defaultdict(int) \n        ct = start = ptr1 = ptr2 = 0\n\n        if not set(s2).issubset(set(s1)): return 0\n\n        s1 = ''.join(char for char in s1 if char in set(s2))\n        \n        while True:\n            for char in s2:\n                ptr = s1.find(char, start)\n                if ptr == -1:\n                    ct += 1\n                    ptr = s1.find(char)\n                start = ptr+1\n            rec.append(ct + 1)\n\n            if rec[-1] >= n1: return (len(rec)-2)//n2\n\n            if ptr not in track: track[ptr] = len(0rec)-1\n            \n            else: break\n        \n        cycleStart = rec[track[ptr]]\n        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]\n        rest = n1 - cycleStart\n        \n        rem = cycleStart + rest%cycle1\n\n        while rec[ptr2] <= rem: ptr2+= 1\n\n        return (cycle2 * (rest//cycle1) + ptr2-1)//n2\n"
    },
    {
        "slug": "n-queens-ii",
        "description": "The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.\nGiven an integer n, return the number of distinct solutions to the\u00a0n-queens puzzle.",
        "examples": [
            "Input: n = 4\nOutput: 2\nExplanation: There are two distinct solutions to the 4-queens puzzle as shown.",
            "Input: n = 1\nOutput: 1"
        ],
        "constraints": "1 <= n <= 9",
        "oracle_code": "class Solution:\n    def totalNQueens(self, n: int) -> int:\n        def addans(board,ans):\n            temp=[]\n            for row in board:\n                for j in range(len(row)):\n                    if row[j]==\"Q\":\n                        temp.append(j+1)\n            ans.append(temp)\n        def solve(col,board,low,upper,lower,ans,n):\n            if col==n:\n                addans(board,ans)\n                return \n            for row in range(n):\n                if low[row]==0 and upper[n-1+col-row]==0 and lower[row+col]==0:\n                    board[row][col]=\"Q\"\n                    low[row]=1\n                    upper[n-1+col-row]=1\n                    lower[row+col]=1\n                    solve(col+1,board,low,upper,lower,ans,n)\n                    low[row]=0\n                    upper[n-1+col-row]=0\n                    lower[row+col]=0\n        ans=[]        \n        board=[[0]*n for i in range(n)]\n        low=[0]*n\n        upper=[0]*(2*n-1)\n        lower=[0]*(2*n-1)\n        solve(0,board,low,upper,lower,ans,n)\n        return len(ans)",
        "content": "\\n\\n# 1. BackTracking Logic Solution\\n```\\nclass Solution:\\n    def totalNQueens(self, n: int) -> int:\\n        def addans(board,ans):\\n            temp=[]\\n            for row in board:\\n                for j in range(len(row)):\\n                    if row[j]==\"Q\":\\n                        temp.append(j+1)\\n            ans.append(temp)\\n        def solve(col,board,low,upper,lower,ans,n):\\n            if col==n:\\n                addans(board,ans)\\n                return \\n            for row in range(n):\\n                if low[row]==0 and upper[n-1+col-row]==0 and lower[row+col]==0:\\n                    board[row][col]=\"Q\"\\n                    low[row]=1\\n                    upper[n-1+col-row]=1\\n                    lower[row+col]=1\\n                    solve(col+1,board,low,upper,lower,ans,n)\\n                    low[row]=0\\n                    upper[n-1+col-row]=0\\n                    lower[row+col]=0\\n        ans=[]        \\n        board=[[0]*n for i in range(n)]\\n        low=[0]*n\\n        upper=[0]*(2*n-1)\\n        lower=[0]*(2*n-1)\\n        solve(0,board,low,upper,lower,ans,n)\\n        return len(ans)\\n```\\n   # please upvote me it would encourage me alot\\n\\n\\n\\n",
        "level": "hard",
        "type": [
            "colon missing",
            "undefined objects",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution:\n    def totalNQueens(self, n: int) -> int:\n        def addans(board,ans):\n            temp=[]\n            for row in board:\n                for j in range(len(row)):\n                    if row[j]==\"Q\"\n                        temp.append(j+1)\n            ans.append(temp)\n        def solve(col,board,low,upper,lower,ans,n):\n            if col==n:\n                addans(board,ans)\n                return \n            for row in range(n):\n                if low[row]==0 and upper[n-1+col-row]==0 and lower[row+col]==0:\n                    board[row][col]=\"Q\"\n                    low[row]=1\n                    upper[n-1+col-row]=1\n                    lower[row+col]=1\n                    solve(NULL,board,low,upper,lower,ans,n)\n                    low[row]=0\n                    upper[n-1+col-row]=0\n                    lower[row+col]=0\n        ans=[]        \n        board=[[0]*n for i in range(n)\n        low=[0]*n\n        upper=[0]*(2*n-1)\n        lower=[0]*(2*n-1)\n        solve(0,board,low,upper,lower,ans,n)\n        return len(ans)\n"
    },
    {
        "slug": "minimize-the-total-price-of-the-trips",
        "description": "There exists an undirected and unrooted tree with n nodes indexed from 0 to n - 1. You are given the integer n and a 2D integer array edges of length n - 1, where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree.\nEach node has an associated price. You are given an integer array price, where price[i] is the price of the ith node.\nThe price sum of a given path is the sum of the prices of all nodes lying on that path.\nAdditionally, you are given a 2D integer array trips, where trips[i] = [starti, endi] indicates that you start the ith trip from the node starti and travel to the node endi by any path you like.\nBefore performing your first trip, you can choose some non-adjacent nodes and halve the prices.\nReturn the minimum total price sum to perform all the given trips.",
        "examples": [
            "Input: n = 4, edges = [[0,1],[1,2],[1,3]], price = [2,2,10,6], trips = [[0,3],[2,1],[2,3]]\nOutput: 23\nExplanation: The diagram above denotes the tree after rooting it at node 2. The first part shows the initial tree and the second part shows the tree after choosing nodes 0, 2, and 3, and making their price half.\nFor the 1st trip, we choose path [0,1,3]. The price sum of that path is 1 + 2 + 3 = 6.\nFor the 2nd trip, we choose path [2,1]. The price sum of that path is 2 + 5 = 7.\nFor the 3rd trip, we choose path [2,1,3]. The price sum of that path is 5 + 2 + 3 = 10.\nThe total price sum of all trips is 6 + 7 + 10 = 23.\nIt can be proven, that 23 is the minimum answer that we can achieve.",
            "Input: n = 2, edges = [[0,1]], price = [2,2], trips = [[0,0]]\nOutput: 1\nExplanation: The diagram above denotes the tree after rooting it at node 0. The first part shows the initial tree and the second part shows the tree after choosing node 0, and making its price half.\nFor the 1st trip, we choose path [0]. The price sum of that path is 1.\nThe total price sum of all trips is 1. It can be proven, that 1 is the minimum answer that we can achieve."
        ],
        "constraints": "1 <= n <= 50\nedges.length == n - 1\n0 <= ai, bi <= n - 1\nedges represents a valid tree.\nprice.length == n\nprice[i] is an even integer.\n1 <= price[i] <= 1000\n1 <= trips.length <= 100\n0 <= starti, endi\u00a0<= n - 1",
        "oracle_code": "class Solution:\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\n        g = [[] for _ in range(n)]\n        for i, j in edges:\n            g[i].append(j)\n            g[j].append(i)\n            \n        freq = [0] * n\n        level = [0] * n\n        parent = [0] * n\n        \n        def dfs(i, l, p):\n            level[i] = l\n            parent[i] = p\n            for j in g[i]:\n                if j != p:\n                    dfs(j, l + 1, i)\n        \n        def LCA(a, b):\n            if level[a] > level[b]:\n                a, b = b, a\n            d = level[b] - level[a]\n            while d:\n                b = parent[b]\n                d -= 1\n            if a == b:\n                return a\n            while a != b:\n                a = parent[a]\n                b = parent[b]\n            return a\n        \n        dfs(0, 0, -1)\n        for i, j in trips:\n            lca = LCA(i, j)\n            path = []\n            while i != lca:\n                freq[i] += 1\n                i = parent[i]\n            freq[i] += 1\n            while j != lca:\n                freq[j] += 1\n                j = parent[j]\n        \n        def dp(i, p):\n            res0 = 0\n            res1 = price[i] // 2 * freq[i]\n            for j in g[i]:\n                if j != p:\n                    curr = dp(j, i)\n                    res0 += max(curr)\n                    res1 += curr[0]\n            return [res0, res1]\n        ans = 0\n        for i in range(n):\n            ans += freq[i] * price[i]\n        return ans - max(dp(0, -1))",
        "content": "We use lowest common ancestor to find path for each trip. Let `freq` be the frequencies for each node. `dp(i, p)` returns the maximum price we can save without or with choosing node `i`.\\n```\\nclass Solution:\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        g = [[] for _ in range(n)]\\n        for i, j in edges:\\n            g[i].append(j)\\n            g[j].append(i)\\n            \\n        freq = [0] * n\\n        level = [0] * n\\n        parent = [0] * n\\n        \\n        def dfs(i, l, p):\\n            level[i] = l\\n            parent[i] = p\\n            for j in g[i]:\\n                if j != p:\\n                    dfs(j, l + 1, i)\\n        \\n        def LCA(a, b):\\n            if level[a] > level[b]:\\n                a, b = b, a\\n            d = level[b] - level[a]\\n            while d:\\n                b = parent[b]\\n                d -= 1\\n            if a == b:\\n                return a\\n            while a != b:\\n                a = parent[a]\\n                b = parent[b]\\n            return a\\n        \\n        dfs(0, 0, -1)\\n        for i, j in trips:\\n            lca = LCA(i, j)\\n            path = []\\n            while i != lca:\\n                freq[i] += 1\\n                i = parent[i]\\n            freq[i] += 1\\n            while j != lca:\\n                freq[j] += 1\\n                j = parent[j]\\n        \\n        def dp(i, p):\\n            res0 = 0\\n            res1 = price[i] // 2 * freq[i]\\n            for j in g[i]:\\n                if j != p:\\n                    curr = dp(j, i)\\n                    res0 += max(curr)\\n                    res1 += curr[0]\\n            return [res0, res1]\\n        ans = 0\\n        for i in range(n):\\n            ans += freq[i] * price[i]\\n        return ans - max(dp(0, -1))\\n```",
        "level": "hard",
        "type": [
            "other error",
            "colon missing",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution:\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\n        g = [[] for _ in range(n)]\n        for i, j in edges:\n            g[i].append(j)\n            g[j].append(i)\n            \n        freq = [0] * n\n        level = [0] * n\n        parent = [0] * n\n        \n        def dfs(i, l, p)\n            level[i] = l\n            parent[i] = p\n            for j in g[i]:\n                if j != p:\n                    dfs(j, l + 1, i)\n        \n        undefinedLCA(a, b):\n            if level[a] > level[b]:\n                a, b = b, a\n            d = level[b] - level[a]\n            while d:\n                b = parent[b]\n                d -= 1\n            if a == b:\n                return a\n            while a != b:\n                a = parent[a]\n                b = parent[b]\n            return a\n        \n        dfs(0, 0, -1)\n        for i, j in trips:\n            lca = LCA(i, j)\n            path = []\n            while i != lca:\n                freq[i] += 2\n                i = parent[i]\n            freq[i] += 1\n            while j != lca:\n                freq[j] += 1\n                j = parent[j]\n        \n        def dp(i, p)\n            res0 = 0\n            res1 = price[i] // 2 * freq[i]\n            for j in g[i]:\n                if j != p:\n                    curr = dp(j, i)\n                    res0 += max(curr)\n                    res1 += curr[0]\n            return [res0, res1]\n        ans = 0\n        for i in range(n):\n            ans += freq[i] * price[i]\n        return ans - max(dp(0, -1))\n"
    },
    {
        "slug": "kth-largest-element-in-an-array",
        "description": "Given an integer array nums and an integer k, return the kth largest element in the array.\nNote that it is the kth largest element in the sorted order, not the kth distinct element.\nCan you solve it without sorting?",
        "examples": [
            "Input: nums = [3,2,1,5,6,4], k = 2\nOutput: 5",
            "Input: nums = [3,2,3,1,2,4,5,5,6], k = 4\nOutput: 4"
        ],
        "constraints": "1 <= k <= nums.length <= 105\n-104 <= nums[i] <= 104",
        "oracle_code": "class Solution:\n    def findKthLargest(self, nums: List[int], k: int) -> int:\n        return sorted(nums)[-k]",
        "content": "# Approach\\n- Sorting\\n\\n# Complexity\\n- Time complexity: O(n*log(n))\\n\\n# Code\\n```\\nclass Solution:\\n    def findKthLargest(self, nums: List[int], k: int) -> int:\\n        return sorted(nums)[-k]\\n```",
        "level": "medium",
        "type": [
            "parentheses mismatch",
            "undefined keywords from other languages",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def findKthLargest(self, nums: List[int], k: int -> int:\n        return sort(nums)[-k-1]\n"
    },
    {
        "slug": "check-whether-two-strings-are-almost-equivalent",
        "description": "Two strings word1 and word2 are considered almost equivalent if the differences between the frequencies of each letter from 'a' to 'z' between word1 and word2 is at most 3.\nGiven two strings word1 and word2, each of length n, return true if word1 and word2 are almost equivalent, or false otherwise.\nThe frequency of a letter x is the number of times it occurs in the string.",
        "examples": [
            "Input: word1 = \"aaaa\", word2 = \"bccb\"\nOutput: false\nExplanation: There are 4 'a's in \"aaaa\" but 0 'a's in \"bccb\".\nThe difference is 4, which is more than the allowed 3.",
            "Input: word1 = \"abcdeef\", word2 = \"abaaacc\"\nOutput: true\nExplanation: The differences between the frequencies of each letter in word1 and word2 are at most 3:\n- 'a' appears 1 time in word1 and 4 times in word2. The difference is 3.\n- 'b' appears 1 time in word1 and 1 time in word2. The difference is 0.\n- 'c' appears 1 time in word1 and 2 times in word2. The difference is 1.\n- 'd' appears 1 time in word1 and 0 times in word2. The difference is 1.\n- 'e' appears 2 times in word1 and 0 times in word2. The difference is 2.\n- 'f' appears 1 time in word1 and 0 times in word2. The difference is 1.",
            "Input: word1 = \"cccddabba\", word2 = \"babababab\"\nOutput: true\nExplanation: The differences between the frequencies of each letter in word1 and word2 are at most 3:\n- 'a' appears 2 times in word1 and 4 times in word2. The difference is 2.\n- 'b' appears 2 times in word1 and 5 times in word2. The difference is 3.\n- 'c' appears 3 times in word1 and 0 times in word2. The difference is 3.\n- 'd' appears 2 times in word1 and 0 times in word2. The difference is 2."
        ],
        "constraints": "n == word1.length == word2.length\n1 <= n <= 100\nword1 and word2 consist only of lowercase English letters.",
        "oracle_code": "class Solution:\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\n        A = [0] * 26\n        for char in word1: A[ord(char) - ord(\"a\")] += 1\n        for char in word2: A[ord(char) - ord(\"a\")] -= 1\n        return not any ([(f < -3 or f > 3) for f in A])",
        "content": "# Code\\n```\\nclass Solution:\\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\\n        A = [0] * 26\\n        for char in word1: A[ord(char) - ord(\"a\")] += 1\\n        for char in word2: A[ord(char) - ord(\"a\")] -= 1\\n        return not any ([(f < -3 or f > 3) for f in A])        \\n\\n```",
        "level": "easy",
        "type": [
            "colon missing",
            "operation error",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution:\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool\n        A = [0] * 26\n        for char in word1: A[ord(char) - ord(\"a\")] += 1\n        for char in word2: B[ord(char) - ord(\"b\")] -= 1\n        return not any ([(f < -3 or f > 3) for f in A])\n"
    },
    {
        "slug": "find-kth-bit-in-nth-binary-string",
        "description": "Given two positive integers n and k, the binary string Sn is formed as follows:\n\nS1 = \"0\"\nSi = Si - 1 + \"1\" + reverse(invert(Si - 1)) for i > 1\n\nWhere + denotes the concatenation operation, reverse(x) returns the reversed string x, and invert(x) inverts all the bits in x (0 changes to 1 and 1 changes to 0).\nFor example, the first four strings in the above sequence are:\n\nS1 = \"0\"\nS2 = \"011\"\nS3 = \"0111001\"\nS4 = \"011100110110001\"\n\nReturn the kth bit in Sn. It is guaranteed that k is valid for the given n.",
        "examples": [
            "Input: n = 3, k = 1\nOutput: \"0\"\nExplanation: S3 is \"0111001\".\nThe 1st bit is \"0\".",
            "Input: n = 4, k = 11\nOutput: \"1\"\nExplanation: S4 is \"011100110110001\".\nThe 11th bit is \"1\"."
        ],
        "constraints": "1 <= n <= 20\n1 <= k <= 2n - 1",
        "oracle_code": "class Solution:\n    def findKthBit(self, N, K, R = True):\n        if K == 1: return '0' if R else '1'\n        mid = (1 << (N - 1))\n        if K < mid: return self.findKthBit(N - 1, K, R)\n        if K > mid: return self.findKthBit(N - 1, 2 * mid - K, not R)\n        return '1' if R else '0'",
        "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n\\n### Recursive Approach\\n```\\nclass Solution:\\n    def findKthBit(self, N, K, R = True):\\n        if K == 1: return \\'0\\' if R else \\'1\\'\\n        mid = (1 << (N - 1))\\n        if K < mid: return self.findKthBit(N - 1, K, R)\\n        if K > mid: return self.findKthBit(N - 1, 2 * mid - K, not R)\\n        return \\'1\\' if R else \\'0\\'\\n```\\n\\n### Iterative Approach\\n```\\nclass Solution:\\n    def findKthBit(self, N, K):\\n        ans = 1\\n        mid = (1 << (N - 1))\\n        while K > 1:\\n            if K == mid: return str(ans)\\n            if K > mid: \\n                K = 2 * mid - K\\n                ans ^= 1\\n            mid >>= 1\\n        return str(ans^1)\\n```",
        "level": "medium",
        "type": [
            "unclosed string",
            "== and = confusion",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def findKthBit(self, N, K, R = True):\n        if K == 1: return '0' if R else '1'\n        mid = (1 << (N - 1))\n        if K <= mid: return self.findKthBit(N - 1, K, R)\n        if K = mid: return self.findKthBit(N - 1, 2 * mid - K, not R)\n        return \"1 if R else '0\n"
    },
    {
        "slug": "substring-with-concatenation-of-all-words",
        "description": "You are given a string s and an array of strings words. All the strings of words are of the same length.\nA concatenated substring in s is a substring that contains all the strings of any permutation of words concatenated.\n\nFor example, if words = [\"ab\",\"cd\",\"ef\"], then \"abcdef\", \"abefcd\", \"cdabef\", \"cdefab\", \"efabcd\", and \"efcdab\" are all concatenated strings. \"acdbef\" is not a concatenated substring because it is not the concatenation of any permutation of words.\n\nReturn the starting indices of all the concatenated substrings in s. You can return the answer in any order.",
        "examples": [
            "Input: s = \"barfoothefoobarman\", words = [\"foo\",\"bar\"]\nOutput: [0,9]\nExplanation: Since words.length == 2 and words[i].length == 3, the concatenated substring has to be of length 6.\nThe substring starting at 0 is \"barfoo\". It is the concatenation of [\"bar\",\"foo\"] which is a permutation of words.\nThe substring starting at 9 is \"foobar\". It is the concatenation of [\"foo\",\"bar\"] which is a permutation of words.\nThe output order does not matter. Returning [9,0] is fine too.",
            "Input: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]\nOutput: []\nExplanation: Since words.length == 4 and words[i].length == 4, the concatenated substring has to be of length 16.\nThere is no substring of length 16 is s that is equal to the concatenation of any permutation of words.\nWe return an empty array.",
            "Input: s = \"barfoofoobarthefoobarman\", words = [\"bar\",\"foo\",\"the\"]\nOutput: [6,9,12]\nExplanation: Since words.length == 3 and words[i].length == 3, the concatenated substring has to be of length 9.\nThe substring starting at 6 is \"foobarthe\". It is the concatenation of [\"foo\",\"bar\",\"the\"] which is a permutation of words.\nThe substring starting at 9 is \"barthefoo\". It is the concatenation of [\"bar\",\"the\",\"foo\"] which is a permutation of words.\nThe substring starting at 12 is \"thefoobar\". It is the concatenation of [\"the\",\"foo\",\"bar\"] which is a permutation of words."
        ],
        "constraints": "1 <= s.length <= 104\n1 <= words.length <= 5000\n1 <= words[i].length <= 30\ns and words[i] consist of lowercase English letters.",
        "oracle_code": "class Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        wlen= len(words[0])\n        slen= wlen*len(words)\n        track=dict()\n        \n        occ = collections.Counter(words)\n\n        def test():\n            for key, val in track.items():\n                if val !=occ[key]:\n                    return False\n            return True\n        res=[]\n        #first look\n\n        for k in range(wlen):\n            for i in words:\n                track.update({i : 0})\n            for i in range(k,slen+k,wlen):\n                w=s[i:i+wlen]\n                if w in words:\n                    track.update({w: track[w]+1})\n            if test():\n                res.append(k)\n            #complete\n            for i in range(wlen+k, len(s)-slen+1,wlen):\n                \n                nw=s[i+slen-wlen:i+slen]\n                pw=s[i-wlen:i]\n                if nw in words:\n                    track.update({nw: track[nw]+1})\n                if pw in words:\n                    track.update({pw: track[pw]-1})\n                if test():\n                    res.append(i)\n        return res",
        "content": "\\n# Approach\\n\\nThe solution iterates through possible starting points in the given string and checks if the substring starting from each point forms a concatenated substring. It maintains a dictionary to track the occurrences of words encountered and compares it with the expected occurrences. By updating the counts while scanning the string, it identifies valid concatenated substrings and records their starting indices. The solution effectively ensures that all the words in any permutation of the input words array are present in the substring, returning the starting indices of all such valid substrings.\\n\\n# Code\\n```\\nclass Solution:\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\\n        wlen= len(words[0])\\n        slen= wlen*len(words)\\n        track=dict()\\n        \\n        occ = collections.Counter(words)\\n\\n        def test():\\n            for key, val in track.items():\\n                if val !=occ[key]:\\n                    return False\\n            return True\\n        res=[]\\n        #first look\\n\\n        for k in range(wlen):\\n            for i in words:\\n                track.update({i : 0})\\n            for i in range(k,slen+k,wlen):\\n                w=s[i:i+wlen]\\n                if w in words:\\n                    track.update({w: track[w]+1})\\n            if test():\\n                res.append(k)\\n            #complete\\n            for i in range(wlen+k, len(s)-slen+1,wlen):\\n                \\n                nw=s[i+slen-wlen:i+slen]\\n                pw=s[i-wlen:i]\\n                if nw in words:\\n                    track.update({nw: track[nw]+1})\\n                if pw in words:\\n                    track.update({pw: track[pw]-1})\\n                if test():\\n                    res.append(i)\\n        return res\\n\\n        \\n```",
        "level": "hard",
        "type": [
            "indentation error",
            "parentheses mismatch",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        wlen= len(words[0])\n        slen= wlen*len(words)\n        track=dict()\n        \n        occ = collections.Counter(words)\n\n    def test():\n        for key, val in track.items():\n            if val !=occ[key]:\n                return False \n        return True\n    res=[]\n    \n\n    for k in range(wlen):\n        for i in words:\n            track.update({i : 0}))\n        for i in range(k,slen+k,wlen):\n            w=s[i:i+wlen]\n            if w in words:\n                track.update({w: track[w]+1)})\n            if test():\n                res.append(k)\n            #complete\n            for i in range(wlen+k, len(s)-slen+1,wlen):\n                \n                nw=s[i+slen-wlen:i+slen]\n                pw=s[i-wlen:i]\n                if nw in words:\n                    track.update({nw: track[nw]+1}))\n            if pw in words:\n                track.update({pw: track[pw]-1)})\n            if test()):\n                res.append(i+wlen))\n    return res\n"
    },
    {
        "slug": "restore-the-array-from-adjacent-pairs",
        "description": "There is an integer array nums that consists of n unique elements, but you have forgotten it. However, you do remember every pair of adjacent elements in nums.\nYou are given a 2D integer array adjacentPairs of size n - 1 where each adjacentPairs[i] = [ui, vi] indicates that the elements ui and vi are adjacent in nums.\nIt is guaranteed that every adjacent pair of elements nums[i] and nums[i+1] will exist in adjacentPairs, either as [nums[i], nums[i+1]] or [nums[i+1], nums[i]]. The pairs can appear in any order.\nReturn the original array nums. If there are multiple solutions, return any of them.",
        "examples": [
            "Input: adjacentPairs = [[2,1],[3,4],[3,2]]\nOutput: [1,2,3,4]\nExplanation: This array has all its adjacent pairs in adjacentPairs.\nNotice that adjacentPairs[i] may not be in left-to-right order.",
            "Input: adjacentPairs = [[4,-2],[1,4],[-3,1]]\nOutput: [-2,4,1,-3]\nExplanation: There can be negative numbers.\nAnother solution is [-3,1,4,-2], which would also be accepted.",
            "Input: adjacentPairs = [[100000,-100000]]\nOutput: [100000,-100000]"
        ],
        "constraints": "nums.length == n\nadjacentPairs.length == n - 1\nadjacentPairs[i].length == 2\n2 <= n <= 105\n-105 <= nums[i], ui, vi <= 105\nThere exists some nums that has adjacentPairs as its pairs.",
        "oracle_code": "class Solution:\n    def restoreArray(self, adjacentPairs: List[List[int]]) -> List[int]:\n        graph = {}\n        for u, v in adjacentPairs: \n            graph.setdefault(u, []).append(v)\n            graph.setdefault(v, []).append(u)\n        \n        ans = []\n        seen = set()\n        stack = [next(x for x in graph if len(graph[x]) == 1)]\n        while stack: \n            n = stack.pop()\n            ans.append(n)\n            seen.add(n)\n            for nn in graph[n]: \n                if nn not in seen: stack.append(nn)\n        return ans",
        "content": "**Algo**\\nThe structure here is a doubly-linked list. But we can treat it as a graph. Create an adjacency list representation from `adjacentPairs`. Starting from a edge node (with 1 neighbor), traverse the graph to collect values in an array. \\n\\n**Implementation**\\n```\\nclass Solution:\\n    def restoreArray(self, adjacentPairs: List[List[int]]) -> List[int]:\\n        graph = {}\\n        for u, v in adjacentPairs: \\n            graph.setdefault(u, []).append(v)\\n            graph.setdefault(v, []).append(u)\\n        \\n        ans = []\\n        seen = set()\\n        stack = [next(x for x in graph if len(graph[x]) == 1)]\\n        while stack: \\n            n = stack.pop()\\n            ans.append(n)\\n            seen.add(n)\\n            for nn in graph[n]: \\n                if nn not in seen: stack.append(nn)\\n        return ans \\n```\\n\\n**Analysis**\\nTime complexity `O(N)`\\nSpace complexity `O(N)`",
        "level": "medium",
        "type": [
            "colon missing",
            "operation error",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n    def restoreArray(self, adjacentPairs: List[List[int]]) -> List[int]:\n        graph = {}\n        for u, v in adjacentPairs: \n            graph.setdefault(u, []).append(v)\n            graph.setdefault(v, []).append(u)\n        \n        ans = []\n        seen = set()\n        stack = [next(x for x in graph if len(graph[x]) == 1)]\n        while stack \n            n = stack.pop()\n            ans.append(n)\n            seen.add(n)\n            for nn in graph[n]: \n                if nn not in seen: stack.append(nn = \n        return ans\n"
    },
    {
        "slug": "find-closest-node-to-given-two-nodes",
        "description": "You are given a directed graph of n nodes numbered from 0 to n - 1, where each node has at most one outgoing edge.\nThe graph is represented with a given 0-indexed array edges of size n, indicating that there is a directed edge from node i to node edges[i]. If there is no outgoing edge from i, then edges[i] == -1.\nYou are also given two integers node1 and node2.\nReturn the index of the node that can be reached from both node1 and node2, such that the maximum between the distance from node1 to that node, and from node2 to that node is minimized. If there are multiple answers, return the node with the smallest index, and if no possible answer exists, return -1.\nNote that edges may contain cycles.",
        "examples": [
            "Input: edges = [2,2,3,-1], node1 = 0, node2 = 1\nOutput: 2\nExplanation: The distance from node 0 to node 2 is 1, and the distance from node 1 to node 2 is 1.\nThe maximum of those two distances is 1. It can be proven that we cannot get a node with a smaller maximum distance than 1, so we return node 2.",
            "Input: edges = [1,2,-1], node1 = 0, node2 = 2\nOutput: 2\nExplanation: The distance from node 0 to node 2 is 2, and the distance from node 2 to itself is 0.\nThe maximum of those two distances is 2. It can be proven that we cannot get a node with a smaller maximum distance than 2, so we return node 2."
        ],
        "constraints": "n == edges.length\n2 <= n <= 105\n-1 <= edges[i] < n\nedges[i] != i\n0 <= node1, node2 < n",
        "oracle_code": "class Solution:\n    def cdist(self, it, distArray, distArrayIndex, edges):\n        rdist = 0 \n        nodes = []\n        while it != -1 and distArray[it][distArrayIndex] > rdist:\n            distArray[it][distArrayIndex] = rdist\n            nodes.append(it)\n            it = edges[it]\n            rdist += 1\n        return nodes\n            \n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\n        INF = float('inf')\n        dist = defaultdict(lambda: [INF,INF])\n        mmin, ans = INF, INF\n               \n        n = self.cdist(node1, dist, 0, edges)\n        n += self.cdist(node2, dist, 1, edges)\n                \n        for k in n:\n            m = max(dist[k])\n            if m != INF:\n                if m < mmin: \n                    mmin = m\n                    ans = k\n                elif m == mmin: \n                    ans = min(ans, k)\n                    \n        return ans if ans != float('inf') else -1",
        "content": "Since there is atmost one outgoing edge with cycles, we can iterate this graph in simple manner as cdist function below. The logic briefly is as below. \\n1. Calculate distances between node1 and other reachable nodes. \\n2. Do the same as (1) for node 2\\n3. Iterate the nodes that are on the path for both distances and find max. \\n4. find min of maxes and keep track of minimum index. \\n\\nIf there was a constraint that node1 and node2 have a guarenteed path between them, the problem could have been simpler, to construct find the shortestPath between node1 -> node 2 and the ans is one of the nodes in between. Thats not the case ! \\n\\n```\\nclass Solution:\\n    def cdist(self, it, distArray, distArrayIndex, edges):\\n        rdist = 0 \\n        nodes = []\\n        while it != -1 and distArray[it][distArrayIndex] > rdist:\\n            distArray[it][distArrayIndex] = rdist\\n            nodes.append(it)\\n            it = edges[it]\\n            rdist += 1\\n        return nodes\\n            \\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        INF = float(\\'inf\\')\\n        dist = defaultdict(lambda: [INF,INF])\\n        mmin, ans = INF, INF\\n               \\n        n = self.cdist(node1, dist, 0, edges)\\n        n += self.cdist(node2, dist, 1, edges)\\n                \\n        for k in n:\\n            m = max(dist[k])\\n            if m != INF:\\n                if m < mmin: \\n                    mmin = m\\n                    ans = k\\n                elif m == mmin: \\n                    ans = min(ans, k)\\n                    \\n        return ans if ans != float(\\'inf\\') else -1\\n```\\n\\nA slightly modified logic, \\n\\n```\\nclass Solution:\\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        INF = float(\\'inf\\')\\n        N = len(edges)\\n        dist_node1 = [INF for _ in range(N)]\\n        dist_node2 = [INF for _ in range(N)]\\n        \\n        def dfs(node, di, d):\\n            if d[node] > di: \\n                d[node] = di\\n                if edges[node] != -1:\\n                    dfs(edges[node], di+1, d)\\n        \\n        dfs(node1, 0, dist_node1)\\n        dfs(node2, 0, dist_node2)\\n\\n        for i in range(N):\\n            dist_node1[i] = max(dist_node1[i], dist_node2[i])\\n                        \\n        ans = dist_node1.index(min(dist_node1))\\n        return ans if dist_node1[ans] != INF else -1\\n",
        "level": "medium",
        "type": [
            "indentation error",
            "parentheses mismatch",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def cdist(self, it, distArray, distArrayIndex, edges:\n    rdist = 0 \n    nodes = []\n    while it != -1 and distArray[it+1][distArrayIndex] > rdist:\n        distArray[it][distArrayIndex] = rdist\n        nodes.append(it)\n        it = edges[it]\n        rdist += 1\n    return nodes\n            \n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\n        INF = float('inf')\n        dist = defaultdict(lambda: [INF,INF])\n        mmin, ans = INF, INF\n               \n        n = self.cdist(node1, dist, 0, edges)\n        n += self.cdist(node2, dist, 1, edges)\n                \n        for k in n:\n            m = max(dist[k])\n            if m != INF:\n                if m < mmin: \n                    mmin = m\n                    ans = k\n                elif m == mmin: \n                    ans = min(ans, k)\n                    \n        return ans if ans != float('inf') else -1\n"
    },
    {
        "slug": "find-closest-node-to-given-two-nodes",
        "description": "You are given a directed graph of n nodes numbered from 0 to n - 1, where each node has at most one outgoing edge.\nThe graph is represented with a given 0-indexed array edges of size n, indicating that there is a directed edge from node i to node edges[i]. If there is no outgoing edge from i, then edges[i] == -1.\nYou are also given two integers node1 and node2.\nReturn the index of the node that can be reached from both node1 and node2, such that the maximum between the distance from node1 to that node, and from node2 to that node is minimized. If there are multiple answers, return the node with the smallest index, and if no possible answer exists, return -1.\nNote that edges may contain cycles.",
        "examples": [
            "Input: edges = [2,2,3,-1], node1 = 0, node2 = 1\nOutput: 2\nExplanation: The distance from node 0 to node 2 is 1, and the distance from node 1 to node 2 is 1.\nThe maximum of those two distances is 1. It can be proven that we cannot get a node with a smaller maximum distance than 1, so we return node 2.",
            "Input: edges = [1,2,-1], node1 = 0, node2 = 2\nOutput: 2\nExplanation: The distance from node 0 to node 2 is 2, and the distance from node 2 to itself is 0.\nThe maximum of those two distances is 2. It can be proven that we cannot get a node with a smaller maximum distance than 2, so we return node 2."
        ],
        "constraints": "n == edges.length\n2 <= n <= 105\n-1 <= edges[i] < n\nedges[i] != i\n0 <= node1, node2 < n",
        "oracle_code": "class Solution:\n    def cdist(self, it, distArray, distArrayIndex, edges):\n        rdist = 0 \n        nodes = []\n        while it != -1 and distArray[it][distArrayIndex] > rdist:\n            distArray[it][distArrayIndex] = rdist\n            nodes.append(it)\n            it = edges[it]\n            rdist += 1\n        return nodes\n            \n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\n        INF = float('inf')\n        dist = defaultdict(lambda: [INF,INF])\n        mmin, ans = INF, INF\n               \n        n = self.cdist(node1, dist, 0, edges)\n        n += self.cdist(node2, dist, 1, edges)\n                \n        for k in n:\n            m = max(dist[k])\n            if m != INF:\n                if m < mmin: \n                    mmin = m\n                    ans = k\n                elif m == mmin: \n                    ans = min(ans, k)\n                    \n        return ans if ans != float('inf') else -1",
        "content": "Since there is atmost one outgoing edge with cycles, we can iterate this graph in simple manner as cdist function below. The logic briefly is as below. \\n1. Calculate distances between node1 and other reachable nodes. \\n2. Do the same as (1) for node 2\\n3. Iterate the nodes that are on the path for both distances and find max. \\n4. find min of maxes and keep track of minimum index. \\n\\nIf there was a constraint that node1 and node2 have a guarenteed path between them, the problem could have been simpler, to construct find the shortestPath between node1 -> node 2 and the ans is one of the nodes in between. Thats not the case ! \\n\\n```\\nclass Solution:\\n    def cdist(self, it, distArray, distArrayIndex, edges):\\n        rdist = 0 \\n        nodes = []\\n        while it != -1 and distArray[it][distArrayIndex] > rdist:\\n            distArray[it][distArrayIndex] = rdist\\n            nodes.append(it)\\n            it = edges[it]\\n            rdist += 1\\n        return nodes\\n            \\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        INF = float(\\'inf\\')\\n        dist = defaultdict(lambda: [INF,INF])\\n        mmin, ans = INF, INF\\n               \\n        n = self.cdist(node1, dist, 0, edges)\\n        n += self.cdist(node2, dist, 1, edges)\\n                \\n        for k in n:\\n            m = max(dist[k])\\n            if m != INF:\\n                if m < mmin: \\n                    mmin = m\\n                    ans = k\\n                elif m == mmin: \\n                    ans = min(ans, k)\\n                    \\n        return ans if ans != float(\\'inf\\') else -1\\n```\\n\\nA slightly modified logic, \\n\\n```\\nclass Solution:\\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        INF = float(\\'inf\\')\\n        N = len(edges)\\n        dist_node1 = [INF for _ in range(N)]\\n        dist_node2 = [INF for _ in range(N)]\\n        \\n        def dfs(node, di, d):\\n            if d[node] > di: \\n                d[node] = di\\n                if edges[node] != -1:\\n                    dfs(edges[node], di+1, d)\\n        \\n        dfs(node1, 0, dist_node1)\\n        dfs(node2, 0, dist_node2)\\n\\n        for i in range(N):\\n            dist_node1[i] = max(dist_node1[i], dist_node2[i])\\n                        \\n        ans = dist_node1.index(min(dist_node1))\\n        return ans if dist_node1[ans] != INF else -1\\n",
        "level": "medium",
        "type": [
            "parentheses mismatch",
            "undefined keywords from other languages",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution:\n    def cdist(self, it, distArray, distArrayIndex, edges:\n        rdist = 0 \n        nodes = []\n        while it != -1 and distArray[it][distArrayIndex] > rdist:\n            distArray[it][distArrayIndex] = rdist\n            nodes.append(it)\n            it = edges[it]\n            rdist += 1\n        return nodes\n            \n    def closestMeetingNode(self, edges: List<int>, node1: int, node2: int) -> int:\n        INF = float('inf')\n        dist = defaultdict(lambda: [INF,INF])\n        mmin, ans = INF, INF\n               \n        n = self.cdist(node1, dist, 0, edges)\n        n += var self.cdist(node2, dist, 1, edges)\n                \n        for k in n:\n            m = max(dist[k])\n            if m != INF:\n                if m < mmin: \n                    mmin = m\n                    ans = k\n                elif m == mmin: \n                    ans = min(ans, k)\n                    \n        return ans if ans != 'inf' else -1\n"
    },
    {
        "slug": "lexicographically-smallest-palindrome",
        "description": "You are given a string s consisting of lowercase English letters, and you are allowed to perform operations on it. In one operation, you can replace a character in s with another lowercase English letter.\nYour task is to make s a palindrome with the minimum number of operations possible. If there are multiple palindromes that can be made using the minimum number of operations, make the lexicographically smallest one.\nA string a is lexicographically smaller than a string b (of the same length) if in the first position where a and b differ, string a has a letter that appears earlier in the alphabet than the corresponding letter in b.\nReturn the resulting palindrome string.",
        "examples": [
            "Input: s = \"egcfe\"\nOutput: \"efcfe\"\nExplanation: The minimum number of operations to make \"egcfe\" a palindrome is 1, and the lexicographically smallest palindrome string we can get by modifying one character is \"efcfe\", by changing 'g'.",
            "Input: s = \"abcd\"\nOutput: \"abba\"\nExplanation: The minimum number of operations to make \"abcd\" a palindrome is 2, and the lexicographically smallest palindrome string we can get by modifying two characters is \"abba\".",
            "Input: s = \"seven\"\nOutput: \"neven\"\nExplanation: The minimum number of operations to make \"seven\" a palindrome is 1, and the lexicographically smallest palindrome string we can get by modifying one character is \"neven\"."
        ],
        "constraints": "1 <= s.length <= 1000\ns\u00a0consists of only lowercase English letters.",
        "oracle_code": "class Solution:\n    def makeSmallestPalindrome(self, s: str) -> str:\n        before = 0\n        after = len(s)-1\n        l = [i for i in s]\n        while before <= len(s)/2:\n            l[before] = min(l[before], l[after])\n            l[after] = l[before]\n            before+=1\n            after-=1\n        return \"\".join(l)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: 214 ms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 16.5 MB\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def makeSmallestPalindrome(self, s: str) -> str:\\n        before = 0\\n        after = len(s)-1\\n        l = [i for i in s]\\n        while before <= len(s)/2:\\n            l[before] = min(l[before], l[after])\\n            l[after] = l[before]\\n            before+=1\\n            after-=1\\n        return \"\".join(l)\\n```",
        "level": "easy",
        "type": [
            "undefined methods",
            "indexing error",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def makeSmallestPalindrome(self, s: str) -> str:\n        before = 0\n        after = len(s)-1\n        l = [i for i in s]\n        while before <= len(s):\n            l[before] = self.min(l[before], l[after])\n            l[after] = l[before]\n            before+=1\n            after+=1\n        return \"\".join(l)\n"
    },
    {
        "slug": "find-all-possible-recipes-from-given-supplies",
        "description": "You have information about n different recipes. You are given a string array recipes and a 2D string array ingredients. The ith recipe has the name recipes[i], and you can create it if you have all the needed ingredients from ingredients[i]. Ingredients to a recipe may need to be created from other recipes, i.e., ingredients[i] may contain a string that is in recipes.\nYou are also given a string array supplies containing all the ingredients that you initially have, and you have an infinite supply of all of them.\nReturn a list of all the recipes that you can create. You may return the answer in any order.\nNote that two recipes may contain each other in their ingredients.",
        "examples": [
            "Input: recipes = [\"bread\"], ingredients = [[\"yeast\",\"flour\"]], supplies = [\"yeast\",\"flour\",\"corn\"]\nOutput: [\"bread\"]\nExplanation:\nWe can create \"bread\" since we have the ingredients \"yeast\" and \"flour\".",
            "Input: recipes = [\"bread\",\"sandwich\"], ingredients = [[\"yeast\",\"flour\"],[\"bread\",\"meat\"]], supplies = [\"yeast\",\"flour\",\"meat\"]\nOutput: [\"bread\",\"sandwich\"]\nExplanation:\nWe can create \"bread\" since we have the ingredients \"yeast\" and \"flour\".\nWe can create \"sandwich\" since we have the ingredient \"meat\" and can create the ingredient \"bread\".",
            "Input: recipes = [\"bread\",\"sandwich\",\"burger\"], ingredients = [[\"yeast\",\"flour\"],[\"bread\",\"meat\"],[\"sandwich\",\"meat\",\"bread\"]], supplies = [\"yeast\",\"flour\",\"meat\"]\nOutput: [\"bread\",\"sandwich\",\"burger\"]\nExplanation:\nWe can create \"bread\" since we have the ingredients \"yeast\" and \"flour\".\nWe can create \"sandwich\" since we have the ingredient \"meat\" and can create the ingredient \"bread\".\nWe can create \"burger\" since we have the ingredient \"meat\" and can create the ingredients \"bread\" and \"sandwich\"."
        ],
        "constraints": "n == recipes.length == ingredients.length\n1 <= n <= 100\n1 <= ingredients[i].length, supplies.length <= 100\n1 <= recipes[i].length, ingredients[i][j].length, supplies[k].length <= 10\nrecipes[i], ingredients[i][j], and supplies[k] consist only of lowercase English letters.\nAll the values of recipes and supplies\u00a0combined are unique.\nEach ingredients[i] does not contain any duplicate values.",
        "oracle_code": "class Solution:\n    def findAllRecipes(self, recepies: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\n        dct=defaultdict(lambda :[])\n        indegree={}\n        n=len(recepies)\n\n        for i in recepies:\n            indegree[i]=0\n\n        for i in range(n):\n            for j in ingredients[i]:\n                indegree[j]=0\n\n        for i in range(n):\n            for j in ingredients[i]:\n                dct[j].append(recepies[i])\n                indegree[recepies[i]]+=1\n\n        st=[]\n        for i in indegree:\n            if indegree[i]==0:\n                st.append(i)\n        flst=[]\n        ans=defaultdict(lambda :[])\n        while st:\n            x=st.pop(0)\n            for i in dct[x]:\n                # if ans[x]!=[]:\n                for j in ans[x]:\n                    if j not in ans[i]:\n                        ans[i].append(j)\n                ans[i].append(x)\n                indegree[i]-=1\n                if indegree[i]==0:\n                    st.append(i)\n            if x in recepies:\n                for k in ans[x]:\n                    if k not in supplies:\n                        break\n                else:\n                    flst.append(x)\n                    supplies.append(x)\n\n        return flst",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findAllRecipes(self, recepies: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n        dct=defaultdict(lambda :[])\\n        indegree={}\\n        n=len(recepies)\\n\\n        for i in recepies:\\n            indegree[i]=0\\n\\n        for i in range(n):\\n            for j in ingredients[i]:\\n                indegree[j]=0\\n\\n        for i in range(n):\\n            for j in ingredients[i]:\\n                dct[j].append(recepies[i])\\n                indegree[recepies[i]]+=1\\n\\n        st=[]\\n        for i in indegree:\\n            if indegree[i]==0:\\n                st.append(i)\\n        flst=[]\\n        ans=defaultdict(lambda :[])\\n        while st:\\n            x=st.pop(0)\\n            for i in dct[x]:\\n                # if ans[x]!=[]:\\n                for j in ans[x]:\\n                    if j not in ans[i]:\\n                        ans[i].append(j)\\n                ans[i].append(x)\\n                indegree[i]-=1\\n                if indegree[i]==0:\\n                    st.append(i)\\n            if x in recepies:\\n                for k in ans[x]:\\n                    if k not in supplies:\\n                        break\\n                else:\\n                    flst.append(x)\\n                    supplies.append(x)\\n\\n        return flst\\n```",
        "level": "medium",
        "type": [
            "indentation error",
            "operation error",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\ndef findAllRecipes(self, recepies: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\n    dct=defaultdict(lambda :[])\n    indegree={}\n    n=len(recepies)\n\n    for i in recepies:\n        indegree[i]=0\n\n    for i in range(n+1):   \n        for j in ingredients[i]:\n            indegree[j]=0\n\n    for i in range(n):\n        for j in ingredients[i]:\n            dct[j].append(recepies[i])\n            indegree[recepies[i]]+=1\n\n    st=[]\n    for i in indegree:\n        if indegree[i]==0:\n            st.append(i)\n    flst=[]\n    ans=defaultdict(lambda :[])\n    while st:\n        x=st.pop(0)\n        for i in dct[x]:\n            \n            for j in ans[x]:\n                if j not in ans[i]:\n                    ans[i].append(j)\n            ans[i].append(x)\n            indegree[i]-=1\n            if indegree[i]==0:\n                st.append(i)\n        if x in recepies:\n            for k in ans[x]:\n                if k not in supplies:\n                    break\n            else:\n                flst.append(x)\n                supplies.append(x)\n\n    return iflst\n"
    },
    {
        "slug": "baseball-game",
        "description": "You are keeping the scores for a baseball game with strange rules. At the beginning of the game, you start with an empty record.\nYou are given a list of strings operations, where operations[i] is the ith operation you must apply to the record and is one of the following:\n\nAn integer x.\n\n\t\nRecord a new score of x.\n\n\n'+'.\n\t\nRecord a new score that is the sum of the previous two scores.\n\n\n'D'.\n\t\nRecord a new score that is the double of the previous score.\n\n\n'C'.\n\t\nInvalidate the previous score, removing it from the record.\n\n\n\nReturn the sum of all the scores on the record after applying all the operations.\nThe test cases are generated such that the answer and all intermediate calculations fit in a 32-bit integer and that all operations are valid.",
        "examples": [
            "Input: ops = [\"5\",\"2\",\"C\",\"D\",\"+\"]\nOutput: 30\nExplanation:\n\"5\" - Add 5 to the record, record is now [5].\n\"2\" - Add 2 to the record, record is now [5, 2].\n\"C\" - Invalidate and remove the previous score, record is now [5].\n\"D\" - Add 2 * 5 = 10 to the record, record is now [5, 10].\n\"+\" - Add 5 + 10 = 15 to the record, record is now [5, 10, 15].\nThe total sum is 5 + 10 + 15 = 30.",
            "Input: ops = [\"5\",\"-2\",\"4\",\"C\",\"D\",\"9\",\"+\",\"+\"]\nOutput: 27\nExplanation:\n\"5\" - Add 5 to the record, record is now [5].\n\"-2\" - Add -2 to the record, record is now [5, -2].\n\"4\" - Add 4 to the record, record is now [5, -2, 4].\n\"C\" - Invalidate and remove the previous score, record is now [5, -2].\n\"D\" - Add 2 * -2 = -4 to the record, record is now [5, -2, -4].\n\"9\" - Add 9 to the record, record is now [5, -2, -4, 9].\n\"+\" - Add -4 + 9 = 5 to the record, record is now [5, -2, -4, 9, 5].\n\"+\" - Add 9 + 5 = 14 to the record, record is now [5, -2, -4, 9, 5, 14].\nThe total sum is 5 + -2 + -4 + 9 + 5 + 14 = 27.",
            "Input: ops = [\"1\",\"C\"]\nOutput: 0\nExplanation:\n\"1\" - Add 1 to the record, record is now [1].\n\"C\" - Invalidate and remove the previous score, record is now [].\nSince the record is empty, the total sum is 0."
        ],
        "constraints": "1 <= operations.length <= 1000\noperations[i] is \"C\", \"D\", \"+\", or a string representing an integer in the range [-3 * 104, 3 * 104].\nFor operation \"+\", there will always be at least two previous scores on the record.\nFor operations \"C\" and \"D\", there will always be at least one previous score on the record.",
        "oracle_code": "class Solution:\n    def calPoints(self, operations: List[str]) -> int:\n        stack=[]\n        for i in operations:\n            if i =='D':\n                stack.append(2*stack[-1])\n            elif i=='C':\n                stack.pop()\n            elif i=='+':\n                stack.append(stack[-1]+stack[-2])\n            else:\n                stack.append(int(i))\n        return sum(stack)",
        "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def calPoints(self, operations: List[str]) -> int:\\n        stack=[]\\n        for i in operations:\\n            if i ==\\'D\\':\\n                stack.append(2*stack[-1])\\n            elif i==\\'C\\':\\n                stack.pop()\\n            elif i==\\'+\\':\\n                stack.append(stack[-1]+stack[-2])\\n            else:\\n                stack.append(int(i))\\n        return sum(stack)\\n```",
        "level": "easy",
        "type": [
            "operation error",
            "undefined keywords from other languages",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution:\n    def calPoints(self, operations: List[str]) -> int:\n        stack=[]\n        for i in operations:\n            if i =='D':\n                stack.append(2*math.notify(stack[-1]))\n            elif i=='C\":\n                stack.pop()\n            elif i=='+':\n                stack.append(stack[-1]+stack[-2])\n            else:\n                stack.append(int(\"i))\n        return sum(stack[0])\n"
    },
    {
        "slug": "kth-largest-element-in-an-array",
        "description": "Given an integer array nums and an integer k, return the kth largest element in the array.\nNote that it is the kth largest element in the sorted order, not the kth distinct element.\nCan you solve it without sorting?",
        "examples": [
            "Input: nums = [3,2,1,5,6,4], k = 2\nOutput: 5",
            "Input: nums = [3,2,3,1,2,4,5,5,6], k = 4\nOutput: 4"
        ],
        "constraints": "1 <= k <= nums.length <= 105\n-104 <= nums[i] <= 104",
        "oracle_code": "class Solution:\n    def findKthLargest(self, nums: List[int], k: int) -> int:\n        return sorted(nums)[-k]",
        "content": "# Approach\\n- Sorting\\n\\n# Complexity\\n- Time complexity: O(n*log(n))\\n\\n# Code\\n```\\nclass Solution:\\n    def findKthLargest(self, nums: List[int], k: int) -> int:\\n        return sorted(nums)[-k]\\n```",
        "level": "medium",
        "type": [
            "undefined objects",
            "parentheses mismatch",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def findKthLargest(self, nums: List[int], k: int -> int:\n        return sorted(no_nums)[-k-1]\n"
    },
    {
        "slug": "grid-game",
        "description": "You are given a 0-indexed 2D array grid of size 2 x n, where grid[r][c] represents the number of points at position (r, c) on the matrix. Two robots are playing a game on this matrix.\nBoth robots initially start at (0, 0) and want to reach (1, n-1). Each robot may only move to the right ((r, c) to (r, c + 1)) or down ((r, c) to (r + 1, c)).\nAt the start of the game, the first robot moves from (0, 0) to (1, n-1), collecting all the points from the cells on its path. For all cells (r, c) traversed on the path, grid[r][c] is set to 0. Then, the second robot moves from (0, 0) to (1, n-1), collecting the points on its path. Note that their paths may intersect with one another.\nThe first robot wants to minimize the number of points collected by the second robot. In contrast, the second robot wants to maximize the number of points it collects. If both robots play optimally, return the number of points collected by the second robot.",
        "examples": [
            "Input: grid = [[2,5,4],[1,5,1]]\nOutput: 4\nExplanation: The optimal path taken by the first robot is shown in red, and the optimal path taken by the second robot is shown in blue.\nThe cells visited by the first robot are set to 0.\nThe second robot will collect 0 + 0 + 4 + 0 = 4 points.",
            "Input: grid = [[3,3,1],[8,5,2]]\nOutput: 4\nExplanation: The optimal path taken by the first robot is shown in red, and the optimal path taken by the second robot is shown in blue.\nThe cells visited by the first robot are set to 0.\nThe second robot will collect 0 + 3 + 1 + 0 = 4 points.",
            "Input: grid = [[1,3,1,15],[1,3,3,1]]\nOutput: 7\nExplanation: The optimal path taken by the first robot is shown in red, and the optimal path taken by the second robot is shown in blue.\nThe cells visited by the first robot are set to 0.\nThe second robot will collect 0 + 1 + 3 + 3 + 0 = 7 points."
        ],
        "constraints": "grid.length == 2\nn == grid[r].length\n1 <= n <= 5 * 104\n1 <= grid[r][c] <= 105",
        "oracle_code": "class Solution:\n    def gridGame(self, grid: List[List[int]]) -> int: \n        result = float(\"inf\")\n        left,right = 0,sum(grid[0])\n\n        for a,b in zip(grid[0],grid[1]):\n            right-=a\n\n            result = min(result,max(left,right))\n            left+=b\n        \n        return result\n\n# time & space - O(n),O(1)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def gridGame(self, grid: List[List[int]]) -> int: \\n        result = float(\"inf\")\\n        left,right = 0,sum(grid[0])\\n\\n        for a,b in zip(grid[0],grid[1]):\\n            right-=a\\n\\n            result = min(result,max(left,right))\\n            left+=b\\n        \\n        return result\\n\\n# time & space - O(n),O(1)\\n\\n\\n```",
        "level": "medium",
        "type": [
            "colon missing",
            "unclosed string",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def gridGame(self, grid: List[List[int]]) -> int \n        result = float(\"inf\")\n        left,right = 0,sum(grid[0])\n\n        for a,b in zip(grid[0],grid[1]):\n            right-=a\n\n            result = min(result,max(left,right))\n            left+=b1],grid[\n        \n        return result\n"
    },
    {
        "slug": "valid-arrangement-of-pairs",
        "description": "You are given a 0-indexed 2D integer array pairs where pairs[i] = [starti, endi]. An arrangement of pairs is valid if for every index i where 1 <= i < pairs.length, we have endi-1 == starti.\nReturn any valid arrangement of pairs.\nNote: The inputs will be generated such that there exists a valid arrangement of pairs.",
        "examples": [
            "Input: pairs = [[5,1],[4,5],[11,9],[9,4]]\nOutput: [[11,9],[9,4],[4,5],[5,1]]\nExplanation:\nThis is a valid arrangement since endi-1 always equals starti.\nend0 = 9 == 9 = start1 \nend1 = 4 == 4 = start2\nend2 = 5 == 5 = start3",
            "Input: pairs = [[1,3],[3,2],[2,1]]\nOutput: [[1,3],[3,2],[2,1]]\nExplanation:\nThis is a valid arrangement since endi-1 always equals starti.\nend0 = 3 == 3 = start1\nend1 = 2 == 2 = start2\nThe arrangements [[2,1],[1,3],[3,2]] and [[3,2],[2,1],[1,3]] are also valid.",
            "Input: pairs = [[1,2],[1,3],[2,1]]\nOutput: [[1,2],[2,1],[1,3]]\nExplanation:\nThis is a valid arrangement since endi-1 always equals starti.\nend0 = 2 == 2 = start1\nend1 = 1 == 1 = start2"
        ],
        "constraints": "1 <= pairs.length <= 105\npairs[i].length == 2\n0 <= starti, endi <= 109\nstarti != endi\nNo two pairs are exactly the same.\nThere exists a valid arrangement of pairs.",
        "oracle_code": "class Solution:\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\n        graph = defaultdict(list)\n        degree = defaultdict(int) # net out degree \n        for x, y in pairs: \n            graph[x].append(y)\n            degree[x] += 1\n            degree[y] -= 1\n                \n        for k in degree: \n            if degree[k] == 1: \n                x = k\n                break \n                \n        ans = []\n\n        def fn(x): \n            \"\"\"Return Eulerian path via dfs.\"\"\"\n            while graph[x]: fn(graph[x].pop()) \n            ans.append(x)\n        \n        fn(x)\n        ans.reverse()\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]",
        "content": "Please check out this [commit](https://github.com/gaosanyong/leetcode/commit/b1948f8814bebeca475cbb354cd44d19092dff59) for solutions of weekly 270.\\n\\n```\\nclass Solution:\\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\\n        graph = defaultdict(list)\\n        degree = defaultdict(int) # net out degree \\n        for x, y in pairs: \\n            graph[x].append(y)\\n            degree[x] += 1\\n            degree[y] -= 1\\n                \\n        for k in degree: \\n            if degree[k] == 1: \\n                x = k\\n                break \\n                \\n        ans = []\\n\\n        def fn(x): \\n            \"\"\"Return Eulerian path via dfs.\"\"\"\\n            while graph[x]: fn(graph[x].pop()) \\n            ans.append(x)\\n        \\n        fn(x)\\n        ans.reverse()\\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]\\n```\\n\\nAdding an iterative implementation of Hieholzer\\'s algo from @delphih\\n```\\nclass Solution:\\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\\n        graph = defaultdict(list)\\n        degree = defaultdict(int) # net out degree \\n        for x, y in pairs: \\n            graph[x].append(y)\\n            degree[x] += 1\\n            degree[y] -= 1\\n                \\n        for k in degree: \\n            if degree[k] == 1: \\n                x = k\\n                break \\n                \\n        ans = []\\n        stack = [x]\\n        while stack: \\n            while graph[stack[-1]]: \\n                stack.append(graph[stack[-1]].pop())\\n            ans.append(stack.pop())\\n        ans.reverse()\\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]\\n```",
        "level": "hard",
        "type": [
            "undefined methods",
            "parentheses mismatch",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\n        graph = defaultdict(list)\n        degree = defaultdict(int) # net out degree \n        for x, y in pairs: \n            graph[x].append(y)\n            degree[x] += 1\n            degree[y] -= 1\n                \n        for k in degree: \n            if degree[k] != 1: \n                x = k\n                break \n                \n        ans = []\n\n        def fn(x): \n            \"\"\"Return Eulerian path via dfs.\"\"\"\n            while graph[x]: fn(graph[x].pop()) \n            ans.append(x)\n        \n        dfn(s\n        ans.reverse()\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]\n"
    },
    {
        "slug": "minimum-index-sum-of-two-lists",
        "description": "Given two arrays of strings list1 and list2, find the common strings with the least index sum.\nA common string is a string that appeared in both list1 and list2.\nA common string with the least index sum is a common string such that if it appeared at list1[i] and list2[j] then i + j should be the minimum value among all the other common strings.\nReturn all the common strings with the least index sum. Return the answer in any order.",
        "examples": [
            "Input: list1 = [\"Shogun\",\"Tapioca Express\",\"Burger King\",\"KFC\"], list2 = [\"Piatti\",\"The Grill at Torrey Pines\",\"Hungry Hunter Steakhouse\",\"Shogun\"]\nOutput: [\"Shogun\"]\nExplanation: The only common string is \"Shogun\".",
            "Input: list1 = [\"Shogun\",\"Tapioca Express\",\"Burger King\",\"KFC\"], list2 = [\"KFC\",\"Shogun\",\"Burger King\"]\nOutput: [\"Shogun\"]\nExplanation: The common string with the least index sum is \"Shogun\" with index sum = (0 + 1) = 1.",
            "Input: list1 = [\"happy\",\"sad\",\"good\"], list2 = [\"sad\",\"happy\",\"good\"]\nOutput: [\"sad\",\"happy\"]\nExplanation: There are three common strings:\n\"happy\" with index sum = (0 + 1) = 1.\n\"sad\" with index sum = (1 + 0) = 1.\n\"good\" with index sum = (2 + 2) = 4.\nThe strings with the least index sum are \"sad\" and \"happy\"."
        ],
        "constraints": "1 <= list1.length, list2.length <= 1000\n1 <= list1[i].length, list2[i].length <= 30\nlist1[i] and list2[i] consist of spaces ' ' and English letters.\nAll the strings of list1 are unique.\nAll the strings of list2 are unique.\nThere is at least a common string between list1 and list2.",
        "oracle_code": "class Solution:\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\n        d2={}\n        l=[]\n        for i in range(len(list2)):\n            d2[list2[i]]=i\n        for i in range(len(list1)):\n            if list1[i] in d2:\n                l.append([i+d2[list1[i]],list1[i]])\n        l1=[]\n        l.sort()\n        l1.append(l[0][1])\n        for i in range(1,len(l)):\n            if l[i][0]==l[i-1][0]:\n                l1.append(l[i][1])\n            else:\n                break\n        return l1",
        "content": "# Intuition\\nbeats 99.9%\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nBrute force\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n      n(log n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\\n        d2={}\\n        l=[]\\n        for i in range(len(list2)):\\n            d2[list2[i]]=i\\n        for i in range(len(list1)):\\n            if list1[i] in d2:\\n                l.append([i+d2[list1[i]],list1[i]])\\n        l1=[]\\n        l.sort()\\n        l1.append(l[0][1])\\n        for i in range(1,len(l)):\\n            if l[i][0]==l[i-1][0]:\\n                l1.append(l[i][1])\\n            else:\\n                break\\n        return l1\\n        \\n```",
        "level": "easy",
        "type": [
            "indentation error",
            "variable value error",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution:\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\n        d2={}\n        l=[]\n        for i in range(len(list2)):\n            d2[list2[i]]=i\n          for i in range(len(list1)):\n            if list1[i] in d2:\n                l.append([var i+d2[list1[i]],list1[i]])   \n        l1=[]\n        l.sort()\n        l1.append(l[1][1]) \n        for i in range(1,len(l)):\n            if l[i][0]==l[i-1][0]:\n                l1.append(l[i][1])\n            else:\n                break\n        return l1\n"
    },
    {
        "slug": "number-complement",
        "description": "The complement of an integer is the integer you get when you flip all the 0's to 1's and all the 1's to 0's in its binary representation.\n\nFor example, The integer 5 is \"101\" in binary and its complement is \"010\" which is the integer 2.\n\nGiven an integer num, return its complement.",
        "examples": [
            "Input: num = 5\nOutput: 2\nExplanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2.",
            "Input: num = 1\nOutput: 0\nExplanation: The binary representation of 1 is 1 (no leading zero bits), and its complement is 0. So you need to output 0."
        ],
        "constraints": "1 <= num < 231\n\n\u00a0\nNote: This question is the same as 1009: https://leetcode.com/problems/complement-of-base-10-integer/",
        "oracle_code": "class Solution:\n    def findComplement(self, num: int) -> int:\n        com = ''\n        while num > 0 :\n            \n            if num % 2 == 1:\n                com += '0'\n            else:\n                com += '1'\n            num = num // 2\n        return int(com[::-1],2)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findComplement(self, num: int) -> int:\\n        com = \\'\\'\\n        while num > 0 :\\n            \\n            if num % 2 == 1:\\n                com += \\'0\\'\\n            else:\\n                com += \\'1\\'\\n            num = num // 2\\n        return int(com[::-1],2)\\n        \\n\\n```",
        "level": "easy",
        "type": [
            "indentation error",
            "undefined keywords from other languages",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def findComplement(self, num: int) -> int:\n        com = ''\n        while num > 0 :\n            \n            if num % 2 == 1:\n           com += 0\n            else:\n                com += 1\n            num = num // 2\n        return int(com[::-1][1:],2)\n"
    },
    {
        "slug": "largest-positive-integer-that-exists-with-its-negative",
        "description": "Given an integer array nums that does not contain any zeros, find the largest positive integer k such that -k also exists in the array.\nReturn the positive integer k. If there is no such integer, return -1.",
        "examples": [
            "Input: nums = [-1,2,-3,3]\nOutput: 3\nExplanation: 3 is the only valid k we can find in the array.",
            "Input: nums = [-1,10,6,7,-7,1]\nOutput: 7\nExplanation: Both 1 and 7 have their corresponding negative values in the array. 7 has a larger value.",
            "Input: nums = [-10,8,6,7,-2,-3]\nOutput: -1\nExplanation: There is no a single valid k, we return -1."
        ],
        "constraints": "1 <= nums.length <= 1000\n-1000 <= nums[i] <= 1000\nnums[i] != 0",
        "oracle_code": "class Solution:\n    def findMaxK(self, nums: List[int]) -> int:\n        nums=sorted(nums,reverse=True)\n        s=set(nums)\n        for i in range(len(nums)):\n            if 0-nums[i] in s:\n                return nums[i]\n        return -1",
        "content": "\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def findMaxK(self, nums: List[int]) -> int:\\n        nums=sorted(nums,reverse=True)\\n        s=set(nums)\\n        for i in range(len(nums)):\\n            if 0-nums[i] in s:\\n                return nums[i]\\n        return -1\\n\\n```",
        "level": "easy",
        "type": [
            "operation error",
            "wrong comment mark",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def findMaxK(self, nums: List[int]) -> int:\n        \n        s=set(nums)\n        for i in range(len(nums)+1):\n            if nums[i] in s:\n                return nums[i]\n        return -1\n"
    },
    {
        "slug": "median-of-two-sorted-arrays",
        "description": "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\nThe overall run time complexity should be O(log (m+n)).",
        "examples": [
            "Input: nums1 = [1,3], nums2 = [2]\nOutput: 2.00000\nExplanation: merged array = [1,2,3] and median is 2.",
            "Input: nums1 = [1,2], nums2 = [3,4]\nOutput: 2.50000\nExplanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5."
        ],
        "constraints": "nums1.length == m\nnums2.length == n\n0 <= m <= 1000\n0 <= n <= 1000\n1 <= m + n <= 2000\n-106 <= nums1[i], nums2[i] <= 106",
        "oracle_code": "class Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        p1 = 0\n        p2 = 0\n        new = []\n        while p1 < len(nums1) and p2 < len(nums2):\n            if nums1[p1] < nums2[p2]:\n                new.append(nums1[p1])\n                p1 += 1\n            else:\n                new.append(nums2[p2])\n                p2 += 1\n        while p1 < len(nums1):\n            new.append(nums1[p1])\n            p1 += 1\n        while p2 < len(nums2):\n            new.append(nums2[p2])\n            p2+= 1\n        if len(new) % 2 == 0:\n            index = len(new) // 2\n            median = (new[index] + new[index-1]) / 2\n        else:\n            median = float(new[len(new)//2])\n        return median",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind this approach is to merge the two sorted arrays while maintaining the order, and then finding the median based on the length of the merged array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize two pointers, p1 and p2, for the two input arrays nums1 and nums2, respectively, both starting at index 0.\\n2. Create an empty list new to store the merged array.\\n3. Iterate through both arrays using the pointers. Compare the elements pointed to by p1 and p2. Append the smaller element to the new array and increment the corresponding pointer.\\n4. After the iteration, there might be remaining elements in one of the arrays. Iterate through the remaining elements and append them to the new array.\\n5. Calculate the median based on the length of the new array. If the length is even, take the average of the middle two elements. If the length is odd, take the middle element.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(m + n), where m and n are the lengths of the two input arrays.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(m + n), as the merged array new can contain all the elements from the two input arrays.\\n\\n# Code\\n```\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        p1 = 0\\n        p2 = 0\\n        new = []\\n        while p1 < len(nums1) and p2 < len(nums2):\\n            if nums1[p1] < nums2[p2]:\\n                new.append(nums1[p1])\\n                p1 += 1\\n            else:\\n                new.append(nums2[p2])\\n                p2 += 1\\n        while p1 < len(nums1):\\n            new.append(nums1[p1])\\n            p1 += 1\\n        while p2 < len(nums2):\\n            new.append(nums2[p2])\\n            p2+= 1\\n        if len(new) % 2 == 0:\\n            index = len(new) // 2\\n            median = (new[index] + new[index-1]) / 2\\n        else:\\n            median = float(new[len(new)//2])\\n        return median\\n```",
        "level": "hard",
        "type": [
            "indentation error",
            "variable value error",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        p1 = 0\n        p2 = 0\n        new = []\n        while p1 < len(nums1) and p2 < len(nums2):\n            if nums1[p1] < nums2[p2]:\n            new.append(nums1[p1])\n            p1 = 1\n        else:\n            new.append(nums2[p2])\n            p2 += 1\n        while p1 < len(nums1):\n            new.append(nums1[p1])\n            p2 += 1\n        while p2 < len(nums2):\n            new.append(nums2[p2])\n            p1 += 1\n\n        if len(new) % 2 == 0:\n            index = len(new) // 2\n            median = (new[index] + new[index-1]) / 2\n        else:\n            median = float(new[len(new)//2])\n        return median\n"
    },
    {
        "slug": "valid-permutations-for-di-sequence",
        "description": "You are given a string s of length n where s[i] is either:\n\n'D' means decreasing, or\n'I' means increasing.\n\nA permutation perm of n + 1 integers of all the integers in the range [0, n] is called a valid permutation if for all valid i:\n\nIf s[i] == 'D', then perm[i] > perm[i + 1], and\nIf s[i] == 'I', then perm[i] < perm[i + 1].\n\nReturn the number of valid permutations perm. Since the answer may be large, return it modulo 109 + 7.",
        "examples": [
            "Input: s = \"DID\"\nOutput: 5\nExplanation: The 5 valid permutations of (0, 1, 2, 3) are:\n(1, 0, 3, 2)\n(2, 0, 3, 1)\n(2, 1, 3, 0)\n(3, 0, 2, 1)\n(3, 1, 2, 0)",
            "Input: s = \"D\"\nOutput: 1"
        ],
        "constraints": "n == s.length\n1 <= n <= 200\ns[i] is either 'I' or 'D'.",
        "oracle_code": "class Solution:\n    def numPermsDISequence(self, s: str) -> int:\n        mem=defaultdict(int)\n        def dfs(i,val=0):\n            if i==len(s):\n                return 1\n            if (i,val) in mem:\n                return mem[i,val]\n            p=0\n            if s[i]==\"D\":\n                for ind in range(0,val+1):\n                    p+=dfs(i+1,ind)%(10**9+7)\n            else:\n                for ind in range(val+1,i+2):\n                    p+=dfs(i+1,ind)%(10**9+7)\n            mem[i,val]=p\n            return p\n        return dfs(0)",
        "content": "To add a new character to a sequence we only have to consider the last element-\\n\\nLets say currently DID sequence is 1032- this can form\\n\\nDIDI - in cases where we end with 3,4\\nDIDD - in cases where we end with 0,1,2\\n\\nSo just use the last element value to create a new sequence.\\n\\n```\\nclass Solution:\\n    def numPermsDISequence(self, s: str) -> int:\\n        mem=defaultdict(int)\\n        def dfs(i,val=0):\\n            if i==len(s):\\n                return 1\\n            if (i,val) in mem:\\n                return mem[i,val]\\n            p=0\\n            if s[i]==\"D\":\\n                for ind in range(0,val+1):\\n                    p+=dfs(i+1,ind)%(10**9+7)\\n            else:\\n                for ind in range(val+1,i+2):\\n                    p+=dfs(i+1,ind)%(10**9+7)\\n            mem[i,val]=p\\n            return p\\n        return dfs(0)\\n ```\\n\\t\\t\\t\\t",
        "level": "hard",
        "type": [
            "colon missing",
            "parentheses mismatch",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution:\n    def numPermsDISequence(self, s: str) -> int:\n        mem=defaultdict(int)\n        def dfs(i,val=0):\n            if i==len(s):\n                return 1\n            if (i,val in mem\n                return mem[i,val]\n            p=0\n            if s[i]==\"D:\n                for ind in range(0,val+1):\n                    p+=dfs(i+1,ind)%(10**9+7)\n            else:\n                for ind in range(val+1,i+2):\n                    p+=dfs(i+1,ind)%(10**9+7)\n            mem[i,val]=p\n            return p\n        return dfs(0)\n"
    },
    {
        "slug": "binary-tree-level-order-traversal-ii",
        "description": "Given the root of a binary tree, return the bottom-up level order traversal of its nodes' values. (i.e., from left to right, level by level from leaf to root).",
        "examples": [
            "Input: root = [3,9,20,null,null,15,7]\nOutput: [[15,7],[9,20],[3]]",
            "Input: root = [1]\nOutput: [[1]]",
            "Input: root = []\nOutput: []"
        ],
        "constraints": "The number of nodes in the tree is in the range [0, 2000].\n-1000 <= Node.val <= 1000",
        "oracle_code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:\n        def checkReverse(ans):\n            l,r = 0,len(ans)-1\n            while l<=r:\n                ans[l],ans[r] = ans[r],ans[l]\n                l+=1\n                r-=1\n            return ans\n\n        if not root: return None\n        q,ans = [root],[]\n        while q:\n            n,l = len(q),[]\n            for i in range(n):\n                curr = q.pop(0)\n                l.append(curr.val)\n                if curr.left:\n                    q.append(curr.left)\n                if curr.right:\n                    q.append(curr.right)\n            ans.append(l)\n        return checkReverse(ans)",
        "content": "# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:\\n        def checkReverse(ans):\\n            l,r = 0,len(ans)-1\\n            while l<=r:\\n                ans[l],ans[r] = ans[r],ans[l]\\n                l+=1\\n                r-=1\\n            return ans\\n\\n        if not root: return None\\n        q,ans = [root],[]\\n        while q:\\n            n,l = len(q),[]\\n            for i in range(n):\\n                curr = q.pop(0)\\n                l.append(curr.val)\\n                if curr.left:\\n                    q.append(curr.left)\\n                if curr.right:\\n                    q.append(curr.right)\\n            ans.append(l)\\n        return checkReverse(ans)\\n```",
        "level": "medium",
        "type": [
            "indentation error",
            "undefined objects",
            "conditional statement error"
        ],
        "buggy_code": "\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:\n        def checkReverse(ans):\n            l,r = 0,len(ans)-1\n            while l<=r:\n                ans[l],ans[r] = ans[r],ans[l]\n                l+=1\n            r-=1\n            return ans\n\n        if not root: return None\n        q,ans = [root],[]\n        while q:\n            n,l = len(Node),[]\n            for i in range(n):\n                curr = q.pop(0)\n                l.append(curr.val)\n               if curr.left:\n                q.append(curr.lq.append(eft)curr.right)\n\n            ans.append(l)\n        return checkReverse(ans)\n"
    },
    {
        "slug": "maximum-gap",
        "description": "Given an integer array nums, return the maximum difference between two successive elements in its sorted form. If the array contains less than two elements, return 0.\nYou must write an algorithm that runs in linear time and uses linear extra space.",
        "examples": [
            "Input: nums = [3,6,9,1]\nOutput: 3\nExplanation: The sorted form of the array is [1,3,6,9], either (3,6) or (6,9) has the maximum difference 3.",
            "Input: nums = [10]\nOutput: 0\nExplanation: The array contains less than 2 elements, therefore return 0."
        ],
        "constraints": "1 <= nums.length <= 105\n0 <= nums[i] <= 109",
        "oracle_code": "class Solution:\n    def maximumGap(self, nums: List[int]) -> int:\n        nums=sorted(nums)\n        min=float(\"-inf\")\n        if len(nums)<2:\n            return 0\n        for i in range(len(nums)-1):\n            x=abs(nums[i]-nums[i+1])\n            if min<x:\n                min=x\n        return min",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumGap(self, nums: List[int]) -> int:\\n        nums=sorted(nums)\\n        min=float(\"-inf\")\\n        if len(nums)<2:\\n            return 0\\n        for i in range(len(nums)-1):\\n            x=abs(nums[i]-nums[i+1])\\n            if min<x:\\n                min=x\\n        return min\\n```",
        "level": "medium",
        "type": [
            "variable value error",
            "undefined objects",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution:\n    def maximumGap(self, nums: list) -> int:\n        nums=sorted(nums)\n        min=float(\"inf\")\n        if len(nums)<2:\n            return 0\n        for i in range(len(nums)-1):\n            x=abs(nums[i]-undefined_variable\n            if min<x:\n                min=x\n        return min\n"
    },
    {
        "slug": "kth-largest-element-in-an-array",
        "description": "Given an integer array nums and an integer k, return the kth largest element in the array.\nNote that it is the kth largest element in the sorted order, not the kth distinct element.\nCan you solve it without sorting?",
        "examples": [
            "Input: nums = [3,2,1,5,6,4], k = 2\nOutput: 5",
            "Input: nums = [3,2,3,1,2,4,5,5,6], k = 4\nOutput: 4"
        ],
        "constraints": "1 <= k <= nums.length <= 105\n-104 <= nums[i] <= 104",
        "oracle_code": "class Solution:\n    def findKthLargest(self, nums: List[int], k: int) -> int:\n        return sorted(nums)[-k]",
        "content": "# Approach\\n- Sorting\\n\\n# Complexity\\n- Time complexity: O(n*log(n))\\n\\n# Code\\n```\\nclass Solution:\\n    def findKthLargest(self, nums: List[int], k: int) -> int:\\n        return sorted(nums)[-k]\\n```",
        "level": "medium",
        "type": [
            "colon missing",
            "parentheses mismatch",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution\n    def findKthLargest(self, nums: List[int], k: int -> int:\n        return sorted(nums)[-k-1]\n"
    },
    {
        "slug": "lexicographically-smallest-palindrome",
        "description": "You are given a string s consisting of lowercase English letters, and you are allowed to perform operations on it. In one operation, you can replace a character in s with another lowercase English letter.\nYour task is to make s a palindrome with the minimum number of operations possible. If there are multiple palindromes that can be made using the minimum number of operations, make the lexicographically smallest one.\nA string a is lexicographically smaller than a string b (of the same length) if in the first position where a and b differ, string a has a letter that appears earlier in the alphabet than the corresponding letter in b.\nReturn the resulting palindrome string.",
        "examples": [
            "Input: s = \"egcfe\"\nOutput: \"efcfe\"\nExplanation: The minimum number of operations to make \"egcfe\" a palindrome is 1, and the lexicographically smallest palindrome string we can get by modifying one character is \"efcfe\", by changing 'g'.",
            "Input: s = \"abcd\"\nOutput: \"abba\"\nExplanation: The minimum number of operations to make \"abcd\" a palindrome is 2, and the lexicographically smallest palindrome string we can get by modifying two characters is \"abba\".",
            "Input: s = \"seven\"\nOutput: \"neven\"\nExplanation: The minimum number of operations to make \"seven\" a palindrome is 1, and the lexicographically smallest palindrome string we can get by modifying one character is \"neven\"."
        ],
        "constraints": "1 <= s.length <= 1000\ns\u00a0consists of only lowercase English letters.",
        "oracle_code": "class Solution:\n    def makeSmallestPalindrome(self, s: str) -> str:\n        before = 0\n        after = len(s)-1\n        l = [i for i in s]\n        while before <= len(s)/2:\n            l[before] = min(l[before], l[after])\n            l[after] = l[before]\n            before+=1\n            after-=1\n        return \"\".join(l)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: 214 ms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 16.5 MB\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def makeSmallestPalindrome(self, s: str) -> str:\\n        before = 0\\n        after = len(s)-1\\n        l = [i for i in s]\\n        while before <= len(s)/2:\\n            l[before] = min(l[before], l[after])\\n            l[after] = l[before]\\n            before+=1\\n            after-=1\\n        return \"\".join(l)\\n```",
        "level": "easy",
        "type": [
            "undefined methods",
            "unclosed string",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def makeSmallestPalindrome(self, s: str) -> str:\n        before = 0\n        after = len(s)-1\n        l = [i for i in s]\n        while before <= len(s)\n            l[before] = self.min(l[before], l[after])\n            l[after] = l[before]\n            before+=1\n            after-=1\n        return \"\".join(l)\n"
    },
    {
        "slug": "sum-of-subarray-minimums",
        "description": "Given an array of integers arr, find the sum of min(b), where b ranges over every (contiguous) subarray of arr. Since the answer may be large, return the answer modulo 109 + 7.",
        "examples": [
            "Input: arr = [3,1,2,4]\nOutput: 17\nExplanation: \nSubarrays are [3], [1], [2], [4], [3,1], [1,2], [2,4], [3,1,2], [1,2,4], [3,1,2,4]. \nMinimums are 3, 1, 2, 4, 1, 1, 2, 1, 1, 1.\nSum is 17.",
            "Input: arr = [11,81,94,43,3]\nOutput: 444"
        ],
        "constraints": "1 <= arr.length <= 3 * 104\n1 <= arr[i] <= 3 * 104",
        "oracle_code": "class Solution:\n    def sumSubarrayMins(self, arr: List[int]) -> int:\n        stack = []\n        res = 0\n        arr = [float('-inf')] + arr + [float('-inf')]\n        for i, num in enumerate(arr):\n            while stack and arr[stack[-1]] > num:\n                cur = stack.pop()\n                res += arr[cur] * (i - cur) * (cur - stack[-1])\n            stack.append(i)\n        return res % (10**9 + 7)",
        "content": "Maintain a stack of indexes of subarrays, \\nwhich would have the minimum number at the top of the stack.\\n \\nUse following logic to compute the sum(i):\\n- If arr[i] is small, then arr[i] is minimum for all subarrays \\nstarting at arr[i].\\n- If arr[i] is greater, then find the smallest element from the top of stack which is bigger than arr[i]. \\n- Let the index of the smallest element be on top. \\n- Now, arr[i] is minimum for all subarrays starting at arr[top+1]. \\n\\nWe already know the value of sum(top), so add sum(top) + arr[i] * (i \\u2013 top) to result. Finally, push the index of arr[i] to stack.\\n\\n# Complexity\\nTime Complexity: O(N)\\nSpace Complexity: O(N)\\n\\n# Code\\n```\\nclass Solution:\\n    def sumSubarrayMins(self, arr: List[int]) -> int:\\n        stack = []\\n        res = 0\\n        arr = [float(\\'-inf\\')] + arr + [float(\\'-inf\\')]\\n        for i, num in enumerate(arr):\\n            while stack and arr[stack[-1]] > num:\\n                cur = stack.pop()\\n                res += arr[cur] * (i - cur) * (cur - stack[-1])\\n            stack.append(i)\\n        return res % (10**9 + 7)\\n\\n```",
        "level": "medium",
        "type": [
            "other error",
            "unclosed string",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def sumSubarrayMins(self, arr: List[int]) -> int:\n        stack = []\n        res = 0\n        arr = [float('-inf')] + arr + [float('-inf')]\n        for i, num in enumerate(arr):\n            while stack and arr[stack[-1]] > num:\n                cur = stack.pop()\n                res += arr[cur] * (cur - i) * (cur - stack[-2]\n            stack.append(i)\n        return res % (10**9 + 7)\n"
    },
    {
        "slug": "restore-ip-addresses",
        "description": "A valid IP address consists of exactly four integers separated by single dots. Each integer is between 0 and 255 (inclusive) and cannot have leading zeros.\n\nFor example, \"0.1.2.201\" and \"192.168.1.1\" are valid IP addresses, but \"0.011.255.245\", \"192.168.1.312\" and \"192.168@1.1\" are invalid IP addresses.\n\nGiven a string s containing only digits, return all possible valid IP addresses that can be formed by inserting dots into s. You are not allowed to reorder or remove any digits in s. You may return the valid IP addresses in any order.",
        "examples": [
            "Input: s = \"25525511135\"\nOutput: [\"255.255.11.135\",\"255.255.111.35\"]",
            "Input: s = \"0000\"\nOutput: [\"0.0.0.0\"]",
            "Input: s = \"101023\"\nOutput: [\"1.0.10.23\",\"1.0.102.3\",\"10.1.0.23\",\"10.10.2.3\",\"101.0.2.3\"]"
        ],
        "constraints": "1 <= s.length <= 20\ns consists of digits only.",
        "oracle_code": "class Solution:\n    def restoreIpAddresses(self, s: str) -> List[str]:\n        res=[]\n        cur=[]\n        def backtrack(i):\n            if i==len(s) and len(cur)==4:\n                res.append(\".\".join(cur))\n                return\n            if len(cur)>4 or i>=len(s):\n                return\n            if s[i]=='0':\n                cur.append(s[i])\n                backtrack(i+1)\n                cur.pop()\n                return\n            j=0\n            while j<4 and i+j<len(s):\n                if int(s[i:i+j+1])<256:\n                    cur.append(s[i:i+j+1])\n                    backtrack(i+j+1)\n                    cur.pop()\n                j+=1\n        backtrack(0)\n        return res",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\njust take care with the processing number should be lower than len(s) and the length of current stack should be lower or equal 4.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(4)\\n# Code\\n```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        res=[]\\n        cur=[]\\n        def backtrack(i):\\n            if i==len(s) and len(cur)==4:\\n                res.append(\".\".join(cur))\\n                return\\n            if len(cur)>4 or i>=len(s):\\n                return\\n            if s[i]==\\'0\\':\\n                cur.append(s[i])\\n                backtrack(i+1)\\n                cur.pop()\\n                return\\n            j=0\\n            while j<4 and i+j<len(s):\\n                if int(s[i:i+j+1])<256:\\n                    cur.append(s[i:i+j+1])\\n                    backtrack(i+j+1)\\n                    cur.pop()\\n                j+=1\\n        backtrack(0)\\n        return res\\n\\n```",
        "level": "medium",
        "type": [
            "colon missing",
            "parentheses mismatch",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution():\n    def restoreIpAddresses(self, s: str) -> List[str]:\n        res=[]\n        cur=[]\n        def backtrack(i:\n            if i==len(s) and len(cur)==4:\n                res.append(\".\".join(cur))\n                return\n            if len(cur)>4 or i>=len(s):\n                return\n            if s[i]=='0':\n                cur.append(s[i])\n                backtrack(i+1)\n                cur.pop()\n                return\n            j=0\n            while j<4 and i+j<len(s)\n                if int(s[i:i+j+1])<256:\n                    cur.append(s[i:i+j+1])\n                    backtrack(i+j+1)\n                    cur.pop()\n                j+=1\n        backtrack(0)\n        return 'res\n"
    },
    {
        "slug": "valid-arrangement-of-pairs",
        "description": "You are given a 0-indexed 2D integer array pairs where pairs[i] = [starti, endi]. An arrangement of pairs is valid if for every index i where 1 <= i < pairs.length, we have endi-1 == starti.\nReturn any valid arrangement of pairs.\nNote: The inputs will be generated such that there exists a valid arrangement of pairs.",
        "examples": [
            "Input: pairs = [[5,1],[4,5],[11,9],[9,4]]\nOutput: [[11,9],[9,4],[4,5],[5,1]]\nExplanation:\nThis is a valid arrangement since endi-1 always equals starti.\nend0 = 9 == 9 = start1 \nend1 = 4 == 4 = start2\nend2 = 5 == 5 = start3",
            "Input: pairs = [[1,3],[3,2],[2,1]]\nOutput: [[1,3],[3,2],[2,1]]\nExplanation:\nThis is a valid arrangement since endi-1 always equals starti.\nend0 = 3 == 3 = start1\nend1 = 2 == 2 = start2\nThe arrangements [[2,1],[1,3],[3,2]] and [[3,2],[2,1],[1,3]] are also valid.",
            "Input: pairs = [[1,2],[1,3],[2,1]]\nOutput: [[1,2],[2,1],[1,3]]\nExplanation:\nThis is a valid arrangement since endi-1 always equals starti.\nend0 = 2 == 2 = start1\nend1 = 1 == 1 = start2"
        ],
        "constraints": "1 <= pairs.length <= 105\npairs[i].length == 2\n0 <= starti, endi <= 109\nstarti != endi\nNo two pairs are exactly the same.\nThere exists a valid arrangement of pairs.",
        "oracle_code": "class Solution:\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\n        graph = defaultdict(list)\n        degree = defaultdict(int) # net out degree \n        for x, y in pairs: \n            graph[x].append(y)\n            degree[x] += 1\n            degree[y] -= 1\n                \n        for k in degree: \n            if degree[k] == 1: \n                x = k\n                break \n                \n        ans = []\n\n        def fn(x): \n            \"\"\"Return Eulerian path via dfs.\"\"\"\n            while graph[x]: fn(graph[x].pop()) \n            ans.append(x)\n        \n        fn(x)\n        ans.reverse()\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]",
        "content": "Please check out this [commit](https://github.com/gaosanyong/leetcode/commit/b1948f8814bebeca475cbb354cd44d19092dff59) for solutions of weekly 270.\\n\\n```\\nclass Solution:\\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\\n        graph = defaultdict(list)\\n        degree = defaultdict(int) # net out degree \\n        for x, y in pairs: \\n            graph[x].append(y)\\n            degree[x] += 1\\n            degree[y] -= 1\\n                \\n        for k in degree: \\n            if degree[k] == 1: \\n                x = k\\n                break \\n                \\n        ans = []\\n\\n        def fn(x): \\n            \"\"\"Return Eulerian path via dfs.\"\"\"\\n            while graph[x]: fn(graph[x].pop()) \\n            ans.append(x)\\n        \\n        fn(x)\\n        ans.reverse()\\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]\\n```\\n\\nAdding an iterative implementation of Hieholzer\\'s algo from @delphih\\n```\\nclass Solution:\\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\\n        graph = defaultdict(list)\\n        degree = defaultdict(int) # net out degree \\n        for x, y in pairs: \\n            graph[x].append(y)\\n            degree[x] += 1\\n            degree[y] -= 1\\n                \\n        for k in degree: \\n            if degree[k] == 1: \\n                x = k\\n                break \\n                \\n        ans = []\\n        stack = [x]\\n        while stack: \\n            while graph[stack[-1]]: \\n                stack.append(graph[stack[-1]].pop())\\n            ans.append(stack.pop())\\n        ans.reverse()\\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]\\n```",
        "level": "hard",
        "type": [
            "undefined methods",
            "parentheses mismatch",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution:\n    function validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\n        graph = defaultdict(list)\n        degree = defaultdict(int) # net out degree \n        for x, y in pairs: \n            graph[x].append(y)\n            degree[x] += 1\n            degree[y] -= 1\n                \n        for k in degree: \n            if degree[k] == 1: \n                x = k\n                break \n                \n        ans = []\n\n        function fn(x): \n            \"\"\"Return Eulerian path via dfs.\"\"\"\n            while graph[x]: fn(graph[x].pop()) \n            ans.append(x)\n        \n        dfn(s\n        ans.reverse()\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]\n"
    },
    {
        "slug": "median-of-two-sorted-arrays",
        "description": "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\nThe overall run time complexity should be O(log (m+n)).",
        "examples": [
            "Input: nums1 = [1,3], nums2 = [2]\nOutput: 2.00000\nExplanation: merged array = [1,2,3] and median is 2.",
            "Input: nums1 = [1,2], nums2 = [3,4]\nOutput: 2.50000\nExplanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5."
        ],
        "constraints": "nums1.length == m\nnums2.length == n\n0 <= m <= 1000\n0 <= n <= 1000\n1 <= m + n <= 2000\n-106 <= nums1[i], nums2[i] <= 106",
        "oracle_code": "class Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        p1 = 0\n        p2 = 0\n        new = []\n        while p1 < len(nums1) and p2 < len(nums2):\n            if nums1[p1] < nums2[p2]:\n                new.append(nums1[p1])\n                p1 += 1\n            else:\n                new.append(nums2[p2])\n                p2 += 1\n        while p1 < len(nums1):\n            new.append(nums1[p1])\n            p1 += 1\n        while p2 < len(nums2):\n            new.append(nums2[p2])\n            p2+= 1\n        if len(new) % 2 == 0:\n            index = len(new) // 2\n            median = (new[index] + new[index-1]) / 2\n        else:\n            median = float(new[len(new)//2])\n        return median",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind this approach is to merge the two sorted arrays while maintaining the order, and then finding the median based on the length of the merged array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize two pointers, p1 and p2, for the two input arrays nums1 and nums2, respectively, both starting at index 0.\\n2. Create an empty list new to store the merged array.\\n3. Iterate through both arrays using the pointers. Compare the elements pointed to by p1 and p2. Append the smaller element to the new array and increment the corresponding pointer.\\n4. After the iteration, there might be remaining elements in one of the arrays. Iterate through the remaining elements and append them to the new array.\\n5. Calculate the median based on the length of the new array. If the length is even, take the average of the middle two elements. If the length is odd, take the middle element.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(m + n), where m and n are the lengths of the two input arrays.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(m + n), as the merged array new can contain all the elements from the two input arrays.\\n\\n# Code\\n```\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        p1 = 0\\n        p2 = 0\\n        new = []\\n        while p1 < len(nums1) and p2 < len(nums2):\\n            if nums1[p1] < nums2[p2]:\\n                new.append(nums1[p1])\\n                p1 += 1\\n            else:\\n                new.append(nums2[p2])\\n                p2 += 1\\n        while p1 < len(nums1):\\n            new.append(nums1[p1])\\n            p1 += 1\\n        while p2 < len(nums2):\\n            new.append(nums2[p2])\\n            p2+= 1\\n        if len(new) % 2 == 0:\\n            index = len(new) // 2\\n            median = (new[index] + new[index-1]) / 2\\n        else:\\n            median = float(new[len(new)//2])\\n        return median\\n```",
        "level": "hard",
        "type": [
            "indentation error",
            "colon missing",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float\n        p1 = 0\n        p2 = 0\n        new = []\n        while p1 < len(nums1) and p2 < len(nums2):\n            if nums1[p1] < nums2[p2]:\n            new.append(nums1[p1])\n            p1 += 1\n        else:\n            new.append(nums2[p2])\n            p2 += 1\n        while p1 < len(nums1):\n            new.append(nums1[p1])\n            p1 += 1\n        while p2 <= len(nums2):\n            new.append(nums2[p2])\n            p2+= 1\n        if len(new) % 2 == 0:\n            index = len(new) // 2\n            median = (new[index] + new[index-1]) / 2\n        else:\n            median = float(new[len(new)//2])\n        return median\n"
    },
    {
        "slug": "find-closest-node-to-given-two-nodes",
        "description": "You are given a directed graph of n nodes numbered from 0 to n - 1, where each node has at most one outgoing edge.\nThe graph is represented with a given 0-indexed array edges of size n, indicating that there is a directed edge from node i to node edges[i]. If there is no outgoing edge from i, then edges[i] == -1.\nYou are also given two integers node1 and node2.\nReturn the index of the node that can be reached from both node1 and node2, such that the maximum between the distance from node1 to that node, and from node2 to that node is minimized. If there are multiple answers, return the node with the smallest index, and if no possible answer exists, return -1.\nNote that edges may contain cycles.",
        "examples": [
            "Input: edges = [2,2,3,-1], node1 = 0, node2 = 1\nOutput: 2\nExplanation: The distance from node 0 to node 2 is 1, and the distance from node 1 to node 2 is 1.\nThe maximum of those two distances is 1. It can be proven that we cannot get a node with a smaller maximum distance than 1, so we return node 2.",
            "Input: edges = [1,2,-1], node1 = 0, node2 = 2\nOutput: 2\nExplanation: The distance from node 0 to node 2 is 2, and the distance from node 2 to itself is 0.\nThe maximum of those two distances is 2. It can be proven that we cannot get a node with a smaller maximum distance than 2, so we return node 2."
        ],
        "constraints": "n == edges.length\n2 <= n <= 105\n-1 <= edges[i] < n\nedges[i] != i\n0 <= node1, node2 < n",
        "oracle_code": "class Solution:\n    def cdist(self, it, distArray, distArrayIndex, edges):\n        rdist = 0 \n        nodes = []\n        while it != -1 and distArray[it][distArrayIndex] > rdist:\n            distArray[it][distArrayIndex] = rdist\n            nodes.append(it)\n            it = edges[it]\n            rdist += 1\n        return nodes\n            \n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\n        INF = float('inf')\n        dist = defaultdict(lambda: [INF,INF])\n        mmin, ans = INF, INF\n               \n        n = self.cdist(node1, dist, 0, edges)\n        n += self.cdist(node2, dist, 1, edges)\n                \n        for k in n:\n            m = max(dist[k])\n            if m != INF:\n                if m < mmin: \n                    mmin = m\n                    ans = k\n                elif m == mmin: \n                    ans = min(ans, k)\n                    \n        return ans if ans != float('inf') else -1",
        "content": "Since there is atmost one outgoing edge with cycles, we can iterate this graph in simple manner as cdist function below. The logic briefly is as below. \\n1. Calculate distances between node1 and other reachable nodes. \\n2. Do the same as (1) for node 2\\n3. Iterate the nodes that are on the path for both distances and find max. \\n4. find min of maxes and keep track of minimum index. \\n\\nIf there was a constraint that node1 and node2 have a guarenteed path between them, the problem could have been simpler, to construct find the shortestPath between node1 -> node 2 and the ans is one of the nodes in between. Thats not the case ! \\n\\n```\\nclass Solution:\\n    def cdist(self, it, distArray, distArrayIndex, edges):\\n        rdist = 0 \\n        nodes = []\\n        while it != -1 and distArray[it][distArrayIndex] > rdist:\\n            distArray[it][distArrayIndex] = rdist\\n            nodes.append(it)\\n            it = edges[it]\\n            rdist += 1\\n        return nodes\\n            \\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        INF = float(\\'inf\\')\\n        dist = defaultdict(lambda: [INF,INF])\\n        mmin, ans = INF, INF\\n               \\n        n = self.cdist(node1, dist, 0, edges)\\n        n += self.cdist(node2, dist, 1, edges)\\n                \\n        for k in n:\\n            m = max(dist[k])\\n            if m != INF:\\n                if m < mmin: \\n                    mmin = m\\n                    ans = k\\n                elif m == mmin: \\n                    ans = min(ans, k)\\n                    \\n        return ans if ans != float(\\'inf\\') else -1\\n```\\n\\nA slightly modified logic, \\n\\n```\\nclass Solution:\\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        INF = float(\\'inf\\')\\n        N = len(edges)\\n        dist_node1 = [INF for _ in range(N)]\\n        dist_node2 = [INF for _ in range(N)]\\n        \\n        def dfs(node, di, d):\\n            if d[node] > di: \\n                d[node] = di\\n                if edges[node] != -1:\\n                    dfs(edges[node], di+1, d)\\n        \\n        dfs(node1, 0, dist_node1)\\n        dfs(node2, 0, dist_node2)\\n\\n        for i in range(N):\\n            dist_node1[i] = max(dist_node1[i], dist_node2[i])\\n                        \\n        ans = dist_node1.index(min(dist_node1))\\n        return ans if dist_node1[ans] != INF else -1\\n",
        "level": "medium",
        "type": [
            "indentation error",
            "unclosed string",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def cdist(self, it, distArray, distArrayIndex, edges):\n    rdist = 0 \n    nodes = []\n    while it != -1 and distArray[it+1][distArrayIndex] > rdist:\n        distArray[it][distArrayIndex] = rdist\n        nodes.append(it)\n        it = edges[it]\n        rdist += 1\n    return nodes\n            \n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\n        INF = float('inf')\n        dist = defaultdict(lambda: [INF,INF])\n        mmin, ans = INF, INF\n               \n        n = self.cdist(node1, dist, 0, edges)\n        n += self.cdist(node2, dist, 1, edges)\n                \n        for k in n:\n            m = max(dist[k])\n            if m != INF:\n                if m < mmin: \n                    mmin = m\n                    ans = k\n                elif m == mmin: \n                    ans = min(ans, k)\n                    \n        return ans if ans != 'inf' else -1\n"
    },
    {
        "slug": "find-the-string-with-lcp",
        "description": "We define the lcp matrix of any 0-indexed string word of n lowercase English letters as an n x n grid such that:\n\nlcp[i][j] is equal to the length of the longest common prefix between the substrings word[i,n-1] and word[j,n-1].\n\nGiven an\u00a0n x n matrix lcp, return the alphabetically smallest string word that corresponds to lcp. If there is no such string, return an empty string.\nA string a is lexicographically smaller than a string b (of the same length) if in the first position where a and b differ, string a has a letter that appears earlier in the alphabet than the corresponding letter in b. For example, \"aabd\" is lexicographically smaller than \"aaca\" because the first position they differ is at the third letter, and 'b' comes before 'c'.",
        "examples": [
            "Input: lcp = [[4,0,2,0],[0,3,0,1],[2,0,2,0],[0,1,0,1]]\nOutput: \"abab\"\nExplanation: lcp corresponds to any 4 letter string with two alternating letters. The lexicographically smallest of them is \"abab\".",
            "Input: lcp = [[4,3,2,1],[3,3,2,1],[2,2,2,1],[1,1,1,1]]\nOutput: \"aaaa\"\nExplanation: lcp corresponds to any 4 letter string with a single distinct letter. The lexicographically smallest of them is \"aaaa\".",
            "Input: lcp = [[4,3,2,1],[3,3,2,1],[2,2,2,1],[1,1,1,3]]\nOutput: \"\"\nExplanation: lcp[3][3] cannot be equal to 3 since word[3,...,3] consists of only a single letter; Thus, no answer exists."
        ],
        "constraints": "1 <= n ==\u00a0lcp.length == lcp[i].length\u00a0<= 1000\n0 <= lcp[i][j] <= n",
        "oracle_code": "class Solution:\n    def findTheString(self, lcp: List[List[int]]) -> str:\n        # simple validation\n        n = len(lcp)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if lcp[i][j] != lcp[j][i]:\n                    return ''\n                if lcp[i][j] > n - j:\n                    return ''\n        for i in range(n):\n            if lcp[i][i] != n - i:\n                return ''\n        \n        # build pattern \\u2014 the only possible candidate for answer\n        pattern = [None for _ in range(n)]\n        next_el_ind = 0\n        for i in range(n):\n            if pattern[i] is not None:\n                continue\n            pattern[i] = next_el_ind\n            next_el_ind += 1\n            for j in range(i+1, n):\n                if lcp[i][j] > 0:\n                    if pattern[j] is not None and pattern[j] != pattern[i]:\n                        return ''\n                    pattern[j] = pattern[i]\n    \n        # check if lcp is valid - check that pattern's lcp == original lcp\n        pattern_lcp = [[0 for _ in range(n)] for _ in range(n)]\n        for i in range(n-1, -1, -1):\n            for j in range(n-1, -1, -1):\n                if pattern[i] == pattern[j]:\n                    if max(i, j) + 1 < n:\n                        pattern_lcp[i][j] = pattern_lcp[i+1][j+1] + 1\n                    else:\n                        pattern_lcp[i][j] = 1\n        for i in range(n):\n            for j in range(n):\n                if lcp[i][j] != pattern_lcp[i][j]:\n                    return ''\n    \n        # check that answer has no more than 26 distinct elements\n        if max(pattern) > ord('z') - ord('a'):\n            return ''\n\n        return  ''.join(chr(ord('a') + ind) for ind in pattern)",
        "content": "# Complexity\\n- Time complexity: $O(N^2)$\\n\\n- Space complexity: $O(N^2)$ (can be reduced to $O(N)$ if build and check new lcp at the same time)\\n\\n# Code\\n```\\nclass Solution:\\n    def findTheString(self, lcp: List[List[int]]) -> str:\\n        # simple validation\\n        n = len(lcp)\\n        for i in range(n):\\n            for j in range(i + 1, n):\\n                if lcp[i][j] != lcp[j][i]:\\n                    return \\'\\'\\n                if lcp[i][j] > n - j:\\n                    return \\'\\'\\n        for i in range(n):\\n            if lcp[i][i] != n - i:\\n                return \\'\\'\\n        \\n        # build pattern \\u2014 the only possible candidate for answer\\n        pattern = [None for _ in range(n)]\\n        next_el_ind = 0\\n        for i in range(n):\\n            if pattern[i] is not None:\\n                continue\\n            pattern[i] = next_el_ind\\n            next_el_ind += 1\\n            for j in range(i+1, n):\\n                if lcp[i][j] > 0:\\n                    if pattern[j] is not None and pattern[j] != pattern[i]:\\n                        return \\'\\'\\n                    pattern[j] = pattern[i]\\n    \\n        # check if lcp is valid - check that pattern\\'s lcp == original lcp\\n        pattern_lcp = [[0 for _ in range(n)] for _ in range(n)]\\n        for i in range(n-1, -1, -1):\\n            for j in range(n-1, -1, -1):\\n                if pattern[i] == pattern[j]:\\n                    if max(i, j) + 1 < n:\\n                        pattern_lcp[i][j] = pattern_lcp[i+1][j+1] + 1\\n                    else:\\n                        pattern_lcp[i][j] = 1\\n        for i in range(n):\\n            for j in range(n):\\n                if lcp[i][j] != pattern_lcp[i][j]:\\n                    return \\'\\'\\n    \\n        # check that answer has no more than 26 distinct elements\\n        if max(pattern) > ord(\\'z\\') - ord(\\'a\\'):\\n            return \\'\\'\\n\\n        return  \\'\\'.join(chr(ord(\\'a\\') + ind) for ind in pattern)\\n```",
        "level": "hard",
        "type": [
            "indentation error",
            "operation error",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution:\n    def findTheString(self, lcp: List[List[int]]) -> str:\n        # simple validation\n        n = len(lcp)\n\n        for i in range(n):\n            for j in range(i + 1, n):\n                if lcp[i][j] != lcp[j][i]:\n                    return ''\n                if lcp[i][j] > n - j:\n                    return ''\n        for i in range(n):\n            if lcp[i][i] != n - i:\n                return ''\n\n        # build pattern \\u2014 the only possible candidate for answer\n        pattern = [None for _ in range(n)]\n        next_el_ind = 0\n        for i in range(n):\n        if pattern[i] is not None:\n            continue\n        pattern[i] = next_el_ind\n        next_el_ind += 1\n        for j in range(i+1, n:\n            if lcp[i][j] > 0):\n                if pattern[j] is not None and pattern[j] != pattern[i]:      \n                    return ''      \n                pattern[j] = pattern[i]\n\n        # check if lcp is valid - check that pattern's lcp == original lcp\n        pattern_lcp = [[0 for _ in range(n)] for _ in range(n)]\n        for i in range(n-1, -1, -1):\n            for j in range(n-1, -1, -1):\n                if pattern[i] == pattern[j]:\n                    if max(i, j) + 1 < n:\n                        pattern_lcp[i][j] = pattern_lcp[i+1][j+1] + 2 //Add 2 instead of 1\n                    else:\n                        pattern_lcp[i][j] = 1\n        for i in range(n):\n            for j in range(n):\n                if lcp[i][j] != pattern_lcp[i][j]:\n                    return ''\n\n\n        # check that answer has no more than 26 distinct elements\n        if max(pattern) > ord('z') - ord('a'):\n            return ''\n\n        return  ''.join(chr(ord('a') + ind) for ind in pattern)\n"
    },
    {
        "slug": "decode-the-slanted-ciphertext",
        "description": "A string originalText is encoded using a slanted transposition cipher to a string encodedText with the help of a matrix having a fixed number of rows rows.\noriginalText is placed first in a top-left to bottom-right manner.\n\nThe blue cells are filled first, followed by the red cells, then the yellow cells, and so on, until we reach the end of originalText. The arrow indicates the order in which the cells are filled. All empty cells are filled with ' '. The number of columns is chosen such that the rightmost column will not be empty after filling in originalText.\nencodedText is then formed by appending all characters of the matrix in a row-wise fashion.\n\nThe characters in the blue cells are appended first to encodedText, then the red cells, and so on, and finally the yellow cells. The arrow indicates the order in which the cells are accessed.\nFor example, if originalText = \"cipher\" and rows = 3, then we encode it in the following manner:\n\nThe blue arrows depict how originalText is placed in the matrix, and the red arrows denote the order in which encodedText is formed. In the above example, encodedText = \"ch ie pr\".\nGiven the encoded string encodedText and number of rows rows, return the original string originalText.\nNote: originalText does not have any trailing spaces ' '. The test cases are generated such that there is only one possible originalText.",
        "examples": [
            "Input: encodedText = \"ch   ie   pr\", rows = 3\nOutput: \"cipher\"\nExplanation: This is the same example described in the problem description.",
            "Input: encodedText = \"iveo    eed   l te   olc\", rows = 4\nOutput: \"i love leetcode\"\nExplanation: The figure above denotes the matrix that was used to encode originalText. \nThe blue arrows show how we can find originalText from encodedText.",
            "Input: encodedText = \"coding\", rows = 1\nOutput: \"coding\"\nExplanation: Since there is only 1 row, both originalText and encodedText are the same."
        ],
        "constraints": "0 <= encodedText.length <= 106\nencodedText consists of lowercase English letters and ' ' only.\nencodedText is a valid encoding of some originalText that does not have trailing spaces.\n1 <= rows <= 1000\nThe testcases are generated such that there is only one possible originalText.",
        "oracle_code": "class Solution:\n    def decodeCiphertext(self, encoded_text: str, rows: int) -> str:\n        if rows == 1:\n            return encoded_text\n\n        N = len(encoded_text)\n        cols = N // rows\n        i, j, k = 0, 0, 0\n        original_text = []\n\n        while k < N:\n            original_text.append(encoded_text[k])\n            i += 1\n            if i == rows:\n                i = 0\n                j += 1\n            k = i*(cols + 1) + j\n\n        return ''.join(original_text).rstrip()",
        "content": "![Capture d\\u2019\\xE9cran (96).png](https://assets.leetcode.com/users/images/3e9f8a31-b0d3-4995-ae49-64d20c8c39d1_1681219407.2042663.png)\\n\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def decodeCiphertext(self, encoded_text: str, rows: int) -> str:\\n        if rows == 1:\\n            return encoded_text\\n\\n        N = len(encoded_text)\\n        cols = N // rows\\n        i, j, k = 0, 0, 0\\n        original_text = []\\n\\n        while k < N:\\n            original_text.append(encoded_text[k])\\n            i += 1\\n            if i == rows:\\n                i = 0\\n                j += 1\\n            k = i*(cols + 1) + j\\n\\n        return \\'\\'.join(original_text).rstrip()\\n```",
        "level": "medium",
        "type": [
            "undefined objects",
            "unclosed string",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def decodeCiphertext(self, encoded_text: str, rows: int) -> str:\n        if rows == 1:\n            return 'encoded_text\n\n        N = len(encoded_text)\n        cols = non_existing_variable // rows\n        i, j, k = 0, 0, 0\n        original_text = []\n\n        while k < N:\n            original_text.append(encoded_text[k])\n            i += 1\n            if i == rows + 1:\n                i = 0\n                j += 1\n            k = i*(cols + 1) + j\n\n        return ''.join(original_text).rstrip()\n"
    },
    {
        "slug": "find-closest-node-to-given-two-nodes",
        "description": "You are given a directed graph of n nodes numbered from 0 to n - 1, where each node has at most one outgoing edge.\nThe graph is represented with a given 0-indexed array edges of size n, indicating that there is a directed edge from node i to node edges[i]. If there is no outgoing edge from i, then edges[i] == -1.\nYou are also given two integers node1 and node2.\nReturn the index of the node that can be reached from both node1 and node2, such that the maximum between the distance from node1 to that node, and from node2 to that node is minimized. If there are multiple answers, return the node with the smallest index, and if no possible answer exists, return -1.\nNote that edges may contain cycles.",
        "examples": [
            "Input: edges = [2,2,3,-1], node1 = 0, node2 = 1\nOutput: 2\nExplanation: The distance from node 0 to node 2 is 1, and the distance from node 1 to node 2 is 1.\nThe maximum of those two distances is 1. It can be proven that we cannot get a node with a smaller maximum distance than 1, so we return node 2.",
            "Input: edges = [1,2,-1], node1 = 0, node2 = 2\nOutput: 2\nExplanation: The distance from node 0 to node 2 is 2, and the distance from node 2 to itself is 0.\nThe maximum of those two distances is 2. It can be proven that we cannot get a node with a smaller maximum distance than 2, so we return node 2."
        ],
        "constraints": "n == edges.length\n2 <= n <= 105\n-1 <= edges[i] < n\nedges[i] != i\n0 <= node1, node2 < n",
        "oracle_code": "class Solution:\n    def cdist(self, it, distArray, distArrayIndex, edges):\n        rdist = 0 \n        nodes = []\n        while it != -1 and distArray[it][distArrayIndex] > rdist:\n            distArray[it][distArrayIndex] = rdist\n            nodes.append(it)\n            it = edges[it]\n            rdist += 1\n        return nodes\n            \n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\n        INF = float('inf')\n        dist = defaultdict(lambda: [INF,INF])\n        mmin, ans = INF, INF\n               \n        n = self.cdist(node1, dist, 0, edges)\n        n += self.cdist(node2, dist, 1, edges)\n                \n        for k in n:\n            m = max(dist[k])\n            if m != INF:\n                if m < mmin: \n                    mmin = m\n                    ans = k\n                elif m == mmin: \n                    ans = min(ans, k)\n                    \n        return ans if ans != float('inf') else -1",
        "content": "Since there is atmost one outgoing edge with cycles, we can iterate this graph in simple manner as cdist function below. The logic briefly is as below. \\n1. Calculate distances between node1 and other reachable nodes. \\n2. Do the same as (1) for node 2\\n3. Iterate the nodes that are on the path for both distances and find max. \\n4. find min of maxes and keep track of minimum index. \\n\\nIf there was a constraint that node1 and node2 have a guarenteed path between them, the problem could have been simpler, to construct find the shortestPath between node1 -> node 2 and the ans is one of the nodes in between. Thats not the case ! \\n\\n```\\nclass Solution:\\n    def cdist(self, it, distArray, distArrayIndex, edges):\\n        rdist = 0 \\n        nodes = []\\n        while it != -1 and distArray[it][distArrayIndex] > rdist:\\n            distArray[it][distArrayIndex] = rdist\\n            nodes.append(it)\\n            it = edges[it]\\n            rdist += 1\\n        return nodes\\n            \\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        INF = float(\\'inf\\')\\n        dist = defaultdict(lambda: [INF,INF])\\n        mmin, ans = INF, INF\\n               \\n        n = self.cdist(node1, dist, 0, edges)\\n        n += self.cdist(node2, dist, 1, edges)\\n                \\n        for k in n:\\n            m = max(dist[k])\\n            if m != INF:\\n                if m < mmin: \\n                    mmin = m\\n                    ans = k\\n                elif m == mmin: \\n                    ans = min(ans, k)\\n                    \\n        return ans if ans != float(\\'inf\\') else -1\\n```\\n\\nA slightly modified logic, \\n\\n```\\nclass Solution:\\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        INF = float(\\'inf\\')\\n        N = len(edges)\\n        dist_node1 = [INF for _ in range(N)]\\n        dist_node2 = [INF for _ in range(N)]\\n        \\n        def dfs(node, di, d):\\n            if d[node] > di: \\n                d[node] = di\\n                if edges[node] != -1:\\n                    dfs(edges[node], di+1, d)\\n        \\n        dfs(node1, 0, dist_node1)\\n        dfs(node2, 0, dist_node2)\\n\\n        for i in range(N):\\n            dist_node1[i] = max(dist_node1[i], dist_node2[i])\\n                        \\n        ans = dist_node1.index(min(dist_node1))\\n        return ans if dist_node1[ans] != INF else -1\\n",
        "level": "medium",
        "type": [
            "undefined keywords from other languages",
            "unclosed string",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def cdist(self, it, distArray, distArrayIndex, edges):\n        rdist = 0 \n        nodes = []\n        while it != -1 and distArray[it+1][distArrayIndex] > rdist:\n            distArray[it][distArrayIndex] = rdist\n            nodes.append(it)\n            it = edges[it]\n            rdist += 1\n        return nodes\n            \n    def closestMeetingNode(self, edges: List<int>, node1: int, node2: int) -> int:\n        INF = float('inf')\n        dist = defaultdict(lambda: [INF,INF])\n        mmin, ans = INF, INF\n               \n        n = self.cdist(node1, dist, 0, edges)\n        n += var self.cdist(node2, dist, 1, edges)\n                \n        for k in n:\n            m = max(dist[k])\n            if m != INF:\n                if m < mmin: \n                    mmin = m\n                    ans = k\n                elif m == mmin: \n                    ans = min(ans, k)\n                    \n        return ans if ans != 'inf' else -1\n"
    },
    {
        "slug": "adding-two-negabinary-numbers",
        "description": "Given two numbers arr1 and arr2 in base -2, return the result of adding them together.\nEach number is given in array format:\u00a0 as an array of 0s and 1s, from most significant bit to least significant bit.\u00a0 For example, arr = [1,1,0,1] represents the number (-2)^3\u00a0+ (-2)^2 + (-2)^0 = -3.\u00a0 A number arr in array, format is also guaranteed to have no leading zeros: either\u00a0arr == [0] or arr[0] == 1.\nReturn the result of adding arr1 and arr2 in the same format: as an array of 0s and 1s with no leading zeros.",
        "examples": [
            "Input: arr1 = [1,1,1,1,1], arr2 = [1,0,1]\nOutput: [1,0,0,0,0]\nExplanation: arr1 represents 11, arr2 represents 5, the output represents 16.",
            "Input: arr1 = [0], arr2 = [0]\nOutput: [0]",
            "Input: arr1 = [0], arr2 = [1]\nOutput: [1]"
        ],
        "constraints": "1 <= arr1.length,\u00a0arr2.length <= 1000\narr1[i]\u00a0and arr2[i] are\u00a00 or 1\narr1 and arr2 have no leading zeros",
        "oracle_code": "class Solution:\n    def addBinary(self, A, B):\n        res = []\n        carry = 0\n        while A or B or carry:\n            carry += (A or [0]).pop() + (B or [0]).pop()\n            res.append(carry & 1)\n            carry = carry >> 1\n        return res[::-1]\n\n    def addNegabinary(self, A, B):\n        res = []\n        carry = 0\n        while A or B or carry:\n            carry += (A or [0]).pop() + (B or [0]).pop()\n            res.append(carry & 1)\n            carry = -(carry >> 1)\n        while len(res) > 1 and res[-1] == 0:\n            res.pop()\n        return res[::-1]",
        "content": "# Code\\n```\\nclass Solution:\\n    def addBinary(self, A, B):\\n        res = []\\n        carry = 0\\n        while A or B or carry:\\n            carry += (A or [0]).pop() + (B or [0]).pop()\\n            res.append(carry & 1)\\n            carry = carry >> 1\\n        return res[::-1]\\n\\n    def addNegabinary(self, A, B):\\n        res = []\\n        carry = 0\\n        while A or B or carry:\\n            carry += (A or [0]).pop() + (B or [0]).pop()\\n            res.append(carry & 1)\\n            carry = -(carry >> 1)\\n        while len(res) > 1 and res[-1] == 0:\\n            res.pop()\\n        return res[::-1]\\n```",
        "level": "medium",
        "type": [
            "colon missing",
            "wrong comment mark",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def addBinary(self, A, B):\n        res = []\n        carry = 0\n        while A or B or carry:\n            carry += (A or [0]).pop() + (B or [0]).pop()\n            res.append(carry & 1)\n            carry = carry >> 1\n        [1]  \n\ndef addNegabinary(self, A, B):\n    res = []\n    carry = 0\n    while A or B or carry:\n        carry += (A or [0]).pop() + (B or [0]).pop()\n        res.append(carry & 1)\n        carry = -(carry >> 1)\n    while len(res) > 1 and res[-1] == 0:\n        res.pop()\n    \n\n\n[1]  \n"
    },
    {
        "slug": "can-place-flowers",
        "description": "You have a long flowerbed in which some of the plots are planted, and some are not. However, flowers cannot be planted in adjacent plots.\nGiven an integer array flowerbed containing 0's and 1's, where 0 means empty and 1 means not empty, and an integer n, return true\u00a0if n new flowers can be planted in the flowerbed without violating the no-adjacent-flowers rule and false otherwise.",
        "examples": [
            "Input: flowerbed = [1,0,0,0,1], n = 1\nOutput: true",
            "Input: flowerbed = [1,0,0,0,1], n = 2\nOutput: false"
        ],
        "constraints": "1 <= flowerbed.length <= 2 * 104\nflowerbed[i] is 0 or 1.\nThere are no two adjacent flowers in flowerbed.\n0 <= n <= flowerbed.length",
        "oracle_code": "class Solution:\n    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:\n        flowerbed=[0]+flowerbed+[0]\n        for i in range(1,len(flowerbed)-1):\n            if flowerbed[i]==0 and flowerbed[i+1]==0 and flowerbed[i-1]==0:flowerbed[i]=1;n-=1\n        if n<=0:return True\n        return False",
        "content": "![image.png](https://assets.leetcode.com/users/images/c82b49a3-d51e-40a4-b4b5-197596cb28f2_1691328287.5834074.png)\\n\\n\\n\\n\\n\\nPLease UPVOTE \\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:\\n        flowerbed=[0]+flowerbed+[0]\\n        for i in range(1,len(flowerbed)-1):\\n            if flowerbed[i]==0 and flowerbed[i+1]==0 and flowerbed[i-1]==0:flowerbed[i]=1;n-=1\\n        if n<=0:return True\\n        return False\\n```",
        "level": "easy",
        "type": [
            "colon missing",
            "undefined objects",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:\n        flowerbed=[0]+flowerbed+[0]\n        for i in range(1,len(flowerbed)-1)\n            if flowerbed[i]==0 and flowerbed[i+2]==0 and flowerbed[i-1]==0:flowerbed[i]=1;randomFluid-=1\n        if n<=0:return True\n        return False\n"
    },
    {
        "slug": "construct-quad-tree",
        "description": "Given a n * n matrix grid of 0's and 1's only. We want to represent grid with a Quad-Tree.\nReturn the root of the Quad-Tree representing grid.\nA Quad-Tree is a tree data structure in which each internal node has exactly four children. Besides, each node has two attributes:\n\nval: True if the node represents a grid of 1's or False if the node represents a grid of 0's. Notice that you can assign the val to True or False when isLeaf is False, and both are accepted in the answer.\nisLeaf: True if the node is a leaf node on the tree or False if the node has four children.\n\n\nclass Node {\n    public boolean val;\n    public boolean isLeaf;\n    public Node topLeft;\n    public Node topRight;\n    public Node bottomLeft;\n    public Node bottomRight;\n}\nWe can construct a Quad-Tree from a two-dimensional area using the following steps:\n\nIf the current grid has the same value (i.e all 1's or all 0's) set isLeaf True and set val to the value of the grid and set the four children to Null and stop.\nIf the current grid has different values, set isLeaf to False and set val to any value and divide the current grid into four sub-grids as shown in the photo.\nRecurse for each of the children with the proper sub-grid.\n\n\nIf you want to know more about the Quad-Tree, you can refer to the wiki.\nQuad-Tree format:\nYou don't need to read this section for solving the problem. This is only if you want to understand the output format here. The output represents the serialized format of a Quad-Tree using level order traversal, where null signifies a path terminator where no node exists below.\nIt is very similar to the serialization of the binary tree. The only difference is that the node is represented as a list [isLeaf, val].\nIf the value of isLeaf or val is True we represent it as 1 in the list [isLeaf, val] and if the value of isLeaf or val is False we represent it as 0.",
        "examples": [
            "Input: grid = [[0,1],[1,0]]\nOutput: [[0,1],[1,0],[1,1],[1,1],[1,0]]\nExplanation: The explanation of this example is shown below:\nNotice that 0 represents False and 1 represents True in the photo representing the Quad-Tree.",
            "Input: grid = [[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0]]\nOutput: [[0,1],[1,1],[0,1],[1,1],[1,0],null,null,null,null,[1,0],[1,0],[1,1],[1,1]]\nExplanation: All values in the grid are not the same. We divide the grid into four sub-grids.\nThe topLeft, bottomLeft and bottomRight each has the same value.\nThe topRight have different values so we divide it into 4 sub-grids where each has the same value.\nExplanation is shown in the photo below:"
        ],
        "constraints": "n == grid.length == grid[i].length\nn == 2x where 0 <= x <= 6",
        "oracle_code": "class Solution:\n    def construct(self, grid: List[List[int]]) -> 'Node':\n        level = len(grid)\n        root = None\n        if level >= 1:\n            root = self.buildTree(grid, 0, level, 0, level, level)\n        return root\n        \n        \n    def buildTree(self, grid, rs, re, cs, ce, level):\n        if level == 1:\n            # this is a leaf node:\n            return Node(grid[rs][cs], True, None, None, None, None)\n        \n        next_level = level // 2\n        tl = self.buildTree(grid, rs, re - next_level, cs, ce - next_level, next_level)\n        tr = self.buildTree(grid, rs, re - next_level, ce - next_level, ce, next_level)\n        bl = self.buildTree(grid, re - next_level, re, cs, ce - next_level, next_level)\n        br = self.buildTree(grid, re - next_level, re, ce - next_level, ce, next_level)\n        \n        if tl.isLeaf and tr.isLeaf and bl.isLeaf and br.isLeaf:\n            if tl.val == tr.val == bl.val == br.val:\n                new_node = Node(tl.val, True, None, None, None, None)\n            else:\n                new_node = Node(tl.val, False, tl, tr, bl, br)\n        else:\n            new_node = Node(tl.val, False, tl, tr, bl, br)\n            \n        return new_node",
        "content": "This is a simple recursion problem.\\n\\nWe can go from top to bottom (i.e., 2 ^ n -->  1) and build the tree based on the return value of the four children.\\n\\n(1) if the number of element in the grid region is 1, this is a leaf node, we build a new node and return it;\\n(2) check the four children, if they all are leaf nodes and have the same value, we can merge the four nodes by create a new leaf node;\\n(3) otherwise, just build a new node from the four children.\\n\\n\\n```\\nclass Solution:\\n    def construct(self, grid: List[List[int]]) -> \\'Node\\':\\n        level = len(grid)\\n        root = None\\n        if level >= 1:\\n            root = self.buildTree(grid, 0, level, 0, level, level)\\n        return root\\n        \\n        \\n    def buildTree(self, grid, rs, re, cs, ce, level):\\n        if level == 1:\\n            # this is a leaf node:\\n            return Node(grid[rs][cs], True, None, None, None, None)\\n        \\n        next_level = level // 2\\n        tl = self.buildTree(grid, rs, re - next_level, cs, ce - next_level, next_level)\\n        tr = self.buildTree(grid, rs, re - next_level, ce - next_level, ce, next_level)\\n        bl = self.buildTree(grid, re - next_level, re, cs, ce - next_level, next_level)\\n        br = self.buildTree(grid, re - next_level, re, ce - next_level, ce, next_level)\\n        \\n        if tl.isLeaf and tr.isLeaf and bl.isLeaf and br.isLeaf:\\n            if tl.val == tr.val == bl.val == br.val:\\n                new_node = Node(tl.val, True, None, None, None, None)\\n            else:\\n                new_node = Node(tl.val, False, tl, tr, bl, br)\\n        else:\\n            new_node = Node(tl.val, False, tl, tr, bl, br)\\n            \\n        return new_node\\n```",
        "level": "medium",
        "type": [
            "colon missing",
            "indexing error",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def construct(self, grid: List[List[int]]) -> 'Node':\n        level = len(grid)\n        root = None\n        if level >= 1:\n            root = self.buildTree(grid, 0, level, 0, level, level)\n        return root  \n        \n    def buildTree(self, grid, rs, re, cs, ce, level)\n        if level == 1:\n            # this is a leaf node:\n            return Node(grid[rs][cs+1], True, None, None, None, None)\n        \n        next_level = level // 2\n        tl = self.buildTree(grid, rs, re - next_level, cs, ce - next_level, next_level)\n        tr = self.buildTree(grid, rs, re - next_level, cs, ce - next_level, next_level)\n        bl = self.buildTree(grid, re - next_level, re, cs, ce - next_level, next_level)\n        br = self.buildTree(grid, re - next_level, re, cs, ce - next_level, next_level)\n        \n        if tl.isLeaf and tr.isLeaf and bl.isLeaf and br.isLeaf:\n            if tl.val == tr.val == bl.val == br.val:\n                new_node = Node(tl.val, True, None, None, None, None)\n            else:\n                new_node = Node(tl.val, False, tl, tr, bl, br)\n            else:\n                new_node = Node(tl.val, False, tl, tr, bl, br)\n            \n        return new_node\n\n"
    },
    {
        "slug": "check-if-two-string-arrays-are-equivalent",
        "description": "Given two string arrays word1 and word2, return true if the two arrays represent the same string, and false otherwise.\nA string is represented by an array if the array elements concatenated in order forms the string.",
        "examples": [
            "Input: word1 = [\"ab\", \"c\"], word2 = [\"a\", \"bc\"]\nOutput: true\nExplanation:\nword1 represents string \"ab\" + \"c\" -> \"abc\"\nword2 represents string \"a\" + \"bc\" -> \"abc\"\nThe strings are the same, so return true.",
            "Input: word1 = [\"a\", \"cb\"], word2 = [\"ab\", \"c\"]\nOutput: false",
            "Input: word1  = [\"abc\", \"d\", \"defg\"], word2 = [\"abcddefg\"]\nOutput: true"
        ],
        "constraints": "1 <= word1.length, word2.length <= 103\n1 <= word1[i].length, word2[i].length <= 103\n1 <= sum(word1[i].length), sum(word2[i].length) <= 103\nword1[i] and word2[i] consist of lowercase letters.",
        "oracle_code": "class Solution:\n    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) -> bool:\n        word3=\"\".join(word1)\n        word4=\"\".join(word2)\n        if word3==word4:\n            return True\n        else:\n            return False",
        "content": "**1**.First we will join the contents or concatenate the Strings present in the list using join()\\n**2**.then compare 2 list.\\n**3** if true return true else return false\\n```\\nclass Solution:\\n    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) -> bool:\\n        word3=\"\".join(word1)\\n        word4=\"\".join(word2)\\n        if word3==word4:\\n            return True\\n        else:\\n            return False\\n```\\n**code**\\nOnline Solution :\\n    -Thank you for this solution @jeevabharathiS\\n        \\n```\\nclass Solution:\\n    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) \\n        return((\"\".join(word1))==(\"\".join(word2)))\\n```",
        "level": "easy",
        "type": [
            "operation error",
            "parentheses mismatch",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution:\n    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) -> bool:\n        word3=\"\".join(word1.reverse()\n        word4=\"\".join(word2\n        if word3==word4:\n            return True\n        else:\n            return False\n"
    },
    {
        "slug": "can-place-flowers",
        "description": "You have a long flowerbed in which some of the plots are planted, and some are not. However, flowers cannot be planted in adjacent plots.\nGiven an integer array flowerbed containing 0's and 1's, where 0 means empty and 1 means not empty, and an integer n, return true\u00a0if n new flowers can be planted in the flowerbed without violating the no-adjacent-flowers rule and false otherwise.",
        "examples": [
            "Input: flowerbed = [1,0,0,0,1], n = 1\nOutput: true",
            "Input: flowerbed = [1,0,0,0,1], n = 2\nOutput: false"
        ],
        "constraints": "1 <= flowerbed.length <= 2 * 104\nflowerbed[i] is 0 or 1.\nThere are no two adjacent flowers in flowerbed.\n0 <= n <= flowerbed.length",
        "oracle_code": "class Solution:\n    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:\n        flowerbed=[0]+flowerbed+[0]\n        for i in range(1,len(flowerbed)-1):\n            if flowerbed[i]==0 and flowerbed[i+1]==0 and flowerbed[i-1]==0:flowerbed[i]=1;n-=1\n        if n<=0:return True\n        return False",
        "content": "![image.png](https://assets.leetcode.com/users/images/c82b49a3-d51e-40a4-b4b5-197596cb28f2_1691328287.5834074.png)\\n\\n\\n\\n\\n\\nPLease UPVOTE \\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:\\n        flowerbed=[0]+flowerbed+[0]\\n        for i in range(1,len(flowerbed)-1):\\n            if flowerbed[i]==0 and flowerbed[i+1]==0 and flowerbed[i-1]==0:flowerbed[i]=1;n-=1\\n        if n<=0:return True\\n        return False\\n```",
        "level": "easy",
        "type": [
            "undefined keywords from other languages",
            "== and = confusion",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:\n        flowerbed=[0]+flowerbed+[0]\n        for i in range(1,len(flowerbed)-1):\n            if (flowerbed[i]==0 and flowerbed[i+2]=0 and flowerbed[i-1]==0): flowerbed[i]=1; n-=1\n            else if(flowerbed[i]==1): n-=1\n        if n<=0:return True\n        return False\n"
    },
    {
        "slug": "number-complement",
        "description": "The complement of an integer is the integer you get when you flip all the 0's to 1's and all the 1's to 0's in its binary representation.\n\nFor example, The integer 5 is \"101\" in binary and its complement is \"010\" which is the integer 2.\n\nGiven an integer num, return its complement.",
        "examples": [
            "Input: num = 5\nOutput: 2\nExplanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2.",
            "Input: num = 1\nOutput: 0\nExplanation: The binary representation of 1 is 1 (no leading zero bits), and its complement is 0. So you need to output 0."
        ],
        "constraints": "1 <= num < 231\n\n\u00a0\nNote: This question is the same as 1009: https://leetcode.com/problems/complement-of-base-10-integer/",
        "oracle_code": "class Solution:\n    def findComplement(self, num: int) -> int:\n        com = ''\n        while num > 0 :\n            \n            if num % 2 == 1:\n                com += '0'\n            else:\n                com += '1'\n            num = num // 2\n        return int(com[::-1],2)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findComplement(self, num: int) -> int:\\n        com = \\'\\'\\n        while num > 0 :\\n            \\n            if num % 2 == 1:\\n                com += \\'0\\'\\n            else:\\n                com += \\'1\\'\\n            num = num // 2\\n        return int(com[::-1],2)\\n        \\n\\n```",
        "level": "easy",
        "type": [
            "operation error",
            "undefined keywords from other languages",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n    def findComplement(self, num: int) -> int:\n        com = ''\n        while num > 0 :\n            \n            if num % 2 = 1:\n                com += 0\n            else:\n                com += 1\n            num = num // 2\n        return int(com,2)\n"
    },
    {
        "slug": "length-of-the-longest-valid-substring",
        "description": "You are given a string word and an array of strings forbidden.\nA string is called valid if none of its substrings are present in forbidden.\nReturn the length of the longest valid substring of the string word.\nA substring is a contiguous sequence of characters in a string, possibly empty.",
        "examples": [
            "Input: word = \"cbaaaabc\", forbidden = [\"aaa\",\"cb\"]\nOutput: 4\nExplanation: There are 11 valid substrings in word: \"c\", \"b\", \"a\", \"ba\", \"aa\", \"bc\", \"baa\", \"aab\", \"ab\", \"abc\"and \"aabc\". The length of the longest valid substring is 4. \nIt can be shown that all other substrings contain either \"aaa\" or \"cb\" as a substring.",
            "Input: word = \"leetcode\", forbidden = [\"de\",\"le\",\"e\"]\nOutput: 4\nExplanation: There are 11 valid substrings in word: \"l\", \"t\", \"c\", \"o\", \"d\", \"tc\", \"co\", \"od\", \"tco\", \"cod\", and \"tcod\". The length of the longest valid substring is 4.\nIt can be shown that all other substrings contain either \"de\", \"le\", or \"e\" as a substring."
        ],
        "constraints": "1 <= word.length <= 105\nword consists only of lowercase English letters.\n1 <= forbidden.length <= 105\n1 <= forbidden[i].length <= 10\nforbidden[i] consists only of lowercase English letters.",
        "oracle_code": "class Solution:\n    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int:\n        trie = {}\n        for f in forbidden:\n            t = trie\n            for c in f:\n                if c not in t:\n                    t[c] = {}\n                t = t[c]\n            t[\"end\"] = True\n        \n        def isForbidden(s):\n            t = trie\n            counter = 0\n            for c in s:\n                if c not in t:\n                    return False\n                t = t[c]\n                counter += 1\n                if \"end\" in t:\n                    return counter\n            return False\n        \n        res = 0\n        j = len(word)\n        for i in range(len(word) - 1, -1, -1):\n            truc = isForbidden(word[i:j])\n            if truc:\n                j = i + truc - 1\n            res = max(res, j - i)\n        return res",
        "content": "Put all the forbidden strings into a trie, so that for each string `s`, we can check every substring starts from the beginning (i.e. `s[:1]`,  `s[:2]` ...  `s[:len(s)]`) in one travesal.\\n\\nUse a sliding window to iterate from back to front, each time, we only need to check whether the substrings starting from the new character is forbidden. If the substring is forbidden, then we truncate the string and continue to search.\\n\\nUsing a trie can make the foibidden check fails faster and can deal with longer foibidden strings.\\n\\n# Code\\n```\\nclass Solution:\\n    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int:\\n        trie = {}\\n        for f in forbidden:\\n            t = trie\\n            for c in f:\\n                if c not in t:\\n                    t[c] = {}\\n                t = t[c]\\n            t[\"end\"] = True\\n        \\n        def isForbidden(s):\\n            t = trie\\n            counter = 0\\n            for c in s:\\n                if c not in t:\\n                    return False\\n                t = t[c]\\n                counter += 1\\n                if \"end\" in t:\\n                    return counter\\n            return False\\n        \\n        res = 0\\n        j = len(word)\\n        for i in range(len(word) - 1, -1, -1):\\n            truc = isForbidden(word[i:j])\\n            if truc:\\n                j = i + truc - 1\\n            res = max(res, j - i)\\n        return res\\n```",
        "level": "hard",
        "type": [
            "undefined methods",
            "operation error",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int:\n        trie = {}\n        for f in forbidden:\n            t = trie\n            for c in f:\n                if c not in t:\n                    t[c] = {}\n                t = t[c]\n            t[\"end\"] = True\n        \n        def isForbidden(s):\n            t = trie\n            counter = 0\n            for c in s:\n                if c not in t:\n                    return False\n                t = t[c]\n                counter += 1\n                if \"end\" in t:\n                    return counter\n            return False\n        \n        res = 0\n        j = len(word) + 1\n        for i in range(len(word) - 1, -1, -1):\n            truc = isForbidden(word[i:j])\n            if truc:\n                j = i - truc - 1\n                undefinedFunction(word)\n            res = max(res, j - i)\n        return res\n"
    },
    {
        "slug": "count-the-repetitions",
        "description": "We define str = [s, n] as the string str which consists of the string s concatenated n times.\n\nFor example, str == [\"abc\", 3] ==\"abcabcabc\".\n\nWe define that string s1 can be obtained from string s2 if we can remove some characters from s2 such that it becomes s1.\n\nFor example, s1 = \"abc\" can be obtained from s2 = \"abdbec\" based on our definition by removing the bolded underlined characters.\n\nYou are given two strings s1 and s2 and two integers n1 and n2. You have the two strings str1 = [s1, n1] and str2 = [s2, n2].\nReturn the maximum integer m such that str = [str2, m] can be obtained from str1.",
        "examples": [
            "Input: s1 = \"acb\", n1 = 4, s2 = \"ab\", n2 = 2\nOutput: 2",
            "Input: s1 = \"acb\", n1 = 1, s2 = \"acb\", n2 = 1\nOutput: 1"
        ],
        "constraints": "1 <= s1.length, s2.length <= 100\ns1 and s2 consist of lowercase English letters.\n1 <= n1, n2 <= 106",
        "oracle_code": "class Solution:\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\n\n        rec, track = [0], defaultdict(int) \n        ct = start = ptr1 = ptr2 = 0\n\n        if not set(s2).issubset(set(s1)): return 0\n\n        s1 = ''.join(char for char in s1 if char in set(s2))\n        \n        while True:\n            for char in s2:\n                ptr = s1.find(char, start)\n                if ptr == -1:\n                    ct += 1\n                    ptr = s1.find(char)\n                start = ptr+1\n            rec.append(ct + 1)\n\n            if rec[-1] > n1: return (len(rec)-2)//n2\n\n            if ptr not in track: track[ptr] = len(rec)-1\n            else: break\n        \n        cycleStart = rec[track[ptr]]\n        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]\n        rest = n1 - cycleStart\n        \n        rem = cycleStart + rest%cycle1\n\n        while rec[ptr2] <= rem: ptr2+= 1\n\n        return (cycle2 * (rest//cycle1) + ptr2-1)//n2",
        "content": "```\\nclass Solution:\\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\\n\\n        rec, track = [0], defaultdict(int) \\n        ct = start = ptr1 = ptr2 = 0\\n\\n        if not set(s2).issubset(set(s1)): return 0\\n\\n        s1 = \\'\\'.join(char for char in s1 if char in set(s2))\\n        \\n        while True:\\n            for char in s2:\\n                ptr = s1.find(char, start)\\n                if ptr == -1:\\n                    ct += 1\\n                    ptr = s1.find(char)\\n                start = ptr+1\\n            rec.append(ct + 1)\\n\\n            if rec[-1] > n1: return (len(rec)-2)//n2\\n\\n            if ptr not in track: track[ptr] = len(rec)-1\\n            else: break\\n        \\n        cycleStart = rec[track[ptr]]\\n        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]\\n        rest = n1 - cycleStart\\n        \\n        rem = cycleStart + rest%cycle1\\n\\n        while rec[ptr2] <= rem: ptr2+= 1\\n\\n        return (cycle2 * (rest//cycle1) + ptr2-1)//n2\\n```\\n[https://leetcode.com/problems/count-the-repetitions/submissions/864907562/](http://)\\n\\nI could be wrong, but I think that time is *O*(*N*) and space is *O*(*N*).",
        "level": "hard",
        "type": [
            "undefined methods",
            "undefined objects",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\n\n        rec, track = [0], defaultdict(int) \n        ct = start = ptr1 = undefinedVariable = 0\n\n        if not set(s2).issubset(set(s1)): return 0\n\n        s1 = ''.join(char for char in s1 if char in set(undefinedVariable))\n        \n        while True:\n            for char in s2:\n                ptr = s1.find(char, start)\n                if ptr == -1:\n                    ct += 1\n                    ptr = s1.find(char)\n                start = ptr+1\n            rec.append(ct + 1)\n\n            if rec[-1] > n1: return (len(rec)-2)//n2\n\n            if ptr not in track: track[ptr] = len(rec)-1\n            else: break\n        \n        cycleStart = rec[track[ptr]]\n        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]\n        rest = n1 - cycleStart\n        \n        rem = cycleStart + self.calculateRemainder(rest, cycle1)\n\n        while rec[ptr2] <= rem: ptr2+= 1\n\n        return (cycle2 * (rest//cycle1) + ptr2-2)//n2\n"
    },
    {
        "slug": "count-the-repetitions",
        "description": "We define str = [s, n] as the string str which consists of the string s concatenated n times.\n\nFor example, str == [\"abc\", 3] ==\"abcabcabc\".\n\nWe define that string s1 can be obtained from string s2 if we can remove some characters from s2 such that it becomes s1.\n\nFor example, s1 = \"abc\" can be obtained from s2 = \"abdbec\" based on our definition by removing the bolded underlined characters.\n\nYou are given two strings s1 and s2 and two integers n1 and n2. You have the two strings str1 = [s1, n1] and str2 = [s2, n2].\nReturn the maximum integer m such that str = [str2, m] can be obtained from str1.",
        "examples": [
            "Input: s1 = \"acb\", n1 = 4, s2 = \"ab\", n2 = 2\nOutput: 2",
            "Input: s1 = \"acb\", n1 = 1, s2 = \"acb\", n2 = 1\nOutput: 1"
        ],
        "constraints": "1 <= s1.length, s2.length <= 100\ns1 and s2 consist of lowercase English letters.\n1 <= n1, n2 <= 106",
        "oracle_code": "class Solution:\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\n\n        rec, track = [0], defaultdict(int) \n        ct = start = ptr1 = ptr2 = 0\n\n        if not set(s2).issubset(set(s1)): return 0\n\n        s1 = ''.join(char for char in s1 if char in set(s2))\n        \n        while True:\n            for char in s2:\n                ptr = s1.find(char, start)\n                if ptr == -1:\n                    ct += 1\n                    ptr = s1.find(char)\n                start = ptr+1\n            rec.append(ct + 1)\n\n            if rec[-1] > n1: return (len(rec)-2)//n2\n\n            if ptr not in track: track[ptr] = len(rec)-1\n            else: break\n        \n        cycleStart = rec[track[ptr]]\n        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]\n        rest = n1 - cycleStart\n        \n        rem = cycleStart + rest%cycle1\n\n        while rec[ptr2] <= rem: ptr2+= 1\n\n        return (cycle2 * (rest//cycle1) + ptr2-1)//n2",
        "content": "```\\nclass Solution:\\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\\n\\n        rec, track = [0], defaultdict(int) \\n        ct = start = ptr1 = ptr2 = 0\\n\\n        if not set(s2).issubset(set(s1)): return 0\\n\\n        s1 = \\'\\'.join(char for char in s1 if char in set(s2))\\n        \\n        while True:\\n            for char in s2:\\n                ptr = s1.find(char, start)\\n                if ptr == -1:\\n                    ct += 1\\n                    ptr = s1.find(char)\\n                start = ptr+1\\n            rec.append(ct + 1)\\n\\n            if rec[-1] > n1: return (len(rec)-2)//n2\\n\\n            if ptr not in track: track[ptr] = len(rec)-1\\n            else: break\\n        \\n        cycleStart = rec[track[ptr]]\\n        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]\\n        rest = n1 - cycleStart\\n        \\n        rem = cycleStart + rest%cycle1\\n\\n        while rec[ptr2] <= rem: ptr2+= 1\\n\\n        return (cycle2 * (rest//cycle1) + ptr2-1)//n2\\n```\\n[https://leetcode.com/problems/count-the-repetitions/submissions/864907562/](http://)\\n\\nI could be wrong, but I think that time is *O*(*N*) and space is *O*(*N*).",
        "level": "hard",
        "type": [
            "undefined methods",
            "indexing error",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\n\n        rec, track = [0], defaultdict(int) \n        ct = start = ptr1 = ptr2 = 0\n\n        if not set(s2).issubset(set(s1)): return 0\n\n        s1 = ''.join(char for char in s1 if char in set(s2))\n        \n        while True:\n            for char in s2:\n                ptr = s1.find(char, start)\n                if ptr == -1:\n                    ct += 1\n                    ptr = s1.find(char)\n                start = ptr+1\n            rec.append(ct + 1)\n\n            if rec[-1] >= n1: return (len(rec)-2)//n2\n\n            if ptr not in track: track[ptr] = len(rec)-1\n            else: break\n        \n        cycleStart = rec[track[ptr]]\n        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]\n        rest = n1 - cycleStart\n        \n        rem = cycleStart + self.calculateRemainder(rest, cycle1)\n\n        while rec[ptr2] <= rem: ptr2+= 1\n\n        return (cycle2 * (rest//cycle1) + ptr2-2)//n2\n"
    },
    {
        "slug": "kth-largest-element-in-an-array",
        "description": "Given an integer array nums and an integer k, return the kth largest element in the array.\nNote that it is the kth largest element in the sorted order, not the kth distinct element.\nCan you solve it without sorting?",
        "examples": [
            "Input: nums = [3,2,1,5,6,4], k = 2\nOutput: 5",
            "Input: nums = [3,2,3,1,2,4,5,5,6], k = 4\nOutput: 4"
        ],
        "constraints": "1 <= k <= nums.length <= 105\n-104 <= nums[i] <= 104",
        "oracle_code": "class Solution:\n    def findKthLargest(self, nums: List[int], k: int) -> int:\n        return sorted(nums)[-k]",
        "content": "# Approach\\n- Sorting\\n\\n# Complexity\\n- Time complexity: O(n*log(n))\\n\\n# Code\\n```\\nclass Solution:\\n    def findKthLargest(self, nums: List[int], k: int) -> int:\\n        return sorted(nums)[-k]\\n```",
        "level": "medium",
        "type": [
            "colon missing",
            "undefined objects",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution\n    def findKthLargest(self, nums: List[int], k: int -> int:\n        return sorted(no_nums)[-k]\n"
    },
    {
        "slug": "minimum-flips-to-make-a-or-b-equal-to-c",
        "description": "Given 3 positives numbers a, b and c. Return the minimum flips required in some bits of a and b to make (\u00a0a OR b == c\u00a0). (bitwise OR operation).\r\nFlip operation\u00a0consists of change\u00a0any\u00a0single bit 1 to 0 or change the bit 0 to 1\u00a0in their binary representation.",
        "examples": [
            "Input: a = 2, b = 6, c = 5\r\nOutput: 3\r\nExplanation: After flips a = 1 , b = 4 , c = 5 such that (a OR b == c)",
            "Input: a = 4, b = 2, c = 7\r\nOutput: 1",
            "Input: a = 1, b = 2, c = 3\r\nOutput: 0"
        ],
        "constraints": "1 <= a <= 10^9\n1 <= b\u00a0<= 10^9\n1 <= c\u00a0<= 10^9",
        "oracle_code": "class Solution:\n    def minFlips(self, a: int, b: int, c: int) -> int:\n        if a | b == c: return 0\n        c = ('0' * 32 + bin(c)[2:])[-32:]\n        a = ('0' * 32 + bin(a)[2:])[-32:]\n        b = ('0' * 32 + bin(b)[2:])[-32:]\n        \n        \n        cnt = 0\n        for i in range(len(c)):\n            if c[i] == '1':\n                if not (a[i] == c[i] or b[i] == c[i]):\n                    cnt += 1\n            else:\n                if a[i] != c[i]:\n                    cnt += 1\n                if b[i] != c[i]:\n                    cnt += 1\n        return cnt",
        "content": "# Code\\n\\n```\\nclass Solution:\\n    def minFlips(self, a: int, b: int, c: int) -> int:\\n        if a | b == c: return 0\\n        c = (\\'0\\' * 32 + bin(c)[2:])[-32:]\\n        a = (\\'0\\' * 32 + bin(a)[2:])[-32:]\\n        b = (\\'0\\' * 32 + bin(b)[2:])[-32:]\\n        \\n        \\n        cnt = 0\\n        for i in range(len(c)):\\n            if c[i] == \\'1\\':\\n                if not (a[i] == c[i] or b[i] == c[i]):\\n                    cnt += 1\\n            else:\\n                if a[i] != c[i]:\\n                    cnt += 1\\n                if b[i] != c[i]:\\n                    cnt += 1\\n        return cnt\\n```\\n\\n## Bit Manipulation\\n```\\nclass Solution:\\n    def minFlips(self, a: int, b: int, c: int) -> int:\\n        return bin((a | b) ^ c).count(\\'1\\') + bin(a & b & ((a | b) ^ c)).count(\\'1\\')\\n```",
        "level": "medium",
        "type": [
            "undefined objects",
            "== and = confusion",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def minFlips(self, a: int, b: int, c: int) -> int:\n        if a | b = c: return 0\n        c = ('0' * 32 + bin(c)[2:])[-32:]\n        a = ('0' * 32 + bin(a)[2:])[-32:]\n        b = ('0' * 32 + bin(b)[2:])[-32:]\n        \n        \n        cnt = 0\n        for i in range(len(c)):\n            if c[i] == '0':\n                if not (a[i] == c[i] or b[i] == c[i]):\n                    cnt += 1\n            else:\n                if a[i] != c[i]:\n                    cnt += 1\n                if d[i] != c[i]: \n                    cnt += 1\n        return cnt\n"
    },
    {
        "slug": "check-if-string-is-transformable-with-substring-sort-operations",
        "description": "Given two strings s and t, transform string s into string t using the following operation any number of times:\n\nChoose a non-empty substring in s and sort it in place so the characters are in ascending order.\n\n\t\nFor example, applying the operation on the underlined substring in \"14234\" results in \"12344\".\n\n\n\nReturn true if it is possible to transform s into t. Otherwise, return false.\nA substring is a contiguous sequence of characters within a string.",
        "examples": [
            "Input: s = \"84532\", t = \"34852\"\nOutput: true\nExplanation: You can transform s into t using the following sort operations:\n\"84532\" (from index 2 to 3) -> \"84352\"\n\"84352\" (from index 0 to 2) -> \"34852\"",
            "Input: s = \"34521\", t = \"23415\"\nOutput: true\nExplanation: You can transform s into t using the following sort operations:\n\"34521\" -> \"23451\"\n\"23451\" -> \"23415\"",
            "Input: s = \"12345\", t = \"12435\"\nOutput: false"
        ],
        "constraints": "s.length == t.length\n1 <= s.length <= 105\ns and t consist of only digits.",
        "oracle_code": "class BIT():\n    def __init__(self, n):\n        self.n = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        ans = 0\n        i += 1\n        while i > 0:\n            ans += self.tree[i]\n            i -= (i & (-i))\n        return ans\n\n    def update(self, i, value):\n        i += 1\n        while i <= self.n:\n            self.tree[i] += value\n            i += (i & (-i))\n\n\nclass Solution:\n    def isTransformable(self, s: str, t: str) -> bool:\n        if Counter(s)!=Counter(t):\n            return False\n        ind = defaultdict(deque)\n        for id, i in enumerate(t):\n            ind[i].append(id)\n        a = []\n        for i in s:\n            a.append(ind[i].popleft())\n        n=len(a)\n        bt=BIT(n+1)\n        ind=defaultdict(lambda :-1)\n        for i in range(n):\n            inv=bt.sum(n)-bt.sum(a[i])\n            bt.update(a[i],1)\n            for dig in range(int(s[i])-1,-1,-1):\n                if ind[dig]>=i-inv:\n                    return False\n            ind[int(s[i])]=i-inv\n        return True",
        "content": "\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass BIT():\\n    def __init__(self, n):\\n        self.n = n\\n        self.tree = [0] * (n + 1)\\n\\n    def sum(self, i):\\n        ans = 0\\n        i += 1\\n        while i > 0:\\n            ans += self.tree[i]\\n            i -= (i & (-i))\\n        return ans\\n\\n    def update(self, i, value):\\n        i += 1\\n        while i <= self.n:\\n            self.tree[i] += value\\n            i += (i & (-i))\\n\\n\\nclass Solution:\\n    def isTransformable(self, s: str, t: str) -> bool:\\n        if Counter(s)!=Counter(t):\\n            return False\\n        ind = defaultdict(deque)\\n        for id, i in enumerate(t):\\n            ind[i].append(id)\\n        a = []\\n        for i in s:\\n            a.append(ind[i].popleft())\\n        n=len(a)\\n        bt=BIT(n+1)\\n        ind=defaultdict(lambda :-1)\\n        for i in range(n):\\n            inv=bt.sum(n)-bt.sum(a[i])\\n            bt.update(a[i],1)\\n            for dig in range(int(s[i])-1,-1,-1):\\n                if ind[dig]>=i-inv:\\n                    return False\\n            ind[int(s[i])]=i-inv\\n        return True\\n\\n\\n```",
        "level": "hard",
        "type": [
            "indentation error",
            "colon missing",
            "operation error"
        ],
        "buggy_code": "\nclass BIT():\n    def __init__(self, n):\n        self.n = n\n    self.tree = [0] * (n + 1)\n\n    def sum(self, i)\n        ans = 0\n        i += 1\n        while i > 0:\n            ans += self.tree[i]\n            i -= (i & (-i))\n        return ans\n\n    def update(self, i, value):\n        i += 1\n        while i <= self.n:\n            self.tree[i] += value\n            i -= (i & (-i))  \n\n\nclass Solution:\n    def isTransformable(self, s: str, t: str) -> bool:\n        if Counter(s)!=Counter(t):\n            return False\n        ind = defaultdict(deque)\n        for id, i in enumerate(t):\n            ind[i].append(id)\n        a = []\n        for i in s:\n            a.append(ind[i].popleft())\n        n=len(a)\n        bt=BIT(n+1)\n        ind=defaultdict(lambda :-1)\n        for i in range(n):\n            inv=bt.sum(n)-bt.sum(a[i])\n            bt.update(a[i],1)\n            for dig in range(int(s[i])-1,-1,-1):\n                if ind[dig]>=i-inv:\n                    return False\n            ind[int(s[i])]=i-inv\n        return True\n"
    },
    {
        "slug": "median-of-two-sorted-arrays",
        "description": "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\nThe overall run time complexity should be O(log (m+n)).",
        "examples": [
            "Input: nums1 = [1,3], nums2 = [2]\nOutput: 2.00000\nExplanation: merged array = [1,2,3] and median is 2.",
            "Input: nums1 = [1,2], nums2 = [3,4]\nOutput: 2.50000\nExplanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5."
        ],
        "constraints": "nums1.length == m\nnums2.length == n\n0 <= m <= 1000\n0 <= n <= 1000\n1 <= m + n <= 2000\n-106 <= nums1[i], nums2[i] <= 106",
        "oracle_code": "class Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        p1 = 0\n        p2 = 0\n        new = []\n        while p1 < len(nums1) and p2 < len(nums2):\n            if nums1[p1] < nums2[p2]:\n                new.append(nums1[p1])\n                p1 += 1\n            else:\n                new.append(nums2[p2])\n                p2 += 1\n        while p1 < len(nums1):\n            new.append(nums1[p1])\n            p1 += 1\n        while p2 < len(nums2):\n            new.append(nums2[p2])\n            p2+= 1\n        if len(new) % 2 == 0:\n            index = len(new) // 2\n            median = (new[index] + new[index-1]) / 2\n        else:\n            median = float(new[len(new)//2])\n        return median",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind this approach is to merge the two sorted arrays while maintaining the order, and then finding the median based on the length of the merged array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize two pointers, p1 and p2, for the two input arrays nums1 and nums2, respectively, both starting at index 0.\\n2. Create an empty list new to store the merged array.\\n3. Iterate through both arrays using the pointers. Compare the elements pointed to by p1 and p2. Append the smaller element to the new array and increment the corresponding pointer.\\n4. After the iteration, there might be remaining elements in one of the arrays. Iterate through the remaining elements and append them to the new array.\\n5. Calculate the median based on the length of the new array. If the length is even, take the average of the middle two elements. If the length is odd, take the middle element.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(m + n), where m and n are the lengths of the two input arrays.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(m + n), as the merged array new can contain all the elements from the two input arrays.\\n\\n# Code\\n```\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        p1 = 0\\n        p2 = 0\\n        new = []\\n        while p1 < len(nums1) and p2 < len(nums2):\\n            if nums1[p1] < nums2[p2]:\\n                new.append(nums1[p1])\\n                p1 += 1\\n            else:\\n                new.append(nums2[p2])\\n                p2 += 1\\n        while p1 < len(nums1):\\n            new.append(nums1[p1])\\n            p1 += 1\\n        while p2 < len(nums2):\\n            new.append(nums2[p2])\\n            p2+= 1\\n        if len(new) % 2 == 0:\\n            index = len(new) // 2\\n            median = (new[index] + new[index-1]) / 2\\n        else:\\n            median = float(new[len(new)//2])\\n        return median\\n```",
        "level": "hard",
        "type": [
            "variable value error",
            "colon missing",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float\n        p1 = 0\n        p2 = 0\n        new = []\n        while p1 < len(nums1) and p2 < len(nums2):\n            if nums1[p1] < nums2[p2]:\n                new.append(nums1[p1])\n                p1 = 1\n            else:\n                new.append(nums2[p2])\n                p2 += 1\n        while p1 < len(nums1):\n            new.append(nums1[p1])\n            p2 += 1\n        while p2 < len(nums2):\n            new.append(nums2[p2])\n            p1 += 1\n\n        if len(new) % 2 == 0:\n            index = len(new) // 2\n            median = (new[index] + new[index-1]) / 2\n        else:\n            median = float(new[len(new)//2])\n        return median\n"
    },
    {
        "slug": "restore-ip-addresses",
        "description": "A valid IP address consists of exactly four integers separated by single dots. Each integer is between 0 and 255 (inclusive) and cannot have leading zeros.\n\nFor example, \"0.1.2.201\" and \"192.168.1.1\" are valid IP addresses, but \"0.011.255.245\", \"192.168.1.312\" and \"192.168@1.1\" are invalid IP addresses.\n\nGiven a string s containing only digits, return all possible valid IP addresses that can be formed by inserting dots into s. You are not allowed to reorder or remove any digits in s. You may return the valid IP addresses in any order.",
        "examples": [
            "Input: s = \"25525511135\"\nOutput: [\"255.255.11.135\",\"255.255.111.35\"]",
            "Input: s = \"0000\"\nOutput: [\"0.0.0.0\"]",
            "Input: s = \"101023\"\nOutput: [\"1.0.10.23\",\"1.0.102.3\",\"10.1.0.23\",\"10.10.2.3\",\"101.0.2.3\"]"
        ],
        "constraints": "1 <= s.length <= 20\ns consists of digits only.",
        "oracle_code": "class Solution:\n    def restoreIpAddresses(self, s: str) -> List[str]:\n        res=[]\n        cur=[]\n        def backtrack(i):\n            if i==len(s) and len(cur)==4:\n                res.append(\".\".join(cur))\n                return\n            if len(cur)>4 or i>=len(s):\n                return\n            if s[i]=='0':\n                cur.append(s[i])\n                backtrack(i+1)\n                cur.pop()\n                return\n            j=0\n            while j<4 and i+j<len(s):\n                if int(s[i:i+j+1])<256:\n                    cur.append(s[i:i+j+1])\n                    backtrack(i+j+1)\n                    cur.pop()\n                j+=1\n        backtrack(0)\n        return res",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\njust take care with the processing number should be lower than len(s) and the length of current stack should be lower or equal 4.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(4)\\n# Code\\n```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        res=[]\\n        cur=[]\\n        def backtrack(i):\\n            if i==len(s) and len(cur)==4:\\n                res.append(\".\".join(cur))\\n                return\\n            if len(cur)>4 or i>=len(s):\\n                return\\n            if s[i]==\\'0\\':\\n                cur.append(s[i])\\n                backtrack(i+1)\\n                cur.pop()\\n                return\\n            j=0\\n            while j<4 and i+j<len(s):\\n                if int(s[i:i+j+1])<256:\\n                    cur.append(s[i:i+j+1])\\n                    backtrack(i+j+1)\\n                    cur.pop()\\n                j+=1\\n        backtrack(0)\\n        return res\\n\\n```",
        "level": "medium",
        "type": [
            "colon missing",
            "parentheses mismatch",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution():\n    def restoreIpAddresses(self, s: str) -> List[str]:\n        res=[]\n        cur=[]\n        def backtrack(i:\n            if i==len(s) and len(cur)==4:\n                res.append(\".\".join(cur))\n                return\n            if len(cur)>4 or i>len(s):\n                return\n            if s[i]=='0':\n                cur.append(s[i])\n                backtrack(i+1)\n                cur.pop()\n                return\n            j=0\n            while j<4 and i+j<len(s)\n                if int(s[i:i+j+1])<256:\n                    cur.append(s[i:i+j+1])\n                    backtrack(i+j+1)\n                    cur.pop()\n                j+=1\n        backtrack(0)\n        return res\n"
    },
    {
        "slug": "find-words-that-can-be-formed-by-characters",
        "description": "You are given an array of strings words and a string chars.\nA string is good if it can be formed by characters from chars (each character can only be used once).\nReturn the sum of lengths of all good strings in words.",
        "examples": [
            "Input: words = [\"cat\",\"bt\",\"hat\",\"tree\"], chars = \"atach\"\nOutput: 6\nExplanation: The strings that can be formed are \"cat\" and \"hat\" so the answer is 3 + 3 = 6.",
            "Input: words = [\"hello\",\"world\",\"leetcode\"], chars = \"welldonehoneyr\"\nOutput: 10\nExplanation: The strings that can be formed are \"hello\" and \"world\" so the answer is 5 + 5 = 10."
        ],
        "constraints": "1 <= words.length <= 1000\n1 <= words[i].length, chars.length <= 100\nwords[i] and chars consist of lowercase English letters.",
        "oracle_code": "class Solution:\n    def countCharacters(self, words: List[str], chars: str) -> int:\n        ans=[]\n        d1=Counter(chars)\n        for i in range(len(words)):\n            w=[j for j in words[i]]\n            d2=Counter(w)\n        #print(dc)\n        #print(dw)\n            if all([k in d1 for k in d2]) and all([d2[k]<=d1[k] for k in d2]):\n                ans.append(len(w))\n        return sum(ans)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countCharacters(self, words: List[str], chars: str) -> int:\\n        ans=[]\\n        d1=Counter(chars)\\n        for i in range(len(words)):\\n            w=[j for j in words[i]]\\n            d2=Counter(w)\\n        #print(dc)\\n        #print(dw)\\n            if all([k in d1 for k in d2]) and all([d2[k]<=d1[k] for k in d2]):\\n                ans.append(len(w))\\n        return sum(ans)\\n       \\n```",
        "level": "easy",
        "type": [
            "indentation error",
            "parentheses mismatch",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\ndef countCharacters(self, words: List[str], chars: str) -> int:\n    ans=[]\n    d1=Counter(chars)\n    for i in range(len(words)+1):\n        w=[j for j in words[i]]\n        d2=Counter(w\n    \n    \n        if all([k in d1 for k in d2]) and all([d2[k]<=d1[k] for k in d2]):\n            ans.append(len(w))\n    return sum(ans)\n"
    },
    {
        "slug": "maximum-gap",
        "description": "Given an integer array nums, return the maximum difference between two successive elements in its sorted form. If the array contains less than two elements, return 0.\nYou must write an algorithm that runs in linear time and uses linear extra space.",
        "examples": [
            "Input: nums = [3,6,9,1]\nOutput: 3\nExplanation: The sorted form of the array is [1,3,6,9], either (3,6) or (6,9) has the maximum difference 3.",
            "Input: nums = [10]\nOutput: 0\nExplanation: The array contains less than 2 elements, therefore return 0."
        ],
        "constraints": "1 <= nums.length <= 105\n0 <= nums[i] <= 109",
        "oracle_code": "class Solution:\n    def maximumGap(self, nums: List[int]) -> int:\n        nums=sorted(nums)\n        min=float(\"-inf\")\n        if len(nums)<2:\n            return 0\n        for i in range(len(nums)-1):\n            x=abs(nums[i]-nums[i+1])\n            if min<x:\n                min=x\n        return min",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumGap(self, nums: List[int]) -> int:\\n        nums=sorted(nums)\\n        min=float(\"-inf\")\\n        if len(nums)<2:\\n            return 0\\n        for i in range(len(nums)-1):\\n            x=abs(nums[i]-nums[i+1])\\n            if min<x:\\n                min=x\\n        return min\\n```",
        "level": "medium",
        "type": [
            "undefined objects",
            "parentheses mismatch",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution:\n    def maximumGap(self, nums: list) -> int:\n        nums=sorted(nums)\n        min=float(\"-inf)\n        if len(nums)<2:\n            return 0\n        for i in range(len(nums)-1):\n            x=abs(nums[i]-undefined_variable\n            if min<x:\n                min=x\n        return min\n"
    },
    {
        "slug": "moving-stones-until-consecutive-ii",
        "description": "There are some stones in different positions on the X-axis. You are given an integer array stones, the positions of the stones.\nCall a stone an endpoint stone if it has the smallest or largest position. In one move, you pick up an endpoint stone and move it to an unoccupied position so that it is no longer an endpoint stone.\n\nIn particular, if the stones are at say, stones = [1,2,5], you cannot move the endpoint stone at position 5, since moving it to any position (such as 0, or 3) will still keep that stone as an endpoint stone.\n\nThe game ends when you cannot make any more moves (i.e., the stones are in three consecutive positions).\nReturn an integer array answer of length 2 where:\n\nanswer[0] is the minimum number of moves you can play, and\nanswer[1] is the maximum number of moves you can play.",
        "examples": [
            "Input: stones = [7,4,9]\nOutput: [1,2]\nExplanation: We can move 4 -> 8 for one move to finish the game.\nOr, we can move 9 -> 5, 4 -> 6 for two moves to finish the game.",
            "Input: stones = [6,5,4,3,10]\nOutput: [2,3]\nExplanation: We can move 3 -> 8 then 10 -> 7 to finish the game.\nOr, we can move 3 -> 7, 4 -> 8, 5 -> 9 to finish the game.\nNotice we cannot move 10 -> 2 to finish the game, because that would be an illegal move."
        ],
        "constraints": "3 <= stones.length <= 104\n1 <= stones[i] <= 109\nAll the values of stones are unique.",
        "oracle_code": "class Solution:\n    '''\n        Test cases walk through \n        Given 7, 4, 9 prove 1, 2                                                            6, 5, 4, 3, 10, prove 2, 3 \n\n        Sort stones -> 4, 7, 9                                                              3, 4, 5, 6, 10 \n        Stone length -> 3                                                                   5\n        Move penultimate = 7 - 4 - 3 + 2 = 2                                                6-3-5+2 = 0 \n        Move final = 9 - 7 - 3 + 2 = 1                                                      10-4-5+2 = 3 \n        Neither is 0, so we cannot return for sure                                          Move penultimate is 0, so move final is assured \n                                                                                            This means we can return [min(2, 3), 3] -> [2, 3]\n\n        Max legal moves is 0                                                                For completeness, max legal moves is 0, max moves is 3  \n        starting index is 0                                                                 starting index is 0 \n\n        Enumeration                                                                         Enumeration\n            index is 0, stone is 4                                                             index is 0, stone is 3 \n            stones[0] lte 4 - 3 ? No, skip while loop                                          stones[0] lte 3 - 5 ? No, skip while \n            max legal moves is min of (max of self and 0 - 0 + 1, most moves)                  max legal moves is min of (max of self and 0 - 0 + 1), max moves -> max legal moves is 1 \n                 -> max legal moves is 1                                                            \n\n            index is 1, stone is 7                                                             index is 1, stone is 4 \n            stones[0] <= 7 - 3 ? Yes, enter while                                              stones[0] lte 4 - 5 ? No, skip while \n                starting index is now 1                                                        max legal moves is min of (max of self and 1 - 0 + 1), max moves -> max legal moves is 2\n            stones[1] <= 7 - 3 ? No, skip while                                                 \n            max legal moves -> min(max of self and 1 - 1 + 1), max_moves \n                -> max legal moves is 1                                                        index is 2, stone is 5 \n                                                                                               stones[0] lte 5 - 5 ? No skip while \n            index is 2, stone is 9                                                             max legal moves is min of (max of self and 2 - 0 + 1), max_moves -> max legal moves is 3 \n            stones[1] <= 9 - 3 ? No, skip while                                                 \n            max legal moves is min(max of self and 2-1 + 1), max_moves\n                 -> max legal moves is 2                                                       index is 3, stone is 6 \n        End enumeration                                                                        stones[0] lte 6 - 5 ? No skip while \n                                                                                               max legal moves is min (max of self and 3 - 0 + 1), max_moves -> max legal moves is 3 \n        Return [3 - 2, 2] -> [1, 2] checks out                                                  \n                                                                                               index is 4, stones is 10 \n                                                                                               stones[0] lte 10 - 5 ? Yes, enter while \n                                                                                                    starting index is 1 \n                                                                                               stones[1] lte 10 - 5 ? Yes, enter while \n                                                                                                    starting index is 2 \n                                                                                               stones[2] lte 10 - 5 ? Yes, enter while \n                                                                                                    starting index is 3 \n                                                                                               max legal moves is min (max of self and 4 - 3 + 1), max moves -> max legal moves is 3 \n                                                                                            End enumeration\n\n                                                                                            Return [5 - 3, 3] -> [2, 3]\n    '''\n    def numMovesStonesII(self, stones: List[int]) -> List[int] :\n        # order does not need to be maintained, so sorting is optimal \n        stones.sort()\n        # want to work within stone physical space since 10^9 >> 10^4 (stone weight vs length)\n        stone_length = len(stones)\n        # what is the cost of moving the second to last stone and the 0th stone? \n        move_penultimate = stones[-2] - stones[0] - stone_length + 2 \n        # what is the cost of moving the last stone and the 1st stone? \n        move_final = stones[-1] - stones[1] - stone_length + 2 \n        # in both of these, the cost is the positional exchange in stones along the stone length + 2 for the two stones moving \n        # our most moves possible are the max of these two \n        most_moves = max(move_penultimate, move_final)\n        # since the stones are unique, if either is 0, the one that we have must be max legal moves \n        # if move penultimate is 0, that means that the second largest stone less the least stone less the length + 2 is 0 \n        # this means that the largest stone, which must be at least one larger than the largest, less the second to least stone which is at least one larger than the least stone  less the length + 2 is move final \n        # our minimal length is 3 \n        # let a, b, c be stones in order \n        # b - a - 3 + 2 = 0 -> b = a + 1 move penultimate  \n        # c - b - 3 + 2 = 0 -> b = c - 1 move final \n        # c - 1 = a + 1 -> c = a + 2 \n        # all stones must be at least 1 to 10^9 and are unique \n        # so at minimum a is 1, b is 2 and c is 3  \n        # in this case, move final is also 0 so we get 0, 0 \n        # if a = 4, b = 5, c = 7 \n        # 5 - 4 - 3 + 2 = 0 move penultimate is 0 \n        # 7 - 5 - 3 + 2 -> 1 move ultimate is 1 \n        # min legal moves is min of 2 and 1 -> min legal moves is 1 -> 1, 1 is returned \n        # from this it can be seen that the movement of c relative to b impacts  the return here when one is 0, and that if either is 0 it does not preclude the other. However it does entail a relation to 2 as most that min could become \n        # this is because if most moves is greater than 2, we could always do the move alternate that was 0 in two steps. This is what locks in to place the ability to use 2 here as the min argument. \n        if move_penultimate == 0 or move_final == 0 : \n            min_legal_moves = min(2, most_moves)\n            return [min_legal_moves, most_moves]\n        # how many legal moves are there in sorted order? \n        max_legal_moves = 0 \n        # starting from 0th index \n        starting_index = 0\n        # enumerate each stone and index \n        for index, stone in enumerate(stones) :\n            # while the stone at starting index is lte this stone minus stone length (cost of a move) \n            while stones[starting_index] <= stone - stone_length : \n                # increment \n                starting_index += 1\n            # max legal moves is then set to maxima of self and indexed difference with 1 for 0 based indexing  \n            max_legal_moves = min(max(max_legal_moves, index - starting_index + 1), most_moves) \n        # return length - max legal moves when in sorted order (your minimal move state) and most moves in sorted order \n        return [stone_length - max_legal_moves, most_moves]",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAt the base of this problem is a linear scan. This is because we are trying to achieve the pairing of minimum number of moves and maximum number of moves. As such, we are trying to sort the move value space and scan over it linearly. This can be achieved with a few key insights from the problem that keep it at a medium level. \\n\\nFirst, we have a list size lower bound of 3. This is actually dreadfully important for one of our key edge cases that make this easily solvable so don\\'t discard such things when they come up! \\n\\nSecond, we have that all the stone values are unique. \\n\\nThird, we have that all the stone values are positive integers from 1 to 10^9. This is important both as an insight into the fact that we are working with only positive values, and that we are working with a very large value space compared to a much relatively smaller value ordination (there are 10^9 values for the stones, but only 10^4 positions at most for them) \\n\\nWe are also provided with a helpful hint \\n>For the minimum, how many cows are already in place? For the maximum, we have to lose either the gap A[1] - A[0] or A[N-1] - A[N-2] (where N = A.length), but every other space can be occupied ?  \\n\\nWe turn first to the idea of the maximum, where we have a gap we will need to lose of either between the first and second position or ultimate and penultimate position. \\n\\nIf we consider a list of 3 items, our minimum, what is our minimum values to get our minimal return? Not to spoil anything, but it is 1, 2, 3 \\n\\nThis is key to the problem, since there are no spaces provided between the values, so our return should be [0, 0] \\n\\nBy realizing the impact of this the approach follows below. Try to work out for a few values and sizes to get the feel for it and you\\'ll likely find an understanding either intuitively or by action. I recommend working with small list sizes and trying to generate [0, 1], [0, 2], [1, 2], and [2, 2] with only 3 or so items. It\\'ll be difficult, but worth it for the understanding pay off. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe original ordering of the stones is not valid compared to their ordinal positioning, and since we know we have a size limit much less than a value limit, we start by sorting. \\n\\nThen, we want to know how much space we have to work witin, so get the size of your listing (how many stones do you have regardless of how much they are worth?) \\n\\nThen, we need to calculate the two largest costs, move penultimate and move ultimate (final in the code) \\n\\nMove penultimate is the cost of swapping the stones at the second to last spot and the first spot, minus the cost of the number of stones you have (Since you moved over the whole thing!) plus 2 to deal with the fact that they are unique\\n\\nMove ultimate is the cost of swapping the stones at the last spot and second spot, minus the cost of the number of stones you have plus 2 to deal with the fact that they are unique\\n\\nIf either of these is 0, the other must be locked in as most moves, as most moves will be the max of these two options (try to convince yourself of why that is the case! This relates to the idea of the list sizings, and is really clearly seen with a list of size 3)\\n\\nIf either is 0, \\n- min legal moves is min of 2 and most moves \\n- return min legal moves and most moves \\n\\nOtherwise we now must consider how many max legal moves are there really? \\n\\nSet max legal moves to 0 \\nSet starting index to 0 \\nenumerate index and stone in stones \\n- while stones at starting index lte stone - stone length \\n    - increment starting index \\n- our max legal moves here is the max of itself (so it preserves good discoveries) and index - starting index + 1 (+1 for the fact we use 0 indexing) \\n- but, it cannot get too big! Remember, we already found the actual max, so don\\'t let anything in here fool you! Set max legal moves as such to min(max(max_legal_moves, index - starting_index + 1), max_moves) \\n- this keeps our newly found max legal less than our actual max moves \\n\\nWhen done enumerating return length - max legal moves, max moves \\n\\n# Complexity\\n- Time complexity : O(S log S + S)\\n    - O(S log S) to sort the stones \\n    - O(S) to loop over (while loop is incindental, as it can only run as many times as the length of stones as well in total, so it does not add to this)  \\n\\n- Space complexity : O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nNo additional space utilized \\n\\n# Code\\n```\\nclass Solution:\\n    \\'\\'\\'\\n        Test cases walk through \\n        Given 7, 4, 9 prove 1, 2                                                            6, 5, 4, 3, 10, prove 2, 3 \\n\\n        Sort stones -> 4, 7, 9                                                              3, 4, 5, 6, 10 \\n        Stone length -> 3                                                                   5\\n        Move penultimate = 7 - 4 - 3 + 2 = 2                                                6-3-5+2 = 0 \\n        Move final = 9 - 7 - 3 + 2 = 1                                                      10-4-5+2 = 3 \\n        Neither is 0, so we cannot return for sure                                          Move penultimate is 0, so move final is assured \\n                                                                                            This means we can return [min(2, 3), 3] -> [2, 3]\\n\\n        Max legal moves is 0                                                                For completeness, max legal moves is 0, max moves is 3  \\n        starting index is 0                                                                 starting index is 0 \\n\\n        Enumeration                                                                         Enumeration\\n            index is 0, stone is 4                                                             index is 0, stone is 3 \\n            stones[0] lte 4 - 3 ? No, skip while loop                                          stones[0] lte 3 - 5 ? No, skip while \\n            max legal moves is min of (max of self and 0 - 0 + 1, most moves)                  max legal moves is min of (max of self and 0 - 0 + 1), max moves -> max legal moves is 1 \\n                 -> max legal moves is 1                                                            \\n\\n            index is 1, stone is 7                                                             index is 1, stone is 4 \\n            stones[0] <= 7 - 3 ? Yes, enter while                                              stones[0] lte 4 - 5 ? No, skip while \\n                starting index is now 1                                                        max legal moves is min of (max of self and 1 - 0 + 1), max moves -> max legal moves is 2\\n            stones[1] <= 7 - 3 ? No, skip while                                                 \\n            max legal moves -> min(max of self and 1 - 1 + 1), max_moves \\n                -> max legal moves is 1                                                        index is 2, stone is 5 \\n                                                                                               stones[0] lte 5 - 5 ? No skip while \\n            index is 2, stone is 9                                                             max legal moves is min of (max of self and 2 - 0 + 1), max_moves -> max legal moves is 3 \\n            stones[1] <= 9 - 3 ? No, skip while                                                 \\n            max legal moves is min(max of self and 2-1 + 1), max_moves\\n                 -> max legal moves is 2                                                       index is 3, stone is 6 \\n        End enumeration                                                                        stones[0] lte 6 - 5 ? No skip while \\n                                                                                               max legal moves is min (max of self and 3 - 0 + 1), max_moves -> max legal moves is 3 \\n        Return [3 - 2, 2] -> [1, 2] checks out                                                  \\n                                                                                               index is 4, stones is 10 \\n                                                                                               stones[0] lte 10 - 5 ? Yes, enter while \\n                                                                                                    starting index is 1 \\n                                                                                               stones[1] lte 10 - 5 ? Yes, enter while \\n                                                                                                    starting index is 2 \\n                                                                                               stones[2] lte 10 - 5 ? Yes, enter while \\n                                                                                                    starting index is 3 \\n                                                                                               max legal moves is min (max of self and 4 - 3 + 1), max moves -> max legal moves is 3 \\n                                                                                            End enumeration\\n\\n                                                                                            Return [5 - 3, 3] -> [2, 3]\\n    \\'\\'\\'\\n    def numMovesStonesII(self, stones: List[int]) -> List[int] :\\n        # order does not need to be maintained, so sorting is optimal \\n        stones.sort()\\n        # want to work within stone physical space since 10^9 >> 10^4 (stone weight vs length)\\n        stone_length = len(stones)\\n        # what is the cost of moving the second to last stone and the 0th stone? \\n        move_penultimate = stones[-2] - stones[0] - stone_length + 2 \\n        # what is the cost of moving the last stone and the 1st stone? \\n        move_final = stones[-1] - stones[1] - stone_length + 2 \\n        # in both of these, the cost is the positional exchange in stones along the stone length + 2 for the two stones moving \\n        # our most moves possible are the max of these two \\n        most_moves = max(move_penultimate, move_final)\\n        # since the stones are unique, if either is 0, the one that we have must be max legal moves \\n        # if move penultimate is 0, that means that the second largest stone less the least stone less the length + 2 is 0 \\n        # this means that the largest stone, which must be at least one larger than the largest, less the second to least stone which is at least one larger than the least stone  less the length + 2 is move final \\n        # our minimal length is 3 \\n        # let a, b, c be stones in order \\n        # b - a - 3 + 2 = 0 -> b = a + 1 move penultimate  \\n        # c - b - 3 + 2 = 0 -> b = c - 1 move final \\n        # c - 1 = a + 1 -> c = a + 2 \\n        # all stones must be at least 1 to 10^9 and are unique \\n        # so at minimum a is 1, b is 2 and c is 3  \\n        # in this case, move final is also 0 so we get 0, 0 \\n        # if a = 4, b = 5, c = 7 \\n        # 5 - 4 - 3 + 2 = 0 move penultimate is 0 \\n        # 7 - 5 - 3 + 2 -> 1 move ultimate is 1 \\n        # min legal moves is min of 2 and 1 -> min legal moves is 1 -> 1, 1 is returned \\n        # from this it can be seen that the movement of c relative to b impacts  the return here when one is 0, and that if either is 0 it does not preclude the other. However it does entail a relation to 2 as most that min could become \\n        # this is because if most moves is greater than 2, we could always do the move alternate that was 0 in two steps. This is what locks in to place the ability to use 2 here as the min argument. \\n        if move_penultimate == 0 or move_final == 0 : \\n            min_legal_moves = min(2, most_moves)\\n            return [min_legal_moves, most_moves]\\n        # how many legal moves are there in sorted order? \\n        max_legal_moves = 0 \\n        # starting from 0th index \\n        starting_index = 0\\n        # enumerate each stone and index \\n        for index, stone in enumerate(stones) :\\n            # while the stone at starting index is lte this stone minus stone length (cost of a move) \\n            while stones[starting_index] <= stone - stone_length : \\n                # increment \\n                starting_index += 1\\n            # max legal moves is then set to maxima of self and indexed difference with 1 for 0 based indexing  \\n            max_legal_moves = min(max(max_legal_moves, index - starting_index + 1), most_moves) \\n        # return length - max legal moves when in sorted order (your minimal move state) and most moves in sorted order \\n        return [stone_length - max_legal_moves, most_moves]\\n```",
        "level": "medium",
        "type": [
            "indentation error",
            "parentheses mismatch",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:dfnumMovStonesII(sef,stones: List[int]) -> List[int] :\n        stones.sort()\n        stone_leng = len(stnes)\n        move_penltimate = stones[-2] - stones[0] - stone_lent+2\n move_final = stones[-1) - stones[1] - stone_length + 2 \n        most_moves = max(move_penultimatemove_final)\n      if move_nultimate==mv_final==:_gl_movs=most_moves\n            return [min_legal_movesmost_moves\n      max_legal_moves = 0 \n        starting_index = 0\n        for index():starting_index<=stne - stone_length :\n                starting_index += 1\n            max_legal_moves = min(max(max_legal_moves-trting_iext_)rtur[tone_length- max_legal_movesm_mvsne_leng==ms_mves = max(move_penultimate, move_nal)\n      if move_uima=0ormove_x__=0\n       arting_inex= 0\n        f in,stones[starting_index] <= stone - stone_leng:\n              starting_[stone_\n"
    },
    {
        "slug": "find-closest-node-to-given-two-nodes",
        "description": "You are given a directed graph of n nodes numbered from 0 to n - 1, where each node has at most one outgoing edge.\nThe graph is represented with a given 0-indexed array edges of size n, indicating that there is a directed edge from node i to node edges[i]. If there is no outgoing edge from i, then edges[i] == -1.\nYou are also given two integers node1 and node2.\nReturn the index of the node that can be reached from both node1 and node2, such that the maximum between the distance from node1 to that node, and from node2 to that node is minimized. If there are multiple answers, return the node with the smallest index, and if no possible answer exists, return -1.\nNote that edges may contain cycles.",
        "examples": [
            "Input: edges = [2,2,3,-1], node1 = 0, node2 = 1\nOutput: 2\nExplanation: The distance from node 0 to node 2 is 1, and the distance from node 1 to node 2 is 1.\nThe maximum of those two distances is 1. It can be proven that we cannot get a node with a smaller maximum distance than 1, so we return node 2.",
            "Input: edges = [1,2,-1], node1 = 0, node2 = 2\nOutput: 2\nExplanation: The distance from node 0 to node 2 is 2, and the distance from node 2 to itself is 0.\nThe maximum of those two distances is 2. It can be proven that we cannot get a node with a smaller maximum distance than 2, so we return node 2."
        ],
        "constraints": "n == edges.length\n2 <= n <= 105\n-1 <= edges[i] < n\nedges[i] != i\n0 <= node1, node2 < n",
        "oracle_code": "class Solution:\n    def cdist(self, it, distArray, distArrayIndex, edges):\n        rdist = 0 \n        nodes = []\n        while it != -1 and distArray[it][distArrayIndex] > rdist:\n            distArray[it][distArrayIndex] = rdist\n            nodes.append(it)\n            it = edges[it]\n            rdist += 1\n        return nodes\n            \n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\n        INF = float('inf')\n        dist = defaultdict(lambda: [INF,INF])\n        mmin, ans = INF, INF\n               \n        n = self.cdist(node1, dist, 0, edges)\n        n += self.cdist(node2, dist, 1, edges)\n                \n        for k in n:\n            m = max(dist[k])\n            if m != INF:\n                if m < mmin: \n                    mmin = m\n                    ans = k\n                elif m == mmin: \n                    ans = min(ans, k)\n                    \n        return ans if ans != float('inf') else -1",
        "content": "Since there is atmost one outgoing edge with cycles, we can iterate this graph in simple manner as cdist function below. The logic briefly is as below. \\n1. Calculate distances between node1 and other reachable nodes. \\n2. Do the same as (1) for node 2\\n3. Iterate the nodes that are on the path for both distances and find max. \\n4. find min of maxes and keep track of minimum index. \\n\\nIf there was a constraint that node1 and node2 have a guarenteed path between them, the problem could have been simpler, to construct find the shortestPath between node1 -> node 2 and the ans is one of the nodes in between. Thats not the case ! \\n\\n```\\nclass Solution:\\n    def cdist(self, it, distArray, distArrayIndex, edges):\\n        rdist = 0 \\n        nodes = []\\n        while it != -1 and distArray[it][distArrayIndex] > rdist:\\n            distArray[it][distArrayIndex] = rdist\\n            nodes.append(it)\\n            it = edges[it]\\n            rdist += 1\\n        return nodes\\n            \\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        INF = float(\\'inf\\')\\n        dist = defaultdict(lambda: [INF,INF])\\n        mmin, ans = INF, INF\\n               \\n        n = self.cdist(node1, dist, 0, edges)\\n        n += self.cdist(node2, dist, 1, edges)\\n                \\n        for k in n:\\n            m = max(dist[k])\\n            if m != INF:\\n                if m < mmin: \\n                    mmin = m\\n                    ans = k\\n                elif m == mmin: \\n                    ans = min(ans, k)\\n                    \\n        return ans if ans != float(\\'inf\\') else -1\\n```\\n\\nA slightly modified logic, \\n\\n```\\nclass Solution:\\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        INF = float(\\'inf\\')\\n        N = len(edges)\\n        dist_node1 = [INF for _ in range(N)]\\n        dist_node2 = [INF for _ in range(N)]\\n        \\n        def dfs(node, di, d):\\n            if d[node] > di: \\n                d[node] = di\\n                if edges[node] != -1:\\n                    dfs(edges[node], di+1, d)\\n        \\n        dfs(node1, 0, dist_node1)\\n        dfs(node2, 0, dist_node2)\\n\\n        for i in range(N):\\n            dist_node1[i] = max(dist_node1[i], dist_node2[i])\\n                        \\n        ans = dist_node1.index(min(dist_node1))\\n        return ans if dist_node1[ans] != INF else -1\\n",
        "level": "medium",
        "type": [
            "indentation error",
            "parentheses mismatch",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution:\n    def cdist(self, it, distArray, distArrayIndex, edges:\n    rdist = 0 \n    nodes = []\n    while it != -1 and distArray[it][distArrayIndex] > rdist:\n        distArray[it][distArrayIndex] = rdist\n        nodes.append(it)\n        it = edges[it]\n        rdist += 1\n    return nodes\n            \n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\n        INF = float('inf')\n        dist = defaultdict(lambda: [INF,INF])\n        mmin, ans = INF, INF\n               \n        n = self.cdist(node1, dist, 0, edges)\n        n += self.cdist(node2, dist, 1, edges)\n                \n        for k in n:\n            m = max(dist[k])\n            if m != INF:\n                if m < mmin: \n                    mmin = m\n                    ans = k\n                elif m == mmin: \n                    ans = min(ans, k)\n                    \n        return ans if ans != 'inf' else -1\n"
    },
    {
        "slug": "largest-number-after-mutating-substring",
        "description": "You are given a string num, which represents a large integer. You are also given a 0-indexed integer array change of length 10 that maps each digit 0-9 to another digit. More formally, digit d maps to digit change[d].\nYou may choose to mutate a single substring of num. To mutate a substring, replace each digit num[i] with the digit it maps to in change (i.e. replace num[i] with change[num[i]]).\nReturn a string representing the largest possible integer after mutating (or choosing not to) a single substring of num.\nA substring is a contiguous sequence of characters within the string.",
        "examples": [
            "Input: num = \"132\", change = [9,8,5,0,3,6,4,2,6,8]\nOutput: \"832\"\nExplanation: Replace the substring \"1\":\n- 1 maps to change[1] = 8.\nThus, \"132\" becomes \"832\".\n\"832\" is the largest number that can be created, so return it.",
            "Input: num = \"021\", change = [9,4,3,5,7,2,1,9,0,6]\nOutput: \"934\"\nExplanation: Replace the substring \"021\":\n- 0 maps to change[0] = 9.\n- 2 maps to change[2] = 3.\n- 1 maps to change[1] = 4.\nThus, \"021\" becomes \"934\".\n\"934\" is the largest number that can be created, so return it.",
            "Input: num = \"5\", change = [1,4,7,5,3,2,5,6,9,4]\nOutput: \"5\"\nExplanation: \"5\" is already the largest number that can be created, so return it."
        ],
        "constraints": "1 <= num.length <= 105\nnum consists of only digits 0-9.\nchange.length == 10\n0 <= change[d] <= 9",
        "oracle_code": "class Solution:\n    def maximumNumber(self, num: str, change: List[int]) -> str:\n        num = list(num)\n        on = False \n        for i, ch in enumerate(num): \n            x = int(ch)\n            if x < change[x]: \n                on = True\n                num[i] = str(change[x])\n            elif x > change[x] and on: break\n        return \"\".join(num)",
        "content": "\\n```\\nclass Solution:\\n    def maximumNumber(self, num: str, change: List[int]) -> str:\\n        num = list(num)\\n        on = False \\n        for i, ch in enumerate(num): \\n            x = int(ch)\\n            if x < change[x]: \\n                on = True\\n                num[i] = str(change[x])\\n            elif x > change[x] and on: break\\n        return \"\".join(num)\\n```",
        "level": "medium",
        "type": [
            "indentation error",
            "undefined methods",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def maximumNumber(self, num: str, change: List[int]) -> str:\n        num = list(num)\n        on = False \n     for i, ch in enumerate(num): \n         x = int(ch)\n         if x < change[x+1]: \n              on = True\n              num[i] = str(change[x])\n         elif x > change[x] and on: break\n        self.undefined_method()\n    return \"\".join(num)\n"
    },
    {
        "slug": "count-the-repetitions",
        "description": "We define str = [s, n] as the string str which consists of the string s concatenated n times.\n\nFor example, str == [\"abc\", 3] ==\"abcabcabc\".\n\nWe define that string s1 can be obtained from string s2 if we can remove some characters from s2 such that it becomes s1.\n\nFor example, s1 = \"abc\" can be obtained from s2 = \"abdbec\" based on our definition by removing the bolded underlined characters.\n\nYou are given two strings s1 and s2 and two integers n1 and n2. You have the two strings str1 = [s1, n1] and str2 = [s2, n2].\nReturn the maximum integer m such that str = [str2, m] can be obtained from str1.",
        "examples": [
            "Input: s1 = \"acb\", n1 = 4, s2 = \"ab\", n2 = 2\nOutput: 2",
            "Input: s1 = \"acb\", n1 = 1, s2 = \"acb\", n2 = 1\nOutput: 1"
        ],
        "constraints": "1 <= s1.length, s2.length <= 100\ns1 and s2 consist of lowercase English letters.\n1 <= n1, n2 <= 106",
        "oracle_code": "class Solution:\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\n\n        rec, track = [0], defaultdict(int) \n        ct = start = ptr1 = ptr2 = 0\n\n        if not set(s2).issubset(set(s1)): return 0\n\n        s1 = ''.join(char for char in s1 if char in set(s2))\n        \n        while True:\n            for char in s2:\n                ptr = s1.find(char, start)\n                if ptr == -1:\n                    ct += 1\n                    ptr = s1.find(char)\n                start = ptr+1\n            rec.append(ct + 1)\n\n            if rec[-1] > n1: return (len(rec)-2)//n2\n\n            if ptr not in track: track[ptr] = len(rec)-1\n            else: break\n        \n        cycleStart = rec[track[ptr]]\n        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]\n        rest = n1 - cycleStart\n        \n        rem = cycleStart + rest%cycle1\n\n        while rec[ptr2] <= rem: ptr2+= 1\n\n        return (cycle2 * (rest//cycle1) + ptr2-1)//n2",
        "content": "```\\nclass Solution:\\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\\n\\n        rec, track = [0], defaultdict(int) \\n        ct = start = ptr1 = ptr2 = 0\\n\\n        if not set(s2).issubset(set(s1)): return 0\\n\\n        s1 = \\'\\'.join(char for char in s1 if char in set(s2))\\n        \\n        while True:\\n            for char in s2:\\n                ptr = s1.find(char, start)\\n                if ptr == -1:\\n                    ct += 1\\n                    ptr = s1.find(char)\\n                start = ptr+1\\n            rec.append(ct + 1)\\n\\n            if rec[-1] > n1: return (len(rec)-2)//n2\\n\\n            if ptr not in track: track[ptr] = len(rec)-1\\n            else: break\\n        \\n        cycleStart = rec[track[ptr]]\\n        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]\\n        rest = n1 - cycleStart\\n        \\n        rem = cycleStart + rest%cycle1\\n\\n        while rec[ptr2] <= rem: ptr2+= 1\\n\\n        return (cycle2 * (rest//cycle1) + ptr2-1)//n2\\n```\\n[https://leetcode.com/problems/count-the-repetitions/submissions/864907562/](http://)\\n\\nI could be wrong, but I think that time is *O*(*N*) and space is *O*(*N*).",
        "level": "hard",
        "type": [
            "undefined methods",
            "undefined objects",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution:\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\n\n        rec, track = [0], defaultdict(int) \n        ct = start = ptr1 = undefinedVariable = 0\n\n        if not set(s2).issubset(set(s1)): return 0\n\n        s1 = ''.join(char for char in s1 if char in set(undefinedVariable))\n        \n        while True:\n            for char in s2:\n                ptr = s1.find(char, start)\n                if ptr == -1:\n                    ct += 1\n                    ptr = s1.find(char)\n                start = ptr+1\n            rec.append(ct + 1)\n\n            if rec[-1] > n1: return (len(rec)-2)//n2\n\n            if ptr not in track: track[ptr] = len(0rec)-1\n            \n            else: break\n        \n        cycleStart = rec[track[ptr]]\n        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]\n        rest = n1 - cycleStart\n        \n        rem = cycleStart + self.calculateRemainder(rest, cycle1)\n\n        while rec[ptr2] <= rem: ptr2+= 1\n\n        return (cycle2 * (rest//cycle1) + ptr2-1)//n2\n"
    },
    {
        "slug": "check-if-string-is-transformable-with-substring-sort-operations",
        "description": "Given two strings s and t, transform string s into string t using the following operation any number of times:\n\nChoose a non-empty substring in s and sort it in place so the characters are in ascending order.\n\n\t\nFor example, applying the operation on the underlined substring in \"14234\" results in \"12344\".\n\n\n\nReturn true if it is possible to transform s into t. Otherwise, return false.\nA substring is a contiguous sequence of characters within a string.",
        "examples": [
            "Input: s = \"84532\", t = \"34852\"\nOutput: true\nExplanation: You can transform s into t using the following sort operations:\n\"84532\" (from index 2 to 3) -> \"84352\"\n\"84352\" (from index 0 to 2) -> \"34852\"",
            "Input: s = \"34521\", t = \"23415\"\nOutput: true\nExplanation: You can transform s into t using the following sort operations:\n\"34521\" -> \"23451\"\n\"23451\" -> \"23415\"",
            "Input: s = \"12345\", t = \"12435\"\nOutput: false"
        ],
        "constraints": "s.length == t.length\n1 <= s.length <= 105\ns and t consist of only digits.",
        "oracle_code": "class BIT():\n    def __init__(self, n):\n        self.n = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        ans = 0\n        i += 1\n        while i > 0:\n            ans += self.tree[i]\n            i -= (i & (-i))\n        return ans\n\n    def update(self, i, value):\n        i += 1\n        while i <= self.n:\n            self.tree[i] += value\n            i += (i & (-i))\n\n\nclass Solution:\n    def isTransformable(self, s: str, t: str) -> bool:\n        if Counter(s)!=Counter(t):\n            return False\n        ind = defaultdict(deque)\n        for id, i in enumerate(t):\n            ind[i].append(id)\n        a = []\n        for i in s:\n            a.append(ind[i].popleft())\n        n=len(a)\n        bt=BIT(n+1)\n        ind=defaultdict(lambda :-1)\n        for i in range(n):\n            inv=bt.sum(n)-bt.sum(a[i])\n            bt.update(a[i],1)\n            for dig in range(int(s[i])-1,-1,-1):\n                if ind[dig]>=i-inv:\n                    return False\n            ind[int(s[i])]=i-inv\n        return True",
        "content": "\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass BIT():\\n    def __init__(self, n):\\n        self.n = n\\n        self.tree = [0] * (n + 1)\\n\\n    def sum(self, i):\\n        ans = 0\\n        i += 1\\n        while i > 0:\\n            ans += self.tree[i]\\n            i -= (i & (-i))\\n        return ans\\n\\n    def update(self, i, value):\\n        i += 1\\n        while i <= self.n:\\n            self.tree[i] += value\\n            i += (i & (-i))\\n\\n\\nclass Solution:\\n    def isTransformable(self, s: str, t: str) -> bool:\\n        if Counter(s)!=Counter(t):\\n            return False\\n        ind = defaultdict(deque)\\n        for id, i in enumerate(t):\\n            ind[i].append(id)\\n        a = []\\n        for i in s:\\n            a.append(ind[i].popleft())\\n        n=len(a)\\n        bt=BIT(n+1)\\n        ind=defaultdict(lambda :-1)\\n        for i in range(n):\\n            inv=bt.sum(n)-bt.sum(a[i])\\n            bt.update(a[i],1)\\n            for dig in range(int(s[i])-1,-1,-1):\\n                if ind[dig]>=i-inv:\\n                    return False\\n            ind[int(s[i])]=i-inv\\n        return True\\n\\n\\n```",
        "level": "hard",
        "type": [
            "indentation error",
            "operation error",
            "undefined objects"
        ],
        "buggy_code": "\nclass BIT():\n    def __init__(self, n):\n        self.n = n\n    self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        ans = 0\n        i += 1\n        while i > 0:\n            ans += self.tree[i]\n            i -= (i & (-i))\n        return ans\n\n    def update(self, i, value):\n        i += 1\n        while i <= self.n:\n            self.tree[i] += value\n            i -= (i & (-i))  \n\n\nclass Solution:\n    def isTransformable(self, s: str, t: str) -> bool:\n        if Counter(s)!=Counter(t):\n            return False\n        ind = defaultdict(deque)\n        for id, i in enumerate(t):\n            ind[i].append(id)\n        a = []\n        for i in s:\n            a.append(ind[x].popleft())\n        n=len(a)\n        bt=BIT(n+1)\n        ind=defaultdict(lambda :-1)\n        for i in range(n):\n            inv=bt.sum(n)-bt.sum(a[i])\n            bt.update(a[i],1)\n            for dig in range(int(s[i])-1,-1,-1):\n                if ind[dig]>=i-inv:\n                    return False\n            ind[int(s[i])]=i-inv\n        return True\n"
    },
    {
        "slug": "binary-tree-level-order-traversal-ii",
        "description": "Given the root of a binary tree, return the bottom-up level order traversal of its nodes' values. (i.e., from left to right, level by level from leaf to root).",
        "examples": [
            "Input: root = [3,9,20,null,null,15,7]\nOutput: [[15,7],[9,20],[3]]",
            "Input: root = [1]\nOutput: [[1]]",
            "Input: root = []\nOutput: []"
        ],
        "constraints": "The number of nodes in the tree is in the range [0, 2000].\n-1000 <= Node.val <= 1000",
        "oracle_code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:\n        def checkReverse(ans):\n            l,r = 0,len(ans)-1\n            while l<=r:\n                ans[l],ans[r] = ans[r],ans[l]\n                l+=1\n                r-=1\n            return ans\n\n        if not root: return None\n        q,ans = [root],[]\n        while q:\n            n,l = len(q),[]\n            for i in range(n):\n                curr = q.pop(0)\n                l.append(curr.val)\n                if curr.left:\n                    q.append(curr.left)\n                if curr.right:\n                    q.append(curr.right)\n            ans.append(l)\n        return checkReverse(ans)",
        "content": "# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:\\n        def checkReverse(ans):\\n            l,r = 0,len(ans)-1\\n            while l<=r:\\n                ans[l],ans[r] = ans[r],ans[l]\\n                l+=1\\n                r-=1\\n            return ans\\n\\n        if not root: return None\\n        q,ans = [root],[]\\n        while q:\\n            n,l = len(q),[]\\n            for i in range(n):\\n                curr = q.pop(0)\\n                l.append(curr.val)\\n                if curr.left:\\n                    q.append(curr.left)\\n                if curr.right:\\n                    q.append(curr.right)\\n            ans.append(l)\\n        return checkReverse(ans)\\n```",
        "level": "medium",
        "type": [
            "indentation error",
            "undefined objects",
            "indexing error"
        ],
        "buggy_code": "\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:\n        def checkReverse(ans):\n            l,r = 0,len(ans)\n            while l<=r:\n                ans[l],ans[r] = ans[r],ans[l]\n                l+=1\n            r-=1\n            return ans\n\n        if not root: return None\n        q,ans = [root],[]\n        while q:\n            n,l = len(Node),[]\n            for i in range(n):\n                curr = q.pop(0)\n                l.append(curr.val)\n               if curr.left:\n                q.append(curr.left)\n               if curr.right:\n                    q.append(curr.right)\n            ans.append(l)\n        return checkReverse(ans)\n"
    },
    {
        "slug": "split-linked-list-in-parts",
        "description": "Given the head of a singly linked list and an integer k, split the linked list into k consecutive linked list parts.\nThe length of each part should be as equal as possible: no two parts should have a size differing by more than one. This may lead to some parts being null.\nThe parts should be in the order of occurrence in the input list, and parts occurring earlier should always have a size greater than or equal to parts occurring later.\nReturn an array of the k parts.",
        "examples": [
            "Input: head = [1,2,3], k = 5\nOutput: [[1],[2],[3],[],[]]\nExplanation:\nThe first element output[0] has output[0].val = 1, output[0].next = null.\nThe last element output[4] is null, but its string representation as a ListNode is [].",
            "Input: head = [1,2,3,4,5,6,7,8,9,10], k = 3\nOutput: [[1,2,3,4],[5,6,7],[8,9,10]]\nExplanation:\nThe input has been split into consecutive parts with size difference at most 1, and earlier parts are a larger size than the later parts."
        ],
        "constraints": "The number of nodes in the list is in the range [0, 1000].\n0 <= Node.val <= 1000\n1 <= k <= 50",
        "oracle_code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def splitListToParts(self, head: Optional[ListNode], k: int) -> List[Optional[ListNode]]:\n\n        # first calculate the length\n        # then find the arrangement of the number of elements and store it in list\n    \n        l = []\n        length = 0\n        ptr = head\n        while(ptr) :\n            length += 1\n            ptr = ptr.next\n\n        # possible length of the elements of an node to split\n        # first find how much it will be posiibe to split by length // k\n        # then calculate the remaining no of elements by length % k\n        arrange = []\n        maxi = length//k \n        remain = length%k\n\n        for i in range(k) :\n            if remain :\n                arrange.append(maxi + 1)  # add 1 till the reaminder become 0\n                remain -= 1\n            else:\n                arrange.append(maxi)\n\n        # now traverse the linked list and split the node \n        j = 0\n        ptr = head \n        i = 0\n        while(ptr) :\n            q = ptr \n            i += 1\n            ptr = ptr.next \n            # if the new length i is equal to the arrange[i] then just make that nodes next pointer to None\n            if i == arrange[j] :\n                q.next = None\n                l.append(head)\n                head = ptr \n                i = 0\n                j += 1\n\n        # if the length is not satisfied then just add none\n        for i in range(j,k):\n            l.append(None)\n        return l",
        "content": "\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def splitListToParts(self, head: Optional[ListNode], k: int) -> List[Optional[ListNode]]:\\n\\n        # first calculate the length\\n        # then find the arrangement of the number of elements and store it in list\\n    \\n        l = []\\n        length = 0\\n        ptr = head\\n        while(ptr) :\\n            length += 1\\n            ptr = ptr.next\\n\\n        # possible length of the elements of an node to split\\n        # first find how much it will be posiibe to split by length // k\\n        # then calculate the remaining no of elements by length % k\\n        arrange = []\\n        maxi = length//k \\n        remain = length%k\\n\\n        for i in range(k) :\\n            if remain :\\n                arrange.append(maxi + 1)  # add 1 till the reaminder become 0\\n                remain -= 1\\n            else:\\n                arrange.append(maxi)\\n\\n        # now traverse the linked list and split the node \\n        j = 0\\n        ptr = head \\n        i = 0\\n        while(ptr) :\\n            q = ptr \\n            i += 1\\n            ptr = ptr.next \\n            # if the new length i is equal to the arrange[i] then just make that nodes next pointer to None\\n            if i == arrange[j] :\\n                q.next = None\\n                l.append(head)\\n                head = ptr \\n                i = 0\\n                j += 1\\n\\n        # if the length is not satisfied then just add none\\n        for i in range(j,k):\\n            l.append(None)\\n        return l\\n```",
        "level": "medium",
        "type": [
            "undefined methods",
            "undefined objects",
            "conditional statement error"
        ],
        "buggy_code": "\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def splitListToParts(self, head: Optional[ListNode], k: int) -> List[Optional[ListNode]]:\n\n        # first calculate the length\n        # then find the arrangement of the number of elements and store it in list\n    \n        l = []\n        length = 0\n        ptr = head\n        while(ptr) :\n            length += 1\n            ptr = ptr.getNext()\n\n        # possible length of the elements of an node to split\n        # first find how much it will be posiibe to split by length // k\n        # then calculate the remaining no of elements by length % k\n        arrange = []\n        maxi = len//k \n        remain = len%k\n\n        for i in range(k) :\n            if remain :\n                arrange.append(maxi + 1)  # add 1 till the reaminder become 0\n                remain -= 1\n            else:\n                arrange.append(maxi)\n\n        # now traverse the linked list and split the node \n        j = 0\n        ptr = head \n        i = 0\n        while(ptr) :\n            q = ptr \n            i += 1\n            ptr = ptr.next \n            # if the new length i is equal to the arrange[i] then just make that nodes next pointer to None\n            if i == arrange[j] :\n                q.next = None\n                l.append(head)\n                head = ptr \n                i = 0\n                j += 1\n\n        # if the length is not satisfied then just add none\n        for i in range(j,k+1):\n            l.append(None)\n        return l\n"
    },
    {
        "slug": "number-complement",
        "description": "The complement of an integer is the integer you get when you flip all the 0's to 1's and all the 1's to 0's in its binary representation.\n\nFor example, The integer 5 is \"101\" in binary and its complement is \"010\" which is the integer 2.\n\nGiven an integer num, return its complement.",
        "examples": [
            "Input: num = 5\nOutput: 2\nExplanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2.",
            "Input: num = 1\nOutput: 0\nExplanation: The binary representation of 1 is 1 (no leading zero bits), and its complement is 0. So you need to output 0."
        ],
        "constraints": "1 <= num < 231\n\n\u00a0\nNote: This question is the same as 1009: https://leetcode.com/problems/complement-of-base-10-integer/",
        "oracle_code": "class Solution:\n    def findComplement(self, num: int) -> int:\n        com = ''\n        while num > 0 :\n            \n            if num % 2 == 1:\n                com += '0'\n            else:\n                com += '1'\n            num = num // 2\n        return int(com[::-1],2)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findComplement(self, num: int) -> int:\\n        com = \\'\\'\\n        while num > 0 :\\n            \\n            if num % 2 == 1:\\n                com += \\'0\\'\\n            else:\\n                com += \\'1\\'\\n            num = num // 2\\n        return int(com[::-1],2)\\n        \\n\\n```",
        "level": "easy",
        "type": [
            "operation error",
            "== and = confusion",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def findComplement(self, num: int) -> int:\n        com = ''\n        while num > 0 :\n            \n            if num % 2 = 1:\n                com += '0'\n            else:\n                com += '1'\n            num = num // 2\n        return int(com][1:,2)\n"
    },
    {
        "slug": "closest-dessert-cost",
        "description": "You would like to make dessert and are preparing to buy the ingredients. You have n ice cream base flavors and m types of toppings to choose from. You must follow these rules when making your dessert:\n\nThere must be exactly one ice cream base.\nYou can add one or more types of topping or have no toppings at all.\nThere are at most two of each type of topping.\n\nYou are given three inputs:\n\nbaseCosts, an integer array of length n, where each baseCosts[i] represents the price of the ith ice cream base flavor.\ntoppingCosts, an integer array of length m, where each toppingCosts[i] is the price of one of the ith topping.\ntarget, an integer representing your target price for dessert.\n\nYou want to make a dessert with a total cost as close to target as possible.\nReturn the closest possible cost of the dessert to target. If there are multiple, return the lower one.",
        "examples": [
            "Input: baseCosts = [1,7], toppingCosts = [3,4], target = 10\nOutput: 10\nExplanation: Consider the following combination (all 0-indexed):\n- Choose base 1: cost 7\n- Take 1 of topping 0: cost 1 x 3 = 3\n- Take 0 of topping 1: cost 0 x 4 = 0\nTotal: 7 + 3 + 0 = 10.",
            "Input: baseCosts = [2,3], toppingCosts = [4,5,100], target = 18\nOutput: 17\nExplanation: Consider the following combination (all 0-indexed):\n- Choose base 1: cost 3\n- Take 1 of topping 0: cost 1 x 4 = 4\n- Take 2 of topping 1: cost 2 x 5 = 10\n- Take 0 of topping 2: cost 0 x 100 = 0\nTotal: 3 + 4 + 10 + 0 = 17. You cannot make a dessert with a total cost of 18.",
            "Input: baseCosts = [3,10], toppingCosts = [2,5], target = 9\nOutput: 8\nExplanation: It is possible to make desserts with cost 8 and 10. Return 8 as it is the lower cost."
        ],
        "constraints": "n == baseCosts.length\nm == toppingCosts.length\n1 <= n, m <= 10\n1 <= baseCosts[i], toppingCosts[i] <= 104\n1 <= target <= 104",
        "oracle_code": "class Solution:\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\n        toppingCosts *= 2\n        \n        @cache\n        def fn(i, x):\n            \"\"\"Return sum of subsequence of toppingCosts[i:] closest to x.\"\"\"\n            if x < 0 or i == len(toppingCosts): return 0\n            return min(fn(i+1, x), toppingCosts[i] + fn(i+1, x-toppingCosts[i]), key=lambda y: (abs(y-x), y))\n        \n        ans = inf\n        for bc in baseCosts: \n            ans = min(ans, bc + fn(0, target - bc), key=lambda x: (abs(x-target), x))\n        return ans",
        "content": "\\n```\\nclass Solution:\\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\\n        toppingCosts *= 2\\n        \\n        @cache\\n        def fn(i, x):\\n            \"\"\"Return sum of subsequence of toppingCosts[i:] closest to x.\"\"\"\\n            if x < 0 or i == len(toppingCosts): return 0\\n            return min(fn(i+1, x), toppingCosts[i] + fn(i+1, x-toppingCosts[i]), key=lambda y: (abs(y-x), y))\\n        \\n        ans = inf\\n        for bc in baseCosts: \\n            ans = min(ans, bc + fn(0, target - bc), key=lambda x: (abs(x-target), x))\\n        return ans \\n```\\nTime complexity `O(MNV)`\\n\\nEdited on 2/28/2021\\n\\nAdding the version by @lenchen1112\\n```\\nclass Solution:\\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\\n        \\n        @cache\\n        def fn(i, cost):\\n            \"\"\"Return sum of subsequence closest to target.\"\"\"\\n            if cost >= target or i == len(toppingCosts): return cost\\n            return min(fn(i+1, cost), fn(i+1, cost+toppingCosts[i]), key=lambda x: (abs(x-target), x))\\n        \\n        ans = inf\\n        toppingCosts *= 2\\n        for cost in baseCosts: \\n            ans = min(ans, fn(0, cost), key=lambda x: (abs(x-target), x))\\n        return ans \\n```\\n\\nAdding binary search implementation\\n```\\nclass Solution:\\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\\n        top = {0}\\n        for x in toppingCosts*2: \\n            top |= {x + xx for xx in top}\\n        top = sorted(top)\\n        \\n        ans = inf \\n        for bc in baseCosts: \\n            k = bisect_left(top, target - bc)\\n            if k < len(top): ans = min(ans, bc + top[k], key=lambda x: (abs(x-target), x))\\n            if k: ans = min(ans, bc + top[k-1], key=lambda x: (abs(x-target), x))\\n        return ans \\n```\\nTime complexity `O(N*2^(2N) + MN)`",
        "level": "medium",
        "type": [
            "undefined keywords from other languages",
            "unclosed string",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\n        toppingCosts *= 2\n\n        @cache\n        def fn(i, x):\n            \"\"\"Return sum of subsequence of toppingCosts[i:] closest to x.\"\n            if x < 0 or i = len(toppingCosts): return 0\n            return min(fn(i+1, x), toppingCosts[i] + fn(i+1, x-toppingCosts[i]), key=lambda y: (abs(y-x), y))\n        \n        ans = infinity\n        for bc in baseCosts: \n            ans = min(ans, bc + fn(0, target - bc), key=lambda x: (abs(x-target), x))\n        return ans\n"
    },
    {
        "slug": "count-the-repetitions",
        "description": "We define str = [s, n] as the string str which consists of the string s concatenated n times.\n\nFor example, str == [\"abc\", 3] ==\"abcabcabc\".\n\nWe define that string s1 can be obtained from string s2 if we can remove some characters from s2 such that it becomes s1.\n\nFor example, s1 = \"abc\" can be obtained from s2 = \"abdbec\" based on our definition by removing the bolded underlined characters.\n\nYou are given two strings s1 and s2 and two integers n1 and n2. You have the two strings str1 = [s1, n1] and str2 = [s2, n2].\nReturn the maximum integer m such that str = [str2, m] can be obtained from str1.",
        "examples": [
            "Input: s1 = \"acb\", n1 = 4, s2 = \"ab\", n2 = 2\nOutput: 2",
            "Input: s1 = \"acb\", n1 = 1, s2 = \"acb\", n2 = 1\nOutput: 1"
        ],
        "constraints": "1 <= s1.length, s2.length <= 100\ns1 and s2 consist of lowercase English letters.\n1 <= n1, n2 <= 106",
        "oracle_code": "class Solution:\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\n\n        rec, track = [0], defaultdict(int) \n        ct = start = ptr1 = ptr2 = 0\n\n        if not set(s2).issubset(set(s1)): return 0\n\n        s1 = ''.join(char for char in s1 if char in set(s2))\n        \n        while True:\n            for char in s2:\n                ptr = s1.find(char, start)\n                if ptr == -1:\n                    ct += 1\n                    ptr = s1.find(char)\n                start = ptr+1\n            rec.append(ct + 1)\n\n            if rec[-1] > n1: return (len(rec)-2)//n2\n\n            if ptr not in track: track[ptr] = len(rec)-1\n            else: break\n        \n        cycleStart = rec[track[ptr]]\n        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]\n        rest = n1 - cycleStart\n        \n        rem = cycleStart + rest%cycle1\n\n        while rec[ptr2] <= rem: ptr2+= 1\n\n        return (cycle2 * (rest//cycle1) + ptr2-1)//n2",
        "content": "```\\nclass Solution:\\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\\n\\n        rec, track = [0], defaultdict(int) \\n        ct = start = ptr1 = ptr2 = 0\\n\\n        if not set(s2).issubset(set(s1)): return 0\\n\\n        s1 = \\'\\'.join(char for char in s1 if char in set(s2))\\n        \\n        while True:\\n            for char in s2:\\n                ptr = s1.find(char, start)\\n                if ptr == -1:\\n                    ct += 1\\n                    ptr = s1.find(char)\\n                start = ptr+1\\n            rec.append(ct + 1)\\n\\n            if rec[-1] > n1: return (len(rec)-2)//n2\\n\\n            if ptr not in track: track[ptr] = len(rec)-1\\n            else: break\\n        \\n        cycleStart = rec[track[ptr]]\\n        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]\\n        rest = n1 - cycleStart\\n        \\n        rem = cycleStart + rest%cycle1\\n\\n        while rec[ptr2] <= rem: ptr2+= 1\\n\\n        return (cycle2 * (rest//cycle1) + ptr2-1)//n2\\n```\\n[https://leetcode.com/problems/count-the-repetitions/submissions/864907562/](http://)\\n\\nI could be wrong, but I think that time is *O*(*N*) and space is *O*(*N*).",
        "level": "hard",
        "type": [
            "undefined objects",
            "indexing error",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\n\n        rec, track = [0], defaultdict(int) \n        ct = start = ptr1 = undefinedVariable = 0\n\n        if not set(s2).issubset(set(s1)): return 0\n\n        s1 = ''.join(char for char in s1 if char in set(undefinedVariable))\n        \n        while True:\n            for char in s2:\n                ptr = s1.find(char, start)\n                if ptr == -1:\n                    ct += 1\n                    ptr = s1.find(char)\n                start = ptr+1\n            rec.append(ct + 1)\n\n            if rec[-1] >= n1: return (len(rec)-2)//n2\n\n            if ptr not in track: track[ptr] = len(rec)-1\n            else: break\n        \n        cycleStart = rec[track[ptr]]\n        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]\n        rest = n1 - cycleStart\n        \n        rem = cycleStart + rest%cycle1\n\n        while rec[ptr2] <= rem: ptr2+= 1\n\n        return (cycle2 * (rest//cycle1) + ptr2-2)//n2\n"
    },
    {
        "slug": "kth-largest-element-in-an-array",
        "description": "Given an integer array nums and an integer k, return the kth largest element in the array.\nNote that it is the kth largest element in the sorted order, not the kth distinct element.\nCan you solve it without sorting?",
        "examples": [
            "Input: nums = [3,2,1,5,6,4], k = 2\nOutput: 5",
            "Input: nums = [3,2,3,1,2,4,5,5,6], k = 4\nOutput: 4"
        ],
        "constraints": "1 <= k <= nums.length <= 105\n-104 <= nums[i] <= 104",
        "oracle_code": "class Solution:\n    def findKthLargest(self, nums: List[int], k: int) -> int:\n        return sorted(nums)[-k]",
        "content": "# Approach\\n- Sorting\\n\\n# Complexity\\n- Time complexity: O(n*log(n))\\n\\n# Code\\n```\\nclass Solution:\\n    def findKthLargest(self, nums: List[int], k: int) -> int:\\n        return sorted(nums)[-k]\\n```",
        "level": "medium",
        "type": [
            "operation error",
            "undefined objects",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution:\n    def findKthLargest(self, nums: List[int], k: int -> int:\n        return sorted(no_nums)[-k-1]\n"
    },
    {
        "slug": "valid-arrangement-of-pairs",
        "description": "You are given a 0-indexed 2D integer array pairs where pairs[i] = [starti, endi]. An arrangement of pairs is valid if for every index i where 1 <= i < pairs.length, we have endi-1 == starti.\nReturn any valid arrangement of pairs.\nNote: The inputs will be generated such that there exists a valid arrangement of pairs.",
        "examples": [
            "Input: pairs = [[5,1],[4,5],[11,9],[9,4]]\nOutput: [[11,9],[9,4],[4,5],[5,1]]\nExplanation:\nThis is a valid arrangement since endi-1 always equals starti.\nend0 = 9 == 9 = start1 \nend1 = 4 == 4 = start2\nend2 = 5 == 5 = start3",
            "Input: pairs = [[1,3],[3,2],[2,1]]\nOutput: [[1,3],[3,2],[2,1]]\nExplanation:\nThis is a valid arrangement since endi-1 always equals starti.\nend0 = 3 == 3 = start1\nend1 = 2 == 2 = start2\nThe arrangements [[2,1],[1,3],[3,2]] and [[3,2],[2,1],[1,3]] are also valid.",
            "Input: pairs = [[1,2],[1,3],[2,1]]\nOutput: [[1,2],[2,1],[1,3]]\nExplanation:\nThis is a valid arrangement since endi-1 always equals starti.\nend0 = 2 == 2 = start1\nend1 = 1 == 1 = start2"
        ],
        "constraints": "1 <= pairs.length <= 105\npairs[i].length == 2\n0 <= starti, endi <= 109\nstarti != endi\nNo two pairs are exactly the same.\nThere exists a valid arrangement of pairs.",
        "oracle_code": "class Solution:\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\n        graph = defaultdict(list)\n        degree = defaultdict(int) # net out degree \n        for x, y in pairs: \n            graph[x].append(y)\n            degree[x] += 1\n            degree[y] -= 1\n                \n        for k in degree: \n            if degree[k] == 1: \n                x = k\n                break \n                \n        ans = []\n\n        def fn(x): \n            \"\"\"Return Eulerian path via dfs.\"\"\"\n            while graph[x]: fn(graph[x].pop()) \n            ans.append(x)\n        \n        fn(x)\n        ans.reverse()\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]",
        "content": "Please check out this [commit](https://github.com/gaosanyong/leetcode/commit/b1948f8814bebeca475cbb354cd44d19092dff59) for solutions of weekly 270.\\n\\n```\\nclass Solution:\\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\\n        graph = defaultdict(list)\\n        degree = defaultdict(int) # net out degree \\n        for x, y in pairs: \\n            graph[x].append(y)\\n            degree[x] += 1\\n            degree[y] -= 1\\n                \\n        for k in degree: \\n            if degree[k] == 1: \\n                x = k\\n                break \\n                \\n        ans = []\\n\\n        def fn(x): \\n            \"\"\"Return Eulerian path via dfs.\"\"\"\\n            while graph[x]: fn(graph[x].pop()) \\n            ans.append(x)\\n        \\n        fn(x)\\n        ans.reverse()\\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]\\n```\\n\\nAdding an iterative implementation of Hieholzer\\'s algo from @delphih\\n```\\nclass Solution:\\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\\n        graph = defaultdict(list)\\n        degree = defaultdict(int) # net out degree \\n        for x, y in pairs: \\n            graph[x].append(y)\\n            degree[x] += 1\\n            degree[y] -= 1\\n                \\n        for k in degree: \\n            if degree[k] == 1: \\n                x = k\\n                break \\n                \\n        ans = []\\n        stack = [x]\\n        while stack: \\n            while graph[stack[-1]]: \\n                stack.append(graph[stack[-1]].pop())\\n            ans.append(stack.pop())\\n        ans.reverse()\\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]\\n```",
        "level": "hard",
        "type": [
            "undefined methods",
            "undefined keywords from other languages",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution:\n    function validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\n        graph = defaultdict(list)\n        degree = defaultdict(int) # net out degree \n        for x, y in pairs: \n            graph[x].append(y)\n            degree[x] += 1\n            degree[y] -= 1\n                \n        for k in degree: \n            if degree[k] == 1: \n                x = k\n                break \n                \n        ans = []\n\n        function fn(x): \n            \"\"\"Return Eulerian path via dfs.\"\n            while graph[x]: fn(graph[x].pop()) \n            ans.append(x)\n        \n        dfn(s)\n        ans.reverse()\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]\n"
    },
    {
        "slug": "string-compression-ii",
        "description": "Run-length encoding is a string compression method that works by\u00a0replacing consecutive identical characters (repeated 2 or more times) with the concatenation of the character and the number marking the count of the characters (length of the run). For example, to compress the string\u00a0\"aabccc\"\u00a0we replace \"aa\"\u00a0by\u00a0\"a2\"\u00a0and replace \"ccc\"\u00a0by\u00a0\"c3\". Thus the compressed string becomes \"a2bc3\".\nNotice that in this problem, we are not adding\u00a0'1'\u00a0after single characters.\nGiven a\u00a0string s\u00a0and an integer k. You need to delete at most\u00a0k characters from\u00a0s\u00a0such that the run-length encoded version of s\u00a0has minimum length.\nFind the minimum length of the run-length encoded\u00a0version of s after deleting at most k characters.",
        "examples": [
            "Input: s = \"aaabcccd\", k = 2\nOutput: 4\nExplanation: Compressing s without deleting anything will give us \"a3bc3d\" of length 6. Deleting any of the characters 'a' or 'c' would at most decrease the length of the compressed string to 5, for instance delete 2 'a' then we will have s = \"abcccd\" which compressed is abc3d. Therefore, the optimal way is to delete 'b' and 'd', then the compressed version of s will be \"a3c3\" of length 4.",
            "Input: s = \"aabbaa\", k = 2\nOutput: 2\nExplanation: If we delete both 'b' characters, the resulting compressed string would be \"a4\" of length 2.",
            "Input: s = \"aaaaaaaaaaa\", k = 0\nOutput: 3\nExplanation: Since k is zero, we cannot delete anything. The compressed string is \"a11\" of length 3."
        ],
        "constraints": "1 <= s.length <= 100\n0 <= k <= s.length\ns contains only lowercase English letters.",
        "oracle_code": "class Solution:\n    def dp(self,i,s,prev,k,ct,n,dct):\n        if k<0:\n            return float(\"infinity\")\n        if i>=n:\n            x=0\n            if ct>1:\n                x=len(str(ct))+1\n            elif ct==1:\n                x=1\n            return x\n        if (i,prev,ct,k) in dct:\n            return dct[(i,prev,ct,k)]\n        if s[i]==prev:\n            inc=self.dp(i+1,s,prev,k,ct+1,n,dct)\n        else:\n            x=0\n            if ct>1:\n                x=len(str(ct))+1\n            elif ct==1:\n                x=1\n            inc=x+self.dp(i+1,s,s[i],k,1,n,dct)\n        exc=self.dp(i+1,s,prev,k-1,ct,n,dct)\n        dct[(i,prev,ct,k)]=min(inc,exc)\n        return min(inc,exc)\n\n\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n        n=len(s)\n        return self.dp(0,s,\"\",k,0,n,{})",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def dp(self,i,s,prev,k,ct,n,dct):\\n        if k<0:\\n            return float(\"infinity\")\\n        if i>=n:\\n            x=0\\n            if ct>1:\\n                x=len(str(ct))+1\\n            elif ct==1:\\n                x=1\\n            return x\\n        if (i,prev,ct,k) in dct:\\n            return dct[(i,prev,ct,k)]\\n        if s[i]==prev:\\n            inc=self.dp(i+1,s,prev,k,ct+1,n,dct)\\n        else:\\n            x=0\\n            if ct>1:\\n                x=len(str(ct))+1\\n            elif ct==1:\\n                x=1\\n            inc=x+self.dp(i+1,s,s[i],k,1,n,dct)\\n        exc=self.dp(i+1,s,prev,k-1,ct,n,dct)\\n        dct[(i,prev,ct,k)]=min(inc,exc)\\n        return min(inc,exc)\\n\\n\\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\\n        n=len(s)\\n        return self.dp(0,s,\"\",k,0,n,{})\\n\\n        \\n```",
        "level": "hard",
        "type": [
            "parentheses mismatch",
            "== and = confusion",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def dp(self,i,s,prev,k,ct,n,dct:\n        if k<0:\n            return float(\"infinity\")\n        if i>=n+1:\n            x=0\n            if ct>1:\n                x=len(str(ct))+1\n            elif ct==1:\n                x=1\n            return x\n        if (i,prev,ct,k) in dct:\n            return dct[(i,prev,ct,k)]\n        if s[i]==prev:\n            inc=self.dp(i+1,s,prev,k,ct+1,n,dct)\n        else:\n            x=0\n            if ct>1:\n                x=len(str(ct))+1\n            elif ct==1:\n                x=1\n            inc=x+self.dp(i+1,s,s[i],k,1,n,dct)\n        exc=self.dp(i+1,s,prev,k-1,ct,n,dct)\n        dct[(i,prev,ct,k)]=min(inc,exc) == 0\n        return min(inc,exc)\n\n\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n        n=len(s)\n        return self.dp(0,s,\"\",k,0,n,{})\n"
    },
    {
        "slug": "disconnect-path-in-a-binary-matrix-by-at-most-one-flip",
        "description": "You are given a 0-indexed m x n binary matrix grid. You can move from a cell (row, col) to any of the cells (row + 1, col) or (row, col + 1) that has the value 1.\u00a0The matrix is disconnected if there is no path from (0, 0) to (m - 1, n - 1).\nYou can flip the value of at most one (possibly none) cell. You cannot flip the cells (0, 0) and (m - 1, n - 1).\nReturn true if it is possible to make the matrix disconnect or false otherwise.\nNote that flipping a cell changes its value from 0 to 1 or from 1 to 0.",
        "examples": [
            "Input: grid = [[1,1,1],[1,0,0],[1,1,1]]\nOutput: true\nExplanation: We can change the cell shown in the diagram above. There is no path from (0, 0) to (2, 2) in the resulting grid.",
            "Input: grid = [[1,1,1],[1,0,1],[1,1,1]]\nOutput: false\nExplanation: It is not possible to change at most one cell such that there is not path from (0, 0) to (2, 2)."
        ],
        "constraints": "m == grid.length\nn == grid[i].length\n1 <= m, n <= 1000\n1 <= m * n <= 105\ngrid[i][j] is either 0 or 1.\ngrid[0][0] == grid[m - 1][n - 1] == 1",
        "oracle_code": "class Solution:\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\n        m, n = len(grid), len(grid[0])\n        dirs = [(-1, 0), (0, -1)]\n        def dfs(i: int, j: int) -> None:\n            grid[i][j] = 2\n            for di, dj in dirs:\n                if 0 <= i + di < m and 0 <= j + dj < n and grid[i + di][j + dj] == 1: dfs(i + di, j + dj)\n        \n        dfs(m - 1, n - 1)\n    \n        dq = collections.deque([(0, 0)])\n        grid[0][0] = 0\n        dirs = [(1, 0), (0, 1)]\n        while dq:\n            l = len(dq)\n            for _ in range(l):\n                i, j = dq.popleft()\n                if i == m - 1 and j == n - 1: return False\n                for di, dj in dirs:\n                    if 0 <= i + di < m and 0 <= j + dj < n and grid[i + di][j + dj] == 2: \n                        dq.append((i + di, j + dj))\n                        grid[i + di][j + dj] = 0\n\n\n            if len(dq) == 1 and dq[0] != (m - 1, n - 1): return True\n\n        return True",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(M * N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(M * N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n1. DFS + BFS\\n```\\nclass Solution:\\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\\n        m, n = len(grid), len(grid[0])\\n        dirs = [(-1, 0), (0, -1)]\\n        def dfs(i: int, j: int) -> None:\\n            grid[i][j] = 2\\n            for di, dj in dirs:\\n                if 0 <= i + di < m and 0 <= j + dj < n and grid[i + di][j + dj] == 1: dfs(i + di, j + dj)\\n        \\n        dfs(m - 1, n - 1)\\n    \\n        dq = collections.deque([(0, 0)])\\n        grid[0][0] = 0\\n        dirs = [(1, 0), (0, 1)]\\n        while dq:\\n            l = len(dq)\\n            for _ in range(l):\\n                i, j = dq.popleft()\\n                if i == m - 1 and j == n - 1: return False\\n                for di, dj in dirs:\\n                    if 0 <= i + di < m and 0 <= j + dj < n and grid[i + di][j + dj] == 2: \\n                        dq.append((i + di, j + dj))\\n                        grid[i + di][j + dj] = 0\\n\\n\\n            if len(dq) == 1 and dq[0] != (m - 1, n - 1): return True\\n\\n        return True\\n```",
        "level": "medium",
        "type": [
            "indentation error",
            "wrong comment mark",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\n        m, n = len(grid), len(grid[0])\n        dirs = [(-1, 0), (0, -1)]\n        def dfs(i: int, j: int) -> None:\n            grid[i][j] = 2\n        for di, dj in dirs:\n            if 0 <= i + di < m and 0 <= j + dj < n and grid[i + di][j + dj] == 1: dfs(i + di, j + dj)\n'''\n        dfs(m - 1, n - 1)\n        dq = collections.deque([(0, 0)])\n        grid[0][0] = 0\n        dirs = [(1, 0), (0, 1)]\n        while dq:\n            l = len(dq)\n            for _ in range(l):\n                i, j = dq.popleft()\n                if i == m - 1 and j == n - 1: return True\n                for di, dj in dirs:\n                    if 0 <= i + di < m and 0 <= j + dj < n and grid[i + di][j + dj] == 2: \n                        dq.append((i + di, j + dj))\n                        grid[i + di][j + dj] = 0\n        '''\n        if len(dq) == 1 and dq[0] != (m - 1, n - 1): return False\n\n        return False\n"
    },
    {
        "slug": "number-complement",
        "description": "The complement of an integer is the integer you get when you flip all the 0's to 1's and all the 1's to 0's in its binary representation.\n\nFor example, The integer 5 is \"101\" in binary and its complement is \"010\" which is the integer 2.\n\nGiven an integer num, return its complement.",
        "examples": [
            "Input: num = 5\nOutput: 2\nExplanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2.",
            "Input: num = 1\nOutput: 0\nExplanation: The binary representation of 1 is 1 (no leading zero bits), and its complement is 0. So you need to output 0."
        ],
        "constraints": "1 <= num < 231\n\n\u00a0\nNote: This question is the same as 1009: https://leetcode.com/problems/complement-of-base-10-integer/",
        "oracle_code": "class Solution:\n    def findComplement(self, num: int) -> int:\n        com = ''\n        while num > 0 :\n            \n            if num % 2 == 1:\n                com += '0'\n            else:\n                com += '1'\n            num = num // 2\n        return int(com[::-1],2)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findComplement(self, num: int) -> int:\\n        com = \\'\\'\\n        while num > 0 :\\n            \\n            if num % 2 == 1:\\n                com += \\'0\\'\\n            else:\\n                com += \\'1\\'\\n            num = num // 2\\n        return int(com[::-1],2)\\n        \\n\\n```",
        "level": "easy",
        "type": [
            "indentation error",
            "== and = confusion",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def findComplement(self, num: int) -> int:\n        com = ''\n        while num > 0 :\n            \n            if num % 2 = 1:\n           com += '0'\n            else:\n                com += '1'\n            num = num // 2\n        return int(com[::-1][1:],2)\n"
    },
    {
        "slug": "valid-permutations-for-di-sequence",
        "description": "You are given a string s of length n where s[i] is either:\n\n'D' means decreasing, or\n'I' means increasing.\n\nA permutation perm of n + 1 integers of all the integers in the range [0, n] is called a valid permutation if for all valid i:\n\nIf s[i] == 'D', then perm[i] > perm[i + 1], and\nIf s[i] == 'I', then perm[i] < perm[i + 1].\n\nReturn the number of valid permutations perm. Since the answer may be large, return it modulo 109 + 7.",
        "examples": [
            "Input: s = \"DID\"\nOutput: 5\nExplanation: The 5 valid permutations of (0, 1, 2, 3) are:\n(1, 0, 3, 2)\n(2, 0, 3, 1)\n(2, 1, 3, 0)\n(3, 0, 2, 1)\n(3, 1, 2, 0)",
            "Input: s = \"D\"\nOutput: 1"
        ],
        "constraints": "n == s.length\n1 <= n <= 200\ns[i] is either 'I' or 'D'.",
        "oracle_code": "class Solution:\n    def numPermsDISequence(self, s: str) -> int:\n        mem=defaultdict(int)\n        def dfs(i,val=0):\n            if i==len(s):\n                return 1\n            if (i,val) in mem:\n                return mem[i,val]\n            p=0\n            if s[i]==\"D\":\n                for ind in range(0,val+1):\n                    p+=dfs(i+1,ind)%(10**9+7)\n            else:\n                for ind in range(val+1,i+2):\n                    p+=dfs(i+1,ind)%(10**9+7)\n            mem[i,val]=p\n            return p\n        return dfs(0)",
        "content": "To add a new character to a sequence we only have to consider the last element-\\n\\nLets say currently DID sequence is 1032- this can form\\n\\nDIDI - in cases where we end with 3,4\\nDIDD - in cases where we end with 0,1,2\\n\\nSo just use the last element value to create a new sequence.\\n\\n```\\nclass Solution:\\n    def numPermsDISequence(self, s: str) -> int:\\n        mem=defaultdict(int)\\n        def dfs(i,val=0):\\n            if i==len(s):\\n                return 1\\n            if (i,val) in mem:\\n                return mem[i,val]\\n            p=0\\n            if s[i]==\"D\":\\n                for ind in range(0,val+1):\\n                    p+=dfs(i+1,ind)%(10**9+7)\\n            else:\\n                for ind in range(val+1,i+2):\\n                    p+=dfs(i+1,ind)%(10**9+7)\\n            mem[i,val]=p\\n            return p\\n        return dfs(0)\\n ```\\n\\t\\t\\t\\t",
        "level": "hard",
        "type": [
            "colon missing",
            "== and = confusion",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def numPermsDISequence(self, s: str) -> int:\n        mem=defaultdict(int)\n        def dfs(i,val=0):\n            if i=len(s): \n                return 1\n            if (i,val) in mem\n                return mem[i,val]\n            p=0\n            if s[i]==\"D\":\n                for ind in range(0,val+2): \n                    p+=dfs(i+1,ind)%(10**9+7)\n            else:\n                if ind in range(val+1,i+3): \n                    p+=dfs(i+1,ind)%(10**9+7)\n            mem[i,val]=p\n            return p\n        return dfs(0)\n"
    },
    {
        "slug": "fizz-buzz",
        "description": "Given an integer n, return a string array answer (1-indexed) where:\n\nanswer[i] == \"FizzBuzz\" if i is divisible by 3 and 5.\nanswer[i] == \"Fizz\" if i is divisible by 3.\nanswer[i] == \"Buzz\" if i is divisible by 5.\nanswer[i] == i (as a string) if none of the above conditions are true.",
        "examples": [
            "Input: n = 3\nOutput: [\"1\",\"2\",\"Fizz\"]",
            "Input: n = 5\nOutput: [\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\"]",
            "Input: n = 15\nOutput: [\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\",\"Fizz\",\"7\",\"8\",\"Fizz\",\"Buzz\",\"11\",\"Fizz\",\"13\",\"14\",\"FizzBuzz\"]"
        ],
        "constraints": "1 <= n <= 104",
        "oracle_code": "class Solution:\n    def fizzBuzz(self, n: int) -> List[str]:\n        arr=[]\n        for i in range(1,n+1):\n            if i % 3==0 and  i % 5==0 :\n                arr.append(\"FizzBuzz\")\n            elif i % 3==0:\n                arr.append(\"Fizz\")\n            elif i % 5==0 :\n                arr.append(\"Buzz\")\n  \n            else:\n                arr.append(str(i))\n        return(arr)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def fizzBuzz(self, n: int) -> List[str]:\\n        arr=[]\\n        for i in range(1,n+1):\\n            if i % 3==0 and  i % 5==0 :\\n                arr.append(\"FizzBuzz\")\\n            elif i % 3==0:\\n                arr.append(\"Fizz\")\\n            elif i % 5==0 :\\n                arr.append(\"Buzz\")\\n  \\n            else:\\n                arr.append(str(i))\\n        return(arr)\\n```",
        "level": "easy",
        "type": [
            "undefined objects",
            "== and = confusion",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def fizzBuzz(self, n: int) -> List[str]:\n        arr=[]\n        for i in range(0,n+1):\n            if i % 3 = 0 and  i % k==0 :\n                arr.append(\"FizzBuzz\")\n            elif i % 3==0:\n                arr.append(\"Fizz\")\n            elif i % 5 = 0 :\n                arr.append(\"Buzz\")\n  \n            else  :\n                arr.append(  str(i))\n        return(arr)\n"
    },
    {
        "slug": "valid-arrangement-of-pairs",
        "description": "You are given a 0-indexed 2D integer array pairs where pairs[i] = [starti, endi]. An arrangement of pairs is valid if for every index i where 1 <= i < pairs.length, we have endi-1 == starti.\nReturn any valid arrangement of pairs.\nNote: The inputs will be generated such that there exists a valid arrangement of pairs.",
        "examples": [
            "Input: pairs = [[5,1],[4,5],[11,9],[9,4]]\nOutput: [[11,9],[9,4],[4,5],[5,1]]\nExplanation:\nThis is a valid arrangement since endi-1 always equals starti.\nend0 = 9 == 9 = start1 \nend1 = 4 == 4 = start2\nend2 = 5 == 5 = start3",
            "Input: pairs = [[1,3],[3,2],[2,1]]\nOutput: [[1,3],[3,2],[2,1]]\nExplanation:\nThis is a valid arrangement since endi-1 always equals starti.\nend0 = 3 == 3 = start1\nend1 = 2 == 2 = start2\nThe arrangements [[2,1],[1,3],[3,2]] and [[3,2],[2,1],[1,3]] are also valid.",
            "Input: pairs = [[1,2],[1,3],[2,1]]\nOutput: [[1,2],[2,1],[1,3]]\nExplanation:\nThis is a valid arrangement since endi-1 always equals starti.\nend0 = 2 == 2 = start1\nend1 = 1 == 1 = start2"
        ],
        "constraints": "1 <= pairs.length <= 105\npairs[i].length == 2\n0 <= starti, endi <= 109\nstarti != endi\nNo two pairs are exactly the same.\nThere exists a valid arrangement of pairs.",
        "oracle_code": "class Solution:\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\n        graph = defaultdict(list)\n        degree = defaultdict(int) # net out degree \n        for x, y in pairs: \n            graph[x].append(y)\n            degree[x] += 1\n            degree[y] -= 1\n                \n        for k in degree: \n            if degree[k] == 1: \n                x = k\n                break \n                \n        ans = []\n\n        def fn(x): \n            \"\"\"Return Eulerian path via dfs.\"\"\"\n            while graph[x]: fn(graph[x].pop()) \n            ans.append(x)\n        \n        fn(x)\n        ans.reverse()\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]",
        "content": "Please check out this [commit](https://github.com/gaosanyong/leetcode/commit/b1948f8814bebeca475cbb354cd44d19092dff59) for solutions of weekly 270.\\n\\n```\\nclass Solution:\\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\\n        graph = defaultdict(list)\\n        degree = defaultdict(int) # net out degree \\n        for x, y in pairs: \\n            graph[x].append(y)\\n            degree[x] += 1\\n            degree[y] -= 1\\n                \\n        for k in degree: \\n            if degree[k] == 1: \\n                x = k\\n                break \\n                \\n        ans = []\\n\\n        def fn(x): \\n            \"\"\"Return Eulerian path via dfs.\"\"\"\\n            while graph[x]: fn(graph[x].pop()) \\n            ans.append(x)\\n        \\n        fn(x)\\n        ans.reverse()\\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]\\n```\\n\\nAdding an iterative implementation of Hieholzer\\'s algo from @delphih\\n```\\nclass Solution:\\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\\n        graph = defaultdict(list)\\n        degree = defaultdict(int) # net out degree \\n        for x, y in pairs: \\n            graph[x].append(y)\\n            degree[x] += 1\\n            degree[y] -= 1\\n                \\n        for k in degree: \\n            if degree[k] == 1: \\n                x = k\\n                break \\n                \\n        ans = []\\n        stack = [x]\\n        while stack: \\n            while graph[stack[-1]]: \\n                stack.append(graph[stack[-1]].pop())\\n            ans.append(stack.pop())\\n        ans.reverse()\\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]\\n```",
        "level": "hard",
        "type": [
            "undefined keywords from other languages",
            "== and = confusion",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    function validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\n        graph = defaultdict(list)\n        degree = defaultdict(int) # net out degree \n        for x, y in pairs: \n            graph[x].append(y)\n            degree[x] += 1\n            degree[y] -= 1\n                \n        for k in degree: \n            if degree[k] ! 1: \n                x = k\n                break \n                \n        ans = []\n\n        function fn(x): \n            \"\"\"Return Eulerian path via dfs.\"\"\"\n            while graph[x]: fn(graph[x].pop()) \n            ans.append(x)\n        \n        fn(x)\n        ans.reverse()\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]\n"
    },
    {
        "slug": "number-of-ways-of-cutting-a-pizza",
        "description": "Given a rectangular pizza represented as a rows x cols\u00a0matrix containing the following characters: 'A' (an apple) and '.' (empty cell) and given the integer k. You have to cut the pizza into k pieces using k-1 cuts.\u00a0\nFor each cut you choose the direction: vertical or horizontal, then you choose a cut position at the cell boundary and cut the pizza into two pieces. If you cut the pizza vertically, give the left part of the pizza to a person. If you cut the pizza horizontally, give the upper part of the pizza to a person. Give the last piece of pizza to the last person.\nReturn the number of ways of cutting the pizza such that each piece contains at least one apple.\u00a0Since the answer can be a huge number, return this modulo 10^9 + 7.",
        "examples": [
            "Input: pizza = [\"A..\",\"AAA\",\"...\"], k = 3\nOutput: 3 \nExplanation: The figure above shows the three ways to cut the pizza. Note that pieces must contain at least one apple.",
            "Input: pizza = [\"A..\",\"AA.\",\"...\"], k = 3\nOutput: 1",
            "Input: pizza = [\"A..\",\"A..\",\"...\"], k = 1\nOutput: 1"
        ],
        "constraints": "1 <= rows, cols <= 50\nrows ==\u00a0pizza.length\ncols ==\u00a0pizza[i].length\n1 <= k <= 10\npizza consists of characters 'A'\u00a0and '.' only.",
        "oracle_code": "class Solution:\n    def ways(self, pizza: List[str], k: int) -> int:\n        self.r = len(pizza)\n        self.c = len(pizza[0])\n        \n        # Step 1, pre-process the apple array and get the prefix sum\n        tot_apples = 0\n        self.pfsum_row = []\n        self.pfsum_col = []\n        \n        for i in range(self.r):\n            pfr = 0\n            pfs_r = [0] * self.c\n            pfs_c = [0] * self.c\n            for j in range(self.c):\n                if i > 0:\n                    pfs_c[j] += self.pfsum_col[i - 1][j]\n                if pizza[i][j] == 'A':\n                    pfr += 1\n                    pfs_c[j] += 1\n                    tot_apples += 1\n                pfs_r[j] = pfr\n            self.pfsum_row.append(pfs_r)\n            self.pfsum_col.append(pfs_c)\n        \n        if tot_apples < k:\n            return 0\n        \n        if k == 1:\n            return 1\n        \n        return self.getWays(0, 0, k) % (1000000007)\n    \n    \n    @cache\n    def getWays(self, i, j, k):\n        if k == 1:\n            # if only left one piece for cutting, we just need to check if there is any apple in the region\n            found = False\n            for c in range(j, self.c):\n                apple_in_region = self.pfsum_col[self.r - 1][c]\n                if i > 0:\n                     apple_in_region -= self.pfsum_col[i - 1][c]\n                if apple_in_region:\n                    found = True\n                    break\n            if found:\n                return 1\n            return 0\n        else:\n            # horizontally cut\n            cannot_cut = True\n            nr = i\n            t_cnt = 0\n            while nr < self.r - 1:\n                # find the first row that we can start cutting\n                while nr < self.r - 1 and cannot_cut:\n                    apple_in_region = self.pfsum_row[nr][self.c - 1]\n                    if j > 0:\n                        apple_in_region -= self.pfsum_row[nr][j - 1]\n                    if apple_in_region:\n                        cannot_cut = False\n                    else:\n                        nr += 1\n                        \n                if nr < self.r - 1:\n                    t_cnt += self.getWays(nr + 1, j, k - 1)\n                nr += 1\n                \n            # vertically cut\n            cannot_cut = True\n            nc = j\n            while nc < self.c - 1:\n                # find the first col that we can start cutting\n                while nc < self. c - 1 and cannot_cut:\n                    apple_in_region = self.pfsum_col[self.r - 1][nc]\n                    if i > 0:\n                        apple_in_region -= self.pfsum_col[i - 1][nc]\n                    if apple_in_region:\n                        cannot_cut = False\n                    else:\n                        nc += 1\n                \n                if nc < self.c - 1:\n                    t_cnt += self.getWays(i, nc + 1, k - 1)\n                nc += 1\n            \n            return t_cnt",
        "content": "The key to this problem is how to count the number of apples on the region we want to cut.\\n\\nWe can simply use the prefix sum that help to identify the number of apples between any two index.\\n\\nTherefore, we need to pre-process the input array, get the prefix sum horizatonally and vertically.\\n\\nWith the prefix sum array, we can create a dp funtion that get the number of cuts in the region (i, j) to (row - 1, col - 1)\\n\\n\\n```\\nclass Solution:\\n    def ways(self, pizza: List[str], k: int) -> int:\\n        self.r = len(pizza)\\n        self.c = len(pizza[0])\\n        \\n        # Step 1, pre-process the apple array and get the prefix sum\\n        tot_apples = 0\\n        self.pfsum_row = []\\n        self.pfsum_col = []\\n        \\n        for i in range(self.r):\\n            pfr = 0\\n            pfs_r = [0] * self.c\\n            pfs_c = [0] * self.c\\n            for j in range(self.c):\\n                if i > 0:\\n                    pfs_c[j] += self.pfsum_col[i - 1][j]\\n                if pizza[i][j] == \\'A\\':\\n                    pfr += 1\\n                    pfs_c[j] += 1\\n                    tot_apples += 1\\n                pfs_r[j] = pfr\\n            self.pfsum_row.append(pfs_r)\\n            self.pfsum_col.append(pfs_c)\\n        \\n        if tot_apples < k:\\n            return 0\\n        \\n        if k == 1:\\n            return 1\\n        \\n        return self.getWays(0, 0, k) % (1000000007)\\n    \\n    \\n    @cache\\n    def getWays(self, i, j, k):\\n        if k == 1:\\n            # if only left one piece for cutting, we just need to check if there is any apple in the region\\n            found = False\\n            for c in range(j, self.c):\\n                apple_in_region = self.pfsum_col[self.r - 1][c]\\n                if i > 0:\\n                     apple_in_region -= self.pfsum_col[i - 1][c]\\n                if apple_in_region:\\n                    found = True\\n                    break\\n            if found:\\n                return 1\\n            return 0\\n        else:\\n            # horizontally cut\\n            cannot_cut = True\\n            nr = i\\n            t_cnt = 0\\n            while nr < self.r - 1:\\n                # find the first row that we can start cutting\\n                while nr < self.r - 1 and cannot_cut:\\n                    apple_in_region = self.pfsum_row[nr][self.c - 1]\\n                    if j > 0:\\n                        apple_in_region -= self.pfsum_row[nr][j - 1]\\n                    if apple_in_region:\\n                        cannot_cut = False\\n                    else:\\n                        nr += 1\\n                        \\n                if nr < self.r - 1:\\n                    t_cnt += self.getWays(nr + 1, j, k - 1)\\n                nr += 1\\n                \\n            # vertically cut\\n            cannot_cut = True\\n            nc = j\\n            while nc < self.c - 1:\\n                # find the first col that we can start cutting\\n                while nc < self. c - 1 and cannot_cut:\\n                    apple_in_region = self.pfsum_col[self.r - 1][nc]\\n                    if i > 0:\\n                        apple_in_region -= self.pfsum_col[i - 1][nc]\\n                    if apple_in_region:\\n                        cannot_cut = False\\n                    else:\\n                        nc += 1\\n                \\n                if nc < self.c - 1:\\n                    t_cnt += self.getWays(i, nc + 1, k - 1)\\n                nc += 1\\n            \\n            return t_cnt\\n\\n```",
        "level": "hard",
        "type": [
            "operation error",
            "undefined objects",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def ways(self, pizza: List[str], k: int) -> int:\n        self.r = len(pizza)\n        self.c = len(pizza[0])\n        \n        tot_apples = 0\n        self.pfsum_row = []\n        self.pfsum_col = []\n        for i in range(self.r):\n            pfr = 0\n            pfs_r = [0] * self.c\n            pfs_c = [0] * self.c\n            for j in range(self.c):\n                if i > 0:\n                    pfs_c[j] += self.charlie[i - 1][j]\n                if pizza[i][j] == 'A':\n                    pfr += 1\n                    pfs_c[j] += 1\n                    tot_apples -= 1\n                pfs_r[j] = pfr\n            self.pfsum_row.append(pfs_r)\n            self.pfsum_col.append(pfs_c)\n        \n        if tot_apples < k:\n            return 0\n        \n        if k == 1:\n            return 1\n        return self.getWays(0, 0, k - 2) % (1000000007)\n    \n    \n    @cache\n    def getWays(self, i, j, k):\n        if k == 1:\n            found = False\n            for c in range(j, self.c):\n                apple_in_region = self.pfsum_col[self.r - 1][c]\n                if i > 0:\n                     apple_in_region -= self.pfsum_col[i - 1][c]\n                if apple_in_region:\n                    found = True\n                    break\n            if found:\n                return 1   \n            return 0\n        else:\n            cannot_cut = True\n            nr = i\n            t_cnt = 0\n            while nr < self.r - 1:\n                while nr < self.r - 1 and cannot_cut:\n                    apple_in_region = self.pfsum_row[nr][self.c - 1]\n                    if j > 0:\n                        apple_in_region -= self.pfsum_row[nr][j - 1]\n                    if apple_in_region:\n                        cannot_cut = False\n                    else:\n                        nr += 1\n                        \n                if nr < self.r - 1:\n                    t_cnt += self.getWays(nr + 1, j, k - 1)\n                nr += 1\n                \n            cannot_cut = True\n            nc = j\n            while nc < self.c - 1:\n                while nc < self. c - 1 and cannot_cut:\n                    apple_in_region = self.pfsum_col[self.r - 1][nc]\n                    if i > 0:\n                        apple_in_region -= self.pfsum_col[i - 1][nc]\n                    if apple_in_region:\n                        cannot_cut = False\n                    else:\n                        nc += 1\n                \n                if nc < self.c - 1:\n                    t_cnt += self.getWays(i, nc + 1, k - 1)\n                nc += 1\n            \n            return t_cnt\n"
    },
    {
        "slug": "find-the-string-with-lcp",
        "description": "We define the lcp matrix of any 0-indexed string word of n lowercase English letters as an n x n grid such that:\n\nlcp[i][j] is equal to the length of the longest common prefix between the substrings word[i,n-1] and word[j,n-1].\n\nGiven an\u00a0n x n matrix lcp, return the alphabetically smallest string word that corresponds to lcp. If there is no such string, return an empty string.\nA string a is lexicographically smaller than a string b (of the same length) if in the first position where a and b differ, string a has a letter that appears earlier in the alphabet than the corresponding letter in b. For example, \"aabd\" is lexicographically smaller than \"aaca\" because the first position they differ is at the third letter, and 'b' comes before 'c'.",
        "examples": [
            "Input: lcp = [[4,0,2,0],[0,3,0,1],[2,0,2,0],[0,1,0,1]]\nOutput: \"abab\"\nExplanation: lcp corresponds to any 4 letter string with two alternating letters. The lexicographically smallest of them is \"abab\".",
            "Input: lcp = [[4,3,2,1],[3,3,2,1],[2,2,2,1],[1,1,1,1]]\nOutput: \"aaaa\"\nExplanation: lcp corresponds to any 4 letter string with a single distinct letter. The lexicographically smallest of them is \"aaaa\".",
            "Input: lcp = [[4,3,2,1],[3,3,2,1],[2,2,2,1],[1,1,1,3]]\nOutput: \"\"\nExplanation: lcp[3][3] cannot be equal to 3 since word[3,...,3] consists of only a single letter; Thus, no answer exists."
        ],
        "constraints": "1 <= n ==\u00a0lcp.length == lcp[i].length\u00a0<= 1000\n0 <= lcp[i][j] <= n",
        "oracle_code": "class Solution:\n    def findTheString(self, lcp: List[List[int]]) -> str:\n        # simple validation\n        n = len(lcp)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if lcp[i][j] != lcp[j][i]:\n                    return ''\n                if lcp[i][j] > n - j:\n                    return ''\n        for i in range(n):\n            if lcp[i][i] != n - i:\n                return ''\n        \n        # build pattern \\u2014 the only possible candidate for answer\n        pattern = [None for _ in range(n)]\n        next_el_ind = 0\n        for i in range(n):\n            if pattern[i] is not None:\n                continue\n            pattern[i] = next_el_ind\n            next_el_ind += 1\n            for j in range(i+1, n):\n                if lcp[i][j] > 0:\n                    if pattern[j] is not None and pattern[j] != pattern[i]:\n                        return ''\n                    pattern[j] = pattern[i]\n    \n        # check if lcp is valid - check that pattern's lcp == original lcp\n        pattern_lcp = [[0 for _ in range(n)] for _ in range(n)]\n        for i in range(n-1, -1, -1):\n            for j in range(n-1, -1, -1):\n                if pattern[i] == pattern[j]:\n                    if max(i, j) + 1 < n:\n                        pattern_lcp[i][j] = pattern_lcp[i+1][j+1] + 1\n                    else:\n                        pattern_lcp[i][j] = 1\n        for i in range(n):\n            for j in range(n):\n                if lcp[i][j] != pattern_lcp[i][j]:\n                    return ''\n    \n        # check that answer has no more than 26 distinct elements\n        if max(pattern) > ord('z') - ord('a'):\n            return ''\n\n        return  ''.join(chr(ord('a') + ind) for ind in pattern)",
        "content": "# Complexity\\n- Time complexity: $O(N^2)$\\n\\n- Space complexity: $O(N^2)$ (can be reduced to $O(N)$ if build and check new lcp at the same time)\\n\\n# Code\\n```\\nclass Solution:\\n    def findTheString(self, lcp: List[List[int]]) -> str:\\n        # simple validation\\n        n = len(lcp)\\n        for i in range(n):\\n            for j in range(i + 1, n):\\n                if lcp[i][j] != lcp[j][i]:\\n                    return \\'\\'\\n                if lcp[i][j] > n - j:\\n                    return \\'\\'\\n        for i in range(n):\\n            if lcp[i][i] != n - i:\\n                return \\'\\'\\n        \\n        # build pattern \\u2014 the only possible candidate for answer\\n        pattern = [None for _ in range(n)]\\n        next_el_ind = 0\\n        for i in range(n):\\n            if pattern[i] is not None:\\n                continue\\n            pattern[i] = next_el_ind\\n            next_el_ind += 1\\n            for j in range(i+1, n):\\n                if lcp[i][j] > 0:\\n                    if pattern[j] is not None and pattern[j] != pattern[i]:\\n                        return \\'\\'\\n                    pattern[j] = pattern[i]\\n    \\n        # check if lcp is valid - check that pattern\\'s lcp == original lcp\\n        pattern_lcp = [[0 for _ in range(n)] for _ in range(n)]\\n        for i in range(n-1, -1, -1):\\n            for j in range(n-1, -1, -1):\\n                if pattern[i] == pattern[j]:\\n                    if max(i, j) + 1 < n:\\n                        pattern_lcp[i][j] = pattern_lcp[i+1][j+1] + 1\\n                    else:\\n                        pattern_lcp[i][j] = 1\\n        for i in range(n):\\n            for j in range(n):\\n                if lcp[i][j] != pattern_lcp[i][j]:\\n                    return \\'\\'\\n    \\n        # check that answer has no more than 26 distinct elements\\n        if max(pattern) > ord(\\'z\\') - ord(\\'a\\'):\\n            return \\'\\'\\n\\n        return  \\'\\'.join(chr(ord(\\'a\\') + ind) for ind in pattern)\\n```",
        "level": "hard",
        "type": [
            "indentation error",
            "operation error",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n    def findTheString(self, lcp: List[List[int]]) -> str:\n        # simple validation\n        n = len(lcp)\n\n        for i in range(n):\n            for j in range(i + 1, n):\n                if lcp[i][j] = lcp[j][i]:\n                    return ''\n                if lcp[i][j] > n - j:\n                    return ''\n        for i in range(n):\n            if lcp[i][i] = n - i:\n                return ''\n\n        # build pattern \\u2014 the only possible candidate for answer\n        pattern = [None for _ in range(n)]\n        next_el_ind = 0\n        for i in range(n):\n        if pattern[i] is not None:\n            continue\n        pattern[i] = next_el_ind\n        next_el_ind += 1\n        for j in range(i+1, n):\n            if lcp[i][j] > 0:\n                if pattern[j] is not None and pattern[j] != pattern[i]:      \n                    return ''      \n                pattern[j] = pattern[i]\n\n        # check if lcp is valid - check that pattern's lcp == original lcp\n        pattern_lcp = [[0 for _ in range(n)] for _ in range(n)]\n        for i in range(n-1, -1, -1):\n            for j in range(n-1, -1, -1):\n                if pattern[i] == pattern[j]:\n                    if max(i, j) + 1 < n:\n                        pattern_lcp[i][j] = pattern_lcp[i+1][j+1] + 2 //Add 2 instead of 1\n                    else:\n                        pattern_lcp[i][j] = 1\n        for i in range(n):\n            for j in range(n):\n                if lcp[i][j] = pattern_lcp[i][j]:\n                    return ''\n\n\n        # check that answer has no more than 26 distinct elements\n        if max(pattern) > ord('z') - ord('a'):\n            return ''\n\n        return  ''.join(chr(ord('a') + ind) for ind in pattern)\n"
    },
    {
        "slug": "binary-tree-level-order-traversal-ii",
        "description": "Given the root of a binary tree, return the bottom-up level order traversal of its nodes' values. (i.e., from left to right, level by level from leaf to root).",
        "examples": [
            "Input: root = [3,9,20,null,null,15,7]\nOutput: [[15,7],[9,20],[3]]",
            "Input: root = [1]\nOutput: [[1]]",
            "Input: root = []\nOutput: []"
        ],
        "constraints": "The number of nodes in the tree is in the range [0, 2000].\n-1000 <= Node.val <= 1000",
        "oracle_code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:\n        def checkReverse(ans):\n            l,r = 0,len(ans)-1\n            while l<=r:\n                ans[l],ans[r] = ans[r],ans[l]\n                l+=1\n                r-=1\n            return ans\n\n        if not root: return None\n        q,ans = [root],[]\n        while q:\n            n,l = len(q),[]\n            for i in range(n):\n                curr = q.pop(0)\n                l.append(curr.val)\n                if curr.left:\n                    q.append(curr.left)\n                if curr.right:\n                    q.append(curr.right)\n            ans.append(l)\n        return checkReverse(ans)",
        "content": "# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:\\n        def checkReverse(ans):\\n            l,r = 0,len(ans)-1\\n            while l<=r:\\n                ans[l],ans[r] = ans[r],ans[l]\\n                l+=1\\n                r-=1\\n            return ans\\n\\n        if not root: return None\\n        q,ans = [root],[]\\n        while q:\\n            n,l = len(q),[]\\n            for i in range(n):\\n                curr = q.pop(0)\\n                l.append(curr.val)\\n                if curr.left:\\n                    q.append(curr.left)\\n                if curr.right:\\n                    q.append(curr.right)\\n            ans.append(l)\\n        return checkReverse(ans)\\n```",
        "level": "medium",
        "type": [
            "indentation error",
            "colon missing",
            "conditional statement error"
        ],
        "buggy_code": "\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:\n        def checkReverse(ans):\n            l,r = 0,len(ans)-1\n            while l<=r\n                ans[l],ans[r] = ans[r],ans[l]\n                l+=1\n            r-=1\n            return ans\n\n        if not root: return None\n        q,ans = [root],[]\n        while q:\n            n,l = len(q),[]\n            for i in range(n):\n                curr = q.pop(0)\n                l.append(curr.val)\n               q.append(curr.left)\n                q.append(curr.right)\n\n            ans.append(l)\n        return checkReverse(ans)\n"
    },
    {
        "slug": "count-the-repetitions",
        "description": "We define str = [s, n] as the string str which consists of the string s concatenated n times.\n\nFor example, str == [\"abc\", 3] ==\"abcabcabc\".\n\nWe define that string s1 can be obtained from string s2 if we can remove some characters from s2 such that it becomes s1.\n\nFor example, s1 = \"abc\" can be obtained from s2 = \"abdbec\" based on our definition by removing the bolded underlined characters.\n\nYou are given two strings s1 and s2 and two integers n1 and n2. You have the two strings str1 = [s1, n1] and str2 = [s2, n2].\nReturn the maximum integer m such that str = [str2, m] can be obtained from str1.",
        "examples": [
            "Input: s1 = \"acb\", n1 = 4, s2 = \"ab\", n2 = 2\nOutput: 2",
            "Input: s1 = \"acb\", n1 = 1, s2 = \"acb\", n2 = 1\nOutput: 1"
        ],
        "constraints": "1 <= s1.length, s2.length <= 100\ns1 and s2 consist of lowercase English letters.\n1 <= n1, n2 <= 106",
        "oracle_code": "class Solution:\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\n\n        rec, track = [0], defaultdict(int) \n        ct = start = ptr1 = ptr2 = 0\n\n        if not set(s2).issubset(set(s1)): return 0\n\n        s1 = ''.join(char for char in s1 if char in set(s2))\n        \n        while True:\n            for char in s2:\n                ptr = s1.find(char, start)\n                if ptr == -1:\n                    ct += 1\n                    ptr = s1.find(char)\n                start = ptr+1\n            rec.append(ct + 1)\n\n            if rec[-1] > n1: return (len(rec)-2)//n2\n\n            if ptr not in track: track[ptr] = len(rec)-1\n            else: break\n        \n        cycleStart = rec[track[ptr]]\n        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]\n        rest = n1 - cycleStart\n        \n        rem = cycleStart + rest%cycle1\n\n        while rec[ptr2] <= rem: ptr2+= 1\n\n        return (cycle2 * (rest//cycle1) + ptr2-1)//n2",
        "content": "```\\nclass Solution:\\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\\n\\n        rec, track = [0], defaultdict(int) \\n        ct = start = ptr1 = ptr2 = 0\\n\\n        if not set(s2).issubset(set(s1)): return 0\\n\\n        s1 = \\'\\'.join(char for char in s1 if char in set(s2))\\n        \\n        while True:\\n            for char in s2:\\n                ptr = s1.find(char, start)\\n                if ptr == -1:\\n                    ct += 1\\n                    ptr = s1.find(char)\\n                start = ptr+1\\n            rec.append(ct + 1)\\n\\n            if rec[-1] > n1: return (len(rec)-2)//n2\\n\\n            if ptr not in track: track[ptr] = len(rec)-1\\n            else: break\\n        \\n        cycleStart = rec[track[ptr]]\\n        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]\\n        rest = n1 - cycleStart\\n        \\n        rem = cycleStart + rest%cycle1\\n\\n        while rec[ptr2] <= rem: ptr2+= 1\\n\\n        return (cycle2 * (rest//cycle1) + ptr2-1)//n2\\n```\\n[https://leetcode.com/problems/count-the-repetitions/submissions/864907562/](http://)\\n\\nI could be wrong, but I think that time is *O*(*N*) and space is *O*(*N*).",
        "level": "hard",
        "type": [
            "colon missing",
            "unclosed string",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int\n\n        rec, track = [0], defaultdict(int) \n        ct = start = ptr1 = ptr2 = 0\n\n        if not set(s2).issubset(set(s1)): return 0\n\n        s1 = ''.join(char for char in s1 if char in set(s2))\n        \n        while True:\n            for char in s2:\n                ptr = s1.find(char, start)\n                if ptr == -1:\n                    ct += 1\n                    ptr = s1.find(char)\n                start = ptr+1\n            rec.append(ct + 1)\n\n            if rec[-1] > n1: return (len(rec)-2)//n2\n\n            if ptr not in track: track[ptr] = len(0rec)-1\n            \n            else: break\n        \n        cycleStart = rec[track[ptr]]\n        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]\n        rest = n1 - cycleStart\n        \n        rem = cycleStart + rest%cycle1\n\n        while rec[ptr2] <= rem: ptr2+= 1\n\n        return (cycle2 * (rest//cycle1) + ptr2-2)//n2\n"
    },
    {
        "slug": "check-if-string-is-transformable-with-substring-sort-operations",
        "description": "Given two strings s and t, transform string s into string t using the following operation any number of times:\n\nChoose a non-empty substring in s and sort it in place so the characters are in ascending order.\n\n\t\nFor example, applying the operation on the underlined substring in \"14234\" results in \"12344\".\n\n\n\nReturn true if it is possible to transform s into t. Otherwise, return false.\nA substring is a contiguous sequence of characters within a string.",
        "examples": [
            "Input: s = \"84532\", t = \"34852\"\nOutput: true\nExplanation: You can transform s into t using the following sort operations:\n\"84532\" (from index 2 to 3) -> \"84352\"\n\"84352\" (from index 0 to 2) -> \"34852\"",
            "Input: s = \"34521\", t = \"23415\"\nOutput: true\nExplanation: You can transform s into t using the following sort operations:\n\"34521\" -> \"23451\"\n\"23451\" -> \"23415\"",
            "Input: s = \"12345\", t = \"12435\"\nOutput: false"
        ],
        "constraints": "s.length == t.length\n1 <= s.length <= 105\ns and t consist of only digits.",
        "oracle_code": "class BIT():\n    def __init__(self, n):\n        self.n = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        ans = 0\n        i += 1\n        while i > 0:\n            ans += self.tree[i]\n            i -= (i & (-i))\n        return ans\n\n    def update(self, i, value):\n        i += 1\n        while i <= self.n:\n            self.tree[i] += value\n            i += (i & (-i))\n\n\nclass Solution:\n    def isTransformable(self, s: str, t: str) -> bool:\n        if Counter(s)!=Counter(t):\n            return False\n        ind = defaultdict(deque)\n        for id, i in enumerate(t):\n            ind[i].append(id)\n        a = []\n        for i in s:\n            a.append(ind[i].popleft())\n        n=len(a)\n        bt=BIT(n+1)\n        ind=defaultdict(lambda :-1)\n        for i in range(n):\n            inv=bt.sum(n)-bt.sum(a[i])\n            bt.update(a[i],1)\n            for dig in range(int(s[i])-1,-1,-1):\n                if ind[dig]>=i-inv:\n                    return False\n            ind[int(s[i])]=i-inv\n        return True",
        "content": "\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass BIT():\\n    def __init__(self, n):\\n        self.n = n\\n        self.tree = [0] * (n + 1)\\n\\n    def sum(self, i):\\n        ans = 0\\n        i += 1\\n        while i > 0:\\n            ans += self.tree[i]\\n            i -= (i & (-i))\\n        return ans\\n\\n    def update(self, i, value):\\n        i += 1\\n        while i <= self.n:\\n            self.tree[i] += value\\n            i += (i & (-i))\\n\\n\\nclass Solution:\\n    def isTransformable(self, s: str, t: str) -> bool:\\n        if Counter(s)!=Counter(t):\\n            return False\\n        ind = defaultdict(deque)\\n        for id, i in enumerate(t):\\n            ind[i].append(id)\\n        a = []\\n        for i in s:\\n            a.append(ind[i].popleft())\\n        n=len(a)\\n        bt=BIT(n+1)\\n        ind=defaultdict(lambda :-1)\\n        for i in range(n):\\n            inv=bt.sum(n)-bt.sum(a[i])\\n            bt.update(a[i],1)\\n            for dig in range(int(s[i])-1,-1,-1):\\n                if ind[dig]>=i-inv:\\n                    return False\\n            ind[int(s[i])]=i-inv\\n        return True\\n\\n\\n```",
        "level": "hard",
        "type": [
            "colon missing",
            "undefined objects",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass BIT():\n    def __init__(self, n):\n        self.n = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i)\n        ans = 0\n        i += 1\n        while i > 0:\n            ans += self.tree[i]\n            i -= (i & (-i))\n        return ans\n\n    def update(self, i, value):\n        i += 1\n        while i <= self.n:\n            self.tree[i] += value\n            i += (i & (-i))\n\n\nclass Solution:\n    def isTransformable(self, s: str, t: str) -> bool:\n        if Counter(s)!=Counter(t):\n            return False\n        ind = defaultdict(deque)\n        for id, i in enumerate(t):\n            ind[i].append(id)\n        a = []\n        for i in s:\n            a.append(ind[x].popleft())\n        n=len(a)\n        bt=BIT(n+1)\n        ind=defaultdict(lambda :-1)\n        for i in range(n):\n            inv=bt.sum(n)-bt.sum(a[i])\n            bt.update(a[i],1)\n            for dig in range(int(s[i])-1,-1,-1):\n                if ind[dig]>=i-inv:\n                    return False\n            ind[parseFloat(s[i])]=i-inv\n        return True\n"
    },
    {
        "slug": "how-many-numbers-are-smaller-than-the-current-number",
        "description": "Given the array nums, for each nums[i] find out how many numbers in the array are smaller than it. That is, for each nums[i] you have to count the number of valid j's\u00a0such that\u00a0j != i and nums[j] < nums[i].\nReturn the answer in an array.",
        "examples": [
            "Input: nums = [8,1,2,2,3]\nOutput: [4,0,1,1,3]\nExplanation: \nFor nums[0]=8 there exist four smaller numbers than it (1, 2, 2 and 3). \nFor nums[1]=1 does not exist any smaller number than it.\nFor nums[2]=2 there exist one smaller number than it (1). \nFor nums[3]=2 there exist one smaller number than it (1). \nFor nums[4]=3 there exist three smaller numbers than it (1, 2 and 2).",
            "Input: nums = [6,5,4,8]\nOutput: [2,1,0,3]",
            "Input: nums = [7,7,7,7]\nOutput: [0,0,0,0]"
        ],
        "constraints": "2 <= nums.length <= 500\n0 <= nums[i] <= 100",
        "oracle_code": "class Solution:\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\n        count=[0]*101\n        res=[]\n        for num in nums:\n            count[num]+=1 \n        for num in nums:\n            res.append(sum(count[:num]))\n        return res",
        "content": "# Intuition\\nThe problem asks us to find the number of elements in the input list `nums` that are smaller than each element at each position. To solve this, we can use a counting sort technique. We will first count the occurrences of each number in the `nums` list and then use the count information to find the number of elements smaller than each element.\\n\\n# Approach\\n1. Create a `count` list of size 101 (since the constraint specifies that the numbers in the input list will be in the range [0, 100]).\\n2. Traverse through the `nums` list and count the occurrences of each number by incrementing the corresponding index in the `count` list.\\n3. Create a new list `res` to store the results.\\n4. Traverse through the `nums` list again and for each element `num`, find the sum of all elements in `count` list up to the index `num` and append it to the `res` list.\\n5. Return the `res` list as the final result.\\n\\n# Complexity\\n- Time complexity: O(n), where n is the size of the `nums` list. We traverse the list twice, but both traversals are linear in terms of the input size.\\n- Space complexity: O(1) since the `count` list is of constant size (101) and the `res` list is the same size as the input `nums` list. So, we can consider it as O(1) space complexity.\\n# Code\\n```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        count=[0]*101\\n        res=[]\\n        for num in nums:\\n            count[num]+=1 \\n        for num in nums:\\n            res.append(sum(count[:num]))\\n        return res\\n\\n\\n\\n```",
        "level": "easy",
        "type": [
            "indentation error",
            "undefined methods",
            "wrong comment mark"
        ],
        "buggy_code": "\nclass Solution:\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\n        count=[0]*101\n    res=[]\n    for num in nums:\n        count[num]+=1 \n    for num in \n        res.append(self.calculate_numbers(count[:num]))\n    return res\n"
    },
    {
        "slug": "find-kth-bit-in-nth-binary-string",
        "description": "Given two positive integers n and k, the binary string Sn is formed as follows:\n\nS1 = \"0\"\nSi = Si - 1 + \"1\" + reverse(invert(Si - 1)) for i > 1\n\nWhere + denotes the concatenation operation, reverse(x) returns the reversed string x, and invert(x) inverts all the bits in x (0 changes to 1 and 1 changes to 0).\nFor example, the first four strings in the above sequence are:\n\nS1 = \"0\"\nS2 = \"011\"\nS3 = \"0111001\"\nS4 = \"011100110110001\"\n\nReturn the kth bit in Sn. It is guaranteed that k is valid for the given n.",
        "examples": [
            "Input: n = 3, k = 1\nOutput: \"0\"\nExplanation: S3 is \"0111001\".\nThe 1st bit is \"0\".",
            "Input: n = 4, k = 11\nOutput: \"1\"\nExplanation: S4 is \"011100110110001\".\nThe 11th bit is \"1\"."
        ],
        "constraints": "1 <= n <= 20\n1 <= k <= 2n - 1",
        "oracle_code": "class Solution:\n    def findKthBit(self, N, K, R = True):\n        if K == 1: return '0' if R else '1'\n        mid = (1 << (N - 1))\n        if K < mid: return self.findKthBit(N - 1, K, R)\n        if K > mid: return self.findKthBit(N - 1, 2 * mid - K, not R)\n        return '1' if R else '0'",
        "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n\\n### Recursive Approach\\n```\\nclass Solution:\\n    def findKthBit(self, N, K, R = True):\\n        if K == 1: return \\'0\\' if R else \\'1\\'\\n        mid = (1 << (N - 1))\\n        if K < mid: return self.findKthBit(N - 1, K, R)\\n        if K > mid: return self.findKthBit(N - 1, 2 * mid - K, not R)\\n        return \\'1\\' if R else \\'0\\'\\n```\\n\\n### Iterative Approach\\n```\\nclass Solution:\\n    def findKthBit(self, N, K):\\n        ans = 1\\n        mid = (1 << (N - 1))\\n        while K > 1:\\n            if K == mid: return str(ans)\\n            if K > mid: \\n                K = 2 * mid - K\\n                ans ^= 1\\n            mid >>= 1\\n        return str(ans^1)\\n```",
        "level": "medium",
        "type": [
            "undefined methods",
            "== and = confusion",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def findKthBit(self, N, K, R = True):\n        if K == 1: return '0' if R else '1'\n        mid = (1 << (N - 1))\n        if K <= mid: return self.findKthBit(N - 1, K, R)\n        if K = mid: return self.callUndefinedMethod(N - 1, 2 * mid - K, not R)\n        return '1' if R else '0'\n"
    },
    {
        "slug": "best-time-to-buy-and-sell-stock-ii",
        "description": "You are given an integer array prices where prices[i] is the price of a given stock on the ith day.\nOn each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.\nFind and return the maximum profit you can achieve.",
        "examples": [
            "Input: prices = [7,1,5,3,6,4]\nOutput: 7\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7.",
            "Input: prices = [1,2,3,4,5]\nOutput: 4\nExplanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.\nTotal profit is 4.",
            "Input: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0."
        ],
        "constraints": "1 <= prices.length <= 3 * 104\n0 <= prices[i] <= 104",
        "oracle_code": "class Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        if len(prices) < 2:\n            return 0\n        if len(prices) == 2:\n            output = prices[1] - prices[0]\n            return output if output > 0 else 0\n        i = 0\n        j = 1\n        stockBuy = prices[i]\n        stockSell = prices[j]\n        counter = 0\n        profit = 0\n        while counter < len(prices)-2:\n            if stockSell - stockBuy < 0:\n                i = counter + 1\n                j = i + 1\n            else:\n                if prices[j+1] > prices[j]:\n                    j += 1\n                else:\n                    profit = profit + (stockSell - stockBuy)\n                    i = counter + 1\n                    j = i + 1\n\n            stockSell = prices[j]\n            stockBuy = prices[i]\n            counter += 1\n        if (stockSell - stockBuy) > 0:\n            profit = profit + (stockSell - stockBuy)\n        return profit",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        if len(prices) < 2:\\n            return 0\\n        if len(prices) == 2:\\n            output = prices[1] - prices[0]\\n            return output if output > 0 else 0\\n        i = 0\\n        j = 1\\n        stockBuy = prices[i]\\n        stockSell = prices[j]\\n        counter = 0\\n        profit = 0\\n        while counter < len(prices)-2:\\n            if stockSell - stockBuy < 0:\\n                i = counter + 1\\n                j = i + 1\\n            else:\\n                if prices[j+1] > prices[j]:\\n                    j += 1\\n                else:\\n                    profit = profit + (stockSell - stockBuy)\\n                    i = counter + 1\\n                    j = i + 1\\n\\n            stockSell = prices[j]\\n            stockBuy = prices[i]\\n            counter += 1\\n        if (stockSell - stockBuy) > 0:\\n            profit = profit + (stockSell - stockBuy)\\n        return profit \\n```",
        "level": "medium",
        "type": [
            "indentation error",
            "variable value error",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n    if len(prices) < 2:\n        return 0\n    if len(prices) == 2:\n        output = prices[1] - prices[0]\n        return output if output > 0 else 0\n    i = 0\n    j = 1\n    stockBuy = prices[i]\n    stockSell = prices[j]\n    counter = 0\n    profit = 0\n    while counter < len(prices)-2:\n        if stockSell - stockBuy < 0:\n            i = counter + 1\n            j = i + 1\n        else:\n            if prices[j+1] > prices[j]:\n                j += 1\n            else:\n                profit = profit + (stockSell - stockBuy)\n                i = counter\n                j = i + 1\n\n        stockSell = prices[j]\n        stockBuy = prices[i]\n        counter += 1\n    if (stockSell - stockBuy) > 0:\n        profit = profit + (stockSell - random_object)\n    return profit\n"
    },
    {
        "slug": "kth-largest-element-in-an-array",
        "description": "Given an integer array nums and an integer k, return the kth largest element in the array.\nNote that it is the kth largest element in the sorted order, not the kth distinct element.\nCan you solve it without sorting?",
        "examples": [
            "Input: nums = [3,2,1,5,6,4], k = 2\nOutput: 5",
            "Input: nums = [3,2,3,1,2,4,5,5,6], k = 4\nOutput: 4"
        ],
        "constraints": "1 <= k <= nums.length <= 105\n-104 <= nums[i] <= 104",
        "oracle_code": "class Solution:\n    def findKthLargest(self, nums: List[int], k: int) -> int:\n        return sorted(nums)[-k]",
        "content": "# Approach\\n- Sorting\\n\\n# Complexity\\n- Time complexity: O(n*log(n))\\n\\n# Code\\n```\\nclass Solution:\\n    def findKthLargest(self, nums: List[int], k: int) -> int:\\n        return sorted(nums)[-k]\\n```",
        "level": "medium",
        "type": [
            "undefined objects",
            "parentheses mismatch",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution:\n    def findKthLargest(self, nums: List[int], k: int -> int:\n        return sort(no_nums)[-k]\n"
    },
    {
        "slug": "median-of-two-sorted-arrays",
        "description": "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\nThe overall run time complexity should be O(log (m+n)).",
        "examples": [
            "Input: nums1 = [1,3], nums2 = [2]\nOutput: 2.00000\nExplanation: merged array = [1,2,3] and median is 2.",
            "Input: nums1 = [1,2], nums2 = [3,4]\nOutput: 2.50000\nExplanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5."
        ],
        "constraints": "nums1.length == m\nnums2.length == n\n0 <= m <= 1000\n0 <= n <= 1000\n1 <= m + n <= 2000\n-106 <= nums1[i], nums2[i] <= 106",
        "oracle_code": "class Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        p1 = 0\n        p2 = 0\n        new = []\n        while p1 < len(nums1) and p2 < len(nums2):\n            if nums1[p1] < nums2[p2]:\n                new.append(nums1[p1])\n                p1 += 1\n            else:\n                new.append(nums2[p2])\n                p2 += 1\n        while p1 < len(nums1):\n            new.append(nums1[p1])\n            p1 += 1\n        while p2 < len(nums2):\n            new.append(nums2[p2])\n            p2+= 1\n        if len(new) % 2 == 0:\n            index = len(new) // 2\n            median = (new[index] + new[index-1]) / 2\n        else:\n            median = float(new[len(new)//2])\n        return median",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind this approach is to merge the two sorted arrays while maintaining the order, and then finding the median based on the length of the merged array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize two pointers, p1 and p2, for the two input arrays nums1 and nums2, respectively, both starting at index 0.\\n2. Create an empty list new to store the merged array.\\n3. Iterate through both arrays using the pointers. Compare the elements pointed to by p1 and p2. Append the smaller element to the new array and increment the corresponding pointer.\\n4. After the iteration, there might be remaining elements in one of the arrays. Iterate through the remaining elements and append them to the new array.\\n5. Calculate the median based on the length of the new array. If the length is even, take the average of the middle two elements. If the length is odd, take the middle element.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(m + n), where m and n are the lengths of the two input arrays.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(m + n), as the merged array new can contain all the elements from the two input arrays.\\n\\n# Code\\n```\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        p1 = 0\\n        p2 = 0\\n        new = []\\n        while p1 < len(nums1) and p2 < len(nums2):\\n            if nums1[p1] < nums2[p2]:\\n                new.append(nums1[p1])\\n                p1 += 1\\n            else:\\n                new.append(nums2[p2])\\n                p2 += 1\\n        while p1 < len(nums1):\\n            new.append(nums1[p1])\\n            p1 += 1\\n        while p2 < len(nums2):\\n            new.append(nums2[p2])\\n            p2+= 1\\n        if len(new) % 2 == 0:\\n            index = len(new) // 2\\n            median = (new[index] + new[index-1]) / 2\\n        else:\\n            median = float(new[len(new)//2])\\n        return median\\n```",
        "level": "hard",
        "type": [
            "variable value error",
            "colon missing",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float\n        p1 = 0\n        p2 = 0\n        new = []\n        while p1 < len(nums1) and p2 < len(nums2):\n            if nums1[p1] < nums2[p2]:\n                new.append(nums1[p1])\n                p1 += 1\n            else:\n                new.append(nums2[p2])\n                p2 += 1\n        while p1 < len(nums1):\n            new.append(nums1[p1])\n            p2 += 1\n        while p2 <= len(nums2):\n            new.append(nums2[p2])\n            p1 += 1\n\n        if len(new) % 2 == 0:\n            index = len(new) // 2\n            median = (new[index] + new[index-1]) / 2\n        else:\n            median = float(new[len(new)//2])\n        return median\n"
    },
    {
        "slug": "check-if-string-is-transformable-with-substring-sort-operations",
        "description": "Given two strings s and t, transform string s into string t using the following operation any number of times:\n\nChoose a non-empty substring in s and sort it in place so the characters are in ascending order.\n\n\t\nFor example, applying the operation on the underlined substring in \"14234\" results in \"12344\".\n\n\n\nReturn true if it is possible to transform s into t. Otherwise, return false.\nA substring is a contiguous sequence of characters within a string.",
        "examples": [
            "Input: s = \"84532\", t = \"34852\"\nOutput: true\nExplanation: You can transform s into t using the following sort operations:\n\"84532\" (from index 2 to 3) -> \"84352\"\n\"84352\" (from index 0 to 2) -> \"34852\"",
            "Input: s = \"34521\", t = \"23415\"\nOutput: true\nExplanation: You can transform s into t using the following sort operations:\n\"34521\" -> \"23451\"\n\"23451\" -> \"23415\"",
            "Input: s = \"12345\", t = \"12435\"\nOutput: false"
        ],
        "constraints": "s.length == t.length\n1 <= s.length <= 105\ns and t consist of only digits.",
        "oracle_code": "class BIT():\n    def __init__(self, n):\n        self.n = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        ans = 0\n        i += 1\n        while i > 0:\n            ans += self.tree[i]\n            i -= (i & (-i))\n        return ans\n\n    def update(self, i, value):\n        i += 1\n        while i <= self.n:\n            self.tree[i] += value\n            i += (i & (-i))\n\n\nclass Solution:\n    def isTransformable(self, s: str, t: str) -> bool:\n        if Counter(s)!=Counter(t):\n            return False\n        ind = defaultdict(deque)\n        for id, i in enumerate(t):\n            ind[i].append(id)\n        a = []\n        for i in s:\n            a.append(ind[i].popleft())\n        n=len(a)\n        bt=BIT(n+1)\n        ind=defaultdict(lambda :-1)\n        for i in range(n):\n            inv=bt.sum(n)-bt.sum(a[i])\n            bt.update(a[i],1)\n            for dig in range(int(s[i])-1,-1,-1):\n                if ind[dig]>=i-inv:\n                    return False\n            ind[int(s[i])]=i-inv\n        return True",
        "content": "\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass BIT():\\n    def __init__(self, n):\\n        self.n = n\\n        self.tree = [0] * (n + 1)\\n\\n    def sum(self, i):\\n        ans = 0\\n        i += 1\\n        while i > 0:\\n            ans += self.tree[i]\\n            i -= (i & (-i))\\n        return ans\\n\\n    def update(self, i, value):\\n        i += 1\\n        while i <= self.n:\\n            self.tree[i] += value\\n            i += (i & (-i))\\n\\n\\nclass Solution:\\n    def isTransformable(self, s: str, t: str) -> bool:\\n        if Counter(s)!=Counter(t):\\n            return False\\n        ind = defaultdict(deque)\\n        for id, i in enumerate(t):\\n            ind[i].append(id)\\n        a = []\\n        for i in s:\\n            a.append(ind[i].popleft())\\n        n=len(a)\\n        bt=BIT(n+1)\\n        ind=defaultdict(lambda :-1)\\n        for i in range(n):\\n            inv=bt.sum(n)-bt.sum(a[i])\\n            bt.update(a[i],1)\\n            for dig in range(int(s[i])-1,-1,-1):\\n                if ind[dig]>=i-inv:\\n                    return False\\n            ind[int(s[i])]=i-inv\\n        return True\\n\\n\\n```",
        "level": "hard",
        "type": [
            "operation error",
            "undefined objects",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass BIT():\n    def __init__(self, n):\n        self.n = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        ans = 0\n        i += 1\n        while i > 0:\n            ans += self.tree[i]\n            i -= (i & (-i))\n        return ans\n\n    def update(self, i, value):\n        i += 1\n        while i <= self.n:\n            self.tree[i] += value\n            i -= (i & (-i))  \n\n\nclass Solution:\n    def isTransformable(self, s: str, t: str) -> bool:\n        if Counter(s)!=Counter(t):\n            return False\n        ind = defaultdict(deque)\n        for id, i in enumerate(t):\n            ind[i].append(id)\n        a = []\n        for i in s:\n            a.append(ind[x].popleft())\n        n=len(a)\n        bt=BIT(n+1)\n        ind=defaultdict(lambda :-1)\n        for i in range(n):\n            inv=bt.sum(n)-bt.sum(a[i])\n            bt.update(a[i],1)\n            for dig in range(int(s[i])-1,-1,-1):\n                if ind[dig]>=i-inv:\n                    return False\n            ind[parseFloat(s[i])]=i-inv\n        return True\n"
    },
    {
        "slug": "median-of-two-sorted-arrays",
        "description": "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\nThe overall run time complexity should be O(log (m+n)).",
        "examples": [
            "Input: nums1 = [1,3], nums2 = [2]\nOutput: 2.00000\nExplanation: merged array = [1,2,3] and median is 2.",
            "Input: nums1 = [1,2], nums2 = [3,4]\nOutput: 2.50000\nExplanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5."
        ],
        "constraints": "nums1.length == m\nnums2.length == n\n0 <= m <= 1000\n0 <= n <= 1000\n1 <= m + n <= 2000\n-106 <= nums1[i], nums2[i] <= 106",
        "oracle_code": "class Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        p1 = 0\n        p2 = 0\n        new = []\n        while p1 < len(nums1) and p2 < len(nums2):\n            if nums1[p1] < nums2[p2]:\n                new.append(nums1[p1])\n                p1 += 1\n            else:\n                new.append(nums2[p2])\n                p2 += 1\n        while p1 < len(nums1):\n            new.append(nums1[p1])\n            p1 += 1\n        while p2 < len(nums2):\n            new.append(nums2[p2])\n            p2+= 1\n        if len(new) % 2 == 0:\n            index = len(new) // 2\n            median = (new[index] + new[index-1]) / 2\n        else:\n            median = float(new[len(new)//2])\n        return median",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind this approach is to merge the two sorted arrays while maintaining the order, and then finding the median based on the length of the merged array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize two pointers, p1 and p2, for the two input arrays nums1 and nums2, respectively, both starting at index 0.\\n2. Create an empty list new to store the merged array.\\n3. Iterate through both arrays using the pointers. Compare the elements pointed to by p1 and p2. Append the smaller element to the new array and increment the corresponding pointer.\\n4. After the iteration, there might be remaining elements in one of the arrays. Iterate through the remaining elements and append them to the new array.\\n5. Calculate the median based on the length of the new array. If the length is even, take the average of the middle two elements. If the length is odd, take the middle element.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(m + n), where m and n are the lengths of the two input arrays.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(m + n), as the merged array new can contain all the elements from the two input arrays.\\n\\n# Code\\n```\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        p1 = 0\\n        p2 = 0\\n        new = []\\n        while p1 < len(nums1) and p2 < len(nums2):\\n            if nums1[p1] < nums2[p2]:\\n                new.append(nums1[p1])\\n                p1 += 1\\n            else:\\n                new.append(nums2[p2])\\n                p2 += 1\\n        while p1 < len(nums1):\\n            new.append(nums1[p1])\\n            p1 += 1\\n        while p2 < len(nums2):\\n            new.append(nums2[p2])\\n            p2+= 1\\n        if len(new) % 2 == 0:\\n            index = len(new) // 2\\n            median = (new[index] + new[index-1]) / 2\\n        else:\\n            median = float(new[len(new)//2])\\n        return median\\n```",
        "level": "hard",
        "type": [
            "indentation error",
            "== and = confusion",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        p1 = 0\n        p2 = 0\n        new = []\n        while p1 < len(nums1) and p2 < len(nums2):\n            if nums1[p1] < nums2[p2]:\n            new.append(nums1[p1])\n            p1 = 1\n        else:\n            new.append(nums2[p2])\n            p2 += 1\n        while p1 < len(nums1):\n            new.append(nums1[p1])\n            p1 += 1\n        while p2 <= len(nums2):\n            new.append(nums2[p2])\n            p2+= 1\n        if len(new) % 2 == 0:\n            index = len(new) // 2\n            median = (new[index] + new[index-1]) / 2\n        else:\n            median = float(new[len(new)//2])\n        return median\n"
    },
    {
        "slug": "self-dividing-numbers",
        "description": "A self-dividing number is a number that is divisible by every digit it contains.\n\nFor example, 128 is a self-dividing number because 128 % 1 == 0, 128 % 2 == 0, and 128 % 8 == 0.\n\nA self-dividing number is not allowed to contain the digit zero.\nGiven two integers left and right, return a list of all the self-dividing numbers in the range [left, right].",
        "examples": [
            "Input: left = 1, right = 22\nOutput: [1,2,3,4,5,6,7,8,9,11,12,15,22]",
            "Input: left = 47, right = 85\nOutput: [48,55,66,77]"
        ],
        "constraints": "1 <= left <= right <= 104",
        "oracle_code": "class Solution:\n    def selfDividingNumbers(self, left: int, right: int) -> List[int]:\n        res=[]\n        for i in range(left,right+1 ):\n            ch=True\n            for j in str(i):\n                if j!='0':\n                    if i%int(j)!=0:\n                        ch=False\n                else:\n                    ch=False\n                    break   \n            if ch:\n                res.append(i)\n        return res",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def selfDividingNumbers(self, left: int, right: int) -> List[int]:\\n        res=[]\\n        for i in range(left,right+1 ):\\n            ch=True\\n            for j in str(i):\\n                if j!=\\'0\\':\\n                    if i%int(j)!=0:\\n                        ch=False\\n                else:\\n                    ch=False\\n                    break   \\n            if ch:\\n                res.append(i)\\n        return res\\n```",
        "level": "easy",
        "type": [
            "undefined keywords from other languages",
            "wrong comment mark",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def selfDividingNumbers(self, left: int, right: int) -> Lista[int]:\n        res=[]\n        for i in range(left,right ):\n            ch=True\n            for j in str(i):\n                \n                if i%int(j)!=0:\n                    ch=False\n                else:\n                    ch=False\n                    break   \n            if ch:\n                res.append(i)\n        return res\n"
    },
    {
        "slug": "binary-tree-level-order-traversal-ii",
        "description": "Given the root of a binary tree, return the bottom-up level order traversal of its nodes' values. (i.e., from left to right, level by level from leaf to root).",
        "examples": [
            "Input: root = [3,9,20,null,null,15,7]\nOutput: [[15,7],[9,20],[3]]",
            "Input: root = [1]\nOutput: [[1]]",
            "Input: root = []\nOutput: []"
        ],
        "constraints": "The number of nodes in the tree is in the range [0, 2000].\n-1000 <= Node.val <= 1000",
        "oracle_code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:\n        queue=deque()\n        queue.append(root)\n        lst=[]\n        while queue:\n            levels=[]\n            for i in range(len(queue)):\n                tmp=queue.popleft()\n                if tmp:\n                    levels.append(tmp.val)\n                    queue.append(tmp.left)\n                    queue.append(tmp.right)\n\n            if levels:\n                lst.append(levels)\n        return lst[::-1]",
        "content": "# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:\\n        queue=deque()\\n        queue.append(root)\\n        lst=[]\\n        while queue:\\n            levels=[]\\n            for i in range(len(queue)):\\n                tmp=queue.popleft()\\n                if tmp:\\n                    levels.append(tmp.val)\\n                    queue.append(tmp.left)\\n                    queue.append(tmp.right)\\n\\n            if levels:\\n                lst.append(levels)\\n        return lst[::-1]\\n```",
        "level": "medium",
        "type": [
            "other error",
            "undefined keywords from other languages",
            "indexing error"
        ],
        "buggy_code": "\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:\n        queue=deque()\n        queue.append(root)\n        lst=[]\n        while queue:\n            levels=[]\n            for i in range(len(queue)+1): \n                tmp=queue.popleft()\n                if tmp:\n                    levels.append(tmp.val)\n                    queue.append(tmp.right)  \n                    queue.append(tmp.left)   \n\n            if levels:\n                lst.add(levels)\n        return lst[::-1]\n"
    },
    {
        "slug": "valid-arrangement-of-pairs",
        "description": "You are given a 0-indexed 2D integer array pairs where pairs[i] = [starti, endi]. An arrangement of pairs is valid if for every index i where 1 <= i < pairs.length, we have endi-1 == starti.\nReturn any valid arrangement of pairs.\nNote: The inputs will be generated such that there exists a valid arrangement of pairs.",
        "examples": [
            "Input: pairs = [[5,1],[4,5],[11,9],[9,4]]\nOutput: [[11,9],[9,4],[4,5],[5,1]]\nExplanation:\nThis is a valid arrangement since endi-1 always equals starti.\nend0 = 9 == 9 = start1 \nend1 = 4 == 4 = start2\nend2 = 5 == 5 = start3",
            "Input: pairs = [[1,3],[3,2],[2,1]]\nOutput: [[1,3],[3,2],[2,1]]\nExplanation:\nThis is a valid arrangement since endi-1 always equals starti.\nend0 = 3 == 3 = start1\nend1 = 2 == 2 = start2\nThe arrangements [[2,1],[1,3],[3,2]] and [[3,2],[2,1],[1,3]] are also valid.",
            "Input: pairs = [[1,2],[1,3],[2,1]]\nOutput: [[1,2],[2,1],[1,3]]\nExplanation:\nThis is a valid arrangement since endi-1 always equals starti.\nend0 = 2 == 2 = start1\nend1 = 1 == 1 = start2"
        ],
        "constraints": "1 <= pairs.length <= 105\npairs[i].length == 2\n0 <= starti, endi <= 109\nstarti != endi\nNo two pairs are exactly the same.\nThere exists a valid arrangement of pairs.",
        "oracle_code": "class Solution:\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\n        graph = defaultdict(list)\n        degree = defaultdict(int) # net out degree \n        for x, y in pairs: \n            graph[x].append(y)\n            degree[x] += 1\n            degree[y] -= 1\n                \n        for k in degree: \n            if degree[k] == 1: \n                x = k\n                break \n                \n        ans = []\n\n        def fn(x): \n            \"\"\"Return Eulerian path via dfs.\"\"\"\n            while graph[x]: fn(graph[x].pop()) \n            ans.append(x)\n        \n        fn(x)\n        ans.reverse()\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]",
        "content": "Please check out this [commit](https://github.com/gaosanyong/leetcode/commit/b1948f8814bebeca475cbb354cd44d19092dff59) for solutions of weekly 270.\\n\\n```\\nclass Solution:\\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\\n        graph = defaultdict(list)\\n        degree = defaultdict(int) # net out degree \\n        for x, y in pairs: \\n            graph[x].append(y)\\n            degree[x] += 1\\n            degree[y] -= 1\\n                \\n        for k in degree: \\n            if degree[k] == 1: \\n                x = k\\n                break \\n                \\n        ans = []\\n\\n        def fn(x): \\n            \"\"\"Return Eulerian path via dfs.\"\"\"\\n            while graph[x]: fn(graph[x].pop()) \\n            ans.append(x)\\n        \\n        fn(x)\\n        ans.reverse()\\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]\\n```\\n\\nAdding an iterative implementation of Hieholzer\\'s algo from @delphih\\n```\\nclass Solution:\\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\\n        graph = defaultdict(list)\\n        degree = defaultdict(int) # net out degree \\n        for x, y in pairs: \\n            graph[x].append(y)\\n            degree[x] += 1\\n            degree[y] -= 1\\n                \\n        for k in degree: \\n            if degree[k] == 1: \\n                x = k\\n                break \\n                \\n        ans = []\\n        stack = [x]\\n        while stack: \\n            while graph[stack[-1]]: \\n                stack.append(graph[stack[-1]].pop())\\n            ans.append(stack.pop())\\n        ans.reverse()\\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]\\n```",
        "level": "hard",
        "type": [
            "undefined methods",
            "unclosed string",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\n        graph = defaultdict(list)\n        degree = defaultdict(int) # net out degree \n        for x, y in pairs: \n            graph[x].append(y)\n            degree[x] += 1\n            degree[y] -= 1\n                \n        for k in degree: \n            if degree[k] != 1: \n                x = k\n                break \n                \n        ans = []\n\n        def fn(x): \n            \"\"\"Return Eulerian path via dfs.\"\n            while graph[x]: fn(graph[x].pop()) \n            ans.append(x)\n        \n        dfn(s)\n        ans.reverse()\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]\n"
    },
    {
        "slug": "median-of-two-sorted-arrays",
        "description": "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\nThe overall run time complexity should be O(log (m+n)).",
        "examples": [
            "Input: nums1 = [1,3], nums2 = [2]\nOutput: 2.00000\nExplanation: merged array = [1,2,3] and median is 2.",
            "Input: nums1 = [1,2], nums2 = [3,4]\nOutput: 2.50000\nExplanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5."
        ],
        "constraints": "nums1.length == m\nnums2.length == n\n0 <= m <= 1000\n0 <= n <= 1000\n1 <= m + n <= 2000\n-106 <= nums1[i], nums2[i] <= 106",
        "oracle_code": "class Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        p1 = 0\n        p2 = 0\n        new = []\n        while p1 < len(nums1) and p2 < len(nums2):\n            if nums1[p1] < nums2[p2]:\n                new.append(nums1[p1])\n                p1 += 1\n            else:\n                new.append(nums2[p2])\n                p2 += 1\n        while p1 < len(nums1):\n            new.append(nums1[p1])\n            p1 += 1\n        while p2 < len(nums2):\n            new.append(nums2[p2])\n            p2+= 1\n        if len(new) % 2 == 0:\n            index = len(new) // 2\n            median = (new[index] + new[index-1]) / 2\n        else:\n            median = float(new[len(new)//2])\n        return median",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind this approach is to merge the two sorted arrays while maintaining the order, and then finding the median based on the length of the merged array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize two pointers, p1 and p2, for the two input arrays nums1 and nums2, respectively, both starting at index 0.\\n2. Create an empty list new to store the merged array.\\n3. Iterate through both arrays using the pointers. Compare the elements pointed to by p1 and p2. Append the smaller element to the new array and increment the corresponding pointer.\\n4. After the iteration, there might be remaining elements in one of the arrays. Iterate through the remaining elements and append them to the new array.\\n5. Calculate the median based on the length of the new array. If the length is even, take the average of the middle two elements. If the length is odd, take the middle element.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(m + n), where m and n are the lengths of the two input arrays.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(m + n), as the merged array new can contain all the elements from the two input arrays.\\n\\n# Code\\n```\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        p1 = 0\\n        p2 = 0\\n        new = []\\n        while p1 < len(nums1) and p2 < len(nums2):\\n            if nums1[p1] < nums2[p2]:\\n                new.append(nums1[p1])\\n                p1 += 1\\n            else:\\n                new.append(nums2[p2])\\n                p2 += 1\\n        while p1 < len(nums1):\\n            new.append(nums1[p1])\\n            p1 += 1\\n        while p2 < len(nums2):\\n            new.append(nums2[p2])\\n            p2+= 1\\n        if len(new) % 2 == 0:\\n            index = len(new) // 2\\n            median = (new[index] + new[index-1]) / 2\\n        else:\\n            median = float(new[len(new)//2])\\n        return median\\n```",
        "level": "hard",
        "type": [
            "wrong comment mark",
            "== and = confusion",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        p1 = 0\n        p2 = 0\n        \n        while p1 < len(nums1) and p2 < len(nums2):\n            if nums1[p1] < nums2[p2]:\n                new.append(nums1[p1])\n                p1 = 1\n            else:\n                new.append(nums2[p2])\n                p2 += 1\n        while p1 < len(nums1):\n            new.append(nums1[p1])\n            p1 += 1\n        while p2 <= len(nums2):\n            new.append(nums2[p2])\n            p2+= 1\n        if len(new) % 2 == 0:\n            index = len(new) // 2\n            median = (new[index] + new[index-1]) / 2\n        else:\n            median = float(new[len(new)//2])\n        return median\n"
    }
]