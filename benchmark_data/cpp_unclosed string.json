[
    {
        "slug": "shuffle-string",
        "description": "You are given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string.\nReturn the shuffled string.",
        "examples": [
            "Input: s = \"codeleet\", indices = [4,5,6,7,0,2,1,3]\nOutput: \"leetcode\"\nExplanation: As shown, \"codeleet\" becomes \"leetcode\" after shuffling.",
            "Input: s = \"abc\", indices = [0,1,2]\nOutput: \"abc\"\nExplanation: After shuffling, each character remains in its position."
        ],
        "constraints": "s.length == indices.length == n\n1 <= n <= 100\ns consists of only lowercase English letters.\n0 <= indices[i] < n\nAll values of indices are unique.",
        "release_time": 1690699398,
        "oracle_code": "class Solution {\npublic:\n    string restoreString(string s, vector<int>& ind) {\n        int n = s.size();\n        string ans(n, '.');\n        for (int i = 0; i < n; i++) {\n            ans[ind[i]] = s[i];\n        } \n        return ans;\n    }\n};",
        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string restoreString(string s, vector<int>& ind) {\\n        int n = s.size();\\n        string ans(n, \\'.\\');\\n        for (int i = 0; i < n; i++) {\\n            ans[ind[i]] = s[i];\\n        } \\n        return ans;\\n    }\\n};\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\npublic:\n    string restoreString(string s, vector<int>& ind) {\n        int n = s.size();\n        string ans(n, '.\");\n        for (int i = 0; i < n; i++) {\n            ans[ind[i]] = s[i];\n        } \n        return ans;\n    }\n};\n",
        "explanations": "\nThe closing quote for the string '.' isn't there which leads to a string unclosed error.\n"
    },
    {
        "slug": "minimum-number-of-steps-to-make-two-strings-anagram",
        "description": "You are given two strings of the same length s and t. In one step you can choose any character of t and replace it with another character.\nReturn the minimum number of steps to make t an anagram of s.\nAn Anagram of a string is a string that contains the same characters with a different (or the same) ordering.",
        "examples": [
            "Input: s = \"bab\", t = \"aba\"\nOutput: 1\nExplanation: Replace the first 'a' in t with b, t = \"bba\" which is anagram of s.",
            "Input: s = \"leetcode\", t = \"practice\"\nOutput: 5\nExplanation: Replace 'p', 'r', 'a', 'i' and 'c' from t with proper characters to make t anagram of s.",
            "Input: s = \"anagram\", t = \"mangaar\"\nOutput: 0\nExplanation: \"anagram\" and \"mangaar\" are anagrams."
        ],
        "constraints": "1 <= s.length <= 5 * 104\ns.length == t.length\ns and t consist of lowercase English letters only.",
        "release_time": 1678804304,
        "oracle_code": "class Solution {\npublic:\n\n    vector<int> mapping(string s)\n    {\n        vector<int> v(26, 0);\n        for (int i = 0; i < s.size(); i++)\n            v[s[i] - 'a']++;\n        return v;\n    }\n\n    int minSteps(string s, string t) {\n\n    vector<int> mapping1 = mapping(s);\n    vector<int> mapping2 = mapping(t);\n    int count = 0;\n    for (int i = 0; i < 26; i++)\n    {\n        int diff = 0;\n        if (mapping1[i] != 0)\n            if (mapping1[i] > mapping2[i])\n                diff = mapping1[i] - mapping2[i];\n        count += diff;\n    }\n    return count;\n        \n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    vector<int> mapping(string s)\\n    {\\n        vector<int> v(26, 0);\\n        for (int i = 0; i < s.size(); i++)\\n            v[s[i] - \\'a\\']++;\\n        return v;\\n    }\\n\\n    int minSteps(string s, string t) {\\n\\n    vector<int> mapping1 = mapping(s);\\n    vector<int> mapping2 = mapping(t);\\n    int count = 0;\\n    for (int i = 0; i < 26; i++)\\n    {\\n        int diff = 0;\\n        if (mapping1[i] != 0)\\n            if (mapping1[i] > mapping2[i])\\n                diff = mapping1[i] - mapping2[i];\\n        count += diff;\\n    }\\n    return count;\\n        \\n    }\\n};\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\npublic:\n\n    vector<int> mapping(string s)\n    {\n        vector<int> v(26, 0);\n        for (int i = 0; i < s.size(); i++)\n            v[s[i] - 'a']++;\n        return v;\n    }\n\n    int minSteps(string s, string t) {\n\n    vector<int> mapping1 = mapping(s);\n    vector<int> mapping2 = mapping(\"t);\n    int count = 0;\n    for (int i = 0; i < 26; i++)\n    {\n        int diff = 0;\n        if (mapping1[i] != 0)\n            if (mapping1[i] > mapping2[i])\n                diff = mapping1[i] - mapping2[i];\n        count += diff;\n    }\n    return count;\n        \n    }\n};\n",
        "explanations": "\nThe string \"t\" is missing a closing quote, resulting in an unclosed string bug.\n"
    },
    {
        "slug": "number-of-different-integers-in-a-string",
        "description": "You are given a string word that consists of digits and lowercase English letters.\nYou will replace every non-digit character with a space. For example, \"a123bc34d8ef34\" will become \" 123\u00a0 34 8\u00a0 34\". Notice that you are left with some integers that are separated by at least one space: \"123\", \"34\", \"8\", and \"34\".\nReturn the number of different integers after performing the replacement operations on word.\nTwo integers are considered different if their decimal representations without any leading zeros are different.",
        "examples": [
            "Input: word = \"a123bc34d8ef34\"\nOutput: 3\nExplanation: The three different integers are \"123\", \"34\", and \"8\". Notice that \"34\" is only counted once.",
            "Input: word = \"leet1234code234\"\nOutput: 2",
            "Input: word = \"a1b01c001\"\nOutput: 1\nExplanation: The three integers \"1\", \"01\", and \"001\" all represent the same integer because\nthe leading zeros are ignored when comparing their decimal values."
        ],
        "constraints": "1 <= word.length <= 1000\nword consists of digits and lowercase English letters.",
        "release_time": 1669008957,
        "oracle_code": "class Solution {\npublic:\n   int numDifferentIntegers(string word) {\n        int n = word.length();\n        unordered_set<string>s;\n        int i=0;\n        while(i<n){\n            if(isdigit(word[i]) == false){\n                i++;\n                continue;\n            }\n            string temp = \"\";\n            while(i<n && isdigit(word[i])){\n                temp+=word[i];\n                i++;\n            }\n            int j=0;\n            while(j<temp.length() && temp[j] == '0') j++;\n            temp = temp.substr(j);\n            s.insert(temp);\n        }\n        return s.size();\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   int numDifferentIntegers(string word) {\\n        int n = word.length();\\n        unordered_set<string>s;\\n        int i=0;\\n        while(i<n){\\n            if(isdigit(word[i]) == false){\\n                i++;\\n                continue;\\n            }\\n            string temp = \"\";\\n            while(i<n && isdigit(word[i])){\\n                temp+=word[i];\\n                i++;\\n            }\\n            int j=0;\\n            while(j<temp.length() && temp[j] == \\'0\\') j++;\\n            temp = temp.substr(j);\\n            s.insert(temp);\\n        }\\n        return s.size();\\n    }\\n};\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\npublic:\n   int numDifferentIntegers(string word) {\n        int n = word.length();\n        unordered_set<string>s;\n        int i=0;\n        while(i<n){\n            if(isdigit(word[i]) == false){\n                i++;\n                continue;\n            }\n            string temp = \"Start of sub-string;\n            while(i<n && isdigit(word[i])){\n                temp+=word[i];\n                i++;\n            }\n            int j=0;\n            while(j<temp.length() && temp[j] == '0') j++;\n            temp = temp.substr(j);\n            s.insert(temp);\n        }\n        return s.size();\n    }\n};\n",
        "explanations": "\nThe string temp is left unclosed after \"Start of sub-string\". This will cause an error.\n"
    },
    {
        "slug": "lexicographically-smallest-string-after-substring-operation",
        "description": "You are given a string s consisting of only lowercase English letters. In one operation, you can do the following:\n\nSelect any non-empty substring of s, possibly the entire string, then replace each one of its characters with the previous character of the English alphabet. For example, 'b' is converted to 'a', and 'a' is converted to 'z'.\n\nReturn the lexicographically smallest string you can obtain after performing the above operation exactly once.\nA substring is a contiguous sequence of characters in a string.\nA string x is lexicographically smaller than a string y of the same length if x[i] comes before y[i] in alphabetic order for the first position i such that x[i] != y[i].",
        "examples": [
            "Input: s = \"cbabc\"\nOutput: \"baabc\"\nExplanation: We apply the operation on the substring starting at index 0, and ending at index 1 inclusive. \nIt can be proven that the resulting string is the lexicographically smallest.",
            "Input: s = \"acbbc\"\nOutput: \"abaab\"\nExplanation: We apply the operation on the substring starting at index 1, and ending at index 4 inclusive. \nIt can be proven that the resulting string is the lexicographically smallest.",
            "Input: s = \"leetcode\"\nOutput: \"kddsbncd\"\nExplanation: We apply the operation on the entire string. \nIt can be proven that the resulting string is the lexicographically smallest."
        ],
        "constraints": "1 <= s.length <= 3 * 105\ns consists of lowercase English letters",
        "release_time": 1686461405,
        "oracle_code": "class Solution {\npublic:\n    string smallestString(string s) {\n        int temp = -1;\n        int cnt = 0;\n        for(int i = 0; i < s.size(); i++)\n        {\n            if(s[i] == 'a')\n            {\n                cnt++;\n            }\n        }\n        if(cnt == s.size())\n        {\n            s[s.size() - 1] = 'z';\n            return s;\n        }\n        else\n        {\n            for(int i = 0; i < s.size(); i++)\n            {\n                if(s[i] == 'a')\n                {\n                    temp = i;\n                    break;\n                }\n            }\n\n            if(temp == 0)\n            {\n                int temp1 = 1, temp2 = 1;\n                for(int i = 1 ; i < s.size(); i++)\n                {\n                    if(s[i] != 'a')\n                    {\n                        temp1 = i;\n                        break;\n                    }\n                }\n                for(int i = temp1; i < s.size(); i++)\n                {\n                    if(s[i] == 'a')\n                    {\n                        temp2 = i;\n                        break;\n                    }\n                }\n\n                if(temp2 > 1)\n                {\n                    for(int i = temp1; i < temp2; i++)\n                    {\n                        s[i] = s[i] - 1;\n                    }\n                }\n                else if(temp2 == 1)\n                {\n                    for(int i = temp1; i < s.size(); i++)\n                    {\n                        s[i] = s[i] - 1;\n                    }\n                }\n\n                return s;\n            }\n            else if(temp == -1)\n            {\n                for(int i = 0; i < s.size(); i++)\n                {\n                    s[i] = s[i] - 1;\n                }\n                return s;\n            }\n            else\n            {\n                for(int i = 0; i < temp; i++)\n                {\n                    s[i] = s[i] - 1;\n                }\n                return s;\n            }\n        }\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCheck for the first occurence of \\'a\\'.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Check for the index where \\'a\\' has occured the very first time.\\n2. If it is index 0, then check for the very first index at which s[i] != \\'a\\', store this index in temp1 variable, then from temp1 check for the nearest occurence of \\'a\\' and store in temp2 variable, and from temp1 till temp2 - 1, replace all the letters with their previous one (alphabetically).\\n3. If index of first occurence of \\'a\\' is greater than 0 and store it in temp variable, then simply starting from 0 and ranging to temp - 1, replace all the letters with their previous one (alphabetically).\\n\\n# Complexity\\n- Time complexity: **O(n)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nIn worst case, we need to traverse the whole string.\\n\\n- Space complexity: **O(1)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nConstant extra space.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string smallestString(string s) {\\n        int temp = -1;\\n        int cnt = 0;\\n        for(int i = 0; i < s.size(); i++)\\n        {\\n            if(s[i] == \\'a\\')\\n            {\\n                cnt++;\\n            }\\n        }\\n        if(cnt == s.size())\\n        {\\n            s[s.size() - 1] = \\'z\\';\\n            return s;\\n        }\\n        else\\n        {\\n            for(int i = 0; i < s.size(); i++)\\n            {\\n                if(s[i] == \\'a\\')\\n                {\\n                    temp = i;\\n                    break;\\n                }\\n            }\\n\\n            if(temp == 0)\\n            {\\n                int temp1 = 1, temp2 = 1;\\n                for(int i = 1 ; i < s.size(); i++)\\n                {\\n                    if(s[i] != \\'a\\')\\n                    {\\n                        temp1 = i;\\n                        break;\\n                    }\\n                }\\n                for(int i = temp1; i < s.size(); i++)\\n                {\\n                    if(s[i] == \\'a\\')\\n                    {\\n                        temp2 = i;\\n                        break;\\n                    }\\n                }\\n\\n                if(temp2 > 1)\\n                {\\n                    for(int i = temp1; i < temp2; i++)\\n                    {\\n                        s[i] = s[i] - 1;\\n                    }\\n                }\\n                else if(temp2 == 1)\\n                {\\n                    for(int i = temp1; i < s.size(); i++)\\n                    {\\n                        s[i] = s[i] - 1;\\n                    }\\n                }\\n\\n                return s;\\n            }\\n            else if(temp == -1)\\n            {\\n                for(int i = 0; i < s.size(); i++)\\n                {\\n                    s[i] = s[i] - 1;\\n                }\\n                return s;\\n            }\\n            else\\n            {\\n                for(int i = 0; i < temp; i++)\\n                {\\n                    s[i] = s[i] - 1;\\n                }\\n                return s;\\n            }\\n        }\\n    }\\n};\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\npublic:\n    string smallestString(string s) {\n        int temp = -1;\n        int cnt = 0;\n        for(int i = 0; i < s.size(); i++)\n        {\n            if(s[i] == 'a')\n            {\n                cnt++;\n            }\n        }\n        string msg = \"Input data: ;\n        if(cnt == s.size())\n        {\n            s[s.size() - 1] = 'z';\n            return s;\n        }\n        else\n        {\n            for(int i = 0; i < s.size(); i++)\n            {\n                if(s[i] == 'a')\n                {\n                    temp = i;\n                    break;\n                }\n            }\n\n            if(temp == 0)\n            {\n                int temp1 = 1, temp2 = 1;\n                for(int i = 1 ; i < s.size(); i++)\n                {\n                    if(s[i] != 'a')\n                    {\n                        temp1 = i;\n                        break;\n                    }\n                }\n                for(int i = temp1; i < s.size(); i++)\n                {\n                    if(s[i] == 'a')\n                    {\n                        temp2 = i;\n                        break;\n                    }\n                }\n\n                if(temp2 > 1)\n                {\n                    for(int i = temp1; i < temp2; i++)\n                    {\n                        s[i] = s[i] - 1;\n                    }\n                }\n                else if(temp2 == 1)\n                {\n                    for(int i = temp1; i < s.size(); i++)\n                    {\n                        s[i] = s[i] - 1;\n                    }\n                }\n\n                return s;\n            }\n            else if(temp == -1)\n            {\n                for(int i = 0; i < s.size(); i++)\n                {\n                    s[i] = s[i] - 1;\n                }\n                return s;\n            }\n            else\n            {\n                for(int i = 0; i < temp; i++)\n                {\n                    s[i] = s[i] - 1;\n                }\n                return s;\n            }\n        }\n    }\n};\n",
        "explanations": "\nUnclosed string introduced by not closing the quotes in the line defining the 'msg' variable.\n"
    },
    {
        "slug": "valid-anagram",
        "description": "Given two strings s and t, return true if t is an anagram of s, and false otherwise.\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.",
        "examples": [
            "Input: s = \"anagram\", t = \"nagaram\"\nOutput: true",
            "Input: s = \"rat\", t = \"car\"\nOutput: false"
        ],
        "constraints": "1 <= s.length, t.length <= 5 * 104\ns and t consist of lowercase English letters.",
        "release_time": 1679637788,
        "oracle_code": "class Solution {\npublic:\n    bool isAnagram(string s, string t) {\n        if(s.length()!=t.length())\n            return false;\n        vector<int> freq(26, 0);\n        for(int i =0; i<s.length(); i++){\n            freq[s[i]-'a']++;\n            freq[t[i]-'a']--;\n        }\n        for(int i =0; i<freq.size(); i++){\n            if(freq[i]!=0)\n                return false;\n        }\n        return true;\n    }\n};",
        "content": "# Intuition\\nTo solve this problem we will count occurence of each character in both strings and if they are same then both strings are anagram of each other.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nWe can use vector of length 26 to track the occurences of character. \\nIf the size of both string is different then they can\\'t be anagram of each other, so we are checking this first.We loop through each character in both strings and increment the frequency of the corresponding letter in s and decrement the frequency of the corresponding letter in t.\\nThen we loop through freq array if all the elements are 0, if all the elements are 0 this means the two strings are anagram and if not then these things are not anagram of each othe.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n), n is the size of s or t string.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isAnagram(string s, string t) {\\n        if(s.length()!=t.length())\\n            return false;\\n        vector<int> freq(26, 0);\\n        for(int i =0; i<s.length(); i++){\\n            freq[s[i]-\\'a\\']++;\\n            freq[t[i]-\\'a\\']--;\\n        }\\n        for(int i =0; i<freq.size(); i++){\\n            if(freq[i]!=0)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\npublic:\n    bool isAnagram(string s, string t) {\n        if(s.length()!=t.length())\n            return false;\n        vector<int> freq(26, 0);\n        for(int i =0; i<s.length(); i++){\n            freq[s[i]-'a']++;\n            freq[t[i]-'a']--;\n        }\n        for(int i =0; i<freq.size(); i++){\n            if(freq[i]!=0)\n                return 'false;\n        }\n        return true;\n    }\n};\n",
        "explanations": "\nThe string 'false is unclosed which causes a compilation error.\n"
    },
    {
        "slug": "total-appeal-of-a-string",
        "description": "The appeal of a string is the number of distinct characters found in the string.\n\nFor example, the appeal of \"abbca\" is 3 because it has 3 distinct characters: 'a', 'b', and 'c'.\n\nGiven a string s, return the total appeal of all of its substrings.\nA substring is a contiguous sequence of characters within a string.",
        "examples": [
            "Input: s = \"abbca\"\nOutput: 28\nExplanation: The following are the substrings of \"abbca\":\n- Substrings of length 1: \"a\", \"b\", \"b\", \"c\", \"a\" have an appeal of 1, 1, 1, 1, and 1 respectively. The sum is 5.\n- Substrings of length 2: \"ab\", \"bb\", \"bc\", \"ca\" have an appeal of 2, 1, 2, and 2 respectively. The sum is 7.\n- Substrings of length 3: \"abb\", \"bbc\", \"bca\" have an appeal of 2, 2, and 3 respectively. The sum is 7.\n- Substrings of length 4: \"abbc\", \"bbca\" have an appeal of 3 and 3 respectively. The sum is 6.\n- Substrings of length 5: \"abbca\" has an appeal of 3. The sum is 3.\nThe total sum is 5 + 7 + 7 + 6 + 3 = 28.",
            "Input: s = \"code\"\nOutput: 20\nExplanation: The following are the substrings of \"code\":\n- Substrings of length 1: \"c\", \"o\", \"d\", \"e\" have an appeal of 1, 1, 1, and 1 respectively. The sum is 4.\n- Substrings of length 2: \"co\", \"od\", \"de\" have an appeal of 2, 2, and 2 respectively. The sum is 6.\n- Substrings of length 3: \"cod\", \"ode\" have an appeal of 3 and 3 respectively. The sum is 6.\n- Substrings of length 4: \"code\" has an appeal of 4. The sum is 4.\nThe total sum is 4 + 6 + 6 + 4 = 20."
        ],
        "constraints": "1 <= s.length <= 105\ns consists of lowercase English letters.",
        "release_time": 1684999206,
        "oracle_code": "class Solution {\npublic:\n    long long appealSum(string s) {\n        long long int x = 1, y = 1, k = 0;\n        vector<int> v(26,-1);//make an array store index of chars\n\n        v[s[0]-'a'] = 1; \n        // cout<<1<<\" \";\n        for(int i = 1; i < s.length(); i++){\n            x += i+1;//x is strore ans till ith index.\n            if(v[s[i]-'a'] > 0){//if char previously came than increment and by curr index - pre index\n                x -= v[s[i]-'a'];\n            }\n            // cout<<x<<\" \";\n            y += x;\n            v[s[i]-'a'] = i+1;//storing index\n        }\n        return y;//y is ans variable\n    }\n};",
        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long appealSum(string s) {\\n        long long int x = 1, y = 1, k = 0;\\n        vector<int> v(26,-1);//make an array store index of chars\\n\\n        v[s[0]-\\'a\\'] = 1; \\n        // cout<<1<<\" \";\\n        for(int i = 1; i < s.length(); i++){\\n            x += i+1;//x is strore ans till ith index.\\n            if(v[s[i]-\\'a\\'] > 0){//if char previously came than increment and by curr index - pre index\\n                x -= v[s[i]-\\'a\\'];\\n            }\\n            // cout<<x<<\" \";\\n            y += x;\\n            v[s[i]-\\'a\\'] = i+1;//storing index\\n        }\\n        return y;//y is ans variable\\n    }\\n};\\n```",
        "level": "hard",
        "buggy_code": "\nclass Solution {\npublic:\n    long long appealSum(string s) {\n        long long int x = 1, y = 1, k = 0;\n        vector<int> v(26,-1);//make an array store index of chars\n\n        v[s[0]-'a'] = 1; \n        // cout<<1<<\" \";\n        for(int i = 1; i < s.length(); i++){\n            x += i+1;//x is strore ans till ith index.\n            if(v[s[i]-'a'] > 0){//if char previously came than increment and by curr index - pre index\n                x -= v[s[i]-'a'];\n            }\n            // cout<<x<<\" \";\n            y += x;\n            v[s[i]-'a'] = i+1;//storing index\n        }\n        return \"y;\n    }\n};\n",
        "explanations": "\nThe string 'y' is not properly closed, causing a syntax error in the code.\n"
    },
    {
        "slug": "final-value-of-variable-after-performing-operations",
        "description": "There is a programming language with only four operations and one variable X:\n\n++X and X++ increments the value of the variable X by 1.\n--X and X-- decrements the value of the variable X by 1.\n\nInitially, the value of X is 0.\nGiven an array of strings operations containing a list of operations, return the final value of X after performing all the operations.",
        "examples": [
            "Input: operations = [\"--X\",\"X++\",\"X++\"]\nOutput: 1\nExplanation:\u00a0The operations are performed as follows:\nInitially, X = 0.\n--X: X is decremented by 1, X =  0 - 1 = -1.\nX++: X is incremented by 1, X = -1 + 1 =  0.\nX++: X is incremented by 1, X =  0 + 1 =  1.",
            "Input: operations = [\"++X\",\"++X\",\"X++\"]\nOutput: 3\nExplanation: The operations are performed as follows:\nInitially, X = 0.\n++X: X is incremented by 1, X = 0 + 1 = 1.\n++X: X is incremented by 1, X = 1 + 1 = 2.\nX++: X is incremented by 1, X = 2 + 1 = 3.",
            "Input: operations = [\"X++\",\"++X\",\"--X\",\"X--\"]\nOutput: 0\nExplanation:\u00a0The operations are performed as follows:\nInitially, X = 0.\nX++: X is incremented by 1, X = 0 + 1 = 1.\n++X: X is incremented by 1, X = 1 + 1 = 2.\n--X: X is decremented by 1, X = 2 - 1 = 1.\nX--: X is decremented by 1, X = 1 - 1 = 0."
        ],
        "constraints": "1 <= operations.length <= 100\noperations[i] will be either \"++X\", \"X++\", \"--X\", or \"X--\".",
        "release_time": 1690653502,
        "oracle_code": "class Solution {\npublic:\n    int finalValueAfterOperations(vector<string>& operations) {\n        int x = 0;\n        for (auto& operation : operations) {\n            if (operation[1] == '+') x++;\n            else x--;\n        }\n        return x;\n    }\n};",
        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int finalValueAfterOperations(vector<string>& operations) {\\n        int x = 0;\\n        for (auto& operation : operations) {\\n            if (operation[1] == \\'+\\') x++;\\n            else x--;\\n        }\\n        return x;\\n    }\\n};\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\npublic:\n    int finalValueAfterOperations(vector<string>& operations) {\n        int x = 0;\n        for (auto& operation : operations) {\n            if (operation[1] == '+') x++;\n            else x--;\n        }\n        cout << \"The final value is: ;\n        return x;\n    }\n};\n",
        "explanations": "\nThere is an error of having an unclosed string at \"The final value is\".\n"
    },
    {
        "slug": "longest-common-prefix",
        "description": "Write a function to find the longest common prefix string amongst an array of strings.\nIf there is no common prefix, return an empty string \"\".",
        "examples": [
            "Input: strs = [\"flower\",\"flow\",\"flight\"]\nOutput: \"fl\"",
            "Input: strs = [\"dog\",\"racecar\",\"car\"]\nOutput: \"\"\nExplanation: There is no common prefix among the input strings."
        ],
        "constraints": "1 <= strs.length <= 200\n0 <= strs[i].length <= 200\nstrs[i] consists of only lowercase English letters.",
        "release_time": 1692119515,
        "oracle_code": "class Solution {\npublic:\n    string longestCommonPrefix(vector<string>& str) \n    {\n        sort(str.begin(), str.end()); //sorting the array\n        string ans=\"\"; //creating a new empty string to store the common prefixes\n        for(int i=0;i<str[0].length();i++) // max iterations = length of the first string\n        {\n            if(str[0][i]!=str[str.size()-1][i]) // checking the characters of the first and last string\n                break;\n            ans+=str[0][i]; // concatinate if the characters are matching\n        }\n        return ans;\n    }\n};",
        "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWhen you sort an array, it is enough to check for the common characters of the the first & last string of the sorted vector.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& str) \\n    {\\n        sort(str.begin(), str.end()); //sorting the array\\n        string ans=\"\"; //creating a new empty string to store the common prefixes\\n        for(int i=0;i<str[0].length();i++) // max iterations = length of the first string\\n        {\\n            if(str[0][i]!=str[str.size()-1][i]) // checking the characters of the first and last string\\n                break;\\n            ans+=str[0][i]; // concatinate if the characters are matching\\n        }\\n        return ans;\\n    }\\n};\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\npublic:\n    string longestCommonPrefix(vector<string>& str) \n    {\n        sort(str.begin(), str.end()); //sorting the array\n        string ans=\"; \n        for(int i=0;i<str[0].length();i++) // max iterations = length of the first string\n        {\n            if(str[0][i]!=str[str.size()-1][i]) // checking the characters of the first and last string\n                break;\n            ans+=str[0][i]; // concatinate if the characters are matching\n        }\n        return ans;\n    }\n};\n",
        "explanations": "\nThe string 'ans' initialization in 'longestCommonPrefix' function is unclosed, which causes a syntax error.\n"
    },
    {
        "slug": "brace-expansion-ii",
        "description": "Under the grammar given below, strings can represent a set of lowercase words. Let\u00a0R(expr)\u00a0denote the set of words the expression represents.\nThe grammar can best be understood through simple examples:\n\nSingle letters represent a singleton set containing that word.\n\t\nR(\"a\") = {\"a\"}\nR(\"w\") = {\"w\"}\n\n\nWhen we take a comma-delimited list of two or more expressions, we take the union of possibilities.\n\t\nR(\"{a,b,c}\") = {\"a\",\"b\",\"c\"}\nR(\"{{a,b},{b,c}}\") = {\"a\",\"b\",\"c\"} (notice the final set only contains each word at most once)\n\n\nWhen we concatenate two expressions, we take the set of possible concatenations between two words where the first word comes from the first expression and the second word comes from the second expression.\n\t\nR(\"{a,b}{c,d}\") = {\"ac\",\"ad\",\"bc\",\"bd\"}\nR(\"a{b,c}{d,e}f{g,h}\") = {\"abdfg\", \"abdfh\", \"abefg\", \"abefh\", \"acdfg\", \"acdfh\", \"acefg\", \"acefh\"}\n\n\n\nFormally, the three rules for our grammar:\n\nFor every lowercase letter x, we have R(x) = {x}.\nFor expressions e1, e2, ... , ek with k >= 2, we have R({e1, e2, ...}) = R(e1) \u222a R(e2) \u222a ...\nFor expressions e1 and e2, we have R(e1 + e2) = {a + b for (a, b) in R(e1) \u00d7 R(e2)}, where + denotes concatenation, and \u00d7 denotes the cartesian product.\n\nGiven an expression representing a set of words under the given grammar, return the sorted list of words that the expression represents.",
        "examples": [
            "Input: expression = \"{a,b}{c,{d,e}}\"\nOutput: [\"ac\",\"ad\",\"ae\",\"bc\",\"bd\",\"be\"]",
            "Input: expression = \"{{a,z},a{b,c},{ab,z}}\"\nOutput: [\"a\",\"ab\",\"ac\",\"z\"]\nExplanation: Each distinct word is written only once in the final answer."
        ],
        "constraints": "1 <= expression.length <= 60\nexpression[i] consists of '{', '}', ','or lowercase English letters.\nThe given\u00a0expression\u00a0represents a set of words based on the grammar given in the description.",
        "release_time": 1677655008,
        "oracle_code": "class Solution {\npublic:\n    \n    vector<string> multiply(vector<string>& a, vector<string>& b){\n        if(a.empty()) return b;\n        if(b.empty()) return a;\n        vector<string> ans;\n        for(auto&i:a){\n            for(auto&j:b) ans.push_back(i+j);\n        }\n        return ans;\n    }\n    \n    vector<string> braceExpansionII(string expression) {\n        vector<string>  res, curr;\n        stack<vector<string>> st;\n        for(auto&x:expression){\n            if(x >= 'a' and x <= 'z'){\n                if(curr.size()) for(auto&i:curr) i += x;\n                else curr.push_back(string(1, x));\n            }\n            else if(x == '{'){\n                st.push(res); st.push(curr);\n                res.clear(), curr.clear();\n            }\n            else if(x == '}'){\n                vector<string> preCurr = st.top(); st.pop();\n                vector<string> preRes = st.top(); st.pop();\n                for(auto&i:curr) res.push_back(i);\n                curr = multiply(preCurr, res);\n                res = preRes;\n            }\n            else if(x == ','){\n                for(auto&i:curr) res.push_back(i);\n                curr.clear();\n            }\n        }\n        for(auto&i:curr) res.push_back(i);\n        sort(res.begin(), res.end());\n        return vector<string>(res.begin(), unique(res.begin(), res.end()));\n    }\n};",
        "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nUse stack to keep track of previous two lists\\n<!-- Describe your approach to solving the problem. -->\\n<!-- \\n# Complexity\\n- Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    vector<string> multiply(vector<string>& a, vector<string>& b){\\n        if(a.empty()) return b;\\n        if(b.empty()) return a;\\n        vector<string> ans;\\n        for(auto&i:a){\\n            for(auto&j:b) ans.push_back(i+j);\\n        }\\n        return ans;\\n    }\\n    \\n    vector<string> braceExpansionII(string expression) {\\n        vector<string>  res, curr;\\n        stack<vector<string>> st;\\n        for(auto&x:expression){\\n            if(x >= \\'a\\' and x <= \\'z\\'){\\n                if(curr.size()) for(auto&i:curr) i += x;\\n                else curr.push_back(string(1, x));\\n            }\\n            else if(x == \\'{\\'){\\n                st.push(res); st.push(curr);\\n                res.clear(), curr.clear();\\n            }\\n            else if(x == \\'}\\'){\\n                vector<string> preCurr = st.top(); st.pop();\\n                vector<string> preRes = st.top(); st.pop();\\n                for(auto&i:curr) res.push_back(i);\\n                curr = multiply(preCurr, res);\\n                res = preRes;\\n            }\\n            else if(x == \\',\\'){\\n                for(auto&i:curr) res.push_back(i);\\n                curr.clear();\\n            }\\n        }\\n        for(auto&i:curr) res.push_back(i);\\n        sort(res.begin(), res.end());\\n        return vector<string>(res.begin(), unique(res.begin(), res.end()));\\n    }\\n};\\n```",
        "level": "hard",
        "buggy_code": "\nclass Solution {\npublic:\n    \n    vector<string> multiply(vector<string>& a, vector<string>& b){\n        if(a.empty()) return b;\n        if(b.empty()) return a;\n        vector<string> ans;\n        for(auto&i:a){\n            for(auto&j:b) ans.push_back(i+j);\n        }\n        return ans;\n    }\n    \n    vector<string> braceExpansionII(string expression) {\n        vector<string>  res, curr;\n        stack<vector<string>> st;\n        for(auto&x:expression){\n            if(x >= 'a' and x <= 'z'){\n                if(curr.size()) for(auto&i:curr) i += x;\n                else curr.push_back(string(1, x));\n            }\n            else if(x == '{'){\n                st.push(res); st.push(curr);\n                res.clear(), curr.clear();\n            }\n            else if(x == '}'){\n                vector<string> preCurr = st.top(); st.pop();\n                vector<string> preRes = st.top(); st.pop();\n                for(auto&i:curr) res.push_back(i);\n                curr = multiply(preCurr, res);\n                res = preRes;\n            }\n            else if(x == ','){\n                for(auto&i:curr) res.push_back(i);\n                curr.clear();\n            }\n        }\n        for(auto&i:curr) res.push_back(i);\n        sort(res.begin(), res.end());\n        return vector<string>(res.begin(), unique(res.begin(), res.end()));\n    }\n}; string message = \"This message is not closed\n",
        "explanations": "\nThe string \"message\" is not closed with a quotation mark (\"), causing it to be unclosed.\n"
    },
    {
        "slug": "shortest-path-to-get-all-keys",
        "description": "You are given an m x n grid grid where:\n\n'.' is an empty cell.\n'#' is a wall.\n'@' is the starting point.\nLowercase letters represent keys.\nUppercase letters represent locks.\n\nYou start at the starting point and one move consists of walking one space in one of the four cardinal directions. You cannot walk outside the grid, or walk into a wall.\nIf you walk over a key, you can pick it up and you cannot walk over a lock unless you have its corresponding key.\nFor some 1 <= k <= 6, there is exactly one lowercase and one uppercase letter of the first k letters of the English alphabet in the grid. This means that there is exactly one key for each lock, and one lock for each key; and also that the letters used to represent the keys and locks were chosen in the same order as the English alphabet.\nReturn the lowest number of moves to acquire all keys. If it is impossible, return -1.",
        "examples": [
            "Input: grid = [\"@.a..\",\"###.#\",\"b.A.B\"]\nOutput: 8\nExplanation: Note that the goal is to obtain all the keys not to open all the locks.",
            "Input: grid = [\"@..aA\",\"..B#.\",\"....b\"]\nOutput: 6",
            "Input: grid = [\"@Aa\"]\nOutput: -1"
        ],
        "constraints": "m == grid.length\nn == grid[i].length\n1 <= m, n <= 30\ngrid[i][j] is either an English letter, '.', '#', or '@'.\u00a0\nThere is exactly one\u00a0'@'\u00a0in the grid.\nThe number of keys in the grid is in the range [1, 6].\nEach key in the grid is unique.\nEach key in the grid has a matching lock.",
        "release_time": 1688009151,
        "oracle_code": "class Solution {\npublic:\n    using int2 = pair<int, int>;\n\n    int shortestPathAllKeys(vector<string>& grid) {\n        int n = grid.size();\n        int m = grid[0].size();\n\n        int2 start;\n        // Scan the start and KeyMask\n        int KeyMask = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                char c = grid[i][j];\n                int2 pos = {i, j};\n                if (c == '@')\n                    start = pos;  // Store the position of the starting point\n                if ('a' <= c && c <= 'z')\n                    KeyMask |= (1 << (c - 'a'));  // Set the corresponding bit in KeyMask for each key found\n            }\n        }\n        // Record the visiting status for every key status\n        vector<vector<vector<bool>>> \n        visit(n, vector<vector<bool>>(m, vector<bool>(KeyMask+1, 0)));\n\n        // [i, j, key state, distance]\n        queue<tuple<int, int, int, int>> q;\n        auto [i0, j0] = start;\n        q.push({i0, j0, 0, 0});  // Push the starting point with initial key state and distance 0\n\n        while (!q.empty()) {\n            auto [i, j, keyState, distance] = q.front();  // Extract current position, key state, and distance from the front of the queue\n            q.pop();\n            vector<int2> adj = {{i + 1, j}, {i, j + 1}, {i - 1, j}, {i, j - 1}};\n            for (auto [a, b] : adj) {\n                if (a < 0 || a >= n || b < 0 || b >= m || grid[a][b] == '#')\n                    continue;  // Skip if the next position is out of bounds or a wall ('#')\n                char c = grid[a][b];\n                // c is a key\n                if ('a' <= c && c <= 'z') {\n                    int keyIdx = c - 'a';  // Calculate the index of the key\n                    int newState = keyState | (1 << keyIdx);  // Update the key state by setting the corresponding bit\n                    if (visit[a][b][newState]) continue;  // Skip if this key state has been visited before at this position\n                    visit[a][b][newState] = 1;  // Mark the current key state as visited at this position\n                    if (newState == KeyMask) return distance + 1;  // If all keys are collected, return the distance\n                    q.push({a, b, newState, distance + 1});  // Push the next position with updated key state and increased distance\n                }\n                // c is a lock\n                else if ('A' <= c && c <= 'F') {\n                    int lockIdx = c - 'A';  // Calculate the index of the lock\n                    if ((keyState & (1 << lockIdx)) == 0) continue;  // Skip if the corresponding key for the lock is missing\n                    if (visit[a][b][keyState]) continue;  // Skip if this key state has been visited before at this position\n                    visit[a][b][keyState] = 1;  // Mark the current key state as visited at this position\n                    q.push({a, b, keyState, distance + 1});  // Push the next position with the same key state and increased distance\n                }\n                // c is ',' or '@'\n                else if (visit[a][b][keyState])\n                    continue;  // Skip if this key state has been visited before at this position\n\n                visit[a][b][keyState] = 1;  // Mark the current key state as visited at this position\n                q.push({a, b, keyState, distance + 1});  // Push the next position with the same key state and increased distance\n            }\n        }\n\n        return -1;  // If all keys cannot be collected, return -1\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nC++ code solves the problem of finding the shortest path to collect all keys in a grid. It uses a BFS approach to explore the grid. It initializes the start position and a bitmask to track collected keys. \\n \\nIt checks if the position contains a key or a lock and updates the key state accordingly. It also keeps track of visited positions with different key states to avoid revisiting them. If all keys are collected, it returns the shortest distance. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThere are at most $2^6=64$ key states, not a large amount. In this case, using the boolean array is faster than using the hash tables.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$O(m\\u22C5n\\u22C52^k)$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$O(m\\u22C5n\\u22C52^k)$\\n# Code with Explanation in comments\\n```\\nclass Solution {\\npublic:\\n    using int2 = pair<int, int>;\\n\\n    int shortestPathAllKeys(vector<string>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n\\n        int2 start;\\n        // Scan the start and KeyMask\\n        int KeyMask = 0;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                char c = grid[i][j];\\n                int2 pos = {i, j};\\n                if (c == \\'@\\')\\n                    start = pos;  // Store the position of the starting point\\n                if (\\'a\\' <= c && c <= \\'z\\')\\n                    KeyMask |= (1 << (c - \\'a\\'));  // Set the corresponding bit in KeyMask for each key found\\n            }\\n        }\\n        // Record the visiting status for every key status\\n        vector<vector<vector<bool>>> \\n        visit(n, vector<vector<bool>>(m, vector<bool>(KeyMask+1, 0)));\\n\\n        // [i, j, key state, distance]\\n        queue<tuple<int, int, int, int>> q;\\n        auto [i0, j0] = start;\\n        q.push({i0, j0, 0, 0});  // Push the starting point with initial key state and distance 0\\n\\n        while (!q.empty()) {\\n            auto [i, j, keyState, distance] = q.front();  // Extract current position, key state, and distance from the front of the queue\\n            q.pop();\\n            vector<int2> adj = {{i + 1, j}, {i, j + 1}, {i - 1, j}, {i, j - 1}};\\n            for (auto [a, b] : adj) {\\n                if (a < 0 || a >= n || b < 0 || b >= m || grid[a][b] == \\'#\\')\\n                    continue;  // Skip if the next position is out of bounds or a wall (\\'#\\')\\n                char c = grid[a][b];\\n                // c is a key\\n                if (\\'a\\' <= c && c <= \\'z\\') {\\n                    int keyIdx = c - \\'a\\';  // Calculate the index of the key\\n                    int newState = keyState | (1 << keyIdx);  // Update the key state by setting the corresponding bit\\n                    if (visit[a][b][newState]) continue;  // Skip if this key state has been visited before at this position\\n                    visit[a][b][newState] = 1;  // Mark the current key state as visited at this position\\n                    if (newState == KeyMask) return distance + 1;  // If all keys are collected, return the distance\\n                    q.push({a, b, newState, distance + 1});  // Push the next position with updated key state and increased distance\\n                }\\n                // c is a lock\\n                else if (\\'A\\' <= c && c <= \\'F\\') {\\n                    int lockIdx = c - \\'A\\';  // Calculate the index of the lock\\n                    if ((keyState & (1 << lockIdx)) == 0) continue;  // Skip if the corresponding key for the lock is missing\\n                    if (visit[a][b][keyState]) continue;  // Skip if this key state has been visited before at this position\\n                    visit[a][b][keyState] = 1;  // Mark the current key state as visited at this position\\n                    q.push({a, b, keyState, distance + 1});  // Push the next position with the same key state and increased distance\\n                }\\n                // c is \\',\\' or \\'@\\'\\n                else if (visit[a][b][keyState])\\n                    continue;  // Skip if this key state has been visited before at this position\\n\\n                visit[a][b][keyState] = 1;  // Mark the current key state as visited at this position\\n                q.push({a, b, keyState, distance + 1});  // Push the next position with the same key state and increased distance\\n            }\\n        }\\n\\n        return -1;  // If all keys cannot be collected, return -1\\n    }\\n};\\n\\n\\n```",
        "level": "hard",
        "buggy_code": "\nclass Solution {\npublic:\n    using int2 = pair<int, int>;\n\n    int shortestPathAllKeys(vector<string>& grid) {\n        int n = grid.size();\n        int m = grid[0].size();\n\n        int2 start;\n        // Scan the start and KeyMask\n        int KeyMask = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                char c = grid[i][j];\n                int2 pos = {i, j};\n                if (c == '@')\n                    start = pos;  // Store the position of the starting point\n                if ('a' <= c && c <= 'z')\n                    KeyMask |= (1 << (c - 'a'));  // Set the corresponding bit in KeyMask for each key found\n            }\n        }\n        // Record the visiting status for every key status\n        vector<vector<vector<bool>>> \n        visit(n, vector<vector<bool>>(m, vector<bool>(KeyMask+1, \"0));\n\n        // [i, j, key state, distance]\n        queue<tuple<int, int, int, int>> q;\n        auto [i0, j0] = start;\n        q.push({i0, j0, 0, 0});  // Push the starting point with initial key state and distance 0\n\n        while (!q.empty()) {\n            auto [i, j, keyState, distance] = q.front();  // Extract current position, key state, and distance from the front of the queue\n            q.pop();\n            vector<int2> adj = {{i + 1, j}, {i, j + 1}, {i - 1, j}, {i, j - 1}};\n            for (auto [a, b] : adj) {\n                if (a < 0 || a >= n || b < 0 || b >= m || grid[a][b] == '#')\n                    continue;  // Skip if the next position is out of bounds or a wall ('#')\n                char c = grid[a][b];\n                // c is a key\n                if ('a' <= c && c <= 'z') {\n                    int keyIdx = c - 'a';  // Calculate the index of the key\n                    int newState = keyState | (1 << keyIdx);  // Update the key state by setting the corresponding bit\n                    if (visit[a][b][newState]) continue;  // Skip if this key state has been visited before at this position\n                    visit[a][b][newState] = 1;  // Mark the current key state as visited at this position\n                    if (newState == KeyMask) return distance + 1;  // If all keys are collected, return the distance\n                    q.push({a, b, newState, distance + 1});  // Push the next position with updated key state and increased distance\n                }\n                // c is a lock\n                else if ('A' <= c && c <= 'F') {\n                    int lockIdx = c - 'A';  // Calculate the index of the lock\n                    if ((keyState & (1 << lockIdx)) == 0) continue;  // Skip if the corresponding key for the lock is missing\n                    if (visit[a][b][keyState]) continue;  // Skip if this key state has been visited before at this position\n                    visit[a][b][keyState] = 1;  // Mark the current key state as visited at this position\n                    q.push({a, b, keyState, distance + 1});  // Push the next position with the same key state and increased distance\n                }\n                // c is ',' or '@'\n                else if (visit[a][b][keyState])\n                    continue;  // Skip if this key state has been visited before at this position\n\n                visit[a][b][keyState] = 1;  // Mark the current key state as visited at this position\n                q.push({a, b, keyState, distance + 1});  // Push the next position with the same key state and increased distance\n            }\n        }\n\n        return -1;  // If all keys cannot be collected, return -1\n    }\n};\n",
        "explanations": "\nAn unclosed string \"0 is used to initialize a boolean vector causing a compile-time error.\n"
    },
    {
        "slug": "capitalize-the-title",
        "description": "You are given a string title consisting of one or more words separated by a single space, where each word consists of English letters. Capitalize the string by changing the capitalization of each word such that:\n\nIf the length of the word is 1 or 2 letters, change all letters to lowercase.\nOtherwise, change the first letter to uppercase and the remaining letters to lowercase.\n\nReturn the capitalized title.",
        "examples": [
            "Input: title = \"capiTalIze tHe titLe\"\nOutput: \"Capitalize The Title\"\nExplanation:\nSince all the words have a length of at least 3, the first letter of each word is uppercase, and the remaining letters are lowercase.",
            "Input: title = \"First leTTeR of EACH Word\"\nOutput: \"First Letter of Each Word\"\nExplanation:\nThe word \"of\" has length 2, so it is all lowercase.\nThe remaining words have a length of at least 3, so the first letter of each remaining word is uppercase, and the remaining letters are lowercase.",
            "Input: title = \"i lOve leetcode\"\nOutput: \"i Love Leetcode\"\nExplanation:\nThe word \"i\" has length 1, so it is lowercase.\nThe remaining words have a length of at least 3, so the first letter of each remaining word is uppercase, and the remaining letters are lowercase."
        ],
        "constraints": "1 <= title.length <= 100\ntitle consists of words separated by a single space without any leading or trailing spaces.\nEach word consists of uppercase and lowercase English letters and is non-empty.",
        "release_time": 1672683061,
        "oracle_code": "class Solution {\npublic:\n    string capitalizeTitle(string s) {\n        int i=0;\n        int n=s.size();\n        int j=0;\n        while(i<n){\n            j=i;\n            int l=0;\n            while(i<n and s[i]!=' ')s[i]=tolower(s[i]),i++,l++;\n            if(i>0)\n            i++;\n            if(l>2){\n                s[j]=toupper(s[j]);\n            }\n            \n        }\n        return s;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust a tarverse and jsut look at at the code for more clearity \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string capitalizeTitle(string s) {\\n        int i=0;\\n        int n=s.size();\\n        int j=0;\\n        while(i<n){\\n            j=i;\\n            int l=0;\\n            while(i<n and s[i]!=\\' \\')s[i]=tolower(s[i]),i++,l++;\\n            if(i>0)\\n            i++;\\n            if(l>2){\\n                s[j]=toupper(s[j]);\\n            }\\n            \\n        }\\n        return s;\\n    }\\n};\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\npublic:\n    string capitalizeTitle(string s) {\n        int i=0;\n        int n=s.size();\n        int j=0;\n        while(i<n){\n            j=i;\n            int l=0;\n            while(i<n and s[i]!=' ')s[i]=tolower(s[i]),i++,l++;\n            if(i>0)\n            string error = \"This string is not closed;\n            i++;\n            if(l>2){\n                s[j]=toupper(s[j]);\n            }\n            \n        }\n        return s;\n    }\n};\n",
        "explanations": "\nThe string defined as \"error\" isn't properly closed which will cause a compilation error.\n"
    },
    {
        "slug": "add-strings",
        "description": "Given two non-negative integers, num1 and num2 represented as string, return the sum of num1 and num2 as a string.\nYou must solve the problem without using any built-in library for handling large integers (such as BigInteger). You must also not convert the inputs to integers directly.",
        "examples": [
            "Input: num1 = \"11\", num2 = \"123\"\nOutput: \"134\"",
            "Input: num1 = \"456\", num2 = \"77\"\nOutput: \"533\"",
            "Input: num1 = \"0\", num2 = \"0\"\nOutput: \"0\""
        ],
        "constraints": "1 <= num1.length, num2.length <= 104\nnum1 and num2 consist of only digits.\nnum1 and num2 don't have any leading zeros except for the zero itself.",
        "release_time": 1688037697,
        "oracle_code": "class Solution {\npublic:\n    string addStrings(string a, string b) {\n        string ret = \"\" ;\n        int carry = 0, i = a.size() - 1, j = b.size() - 1;\n        while( i >= 0 || j >= 0 ){\n            int x = i >= 0 ? a[i--] - '0' : 0 ;\n            int y = j >= 0 ? b[j--] - '0' : 0 ;\n\n            int sm = x + y + carry ;\n            ret.push_back( '0' + (sm % 10) ) ;\n            carry = sm/10;\n        }\n        if(carry)\n            ret.push_back('0' + carry ) ;\n        \n        reverse( ret.begin(), ret.end() ) ;\n\n        return ret ;\n    }\n};",
        "content": "# Intuition\\nSimple solution will be to do the basice math, and simulate the digits from the back\\n\\n# Approach\\n- We\\'ll start with the ends of both strings, and in each iteration (till we\\'ve iterated all the strings), we\\'ll fetch the last digit from the $$nums1$$, $$nums2$$ if not available we\\'ll default to 0.\\n\\n- Then we\\'ll sum the digits and also add the carry from the last iteration,\\n\\n- Then we\\'ll push the sum modulo 10 to the answer string.\\n\\n- Also dont forget to update the carry variable.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string addStrings(string a, string b) {\\n        string ret = \"\" ;\\n        int carry = 0, i = a.size() - 1, j = b.size() - 1;\\n        while( i >= 0 || j >= 0 ){\\n            int x = i >= 0 ? a[i--] - \\'0\\' : 0 ;\\n            int y = j >= 0 ? b[j--] - \\'0\\' : 0 ;\\n\\n            int sm = x + y + carry ;\\n            ret.push_back( \\'0\\' + (sm % 10) ) ;\\n            carry = sm/10;\\n        }\\n        if(carry)\\n            ret.push_back(\\'0\\' + carry ) ;\\n        \\n        reverse( ret.begin(), ret.end() ) ;\\n\\n        return ret ;\\n    }\\n};\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\npublic:\n    string addStrings(string a, string b) {\n        string ret = \" ;\n        int carry = 0, i = a.size() - 1, j = b.size() - 1;\n        while( i >= 0 || j >= 0 ){\n            int x = i >= 0 ? a[i--] - '0' : 0 ;\n            int y = j >= 0 ? b[j--] - '0' : 0 ;\n\n            int sm = x + y + carry ;\n            ret.push_back( '0' + (sm % 10) ) ;\n            carry = sm/10;\n        }\n        if(carry)\n            ret.push_back('0' + carry ) ;\n        \n        reverse( ret.begin(), ret.end() ) ;\n\n        return ret ;\n    }\n};\n",
        "explanations": "\nThe string 'ret' begins with an unclosed double quote causing a syntax error.\n"
    },
    {
        "slug": "flood-fill",
        "description": "An image is represented by an m x n integer grid image where image[i][j] represents the pixel value of the image.\nYou are also given three integers sr, sc, and color. You should perform a flood fill on the image starting from the pixel image[sr][sc].\nTo perform a flood fill, consider the starting pixel, plus any pixels connected 4-directionally to the starting pixel of the same color as the starting pixel, plus any pixels connected 4-directionally to those pixels (also with the same color), and so on. Replace the color of all of the aforementioned pixels with color.\nReturn the modified image after performing the flood fill.",
        "examples": [
            "Input: image = [[1,1,1],[1,1,0],[1,0,1]], sr = 1, sc = 1, color = 2\nOutput: [[2,2,2],[2,2,0],[2,0,1]]\nExplanation: From the center of the image with position (sr, sc) = (1, 1) (i.e., the red pixel), all pixels connected by a path of the same color as the starting pixel (i.e., the blue pixels) are colored with the new color.\nNote the bottom corner is not colored 2, because it is not 4-directionally connected to the starting pixel.",
            "Input: image = [[0,0,0],[0,0,0]], sr = 0, sc = 0, color = 0\nOutput: [[0,0,0],[0,0,0]]\nExplanation: The starting pixel is already colored 0, so no changes are made to the image."
        ],
        "constraints": "m == image.length\nn == image[i].length\n1 <= m, n <= 50\n0 <= image[i][j], color < 216\n0 <= sr < m\n0 <= sc < n",
        "release_time": 1685971605,
        "oracle_code": "class Solution {\npublic:\n    void bfs(int prevcolor,int row,int col,int color,vector<vector<int>>&visited,vector<vector<int>>&image)\n    {\n        // it'll ease the work\n        queue<pair<int,int>> q;\n        q.push({row,col});\n        visited[row][col]=1;\n\n        while(!q.empty())\n        {\n            row = q.front().first;\n            col = q.front().second;\n            q.pop();\n\n            // if img is of the starting color.\n            if(image[row][col]==prevcolor) image[row][col]=color;\n\n            // up\n            if(row-1>=0 && !visited[row-1][col] && image[row-1][col]==prevcolor) q.push({row-1,col}),visited[row-1][col]=1, image[row-1][col]=color;\n\n            // right\n            if(col+1<image[0].size() &&  !visited[row][col+1] && image[row][col+1]==prevcolor) q.push({row,col+1}),visited[row][col+1]=1, image[row][col+1]=color;\n\n            //down\n            if(row+1<image.size() && !visited[row+1][col] && image[row+1][col]==prevcolor) q.push({row+1,col}),visited[row+1][col]=1, image[row+1][col]=color;\n\n            // left\n            if(col-1>=0 && !visited[row][col-1] && image[row][col-1]==prevcolor) q.push({row,col-1}),visited[row][col-1]=1, image[row][col-1]=color;\n        }\n    }\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\n          int prevcolor = image[sr][sc];\n\n          // visiting array.\n          vector<vector<int>> visited(image.size(),vector<int>(image[0].size(),0));\n\n          bfs(prevcolor,sr,sc,color,visited,image);\n\n          return image;\n    }\n};",
        "content": "# Algo\\n\\n1.  Make a visited array of n*m\\n2. store the initial color.\\n3. do the traversal\\n4. Use queue data structure. \\n\\n\\n# Complexity\\n- Time complexity: O(N*M)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N*M)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void bfs(int prevcolor,int row,int col,int color,vector<vector<int>>&visited,vector<vector<int>>&image)\\n    {\\n        // it\\'ll ease the work\\n        queue<pair<int,int>> q;\\n        q.push({row,col});\\n        visited[row][col]=1;\\n\\n        while(!q.empty())\\n        {\\n            row = q.front().first;\\n            col = q.front().second;\\n            q.pop();\\n\\n            // if img is of the starting color.\\n            if(image[row][col]==prevcolor) image[row][col]=color;\\n\\n            // up\\n            if(row-1>=0 && !visited[row-1][col] && image[row-1][col]==prevcolor) q.push({row-1,col}),visited[row-1][col]=1, image[row-1][col]=color;\\n\\n            // right\\n            if(col+1<image[0].size() &&  !visited[row][col+1] && image[row][col+1]==prevcolor) q.push({row,col+1}),visited[row][col+1]=1, image[row][col+1]=color;\\n\\n            //down\\n            if(row+1<image.size() && !visited[row+1][col] && image[row+1][col]==prevcolor) q.push({row+1,col}),visited[row+1][col]=1, image[row+1][col]=color;\\n\\n            // left\\n            if(col-1>=0 && !visited[row][col-1] && image[row][col-1]==prevcolor) q.push({row,col-1}),visited[row][col-1]=1, image[row][col-1]=color;\\n        }\\n    }\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n          int prevcolor = image[sr][sc];\\n\\n          // visiting array.\\n          vector<vector<int>> visited(image.size(),vector<int>(image[0].size(),0));\\n\\n          bfs(prevcolor,sr,sc,color,visited,image);\\n\\n          return image;\\n    }\\n};\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\npublic:\n    void bfs(int prevcolor,int row,int col,int color,vector<vector<int>>&visited,vector<vector<int>>&image)\n    {\n        // it'll ease the work\n        queue<pair<int,int>> q;\n        q.push({row,col});\n        visited[row][col]=1;\n        string unclosedString = \"bug introduction\n\n        while(!q.empty())\n        {\n            row = q.front().first;\n            col = q.front().second;\n            q.pop();\n\n            // if img is of the starting color.\n            if(image[row][col]==prevcolor) image[row][col]=color;\n\n            // up\n            if(row-1>=0 && !visited[row-1][col] && image[row-1][col]==prevcolor) q.push({row-1,col}),visited[row-1][col]=1, image[row-1][col]=color;\n\n            // right\n            if(col+1<image[0].size() &&  !visited[row][col+1] && image[row][col+1]==prevcolor) q.push({row,col+1}),visited[row][col+1]=1, image[row][col+1]=color;\n\n            //down\n            if(row+1<image.size() && !visited[row+1][col] && image[row+1][col]==prevcolor) q.push({row+1,col}),visited[row+1][col]=1, image[row+1][col]=color;\n\n            // left\n            if(col-1>=0 && !visited[row][col-1] && image[row][col-1]==prevcolor) q.push({row,col-1}),visited[row][col-1]=1, image[row][col-1]=color;\n        }\n    }\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\n          int prevcolor = image[sr][sc];\n\n          // visiting array.\n          vector<vector<int>> visited(image.size(),vector<int>(image[0].size(),0));\n\n          bfs(prevcolor,sr,sc,color,visited,image);\n\n          return image;\n    }\n};\n",
        "explanations": "\nThe bug is an unclosed string which ends the code prematurely and causes a syntax error.\n"
    },
    {
        "slug": "find-the-string-with-lcp",
        "description": "We define the lcp matrix of any 0-indexed string word of n lowercase English letters as an n x n grid such that:\n\nlcp[i][j] is equal to the length of the longest common prefix between the substrings word[i,n-1] and word[j,n-1].\n\nGiven an\u00a0n x n matrix lcp, return the alphabetically smallest string word that corresponds to lcp. If there is no such string, return an empty string.\nA string a is lexicographically smaller than a string b (of the same length) if in the first position where a and b differ, string a has a letter that appears earlier in the alphabet than the corresponding letter in b. For example, \"aabd\" is lexicographically smaller than \"aaca\" because the first position they differ is at the third letter, and 'b' comes before 'c'.",
        "examples": [
            "Input: lcp = [[4,0,2,0],[0,3,0,1],[2,0,2,0],[0,1,0,1]]\nOutput: \"abab\"\nExplanation: lcp corresponds to any 4 letter string with two alternating letters. The lexicographically smallest of them is \"abab\".",
            "Input: lcp = [[4,3,2,1],[3,3,2,1],[2,2,2,1],[1,1,1,1]]\nOutput: \"aaaa\"\nExplanation: lcp corresponds to any 4 letter string with a single distinct letter. The lexicographically smallest of them is \"aaaa\".",
            "Input: lcp = [[4,3,2,1],[3,3,2,1],[2,2,2,1],[1,1,1,3]]\nOutput: \"\"\nExplanation: lcp[3][3] cannot be equal to 3 since word[3,...,3] consists of only a single letter; Thus, no answer exists."
        ],
        "constraints": "1 <= n ==\u00a0lcp.length == lcp[i].length\u00a0<= 1000\n0 <= lcp[i][j] <= n",
        "release_time": 1685466785,
        "oracle_code": "class Solution {\npublic:\n    string findTheString(vector<vector<int>>& lcp) {\n       int n= lcp.size();\n       string ans =\"\";\n       if(lcp[0][0]!=n)\n       return ans;\n\n       for(int i=0;i<n;i++){\n           for(int j=0;j<n;j++){\n               if(lcp[i][j]!=lcp[j][i]||lcp[i][j]>n-max(i,j))\n               return ans;\n               if(i+1<n && j+1<n && lcp[i][j]>0 && lcp[i+1][j+1]!=lcp[i][j]-1)\n            return ans;\n           }\n       }\n\n       int t=0;\n       for(int i=0;i<n;i++)\n       ans +='1';\n\n       for(int i=0;i<n;i++){\n           bool flag = false;\n           for(int j=i;j<n;j++){\n               if(ans[j]=='1' && lcp[i][j]!=0){\n                   if(t>=26)\n                   return \"\";\n                   ans[j] ='a'+t;\n                   flag = true;\n               }\n           }\n           if(flag ==true)\n           t++;\n       }\n\n       for(int i=0;i<n;i++){\n           for(int j=0;j<n;j++){\n               if(lcp[i][j]!=0 && ans[i]!=ans[j])\n               return \"\";\n           }\n       }\n       return ans;\n    }\n};",
        "content": "```\\nclass Solution {\\npublic:\\n    string findTheString(vector<vector<int>>& lcp) {\\n       int n= lcp.size();\\n       string ans =\"\";\\n       if(lcp[0][0]!=n)\\n       return ans;\\n\\n       for(int i=0;i<n;i++){\\n           for(int j=0;j<n;j++){\\n               if(lcp[i][j]!=lcp[j][i]||lcp[i][j]>n-max(i,j))\\n               return ans;\\n               if(i+1<n && j+1<n && lcp[i][j]>0 && lcp[i+1][j+1]!=lcp[i][j]-1)\\n            return ans;\\n           }\\n       }\\n\\n       int t=0;\\n       for(int i=0;i<n;i++)\\n       ans +=\\'1\\';\\n\\n       for(int i=0;i<n;i++){\\n           bool flag = false;\\n           for(int j=i;j<n;j++){\\n               if(ans[j]==\\'1\\' && lcp[i][j]!=0){\\n                   if(t>=26)\\n                   return \"\";\\n                   ans[j] =\\'a\\'+t;\\n                   flag = true;\\n               }\\n           }\\n           if(flag ==true)\\n           t++;\\n       }\\n\\n       for(int i=0;i<n;i++){\\n           for(int j=0;j<n;j++){\\n               if(lcp[i][j]!=0 && ans[i]!=ans[j])\\n               return \"\";\\n           }\\n       }\\n       return ans;\\n    }\\n};\\n```",
        "level": "hard",
        "buggy_code": "\nclass Solution {\npublic:\n    string findTheString(vector<vector<int>>& lcp) {\n       int n= lcp.size();\n       string ans =\"\";\n       if(lcp[0][0]!=n)\n       return ans;\n\n       for(int i=0;i<n;i++){\n           for(int j=0;j<n;j++){\n               if(lcp[i][j]!=lcp[j][i]||lcp[i][j]>n-max(i,j))\n               return ans;\n               if(i+1<n && j+1<n && lcp[i][j]>0 && lcp[i+1][j+1]!=lcp[i][j]-1)\n            return ans;\n           }\n       }\n\n       int t=0;\n       for(int i=0;i<n;i++)\n       ans +='1';\n\n       for(int i=0;i<n;i++){\n           bool flag = false;\n           for(int j=i;j<n;j++){\n               if(ans[j]=='1' && lcp[i][j]!=0){\n                   if(t>=26)\n                   return \"\";\n                   ans[j] ='a'+t;\n                   flag = true;\n               }\n           }\n           if(flag ==true)\n           t++;\n       }\n\n       for(int i=0;i<n;i++){\n           for(int j=0;j<n;j++){\n               if(lcp[i][j]!=0 && ans[i]!=ans[j])\n               return \"bug\n           }\n       }\n       return ans;\n    }\n};\n",
        "explanations": "\nThe closing double quotation mark is missing in return \"bug, creating an unclosed string literal.\n"
    },
    {
        "slug": "shortest-path-to-get-all-keys",
        "description": "You are given an m x n grid grid where:\n\n'.' is an empty cell.\n'#' is a wall.\n'@' is the starting point.\nLowercase letters represent keys.\nUppercase letters represent locks.\n\nYou start at the starting point and one move consists of walking one space in one of the four cardinal directions. You cannot walk outside the grid, or walk into a wall.\nIf you walk over a key, you can pick it up and you cannot walk over a lock unless you have its corresponding key.\nFor some 1 <= k <= 6, there is exactly one lowercase and one uppercase letter of the first k letters of the English alphabet in the grid. This means that there is exactly one key for each lock, and one lock for each key; and also that the letters used to represent the keys and locks were chosen in the same order as the English alphabet.\nReturn the lowest number of moves to acquire all keys. If it is impossible, return -1.",
        "examples": [
            "Input: grid = [\"@.a..\",\"###.#\",\"b.A.B\"]\nOutput: 8\nExplanation: Note that the goal is to obtain all the keys not to open all the locks.",
            "Input: grid = [\"@..aA\",\"..B#.\",\"....b\"]\nOutput: 6",
            "Input: grid = [\"@Aa\"]\nOutput: -1"
        ],
        "constraints": "m == grid.length\nn == grid[i].length\n1 <= m, n <= 30\ngrid[i][j] is either an English letter, '.', '#', or '@'.\u00a0\nThere is exactly one\u00a0'@'\u00a0in the grid.\nThe number of keys in the grid is in the range [1, 6].\nEach key in the grid is unique.\nEach key in the grid has a matching lock.",
        "release_time": 1688006204,
        "oracle_code": "class Solution {\npublic:\n\n    int dir[4][2] = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};\n\n    int shortestPathAllKeys(vector<string>& grid) {\n        \n        int m = grid.size();\n        int n = grid[0].size();\n        queue<pair<pair<int, int>, int>> que;\n        vector<vector<unsigned long>> mapKey(m, vector<unsigned long>(n, 0));\n        int target = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if ('a' <= grid[i][j] && grid[i][j] <= 'f') {\n                    target |= 1 << (grid[i][j] - 'a');\n                    continue;\n                }\n\n                if (grid[i][j] == '@') {\n                    que.emplace(pair<int, int>(i, j), 0);\n                    mapKey[i][j] = 1;\n                }\n            }\n        }\n\n\n        int step = 0;\n        while (!que.empty()) {\n            int size = que.size();\n            for (int s = 0; s < size; s++) {\n                int i = que.front().first.first;\n                int j = que.front().first.second;\n                int key = que.front().second;\n                que.pop();\n                \n                if ('a' <= grid[i][j] && grid[i][j] <= 'f') {\n                    key |= 1 << (grid[i][j] - 'a');\n                    if (key == target)\n                        return step;\n\n                    mapKey[i][j] |= 1l << key;\n                }\n\n                for (int d = 0; d < 4; d++) {\n                    int newi = i + dir[d][0];\n                    int newj = j + dir[d][1];\n                    \n                    if (!(0 <= newi && newi < m && 0 <= newj && newj < n))\n                        continue;\n                        \n                    int val = grid[newi][newj];\n                    if (val == '#')\n                        continue;\n                        \n                    if ('A' <= val && val <= 'F' && (key & (1 << (val - 'A'))) == 0)\n                        continue;\n                        \n                    if (mapKey[newi][newj] & (1l << key))\n                        continue;\n                        \n                     mapKey[newi][newj] |= 1l << key;\n                     que.emplace(pair<int, int>(newi, newj), key);\n                }\n            }\n            step++;\n        }\n        return -1;\n    }\n};",
        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int dir[4][2] = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};\\n\\n    int shortestPathAllKeys(vector<string>& grid) {\\n        \\n        int m = grid.size();\\n        int n = grid[0].size();\\n        queue<pair<pair<int, int>, int>> que;\\n        vector<vector<unsigned long>> mapKey(m, vector<unsigned long>(n, 0));\\n        int target = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (\\'a\\' <= grid[i][j] && grid[i][j] <= \\'f\\') {\\n                    target |= 1 << (grid[i][j] - \\'a\\');\\n                    continue;\\n                }\\n\\n                if (grid[i][j] == \\'@\\') {\\n                    que.emplace(pair<int, int>(i, j), 0);\\n                    mapKey[i][j] = 1;\\n                }\\n            }\\n        }\\n\\n\\n        int step = 0;\\n        while (!que.empty()) {\\n            int size = que.size();\\n            for (int s = 0; s < size; s++) {\\n                int i = que.front().first.first;\\n                int j = que.front().first.second;\\n                int key = que.front().second;\\n                que.pop();\\n                \\n                if (\\'a\\' <= grid[i][j] && grid[i][j] <= \\'f\\') {\\n                    key |= 1 << (grid[i][j] - \\'a\\');\\n                    if (key == target)\\n                        return step;\\n\\n                    mapKey[i][j] |= 1l << key;\\n                }\\n\\n                for (int d = 0; d < 4; d++) {\\n                    int newi = i + dir[d][0];\\n                    int newj = j + dir[d][1];\\n                    \\n                    if (!(0 <= newi && newi < m && 0 <= newj && newj < n))\\n                        continue;\\n                        \\n                    int val = grid[newi][newj];\\n                    if (val == \\'#\\')\\n                        continue;\\n                        \\n                    if (\\'A\\' <= val && val <= \\'F\\' && (key & (1 << (val - \\'A\\'))) == 0)\\n                        continue;\\n                        \\n                    if (mapKey[newi][newj] & (1l << key))\\n                        continue;\\n                        \\n                     mapKey[newi][newj] |= 1l << key;\\n                     que.emplace(pair<int, int>(newi, newj), key);\\n                }\\n            }\\n            step++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
        "level": "hard",
        "buggy_code": "\nclass Solution {\npublic:\n\n    int dir[4][2] = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};\n\n    int shortestPathAllKeys(vector<string>& grid) {\n        \n        int m = grid.size();\n        int n = grid[0].size();\n        queue<pair<pair<int, int>, int>> que;\n        vector<vector<unsigned long>> mapKey(m, vector<unsigned long>(n, 0));\n        int target = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if ('a' <= grid[i][j] && grid[i][j] <= 'f') {\n                    target |= 1 << (grid[i][j] - 'a\");\n                    continue;\n                }\n\n                if (grid[i][j] == '@') {\n                    que.emplace(pair<int, int>(i, j), 0);\n                    mapKey[i][j] = 1;\n                }\n            }\n        }\n\n\n        int step = 0;\n        while (!que.empty()) {\n            int size = que.size();\n            for (int s = 0; s < size; s++) {\n                int i = que.front().first.first;\n                int j = que.front().first.second;\n                int key = que.front().second;\n                que.pop();\n                \n                if ('a' <= grid[i][j] && grid[i][j] <= 'f\") {\n                    key |= 1 << (grid[i][j] - 'a\");\n                    if (key == target)\n                        return step;\n\n                    mapKey[i][j] |= 1l << key;\n                }\n\n                for (int d = 0; d < 4; d++) {\n                    int newi = i + dir[d][0];\n                    int newj = j + dir[d][1];\n                    \n                    if (!(0 <= newi && newi < m && 0 <= newj && newj < n))\n                        continue;\n                        \n                    int val = grid[newi][newj];\n                    if (val == '#')\n                        continue;\n                        \n                    if ('A' <= val && val <= 'F' && (key & (1 << (val - 'A\"))) == 0)\n                        continue;\n                        \n                    if (mapKey[newi][newj] & (1l << key))\n                        continue;\n                        \n                     mapKey[newi][newj] |= 1l << key;\n                     que.emplace(pair<int, int>(newi, newj), key);\n                }\n            }\n            step++;\n        }\n        return -1;\n    }\n};\n",
        "explanations": "\nAn unclosed string is present at line 'target |= 1 << (grid[i][j] - 'a\");'\n"
    },
    {
        "slug": "binary-string-with-substrings-representing-1-to-n",
        "description": "Given a binary string s and a positive integer n, return true if the binary representation of all the integers in the range [1, n] are substrings of s, or false otherwise.\nA substring is a contiguous sequence of characters within a string.",
        "examples": [
            "Input: s = \"0110\", n = 3\nOutput: true",
            "Input: s = \"0110\", n = 4\nOutput: false"
        ],
        "constraints": "1 <= s.length <= 1000\ns[i] is either '0' or '1'.\n1 <= n <= 109",
        "release_time": 1680016299,
        "oracle_code": "class Solution {\npublic:\n    bool queryString(string s, int n)\n     {\n        unordered_set<int> seen;\n        int len = s.length();\n        for(int i=len-1;i>=0;i--)\n        {\n            int num = 0;\n            for(int j=1;j<=min(len-i,31);j++)\n            { \n                num = num*2 + (s[i+j-1] == '1' ? 1 : 0);\n                if(0 < num && num <= n) seen.insert(num);\n            }\n            if(seen.size() == n) return true;\n        }\n        return false;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool queryString(string s, int n)\\n     {\\n        unordered_set<int> seen;\\n        int len = s.length();\\n        for(int i=len-1;i>=0;i--)\\n        {\\n            int num = 0;\\n            for(int j=1;j<=min(len-i,31);j++)\\n            { \\n                num = num*2 + (s[i+j-1] == \\'1\\' ? 1 : 0);\\n                if(0 < num && num <= n) seen.insert(num);\\n            }\\n            if(seen.size() == n) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\npublic:\n    bool queryString(string s, int n)\n     {\n        unordered_set<int> seen;\n        int len = s.length();\n        for(int i=len-1;i>=0;i--)\n        {\n            int num = 0;\n            for(int j=1;j<=min(len-i,31);j++)\n            { \n                num = num*2 + (s[i+j-1] == \"1\" ? 1 : 0);\n                if(0 < num && num <= n) seen.insert(num);\n            }\n            if(seen.size() == n) return true;\n        }\n        return false;\n    }\n};\n",
        "explanations": "\nThe bug is that we are comparing a character with a string \"1\", which will always return false.\n"
    },
    {
        "slug": "reverse-vowels-of-a-string",
        "description": "Given a string s, reverse only all the vowels in the string and return it.\nThe vowels are 'a', 'e', 'i', 'o', and 'u', and they can appear in both lower and upper cases, more than once.",
        "examples": [
            "Input: s = \"hello\"\nOutput: \"holle\"",
            "Input: s = \"leetcode\"\nOutput: \"leotcede\""
        ],
        "constraints": "1 <= s.length <= 3 * 105\ns consist of printable ASCII characters.",
        "release_time": 1667534256,
        "oracle_code": "class Solution {\npublic:\n    string reverseVowels(string s) {\n        \n        vector<char> v;\n        for(int i = 0 ; i < s.length(); i++)\n        {\n            if(s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u'\n              || s[i] == 'A' || s[i] == 'E' || s[i] == 'O' || s[i] == 'I' || s[i] == 'U')\n                v.push_back(s[i]);\n        }\n        reverse(v.begin(), v.end());\n        int rev = 0;\n        for(int i = 0 ; i < s.length(); i++)\n        {\n            if(s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u'\n              || s[i] == 'A' || s[i] == 'E' || s[i] == 'O' || s[i] == 'I' || s[i] == 'U'){\n                s[i] = v[rev];\n                rev++;\n            }\n        }\n        return s;\n    }\n};",
        "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        \\n        vector<char> v;\\n        for(int i = 0 ; i < s.length(); i++)\\n        {\\n            if(s[i] == \\'a\\' || s[i] == \\'e\\' || s[i] == \\'i\\' || s[i] == \\'o\\' || s[i] == \\'u\\'\\n              || s[i] == \\'A\\' || s[i] == \\'E\\' || s[i] == \\'O\\' || s[i] == \\'I\\' || s[i] == \\'U\\')\\n                v.push_back(s[i]);\\n        }\\n        reverse(v.begin(), v.end());\\n        int rev = 0;\\n        for(int i = 0 ; i < s.length(); i++)\\n        {\\n            if(s[i] == \\'a\\' || s[i] == \\'e\\' || s[i] == \\'i\\' || s[i] == \\'o\\' || s[i] == \\'u\\'\\n              || s[i] == \\'A\\' || s[i] == \\'E\\' || s[i] == \\'O\\' || s[i] == \\'I\\' || s[i] == \\'U\\'){\\n                s[i] = v[rev];\\n                rev++;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\npublic:\n    string reverseVowels(string s) {\n        \n        vector<char> v;\n        for(int i = 0 ; i < s.length(); i++)\n        {\n            if(s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u\n              || s[i] == 'A' || s[i] == 'E' || s[i] == 'O' || s[i] == 'I' || s[i] == 'U')\n                v.push_back(s[i]);\n        }\n        reverse(v.begin(), v.end());\n        int rev = 0;\n        for(int i = 0 ; i < s.length(); i++)\n        {\n            if(s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u\n              || s[i] == 'A' || s[i] == 'E' || s[i] == 'O' || s[i] == 'I' || s[i] == 'U'){\n                s[i] = v[rev];\n                rev++;\n            }\n        }\n        return s;\n    }\n};\n",
        "explanations": "\nThe strings 'u' in the if condition statement were not closed properly causing error.\n"
    },
    {
        "slug": "add-two-numbers",
        "description": "You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum\u00a0as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.",
        "examples": [
            "Input: l1 = [2,4,3], l2 = [5,6,4]\nOutput: [7,0,8]\nExplanation: 342 + 465 = 807.",
            "Input: l1 = [0], l2 = [0]\nOutput: [0]",
            "Input: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\nOutput: [8,9,9,9,0,0,0,1]"
        ],
        "constraints": "The number of nodes in each linked list is in the range [1, 100].\n0 <= Node.val <= 9\nIt is guaranteed that the list represents a number that does not have leading zeros.",
        "release_time": 1691909288,
        "oracle_code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        //initializing tem and temp so that l1 and l2 reamins preserved,\n        //though this isn't needed but it a good practice\n        ListNode* temp=l1;\n        ListNode* tem=l2;\n        ListNode *ans;\n        ListNode *head;\n        int carry=0;\n        int valu;\n        //initiallize the first node of answer\n        int sum=tem->val+temp->val+carry;\n        valu=sum%10;\n        carry=sum/10;\n        ListNode* node =new ListNode(valu);\n        ans=node;\n        head=ans;\n        tem=tem->next;\n        temp=temp->next;\n        while(tem!=NULL && temp!=NULL)\n        {\n            sum=tem->val+temp->val+carry;\n            valu=sum%10;\n            carry=sum/10;\n            ListNode* node =new ListNode(valu);\n            ans->next=node;\n            ans=ans->next;\n            temp=temp->next;\n            tem=tem->next;\n        }\n        //if l1 gets over and there are still some elements in l2\n        if(tem==NULL && temp!=NULL)\n        {\n            while(temp!=NULL)\n            {\n                sum=temp->val+carry;\n                valu=sum%10;\n                carry=sum/10;\n                ListNode* node =new ListNode(valu);\n                ans->next=node;\n                ans=ans->next;\n                temp=temp->next;\n            }\n        }\n        //if l2 gets over and there are still some elements in l1\n        if(tem!=NULL && temp==NULL)\n        {\n            while(tem!=NULL)\n            {\n                sum=tem->val+carry;\n                valu=sum%10;\n                carry=sum/10;\n                ListNode* node =new ListNode(valu);\n                ans->next=node;\n                ans=ans->next;\n                tem=tem->next;\n            }\n        }\n        //if there is still a carry left\n        if(carry!=0)\n        {\n            ListNode* node =new ListNode(carry);\n            ans->next=node;\n        }\n        return head;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe code might seem really complex for the first time, but this only because i have specified every corner case differently, cmon i will give u a walk through my code.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe are just using a variable for the value we want as node\\'s vale and a carry, rest the operation is as simple as we add two numbers.\\n\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        //initializing tem and temp so that l1 and l2 reamins preserved,\\n        //though this isn\\'t needed but it a good practice\\n        ListNode* temp=l1;\\n        ListNode* tem=l2;\\n        ListNode *ans;\\n        ListNode *head;\\n        int carry=0;\\n        int valu;\\n        //initiallize the first node of answer\\n        int sum=tem->val+temp->val+carry;\\n        valu=sum%10;\\n        carry=sum/10;\\n        ListNode* node =new ListNode(valu);\\n        ans=node;\\n        head=ans;\\n        tem=tem->next;\\n        temp=temp->next;\\n        while(tem!=NULL && temp!=NULL)\\n        {\\n            sum=tem->val+temp->val+carry;\\n            valu=sum%10;\\n            carry=sum/10;\\n            ListNode* node =new ListNode(valu);\\n            ans->next=node;\\n            ans=ans->next;\\n            temp=temp->next;\\n            tem=tem->next;\\n        }\\n        //if l1 gets over and there are still some elements in l2\\n        if(tem==NULL && temp!=NULL)\\n        {\\n            while(temp!=NULL)\\n            {\\n                sum=temp->val+carry;\\n                valu=sum%10;\\n                carry=sum/10;\\n                ListNode* node =new ListNode(valu);\\n                ans->next=node;\\n                ans=ans->next;\\n                temp=temp->next;\\n            }\\n        }\\n        //if l2 gets over and there are still some elements in l1\\n        if(tem!=NULL && temp==NULL)\\n        {\\n            while(tem!=NULL)\\n            {\\n                sum=tem->val+carry;\\n                valu=sum%10;\\n                carry=sum/10;\\n                ListNode* node =new ListNode(valu);\\n                ans->next=node;\\n                ans=ans->next;\\n                tem=tem->next;\\n            }\\n        }\\n        //if there is still a carry left\\n        if(carry!=0)\\n        {\\n            ListNode* node =new ListNode(carry);\\n            ans->next=node;\\n        }\\n        return head;\\n    }\\n};\\n\\n```",
        "level": "medium",
        "buggy_code": "\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        //initializing tem and temp so that l1 and l2 reamins preserved,\n        //though this isn't needed but it a good practice\n        ListNode* temp=l1;\n        ListNode* tem=l2;\n        ListNode *ans;\n        ListNode *head;\n        int carry=0;\n        int valu;\n        //initiallize the first node of answer\n        int sum=tem->val+temp->val+carry;\n        valu=sum%10;\n        carry=sum/10;\n        ListNode* node =new ListNode(\"valu);\n        ans=node;\n        head=ans;\n        tem=tem->next;\n        temp=temp->next;\n        while(tem!=NULL && temp!=NULL)\n        {\n            sum=tem->val+temp->val+carry;\n            valu=sum%10;\n            carry=sum/10;\n            ListNode* node =new ListNode(valu);\n            ans->next=node;\n            ans=ans->next;\n            temp=temp->next;\n            tem=tem->next;\n        }\n        //if l1 gets over and there are still some elements in l2\n        if(tem==NULL && temp!=NULL)\n        {\n            while(temp!=NULL)\n            {\n                sum=temp->val+carry;\n                valu=sum%10;\n                carry=sum/10;\n                ListNode* node =new ListNode(valu);\n                ans->next=node;\n                ans=ans->next;\n                temp=temp->next;\n            }\n        }\n        //if l2 gets over and there are still some elements in l1\n        if(tem!=NULL && temp==NULL)\n        {\n            while(tem!=NULL)\n            {\n                sum=tem->val+carry;\n                valu=sum%10;\n                carry=sum/10;\n                ListNode* node =new ListNode(valu);\n                ans->next=node;\n                ans=ans->next;\n                tem=tem->next;\n            }\n        }\n        //if there is still a carry left\n        if(carry!=0)\n        {\n            ListNode* node =new ListNode(carry);\n            ans->next=node;\n        }\n        return head;\n    }\n};\n",
        "explanations": "\nThe unclosed string \"valu\" causes an error while creating a new ListNode.\n"
    },
    {
        "slug": "buddy-strings",
        "description": "Given two strings s and goal, return true if you can swap two letters in s so the result is equal to goal, otherwise, return false.\nSwapping letters is defined as taking two indices i and j (0-indexed) such that i != j and swapping the characters at s[i] and s[j].\n\nFor example, swapping at indices 0 and 2 in \"abcd\" results in \"cbad\".",
        "examples": [
            "Input: s = \"ab\", goal = \"ba\"\nOutput: true\nExplanation: You can swap s[0] = 'a' and s[1] = 'b' to get \"ba\", which is equal to goal.",
            "Input: s = \"ab\", goal = \"ab\"\nOutput: false\nExplanation: The only letters you can swap are s[0] = 'a' and s[1] = 'b', which results in \"ba\" != goal.",
            "Input: s = \"aa\", goal = \"aa\"\nOutput: true\nExplanation: You can swap s[0] = 'a' and s[1] = 'a' to get \"aa\", which is equal to goal."
        ],
        "constraints": "1 <= s.length, goal.length <= 2 * 104\ns and goal consist of lowercase letters.",
        "release_time": 1688356386,
        "oracle_code": "class Solution {\npublic:\n    bool buddyStrings(string s, string p) {\n        int n=s.length(), m=p.length();\n        if(n!=m) return false;\n        \n        vector<int> freq(26,0);\n        \n        int first=-1, second=-1;\n        for(int i=0;i<n;i++){\n            if(s[i] != p[i]){\n                if(first==-1){\n                    first=i;\n                }else if(second==-1){\n                    second=i;\n                }else{\n                    return false; // more than 2 mismatching characters\n                }\n            }\n            freq[s[i]-'a']++;\n        }\n        \n\t\t// similar strings\n        if(first == -1 && second == -1){\n            for(int i=0;i<26;i++) if(freq[i] > 1) return true; // can swap similar characters\n            return false; // all characters occur only once\n        }else if(second == -1){\n            return false; // exactly 1 mismatch\n        }\n        \n        return (s[first]==p[second] && s[second]==p[first]); // check similarity on 2 mismatched indexes\n    }\n};",
        "content": "**Connect with me on LinkedIn**: https://www.linkedin.com/in/abhay5349singh/\\n\\n```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string p) {\\n        int n=s.length(), m=p.length();\\n        if(n!=m) return false;\\n        \\n        vector<int> freq(26,0);\\n        \\n        int first=-1, second=-1;\\n        for(int i=0;i<n;i++){\\n            if(s[i] != p[i]){\\n                if(first==-1){\\n                    first=i;\\n                }else if(second==-1){\\n                    second=i;\\n                }else{\\n                    return false; // more than 2 mismatching characters\\n                }\\n            }\\n            freq[s[i]-\\'a\\']++;\\n        }\\n        \\n\\t\\t// similar strings\\n        if(first == -1 && second == -1){\\n            for(int i=0;i<26;i++) if(freq[i] > 1) return true; // can swap similar characters\\n            return false; // all characters occur only once\\n        }else if(second == -1){\\n            return false; // exactly 1 mismatch\\n        }\\n        \\n        return (s[first]==p[second] && s[second]==p[first]); // check similarity on 2 mismatched indexes\\n    }\\n};\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\npublic:\n    bool buddyStrings(string s, string p) {\n        int n=s.length(), m=p.length();\n        if(n!=m) return false;\n        \n        vector<int> freq(26,0);\n        \n        int first=-1, second=-1;\n        for(int i=0;i<n;i++){\n            if(s[i] != p[i]){\n                if(first==-1){\n                    first=i;\n                }else if(second==-1){\n                    second=i;\n                }else{\n                    return false; // more than 2 mismatching characters\n                }\n            }\n            freq[s[i]-'a']++;\n        }\n        \n\t\t// similar strings\n        if(first == -1 && second == -1){\n            for(int i=0;i<26;i++) if(freq[i] > 1) return true; // can swap similar characters\n            return \"false\"; \n        }else if(second == -1){\n            return false; // exactly 1 mismatch\n        }\n        \n        return (s[first]==p[second] && s[second]==p[first]); // check similarity on 2 mismatched indexes\n    }\n};\n",
        "explanations": "\n\"false\" is an unclosed string instead of a boolean false return value.\n"
    },
    {
        "slug": "minimum-number-of-swaps-to-make-the-string-balanced",
        "description": "You are given a 0-indexed string s of even length n. The string consists of exactly n / 2 opening brackets '[' and n / 2 closing brackets ']'.\nA string is called balanced if and only if:\n\nIt is the empty string, or\nIt can be written as AB, where both A and B are balanced strings, or\nIt can be written as [C], where C is a balanced string.\n\nYou may swap the brackets at any two indices any number of times.\nReturn the minimum number of swaps to make s balanced.",
        "examples": [
            "Input: s = \"][][\"\nOutput: 1\nExplanation: You can make the string balanced by swapping index 0 with index 3.\nThe resulting string is \"[[]]\".",
            "Input: s = \"]]][[[\"\nOutput: 2\nExplanation: You can do the following to make the string balanced:\n- Swap index 0 with index 4. s = \"[]][][\".\n- Swap index 1 with index 5. s = \"[[][]]\".\nThe resulting string is \"[[][]]\".",
            "Input: s = \"[]\"\nOutput: 0\nExplanation: The string is already balanced."
        ],
        "constraints": "n == s.length\n2 <= n <= 106\nn is even.\ns[i] is either '[' or ']'.\nThe number of opening brackets '[' equals n / 2, and the number of closing brackets ']' equals n / 2.",
        "release_time": 1686170411,
        "oracle_code": "class Solution {\npublic:\n    int minSwaps(string s) {\n        int size=0;\n        for(char &ch:s){\n          if(ch=='[')  size++;\n          else if(size) size--;\n        }\n        return (size+1)/2;\n    }\n};",
        "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSwaps(string s) {\\n        int size=0;\\n        for(char &ch:s){\\n          if(ch==\\'[\\')  size++;\\n          else if(size) size--;\\n        }\\n        return (size+1)/2;\\n    }\\n};\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\npublic:\n    int minSwaps(string s) {\n        int size=0;\n        for(char &ch:s){\n          if(ch=='[')  size++;\n          else if(size) size--;\n        }\n        return (size+1)/\"bug_string;\n    }\n};\n",
        "explanations": "\nThere is an unclosed string \"bug_string\" at the end of the return statement.\n"
    },
    {
        "slug": "largest-substring-between-two-equal-characters",
        "description": "Given a string s, return the length of the longest substring between two equal characters, excluding the two characters. If there is no such substring return -1.\nA substring is a contiguous sequence of characters within a string.",
        "examples": [
            "Input: s = \"aa\"\nOutput: 0\nExplanation: The optimal substring here is an empty substring between the two 'a's.",
            "Input: s = \"abca\"\nOutput: 2\nExplanation: The optimal substring here is \"bc\".",
            "Input: s = \"cbzxy\"\nOutput: -1\nExplanation: There are no characters that appear twice in s."
        ],
        "constraints": "1 <= s.length <= 300\ns contains only lowercase English letters.",
        "release_time": 1673405367,
        "oracle_code": "class Solution {\npublic:\n    int maxLengthBetweenEqualCharacters(string s) {\n        int v[26];\n        memset(v,-1,sizeof v);\n        int ans=-1;\n        for(int i=0;i<s.size();i++){\n            if(v[s[i]-'a']==-1){\n                v[s[i]-'a']=i;\n            }\n            int res=i-v[s[i]-'a']-1;\n            ans=max(ans,res);\n        }\n        return ans;\n    }\n};",
        "content": "# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxLengthBetweenEqualCharacters(string s) {\\n        int v[26];\\n        memset(v,-1,sizeof v);\\n        int ans=-1;\\n        for(int i=0;i<s.size();i++){\\n            if(v[s[i]-\\'a\\']==-1){\\n                v[s[i]-\\'a\\']=i;\\n            }\\n            int res=i-v[s[i]-\\'a\\']-1;\\n            ans=max(ans,res);\\n        }\\n        return ans;\\n    }\\n};\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\npublic:\n    int maxLengthBetweenEqualCharacters(string s) {\n        int v[26];\n        memset(v,-1,sizeof v);\n        int ans=-1;\n        for(int i=0;i<s.size();i++){\n            if(v[s[i]-'a']==-1){\n                v[s[i]-'a' \"=i;\n            }\n            int res=i-v[s[i]-'a']-1;\n            ans=max(ans,res);\n        }\n        return ans;\n    }\n};\n",
        "explanations": "\nThe code has an unclosed string, \"=\" is not closed properly, causing a compilation error.\n"
    },
    {
        "slug": "remove-outermost-parentheses",
        "description": "A valid parentheses string is either empty \"\", \"(\" + A + \")\", or A + B, where A and B are valid parentheses strings, and + represents string concatenation.\n\nFor example, \"\", \"()\", \"(())()\", and \"(()(()))\" are all valid parentheses strings.\n\nA valid parentheses string s is primitive if it is nonempty, and there does not exist a way to split it into s = A + B, with A and B nonempty valid parentheses strings.\nGiven a valid parentheses string s, consider its primitive decomposition: s = P1 + P2 + ... + Pk, where Pi are primitive valid parentheses strings.\nReturn s after removing the outermost parentheses of every primitive string in the primitive decomposition of s.",
        "examples": [
            "Input: s = \"(()())(())\"\nOutput: \"()()()\"\nExplanation: \nThe input string is \"(()())(())\", with primitive decomposition \"(()())\" + \"(())\".\nAfter removing outer parentheses of each part, this is \"()()\" + \"()\" = \"()()()\".",
            "Input: s = \"(()())(())(()(()))\"\nOutput: \"()()()()(())\"\nExplanation: \nThe input string is \"(()())(())(()(()))\", with primitive decomposition \"(()())\" + \"(())\" + \"(()(()))\".\nAfter removing outer parentheses of each part, this is \"()()\" + \"()\" + \"()(())\" = \"()()()()(())\".",
            "Input: s = \"()()\"\nOutput: \"\"\nExplanation: \nThe input string is \"()()\", with primitive decomposition \"()\" + \"()\".\nAfter removing outer parentheses of each part, this is \"\" + \"\" = \"\"."
        ],
        "constraints": "1 <= s.length <= 105\ns[i] is either '(' or ')'.\ns is a valid parentheses string.",
        "release_time": 1687925926,
        "oracle_code": "class Solution {\npublic:\n    string removeOuterParentheses(string s) {\n        stack<char> st;\n        string res=\"\";\n        for(int i=0;i<s.size();i++){\n            if(s[i]=='(' && st.empty()){\n                st.push(s[i]);\n            }\n            else if(s[i]=='('){\n                st.push(s[i]);\n                res+=s[i];\n            }\n            else{\n                st.pop();\n                if(st.size()){\n                    res+=s[i];\n                }\n            }\n        }\n        return res;\n    }\n};",
        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        stack<char> st;\\n        string res=\"\";\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'(\\' && st.empty()){\\n                st.push(s[i]);\\n            }\\n            else if(s[i]==\\'(\\'){\\n                st.push(s[i]);\\n                res+=s[i];\\n            }\\n            else{\\n                st.pop();\\n                if(st.size()){\\n                    res+=s[i];\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\npublic:\n    string removeOuterParentheses(string s) {\n        stack<char> st;\n        string res=\";\n        for(int i=0;i<s.size();i++){\n            if(s[i]=='(' && st.empty()){\n                st.push(s[i]);\n            }\n            else if(s[i]=='('){\n                st.push(s[i]);\n                res+=s[i];\n            }\n            else{\n                st.pop();\n                if(st.size()){\n                    res+=s[i];\n                }\n            }\n        }\n        return res;\n    }\n};\n",
        "explanations": "\nI started a string but did not close it. This unclosed string creates a syntax error.\n"
    },
    {
        "slug": "add-binary",
        "description": "Given two binary strings a and b, return their sum as a binary string.",
        "examples": [
            "Input: a = \"11\", b = \"1\"\nOutput: \"100\"",
            "Input: a = \"1010\", b = \"1011\"\nOutput: \"10101\""
        ],
        "constraints": "1 <= a.length, b.length <= 104\na and b consist\u00a0only of '0' or '1' characters.\nEach string does not contain leading zeros except for the zero itself.",
        "release_time": 1676392785,
        "oracle_code": "class Solution {\npublic:\n    string addBinary(string a, string b) {\n        int c=0;\n        string s=\"\";\n        int i=0;\n        while(i<a.length() || i<b.length() || c!=0){\n            int x=0;\n            if(i<a.length() && a[a.length()-i-1]=='1')\n                x=1;\n            int y=0;\n            if(i<b.length() && b[b.length()-1-i]=='1')\n                y=1;\n            s=to_string((x+y+c)%2)+s;\n            c=(x+y+c)/2;\n            i++;\n        }\n        return s;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        int c=0;\\n        string s=\"\";\\n        int i=0;\\n        while(i<a.length() || i<b.length() || c!=0){\\n            int x=0;\\n            if(i<a.length() && a[a.length()-i-1]==\\'1\\')\\n                x=1;\\n            int y=0;\\n            if(i<b.length() && b[b.length()-1-i]==\\'1\\')\\n                y=1;\\n            s=to_string((x+y+c)%2)+s;\\n            c=(x+y+c)/2;\\n            i++;\\n        }\\n        return s;\\n    }\\n};\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\npublic:\n    string addBinary(string a, string b) {\n        int c=0;\n        string s=\"\";\n        int i=0;\n        while(i<a.length() || i<b.length() || c!=0){\n            int x=0;\n            if(i<a.length() && a[a.length()-i-1]=='1')\n                x=1;\n            int y=0;\n            if(i<b.length() && b[b.length()-1-i]=='1')\n                y=1;\n            s=to_string((x+y+c)%2)+s;\n            c=(x+y+c)/2;\n            i++;\n        }\n        return \"This is supposed to be a string;\n    }\n};\n",
        "explanations": "\nAn unclosed string is attempted to be returned at the end causing a compilation error.\n"
    },
    {
        "slug": "find-first-palindromic-string-in-the-array",
        "description": "Given an array of strings words, return the first palindromic string in the array. If there is no such string, return an empty string \"\".\nA string is palindromic if it reads the same forward and backward.",
        "examples": [
            "Input: words = [\"abc\",\"car\",\"ada\",\"racecar\",\"cool\"]\nOutput: \"ada\"\nExplanation: The first string that is palindromic is \"ada\".\nNote that \"racecar\" is also palindromic, but it is not the first.",
            "Input: words = [\"notapalindrome\",\"racecar\"]\nOutput: \"racecar\"\nExplanation: The first and only string that is palindromic is \"racecar\".",
            "Input: words = [\"def\",\"ghi\"]\nOutput: \"\"\nExplanation: There are no palindromic strings, so the empty string is returned."
        ],
        "constraints": "1 <= words.length <= 100\n1 <= words[i].length <= 100\nwords[i] consists only of lowercase English letters.",
        "release_time": 1678731739,
        "oracle_code": "class Solution {\npublic:\n    //check for palindrome, return true if it.\n    bool check(string &word)\n    {\n        int l = 0;\n        int r = word.size()-1;\n\n        while(l<r)\n        {\n            if(word[l] != word[r])\n            {\n                return false;\n            }\n            l++;\n             r--;\n        }\n        return true;\n\n    }\n    string firstPalindrome(vector<string>& words) {\n        for(int i=0;i<words.size();i++)\n        {\n            if(check(words[i]))\n            return words[i];\n        }\n\n        return \"\";\n        \n    }\n};",
        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    //check for palindrome, return true if it.\\n    bool check(string &word)\\n    {\\n        int l = 0;\\n        int r = word.size()-1;\\n\\n        while(l<r)\\n        {\\n            if(word[l] != word[r])\\n            {\\n                return false;\\n            }\\n            l++;\\n             r--;\\n        }\\n        return true;\\n\\n    }\\n    string firstPalindrome(vector<string>& words) {\\n        for(int i=0;i<words.size();i++)\\n        {\\n            if(check(words[i]))\\n            return words[i];\\n        }\\n\\n        return \"\";\\n        \\n    }\\n};\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\npublic:\n    //check for palindrome, return true if it.\n    bool check(string &word)\n    {\n        int l = 0;\n        int r = word.size()-1;\n\n        while(l<r)\n        {\n            if(word[l] != word[r])\n            {\n                return false;\n            }\n            l++;\n            r--;\n        }\n        return \"true; \n\n    }\n    string firstPalindrome(vector<string>& words) {\n        for(int i=0;i<words.size();i++)\n        {\n            if(check(words[i]))\n            return words[i];\n        }\n\n        return \"\";\n        \n    }\n};\n",
        "explanations": "\nThe return statement inside the check() function isn't closed properly after \"true\".\n"
    },
    {
        "slug": "magical-string",
        "description": "A magical string s consists of only '1' and '2' and obeys the following rules:\n\nThe string s is magical because concatenating the number of contiguous occurrences of characters '1' and '2' generates the string s itself.\n\nThe first few elements of s is s = \"1221121221221121122\u2026\u2026\". If we group the consecutive 1's and 2's in s, it will be \"1 22 11 2 1 22 1 22 11 2 11 22 ......\" and the occurrences of 1's or 2's in each group are \"1 2 2 1 1 2 1 2 2 1 2 2 ......\". You can see that the occurrence sequence is s itself.\nGiven an integer n, return the number of 1's in the first n number in the magical string s.",
        "examples": [
            "Input: n = 6\nOutput: 3\nExplanation: The first 6 elements of magical string s is \"122112\" and it contains three 1's, so return 3.",
            "Input: n = 1\nOutput: 1"
        ],
        "constraints": "1 <= n <= 105",
        "release_time": 1673536160,
        "oracle_code": "class Solution {\npublic:\n    int magicalString(int n) {\n        string s=\"\";\n        s+=\"122\";\n        int i=2,c=1;\n        while(i<n && s.size()<n)\n        {\n            if(s[i]=='1')\n            {\n                c++;\n                if(s[s.size()-1]=='2')\n                s+='1';\n                else\n                {\n                    s+='2';\n                }\n            }\n            else\n            {\n                if(s[s.size()-1]=='2')\n                s+=\"11\";\n                else\n                {\n                    s+=\"22\";\n                }\n            }\n            i++;\n        }\n        while(i<n)\n        {\n            if(s[i]=='1')\n            c++;\n            i++;\n        }\n        return c;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIntution was to find the repeating part first, then i saw the pattern carefully and tried to make it.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can make the string using first three digits only \"122\",my intution is to make whole string upto length n,and count ones side by side. Also to count the remaining 1\\'s after while loop breaks\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int magicalString(int n) {\\n        string s=\"\";\\n        s+=\"122\";\\n        int i=2,c=1;\\n        while(i<n && s.size()<n)\\n        {\\n            if(s[i]==\\'1\\')\\n            {\\n                c++;\\n                if(s[s.size()-1]==\\'2\\')\\n                s+=\\'1\\';\\n                else\\n                {\\n                    s+=\\'2\\';\\n                }\\n            }\\n            else\\n            {\\n                if(s[s.size()-1]==\\'2\\')\\n                s+=\"11\";\\n                else\\n                {\\n                    s+=\"22\";\\n                }\\n            }\\n            i++;\\n        }\\n        while(i<n)\\n        {\\n            if(s[i]==\\'1\\')\\n            c++;\\n            i++;\\n        }\\n        return c;\\n    }\\n};\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\npublic:\n    int magicalString(int n) {\n        string s=\"\";\n        s+=\"122\";\n        int i=2,c=1;\n        while(i<n && s.size()<n)\n        {\n            if(s[i]=='1')\n            {\n                c++;\n                if(s[s.size()-1]=='2')\n                s+='1';\n                else\n                {\n                    s+='2';\n                }\n            }\n            else\n            {\n                if(s[s.size()-1]=='2')\n                s+=\"11\";\n                else\n                {\n                    s+='22'; \n                }\n            }\n            i++;\n        }\n        while(i<n)\n        {\n            if(s[i]=='1')\n            c++;\n            i++;\n        }\n        return c;\n    }\n};\n",
        "explanations": "\nThe bug is an unclosed string, s+='22'; instead of s+=\"22\";, causing a compilation error.\n"
    },
    {
        "slug": "evaluate-reverse-polish-notation",
        "description": "You are given an array of strings tokens that represents an arithmetic expression in a Reverse Polish Notation.\nEvaluate the expression. Return an integer that represents the value of the expression.\nNote that:\n\nThe valid operators are '+', '-', '*', and '/'.\nEach operand may be an integer or another expression.\nThe division between two integers always truncates toward zero.\nThere will not be any division by zero.\nThe input represents a valid arithmetic expression in a reverse polish notation.\nThe answer and all the intermediate calculations can be represented in a 32-bit integer.",
        "examples": [
            "Input: tokens = [\"2\",\"1\",\"+\",\"3\",\"*\"]\nOutput: 9\nExplanation: ((2 + 1) * 3) = 9",
            "Input: tokens = [\"4\",\"13\",\"5\",\"/\",\"+\"]\nOutput: 6\nExplanation: (4 + (13 / 5)) = 6",
            "Input: tokens = [\"10\",\"6\",\"9\",\"3\",\"+\",\"-11\",\"*\",\"/\",\"*\",\"17\",\"+\",\"5\",\"+\"]\nOutput: 22\nExplanation: ((10 * (6 / ((9 + 3) * -11))) + 17) + 5\n= ((10 * (6 / (12 * -11))) + 17) + 5\n= ((10 * (6 / -132)) + 17) + 5\n= ((10 * 0) + 17) + 5\n= (0 + 17) + 5\n= 17 + 5\n= 22"
        ],
        "constraints": "1 <= tokens.length <= 104\ntokens[i] is either an operator: \"+\", \"-\", \"*\", or \"/\", or an integer in the range [-200, 200].",
        "release_time": 1688227672,
        "oracle_code": "class Solution {\npublic:\n    int performOperation(string operation, int firstNumber, int secondNumber) {\n        if(operation == \"+\")\n            return secondNumber + firstNumber; \n        if(operation == \"-\")    \n            return secondNumber - firstNumber; \n        if(operation == \"*\")\n            return secondNumber * firstNumber; \n        return secondNumber / firstNumber; \n    }\n    int evalRPN(vector<string>& tokens) {\n        stack<int> tokenStack;\n        set<string> operators = {\"+\", \"-\", \"*\", \"/\"};\n\n        for(int i = 0; i < tokens.size(); i++)\n        {\n            // if the token is an operator \n            if(operators.find(tokens[i]) != operators.end())\n            {\n                // pop the 2 numbers in the stack \n                int firstNumber = tokenStack.top();\n                tokenStack.pop();\n                int secondNumber = tokenStack.top(); \n                tokenStack.pop();\n\n                // do the operation on the two numbers\n                int operationResult = performOperation(tokens[i], firstNumber, secondNumber); \n\n                // push the result of the operation in the stack \n                tokenStack.push(operationResult); \n            }\n            else\n            {\n                // if the token is a number, push it to the stack\n                tokenStack.push(stoi(tokens[i])); \n            }\n        }\n        return tokenStack.top();\n    }\n};",
        "content": "# Approach\\nWe traverse the tokens one by one\\n - If the token is a number, we push the number to to the stack. \\n - If the token is an operator, we get the two latest pushed numbers, do the operation on them then push the result to the stack. \\n\\nAt the end of the process, the result will be the last number in the stack.\\n\\n# Visualization of the problem\\n![IMG_0020.jpg](https://assets.leetcode.com/users/images/cb6078c3-36fe-4ddf-aa96-9ec3989469d5_1688227585.5480292.jpeg)\\n\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int performOperation(string operation, int firstNumber, int secondNumber) {\\n        if(operation == \"+\")\\n            return secondNumber + firstNumber; \\n        if(operation == \"-\")    \\n            return secondNumber - firstNumber; \\n        if(operation == \"*\")\\n            return secondNumber * firstNumber; \\n        return secondNumber / firstNumber; \\n    }\\n    int evalRPN(vector<string>& tokens) {\\n        stack<int> tokenStack;\\n        set<string> operators = {\"+\", \"-\", \"*\", \"/\"};\\n\\n        for(int i = 0; i < tokens.size(); i++)\\n        {\\n            // if the token is an operator \\n            if(operators.find(tokens[i]) != operators.end())\\n            {\\n                // pop the 2 numbers in the stack \\n                int firstNumber = tokenStack.top();\\n                tokenStack.pop();\\n                int secondNumber = tokenStack.top(); \\n                tokenStack.pop();\\n\\n                // do the operation on the two numbers\\n                int operationResult = performOperation(tokens[i], firstNumber, secondNumber); \\n\\n                // push the result of the operation in the stack \\n                tokenStack.push(operationResult); \\n            }\\n            else\\n            {\\n                // if the token is a number, push it to the stack\\n                tokenStack.push(stoi(tokens[i])); \\n            }\\n        }\\n        return tokenStack.top();\\n    }\\n};\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\npublic:\n    int performOperation(string operation, int firstNumber, int secondNumber) {\n        if(operation == \"+\")\n            return secondNumber + firstNumber; \n        if(operation == \"-\")    \n            return secondNumber - firstNumber; \n        if(operation == \"*\")\n            return secondNumber * firstNumber; \n        return secondNumber / firstNumber; \n    }\n    int evalRPN(vector<string>& tokens) {\n        stack<int> tokenStack;\n        set<string> operators = {\"+\", \"-\", \"*\", \"/;\n\n        for(int i = 0; i < tokens.size(); i++)\n        {\n            // if the token is an operator \n            if(operators.find(tokens[i]) != operators.end())\n            {\n                // pop the 2 numbers in the stack \n                int firstNumber = tokenStack.top();\n                tokenStack.pop();\n                int secondNumber = tokenStack.top(); \n                tokenStack.pop();\n\n                // do the operation on the two numbers\n                int operationResult = performOperation(tokens[i], firstNumber, secondNumber); \n\n                // push the result of the operation in the stack \n                tokenStack.push(operationResult); \n            }\n            else\n            {\n                // if the token is a number, push it to the stack\n                tokenStack.push(stoi(tokens[i])); \n            }\n        }\n        return tokenStack.top();\n    }\n};\n",
        "explanations": "\nAn unclosed string on the set operators causes a syntax error preventing code compile.\n"
    },
    {
        "slug": "count-stepping-numbers-in-range",
        "description": "Given two positive integers low and high represented as strings, find the count of stepping numbers in the inclusive range [low, high].\nA stepping number is an integer such that all of its adjacent digits have an absolute difference of exactly 1.\nReturn an integer denoting the count of stepping numbers in the inclusive range [low, high]. \nSince the answer may be very large, return it modulo 109 + 7.\nNote: A stepping number should not have a leading zero.",
        "examples": [
            "Input: low = \"1\", high = \"11\"\nOutput: 10\nExplanation: The stepping numbers in the range [1,11] are 1, 2, 3, 4, 5, 6, 7, 8, 9 and 10. There are a total of 10 stepping numbers in the range. Hence, the output is 10.",
            "Input: low = \"90\", high = \"101\"\nOutput: 2\nExplanation: The stepping numbers in the range [90,101] are 98 and 101. There are a total of 2 stepping numbers in the range. Hence, the output is 2."
        ],
        "constraints": "1 <= int(low) <= int(high) < 10100\n1 <= low.length, high.length <= 100\nlow and high consist of only digits.\nlow and high don't have any leading zeros.",
        "release_time": 1692204094,
        "oracle_code": "class Solution {\npublic:\n    #define mod 1000000007\n    long long dp[102][10][2][2];\n    long long f(string &r,int n,int pre,int leadingZero,int tight){\n        if(n==0) return 1;\n        \n        if(dp[n][pre][leadingZero][tight]!=-1) return dp[n][pre][leadingZero][tight];\n        long long up = tight ? (r[r.size()-n]-'0'):9,ans=0;\n        \n        if(leadingZero){\n            for(int i=0;i<=up;i++){\n                ans = (ans + f(r,n-1,i,(i==0),tight&(i==up)))%mod; \n            }\n        } else {\n            if(pre-1>=0 && pre-1<=up) ans = (ans + f(r,n-1,pre-1,0,tight&(pre-1==up)))%mod;\n            if(pre+1<=up) ans = (ans + f(r,n-1,pre+1,0,tight&(pre+1==up)))%mod;\n        }\n        \n        \n        return dp[n][pre][leadingZero][tight]=ans;\n    }\n    int countSteppingNumbers(string low, string high) {\n        int n=high.size();\n        memset(dp,-1,sizeof(dp));\n        long long r= f(high,high.size(),0,1,1);\n        memset(dp,-1,sizeof(dp));\n        for(int i=low.size()-1;i>=0;i--){\n            if((low[i]-'0')>0){\n                low[i]--;break;\n            } else {\n                low[i]='9';\n            }\n        }\n        \n        // cout<<low<<endl;\n        long long l= f(low,low.size(),0,1,1);\n        cout<<l<<\" \"<<r<<endl;\n        return (r-l+mod)%mod;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    #define mod 1000000007\\n    long long dp[102][10][2][2];\\n    long long f(string &r,int n,int pre,int leadingZero,int tight){\\n        if(n==0) return 1;\\n        \\n        if(dp[n][pre][leadingZero][tight]!=-1) return dp[n][pre][leadingZero][tight];\\n        long long up = tight ? (r[r.size()-n]-\\'0\\'):9,ans=0;\\n        \\n        if(leadingZero){\\n            for(int i=0;i<=up;i++){\\n                ans = (ans + f(r,n-1,i,(i==0),tight&(i==up)))%mod; \\n            }\\n        } else {\\n            if(pre-1>=0 && pre-1<=up) ans = (ans + f(r,n-1,pre-1,0,tight&(pre-1==up)))%mod;\\n            if(pre+1<=up) ans = (ans + f(r,n-1,pre+1,0,tight&(pre+1==up)))%mod;\\n        }\\n        \\n        \\n        return dp[n][pre][leadingZero][tight]=ans;\\n    }\\n    int countSteppingNumbers(string low, string high) {\\n        int n=high.size();\\n        memset(dp,-1,sizeof(dp));\\n        long long r= f(high,high.size(),0,1,1);\\n        memset(dp,-1,sizeof(dp));\\n        for(int i=low.size()-1;i>=0;i--){\\n            if((low[i]-\\'0\\')>0){\\n                low[i]--;break;\\n            } else {\\n                low[i]=\\'9\\';\\n            }\\n        }\\n        \\n        // cout<<low<<endl;\\n        long long l= f(low,low.size(),0,1,1);\\n        cout<<l<<\" \"<<r<<endl;\\n        return (r-l+mod)%mod;\\n    }\\n};\\n```",
        "level": "hard",
        "buggy_code": "\nclass Solution {\npublic:\n    #define mod 1000000007\n    long long dp[102][10][2][2];\n    long long f(string &r,int n,int pre,int leadingZero,int tight){\n        if(n==0) return 1;\n        \n        if(dp[n][pre][leadingZero][tight]!=-1) return dp[n][pre][leadingZero][tight];\n        long long up = tight ? (r[r.size()-n]-'0'):9,ans=0;\n        \n        if(leadingZero){\n            for(int i=0;i<=up;i++){\n                ans = (ans + f(r,n-1,i,(i==0),tight&(i==up)))%mod; \n            }\n        } else {\n            if(pre-1>=0 && pre-1<=up) ans = (ans + f(r,n-1,pre-1,0,tight&(pre-1==up)))%mod;\n            if(pre+1<=up) ans = (ans + f(r,n-1,pre+1,0,tight&(pre+1==up)))%mod;\n        }\n        \n        \n        return dp[n][pre][leadingZero][tight]=ans;\n    }\n    int countSteppingNumbers(string low, string high) {\n        int n=high.size();\n        memset(dp,-1,sizeof(dp));\n        long long r= f(high,high.size(),0,1,1);\n        memset(dp,-1,sizeof(dp));\n        for(int i=low.size()-1;i>=0;i--){\n            if((low[i]-'0')>0){\n                low[i]--;break;\n            } else {\n                low[i]='9';\n            }\n        }\n        \n        // cout<<low<<endl;\n        long long l= f(low,low.size(),0,1,1);\n        cout<<l<<\" \"<<r \n        \n        return (r-l+mod)%mod;\n    }\n};\n",
        "explanations": "\nThe bug in this code is that the string is not properly closed.\n"
    },
    {
        "slug": "string-to-integer-atoi",
        "description": "Implement the myAtoi(string s) function, which converts a string to a 32-bit signed integer (similar to C/C++'s atoi function).\nThe algorithm for myAtoi(string s) is as follows:\n\nRead in and ignore any leading whitespace.\nCheck if the next character (if not already at the end of the string) is '-' or '+'. Read this character in if it is either. This determines if the final result is negative or positive respectively. Assume the result is positive if neither is present.\nRead in next the characters until the next non-digit character or the end of the input is reached. The rest of the string is ignored.\nConvert these digits into an integer (i.e. \"123\" -> 123, \"0032\" -> 32). If no digits were read, then the integer is 0. Change the sign as necessary (from step 2).\nIf the integer is out of the 32-bit signed integer range [-231, 231 - 1], then clamp the integer so that it remains in the range. Specifically, integers less than -231 should be clamped to -231, and integers greater than 231 - 1 should be clamped to 231 - 1.\nReturn the integer as the final result.\n\nNote:\n\nOnly the space character ' ' is considered a whitespace character.\nDo not ignore any characters other than the leading whitespace or the rest of the string after the digits.",
        "examples": [
            "Input: s = \"42\"\nOutput: 42\nExplanation: The underlined characters are what is read in, the caret is the current reader position.\nStep 1: \"42\" (no characters read because there is no leading whitespace)\n         ^\nStep 2: \"42\" (no characters read because there is neither a '-' nor '+')\n         ^\nStep 3: \"42\" (\"42\" is read in)\n           ^\nThe parsed integer is 42.\nSince 42 is in the range [-231, 231 - 1], the final result is 42.",
            "Input: s = \"   -42\"\nOutput: -42\nExplanation:\nStep 1: \"   -42\" (leading whitespace is read and ignored)\n            ^\nStep 2: \"   -42\" ('-' is read, so the result should be negative)\n             ^\nStep 3: \"   -42\" (\"42\" is read in)\n               ^\nThe parsed integer is -42.\nSince -42 is in the range [-231, 231 - 1], the final result is -42.",
            "Input: s = \"4193 with words\"\nOutput: 4193\nExplanation:\nStep 1: \"4193 with words\" (no characters read because there is no leading whitespace)\n         ^\nStep 2: \"4193 with words\" (no characters read because there is neither a '-' nor '+')\n         ^\nStep 3: \"4193 with words\" (\"4193\" is read in; reading stops because the next character is a non-digit)\n             ^\nThe parsed integer is 4193.\nSince 4193 is in the range [-231, 231 - 1], the final result is 4193."
        ],
        "constraints": "0 <= s.length <= 200\ns consists of English letters (lower-case and upper-case), digits (0-9), ' ', '+', '-', and '.'.",
        "release_time": 1689150590,
        "oracle_code": "class Solution {\npublic:\n    int myAtoi(string s) {\n        long long res = 0; // stores our integer value\n        bool neg = 0; // checks whether integer will be -ve or +ve\n        bool leading = true; // true if theres leading spaces \n        \n        int n = s.size();\n\n        for (int i = 0; i<n; i++) {\n            if (s[i] == ' ') { // checks for leading spaces\n                if (leading) continue;\n                else break;\n            }\n            else if (s[i] == '-') { // checks -ve \n                if (i+1 < n && isdigit(s[i+1])) neg = 1;\n                else break; // break if next char is non-digit\n            }\n            else if (s[i] == '+') { // checks for +ve\n                if (i+1 < n && isdigit(s[i+1])) neg = 0;\n                else break; // break if next char is non-digit\n            }\n            else if (!isdigit(s[i])) break; // break on encoutring non-digit\n            else { // storing our integer value to res\n                if (res < 1e11) {\n                    res = res*10 + (s[i]-'0');\n                    if (i+1 < n && !isdigit(s[i+1])) \n                        break;// break if next char is non-digit\n                }\n                else break;\n                leading = false; // tells that integer has been encoutered\n            }\n        }\n\n        if (res > INT_MAX && neg) return INT_MIN;\n        if (res > INT_MAX) return INT_MAX;\n\n        return neg ? -1*res : res;\n    }\n};",
        "content": "```\\nclass Solution {\\npublic:\\n    int myAtoi(string s) {\\n        long long res = 0; // stores our integer value\\n        bool neg = 0; // checks whether integer will be -ve or +ve\\n        bool leading = true; // true if theres leading spaces \\n        \\n        int n = s.size();\\n\\n        for (int i = 0; i<n; i++) {\\n            if (s[i] == \\' \\') { // checks for leading spaces\\n                if (leading) continue;\\n                else break;\\n            }\\n            else if (s[i] == \\'-\\') { // checks -ve \\n                if (i+1 < n && isdigit(s[i+1])) neg = 1;\\n                else break; // break if next char is non-digit\\n            }\\n            else if (s[i] == \\'+\\') { // checks for +ve\\n                if (i+1 < n && isdigit(s[i+1])) neg = 0;\\n                else break; // break if next char is non-digit\\n            }\\n            else if (!isdigit(s[i])) break; // break on encoutring non-digit\\n            else { // storing our integer value to res\\n                if (res < 1e11) {\\n                    res = res*10 + (s[i]-\\'0\\');\\n                    if (i+1 < n && !isdigit(s[i+1])) \\n                        break;// break if next char is non-digit\\n                }\\n                else break;\\n                leading = false; // tells that integer has been encoutered\\n            }\\n        }\\n\\n        if (res > INT_MAX && neg) return INT_MIN;\\n        if (res > INT_MAX) return INT_MAX;\\n\\n        return neg ? -1*res : res;\\n    }\\n};\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\npublic:\n    int myAtoi(string s) {\n        long long res = 0; // stores our integer value\n        bool neg = 0; // checks whether integer will be -ve or +ve\n        bool leading = true; // true if theres leading spaces \n        \n        int n = s.size();\n\n        for (int i = 0; i<n; i++) {\n            if (s[i] == ' ') { // checks for leading spaces\n                if (leading) continue;\n                else break;\n            }\n            else if (s[i] == '-') { // checks -ve \n                if (i+1 < n && isdigit(s[i+1])) neg = 1;\n                else break; // break if next char is non-digit\n            }\n            else if (s[i] == '+') { // checks for +ve\n                if (i+1 < n && isdigit(s[i+1])) neg = 0;\n                else break; // break if next char is non-digit\n            }\n            else if (!isdigit(s[i])) break; // break on encoutring non-digit\n            else { // storing our integer value to res\n                if (res < 1e11) {\n                    res = res*10 + (s[i]-'0');\n                    if (i+1 < n && !isdigit(s[i+1])) \n                        break;// break if next char is non-digit\n                }\n                else break;\n                leading = false; // tells that integer has been encoutered\n            }\n        }\n\n        if (res > INT_MAX && neg) return \"INT_MIN\";\n        if (res > INT_MAX) return \"INT_MAX\";\n\n        return neg ? -1*res : res;\n    }\n};\n",
        "explanations": "\nReturning a string where an integer is expected, resulting in a type mismatch.\n"
    },
    {
        "slug": "relative-ranks",
        "description": "You are given an integer array score of size n, where score[i] is the score of the ith athlete in a competition. All the scores are guaranteed to be unique.\nThe athletes are placed based on their scores, where the 1st place athlete has the highest score, the 2nd place athlete has the 2nd highest score, and so on. The placement of each athlete determines their rank:\n\nThe 1st place athlete's rank is \"Gold Medal\".\nThe 2nd place athlete's rank is \"Silver Medal\".\nThe 3rd place athlete's rank is \"Bronze Medal\".\nFor the 4th place to the nth place athlete, their rank is their placement number (i.e., the xth place athlete's rank is \"x\").\n\nReturn an array answer of size n where answer[i] is the rank of the ith athlete.",
        "examples": [
            "Input: score = [5,4,3,2,1]\nOutput: [\"Gold Medal\",\"Silver Medal\",\"Bronze Medal\",\"4\",\"5\"]\nExplanation: The placements are [1st, 2nd, 3rd, 4th, 5th].",
            "Input: score = [10,3,8,9,4]\nOutput: [\"Gold Medal\",\"5\",\"Bronze Medal\",\"Silver Medal\",\"4\"]\nExplanation: The placements are [1st, 5th, 3rd, 2nd, 4th]."
        ],
        "constraints": "n == score.length\n1 <= n <= 104\n0 <= score[i] <= 106\nAll the values in score are unique.",
        "release_time": 1688035608,
        "oracle_code": "class Solution {\npublic:\n    vector<string> findRelativeRanks(vector<int>& score) {\n        int n = score.size();\n        \n        vector<pair<int, int>> arr;\n        for (int i=0; i<n; i++) arr.push_back({score[i], i});\n\n        sort(rbegin(arr), rend(arr));\n\n        vector<string> res(n);\n        for (int i=0; i<n; i++) \n            res[arr[i].second] = i==0? \"Gold Medal\": (i==1? \"Silver Medal\": (i==2? \"Bronze Medal\": to_string(i+1)));\n\n        return res;\n    }\n};",
        "content": "**vector solution**\\n```\\nclass Solution {\\npublic:\\n    vector<string> findRelativeRanks(vector<int>& score) {\\n        int n = score.size();\\n        \\n        vector<pair<int, int>> arr;\\n        for (int i=0; i<n; i++) arr.push_back({score[i], i});\\n\\n        sort(rbegin(arr), rend(arr));\\n\\n        vector<string> res(n);\\n        for (int i=0; i<n; i++) \\n            res[arr[i].second] = i==0? \"Gold Medal\": (i==1? \"Silver Medal\": (i==2? \"Bronze Medal\": to_string(i+1)));\\n\\n        return res;\\n    }\\n};\\n```\\n---\\n**priority queue solution**\\n```\\nclass Solution {\\npublic:\\n    vector<string> findRelativeRanks(vector<int>& score) {\\n        int n = score.size();\\n        \\n        priority_queue< pair<int, int>, vector<pair<int,int>> > pq;\\n        for (int i=0; i<n; i++) pq.push({score[i], i});\\n\\n        vector<string> res(n);\\n        while (!pq.empty()) {\\n            auto x = pq.top();\\n            int size = pq.size();\\n            res[x.second] = (size == n? \"Gold Medal\": (size == n-1? \"Silver Medal\": (size == n-2? \"Bronze Medal\": to_string(n-size+1))));\\n            pq.pop();\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\npublic:\n    vector<string> findRelativeRanks(vector<int>& score) {\n        int n = score.size();\n        \n        vector<pair<int, int>> arr;\n        for (int i=0; i<n; i++) arr.push_back({score[i], i});\n\n        sort(rbegin(arr), rend(arr));\n\n        vector<string> res(n);\n        for (int i=0; i<n; i++) \n            res[arr[i].second] = i==0? \"Gold Medal: (i==1? \"Silver Medal\": (i==2? \"Bronze Medal\": to_string(i+1)));\n\n        return res;\n    }\n};\n",
        "explanations": "\nThe string \"Gold Medal\" is not closed properly which leads to syntax error.\n"
    },
    {
        "slug": "reduction-operations-to-make-the-array-elements-equal",
        "description": "Given an integer array nums, your goal is to make all elements in nums equal. To complete one operation, follow these steps:\n\nFind the largest value in nums. Let its index be i (0-indexed) and its value be largest. If there are multiple elements with the largest value, pick the smallest i.\nFind the next largest value in nums strictly smaller than largest. Let its value be nextLargest.\nReduce nums[i] to nextLargest.\n\nReturn the number of operations to make all elements in nums equal.",
        "examples": [
            "Input: nums = [5,1,3]\nOutput: 3\nExplanation:\u00a0It takes 3 operations to make all elements in nums equal:\n1. largest = 5 at index 0. nextLargest = 3. Reduce nums[0] to 3. nums = [3,1,3].\n2. largest = 3 at index 0. nextLargest = 1. Reduce nums[0] to 1. nums = [1,1,3].\n3. largest = 3 at index 2. nextLargest = 1. Reduce nums[2] to 1. nums = [1,1,1].",
            "Input: nums = [1,1,1]\nOutput: 0\nExplanation:\u00a0All elements in nums are already equal.",
            "Input: nums = [1,1,2,2,3]\nOutput: 4\nExplanation:\u00a0It takes 4 operations to make all elements in nums equal:\n1. largest = 3 at index 4. nextLargest = 2. Reduce nums[4] to 2. nums = [1,1,2,2,2].\n2. largest = 2 at index 2. nextLargest = 1. Reduce nums[2] to 1. nums = [1,1,1,2,2].\n3. largest = 2 at index 3. nextLargest = 1. Reduce nums[3] to 1. nums = [1,1,1,1,2].\n4. largest = 2 at index 4. nextLargest = 1. Reduce nums[4] to 1. nums = [1,1,1,1,1]."
        ],
        "constraints": "1 <= nums.length <= 5 * 104\n1 <= nums[i] <= 5 * 104",
        "release_time": 1675938581,
        "oracle_code": "class Solution {\npublic:\n    int reductionOperations(vector<int>& nums) {\n        int ans = 0;\n        map<int,int> mp;\n        for(auto &i: nums){\n            mp[i]++;\n        }\n        auto it = mp.end();\n        while(mp.begin() != --it){\n            // cout<<it->first<<\" \"<<it->second<<endl;\n            auto x = it;\n            --x;\n            ans += it->second;\n            x->second += it->second;\n        }\n        return ans;\n    }\n};",
        "content": "```\\nclass Solution {\\npublic:\\n    int reductionOperations(vector<int>& nums) {\\n        int ans = 0;\\n        map<int,int> mp;\\n        for(auto &i: nums){\\n            mp[i]++;\\n        }\\n        auto it = mp.end();\\n        while(mp.begin() != --it){\\n            // cout<<it->first<<\" \"<<it->second<<endl;\\n            auto x = it;\\n            --x;\\n            ans += it->second;\\n            x->second += it->second;\\n        }\\n        return ans;\\n    }\\n};\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\npublic:\n    int reductionOperations(vector<int>& nums) {\n        int ans = 0;\n        map<int,int> mp;\n        for(auto &i: nums){\n            mp[i]++;\n        }\n        auto it = mp.end();\n        while(mp.begin() != --it){\n            // cout<<it->first<<\" \"<<it->second<<endl;\n            auto x = it;\n            --x;\n            ans += it->second;\n            x->second += it->second;\n        }\n        string missingQuotation = \"This string is not properly closed;\n        return ans;\n    }\n};\n",
        "explanations": "\nThe bug is an unclosed string, which leads to a compilation error.\n"
    },
    {
        "slug": "maximum-star-sum-of-a-graph",
        "description": "There is an undirected graph consisting of n nodes numbered from 0 to n - 1. You are given a 0-indexed integer array vals of length n where vals[i] denotes the value of the ith node.\nYou are also given a 2D integer array edges where edges[i] = [ai, bi] denotes that there exists an undirected edge connecting nodes ai and bi.\nA star graph is a subgraph of the given graph having a center node containing 0 or more neighbors. In other words, it is a subset of edges of the given graph such that there exists a common node for all edges.\nThe image below shows star graphs with 3 and 4 neighbors respectively, centered at the blue node.\n\nThe star sum is the sum of the values of all the nodes present in the star graph.\nGiven an integer k, return the maximum star sum of a star graph containing at most k edges.",
        "examples": [
            "Input: vals = [1,2,3,4,10,-10,-20], edges = [[0,1],[1,2],[1,3],[3,4],[3,5],[3,6]], k = 2\nOutput: 16\nExplanation: The above diagram represents the input graph.\nThe star graph with the maximum star sum is denoted by blue. It is centered at 3 and includes its neighbors 1 and 4.\nIt can be shown it is not possible to get a star graph with a sum greater than 16.",
            "Input: vals = [-5], edges = [], k = 0\nOutput: -5\nExplanation: There is only one possible star graph, which is node 0 itself.\nHence, we return -5."
        ],
        "constraints": "n == vals.length\n1 <= n <= 105\n-104 <= vals[i] <= 104\n0 <= edges.length <= min(n * (n - 1) / 2, 105)\nedges[i].length == 2\n0 <= ai, bi <= n - 1\nai != bi\n0 <= k <= n - 1",
        "release_time": 1670688277,
        "oracle_code": "class Solution {\npublic:\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) \n    {\n        int n = vals.size();\n        vector<vector<pair<int, int>>>adj(n);\n        for (vector<int>edge : edges)\n        {\n            int startNode = edge[0], startNodeVal = vals[startNode];\n            int endNode = edge[1], endNodeVal = vals[endNode];\n            adj[startNode].push_back({endNodeVal, endNode});\n            adj[endNode].push_back({startNodeVal, startNode});\n        }\n        //========================================================\n        int mxSum = INT_MIN;\n        for (int node = 0; node < n; node++)\n        {\n            sort(adj[node].begin(), adj[node].end()); //sort the neighbors based on increasing \"values\"\n            int neighborSize = adj[node].size();\n            int sum = vals[node];\n            for (int i = neighborSize - 1; i >= 0 && i >= (neighborSize - k); i--) //take k neighbors [start from largest vals]\n            {\n                int val = adj[node][i].first;\n                if (val < 0) break; //if value of neighbor is < 0, it would decrease sum so \"break\", \n\t\t\t\t                     //as the neighbors left to it would also have negative values\n                sum += val;\n            }\n            mxSum = max(mxSum, sum);\n        }\n        //=============================================================\n        return mxSum;\n        \n    }\n};",
        "content": "So a star graph is a graph having **one node [center node] which is connected to all other nodes directly** \\n\\nSo why not try all nodes \"as the center of star graph\"\\nFor each node,\\n  **star graph = node itself(center node)  + all it\\'s direct neighbors**\\n  \\n  Thus for each node treat it is as center node and **find sum of k highest value neighbors**\\n  [Take care of negative values =>  exclude negative values as they would decrease overall sum]\\n  \\n  \\n  \\n```\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) \\n    {\\n        int n = vals.size();\\n        vector<vector<pair<int, int>>>adj(n);\\n        for (vector<int>edge : edges)\\n        {\\n            int startNode = edge[0], startNodeVal = vals[startNode];\\n            int endNode = edge[1], endNodeVal = vals[endNode];\\n            adj[startNode].push_back({endNodeVal, endNode});\\n            adj[endNode].push_back({startNodeVal, startNode});\\n        }\\n        //========================================================\\n        int mxSum = INT_MIN;\\n        for (int node = 0; node < n; node++)\\n        {\\n            sort(adj[node].begin(), adj[node].end()); //sort the neighbors based on increasing \"values\"\\n            int neighborSize = adj[node].size();\\n            int sum = vals[node];\\n            for (int i = neighborSize - 1; i >= 0 && i >= (neighborSize - k); i--) //take k neighbors [start from largest vals]\\n            {\\n                int val = adj[node][i].first;\\n                if (val < 0) break; //if value of neighbor is < 0, it would decrease sum so \"break\", \\n\\t\\t\\t\\t                     //as the neighbors left to it would also have negative values\\n                sum += val;\\n            }\\n            mxSum = max(mxSum, sum);\\n        }\\n        //=============================================================\\n        return mxSum;\\n        \\n    }\\n};\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\npublic:\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) \n    {\n        int n = vals.size();\n        vector<vector<pair<int, int>>>adj(n);\n        for (vector<int>edge : edges)\n        {\n            int startNode = edge[0], startNodeVal = vals[startNode];\n            int endNode = edge[1], endNodeVal = vals[endNode];\n            adj[startNode].push_back({endNodeVal, endNode});\n            adj[endNode].push_back({startNodeVal, startNode);\n        }\n        //========================================================\n        int mxSum = INT_MIN;\n        for (int node = 0; node < n; node++)\n        {\n            sort(adj[node].begin(), adj[node].end()); //sort the neighbors based on increasing \"values\"\n            int neighborSize = adj[node].size();\n            int sum = vals[node];\n            for (int i = neighborSize - 1; i >= 0 && i >= (neighborSize - k); i--) //take k neighbors [start from largest vals]\n            {\n                int val = adj[node][i].first;\n                if (val < 0) break; //if value of neighbor is < 0, it would decrease sum so \"break\", \n\t\t\t\t                     //as the neighbors left to it would also have negative values\n                sum += val;\n            }\n            mxSum = max(mxSum, sum);\n        }\n        //=============================================================\n        return mxSum;\n        \n    }\n};\n",
        "explanations": "\nThe closing bracket of a function call is missing causing an unclosed expression error.\n"
    },
    {
        "slug": "flip-string-to-monotone-increasing",
        "description": "A binary string is monotone increasing if it consists of some number of 0's (possibly none), followed by some number of 1's (also possibly none).\nYou are given a binary string s. You can flip s[i] changing it from 0 to 1 or from 1 to 0.\nReturn the minimum number of flips to make s monotone increasing.",
        "examples": [
            "Input: s = \"00110\"\nOutput: 1\nExplanation: We flip the last digit to get 00111.",
            "Input: s = \"010110\"\nOutput: 2\nExplanation: We flip to get 011111, or alternatively 000111.",
            "Input: s = \"00011000\"\nOutput: 2\nExplanation: We flip to get 00000000."
        ],
        "constraints": "1 <= s.length <= 105\ns[i] is either '0' or '1'.",
        "release_time": 1673915632,
        "oracle_code": "//Memoisation\nclass Solution {\npublic:\n    int solve(int idx,int prev,string &s,vector<vector<int>>& dp){\n        if(idx==s.size()){\n            return 0;\n        }\n        if(dp[idx][prev]!=-1) return dp[idx][prev];\n        if(prev){\n            return dp[idx][prev]=(s[idx]=='0')+solve(idx+1,prev,s,dp);\n        }\n        else{\n            return dp[idx][prev]=min((s[idx]=='1')+solve(idx+1,0,s,dp),(s[idx]=='0')+solve(idx+1,1,s,dp));\n        }\n    }\n    int minFlipsMonoIncr(string s) {\n        vector<vector<int>> dp(s.size(),vector<int>(2,-1));\n        return solve(0,0,s,dp);\n    }\n};",
        "content": "```\\n//Memoisation\\nclass Solution {\\npublic:\\n    int solve(int idx,int prev,string &s,vector<vector<int>>& dp){\\n        if(idx==s.size()){\\n            return 0;\\n        }\\n        if(dp[idx][prev]!=-1) return dp[idx][prev];\\n        if(prev){\\n            return dp[idx][prev]=(s[idx]==\\'0\\')+solve(idx+1,prev,s,dp);\\n        }\\n        else{\\n            return dp[idx][prev]=min((s[idx]==\\'1\\')+solve(idx+1,0,s,dp),(s[idx]==\\'0\\')+solve(idx+1,1,s,dp));\\n        }\\n    }\\n    int minFlipsMonoIncr(string s) {\\n        vector<vector<int>> dp(s.size(),vector<int>(2,-1));\\n        return solve(0,0,s,dp);\\n    }\\n};\\n\\n```\\n```\\n//Tabulation\\nclass Solution {\\npublic:\\n    int minFlipsMonoIncr(string s) {\\n        int n=s.size();\\n        vector<vector<int>> dp(n+1,vector<int>(2,0));\\n        for(int idx=n-1;idx>=0;idx--){\\n            for(int prev=1;prev>=0;prev--){\\n                if(prev){\\n                    dp[idx][prev]=(s[idx]==\\'0\\')+dp[idx+1][prev];\\n                }\\n                else{\\n                    dp[idx][prev]=min((s[idx]==\\'1\\')+dp[idx+1][0],(s[idx]==\\'0\\')+dp[idx+1][1]);\\n                }\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n};\\n```\\n```\\n//Space Optimization\\nclass Solution {\\npublic:\\n    int minFlipsMonoIncr(string s) {\\n        int n=s.size();\\n        vector<int> dp(2,0);\\n        for(int idx=n-1;idx>=0;idx--){\\n            vector<int> curr(2,0);\\n            for(int prev=1;prev>=0;prev--){\\n                if(prev){\\n                    curr[prev]=(s[idx]==\\'0\\')+dp[prev];\\n                }\\n                else{\\n                    curr[prev]=min((s[idx]==\\'1\\')+dp[0],(s[idx]==\\'0\\')+dp[1]);\\n                }\\n            }\\n            dp=curr;\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
        "level": "medium",
        "buggy_code": "\n//Memoisation\nclass Solution {\npublic:\n    int solve(int idx,int prev,string &s,vector<vector<int>>& dp){\n        if(idx==s.size()){\n            return 0;\n        }\n        if(dp[idx][prev]!=-1) return dp[idx][prev];\n        if(prev){\n            return dp[idx][prev]=(s[idx]=='0')+solve(idx+1,prev,s,dp);\n        }\n        else{\n            return dp[idx][prev]=min((s[idx]==1)+solve(idx+1,0,s,dp),(s[idx]=='0')+solve(idx+1,1,s,dp));\n        }\n    }\n    int minFlipsMonoIncr(string s) {\n        vector<vector<int>> dp(s.size(),vector<int>(2,-1));\n        return solve(0,0,s,dp);\n    }\n};\n",
        "explanations": "\nI left an unclosed string where it should check if s[idx] is equal to '1'.\n"
    },
    {
        "slug": "first-letter-to-appear-twice",
        "description": "Given a string s consisting of lowercase English letters, return the first letter to appear twice.\nNote:\n\nA letter a appears twice before another letter b if the second occurrence of a is before the second occurrence of b.\ns will contain at least one letter that appears twice.",
        "examples": [
            "Input: s = \"abccbaacz\"\nOutput: \"c\"\nExplanation:\nThe letter 'a' appears on the indexes 0, 5 and 6.\nThe letter 'b' appears on the indexes 1 and 4.\nThe letter 'c' appears on the indexes 2, 3 and 7.\nThe letter 'z' appears on the index 8.\nThe letter 'c' is the first letter to appear twice, because out of all the letters the index of its second occurrence is the smallest.",
            "Input: s = \"abcdd\"\nOutput: \"d\"\nExplanation:\nThe only letter that appears twice is 'd' so we return 'd'."
        ],
        "constraints": "2 <= s.length <= 100\ns consists of lowercase English letters.\ns has at least one repeated letter.",
        "release_time": 1690691593,
        "oracle_code": "class Solution {\npublic:\n    char repeatedCharacter(string s) {\n        unordered_map<char, int> ump;\n        for(int i = 0; i<s.size(); i++ ){\n            ump[s[i]]++;\n            if( ump[s[i]] == 2 ) {\n                return s[i];\n            }\n        }\n\n        return 'a';\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    char repeatedCharacter(string s) {\\n        unordered_map<char, int> ump;\\n        for(int i = 0; i<s.size(); i++ ){\\n            ump[s[i]]++;\\n            if( ump[s[i]] == 2 ) {\\n                return s[i];\\n            }\\n        }\\n\\n        return \\'a\\';\\n    }\\n};\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\npublic:\n    char repeatedCharacter(string s) {\n        unordered_map<char, int> ump;\n        for(int i = 0; i<s.size(); i++ ){\n            ump[s[i]]++;\n            if( ump[s[i]] == 2 ) {\n                return s[i];\n            }\n        }\n\n        return 'a;\n    }\n};\n",
        "explanations": "\nThe string 'a' is not closed properly with the end quote, causing a syntax error.\n"
    },
    {
        "slug": "is-graph-bipartite",
        "description": "There is an undirected graph with n nodes, where each node is numbered between 0 and n - 1. You are given a 2D array graph, where graph[u] is an array of nodes that node u is adjacent to. More formally, for each v in graph[u], there is an undirected edge between node u and node v. The graph has the following properties:\n\nThere are no self-edges (graph[u] does not contain u).\nThere are no parallel edges (graph[u] does not contain duplicate values).\nIf v is in graph[u], then u is in graph[v] (the graph is undirected).\nThe graph may not be connected, meaning there may be two nodes u and v such that there is no path between them.\n\nA graph is bipartite if the nodes can be partitioned into two independent sets A and B such that every edge in the graph connects a node in set A and a node in set B.\nReturn true if and only if it is bipartite.",
        "examples": [
            "Input: graph = [[1,2,3],[0,2],[0,1,3],[0,2]]\nOutput: false\nExplanation: There is no way to partition the nodes into two independent sets such that every edge connects a node in one and a node in the other.",
            "Input: graph = [[1,3],[0,2],[1,3],[0,2]]\nOutput: true\nExplanation: We can partition the nodes into two sets: {0, 2} and {1, 3}."
        ],
        "constraints": "graph.length == n\n1 <= n <= 100\n0 <= graph[u].length < n\n0 <= graph[u][i] <= n - 1\ngraph[u]\u00a0does not contain\u00a0u.\nAll the values of graph[u] are unique.\nIf graph[u] contains v, then graph[v] contains u.",
        "release_time": 1684525813,
        "oracle_code": "class Solution {\npublic:\n    //graph coloring\n\n    //flag variable, to be turned on when an error of two neighbouring nodes having same colour is detected\n    bool flag = false;\n\n    //dfs traversal\n    void dfs(int ind, vector<vector<int>>& graph, vector<int>& color, int currcolor)\n    {\n\n        //color the current node\n        color[ind]=currcolor;\n\n\n        for(auto it: graph[ind])\n        {\n\n            //if a neighbour node is not coloured yet then color it with opposite color \n            if(color[it] == 0) dfs(it, graph, color, currcolor*(-1));\n\n            //if a neighbour node is already coloured then it should have opposite colour what current node is having right now\n            //else if a neighbour have same colour then making this graph a bipartite is not possible\n            else if(color[it] == currcolor)\n            {\n                flag=true;\n                return;\n            }\n        }\n    }\n    bool isBipartite(vector<vector<int>>& graph) {\n        \n        //no of nodes in graph\n        int n = graph.size();\n        \n        //coloring array\n        vector<int> color(n, 0);\n\n        for(int i=0; i<graph.size(); i++)\n        {\n            //if a uncolored node in encountered then color it and it's corresponding uncoloured neighbouring node\n            if(color[i]==0) dfs(i, graph, color, 1);\n\n            //if flag got turned on then making this graph bipartite is not possible\n            if(flag) return false;\n        }\n\n        return true;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor making a graph bipartite any two of it\\'s adjacent node should come under two different sections.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Denoting two different section as two different colors (here, 1 & -1).\\n- Implementing dfs and start coloring the graph.\\n- Coloring every adjacent node of current node with opposite color of current node.\\n- If two adjacent nodes are encountered with same colour then return false, because in this case making this graph bipartite is not possible.\\n- If whole graph is coloured, then this graph can be bipartite, so return true.\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    //graph coloring\\n\\n    //flag variable, to be turned on when an error of two neighbouring nodes having same colour is detected\\n    bool flag = false;\\n\\n    //dfs traversal\\n    void dfs(int ind, vector<vector<int>>& graph, vector<int>& color, int currcolor)\\n    {\\n\\n        //color the current node\\n        color[ind]=currcolor;\\n\\n\\n        for(auto it: graph[ind])\\n        {\\n\\n            //if a neighbour node is not coloured yet then color it with opposite color \\n            if(color[it] == 0) dfs(it, graph, color, currcolor*(-1));\\n\\n            //if a neighbour node is already coloured then it should have opposite colour what current node is having right now\\n            //else if a neighbour have same colour then making this graph a bipartite is not possible\\n            else if(color[it] == currcolor)\\n            {\\n                flag=true;\\n                return;\\n            }\\n        }\\n    }\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        \\n        //no of nodes in graph\\n        int n = graph.size();\\n        \\n        //coloring array\\n        vector<int> color(n, 0);\\n\\n        for(int i=0; i<graph.size(); i++)\\n        {\\n            //if a uncolored node in encountered then color it and it\\'s corresponding uncoloured neighbouring node\\n            if(color[i]==0) dfs(i, graph, color, 1);\\n\\n            //if flag got turned on then making this graph bipartite is not possible\\n            if(flag) return false;\\n        }\\n\\n        return true;\\n    }\\n};\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\npublic:\n    //graph coloring\n\n    //flag variable, to be turned on when an error of two neighbouring nodes having same colour is detected\n    bool flag = false;\n\n    //dfs traversal\n    void dfs(int ind, vector<vector<int>>& graph, vector<int>& color, int currcolor)\n    {\n\n        //color the current node\n        color[ind]=currcolor;\n\n\n        for(auto it: graph[ind])\n        {\n\n            //if a neighbour node is not coloured yet then color it with opposite color \n            if(color[it] == 0) dfs(it, graph, color, currcolor*(-1));\n\n            //if a neighbour node is already coloured then it should have opposite colour what current node is having right now\n            //else if a neighbour have same colour then making this graph a bipartite is not possible\n            else if(color[it] == currcolor)\n            {\n                flag=true;\n                return;\n            }\n        }\n    }\n    bool isBipartite(vector<vector<int>>& graph) {\n        \n        //no of nodes in graph\n        int n = graph.size();\n        \n        //coloring array\n        vector<int> color(n, 0);\n\n        for(int i=0; i<graph.size(); i++)\n        {\n            //if a uncolored node in encountered then color it and it's corresponding uncoloured neighbouring node\n            if(color[i]==0) dfs(i, graph, color, 1);\n\n            //if flag got turned on then making this graph bipartite is not possible\n            if(flag) return \"false;\n        }\n\n        return true;\n    }\n};\n",
        "explanations": "\nThere is an unclosed string at the return statement in the isBipartite function.\n"
    },
    {
        "slug": "flip-string-to-monotone-increasing",
        "description": "A binary string is monotone increasing if it consists of some number of 0's (possibly none), followed by some number of 1's (also possibly none).\nYou are given a binary string s. You can flip s[i] changing it from 0 to 1 or from 1 to 0.\nReturn the minimum number of flips to make s monotone increasing.",
        "examples": [
            "Input: s = \"00110\"\nOutput: 1\nExplanation: We flip the last digit to get 00111.",
            "Input: s = \"010110\"\nOutput: 2\nExplanation: We flip to get 011111, or alternatively 000111.",
            "Input: s = \"00011000\"\nOutput: 2\nExplanation: We flip to get 00000000."
        ],
        "constraints": "1 <= s.length <= 105\ns[i] is either '0' or '1'.",
        "release_time": 1673920922,
        "oracle_code": "class Solution {\npublic:\n    int minFlipsMonoIncr(string s) {\n        int flip=0,one=0,n = s.size();\n        for(int i=0;i<n;i++){\n            if(s[i]=='1'){\n                one++;\n            }else{\n                if(one==0)continue;\n                else flip++;\n            }\n            if(one<flip)flip = one;\n        }\n        return flip;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nspecial mention : [prathz](https://leetcode.com/problems/flip-string-to-monotone-increasing/solutions/3061177/c-prefix-sum/?orderBy=hot)  for this approach\\nPrefix sum \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSkip the loop until we find the first \\'1\\'\\nafter finding first occurrence of \\'1\\' we have to keep a count of number of \\'1\\'s in countOnes\\n\\nif we find any \\'0\\' after occurrence of \\'1\\' it means turning that \\'0\\' to one may be one possible solution so we have to keep number of flip needed in countFlips variable\\n\\nif value of countFlips is greater than countOnes(number of ones) then converting all \\'1\\' to \\'0\\' would be better option so assign value of countOnes to the countFlips\\n\\nin the end we will return countFlips\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minFlipsMonoIncr(string s) {\\n        int flip=0,one=0,n = s.size();\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'1\\'){\\n                one++;\\n            }else{\\n                if(one==0)continue;\\n                else flip++;\\n            }\\n            if(one<flip)flip = one;\\n        }\\n        return flip;\\n    }\\n};\\n\\n```\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCounting the no. of 1\\'s to flip on left side + no. of 0\\'s to flip on right side of each index i and then select minimum flips from it.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMaintain a prefix and suffix array to count 1 on left side and 0 on right side.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minFlipsMonoIncr(string s) {\\n        int n = s.size(),ans = INT_MAX;\\n        vector<int> onecount(n,0),zerocount(n,0);\\n        onecount[0] = 0,zerocount[n-1]=0;\\n        for(int i=1;i<n;i++){\\n            if(s[i-1]==\\'1\\')onecount[i] = onecount[i-1]+1;\\n            else onecount[i] = onecount[i-1];\\n            if(s[n-i]==\\'0\\')zerocount[n-i-1] = zerocount[n-i]+1;\\n            else zerocount[n-i-1] = zerocount[n-i];\\n        }\\n        for(int i=0;i<n;i++){\\n            ans = min(ans,zerocount[i]+onecount[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCounting the no. of 1\\'s to flip on left side + no. of 0\\'s to flip on right side of each index i and then select minimum flips from it.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBrute \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n^2)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n### TLE on 73rd test case \\n# Code\\n```\\nclass Solution {\\nprivate:\\nint onecount(string s){\\n    int n = s.size();\\n    int cnt=0;\\n    for(int i=0;i<n;i++){\\n        if(s[i]==\\'1\\')cnt++;\\n    }\\n    return cnt;\\n}\\nint zerocount(string s){\\n    int n = s.size();\\n    int cnt=0;\\n    for(int i=0;i<n;i++){\\n        if(s[i]==\\'0\\')cnt++;\\n    }\\n    return cnt;\\n}\\npublic:\\n    int minFlipsMonoIncr(string s) {\\n        int n = s.size();\\n        int mini = INT_MAX;\\n        vector<int> ans(n,0);\\n        for(int i=0;i<n;i++){\\n            ans[i]+= onecount(s.substr(0,i));\\n            ans[i]+= zerocount(s.substr(i+1));\\n            mini = min(mini,ans[i]);\\n        }\\n        return mini;\\n    }\\n};\\n```\\n",
        "level": "medium",
        "buggy_code": "\nclass Solution {\npublic:\n    int minFlipsMonoIncr(string s) {\n        int flip=0,one=0,n = s.size();\n        for(int i=0;i<n;i++){\n            if(s[i]=='1){\n                one++;\n            }else{\n                if(one==0)continue;\n                else flip++;\n            }\n            if(one<flip)flip = \"one;\n        }\n        return flip;\n    }\n};\n",
        "explanations": "\nThe bug is an unclosed string: \"one used instead of one inside if(one<flip) statement.\n"
    },
    {
        "slug": "special-binary-string",
        "description": "Special binary strings are binary strings with the following two properties:\n\nThe number of 0's is equal to the number of 1's.\nEvery prefix of the binary string has at least as many 1's as 0's.\n\nYou are given a special binary string s.\nA move consists of choosing two consecutive, non-empty, special substrings of s, and swapping them. Two strings are consecutive if the last character of the first string is exactly one index before the first character of the second string.\nReturn the lexicographically largest resulting string possible after applying the mentioned operations on the string.",
        "examples": [
            "Input: s = \"11011000\"\nOutput: \"11100100\"\nExplanation: The strings \"10\" [occuring at s[1]] and \"1100\" [at s[3]] are swapped.\nThis is the lexicographically largest string possible after some number of swaps.",
            "Input: s = \"10\"\nOutput: \"10\""
        ],
        "constraints": "1 <= s.length <= 50\ns[i] is either '0' or '1'.\ns is a special binary string.",
        "release_time": 1672388328,
        "oracle_code": "class Solution {\npublic:\n    string makeLargestSpecial(string s) {\n        \n        if(s.length()==0)\n            return \"\"; //return null string if size is zero\n\n        vector<string> ans; //list to store all current special substrings\n        int count=0,i=0; //keep track of special substring starting index using \"i\" and \n                         //\"count\" to keep the track of special substring is over or not\n\n        for(int j=0;j<s.size();j++){\n            if(s[j] == '1')\n                count++;\n            else\n                count--;\n            \n            if(count==0){\n                //call recursively using mid special substring\n\n                ans.push_back('1' + makeLargestSpecial(s.substr(i+1,j-i-1)) + '0');\n                i = j+1;\n            }\n        }\n        //sort current substring stored list to fulfill the question demand\n\n        sort(ans.begin(),ans.end(),greater<string>());\n        string finalString = \"\";\n        for(i=0;i<ans.size();i++){\n            finalString += ans[i];\n        }\n        return finalString;\n    }\n};",
        "content": "Reminder: Special substring can not start with 0 as the 2nd condition states there should be atleast as many no of ones as zeroes, \\neg: \"01001\" prefix of this string is \"0\" but it does\\'nt contain any 1s with itself\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string makeLargestSpecial(string s) {\\n        \\n        if(s.length()==0)\\n            return \"\"; //return null string if size is zero\\n\\n        vector<string> ans; //list to store all current special substrings\\n        int count=0,i=0; //keep track of special substring starting index using \"i\" and \\n                         //\"count\" to keep the track of special substring is over or not\\n\\n        for(int j=0;j<s.size();j++){\\n            if(s[j] == \\'1\\')\\n                count++;\\n            else\\n                count--;\\n            \\n            if(count==0){\\n                //call recursively using mid special substring\\n\\n                ans.push_back(\\'1\\' + makeLargestSpecial(s.substr(i+1,j-i-1)) + \\'0\\');\\n                i = j+1;\\n            }\\n        }\\n        //sort current substring stored list to fulfill the question demand\\n\\n        sort(ans.begin(),ans.end(),greater<string>());\\n        string finalString = \"\";\\n        for(i=0;i<ans.size();i++){\\n            finalString += ans[i];\\n        }\\n        return finalString;\\n    }\\n};\\n```",
        "level": "hard",
        "buggy_code": "\nclass Solution {\npublic:\n    string makeLargestSpecial(string s) {\n        \n        if(s.length()==0)\n            return \"\"; //return null string if size is zero\n\n        vector<string> ans; //list to store all current special substrings\n        int count=0,i=0; //keep track of special substring starting index using \"i\" and \n                         //\"count\" to keep the track of special substring is over or not\n\n        for(int j=0;j<s.size();j++){\n            if(s[j] == '1')\n                count++;\n            else\n                count--;\n            \n            if(count==0){\n                //call recursively using mid special substring\n                ans.push_back('1' + makeLargestSpecial(s.substr(i+1,j-i-1)) + '0\");\n                i = j+1;\n            }\n        }\n        //sort current substring stored list to fulfill the question demand\n\n        sort(ans.begin(),ans.end(),greater<string>());\n        string finalString = \"\";\n        for(i=0;i<ans.size();i++){\n            finalString += ans[i];\n        }\n        return finalString;\n    }\n};\n",
        "explanations": "\nThe string argument in push_back() does not have a closing quote, causing a compile error.\n"
    },
    {
        "slug": "greatest-common-divisor-of-strings",
        "description": "For two strings s and t, we say \"t divides s\" if and only if s = t + ... + t (i.e., t is concatenated with itself one or more times).\nGiven two strings str1 and str2, return the largest string x such that x divides both str1 and str2.",
        "examples": [
            "Input: str1 = \"ABCABC\", str2 = \"ABC\"\nOutput: \"ABC\"",
            "Input: str1 = \"ABABAB\", str2 = \"ABAB\"\nOutput: \"AB\"",
            "Input: str1 = \"LEET\", str2 = \"CODE\"\nOutput: \"\""
        ],
        "constraints": "1 <= str1.length, str2.length <= 1000\nstr1 and str2 consist of English uppercase letters.",
        "release_time": 1675286920,
        "oracle_code": "class Solution {\npublic:\n    string gcdOfStrings(string str1, string str2) {\n\n        if(str1+str2==str2+str1)\n        {\n            return str1.substr(0,gcd(str1.length(),str2.length()));\n        }\n        else{\n            return \"\";\n        }\n        \n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string gcdOfStrings(string str1, string str2) {\\n\\n        if(str1+str2==str2+str1)\\n        {\\n            return str1.substr(0,gcd(str1.length(),str2.length()));\\n        }\\n        else{\\n            return \"\";\\n        }\\n        \\n    }\\n};\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\npublic:\n    string gcdOfStrings(string str1, \"string str2) {\n\n        if(str1+str2==str2+str1)\n        {\n            return str1.substr(0,gcd(str1.length(),str2.length()));\n        }\n        else{\n            return \"\";\n        }\n        \n    }\n};\n",
        "explanations": "\nThe second parameter of the gcdOfStrings function has an unclosed string, causing a compile error.\n"
    },
    {
        "slug": "smallest-string-starting-from-leaf",
        "description": "You are given the root of a binary tree where each node has a value in the range [0, 25] representing the letters 'a' to 'z'.\nReturn the lexicographically smallest string that starts at a leaf of this tree and ends at the root.\nAs a reminder, any shorter prefix of a string is lexicographically smaller.\n\nFor example, \"ab\" is lexicographically smaller than \"aba\".\n\nA leaf of a node is a node that has no children.",
        "examples": [
            "Input: root = [0,1,2,3,4,3,4]\nOutput: \"dba\"",
            "Input: root = [25,1,3,1,3,0,2]\nOutput: \"adz\"",
            "Input: root = [2,2,1,null,1,0,null,0]\nOutput: \"abc\""
        ],
        "constraints": "The number of nodes in the tree is in the range [1, 8500].\n0 <= Node.val <= 25",
        "release_time": 1689057293,
        "oracle_code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    string BFS(TreeNode* root)\n    {\n        if(!root) return \"\";\n        queue<pair<TreeNode*,string>> q;\n        vector<string> ans;\n        string s = \"\";\n        s+=root->val+97;\n        q.push({root,s});\n        while(!q.empty())\n        {\n            TreeNode* node = q.front().first;\n            string str = q.front().second;\n            q.pop();\n            if(!node->left && !node->right)\n            {\n                reverse(str.begin(),str.end());\n                ans.push_back(str);\n            }\n            if(node->left)\n            {\n                string tmp = str;\n                tmp+=node->left->val+97;\n                q.push({node->left,tmp});\n            }\n            if(node->right)\n            {\n                string tmp = str;\n                tmp+=node->right->val+97;\n                q.push({node->right,tmp});\n            }\n        }\n        sort(ans.begin(),ans.end());\n        return ans[0];\n    }\n    string smallestFromLeaf(TreeNode* root) {\n       return BFS(root);\n    }\n};",
        "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDo the BFS Traversal from  **Root Node** to **Leaf Node** and Store the **Path as a string** and return the **lexicographically smallest** string.\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    string BFS(TreeNode* root)\\n    {\\n        if(!root) return \"\";\\n        queue<pair<TreeNode*,string>> q;\\n        vector<string> ans;\\n        string s = \"\";\\n        s+=root->val+97;\\n        q.push({root,s});\\n        while(!q.empty())\\n        {\\n            TreeNode* node = q.front().first;\\n            string str = q.front().second;\\n            q.pop();\\n            if(!node->left && !node->right)\\n            {\\n                reverse(str.begin(),str.end());\\n                ans.push_back(str);\\n            }\\n            if(node->left)\\n            {\\n                string tmp = str;\\n                tmp+=node->left->val+97;\\n                q.push({node->left,tmp});\\n            }\\n            if(node->right)\\n            {\\n                string tmp = str;\\n                tmp+=node->right->val+97;\\n                q.push({node->right,tmp});\\n            }\\n        }\\n        sort(ans.begin(),ans.end());\\n        return ans[0];\\n    }\\n    string smallestFromLeaf(TreeNode* root) {\\n       return BFS(root);\\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/67c6667a-66b6-4d36-846d-56e86a3b137a_1689057284.4817927.jpeg)\\n",
        "level": "medium",
        "buggy_code": "\nclass Solution {\npublic:\n    string BFS(TreeNode* root)\n    {\n        if(!root) return \"\";\n        queue<pair<TreeNode*,string>> q;\n        vector<string> ans;\n        string s = \"Unclosed string;\n        s+=root->val+97;\n        q.push({root,s});\n        while(!q.empty())\n        {\n            TreeNode* node = q.front().first;\n            string str = q.front().second;\n            q.pop();\n            if(!node->left && !node->right)\n            {\n                reverse(str.begin(),str.end());\n                ans.push_back(str);\n            }\n            if(node->left)\n            {\n                string tmp = str;\n                tmp+=node->left->val+97;\n                q.push({node->left,tmp});\n            }\n            if(node->right)\n            {\n                string tmp = str;\n                tmp+=node->right->val+97;\n                q.push({node->right,tmp});\n            }\n        }\n        sort(ans.begin(),ans.end());\n        return ans[0];\n    }\n    string smallestFromLeaf(TreeNode* root) {\n       return BFS(root);\n    }\n};\n",
        "explanations": "\nThe bug is an unclosed string, causing a syntax error while compiling the code.\n"
    },
    {
        "slug": "shortest-path-with-alternating-colors",
        "description": "You are given an integer n, the number of nodes in a directed graph where the nodes are labeled from 0 to n - 1. Each edge is red or blue in this graph, and there could be self-edges and parallel edges.\nYou are given two arrays redEdges and blueEdges where:\n\nredEdges[i] = [ai, bi] indicates that there is a directed red edge from node ai to node bi in the graph, and\nblueEdges[j] = [uj, vj] indicates that there is a directed blue edge from node uj to node vj in the graph.\n\nReturn an array answer of length n, where each answer[x] is the length of the shortest path from node 0 to node x such that the edge colors alternate along the path, or -1 if such a path does not exist.",
        "examples": [
            "Input: n = 3, redEdges = [[0,1],[1,2]], blueEdges = []\nOutput: [0,1,-1]",
            "Input: n = 3, redEdges = [[0,1]], blueEdges = [[2,1]]\nOutput: [0,1,-1]"
        ],
        "constraints": "1 <= n <= 100\n0 <= redEdges.length,\u00a0blueEdges.length <= 400\nredEdges[i].length == blueEdges[j].length == 2\n0 <= ai, bi, uj, vj < n",
        "release_time": 1676113078,
        "oracle_code": "class Solution {\npublic:\n    vector<int> shortestAlternatingPaths(int n,vector<vector<int>>&redEdges,vector<vector<int>>& blueEdges) \n    {\n        multiset<int>temp;\n        vector<multiset<int>>redchilds(n,temp),bluechilds(n,temp);\n        for(auto j:redEdges)\n        {\n            redchilds[j[0]].insert(j[1]);\n        }\n        for(auto j:blueEdges)\n        {\n            bluechilds[j[0]].insert(j[1]);\n        }\n        vector<int>ans;\n        for(int i=0;i<n;i++)\n        {\n            //BFS for all\n            vector<multiset<int>>reds=redchilds,blues=bluechilds;\n            queue<pair<char,int>>visit;\n            visit.push({'n',0});//neutral='n'\n            int steps=0;\n            while(!visit.empty())\n            {\n                bool justbreak=false;\n                int n=visit.size();\n                for(int j=0;j<n;j++)\n                {\n                    pair<char,int>x=visit.front();\n                    visit.pop();\n                    if(x.second==i)\n                    {\n                        ans.push_back(steps);\n                        justbreak=true;\n                        break;\n                    }\n                    if(x.first=='n')\n                    {\n                        for(auto j:reds[x.second])\n                        {\n                            visit.push({'r',j});\n                            auto itr1=reds[x.second].find(j);\n                            reds[x.second].erase(itr1);\n                        }\n                        for(auto j:blues[x.second])\n                        {\n                            visit.push({'b',j});//blue='b'\n                            auto itr1=blues[x.second].find(j);\n                            blues[x.second].erase(itr1);\n                        }\n                    }\n                    else if(x.first=='b')\n                    {\n                        for(auto j:reds[x.second])\n                        {\n                            visit.push({'r',j});//red='r'\n                            auto itr1=reds[x.second].find(j);\n                            reds[x.second].erase(itr1);\n                        }\n                    }\n                    else if(x.first=='r')\n                    {\n                        for(auto j:blues[x.second])\n                        {\n                            visit.push({'b',j});\n                            auto itr1=blues[x.second].find(j);\n                            blues[x.second].erase(itr1);\n                        }\n                    }\n                }\n                if(justbreak)\n                {\n                    break;\n                }\n                steps++;\n            }\n            if(i==ans.size())\n            {\n                ans.push_back(-1);\n            }\n        }\n        return ans;\n    }\n};",
        "content": "*E denotes number of Edges*\\n\\n# Complexity\\n- Time complexity:\\nO((N^2)+(N)*(E)*LOG(E))\\n\\n- Space complexity:\\nO(E)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> shortestAlternatingPaths(int n,vector<vector<int>>&redEdges,vector<vector<int>>& blueEdges) \\n    {\\n        multiset<int>temp;\\n        vector<multiset<int>>redchilds(n,temp),bluechilds(n,temp);\\n        for(auto j:redEdges)\\n        {\\n            redchilds[j[0]].insert(j[1]);\\n        }\\n        for(auto j:blueEdges)\\n        {\\n            bluechilds[j[0]].insert(j[1]);\\n        }\\n        vector<int>ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            //BFS for all\\n            vector<multiset<int>>reds=redchilds,blues=bluechilds;\\n            queue<pair<char,int>>visit;\\n            visit.push({\\'n\\',0});//neutral=\\'n\\'\\n            int steps=0;\\n            while(!visit.empty())\\n            {\\n                bool justbreak=false;\\n                int n=visit.size();\\n                for(int j=0;j<n;j++)\\n                {\\n                    pair<char,int>x=visit.front();\\n                    visit.pop();\\n                    if(x.second==i)\\n                    {\\n                        ans.push_back(steps);\\n                        justbreak=true;\\n                        break;\\n                    }\\n                    if(x.first==\\'n\\')\\n                    {\\n                        for(auto j:reds[x.second])\\n                        {\\n                            visit.push({\\'r\\',j});\\n                            auto itr1=reds[x.second].find(j);\\n                            reds[x.second].erase(itr1);\\n                        }\\n                        for(auto j:blues[x.second])\\n                        {\\n                            visit.push({\\'b\\',j});//blue=\\'b\\'\\n                            auto itr1=blues[x.second].find(j);\\n                            blues[x.second].erase(itr1);\\n                        }\\n                    }\\n                    else if(x.first==\\'b\\')\\n                    {\\n                        for(auto j:reds[x.second])\\n                        {\\n                            visit.push({\\'r\\',j});//red=\\'r\\'\\n                            auto itr1=reds[x.second].find(j);\\n                            reds[x.second].erase(itr1);\\n                        }\\n                    }\\n                    else if(x.first==\\'r\\')\\n                    {\\n                        for(auto j:blues[x.second])\\n                        {\\n                            visit.push({\\'b\\',j});\\n                            auto itr1=blues[x.second].find(j);\\n                            blues[x.second].erase(itr1);\\n                        }\\n                    }\\n                }\\n                if(justbreak)\\n                {\\n                    break;\\n                }\\n                steps++;\\n            }\\n            if(i==ans.size())\\n            {\\n                ans.push_back(-1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\npublic:\n    vector<int> shortestAlternatingPaths(int n,vector<vector<int>>&redEdges,vector<vector<int>>& blueEdges) \n    {\n        multiset<int>temp;\n        vector<multiset<int>>redchilds(n,temp),bluechilds(n,temp);\n        for(auto j:redEdges)\n        {\n            redchilds[j[0]].insert(j[1]);\n        }\n        for(auto j:blueEdges)\n        {\n            bluechilds[j[0]].insert(j[1]);\n        }\n        vector<int>ans;\n        for(int i=0;i<n;i++)\n        {\n            //BFS for all\n            vector<multiset<int>>reds=redchilds,blues=bluechilds;\n            queue<pair<char,int>>visit;\n            visit.push({'n',0});//neutral='n'\n            int steps=0;\n            while(!visit.empty())\n            {\n                bool justbreak=false;\n                int n=visit.size();\n                for(int j=0;j<n;j++)\n                {\n                    pair<char,int>x=visit.front();\n                    visit.pop();\n                    if(x.second==i)\n                    {\n                        ans.push_back(steps);\n                        justbreak=true;\n                        break;\n                    }\n                    if(x.first=='n')\n                    {\n                        for(auto j:reds[x.second])\n                        {\n                            visit.push({'r\",j});\n                            auto itr1=reds[x.second].find(j);\n                            reds[x.second].erase(itr1);\n                        }\n                        for(auto j:blues[x.second])\n                        {\n                            visit.push({'b',j});//blue='b'\n                            auto itr1=blues[x.second].find(j);\n                            blues[x.second].erase(itr1);\n                        }\n                    }\n                    else if(x.first=='b')\n                    {\n                        for(auto j:reds[x.second])\n                        {\n                            visit.push({'r',j});//red='r'\n                            auto itr1=reds[x.second].find(j);\n                            reds[x.second].erase(itr1);\n                        }\n                    }\n                    else if(x.first=='r')\n                    {\n                        for(auto j:blues[x.second])\n                        {\n                            visit.push({'b',j});\n                            auto itr1=blues[x.second].find(j);\n                            blues[x.second].erase(itr1);\n                        }\n                    }\n                }\n                if(justbreak)\n                {\n                    break;\n                }\n                steps++;\n            }\n            if(i==ans.size())\n            {\n                ans.push_back(-1);\n            }\n        }\n        return ans;\n    }\n};\n",
        "explanations": "\nThe opening and closing quotation marks of the character 'r' are mismatched causing a compilation error.\n"
    },
    {
        "slug": "sum-of-digits-of-string-after-convert",
        "description": "You are given a string s consisting of lowercase English letters, and an integer k.\nFirst, convert s into an integer by replacing each letter with its position in the alphabet (i.e., replace 'a' with 1, 'b' with 2, ..., 'z' with 26). Then, transform the integer by replacing it with the sum of its digits. Repeat the transform operation k times in total.\nFor example, if s = \"zbax\" and k = 2, then the resulting integer would be 8 by the following operations:\n\nConvert: \"zbax\" \u279d \"(26)(2)(1)(24)\" \u279d \"262124\" \u279d 262124\nTransform #1: 262124 \u279d 2 + 6 + 2 + 1 + 2 + 4\u00a0\u279d 17\nTransform #2: 17 \u279d 1 + 7 \u279d 8\n\nReturn the resulting integer after performing the operations described above.",
        "examples": [
            "Input: s = \"iiii\", k = 1\nOutput: 36\nExplanation: The operations are as follows:\n- Convert: \"iiii\" \u279d \"(9)(9)(9)(9)\" \u279d \"9999\" \u279d 9999\n- Transform #1: 9999 \u279d 9 + 9 + 9 + 9 \u279d 36\nThus the resulting integer is 36.",
            "Input: s = \"leetcode\", k = 2\nOutput: 6\nExplanation: The operations are as follows:\n- Convert: \"leetcode\" \u279d \"(12)(5)(5)(20)(3)(15)(4)(5)\" \u279d \"12552031545\" \u279d 12552031545\n- Transform #1: 12552031545 \u279d 1 + 2 + 5 + 5 + 2 + 0 + 3 + 1 + 5 + 4 + 5 \u279d 33\n- Transform #2: 33 \u279d 3 + 3 \u279d 6\nThus the resulting integer is 6.",
            "Input: s = \"zbax\", k = 2\nOutput: 8"
        ],
        "constraints": "1 <= s.length <= 100\n1 <= k <= 10\ns consists of lowercase English letters.",
        "release_time": 1690867082,
        "oracle_code": "class Solution {\npublic:\n    int sumDigits(int num) {\n        int sum = 0;\n        while(num) {\n            sum += num%10;\n            num /= 10;\n        }\n        return sum;\n    }\n    \n    int getLucky(string s, int k) {\n        int sum = 0 ; \n        for(auto it: s){\n            int value = it - 'a' + 1;\n            if(value>=10){\n                sum+= value%10 + value/10; //since digit is two place only and we need all the digits(_ _)\n            }else\n                sum = sum + value; \n        }\n\n        k--;//since I did the sum once;\n        while(k-- && sum>=10){//furthur trasformations starts here\n            sum = sumDigits(sum);\n        } \n        return sum;\n    }\n};",
        "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. apne ko firstly har ek char se iterate karke unki value nikalni hogi\\n2. value agar double digits me aaya to usko bhi single me tod ke sum me add kar deinge\\n3. since yehi chiz upto k=0 tak karni paregi to ek function bana ke kar leinge aur sum return kara deinge\\nNote: As hamne ek baar wo sum nikal liya hai therefore k--;\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int sumDigits(int num) {\\n        int sum = 0;\\n        while(num) {\\n            sum += num%10;\\n            num /= 10;\\n        }\\n        return sum;\\n    }\\n    \\n    int getLucky(string s, int k) {\\n        int sum = 0 ; \\n        for(auto it: s){\\n            int value = it - \\'a\\' + 1;\\n            if(value>=10){\\n                sum+= value%10 + value/10; //since digit is two place only and we need all the digits(_ _)\\n            }else\\n                sum = sum + value; \\n        }\\n\\n        k--;//since I did the sum once;\\n        while(k-- && sum>=10){//furthur trasformations starts here\\n            sum = sumDigits(sum);\\n        } \\n        return sum;\\n    }\\n};\\n```\\n\\n\\n![upvote.jpg](https://assets.leetcode.com/users/images/0593cc08-ec64-46b3-bb36-81ecef0ce934_1690867154.0542114.jpeg)\\n",
        "level": "easy",
        "buggy_code": "\nclass Solution {\npublic:\n    int sumDigits(int num) {\n        int sum = 0;\n        while(num) {\n            sum += num%10;\n            num /= 10;\n        }\n        return sum;\n    }\n    \n    int getLucky(string s, int k) {\n        int sum = 0 ; \n        for(auto it: s){\n            int value = it - 'a' + 1;\n            if(value>=10){\n                sum+= value%10 + value/10; //since digit is two place only and we need all the digits(_ _)\n            }else\n                sum = sum + \"value\"; \n        }\n\n        k--;//since I did the sum once;\n        while(k-- && sum>=10){//furthur trasformations starts here\n            sum = sumDigits(sum);\n        } \n        return sum;\n    }\n};\n",
        "explanations": "\nTrying to add an integer and a string \"value\" will lead to a compilation error.\n"
    },
    {
        "slug": "shortest-bridge",
        "description": "You are given an n x n binary matrix grid where 1 represents land and 0 represents water.\nAn island is a 4-directionally connected group of 1's not connected to any other 1's. There are exactly two islands in grid.\nYou may change 0's to 1's to connect the two islands to form one island.\nReturn the smallest number of 0's you must flip to connect the two islands.",
        "examples": [
            "Input: grid = [[0,1],[1,0]]\nOutput: 1",
            "Input: grid = [[0,1,0],[0,0,0],[0,0,1]]\nOutput: 2",
            "Input: grid = [[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]]\nOutput: 1"
        ],
        "constraints": "n == grid.length == grid[i].length\n2 <= n <= 100\ngrid[i][j] is either 0 or 1.\nThere are exactly two islands in grid.",
        "release_time": 1684673230,
        "oracle_code": "class Solution {\npublic:\n\nint r[4] = {-1 , 0, 1, 0};\nint c[4] = {0 ,1 , 0 , -1};\n\nvoid dfs(int row ,int col , vector<pair<int,int>> &v,vector<vector<int>>&vis,vector<vector<int>>&grid)\n{\n    int n = vis[0].size();\n    vis[row][col] = 1;\n    v.push_back({row , col});\n    for(int i=0; i<4; i++)\n    {\n        int nrow = row + r[i];\n        int ncol = col + c[i];\n\n        if(nrow>=0 and ncol>=0 and nrow<n and ncol<n and vis[nrow][ncol] == 0 and grid[nrow][ncol] == 1)\n        {\n            dfs(nrow , ncol , v , vis , grid);\n        }\n    }\n\n}\n\n    int shortestBridge(vector<vector<int>>& grid) {\n        \n        vector<pair<int,int>> v;\n        vector<pair<int,int>> v1;\n        vector<pair<int,int>> v2;\n        int n = grid.size();\n        vector<vector<int>> vis(n , vector<int>(n , 0));\n        bool flag = 0;\n        for(int i=0; i<n; i++)\n        {\n            for(int j=0; j<n; j++)\n            {\n                if(grid[i][j] == 1 and vis[i][j] == 0)\n                {\n                    dfs(i , j , v , vis, grid);\n                    if(flag == 0)\n                    {\n                        v1 = v;\n                        flag = 1;\n                        v.clear();\n                    }\n                    else\n                    {\n                        v2 = v;\n                    }\n                }\n            \n            }\n           \n        }\n        //printed just to check the co-ordinates****\n        //for(auto it: v1)\n        //{\n        //    cout<<it.first<<\" \"<<it.second<<endl;\n        //}\n        //for(auto it: v2)\n        //{\n        //    cout<<it.first<<\" \"<<it.second<<endl;\n        //}\n        int ans = 1e9;\n\n\n        for(auto it: v1)\n        {\n            int row1 = it.first;\n            int col1 = it.second;\n\n            for(auto itt: v2)\n            {\n                int row2 = itt.first;\n                int col2 = itt.second;\n\n                int dist = abs(row1 - row2) + abs(col1 - col2);\n                dist--;\n                ans = min(ans , dist);\n            }\n        }\n    \n        return ans;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nsimple push all the co-ordinates of the first and second island in two vectors by using dfs and then just calculate the distance between each point to every other point in both the vectors and since n is very small we will not get tle and this solution is accepted.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n**1.Push all the co-ordinates of the first and second island in two vectors\\n2.then calculate the distance between each point to every point \\n3.take the minimum distance \\n4.return the minimum distance**\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\ncomment time complexity in comments \\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\ncomment space complexity in comments \\n# Code\\n```\\nclass Solution {\\npublic:\\n\\nint r[4] = {-1 , 0, 1, 0};\\nint c[4] = {0 ,1 , 0 , -1};\\n\\nvoid dfs(int row ,int col , vector<pair<int,int>> &v,vector<vector<int>>&vis,vector<vector<int>>&grid)\\n{\\n    int n = vis[0].size();\\n    vis[row][col] = 1;\\n    v.push_back({row , col});\\n    for(int i=0; i<4; i++)\\n    {\\n        int nrow = row + r[i];\\n        int ncol = col + c[i];\\n\\n        if(nrow>=0 and ncol>=0 and nrow<n and ncol<n and vis[nrow][ncol] == 0 and grid[nrow][ncol] == 1)\\n        {\\n            dfs(nrow , ncol , v , vis , grid);\\n        }\\n    }\\n\\n}\\n\\n    int shortestBridge(vector<vector<int>>& grid) {\\n        \\n        vector<pair<int,int>> v;\\n        vector<pair<int,int>> v1;\\n        vector<pair<int,int>> v2;\\n        int n = grid.size();\\n        vector<vector<int>> vis(n , vector<int>(n , 0));\\n        bool flag = 0;\\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=0; j<n; j++)\\n            {\\n                if(grid[i][j] == 1 and vis[i][j] == 0)\\n                {\\n                    dfs(i , j , v , vis, grid);\\n                    if(flag == 0)\\n                    {\\n                        v1 = v;\\n                        flag = 1;\\n                        v.clear();\\n                    }\\n                    else\\n                    {\\n                        v2 = v;\\n                    }\\n                }\\n            \\n            }\\n           \\n        }\\n        //printed just to check the co-ordinates****\\n        //for(auto it: v1)\\n        //{\\n        //    cout<<it.first<<\" \"<<it.second<<endl;\\n        //}\\n        //for(auto it: v2)\\n        //{\\n        //    cout<<it.first<<\" \"<<it.second<<endl;\\n        //}\\n        int ans = 1e9;\\n\\n\\n        for(auto it: v1)\\n        {\\n            int row1 = it.first;\\n            int col1 = it.second;\\n\\n            for(auto itt: v2)\\n            {\\n                int row2 = itt.first;\\n                int col2 = itt.second;\\n\\n                int dist = abs(row1 - row2) + abs(col1 - col2);\\n                dist--;\\n                ans = min(ans , dist);\\n            }\\n        }\\n    \\n        return ans;\\n    }\\n};\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\npublic:\n\nint r[4] = {-1 , 0, 1, 0};\nint c[4] = {0 ,1 , 0 , -1};\n\nvoid dfs(int row ,int col , vector<pair<int,int>> &v,vector<vector<int>>&vis,vector<vector<int>>&grid)\n{\n    int n = vis[0].size();\n    vis[row][col] = 1;\n    v.push_back({row , col});\n    for(int i=0; i<4; i++)\n    {\n        int nrow = row + r[i];\n        int ncol = col + c[i];\n\n        if(nrow>=0 and ncol>=0 and nrow<n and ncol<n and vis[nrow][ncol] == 0 and grid[nrow][ncol] == 1)\n        {\n            dfs(nrow , ncol , v , vis , grid);\n        }\n    }\n\n}\n\n    int shortestBridge(vector<vector<int>>& grid) {\n        \n        vector<pair<int,int>> v;\n        vector<pair<int,int>> v1;\n        vector<pair<int,int>> v2;\n        int n = grid.size();\n        vector<vector<int>> vis(n , vector<int>(n , 0));\n        bool flag = 0;\n        for(int i=0; i<n; i++)\n        {\n            for(int j=0; j<n; j++)\n            {\n                if(grid[i][j] == 1 and vis[i][j] == 0)\n                {\n                    dfs(i , j , v , vis, grid);\n                    if(flag == 0)\n                    {\n                        v1 = v;\n                        flag = 1;\n                        v.clear();\n                    }\n                    else\n                    {\n                        v2 = v;\n                    }\n                }\n            \n            }\n           \n        }\n\n        int ans = 1e9;\n        string output = \"shortest bridge is : \"\n\n        for(auto it: v1)\n        {\n            int row1 = it.first;\n            int col1 = it.second;\n\n            for(auto itt: v2)\n            {\n                int row2 = itt.first;\n                int col2 = itt.second;\n\n                int dist = abs(row1 - row2) + abs(col1 - col2);\n                dist--;\n                ans = min(ans , dist);\n            }\n        }\n    \n        return ans;\n    }\n};\n",
        "explanations": "\nThe string output on line 66 is not terminated with a semicolon, creating a syntax error.\n"
    },
    {
        "slug": "minimum-changes-to-make-alternating-binary-string",
        "description": "You are given a string s consisting only of the characters '0' and '1'. In one operation, you can change any '0' to '1' or vice versa.\nThe string is called alternating if no two adjacent characters are equal. For example, the string \"010\" is alternating, while the string \"0100\" is not.\nReturn the minimum number of operations needed to make s alternating.",
        "examples": [
            "Input: s = \"0100\"\nOutput: 1\nExplanation: If you change the last character to '1', s will be \"0101\", which is alternating.",
            "Input: s = \"10\"\nOutput: 0\nExplanation: s is already alternating.",
            "Input: s = \"1111\"\nOutput: 2\nExplanation: You need two operations to reach \"0101\" or \"1010\"."
        ],
        "constraints": "1 <= s.length <= 104\ns[i] is either '0' or '1'.",
        "release_time": 1674806782,
        "oracle_code": "class Solution {\npublic:\n    int minOperations(string s) {\n        int n=s.size(), ans=0;\n        for(int i=0;i<n;i++)\n        {\n            if(s[i]-'0' != i%2)\n            ans++;\n        }\n        return min(ans, n-ans);\n    }\n};",
        "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(string s) {\\n        int n=s.size(), ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]-\\'0\\' != i%2)\\n            ans++;\\n        }\\n        return min(ans, n-ans);\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
        "level": "easy",
        "buggy_code": "\nclass Solution {\npublic:\n    int minOperations(string s) {\n        int n=s.size(), ans=0;\n        for(int i=0;i<n;i++)\n        {\n            if(s[i]-'0' != i%\"2)\n            ans++;\n        }\n        return min(ans, n-ans);\n    }\n};\n",
        "explanations": "\nMisplaced quotation mark in the if condition creates an unclosed string, causing a compilation error.\n"
    },
    {
        "slug": "find-the-punishment-number-of-an-integer",
        "description": "Given a positive integer n, return the punishment number of n.\nThe punishment number of n is defined as the sum of the squares of all integers i such that:\n\n1 <= i <= n\nThe decimal representation of i * i can be partitioned into contiguous substrings such that the sum of the integer values of these substrings equals i.",
        "examples": [
            "Input: n = 10\nOutput: 182\nExplanation: There are exactly 3 integers i that satisfy the conditions in the statement:\n- 1 since 1 * 1 = 1\n- 9 since 9 * 9 = 81 and 81 can be partitioned into 8 + 1.\n- 10 since 10 * 10 = 100 and 100 can be partitioned into 10 + 0.\nHence, the punishment number of 10 is 1 + 81 + 100 = 182",
            "Input: n = 37\nOutput: 1478\nExplanation: There are exactly 4 integers i that satisfy the conditions in the statement:\n- 1 since 1 * 1 = 1. \n- 9 since 9 * 9 = 81 and 81 can be partitioned into 8 + 1. \n- 10 since 10 * 10 = 100 and 100 can be partitioned into 10 + 0. \n- 36 since 36 * 36 = 1296 and 1296 can be partitioned into 1 + 29 + 6.\nHence, the punishment number of 37 is 1 + 81 + 100 + 1296 = 1478"
        ],
        "constraints": "1 <= n <= 1000",
        "release_time": 1684675860,
        "oracle_code": "class Solution {\npublic:\n    \n    bool valid(int n, string s,int sum){\n        // empty string indicates we have completed one partition\n        if(s==\"\") if(sum==n) return true;\n\n        // We use backtracking to check for all partitions if it is possible to generate required sum \n        // and if we find sum we immediately return true immediately\n        for(int i=1;i<=s.size();i++){\n            int x  = stoi(s.substr(0,i));\n            if(valid(n, s.substr(i), sum+x)) return true;\n        }\n        \n        //If no partition could add up to required sum n\n        return false;\n    }\n    int punishmentNumber(int n) {\n        int ans = 0;\n\n        //generate all possible squares and check them if they satisfy the given statement\n        for(int i=1;i<=n;i++){\n            int sq = i*i;\n            string x = to_string(sq);\n            if(valid(i,x,0)) ans += i*i;\n        }\n        \n        return ans;\n        \n    }\n};",
        "content": "# Intuition\\nThe main idea of this problem is to generate all non empty partitions of a string using Backtracking.\\n\\nFor example let\\'s  say i = 36, it\\'s square = 36*36 = 1296\\nTo check if some partition of 1296 satisfy given statement, we make all partitions e.g\\n[1,2,9,6], [1,29,6], [1,296], [12,9,6] , [12,96], [129,6]\\n\\nAmong these only [1,29,6] satisfies the constraint.\\n\\nWe only need one of these set to satisfy the statement, hence we break immediately if we find any valid set.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n* Generate all possible squares and check if they satisfy the given statement\\n* To check if a square satisfies the given constraint or not generate all possible partitions using backtracking.\\n* If any single partition satisfy the statement then this square will be added to solution\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity :  O(n*(2^6)), here 6 is the maxm square length that is len(1000*1000) = 6\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    bool valid(int n, string s,int sum){\\n        // empty string indicates we have completed one partition\\n        if(s==\"\") if(sum==n) return true;\\n\\n        // We use backtracking to check for all partitions if it is possible to generate required sum \\n        // and if we find sum we immediately return true immediately\\n        for(int i=1;i<=s.size();i++){\\n            int x  = stoi(s.substr(0,i));\\n            if(valid(n, s.substr(i), sum+x)) return true;\\n        }\\n        \\n        //If no partition could add up to required sum n\\n        return false;\\n    }\\n    int punishmentNumber(int n) {\\n        int ans = 0;\\n\\n        //generate all possible squares and check them if they satisfy the given statement\\n        for(int i=1;i<=n;i++){\\n            int sq = i*i;\\n            string x = to_string(sq);\\n            if(valid(i,x,0)) ans += i*i;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\npublic:\n    \n    bool valid(int n, string s,int sum){\n        // empty string indicates we have completed one partition\n        if(s==\"\") if(sum==n) return true;\n\n        // We use backtracking to check for all partitions if it is possible to generate required sum \n        // and if we find sum we immediately return true immediately\n        string unclosedString = \"This is an unclosed string;\n        for(int i=1;i<=s.size();i++){\n            int x  = stoi(s.substr(0,i));\n            if(valid(n, s.substr(i), sum+x)) return true;\n        }\n        \n        //If no partition could add up to required sum n\n        return false;\n    }\n    int punishmentNumber(int n) {\n        int ans = 0;\n\n        //generate all possible squares and check them if they satisfy the given statement\n        for(int i=1;i<=n;i++){\n            int sq = i*i;\n            string x = to_string(sq);\n            if(valid(i,x,0)) ans += i*i;\n        }\n        \n        return ans;\n        \n    }\n};\n",
        "explanations": "\nThe string \"This is an unclosed string\" fails to have a closing quote, making it an unclosed string bug.\n"
    },
    {
        "slug": "longest-ideal-subsequence",
        "description": "You are given a string s consisting of lowercase letters and an integer k. We call a string t ideal if the following conditions are satisfied:\n\nt is a subsequence of the string s.\nThe absolute difference in the alphabet order of every two adjacent letters in t is less than or equal to k.\n\nReturn the length of the longest ideal string.\nA subsequence is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.\nNote that the alphabet order is not cyclic. For example, the absolute difference in the alphabet order of 'a' and 'z' is 25, not 1.",
        "examples": [
            "Input: s = \"acfgbd\", k = 2\nOutput: 4\nExplanation: The longest ideal string is \"acbd\". The length of this string is 4, so 4 is returned.\nNote that \"acfgbd\" is not ideal because 'c' and 'f' have a difference of 3 in alphabet order.",
            "Input: s = \"abcd\", k = 3\nOutput: 4\nExplanation: The longest ideal string is \"abcd\". The length of this string is 4, so 4 is returned."
        ],
        "constraints": "1 <= s.length <= 105\n0 <= k <= 25\ns consists of lowercase English letters.",
        "release_time": 1665172616,
        "oracle_code": "class Solution {\n\n\n   int SolveByMemo(string &s , int &k , int index , int prev , vector<vector<int>> &dp)\n   {\n       if(index == s.length())\n       return 0;\n\n       if(dp[index][prev] != -1)\n       return dp[index][prev];\n\n       int op1 = 0 + SolveByMemo(s, k , index+1 , prev , dp);\n\n       int op2 = 0 ;\n\n       if(prev == 26)\n       op2 = 1 + SolveByMemo(s, k , index+1 , s[index]-'a' , dp);\n       else if(abs(s[index]-'a' - prev) <= k)\n       op2 = 1 + SolveByMemo(s, k , index+1 , s[index]-'a' , dp);\n\n       return dp[index][prev] = max(op1 , op2);\n   }\n\n   int SolveByTab(string &s , int &k )\n   {\n        vector<vector<int>> dp(s.length()+1 , vector<int> (27, 0));\n       \n        for(int index = s.length()-1 ; index>=0 ; index--)\n        {\n            for(int prev = 0 ; prev<= 26 ; prev++)\n            {\n                int op1 = 0 + dp[index+1][prev];\n                int op2 = 0 ;\n\n               if(prev == 26)\n               op2 = 1 + dp[index+1][s[index]-'a'];\n               else if(abs(s[index]-'a' - prev) <= k)\n               op2 = 1 + dp[index+1][s[index]-'a'];\n\n               dp[index][prev] = max(op1 , op2);\n            }\n        }\n\n       return max(dp[0][s[0]-'a'] , dp[0][26]);\n   }\n\n   int SolveByTabSpaceOptimised(string &s , int &k )\n   {\n        vector<int> next(27, 0) ;\n        vector<int> curr(27, 0);\n       \n        for(int index = s.length()-1 ; index>=0 ; index--)\n        {\n            for(int prev = 0 ; prev<= 26 ; prev++)\n            {\n                int op1 = 0 + next[prev];\n                int op2 = 0 ;\n\n               if(prev == 26)\n               op2 = 1 + next[s[index]-'a'];\n               else if(abs(s[index]-'a' - prev) <= k)\n               op2 = 1 + next[s[index]-'a'];\n\n               curr[prev] = max(op1 , op2);\n            }\n            next = curr;\n        }\n\n       return max(curr[s[0]-'a'] , curr[26]);\n   }\n\npublic:\n    int longestIdealString(string s, int k) {\n        \n        // 1. Recursion + Memoization || Top Down Approach\n        // vector<vector<int>> dp(s.length() , vector<int> (27, -1));\n        // return SolveByMemo(s, k , 0 , 26, dp);\n\n        // 2. Tabulation Method || Bottom Up Approach\n        // return SolveByTab(s, k);\n\n        // 3. Space Optimisation using Tabulation\n        return SolveByTabSpaceOptimised(s , k);\n    }\n};",
        "content": "\\n# Approach\\nWe Have Use Three Different Approaches :\\n1. Recursion + Memoization \\n    TC : O(n^2) , SC : O(n)\\n2. Tabulation Method \\n    TC : O(n^2) , SC : O(n)\\n3.  Tabulatuon With SOace Optimised\\n    TC : O(n^2) , SC : O(1) \\n\\n\\n#Note\\nSC In first two methods is On) and not O(n^2) as size is fixed to 27 for each index hence it is Linear Space ,Similarly for 3rd Method we have optimised to constant space as at any instant we onlt need memory of next 27 blocks  only.\\n\\n#Hope You Liekd It and Upvote are appreciated \\n\\n# Code\\n```\\nclass Solution {\\n\\n\\n   int SolveByMemo(string &s , int &k , int index , int prev , vector<vector<int>> &dp)\\n   {\\n       if(index == s.length())\\n       return 0;\\n\\n       if(dp[index][prev] != -1)\\n       return dp[index][prev];\\n\\n       int op1 = 0 + SolveByMemo(s, k , index+1 , prev , dp);\\n\\n       int op2 = 0 ;\\n\\n       if(prev == 26)\\n       op2 = 1 + SolveByMemo(s, k , index+1 , s[index]-\\'a\\' , dp);\\n       else if(abs(s[index]-\\'a\\' - prev) <= k)\\n       op2 = 1 + SolveByMemo(s, k , index+1 , s[index]-\\'a\\' , dp);\\n\\n       return dp[index][prev] = max(op1 , op2);\\n   }\\n\\n   int SolveByTab(string &s , int &k )\\n   {\\n        vector<vector<int>> dp(s.length()+1 , vector<int> (27, 0));\\n       \\n        for(int index = s.length()-1 ; index>=0 ; index--)\\n        {\\n            for(int prev = 0 ; prev<= 26 ; prev++)\\n            {\\n                int op1 = 0 + dp[index+1][prev];\\n                int op2 = 0 ;\\n\\n               if(prev == 26)\\n               op2 = 1 + dp[index+1][s[index]-\\'a\\'];\\n               else if(abs(s[index]-\\'a\\' - prev) <= k)\\n               op2 = 1 + dp[index+1][s[index]-\\'a\\'];\\n\\n               dp[index][prev] = max(op1 , op2);\\n            }\\n        }\\n\\n       return max(dp[0][s[0]-\\'a\\'] , dp[0][26]);\\n   }\\n\\n   int SolveByTabSpaceOptimised(string &s , int &k )\\n   {\\n        vector<int> next(27, 0) ;\\n        vector<int> curr(27, 0);\\n       \\n        for(int index = s.length()-1 ; index>=0 ; index--)\\n        {\\n            for(int prev = 0 ; prev<= 26 ; prev++)\\n            {\\n                int op1 = 0 + next[prev];\\n                int op2 = 0 ;\\n\\n               if(prev == 26)\\n               op2 = 1 + next[s[index]-\\'a\\'];\\n               else if(abs(s[index]-\\'a\\' - prev) <= k)\\n               op2 = 1 + next[s[index]-\\'a\\'];\\n\\n               curr[prev] = max(op1 , op2);\\n            }\\n            next = curr;\\n        }\\n\\n       return max(curr[s[0]-\\'a\\'] , curr[26]);\\n   }\\n\\npublic:\\n    int longestIdealString(string s, int k) {\\n        \\n        // 1. Recursion + Memoization || Top Down Approach\\n        // vector<vector<int>> dp(s.length() , vector<int> (27, -1));\\n        // return SolveByMemo(s, k , 0 , 26, dp);\\n\\n        // 2. Tabulation Method || Bottom Up Approach\\n        // return SolveByTab(s, k);\\n\\n        // 3. Space Optimisation using Tabulation\\n        return SolveByTabSpaceOptimised(s , k);\\n    }\\n};\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\n\n\n   int SolveByMemo(string &s , int &k , int index , int prev , vector<vector<int>> &dp)\n   {\n       if(index == s.length())\n       return 0;\n\n       if(dp[index][prev] != -1)\n       return dp[index][prev];\n\n       int op1 = 0 + SolveByMemo(s, k , index+1 , prev , dp);\n\n       int op2 = 0 ;\n\n       if(prev == 26)\n       op2 = 1 + SolveByMemo(s, k , index+1 , s[index]-'a' , dp);\n       else if(abs(s[index]-'a' - prev) <= k)\n       op2 = 1 + SolveByMemo(s, k , index+1 , s[index]-'a' , dp);\n\n       return dp[index][prev] = max(op1 , op2);\n   }\n\n   int SolveByTab(string &s , int &k )\n   {\n        vector<vector<int>> dp(s.length()+1 , vector<int> (27, 0));\n       \n        for(int index = s.length()-1 ; index>=0 ; index--)\n        {\n            for(int prev = 0 ; prev<= 26 ; prev++)\n            {\n                int op1 = 0 + dp[index+1][prev];\n                int op2 = 0 ;\n\n               if(prev == 26)\n               op2 = 1 + dp[index+1][s[index]-'a'];\n               else if(abs(s[index]-'a' - prev) <= k)\n               op2 = 1 + dp[index+1][s[index]-'a'];\n\n               dp[index][prev] = max(op1 , op2);\n            }\n        }\n\n       return max(dp[0][s[0]-'a' , dp[0][26]);\n   }\n\n   int SolveByTabSpaceOptimised(string &s , int &k )\n   {\n        vector<int> next(27, 0) ;\n        vector<int> curr(27, 0);\n       \n        for(int index = s.length()-1 ; index>=0 ; index--)\n        {\n            for(int prev = 0 ; prev<= 26 ; prev++)\n            {\n                int op1 = 0 + next[prev];\n                int op2 = 0 ;\n\n               if(prev == 26)\n               op2 = 1 + next[s[index]-'a'];\n               else if(abs(s[index]-'a' - prev) <= k)\n               op2 = 1 + next[s[index]-'a'];\n\n               curr[prev] = max(op1 , op2);\n            }\n            next = curr;\n        }\n\n       return max(curr[s[0]-'a' , curr[26]);\n   }\n\npublic:\n    int longestIdealString(string s, int k) {\n        \n        // 1. Recursion + Memoization || Top Down Approach\n        // vector<vector<int>> dp(s.length() , vector<int> (27, -1));\n        // return SolveByMemo(s, k , 0 , 26, dp);\n\n        // 2. Tabulation Method || Bottom Up Approach\n        // return SolveByTab(s, k);\n\n        // 3. Space Optimisation using Tabulation\n        return SolveByTabSpaceOptimised(s , k);\n    }\n};\n",
        "explanations": "\nThe terminating quotes of the string in the return statement of 'SolveByTab' and 'SolveByTabSpaceOptimised' are missing.\n"
    },
    {
        "slug": "reverse-odd-levels-of-binary-tree",
        "description": "Given the root of a perfect binary tree, reverse the node values at each odd level of the tree.\n\nFor example, suppose the node values at level 3 are [2,1,3,4,7,11,29,18], then it should become [18,29,11,7,4,3,1,2].\n\nReturn the root of the reversed tree.\nA binary tree is perfect if all parent nodes have two children and all leaves are on the same level.\nThe level of a node is the number of edges along the path between it and the root node.",
        "examples": [
            "Input: root = [2,3,5,8,13,21,34]\nOutput: [2,5,3,8,13,21,34]\nExplanation: \nThe tree has only one odd level.\nThe nodes at level 1 are 3, 5 respectively, which are reversed and become 5, 3.",
            "Input: root = [7,13,11]\nOutput: [7,11,13]\nExplanation: \nThe nodes at level 1 are 13, 11, which are reversed and become 11, 13.",
            "Input: root = [0,1,2,0,0,0,0,1,1,1,1,2,2,2,2]\nOutput: [0,2,1,0,0,0,0,2,2,2,2,1,1,1,1]\nExplanation: \nThe odd levels have non-zero values.\nThe nodes at level 1 were 1, 2, and are 2, 1 after the reversal.\nThe nodes at level 3 were 1, 1, 1, 1, 2, 2, 2, 2, and are 2, 2, 2, 2, 1, 1, 1, 1 after the reversal."
        ],
        "constraints": "The number of nodes in the tree is in the range [1, 214].\n0 <= Node.val <= 105\nroot is a perfect binary tree.",
        "release_time": 1665040875,
        "oracle_code": "class Solution {\npublic:\n    TreeNode* reverseOddLevels(TreeNode* root) {\n        queue<TreeNode*> q;\n        q.push(root);\n        int x = 1,n,i,z;\n        vector<TreeNode*> tmp;\n        TreeNode* node;\n        while(!q.empty()){\n            tmp.clear();\n            n = q.size();\n            // cout<<n<<\" \";\n            while(n--){\n                node = q.front();q.pop();\n                // cout<<node->val<<\" \";\n                if(x==0){\n                    tmp.push_back(node);\n                }\n                if(node->left)\n                    q.push(node->left);\n                if(node->right){\n                    q.push(node->right);\n                }\n            }\n            n = tmp.size();\n            for(i = 0; i < n/2; i++){\n                z = tmp[i]->val;\n                tmp[i]->val = tmp[n-1-i]->val;\n                tmp[n-1-i]->val = z;\n            }\n            x ^= 1;\n            n = 0;\n        }\n        return root;\n    }\n};",
        "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* reverseOddLevels(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        int x = 1,n,i,z;\\n        vector<TreeNode*> tmp;\\n        TreeNode* node;\\n        while(!q.empty()){\\n            tmp.clear();\\n            n = q.size();\\n            // cout<<n<<\" \";\\n            while(n--){\\n                node = q.front();q.pop();\\n                // cout<<node->val<<\" \";\\n                if(x==0){\\n                    tmp.push_back(node);\\n                }\\n                if(node->left)\\n                    q.push(node->left);\\n                if(node->right){\\n                    q.push(node->right);\\n                }\\n            }\\n            n = tmp.size();\\n            for(i = 0; i < n/2; i++){\\n                z = tmp[i]->val;\\n                tmp[i]->val = tmp[n-1-i]->val;\\n                tmp[n-1-i]->val = z;\\n            }\\n            x ^= 1;\\n            n = 0;\\n        }\\n        return root;\\n    }\\n};\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\npublic:\n    TreeNode* reverseOddLevels(TreeNode* root) {\n        queue<TreeNode*> q;\n        q.push(root);\n        int x = 1,n,i,z;\n        vector<TreeNode*> tmp;\n        TreeNode* node;\n        while(!q.empty()){\n            tmp.clear();\n            n = q.size();\n            // cout<<n<<\" \";\n            while(n--){\n                node = q.front();q.pop();\n                // cout<<node->val<<\" \";\n                if(x==0){\n                    tmp.push_back(node);\n                }\n                if(node->left)\n                    q.push(node->left);\n                if(node->right){\n                    q.push(node->right);\n                }\n            }\n            n = tmp.size();\n            for(i = 0; i < n/2; i++){\n                z = tmp[i]->val;\n                tmp[i]->val = tmp[n-1-i]->val;\n                tmp[n-1-i]->val = \"z;\n            }\n            x ^= 1;\n            n = 0;\n        }\n        return root;\n    }\n};\n",
        "explanations": "\nThe string \"z; is unclosed which leads to a compilation error.\n"
    }
]