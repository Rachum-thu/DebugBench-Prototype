[
    {
        "slug": "fibonacci-number",
        "description": "The Fibonacci numbers, commonly denoted F(n) form a sequence, called the Fibonacci sequence, such that each number is the sum of the two preceding ones, starting from 0 and 1. That is,\n\nF(0) = 0, F(1) = 1\nF(n) = F(n - 1) + F(n - 2), for n > 1.\n\nGiven n, calculate F(n).",
        "examples": [
            "Input: n = 2\nOutput: 1\nExplanation: F(2) = F(1) + F(0) = 1 + 0 = 1.",
            "Input: n = 3\nOutput: 2\nExplanation: F(3) = F(2) + F(1) = 1 + 1 = 2.",
            "Input: n = 4\nOutput: 3\nExplanation: F(4) = F(3) + F(2) = 2 + 1 = 3."
        ],
        "constraints": "0 <= n <= 30",
        "release_time": 1685093345,
        "oracle_code": "class Solution {\n    int dp[33];\npublic:\n    int fibon(int n) {\n        cout<<n<<endl;\n        if(n==1)return 1;\n        if(n<=0)return 0;\n\n        int& ans = dp[n];\n        if(ans!=-1)return ans;\n\n        return ans = fibon(n-1) + fibon(n-2);\n    }\n\n    int fib(int n){\n        for(int i = 0 ; i < 33 ; i++)dp[i]=-1;\n        int ans = fibon(n);\n        cout<<ans<<endl;\n        return ans;\n    }\n};",
        "content": "# Approach\\nAs we know that many of the states are repeated in fibonacci series while using recursion, so we have to use DP for storing the states and using these precalculated states, so to use these states if encountered again.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$, as one state is exexuted only once.\\n\\n- Space complexity:\\n$$O(n)$$, as we are using array for storing states\\n\\n# Code\\n```\\nclass Solution {\\n    int dp[33];\\npublic:\\n    int fibon(int n) {\\n        cout<<n<<endl;\\n        if(n==1)return 1;\\n        if(n<=0)return 0;\\n\\n        int& ans = dp[n];\\n        if(ans!=-1)return ans;\\n\\n        return ans = fibon(n-1) + fibon(n-2);\\n    }\\n\\n    int fib(int n){\\n        for(int i = 0 ; i < 33 ; i++)dp[i]=-1;\\n        int ans = fibon(n);\\n        cout<<ans<<endl;\\n        return ans;\\n    }\\n};\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\n    int dp[33];\npublic:\n    int fibon(int n) {\n        cout<<n<<endl;\n        if(n==1)return 1;\n        if(n<=0)return 0;\n\n        int& ans = dp[n];\n        if(ans!=-1)return ans;\n\n        return ans = fibon(n-1) + fibon(n+2);\n    }\n\n    int fib(int n){\n        for(int i = 0 ; i < 33 ; i++)dp[i]=-1;\n        int ans = fibon(n);\n        cout<<ans<<endl;\n        return ans;\n    }\n};\n",
        "explanations": "\nThe recursive function fibon(n) incorrectly calls fibon(n+2), which will lead to unexpected behavior.\n"
    },
    {
        "slug": "shortest-subarray-to-be-removed-to-make-array-sorted",
        "description": "Given an integer array arr, remove a subarray (can be empty) from arr such that the remaining elements in arr are non-decreasing.\nReturn the length of the shortest subarray to remove.\nA subarray is a contiguous subsequence of the array.",
        "examples": [
            "Input: arr = [1,2,3,10,4,2,3,5]\nOutput: 3\nExplanation: The shortest subarray we can remove is [10,4,2] of length 3. The remaining elements after that will be [1,2,3,3,5] which are sorted.\nAnother correct solution is to remove the subarray [3,10,4].",
            "Input: arr = [5,4,3,2,1]\nOutput: 4\nExplanation: Since the array is strictly decreasing, we can only keep a single element. Therefore we need to remove a subarray of length 4, either [5,4,3,2] or [4,3,2,1].",
            "Input: arr = [1,2,3]\nOutput: 0\nExplanation: The array is already non-decreasing. We do not need to remove any elements."
        ],
        "constraints": "1 <= arr.length <= 105\n0 <= arr[i] <= 109",
        "release_time": 1678913689,
        "oracle_code": "class Solution {\npublic:\n    int findLengthOfShortestSubarray(vector<int>& arr) {\n\n        int n =(int) arr.size();\n        int h = n-1 , l=0 ;\n        \n        \n        \n        for(int i=h;i>=1;i--)  \n        {\n            if(arr[i]>=arr[i-1] && h>0)\n            {\n                h--;\n            }\n            else break;\n        }\n\n        int res=h;\n\n       for( l=0 ; l<h && (l==0 || arr[l-1]<=arr[l])  ;l++)\n       {\n             \n             while(h<n && arr[l]>arr[h])\n              {\n                 h++;\n              }\n\n\n           res = min(res,h-l-1);\n\n        \n           \n       }\n      return res;\n\n        \n        \n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    int findLengthOfShortestSubarray(vector<int>& arr) {\\n\\n        int n =(int) arr.size();\\n        int h = n-1 , l=0 ;\\n        \\n        \\n        \\n        for(int i=h;i>=1;i--)  \\n        {\\n            if(arr[i]>=arr[i-1] && h>0)\\n            {\\n                h--;\\n            }\\n            else break;\\n        }\\n\\n        int res=h;\\n\\n       for( l=0 ; l<h && (l==0 || arr[l-1]<=arr[l])  ;l++)\\n       {\\n             \\n             while(h<n && arr[l]>arr[h])\\n              {\\n                 h++;\\n              }\\n\\n\\n           res = min(res,h-l-1);\\n\\n        \\n           \\n       }\\n      return res;\\n\\n        \\n        \\n    }\\n};\\n```\\n\\n```\\n\\n\\nclass Solution {\\npublic:\\n\\n    bool checker(vector<int> &arr,vector<int> &pref ,vector<int> &suff , int lo,int mid)\\n    {\\n        int n= (int)arr.size();\\n        bool ff =true;\\n        int hi = lo+mid-1;\\n        if(lo-1>=0 && pref[lo-1]==0) return false;\\n        if(hi+1<n && suff[hi+1]==0) return false;\\n        if(lo-1>=0 && hi+1<n && arr[lo-1]>arr[hi+1] ) return false;\\n        return true;\\n    }\\n    int findLengthOfShortestSubarray(vector<int>& arr) {\\n    \\n       int n = (int)arr.size();\\n       int ans=n;\\n       vector<int> pref(n,0),suff(n,0);\\n       pref[0]=1,suff[n-1]=1;\\n       for(int i=1;i<n;i++)\\n       {\\n           if(arr[i]>=arr[i-1] && pref[i-1]==1) pref[i]=1;\\n       }\\n\\n       for(int i=n-2;i>=0;i--)\\n       {\\n           if(arr[i]<=arr[i+1] && suff[i+1]==1) suff[i]=1;\\n       }\\n\\n       for(int i=0;i<n;i++)\\n       {\\n           int lo=0,hi=n;\\n           while(lo<=hi)\\n           {\\n               int mid = (lo+hi)/2;\\n               if(checker(arr,pref,suff,i,mid))\\n               {\\n                   ans = min(ans,mid);\\n                   hi =mid-1;\\n               }\\n               else lo = mid+1;\\n           }\\n       }\\n\\n       return ans;\\n    }\\n};\\n```\\n![4of9h0.jpg](https://assets.leetcode.com/users/images/d5a48e00-497f-4da5-b25d-ca6650410462_1678915207.8747983.jpeg)\\n\\n\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\npublic:\n    int findLengthOfShortestSubarray(vector<int>& arr) {\n\n        int n =(int) arr.size();\n        int h = n-1 , l=0 ;\n        \n        for(int i=h;i>=1;i--)  \n        {\n            if(arr[i]>=arr[i-1] && h>0)\n            {\n                h--;\n            }\n            else break;\n        }\n\n        int res=h;\n\n       for( l=0 ; l<h && (l==0 || arr[l-1]<=arr[l])  ;l++)\n       {\n             \n             while(h<n && arr[l]>arr[h])\n              {\n                 h++;\n              }\n\n           res = min(res,h);\n\n        \n           \n       }\n      return res;\n      \n    }\n};\n",
        "explanations": "\nChanged 'res = min(res,h-l-1);' to 'res = min(res,h);'. Now it does not calculate proper minimum.\n"
    },
    {
        "slug": "sum-multiples",
        "description": "Given a positive integer n, find the sum of all integers in the range [1, n] inclusive that are divisible by 3, 5, or 7.\nReturn an integer denoting the sum of all numbers in the given range satisfying\u00a0the constraint.",
        "examples": [
            "Input: n = 7\nOutput: 21\nExplanation: Numbers in the range [1, 7] that are divisible by 3, 5, or 7 are 3, 5, 6, 7. The sum of these numbers is 21.",
            "Input: n = 10\nOutput: 40\nExplanation: Numbers in the range [1, 10] that are divisible by 3, 5, or 7 are 3, 5, 6, 7, 9, 10. The sum of these numbers is 40.",
            "Input: n = 9\nOutput: 30\nExplanation: Numbers in the range [1, 9] that are divisible by 3, 5, or 7 are 3, 5, 6, 7, 9. The sum of these numbers is 30."
        ],
        "constraints": "1 <= n <= 103",
        "release_time": 1682768576,
        "oracle_code": "class Solution {\npublic:\n    int sumOfMultiples(int n,int count=0) {\n       \n       \n       for (int i=1;i<=n;i++)\n       {\n         if (i%3==0 || i%5==0 ||i%7==0)\n           count+=i;\n       }\n    return count;\n\n    }\n};",
        "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int sumOfMultiples(int n,int count=0) {\\n       \\n       \\n       for (int i=1;i<=n;i++)\\n       {\\n         if (i%3==0 || i%5==0 ||i%7==0)\\n           count+=i;\\n       }\\n    return count;\\n\\n    }\\n};\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\npublic:\n    int sumOfMultiples(int n,int count=0) {\n\n       for (int i=1;i<=n;i++)\n       {\n         if (i%3==0 || i%5==0 ||i%7==0)\n           count+=i;\n       }\n    return count-1;\n\n    }\n};\n",
        "explanations": "\nThe function is subtracting 1 from the total sum unexpectedly, resulting in incorrect results.\n"
    },
    {
        "slug": "product-of-array-except-self",
        "description": "Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].\nThe product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.\nYou must write an algorithm that runs in\u00a0O(n)\u00a0time and without using the division operation.",
        "examples": [
            "Input: nums = [1,2,3,4]\nOutput: [24,12,8,6]",
            "Input: nums = [-1,1,0,-3,3]\nOutput: [0,0,9,0,0]"
        ],
        "constraints": "2 <= nums.length <= 105\n-30 <= nums[i] <= 30\nThe product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.",
        "release_time": 1691071622,
        "oracle_code": "class Solution {\npublic:\n    vector<int> productExceptSelf(vector<int>& nums) {\n        vector<int>prefVector(nums.size(),1);\n        vector<int>suffVector(nums.size(),1);\n        int prefPro=1;\n        for(int i=0;i<nums.size();i++){\n            prefVector[i]=prefPro;\n            prefPro*=nums[i];\n        }\n        int suffPro=1;\n        for(int i=nums.size()-1;i>=0;i--){\n            suffVector[i]=suffPro;\n            suffPro*=nums[i];\n        }\n        vector<int>ans(nums.size());\n        for(int i=0;i<nums.size();i++){\n            ans[i]=prefVector[i]*suffVector[i];\n        }\n        return ans;\n    }\n};",
        "content": "# Intuition:\\nwe use two different vectors to store the product of all left elements to that element and another vector to store the product of all right values to that value.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        vector<int>prefVector(nums.size(),1);\\n        vector<int>suffVector(nums.size(),1);\\n        int prefPro=1;\\n        for(int i=0;i<nums.size();i++){\\n            prefVector[i]=prefPro;\\n            prefPro*=nums[i];\\n        }\\n        int suffPro=1;\\n        for(int i=nums.size()-1;i>=0;i--){\\n            suffVector[i]=suffPro;\\n            suffPro*=nums[i];\\n        }\\n        vector<int>ans(nums.size());\\n        for(int i=0;i<nums.size();i++){\\n            ans[i]=prefVector[i]*suffVector[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\npublic:\n    vector<int> productExceptSelf(vector<int>& nums) {\n        vector<int>prefVector(nums.size(),1);\n        vector<int>suffVector(nums.size(),1);\n        int prefPro=1;\n        for(int i=0;i<nums.size();i++){\n            prefVector[i]=prefPro;\n            prefPro*=nums[i];\n        }\n        int suffPro=1;\n        for(int i=nums.size()-1;i>=0;i--){\n            suffVector[i]=suffPro;\n            suffPro*=nums[i+1];\n        }\n        vector<int>ans(nums.size());\n        for(int i=0;i<nums.size();i++){\n            ans[i]=prefVector[i]*suffVector[i];\n        }\n        return ans;\n    }\n};\n",
        "explanations": "\nThe bug is in the second loop, suffPro multiplies nums[i+1], potentially accessing invalid memory.\n"
    },
    {
        "slug": "largest-rectangle-in-histogram",
        "description": "Given an array of integers heights representing the histogram's bar height where the width of each bar is 1, return the area of the largest rectangle in the histogram.",
        "examples": [
            "Input: heights = [2,1,5,6,2,3]\nOutput: 10\nExplanation: The above is a histogram where width of each bar is 1.\nThe largest rectangle is shown in the red area, which has an area = 10 units.",
            "Input: heights = [2,4]\nOutput: 4"
        ],
        "constraints": "1 <= heights.length <= 105\n0 <= heights[i] <= 104",
        "release_time": 1691746356,
        "oracle_code": "#include<stack>\n \nclass Solution {\npublic:\n    //function to find the index of next smallerNumber\n    vector<int> nextSmallNumberIndex(vector<int>& v){\n        int n=v.size(),num=0;\n        vector<int> ans(n);\n        stack<int> s;\n        s.push(-1);\n        for(int i=n-1;i>=0;i--){\n            num=v[i];\n            while(s.top()!=-1 && v[s.top()]>=num){\n                s.pop();\n            }\n            ans[i]=s.top();\n            s.push(i);\n        }\n        return ans;\n\n    }\n    //function to find the index of prev smallerNumber\n    vector<int> prevSmallNumberIndex(vector<int>& v){\n        int n=v.size(),num=0;\n        vector<int> ans(n);\n        stack<int> s;\n        s.push(-1);\n        for(int i=0;i<n;i++){\n            num=v[i];\n            while(s.top()!=-1 && v[s.top()]>=num){\n                s.pop();\n            }\n            ans[i]=s.top();\n            s.push(i);\n        }\n        return ans;\n\n    }\n    int largestRectangleArea(vector<int>& heights) {\n        int size=heights.size(),h,l,area=0,curArea;\n        vector<int> next=nextSmallNumberIndex(heights);\n         vector<int> prev=prevSmallNumberIndex(heights);\n         for(int i=0;i<size;i++){\n            h=heights[i];\n            //if index of next smaller number is -1 we change its value to size \n            if(next[i]==-1)next[i]=size;\n            l=next[i]-prev[i]-1;\n            curArea=l*h;\n             area=max(area,curArea);\n\n        }\n        return area;\n        \n    }\n};",
        "content": "\\n\\n# Code\\n```\\n#include<stack>\\n \\nclass Solution {\\npublic:\\n    //function to find the index of next smallerNumber\\n    vector<int> nextSmallNumberIndex(vector<int>& v){\\n        int n=v.size(),num=0;\\n        vector<int> ans(n);\\n        stack<int> s;\\n        s.push(-1);\\n        for(int i=n-1;i>=0;i--){\\n            num=v[i];\\n            while(s.top()!=-1 && v[s.top()]>=num){\\n                s.pop();\\n            }\\n            ans[i]=s.top();\\n            s.push(i);\\n        }\\n        return ans;\\n\\n    }\\n    //function to find the index of prev smallerNumber\\n    vector<int> prevSmallNumberIndex(vector<int>& v){\\n        int n=v.size(),num=0;\\n        vector<int> ans(n);\\n        stack<int> s;\\n        s.push(-1);\\n        for(int i=0;i<n;i++){\\n            num=v[i];\\n            while(s.top()!=-1 && v[s.top()]>=num){\\n                s.pop();\\n            }\\n            ans[i]=s.top();\\n            s.push(i);\\n        }\\n        return ans;\\n\\n    }\\n    int largestRectangleArea(vector<int>& heights) {\\n        int size=heights.size(),h,l,area=0,curArea;\\n        vector<int> next=nextSmallNumberIndex(heights);\\n         vector<int> prev=prevSmallNumberIndex(heights);\\n         for(int i=0;i<size;i++){\\n            h=heights[i];\\n            //if index of next smaller number is -1 we change its value to size \\n            if(next[i]==-1)next[i]=size;\\n            l=next[i]-prev[i]-1;\\n            curArea=l*h;\\n             area=max(area,curArea);\\n\\n        }\\n        return area;\\n        \\n    }\\n};\\n```",
        "level": "hard",
        "buggy_code": "\n#include<stack>\n \nclass Solution {\npublic:\n    //function to find the index of next smallerNumber\n    vector<int> nextSmallNumberIndex(vector<int>& v){\n        int n=v.size(),num=0;\n        vector<int> ans(n);\n        stack<int> s;\n        s.push(-1);\n        for(int i=n-1;i>=0;i--){\n            num=v[i];\n            while(s.top()!=-1 && v[s.top()]>=num){\n                s.pop();\n            }\n            ans[i]=s.top();\n            s.push(i);\n        }\n        return ans;\n\n    }\n    //function to find the index of prev smallerNumber\n    vector<int> prevSmallNumberIndex(vector<int>& v){\n        int n=v.size(),num=0;\n        vector<int> ans(n);\n        stack<int> s;\n        s.push(-1);\n        for(int i=0;i<n;i++){\n            num=v[i];\n            while(s.top()!=-1 && v[s.top()]>=num){\n                s.pop();\n            }\n            ans[i]=s.top();\n            s.push(i);\n        }\n        return ans;\n\n    }\n    int largestRectangleArea(vector<int>& heights) {\n        int size=heights.size(),h,l,area=0,curArea;\n        vector<int> next=nextSmallNumberIndex(heights);\n        vector<int> prev=prevSmallNumberIndex(heights);\n        for(int i=0;i<size;i++){\n            h=heights[i];\n            //if index of next smaller number is -1 we change its value to size \n            if(next[i]==-1)next[i]=size;\n            l=next[i]-prev[i]-1;\n            curArea=l*h;\n            area=max(area,curArea);\n        }\n        return area*2;        \n    }\n};\n",
        "explanations": "\nThe largest area is wrongly multiplied by 2 in the largestRectangleArea function, altering the expected output.\n"
    },
    {
        "slug": "perfect-rectangle",
        "description": "Given an array rectangles where rectangles[i] = [xi, yi, ai, bi] represents an axis-aligned rectangle. The bottom-left point of the rectangle is (xi, yi) and the top-right point of it is (ai, bi).\nReturn true if all the rectangles together form an exact cover of a rectangular region.",
        "examples": [
            "Input: rectangles = [[1,1,3,3],[3,1,4,2],[3,2,4,4],[1,3,2,4],[2,3,3,4]]\nOutput: true\nExplanation: All 5 rectangles together form an exact cover of a rectangular region.",
            "Input: rectangles = [[1,1,2,3],[1,3,2,4],[3,1,4,2],[3,2,4,4]]\nOutput: false\nExplanation: Because there is a gap between the two rectangular regions.",
            "Input: rectangles = [[1,1,3,3],[3,1,4,2],[1,3,2,4],[2,2,4,4]]\nOutput: false\nExplanation: Because two of the rectangles overlap with each other."
        ],
        "constraints": "1 <= rectangles.length <= 2 * 104\nrectangles[i].length == 4\n-105 <= xi, yi, ai, bi <= 105",
        "release_time": 1672756201,
        "oracle_code": "class Solution {\npublic:\n    bool isRectangleCover(vector<vector<int>>& rectangles) {\n        map<pair<int,int>,int>m;\n        for(auto it:rectangles){\n            m[{it[0],it[1]}]++;\n            m[{it[2],it[3]}]++;\n            m[{it[0],it[3]}]--;\n            m[{it[2],it[1]}]--;\n        }\n        int cnt=0;\n        for( auto it=m.begin();it!=m.end();it++){\n            if(abs(it->second)==1){\n                cnt++;\n            }\n            else if(abs(it->second)!=1&&it->second!=0){\n                return false;\n            }\n        }\n        return cnt==4;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust used map to keep the count of edges.\\nIncreasing the count of bottom left and top right vertices.\\nDecreasing the count of bottom right and top left vertices.\\nAt Last We sum all the values of map.\\nIf the value is 4 then return true as four vertices are there, else return false. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCreate a map with key as pair of int and int(pair<int,int>);\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N);\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isRectangleCover(vector<vector<int>>& rectangles) {\\n        map<pair<int,int>,int>m;\\n        for(auto it:rectangles){\\n            m[{it[0],it[1]}]++;\\n            m[{it[2],it[3]}]++;\\n            m[{it[0],it[3]}]--;\\n            m[{it[2],it[1]}]--;\\n        }\\n        int cnt=0;\\n        for( auto it=m.begin();it!=m.end();it++){\\n            if(abs(it->second)==1){\\n                cnt++;\\n            }\\n            else if(abs(it->second)!=1&&it->second!=0){\\n                return false;\\n            }\\n        }\\n        return cnt==4;\\n    }\\n};\\n```",
        "level": "hard",
        "buggy_code": "\nclass Solution {\npublic:\n    bool isRectangleCover(vector<vector<int>>& rectangles) {\n        map<pair<int,int>,int>m;\n        for(auto it:rectangles){\n            m[{it[0],it[1]}]++;\n            m[{it[2],it[3]}]++;\n            m[{it[0],it[3]}]++;\n            m[{it[2],it[1]}]++;\n        }\n        int cnt=0;\n        for( auto it=m.begin();it!=m.end();it++){\n            if(abs(it->second)==1){\n                cnt++;\n            }\n            else if(abs(it->second)!=1&&it->second!=0){\n                return false;\n            }\n        }\n        return cnt==4;\n    }\n};\n",
        "explanations": "\nThe coordinates of the corners are incremented twice, instead of once, causing incorrect checking.\n"
    },
    {
        "slug": "buddy-strings",
        "description": "Given two strings s and goal, return true if you can swap two letters in s so the result is equal to goal, otherwise, return false.\nSwapping letters is defined as taking two indices i and j (0-indexed) such that i != j and swapping the characters at s[i] and s[j].\n\nFor example, swapping at indices 0 and 2 in \"abcd\" results in \"cbad\".",
        "examples": [
            "Input: s = \"ab\", goal = \"ba\"\nOutput: true\nExplanation: You can swap s[0] = 'a' and s[1] = 'b' to get \"ba\", which is equal to goal.",
            "Input: s = \"ab\", goal = \"ab\"\nOutput: false\nExplanation: The only letters you can swap are s[0] = 'a' and s[1] = 'b', which results in \"ba\" != goal.",
            "Input: s = \"aa\", goal = \"aa\"\nOutput: true\nExplanation: You can swap s[0] = 'a' and s[1] = 'a' to get \"aa\", which is equal to goal."
        ],
        "constraints": "1 <= s.length, goal.length <= 2 * 104\ns and goal consist of lowercase letters.",
        "release_time": 1688356386,
        "oracle_code": "class Solution {\npublic:\n    bool buddyStrings(string s, string p) {\n        int n=s.length(), m=p.length();\n        if(n!=m) return false;\n        \n        vector<int> freq(26,0);\n        \n        int first=-1, second=-1;\n        for(int i=0;i<n;i++){\n            if(s[i] != p[i]){\n                if(first==-1){\n                    first=i;\n                }else if(second==-1){\n                    second=i;\n                }else{\n                    return false; // more than 2 mismatching characters\n                }\n            }\n            freq[s[i]-'a']++;\n        }\n        \n\t\t// similar strings\n        if(first == -1 && second == -1){\n            for(int i=0;i<26;i++) if(freq[i] > 1) return true; // can swap similar characters\n            return false; // all characters occur only once\n        }else if(second == -1){\n            return false; // exactly 1 mismatch\n        }\n        \n        return (s[first]==p[second] && s[second]==p[first]); // check similarity on 2 mismatched indexes\n    }\n};",
        "content": "**Connect with me on LinkedIn**: https://www.linkedin.com/in/abhay5349singh/\\n\\n```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string p) {\\n        int n=s.length(), m=p.length();\\n        if(n!=m) return false;\\n        \\n        vector<int> freq(26,0);\\n        \\n        int first=-1, second=-1;\\n        for(int i=0;i<n;i++){\\n            if(s[i] != p[i]){\\n                if(first==-1){\\n                    first=i;\\n                }else if(second==-1){\\n                    second=i;\\n                }else{\\n                    return false; // more than 2 mismatching characters\\n                }\\n            }\\n            freq[s[i]-\\'a\\']++;\\n        }\\n        \\n\\t\\t// similar strings\\n        if(first == -1 && second == -1){\\n            for(int i=0;i<26;i++) if(freq[i] > 1) return true; // can swap similar characters\\n            return false; // all characters occur only once\\n        }else if(second == -1){\\n            return false; // exactly 1 mismatch\\n        }\\n        \\n        return (s[first]==p[second] && s[second]==p[first]); // check similarity on 2 mismatched indexes\\n    }\\n};\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\npublic:\n    bool buddyStrings(string s, string p) {\n        int n=s.length(), m=p.length();\n        if(n!=m) return false;\n        \n        vector<int> freq(26,0);\n        \n        int first=-1, second=-1;\n        for(int i=0;i<n;i++){\n            if(s[i] != p[i]){\n                if(first==-1){\n                    first=i;\n                }else if(second==-1){\n                    second=i;\n                }else{\n                    return false; // more than 2 mismatching characters\n                }\n            }\n            freq[s[i]-'z']++; \n        }\n        \n\t\t// similar strings\n        if(first == -1 && second == -1){\n            for(int i=0;i<26;i++) if(freq[i] > 1) return true; // can swap similar characters\n            return false; // all characters occur only once\n        }else if(second == -1){\n            return false; // exactly 1 mismatch\n        }\n        \n        return (s[first]==p[second] && s[second]==p[first]); // check similarity on 2 mismatched indexes\n    }\n};\n",
        "explanations": "\nThe ASCII subtraction is incorrect, should be 'a' not 'z', leading to incorrect counting.\n"
    },
    {
        "slug": "kth-ancestor-of-a-tree-node",
        "description": "You are given a tree with n nodes numbered from 0 to n - 1 in the form of a parent array parent where parent[i] is the parent of ith node. The root of the tree is node 0. Find the kth ancestor of a given node.\nThe kth ancestor of a tree node is the kth node in the path from that node to the root node.\nImplement the TreeAncestor class:\n\nTreeAncestor(int n, int[] parent) Initializes the object with the number of nodes in the tree and the parent array.\nint getKthAncestor(int node, int k) return the kth ancestor of the given node node. If there is no such ancestor, return -1.",
        "examples": [
            "Input\n[\"TreeAncestor\", \"getKthAncestor\", \"getKthAncestor\", \"getKthAncestor\"]\n[[7, [-1, 0, 0, 1, 1, 2, 2]], [3, 1], [5, 2], [6, 3]]\nOutput\n[null, 1, 0, -1]\n\nExplanation\nTreeAncestor treeAncestor = new TreeAncestor(7, [-1, 0, 0, 1, 1, 2, 2]);\ntreeAncestor.getKthAncestor(3, 1); // returns 1 which is the parent of 3\ntreeAncestor.getKthAncestor(5, 2); // returns 0 which is the grandparent of 5\ntreeAncestor.getKthAncestor(6, 3); // returns -1 because there is no such ancestor"
        ],
        "constraints": "1 <= k <= n <= 5 * 104\nparent.length == n\nparent[0] == -1\n0 <= parent[i] < n for all 0 < i < n\n0 <= node < n\nThere will be at most 5 * 104 queries.",
        "release_time": 1672236479,
        "oracle_code": "class TreeAncestor {\npublic:\n    int n;\n\n    vector<int>belong;\n    vector<int>ind;\n    vector<bool>leaf;\n    vector<vector<int>>path_leaf;\n\n    TreeAncestor(int n, vector<int>& parent) {\n        this->n=n;\n        path_leaf.resize(n);\n        belong.resize(n,-1);\n        ind.resize(n,-1);\n        leaf.resize(n,1);\n\n        for(int i=0;i<n;i++){\n            if(parent[i]!=-1)   \n            leaf[parent[i]]=0;\n        }\n        \n        for(int i=0;i<n;i++){\n            if(!leaf[i]) continue;\n            int curr=i;\n            belong[curr]=curr;\n            while(curr!=-1){\n                curr=parent[curr];\n                path_leaf[i].push_back(curr);\n                if(curr!=-1){\n                    belong[curr]=i;\n                    ind[curr]=path_leaf[i].size()-1;\n                }\n            }\n        }\n\n    }\n    \n    int getKthAncestor(int node, int k) {\n        return path_leaf[belong[node]][min(k+ind[node],(int)path_leaf[belong[node]].size()-1)];\n    }\n};\n\n/**\n * Your TreeAncestor object will be instantiated and called as such:\n * TreeAncestor* obj = new TreeAncestor(n, parent);\n * int param_1 = obj->getKthAncestor(node,k);\n */",
        "content": "\\n# Code\\n```\\nclass TreeAncestor {\\npublic:\\n    int n;\\n\\n    vector<int>belong;\\n    vector<int>ind;\\n    vector<bool>leaf;\\n    vector<vector<int>>path_leaf;\\n\\n    TreeAncestor(int n, vector<int>& parent) {\\n        this->n=n;\\n        path_leaf.resize(n);\\n        belong.resize(n,-1);\\n        ind.resize(n,-1);\\n        leaf.resize(n,1);\\n\\n        for(int i=0;i<n;i++){\\n            if(parent[i]!=-1)   \\n            leaf[parent[i]]=0;\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            if(!leaf[i]) continue;\\n            int curr=i;\\n            belong[curr]=curr;\\n            while(curr!=-1){\\n                curr=parent[curr];\\n                path_leaf[i].push_back(curr);\\n                if(curr!=-1){\\n                    belong[curr]=i;\\n                    ind[curr]=path_leaf[i].size()-1;\\n                }\\n            }\\n        }\\n\\n    }\\n    \\n    int getKthAncestor(int node, int k) {\\n        return path_leaf[belong[node]][min(k+ind[node],(int)path_leaf[belong[node]].size()-1)];\\n    }\\n};\\n\\n/**\\n * Your TreeAncestor object will be instantiated and called as such:\\n * TreeAncestor* obj = new TreeAncestor(n, parent);\\n * int param_1 = obj->getKthAncestor(node,k);\\n */\\n```",
        "level": "hard",
        "buggy_code": "\nclass TreeAncestor {\npublic:\n    int n;\n\n    vector<int>belong;\n    vector<int>ind;\n    vector<bool>leaf;\n    vector<vector<int>>path_leaf;\n\n    TreeAncestor(int n, vector<int>& parent) {\n        this->n=n;\n        path_leaf.resize(n);\n        belong.resize(n,-1);\n        ind.resize(n,-1);\n        leaf.resize(n,1);\n\n        for(int i=0;i<n;i++){\n            if(parent[i]!=-1)   \n            leaf[parent[i]]=0;\n        }\n        \n        for(int i=0;i<n;i++){\n            if(!leaf[i]) continue;\n            int curr=i;\n            belong[curr]=curr;\n            while(curr!=-1){\n                curr=parent[curr];\n                path_leaf[i].push_back(curr);\n                if(curr!=-1){\n                    belong[curr]=i;\n                    ind[curr]=path_leaf[i].size()-1;\n                }\n            }\n        }\n\n    }\n    \n    int getKthAncestor(int node, int k) {\n        return path_leaf[belong[node]][max(k+ind[node],(int)path_leaf[belong[node]].size()-1)];\n    }\n};\n",
        "explanations": "\nIn getKthAncestor, using max instead of min can lead to accessing elements out of vector's range.\n"
    },
    {
        "slug": "find-the-longest-valid-obstacle-course-at-each-position",
        "description": "You want to build some obstacle courses. You are given a 0-indexed integer array obstacles of length n, where obstacles[i] describes the height of the ith obstacle.\nFor every index i between 0 and n - 1 (inclusive), find the length of the longest obstacle course in obstacles such that:\n\nYou choose any number of obstacles between 0 and i inclusive.\nYou must include the ith obstacle in the course.\nYou must put the chosen obstacles in the same order as they appear in obstacles.\nEvery obstacle (except the first) is taller than or the same height as the obstacle immediately before it.\n\nReturn an array ans of length n, where ans[i] is the length of the longest obstacle course for index i as described above.",
        "examples": [
            "Input: obstacles = [1,2,3,2]\nOutput: [1,2,3,3]\nExplanation: The longest valid obstacle course at each position is:\n- i = 0: [1], [1] has length 1.\n- i = 1: [1,2], [1,2] has length 2.\n- i = 2: [1,2,3], [1,2,3] has length 3.\n- i = 3: [1,2,3,2], [1,2,2] has length 3.",
            "Input: obstacles = [2,2,1]\nOutput: [1,2,1]\nExplanation: The longest valid obstacle course at each position is:\n- i = 0: [2], [2] has length 1.\n- i = 1: [2,2], [2,2] has length 2.\n- i = 2: [2,2,1], [1] has length 1.",
            "Input: obstacles = [3,1,5,6,4,2]\nOutput: [1,1,2,3,2,2]\nExplanation: The longest valid obstacle course at each position is:\n- i = 0: [3], [3] has length 1.\n- i = 1: [3,1], [1] has length 1.\n- i = 2: [3,1,5], [3,5] has length 2. [1,5] is also valid.\n- i = 3: [3,1,5,6], [3,5,6] has length 3. [1,5,6] is also valid.\n- i = 4: [3,1,5,6,4], [3,4] has length 2. [1,4] is also valid.\n- i = 5: [3,1,5,6,4,2], [1,2] has length 2."
        ],
        "constraints": "n == obstacles.length\n1 <= n <= 105\n1 <= obstacles[i] <= 107",
        "release_time": 1683425182,
        "oracle_code": "class Solution {\npublic:\n    vector<int> longestObstacleCourseAtEachPosition(vector<int>& nums) {\n        \n        int n = nums.size();\n        \n        // lis store elements of longest increasing subsequence till ith\n        \n        vector<int> lis;\n        \n        // ans[i] store, no of elements satisfying the condition including ith\n        \n        vector<int> ans;\n\n        for(int i = 0; i < n; i++)\n        {\n            int idx = upper_bound(lis.begin(), lis.end(), nums[i]) - lis.begin();\n                \n            ans.push_back(idx + 1);\n            \n            if(idx == lis.size())\n                lis.push_back(nums[i]);\n            \n            else\n            {\n                lis[idx] = nums[i];\n            }\n        }\n        \n        return ans;\n    }\n};",
        "content": "* ***Binary Search***\\n\\n* ***Time Complexity :- O(NlogN)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> longestObstacleCourseAtEachPosition(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        // lis store elements of longest increasing subsequence till ith\\n        \\n        vector<int> lis;\\n        \\n        // ans[i] store, no of elements satisfying the condition including ith\\n        \\n        vector<int> ans;\\n\\n        for(int i = 0; i < n; i++)\\n        {\\n            int idx = upper_bound(lis.begin(), lis.end(), nums[i]) - lis.begin();\\n                \\n            ans.push_back(idx + 1);\\n            \\n            if(idx == lis.size())\\n                lis.push_back(nums[i]);\\n            \\n            else\\n            {\\n                lis[idx] = nums[i];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
        "level": "hard",
        "buggy_code": "\nclass Solution {\npublic:\n    vector<int> longestObstacleCourseAtEachPosition(vector<int>& nums) {\n        \n        int n = nums.size();\n        \n        // lis store elements of longest increasing subsequence till ith\n        \n        vector<int> lis;\n        \n        \n        \n        vector<int> ans;\n\n        for(int i = 0; i < n; i++)\n        {\n            int idx = upper_bound(lis.begin(), lis.end(), nums[i]) - lis.begin();\n                \n            ans.push_back(idx + 2);\n            \n            if(idx == lis.size())\n                lis.push_back(nums[i]);\n            \n            else\n            {\n                lis[idx] = nums[i];\n            }\n        }\n        \n        return ans;\n    }\n};\n",
        "explanations": "\nThe error lies at \"ans.push_back(idx + 2)\". It should push idx + 1 instead.\n"
    },
    {
        "slug": "queries-on-number-of-points-inside-a-circle",
        "description": "You are given an array points where points[i] = [xi, yi] is the coordinates of the ith point on a 2D plane. Multiple points can have the same coordinates.\nYou are also given an array queries where queries[j] = [xj, yj, rj] describes a circle centered at (xj, yj) with a radius of rj.\nFor each query queries[j], compute the number of points inside the jth circle. Points on the border of the circle are considered inside.\nReturn an array answer, where answer[j] is the answer to the jth query.",
        "examples": [
            "Input: points = [[1,3],[3,3],[5,3],[2,2]], queries = [[2,3,1],[4,3,1],[1,1,2]]\nOutput: [3,2,2]\nExplanation: The points and circles are shown above.\nqueries[0] is the green circle, queries[1] is the red circle, and queries[2] is the blue circle.",
            "Input: points = [[1,1],[2,2],[3,3],[4,4],[5,5]], queries = [[1,2,2],[2,2,2],[4,3,2],[4,3,3]]\nOutput: [2,3,2,4]\nExplanation: The points and circles are shown above.\nqueries[0] is green, queries[1] is red, queries[2] is blue, and queries[3] is purple."
        ],
        "constraints": "1 <= points.length <= 500\npoints[i].length == 2\n0 <= x\u200b\u200b\u200b\u200b\u200b\u200bi, y\u200b\u200b\u200b\u200b\u200b\u200bi <= 500\n1 <= queries.length <= 500\nqueries[j].length == 3\n0 <= xj, yj <= 500\n1 <= rj <= 500\nAll coordinates are integers.",
        "release_time": 1670308045,
        "oracle_code": "class Solution {\npublic:\n\n    bool Manhattan(int x1,int x2,int y1,int y2,int r){\n        int dist= pow((x2-x1),2) + pow((y2-y1),2);\n\n        if(dist<=r*r) return true;\n        return false;\n    }\n    vector<int> countPoints(vector<vector<int>>& points, vector<vector<int>>& queries) {\n\n        vector<int> ans;\n\n        for( auto c: queries){\n            int x1=c[0];\n            int y1=c[1];\n            int r=c[2];\n            int temp=0;\n            \n            for(auto i:points){\n                int x2=i[0];\n                int y2=i[1];\n\n                if(Manhattan(x1,x2,y1,y2,r)){\n                    temp++;\n                }\n\n            }\n\n            ans.push_back(temp);\n\n        }\n        return ans;\n\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool Manhattan(int x1,int x2,int y1,int y2,int r){\\n        int dist= pow((x2-x1),2) + pow((y2-y1),2);\\n\\n        if(dist<=r*r) return true;\\n        return false;\\n    }\\n    vector<int> countPoints(vector<vector<int>>& points, vector<vector<int>>& queries) {\\n\\n        vector<int> ans;\\n\\n        for( auto c: queries){\\n            int x1=c[0];\\n            int y1=c[1];\\n            int r=c[2];\\n            int temp=0;\\n            \\n            for(auto i:points){\\n                int x2=i[0];\\n                int y2=i[1];\\n\\n                if(Manhattan(x1,x2,y1,y2,r)){\\n                    temp++;\\n                }\\n\\n            }\\n\\n            ans.push_back(temp);\\n\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\npublic:\n\n    bool Manhattan(int x1,int x2,int y1,int y2,int r){\n        int dist= abs(x2-x1) + abs(y2-y1);\n\n        if(dist<=r*r) return true;\n        return false;\n    }\n    vector<int> countPoints(vector<vector<int>>& points, vector<vector<int>>& queries) {\n\n        vector<int> ans;\n\n        for( auto c: queries){\n            int x1=c[0];\n            int y1=c[1];\n            int r=c[2];\n            int temp=0;\n            \n            for(auto i:points){\n                int x2=i[0];\n                int y2=i[1];\n\n                if(Manhattan(x1,x2,y1,y2,r)){\n                    temp++;\n                }\n\n            }\n\n            ans.push_back(temp);\n\n        }\n        return ans;\n\n    }\n};\n",
        "explanations": "\nUsed Manhattan's distance instead of Euclidean distance in circle point inclusion check.\n"
    },
    {
        "slug": "integer-to-roman",
        "description": "Roman numerals are represented by seven different symbols:\u00a0I, V, X, L, C, D and M.\n\nSymbol       Value\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000\nFor example,\u00a02 is written as II\u00a0in Roman numeral, just two one's added together. 12 is written as\u00a0XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.\nRoman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:\n\nI can be placed before V (5) and X (10) to make 4 and 9.\u00a0\nX can be placed before L (50) and C (100) to make 40 and 90.\u00a0\nC can be placed before D (500) and M (1000) to make 400 and 900.\n\nGiven an integer, convert it to a roman numeral.",
        "examples": [
            "Input: num = 3\nOutput: \"III\"\nExplanation: 3 is represented as 3 ones.",
            "Input: num = 58\nOutput: \"LVIII\"\nExplanation: L = 50, V = 5, III = 3.",
            "Input: num = 1994\nOutput: \"MCMXCIV\"\nExplanation: M = 1000, CM = 900, XC = 90 and IV = 4."
        ],
        "constraints": "1 <= num <= 3999",
        "release_time": 1672226407,
        "oracle_code": "class Solution {\npublic:\n    string intToRoman(int num) {\n        string ones[] = {\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\"};\n        string tens[] = {\"\",\"X\",\"XX\",\"XXX\",\"XL\",\"L\",\"LX\",\"LXX\",\"LXXX\",\"XC\"};\n        string hrns[] = {\"\",\"C\",\"CC\",\"CCC\",\"CD\",\"D\",\"DC\",\"DCC\",\"DCCC\",\"CM\"};\n        string ths[]={\"\",\"M\",\"MM\",\"MMM\"};\n        \n        return ths[num/1000] + hrns[(num%1000)/100] + tens[(num%100)/10] + ones[num%10];\n    }\n};",
        "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ones[] = {\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\"};\\n        string tens[] = {\"\",\"X\",\"XX\",\"XXX\",\"XL\",\"L\",\"LX\",\"LXX\",\"LXXX\",\"XC\"};\\n        string hrns[] = {\"\",\"C\",\"CC\",\"CCC\",\"CD\",\"D\",\"DC\",\"DCC\",\"DCCC\",\"CM\"};\\n        string ths[]={\"\",\"M\",\"MM\",\"MMM\"};\\n        \\n        return ths[num/1000] + hrns[(num%1000)/100] + tens[(num%100)/10] + ones[num%10];\\n    }\\n};\\n```\\n\\n# ***Please Upvote if it helps \\u2764\\uFE0F***",
        "level": "medium",
        "buggy_code": "\nclass Solution {\npublic:\n    string intToRoman(int num) {\n        string ones[] = {\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\"};\n        string tens[] = {\"\",\"X\",\"XX\",\"XXX\",\"XL\",\"L\",\"LX\",\"LXX\",\"LXXX\",\"XC\"};\n        string hrns[] = {\"\",\"C\",\"CC\",\"CCC\",\"CD\",\"D\",\"DC\",\"DCC\",\"DCCC\",\"CM\"};\n        string ths[]={\"\",\"M\",\"MM\",\"MMM\"};\n\n        return ths[num/10000] + hrns[(num%1000)/100] + tens[(num%100)/10] + ones[num%10];\n    }\n};  \n",
        "explanations": "\nThe division in ths[num/10000] is incorrect, which results in an incorrect Roman numeral.\n"
    },
    {
        "slug": "minimum-number-of-swaps-to-make-the-string-balanced",
        "description": "You are given a 0-indexed string s of even length n. The string consists of exactly n / 2 opening brackets '[' and n / 2 closing brackets ']'.\nA string is called balanced if and only if:\n\nIt is the empty string, or\nIt can be written as AB, where both A and B are balanced strings, or\nIt can be written as [C], where C is a balanced string.\n\nYou may swap the brackets at any two indices any number of times.\nReturn the minimum number of swaps to make s balanced.",
        "examples": [
            "Input: s = \"][][\"\nOutput: 1\nExplanation: You can make the string balanced by swapping index 0 with index 3.\nThe resulting string is \"[[]]\".",
            "Input: s = \"]]][[[\"\nOutput: 2\nExplanation: You can do the following to make the string balanced:\n- Swap index 0 with index 4. s = \"[]][][\".\n- Swap index 1 with index 5. s = \"[[][]]\".\nThe resulting string is \"[[][]]\".",
            "Input: s = \"[]\"\nOutput: 0\nExplanation: The string is already balanced."
        ],
        "constraints": "n == s.length\n2 <= n <= 106\nn is even.\ns[i] is either '[' or ']'.\nThe number of opening brackets '[' equals n / 2, and the number of closing brackets ']' equals n / 2.",
        "release_time": 1686170411,
        "oracle_code": "class Solution {\npublic:\n    int minSwaps(string s) {\n        int size=0;\n        for(char &ch:s){\n          if(ch=='[')  size++;\n          else if(size) size--;\n        }\n        return (size+1)/2;\n    }\n};",
        "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSwaps(string s) {\\n        int size=0;\\n        for(char &ch:s){\\n          if(ch==\\'[\\')  size++;\\n          else if(size) size--;\\n        }\\n        return (size+1)/2;\\n    }\\n};\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\npublic:\n    int minSwaps(string s) {\n        int size=0;\n        for(char &ch:s){\n          if(ch=='[')  size++;\n          else if(size) size--;\n        }\n        return (size+2)/2;\n    }\n};\n",
        "explanations": "\nThe logic error added changes the formula for minimum swaps and leads to incorrect results.\n"
    },
    {
        "slug": "number-of-matching-subsequences",
        "description": "Given a string s and an array of strings words, return the number of words[i] that is a subsequence of s.\nA subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.\n\nFor example, \"ace\" is a subsequence of \"abcde\".",
        "examples": [
            "Input: s = \"abcde\", words = [\"a\",\"bb\",\"acd\",\"ace\"]\nOutput: 3\nExplanation: There are three strings in words that are a subsequence of s: \"a\", \"acd\", \"ace\".",
            "Input: s = \"dsahjpjauf\", words = [\"ahjpjau\",\"ja\",\"ahbwzgqnuk\",\"tnmlanowax\"]\nOutput: 2"
        ],
        "constraints": "1 <= s.length <= 5 * 104\n1 <= words.length <= 5000\n1 <= words[i].length <= 50\ns and words[i] consist of only lowercase English letters.",
        "release_time": 1675105253,
        "oracle_code": "class Solution {\npublic:\nmap<char,vector<int>> count;\n    int numMatchingSubseq(string s, vector<string>& words) {\n        for(int i=0;i<s.size();i++){\n            count[s[i]].push_back(i);//add each position of each char\n        }\n        int z=0;\n        for(auto& x:words){\n            int p=-1;//find element greater thn this index\n            int r=0;//flag bit\n            for(int j=0;j<x.size();j++){\n                if(count.find(x[j])==count.end()){r=1;break;}\n                if(upper_bound(count[x[j]].begin(),count[x[j]].end(),p)==count[x[j]].end()){r=1;break;}//if grtr position not found\n                p=count[x[j]][upper_bound(count[x[j]].begin(),count[x[j]].end(),p)-count[x[j]].begin()];//updating search index\n                }\n            if(r==0)z+=1;\n        }\n        return z;\n    }\n};",
        "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\nmap<char,vector<int>> count;\\n    int numMatchingSubseq(string s, vector<string>& words) {\\n        for(int i=0;i<s.size();i++){\\n            count[s[i]].push_back(i);//add each position of each char\\n        }\\n        int z=0;\\n        for(auto& x:words){\\n            int p=-1;//find element greater thn this index\\n            int r=0;//flag bit\\n            for(int j=0;j<x.size();j++){\\n                if(count.find(x[j])==count.end()){r=1;break;}\\n                if(upper_bound(count[x[j]].begin(),count[x[j]].end(),p)==count[x[j]].end()){r=1;break;}//if grtr position not found\\n                p=count[x[j]][upper_bound(count[x[j]].begin(),count[x[j]].end(),p)-count[x[j]].begin()];//updating search index\\n                }\\n            if(r==0)z+=1;\\n        }\\n        return z;\\n    }\\n};\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\npublic:\nmap<char,vector<int>> count;\n    int numMatchingSubseq(string s, vector<string>& words) {\n        for(int i=0;i<s.size();i++){\n            count[s[i]].push_back(i);//add each position of each char\n        }\n        int z=0;\n        for(auto& x:words){\n            int p=-1;//find element greater thn this index\n            int r=0;//flag bit\n            for(int j=0;j<x.size();j++){\n                if(count.find(x[j])==count.end()){r=1;break;}\n                if(upper_bound(count[x[j]].begin(),count[x[j]].end(),p)==count[x[j]].end()){r=1;break;}//if grtr position not found\n                p=upper_bound(count[x[j]].begin(),count[x[j]].end(),p)-count[x[j]].begin();\n                }\n            if(r==0)z+=1;\n        }\n        return z;\n    }\n};\n",
        "explanations": "\nThe bug is at line \"p=upper_bound\". It should update with the position not the index.\n"
    },
    {
        "slug": "smallest-string-starting-from-leaf",
        "description": "You are given the root of a binary tree where each node has a value in the range [0, 25] representing the letters 'a' to 'z'.\nReturn the lexicographically smallest string that starts at a leaf of this tree and ends at the root.\nAs a reminder, any shorter prefix of a string is lexicographically smaller.\n\nFor example, \"ab\" is lexicographically smaller than \"aba\".\n\nA leaf of a node is a node that has no children.",
        "examples": [
            "Input: root = [0,1,2,3,4,3,4]\nOutput: \"dba\"",
            "Input: root = [25,1,3,1,3,0,2]\nOutput: \"adz\"",
            "Input: root = [2,2,1,null,1,0,null,0]\nOutput: \"abc\""
        ],
        "constraints": "The number of nodes in the tree is in the range [1, 8500].\n0 <= Node.val <= 25",
        "release_time": 1689057293,
        "oracle_code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    string BFS(TreeNode* root)\n    {\n        if(!root) return \"\";\n        queue<pair<TreeNode*,string>> q;\n        vector<string> ans;\n        string s = \"\";\n        s+=root->val+97;\n        q.push({root,s});\n        while(!q.empty())\n        {\n            TreeNode* node = q.front().first;\n            string str = q.front().second;\n            q.pop();\n            if(!node->left && !node->right)\n            {\n                reverse(str.begin(),str.end());\n                ans.push_back(str);\n            }\n            if(node->left)\n            {\n                string tmp = str;\n                tmp+=node->left->val+97;\n                q.push({node->left,tmp});\n            }\n            if(node->right)\n            {\n                string tmp = str;\n                tmp+=node->right->val+97;\n                q.push({node->right,tmp});\n            }\n        }\n        sort(ans.begin(),ans.end());\n        return ans[0];\n    }\n    string smallestFromLeaf(TreeNode* root) {\n       return BFS(root);\n    }\n};",
        "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDo the BFS Traversal from  **Root Node** to **Leaf Node** and Store the **Path as a string** and return the **lexicographically smallest** string.\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    string BFS(TreeNode* root)\\n    {\\n        if(!root) return \"\";\\n        queue<pair<TreeNode*,string>> q;\\n        vector<string> ans;\\n        string s = \"\";\\n        s+=root->val+97;\\n        q.push({root,s});\\n        while(!q.empty())\\n        {\\n            TreeNode* node = q.front().first;\\n            string str = q.front().second;\\n            q.pop();\\n            if(!node->left && !node->right)\\n            {\\n                reverse(str.begin(),str.end());\\n                ans.push_back(str);\\n            }\\n            if(node->left)\\n            {\\n                string tmp = str;\\n                tmp+=node->left->val+97;\\n                q.push({node->left,tmp});\\n            }\\n            if(node->right)\\n            {\\n                string tmp = str;\\n                tmp+=node->right->val+97;\\n                q.push({node->right,tmp});\\n            }\\n        }\\n        sort(ans.begin(),ans.end());\\n        return ans[0];\\n    }\\n    string smallestFromLeaf(TreeNode* root) {\\n       return BFS(root);\\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/67c6667a-66b6-4d36-846d-56e86a3b137a_1689057284.4817927.jpeg)\\n",
        "level": "medium",
        "buggy_code": "\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    string BFS(TreeNode* root)\n    {\n        if(!root) return \"\";\n        queue<pair<TreeNode*,string>> q;\n        vector<string> ans;\n        string s = \"\";\n        s+=root->val+96; \n        q.push({root,s});\n        while(!q.empty())\n        {\n            TreeNode* node = q.front().first;\n            string str = q.front().second;\n            q.pop();\n            if(!node->left && !node->right)\n            {\n                reverse(str.begin(),str.end());\n                ans.push_back(str);\n            }\n            if(node->left)\n            {\n                string tmp = str;\n                tmp+=node->left->val+97;\n                q.push({node->left,tmp});\n            }\n            if(node->right)\n            {\n                string tmp = str;\n                tmp+=node->right->val+97;\n                q.push({node->right,tmp});\n            }\n        }\n        sort(ans.begin(),ans.end());\n        return ans[0];\n    }\n    string smallestFromLeaf(TreeNode* root) {\n       return BFS(root);\n    }\n};\n",
        "explanations": "\nThe bug is using 96 instead of 97, causing incorrect ASCII value generation for characters.\n"
    },
    {
        "slug": "mean-of-array-after-removing-some-elements",
        "description": "Given an integer array arr, return the mean of the remaining integers after removing the smallest 5% and the largest 5% of the elements.\nAnswers within 10-5 of the actual answer will be considered accepted.",
        "examples": [
            "Input: arr = [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3]\nOutput: 2.00000\nExplanation: After erasing the minimum and the maximum values of this array, all elements are equal to 2, so the mean is 2.",
            "Input: arr = [6,2,7,5,1,2,0,3,10,2,5,0,5,5,0,8,7,6,8,0]\nOutput: 4.00000",
            "Input: arr = [6,0,7,0,7,5,7,8,3,4,0,7,8,1,6,8,1,1,2,4,8,1,9,5,4,3,8,5,10,8,6,6,1,0,6,10,8,2,3,4]\nOutput: 4.77778"
        ],
        "constraints": "20 <= arr.length <= 1000\narr.length is a multiple of 20.\n0 <= arr[i] <= 105",
        "release_time": 1680188219,
        "oracle_code": "class Solution {\npublic:\n    double trimMean(vector<int>& arr) {\n        int i, k;\n        double mean;\n        sort(arr.begin(), arr.end());\n        k = 0.05*arr.size();\n        for(i=0 ; i<k ; i++)\n        {\n            arr.erase(arr.begin()+0);\n            arr.erase(arr.begin()+arr.size()-1);\n        }\n        mean = (double)accumulate(arr.begin(), arr.end(), 0)/arr.size();\n        return mean;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double trimMean(vector<int>& arr) {\\n        int i, k;\\n        double mean;\\n        sort(arr.begin(), arr.end());\\n        k = 0.05*arr.size();\\n        for(i=0 ; i<k ; i++)\\n        {\\n            arr.erase(arr.begin()+0);\\n            arr.erase(arr.begin()+arr.size()-1);\\n        }\\n        mean = (double)accumulate(arr.begin(), arr.end(), 0)/arr.size();\\n        return mean;\\n    }\\n};\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\npublic:\n    double trimMean(vector<int>& arr) {\n        int i, k;\n        double mean;\n        sort(arr.begin(), arr.end());\n        k = 0.05*arr.size();\n        for(i=0 ; i<k ; i++)\n        {\n            arr.erase(arr.begin()+0);\n            arr.erase(arr.begin()+arr.size());\n        }\n        mean = (double)accumulate(arr.begin(), arr.end(), 0)/arr.size();\n        return mean;\n    }\n};\n",
        "explanations": "\nThe logic is incorrect since the last element index is arr.size()-1, not arr.size(). \n"
    },
    {
        "slug": "the-k-strongest-values-in-an-array",
        "description": "Given an array of integers arr and an integer k.\nA value arr[i] is said to be stronger than a value arr[j] if |arr[i] - m| > |arr[j] - m| where m is the median of the array.\nIf |arr[i] - m| == |arr[j] - m|, then arr[i] is said to be stronger than arr[j] if arr[i] > arr[j].\nReturn a list of the strongest k values in the array. return the answer in any arbitrary order.\nMedian is the middle value in an ordered integer list. More formally, if the length of the list is n, the median is the element in position ((n - 1) / 2) in the sorted list (0-indexed).\n\nFor arr = [6, -3, 7, 2, 11], n = 5 and the median is obtained by sorting the array arr = [-3, 2, 6, 7, 11] and the median is arr[m] where m = ((5 - 1) / 2) = 2. The median is 6.\nFor arr = [-7, 22, 17,\u20093], n = 4 and the median is obtained by sorting the array arr = [-7, 3, 17, 22] and the median is arr[m] where m = ((4 - 1) / 2) = 1. The median is 3.",
        "examples": [
            "Input: arr = [1,2,3,4,5], k = 2\nOutput: [5,1]\nExplanation: Median is 3, the elements of the array sorted by the strongest are [5,1,4,2,3]. The strongest 2 elements are [5, 1]. [1, 5] is also accepted answer.\nPlease note that although |5 - 3| == |1 - 3| but 5 is stronger than 1 because 5 > 1.",
            "Input: arr = [1,1,3,5,5], k = 2\nOutput: [5,5]\nExplanation: Median is 3, the elements of the array sorted by the strongest are [5,5,1,1,3]. The strongest 2 elements are [5, 5].",
            "Input: arr = [6,7,11,7,6,8], k = 5\nOutput: [11,8,6,6,7]\nExplanation: Median is 7, the elements of the array sorted by the strongest are [11,8,6,6,7,7].\nAny permutation of [11,8,6,6,7] is accepted."
        ],
        "constraints": "1 <= arr.length <= 105\n-105 <= arr[i] <= 105\n1 <= k <= arr.length",
        "release_time": 1675661148,
        "oracle_code": "class Solution {\npublic:\n    vector<int> getStrongest(vector<int>& arr, int k) {\n        vector<pair<int,int>>v;\n        int sum=0,n=arr.size();\n        sort(arr.begin(),arr.end());\n        int median=arr[(n-1)/2];\n        for(int i=0;i<arr.size();i++)\n        {\n            v.push_back({abs(arr[i]-median),arr[i]});\n        }\n        sort(v.begin(),v.end());\n        reverse(v.begin(),v.end());\n        vector<int>ans;\n        for(int i=0;i<k;i++)\n        {\n            ans.push_back(v[i].second);\n        }\n        return ans;\n\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(nlogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getStrongest(vector<int>& arr, int k) {\\n        vector<pair<int,int>>v;\\n        int sum=0,n=arr.size();\\n        sort(arr.begin(),arr.end());\\n        int median=arr[(n-1)/2];\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            v.push_back({abs(arr[i]-median),arr[i]});\\n        }\\n        sort(v.begin(),v.end());\\n        reverse(v.begin(),v.end());\\n        vector<int>ans;\\n        for(int i=0;i<k;i++)\\n        {\\n            ans.push_back(v[i].second);\\n        }\\n        return ans;\\n\\n    }\\n};\\n```\\n\\n![upvote.jpg](https://assets.leetcode.com/users/images/ac5baf5d-2804-447b-b09e-5ff966529a4b_1675661178.3177938.jpeg)\\n\\n",
        "level": "medium",
        "buggy_code": "\nclass Solution {\npublic:\n    vector<int> getStrongest(vector<int>& arr, int k) {\n        vector<pair<int,int>>v;\n        int sum=0,n=arr.size();\n        sort(arr.begin(),arr.end());\n        int median=arr[(n-2)/2]; \n        for(int i=0;i<arr.size();i++)\n        {\n            v.push_back({abs(arr[i]-median),arr[i]});\n        }\n        sort(v.begin(),v.end());\n        reverse(v.begin(),v.end());\n        vector<int>ans;\n        for(int i=0;i<k;i++)\n        {\n            ans.push_back(v[i].second);\n        }\n        return ans;\n    }\n};\n",
        "explanations": "\nThe median of array is fetched incorrectly leading to wrong calculations and unexpected results.\n"
    },
    {
        "slug": "score-after-flipping-matrix",
        "description": "You are given an m x n binary matrix grid.\nA move consists of choosing any row or column and toggling each value in that row or column (i.e., changing all 0's to 1's, and all 1's to 0's).\nEvery row of the matrix is interpreted as a binary number, and the score of the matrix is the sum of these numbers.\nReturn the highest possible score after making any number of moves (including zero moves).",
        "examples": [
            "Input: grid = [[0,0,1,1],[1,0,1,0],[1,1,0,0]]\nOutput: 39\nExplanation: 0b1111 + 0b1001 + 0b1111 = 15 + 9 + 15 = 39",
            "Input: grid = [[0]]\nOutput: 1"
        ],
        "constraints": "m == grid.length\nn == grid[i].length\n1 <= m, n <= 20\ngrid[i][j] is either 0 or 1.",
        "release_time": 1688626701,
        "oracle_code": "class Solution {\npublic:\n    void fliprow(int &r,vector<vector<int>>& grid) //function to toggle row\n    {\n        for(int i=0; i<grid[0].size(); i++){\n            grid[r][i]=1-grid[r][i];\n        }\n    }\n\n    void flipcol(int &c,vector<vector<int>>& grid){ //function to toggle column\n        for(int j=0; j<grid.size(); j++){\n            grid[j][c]=1-grid[j][c];\n        }\n    }\n\n    int matrixScore(vector<vector<int>>& grid) {\n        int n=grid.size();\n        int m=grid[0].size();\n//Making the MSB to 1, all values in column 0 should be 1 to get max value\n        for(int i=0; i<n; i++){\n            if(grid[i][0]==0){    \n                fliprow(i,grid);\n            }\n        }\n//traversing and checking which colums have more zeroes than 1, toggling them too\n        for(int j=0; j<m; j++){\n            int cnt0=0;\n            int cnt1=0;\n            for(int i=0; i<n; i++){\n                if(grid[i][j]==0) cnt0++;\n                else cnt1++;\n            }\n            if(cnt0>cnt1){\n                flipcol(j,grid);\n            }\n        }\n//finally calculating the ans\n        int sum=0;\n        for(int i=0; i<n; i++){\n            for(int j=0; j<m; j++){\n                if(grid[i][j]==1){\n                    sum+= (1<<(m-j-1));\n                }\n            }\n        }\n        return sum;\n        \n\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void fliprow(int &r,vector<vector<int>>& grid) //function to toggle row\\n    {\\n        for(int i=0; i<grid[0].size(); i++){\\n            grid[r][i]=1-grid[r][i];\\n        }\\n    }\\n\\n    void flipcol(int &c,vector<vector<int>>& grid){ //function to toggle column\\n        for(int j=0; j<grid.size(); j++){\\n            grid[j][c]=1-grid[j][c];\\n        }\\n    }\\n\\n    int matrixScore(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n//Making the MSB to 1, all values in column 0 should be 1 to get max value\\n        for(int i=0; i<n; i++){\\n            if(grid[i][0]==0){    \\n                fliprow(i,grid);\\n            }\\n        }\\n//traversing and checking which colums have more zeroes than 1, toggling them too\\n        for(int j=0; j<m; j++){\\n            int cnt0=0;\\n            int cnt1=0;\\n            for(int i=0; i<n; i++){\\n                if(grid[i][j]==0) cnt0++;\\n                else cnt1++;\\n            }\\n            if(cnt0>cnt1){\\n                flipcol(j,grid);\\n            }\\n        }\\n//finally calculating the ans\\n        int sum=0;\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(grid[i][j]==1){\\n                    sum+= (1<<(m-j-1));\\n                }\\n            }\\n        }\\n        return sum;\\n        \\n\\n    }\\n};\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\npublic:\n    void fliprow(int &r,vector<vector<int>>& grid) //function to toggle row\n    {\n        for(int i=0; i<grid[0].size(); i++){\n            grid[r][i]=1-grid[r][i];\n        }\n    }\n\n    void flipcol(int &c,vector<vector<int>>& grid){ //function to toggle column\n        for(int j=0; j<grid.size(); j++){\n            grid[j][c]=1-grid[j][c];\n        }\n    }\n\n    int matrixScore(vector<vector<int>>& grid) {\n        int n=grid.size();\n        int m=grid[0].size();\n//Making the MSB to 1, all values in column 0 should be 1 to get max value\n        for(int i=0; i<n; i++){\n            if(grid[i][0]==0){    \n                fliprow(i,grid);\n            }\n        }\n//traversing and checking which colums have more zeroes than 1, toggling them too\n        for(int j=0; j<m; j++){\n            int cnt0=0;\n            int cnt1=0;\n            for(int i=0; i<n; i++){\n                if(grid[i][j]==1) cnt0++;\n                else cnt1++;\n            }\n            if(cnt0>cnt1){\n                flipcol(j,grid);\n            }\n        }\n//finally calculating the ans\n        int sum=0;\n        for(int i=0; i<n; i++){\n            for(int j=0; j<m; j++){\n                if(grid[i][j]==1){\n                    sum+= (1<<(m-j-1));\n                }\n            }\n        }\n        return sum;\n        \n\n    }\n};\n",
        "explanations": "\nIn the column checking loop, it incorrectly increments cnt0 for 1's and cnt1 for 0's.\n"
    },
    {
        "slug": "percentage-of-letter-in-string",
        "description": "Given a string s and a character letter, return the percentage of characters in s that equal letter rounded down to the nearest whole percent.",
        "examples": [
            "Input: s = \"foobar\", letter = \"o\"\nOutput: 33\nExplanation:\nThe percentage of characters in s that equal the letter 'o' is 2 / 6 * 100% = 33% when rounded down, so we return 33.",
            "Input: s = \"jjjj\", letter = \"k\"\nOutput: 0\nExplanation:\nThe percentage of characters in s that equal the letter 'k' is 0%, so we return 0."
        ],
        "constraints": "1 <= s.length <= 100\ns consists of lowercase English letters.\nletter is a lowercase English letter.",
        "release_time": 1672836042,
        "oracle_code": "class Solution {\npublic:\n    int percentageLetter(string s, char letter) {\n        int count = 0;\n        for(int i=0; i<s.length(); i++){\n            if(s[i] == letter){\n                count++;\n            }\n        }\n        int ans = ((count*100)/s.length()); \n        return ans;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int count = 0;\\n        for(int i=0; i<s.length(); i++){\\n            if(s[i] == letter){\\n                count++;\\n            }\\n        }\\n        int ans = ((count*100)/s.length()); \\n        return ans;\\n    }\\n}; \\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\npublic:\n    int percentageLetter(string s, char letter) {\n        int count = 0;\n        for(int i=0; i<s.length(); i++){\n            if(s[i] == letter){\n                count = count + 2;\n            }\n        }\n        int ans = ((count*100)/s.length()); \n        return ans;\n    }\n};\n",
        "explanations": "\nThe bug is that count increases by 2 everytime the letter is found, causing incorrect calculations.\n"
    },
    {
        "slug": "minimum-changes-to-make-alternating-binary-string",
        "description": "You are given a string s consisting only of the characters '0' and '1'. In one operation, you can change any '0' to '1' or vice versa.\nThe string is called alternating if no two adjacent characters are equal. For example, the string \"010\" is alternating, while the string \"0100\" is not.\nReturn the minimum number of operations needed to make s alternating.",
        "examples": [
            "Input: s = \"0100\"\nOutput: 1\nExplanation: If you change the last character to '1', s will be \"0101\", which is alternating.",
            "Input: s = \"10\"\nOutput: 0\nExplanation: s is already alternating.",
            "Input: s = \"1111\"\nOutput: 2\nExplanation: You need two operations to reach \"0101\" or \"1010\"."
        ],
        "constraints": "1 <= s.length <= 104\ns[i] is either '0' or '1'.",
        "release_time": 1674806782,
        "oracle_code": "class Solution {\npublic:\n    int minOperations(string s) {\n        int n=s.size(), ans=0;\n        for(int i=0;i<n;i++)\n        {\n            if(s[i]-'0' != i%2)\n            ans++;\n        }\n        return min(ans, n-ans);\n    }\n};",
        "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(string s) {\\n        int n=s.size(), ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]-\\'0\\' != i%2)\\n            ans++;\\n        }\\n        return min(ans, n-ans);\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
        "level": "easy",
        "buggy_code": "\nclass Solution {\npublic:\n    int minOperations(string s) {\n        int n=s.size(), ans=0;\n        for(int i=0;i<n;i++)\n        {\n            if(s[i]-'0' != i%2)\n            ans++;\n        }\n        return min(ans, n+ans);\n    }\n};\n",
        "explanations": "\nThe logic error is replacing 'n-ans' with 'n+ans' which causes wrong minimum operation count.\n"
    },
    {
        "slug": "length-of-longest-fibonacci-subsequence",
        "description": "A sequence x1, x2, ..., xn is Fibonacci-like if:\n\nn >= 3\nxi + xi+1 == xi+2 for all i + 2 <= n\n\nGiven a strictly increasing array arr of positive integers forming a sequence, return the length of the longest Fibonacci-like subsequence of arr. If one does not exist, return 0.\nA subsequence is derived from another sequence arr by deleting any number of elements (including none) from arr, without changing the order of the remaining elements. For example, [3, 5, 8] is a subsequence of [3, 4, 5, 6, 7, 8].",
        "examples": [
            "Input: arr = [1,2,3,4,5,6,7,8]\nOutput: 5\nExplanation: The longest subsequence that is fibonacci-like: [1,2,3,5,8].",
            "Input: arr = [1,3,7,11,12,14,18]\nOutput: 3\nExplanation: The longest subsequence that is fibonacci-like: [1,11,12], [3,11,14] or [7,11,18]."
        ],
        "constraints": "3 <= arr.length <= 1000\n1 <= arr[i] < arr[i + 1] <= 109",
        "release_time": 1667708738,
        "oracle_code": "class Solution {\npublic:\n  int f(int curr,int prev,vector<int>& nums,int n){\n\t\t\tint t=nums[curr]+nums[prev];\n\t\t\tint i=lower_bound(nums.begin(),nums.end(),t)-nums.begin();\n\t\t\tif(i<n && nums[i]==t) return 1+f(i,curr,nums,n);\n\t\t\treturn 1;\n\t\t}\n\n\t\tint lenLongestFibSubseq(vector<int>& nums) {\n\t\t\tint n=nums.size();\n\t\t\tint maxi=0;\n\t\t\tfor(int prev2=0;prev2<n;prev2++){\n\t\t\t\tfor(int prev1=prev2+1;prev1<n;prev1++){\n\t\t\t\t\tint temp=nums[prev1]+nums[prev2];\n\t\t\t\t\tint ind=lower_bound(nums.begin(),nums.end(),temp)-nums.begin();\n\t\t\t\t\tif(ind<n && nums[ind]==temp) maxi=max(maxi,2+f(ind,prev1,nums,n));\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn maxi;\n\t\t}\n\t};",
        "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  int f(int curr,int prev,vector<int>& nums,int n){\\n\\t\\t\\tint t=nums[curr]+nums[prev];\\n\\t\\t\\tint i=lower_bound(nums.begin(),nums.end(),t)-nums.begin();\\n\\t\\t\\tif(i<n && nums[i]==t) return 1+f(i,curr,nums,n);\\n\\t\\t\\treturn 1;\\n\\t\\t}\\n\\n\\t\\tint lenLongestFibSubseq(vector<int>& nums) {\\n\\t\\t\\tint n=nums.size();\\n\\t\\t\\tint maxi=0;\\n\\t\\t\\tfor(int prev2=0;prev2<n;prev2++){\\n\\t\\t\\t\\tfor(int prev1=prev2+1;prev1<n;prev1++){\\n\\t\\t\\t\\t\\tint temp=nums[prev1]+nums[prev2];\\n\\t\\t\\t\\t\\tint ind=lower_bound(nums.begin(),nums.end(),temp)-nums.begin();\\n\\t\\t\\t\\t\\tif(ind<n && nums[ind]==temp) maxi=max(maxi,2+f(ind,prev1,nums,n));\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn maxi;\\n\\t\\t}\\n\\t};\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\npublic:\n  int f(int curr,int prev,vector<int>& nums,int n){\n\t\t\tint t=nums[curr]+nums[prev];\n\t\t\tint i=lower_bound(nums.begin(),nums.end(),t)-nums.begin();\n\t\t\tif(i<n && nums[i]==t) return 1+f(i,curr,nums,n);\n\t\t\treturn 0;\n\t\t}\n\n\t\tint lenLongestFibSubseq(vector<int>& nums) {\n\t\t\tint n=nums.size();\n\t\t\tint maxi=0;\n\t\t\tfor(int prev2=0;prev2<n;prev2++){\n\t\t\t\tfor(int prev1=prev2+1;prev1<n;prev1++){\n\t\t\t\t\tint temp=nums[prev1]+nums[prev2];\n\t\t\t\t\tint ind=lower_bound(nums.begin(),nums.end(),temp)-nums.begin();\n\t\t\t\t\tif(ind<n && nums[ind]==temp) maxi=max(maxi,2+f(ind,prev1,nums,n));\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn maxi;\n\t\t}\n\t};\n",
        "explanations": "\nThe base case in the recursive function f should return 1, not 0.\n"
    },
    {
        "slug": "longest-subarray-of-1s-after-deleting-one-element",
        "description": "Given a binary array nums, you should delete one element from it.\nReturn the size of the longest non-empty subarray containing only 1's in the resulting array. Return 0 if there is no such subarray.",
        "examples": [
            "Input: nums = [1,1,0,1]\nOutput: 3\nExplanation: After deleting the number in position 2, [1,1,1] contains 3 numbers with value of 1's.",
            "Input: nums = [0,1,1,1,0,1,1,0,1]\nOutput: 5\nExplanation: After deleting the number in position 4, [0,1,1,1,1,1,0,1] longest subarray with value of 1's is [1,1,1,1,1].",
            "Input: nums = [1,1,1]\nOutput: 2\nExplanation: You must delete one element."
        ],
        "constraints": "1 <= nums.length <= 105\nnums[i] is either 0 or 1.",
        "release_time": 1688536604,
        "oracle_code": "class Solution {\npublic:\n    int longestSubarray(vector<int>& nums) {\n        int n = nums.size();\n        int left = 0, right, zeros = 0, ans = 0;\n\n        for (right = 0; right < n; right++) {\n            if (nums[right] == 0){\n                zeros++;\n                }\n            if (zeros > 1 && nums[left++] == 0){\n                zeros--;\n                }\n            ans = max(ans, right - left);\n        }\n        return ans; \n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums) {\\n        int n = nums.size();\\n        int left = 0, right, zeros = 0, ans = 0;\\n\\n        for (right = 0; right < n; right++) {\\n            if (nums[right] == 0){\\n                zeros++;\\n                }\\n            if (zeros > 1 && nums[left++] == 0){\\n                zeros--;\\n                }\\n            ans = max(ans, right - left);\\n        }\\n        return ans; \\n    }\\n};\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\npublic:\n    int longestSubarray(vector<int>& nums) {\n        int n = nums.size();\n        int left = 0, right, zeros = 0, ans = 0;\n\n        for (right = 0; right < n; right++) {\n            if (nums[right] == 0){\n                zeros++;\n                }\n            if (zeros > 1 && nums[left++] == 0){\n                zeros--;\n                }\n            ans = max(ans, right - left);\n        }\n        return ans + 1; \n    }\n};\n",
        "explanations": "\nThe additional '+1' returned may cause the result to exceed the actual longest subarray length.\n"
    },
    {
        "slug": "intervals-between-identical-elements",
        "description": "You are given a 0-indexed array of n integers arr.\nThe interval between two elements in arr is defined as the absolute difference between their indices. More formally, the interval between arr[i] and arr[j] is |i - j|.\nReturn an array intervals of length n where intervals[i] is the sum of intervals between arr[i] and each element in arr with the same value as arr[i].\nNote: |x| is the absolute value of x.",
        "examples": [
            "Input: arr = [2,1,3,1,2,3,3]\nOutput: [4,2,7,2,4,4,5]\nExplanation:\n- Index 0: Another 2 is found at index 4. |0 - 4| = 4\n- Index 1: Another 1 is found at index 3. |1 - 3| = 2\n- Index 2: Two more 3s are found at indices 5 and 6. |2 - 5| + |2 - 6| = 7\n- Index 3: Another 1 is found at index 1. |3 - 1| = 2\n- Index 4: Another 2 is found at index 0. |4 - 0| = 4\n- Index 5: Two more 3s are found at indices 2 and 6. |5 - 2| + |5 - 6| = 4\n- Index 6: Two more 3s are found at indices 2 and 5. |6 - 2| + |6 - 5| = 5",
            "Input: arr = [10,5,10,10]\nOutput: [5,0,3,4]\nExplanation:\n- Index 0: Two more 10s are found at indices 2 and 3. |0 - 2| + |0 - 3| = 5\n- Index 1: There is only one 5 in the array, so its sum of intervals to identical elements is 0.\n- Index 2: Two more 10s are found at indices 0 and 3. |2 - 0| + |2 - 3| = 3\n- Index 3: Two more 10s are found at indices 0 and 2. |3 - 0| + |3 - 2| = 4"
        ],
        "constraints": "n == arr.length\n1 <= n <= 105\n1 <= arr[i] <= 105",
        "release_time": 1687245473,
        "oracle_code": "class Solution {\npublic:\n    vector<long long> getDistances(vector<int>& arr) {\n        \n        int n = arr.size();\n        vector<long long> ans(n);\n        unordered_map<long long,long long> sum,freq,currfreq,currsum;\n\n        for(int i = 0;i<n;i++)\n        {\n           sum[arr[i]]+=i;\n           freq[arr[i]]++;\n        }\n\n        for(int i = 0;i<n;i++)\n        {\n           currfreq[arr[i]]++;\n           currsum[arr[i]]+=i;\n\n           long long currfrq = currfreq[arr[i]]-1,remfreq = freq[arr[i]]-currfreq[arr[i]];\n           long long currsumval = currsum[arr[i]],remsum = sum[arr[i]]-currsum[arr[i]];\n           ans[i] =  abs(i*currfrq-(currsumval-i))+abs(i*remfreq-remsum);\n        }\n        return ans;\n    }\n};",
        "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n**Approach-1:** Brute Force Approach Using Hash Table Looks Easy but it is not efficient solution it gives TLE.\\n**Approach-2:** to optmize the brute force, Break Dawn the Brute Force into **Current (SUM & FREQUENCY)** and **Remaining (SUM & FREQUENCY**) \\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& arr) {\\n        \\n        int n = arr.size();\\n        vector<long long> ans(n);\\n        unordered_map<long long,long long> sum,freq,currfreq,currsum;\\n\\n        for(int i = 0;i<n;i++)\\n        {\\n           sum[arr[i]]+=i;\\n           freq[arr[i]]++;\\n        }\\n\\n        for(int i = 0;i<n;i++)\\n        {\\n           currfreq[arr[i]]++;\\n           currsum[arr[i]]+=i;\\n\\n           long long currfrq = currfreq[arr[i]]-1,remfreq = freq[arr[i]]-currfreq[arr[i]];\\n           long long currsumval = currsum[arr[i]],remsum = sum[arr[i]]-currsum[arr[i]];\\n           ans[i] =  abs(i*currfrq-(currsumval-i))+abs(i*remfreq-remsum);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/ef1866bf-43d6-4c44-877f-d7106d457c67_1687245465.1707878.jpeg)\\n",
        "level": "medium",
        "buggy_code": "\nclass Solution {\npublic:\n    vector<long long> getDistances(vector<int>& arr) {\n        \n        int n = arr.size();\n        vector<long long> ans(n);\n        unordered_map<long long,long long> sum,freq,currfreq,currsum;\n\n        for(int i = 0;i<n;i++)\n        {\n           sum[arr[i]]+=i;\n           freq[arr[i]]++;\n        }\n\n        for(int i = 0;i<n;i++)\n        {\n           currfreq[arr[i]]++;\n           currsum[arr[i]]+=i;\n\n           long long currfrq = currfreq[arr[i]],remfreq = freq[arr[i]]-currfreq[arr[i]];\n           long long currsumval = currsum[arr[i]],remsum = sum[arr[i]]-currsum[arr[i]];\n           ans[i] =  abs(i*currfrq-(currsumval-i))+abs(i*remfreq-remsum);\n        }\n        return ans;\n    }\n};\n",
        "explanations": "\nThe decrement operator is removed from currfrq initialization causing incorrect frequency tracking.\n"
    },
    {
        "slug": "count-elements-with-strictly-smaller-and-greater-elements",
        "description": "Given an integer array nums, return the number of elements that have both a strictly smaller and a strictly greater element appear in nums.",
        "examples": [
            "Input: nums = [11,7,2,15]\nOutput: 2\nExplanation: The element 7 has the element 2 strictly smaller than it and the element 11 strictly greater than it.\nElement 11 has element 7 strictly smaller than it and element 15 strictly greater than it.\nIn total there are 2 elements having both a strictly smaller and a strictly greater element appear in nums.",
            "Input: nums = [-3,3,3,90]\nOutput: 2\nExplanation: The element 3 has the element -3 strictly smaller than it and the element 90 strictly greater than it.\nSince there are two elements with the value 3, in total there are 2 elements having both a strictly smaller and a strictly greater element appear in nums."
        ],
        "constraints": "1 <= nums.length <= 100\n-105 <= nums[i] <= 105",
        "release_time": 1686274970,
        "oracle_code": "class Solution {\npublic:\n    int countElements(vector<int>& nums) {\n\n        if(nums.size() == 1 || nums.size() == 2) return 0;\n        int ma = *max_element(nums.begin(),nums.end());\n        int countma = count(nums.begin(),nums.end(),ma);\n        int mi = *min_element(nums.begin(),nums.end());\n        int countmi = count(nums.begin(),nums.end(),mi);\n        int ans = nums.size() - (countma+countmi);\n        if(ans <= 0) return 0;\n        return nums.size() - (countma+countmi);\n        \n    }\n};",
        "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countElements(vector<int>& nums) {\\n\\n        if(nums.size() == 1 || nums.size() == 2) return 0;\\n        int ma = *max_element(nums.begin(),nums.end());\\n        int countma = count(nums.begin(),nums.end(),ma);\\n        int mi = *min_element(nums.begin(),nums.end());\\n        int countmi = count(nums.begin(),nums.end(),mi);\\n        int ans = nums.size() - (countma+countmi);\\n        if(ans <= 0) return 0;\\n        return nums.size() - (countma+countmi);\\n        \\n    }\\n};\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\npublic:\n    int countElements(vector<int>& nums) {\n\n        if(nums.size() == 1 || nums.size() == 2) return 0;\n        int ma = *max_element(nums.begin(),nums.end());\n        int countma = count(nums.begin(),nums.end(),ma);\n        int mi = *min_element(nums.begin(),nums.end());\n        int countmi = count(nums.begin(),nums.end(),mi);\n        int ans = nums.size() - (countma+countmi);\n        if(ans <= 0) return 0;\n        return nums.size() - (countma + countmi - 1);\n        \n    }\n};\n\n",
        "explanations": "\nThe bug is in re-calculating answer (nums.size() - (countma + countmi - 1)). This would give an answer that is one more than expected if the condition \"ans <= 0\" is not satisfied.\n"
    },
    {
        "slug": "smallest-index-with-equal-value",
        "description": "Given a 0-indexed integer array nums, return the smallest index i of nums such that i mod 10 == nums[i], or -1 if such index does not exist.\nx mod y denotes the remainder when x is divided by y.",
        "examples": [
            "Input: nums = [0,1,2]\nOutput: 0\nExplanation: \ni=0: 0 mod 10 = 0 == nums[0].\ni=1: 1 mod 10 = 1 == nums[1].\ni=2: 2 mod 10 = 2 == nums[2].\nAll indices have i mod 10 == nums[i], so we return the smallest index 0.",
            "Input: nums = [4,3,2,1]\nOutput: 2\nExplanation: \ni=0: 0 mod 10 = 0 != nums[0].\ni=1: 1 mod 10 = 1 != nums[1].\ni=2: 2 mod 10 = 2 == nums[2].\ni=3: 3 mod 10 = 3 != nums[3].\n2 is the only index which has i mod 10 == nums[i].",
            "Input: nums = [1,2,3,4,5,6,7,8,9,0]\nOutput: -1\nExplanation: No index satisfies i mod 10 == nums[i]."
        ],
        "constraints": "1 <= nums.length <= 100\n0 <= nums[i] <= 9",
        "release_time": 1675700110,
        "oracle_code": "class Solution {\npublic:\n    int smallestEqual(vector<int>& nums) {\n        for (int i = 0 ; i < nums.size() ; i ++)\n        {\n            if ( (i % 10) == nums[i] )\n            {\n                return i ;\n            }\n        }\n        return -1; \n    }\n};",
        "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int smallestEqual(vector<int>& nums) {\\n        for (int i = 0 ; i < nums.size() ; i ++)\\n        {\\n            if ( (i % 10) == nums[i] )\\n            {\\n                return i ;\\n            }\\n        }\\n        return -1; \\n    }\\n};\\n```\\n![815a317f-9cdf-46e2-a397-af8869dafa2e_1673498197.3721023.png](https://assets.leetcode.com/users/images/4ad7c7e8-ac3b-44a3-9c07-4fd7fdbfa301_1675700088.7748973.png)\\n",
        "level": "easy",
        "buggy_code": "\nclass Solution {\npublic:\n    int smallestEqual(vector<int>& nums) {\n        for (int i = 0 ; i < nums.size() ; i ++)\n        {\n            if ( (nums[i] % 10) == nums[i] )\n            {\n                return i ;\n            }\n        }\n        return -1; \n    }\n};\n",
        "explanations": "\nThe logic error bug is changing 'i' to 'nums[i]', comparing wrong elements in the vector.\n"
    },
    {
        "slug": "middle-of-the-linked-list",
        "description": "Given the head of a singly linked list, return the middle node of the linked list.\nIf there are two middle nodes, return the second middle node.",
        "examples": [
            "Input: head = [1,2,3,4,5]\nOutput: [3,4,5]\nExplanation: The middle node of the list is node 3.",
            "Input: head = [1,2,3,4,5,6]\nOutput: [4,5,6]\nExplanation: Since the list has two middle nodes with values 3 and 4, we return the second one."
        ],
        "constraints": "The number of nodes in the list is in the range [1, 100].\n1 <= Node.val <= 100",
        "release_time": 1687519093,
        "oracle_code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* middleNode(ListNode* head) {\n        ListNode* temp = head;\n        ListNode* mid = head;\n        while(temp != NULL && temp -> next != NULL){\n            mid = mid -> next;\n            temp = temp->next-> next;\n        }\n        return mid;\n    }\n};",
        "content": "## INITIALIZE BOTH POINTS FROM HEAD AND THEN TRAVERSE\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# FIRST POINT SHOULD TRAVERSE AT A NORMAL PACE\\n# BUT THE OTHER POINTER (ie. FAST) SHOULD SKIP ONE NODE AND THUS YOU WILL REACH THE SOLUTION IN O(n) TIME COMPLEXITY.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* middleNode(ListNode* head) {\\n        ListNode* temp = head;\\n        ListNode* mid = head;\\n        while(temp != NULL && temp -> next != NULL){\\n            mid = mid -> next;\\n            temp = temp->next-> next;\\n        }\\n        return mid;\\n    }\\n};\\n```",
        "level": "easy",
        "buggy_code": "\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* middleNode(ListNode* head) {\n        ListNode* temp = head;\n        ListNode* mid = head;\n        while(temp != NULL && temp -> next != NULL){\n            mid = mid -> next;\n            temp = temp->next;\n        }\n        return mid;\n    }\n};\n",
        "explanations": "\nTemp is only being incremented once in the loop, causing the middle node to be incorrect.\n"
    },
    {
        "slug": "shortest-path-to-get-all-keys",
        "description": "You are given an m x n grid grid where:\n\n'.' is an empty cell.\n'#' is a wall.\n'@' is the starting point.\nLowercase letters represent keys.\nUppercase letters represent locks.\n\nYou start at the starting point and one move consists of walking one space in one of the four cardinal directions. You cannot walk outside the grid, or walk into a wall.\nIf you walk over a key, you can pick it up and you cannot walk over a lock unless you have its corresponding key.\nFor some 1 <= k <= 6, there is exactly one lowercase and one uppercase letter of the first k letters of the English alphabet in the grid. This means that there is exactly one key for each lock, and one lock for each key; and also that the letters used to represent the keys and locks were chosen in the same order as the English alphabet.\nReturn the lowest number of moves to acquire all keys. If it is impossible, return -1.",
        "examples": [
            "Input: grid = [\"@.a..\",\"###.#\",\"b.A.B\"]\nOutput: 8\nExplanation: Note that the goal is to obtain all the keys not to open all the locks.",
            "Input: grid = [\"@..aA\",\"..B#.\",\"....b\"]\nOutput: 6",
            "Input: grid = [\"@Aa\"]\nOutput: -1"
        ],
        "constraints": "m == grid.length\nn == grid[i].length\n1 <= m, n <= 30\ngrid[i][j] is either an English letter, '.', '#', or '@'.\u00a0\nThere is exactly one\u00a0'@'\u00a0in the grid.\nThe number of keys in the grid is in the range [1, 6].\nEach key in the grid is unique.\nEach key in the grid has a matching lock.",
        "release_time": 1688006204,
        "oracle_code": "class Solution {\npublic:\n\n    int dir[4][2] = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};\n\n    int shortestPathAllKeys(vector<string>& grid) {\n        \n        int m = grid.size();\n        int n = grid[0].size();\n        queue<pair<pair<int, int>, int>> que;\n        vector<vector<unsigned long>> mapKey(m, vector<unsigned long>(n, 0));\n        int target = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if ('a' <= grid[i][j] && grid[i][j] <= 'f') {\n                    target |= 1 << (grid[i][j] - 'a');\n                    continue;\n                }\n\n                if (grid[i][j] == '@') {\n                    que.emplace(pair<int, int>(i, j), 0);\n                    mapKey[i][j] = 1;\n                }\n            }\n        }\n\n\n        int step = 0;\n        while (!que.empty()) {\n            int size = que.size();\n            for (int s = 0; s < size; s++) {\n                int i = que.front().first.first;\n                int j = que.front().first.second;\n                int key = que.front().second;\n                que.pop();\n                \n                if ('a' <= grid[i][j] && grid[i][j] <= 'f') {\n                    key |= 1 << (grid[i][j] - 'a');\n                    if (key == target)\n                        return step;\n\n                    mapKey[i][j] |= 1l << key;\n                }\n\n                for (int d = 0; d < 4; d++) {\n                    int newi = i + dir[d][0];\n                    int newj = j + dir[d][1];\n                    \n                    if (!(0 <= newi && newi < m && 0 <= newj && newj < n))\n                        continue;\n                        \n                    int val = grid[newi][newj];\n                    if (val == '#')\n                        continue;\n                        \n                    if ('A' <= val && val <= 'F' && (key & (1 << (val - 'A'))) == 0)\n                        continue;\n                        \n                    if (mapKey[newi][newj] & (1l << key))\n                        continue;\n                        \n                     mapKey[newi][newj] |= 1l << key;\n                     que.emplace(pair<int, int>(newi, newj), key);\n                }\n            }\n            step++;\n        }\n        return -1;\n    }\n};",
        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int dir[4][2] = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};\\n\\n    int shortestPathAllKeys(vector<string>& grid) {\\n        \\n        int m = grid.size();\\n        int n = grid[0].size();\\n        queue<pair<pair<int, int>, int>> que;\\n        vector<vector<unsigned long>> mapKey(m, vector<unsigned long>(n, 0));\\n        int target = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (\\'a\\' <= grid[i][j] && grid[i][j] <= \\'f\\') {\\n                    target |= 1 << (grid[i][j] - \\'a\\');\\n                    continue;\\n                }\\n\\n                if (grid[i][j] == \\'@\\') {\\n                    que.emplace(pair<int, int>(i, j), 0);\\n                    mapKey[i][j] = 1;\\n                }\\n            }\\n        }\\n\\n\\n        int step = 0;\\n        while (!que.empty()) {\\n            int size = que.size();\\n            for (int s = 0; s < size; s++) {\\n                int i = que.front().first.first;\\n                int j = que.front().first.second;\\n                int key = que.front().second;\\n                que.pop();\\n                \\n                if (\\'a\\' <= grid[i][j] && grid[i][j] <= \\'f\\') {\\n                    key |= 1 << (grid[i][j] - \\'a\\');\\n                    if (key == target)\\n                        return step;\\n\\n                    mapKey[i][j] |= 1l << key;\\n                }\\n\\n                for (int d = 0; d < 4; d++) {\\n                    int newi = i + dir[d][0];\\n                    int newj = j + dir[d][1];\\n                    \\n                    if (!(0 <= newi && newi < m && 0 <= newj && newj < n))\\n                        continue;\\n                        \\n                    int val = grid[newi][newj];\\n                    if (val == \\'#\\')\\n                        continue;\\n                        \\n                    if (\\'A\\' <= val && val <= \\'F\\' && (key & (1 << (val - \\'A\\'))) == 0)\\n                        continue;\\n                        \\n                    if (mapKey[newi][newj] & (1l << key))\\n                        continue;\\n                        \\n                     mapKey[newi][newj] |= 1l << key;\\n                     que.emplace(pair<int, int>(newi, newj), key);\\n                }\\n            }\\n            step++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
        "level": "hard",
        "buggy_code": "\nclass Solution {\npublic:\n\n    int dir[4][2] = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};\n\n    int shortestPathAllKeys(vector<string>& grid) {\n        \n        int m = grid.size();\n        int n = grid[0].size();\n        queue<pair<pair<int, int>, int>> que;\n        vector<vector<unsigned long>> mapKey(m, vector<unsigned long>(n, 0));\n        int target = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if ('a' <= grid[i][j] && grid[i][j] <= 'f') {\n                    target |= 1 << (grid[i][j] - 'a');\n                    continue;\n                }\n\n                if (grid[i][j] == '@') {\n                    que.emplace(pair<int, int>(i, j), 0);\n                    mapKey[i][j] = 1;\n                }\n            }\n        }\n\n\n        int step = 0;\n        while (!que.empty()) {\n            int size = que.size();\n            for (int s = 0; s < size; s++) {\n                int i = que.front().first.first;\n                int j = que.front().first.second;\n                int key = que.front().second;\n                que.pop();\n                \n                if ('a' <= grid[i][j] && grid[i][j] <= 'f') {\n                    key |= 1 << (grid[i][j] - 'a');\n                    if (key == target)\n                        return step;\n\n                    mapKey[i][j] |= 1l << key;\n                }\n\n                for (int d = 0; d < 4; d++) {\n                    int newi = i + dir[d][0];\n                    int newj = j + dir[d][1];\n                    \n                    if (!(0 <= newi && newi < m && 0 <= newj && newj < n))\n                        continue;\n                        \n                    int val = grid[newi][newj];\n                    if (val == '#')\n                        continue;\n                        \n                    if ('A' <= val && val <= 'F' && (key & (1 << (val - 'A'))) == 0)\n                        continue;\n                        \n                    if (mapKey[newi][newj] & (1l << key))\n                        continue;\n                        \n                     mapKey[newi][newj] |= 1l << (key+1);  \n                     que.emplace(pair<int, int>(newi, newj), key);\n                }\n            }\n            step++;\n        }\n        return -1;\n    }\n};\n",
        "explanations": "\nmapKey[newi][newj] is incorrectly left-shifted by (key+1) instead of key which leads to incorrect assignment.\n"
    },
    {
        "slug": "plus-one",
        "description": "You are given a large integer represented as an integer array digits, where each digits[i] is the ith digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading 0's.\nIncrement the large integer by one and return the resulting array of digits.",
        "examples": [
            "Input: digits = [1,2,3]\nOutput: [1,2,4]\nExplanation: The array represents the integer 123.\nIncrementing by one gives 123 + 1 = 124.\nThus, the result should be [1,2,4].",
            "Input: digits = [4,3,2,1]\nOutput: [4,3,2,2]\nExplanation: The array represents the integer 4321.\nIncrementing by one gives 4321 + 1 = 4322.\nThus, the result should be [4,3,2,2].",
            "Input: digits = [9]\nOutput: [1,0]\nExplanation: The array represents the integer 9.\nIncrementing by one gives 9 + 1 = 10.\nThus, the result should be [1,0]."
        ],
        "constraints": "1 <= digits.length <= 100\n0 <= digits[i] <= 9\ndigits does not contain any leading 0's.",
        "release_time": 1691775412,
        "oracle_code": "class Solution {\npublic:\n    vector<int> plusOne(vector<int>& digits) {\n        int n=digits.size();\n        digits[n-1]++;\n        for(int i=n-1;i>=1;i--)\n        {\n            if(digits[i]>9)\n            {\n                digits[i]%=10;\n                digits[i-1]++;\n            }\n        }\n        if(digits[0]>9)\n        {\n            digits.insert(digits.begin(),1);\n            digits[1]%=10;\n        }\n        return digits;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nsimple iterative approach.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIterated all index from the end , then manually checked for 0th index and did the needful.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n=digits.size();\\n        digits[n-1]++;\\n        for(int i=n-1;i>=1;i--)\\n        {\\n            if(digits[i]>9)\\n            {\\n                digits[i]%=10;\\n                digits[i-1]++;\\n            }\\n        }\\n        if(digits[0]>9)\\n        {\\n            digits.insert(digits.begin(),1);\\n            digits[1]%=10;\\n        }\\n        return digits;\\n    }\\n};\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\npublic:\n    vector<int> plusOne(vector<int>& digits) {\n        int n=digits.size();\n        digits[n]++;\n        for(int i=n-1;i>=1;i--)\n        {\n            if(digits[i]>9)\n            {\n                digits[i]%=10;\n                digits[i-1]++;\n            }\n        }\n        if(digits[0]>9)\n        {\n            digits.insert(digits.begin(),1);\n            digits[1]%=10;\n        }\n        return digits;\n    }\n};\n",
        "explanations": "\nTrying to increment index n of vector 'digits', which is out of bound. \n"
    },
    {
        "slug": "valid-anagram",
        "description": "Given two strings s and t, return true if t is an anagram of s, and false otherwise.\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.",
        "examples": [
            "Input: s = \"anagram\", t = \"nagaram\"\nOutput: true",
            "Input: s = \"rat\", t = \"car\"\nOutput: false"
        ],
        "constraints": "1 <= s.length, t.length <= 5 * 104\ns and t consist of lowercase English letters.",
        "release_time": 1679637788,
        "oracle_code": "class Solution {\npublic:\n    bool isAnagram(string s, string t) {\n        if(s.length()!=t.length())\n            return false;\n        vector<int> freq(26, 0);\n        for(int i =0; i<s.length(); i++){\n            freq[s[i]-'a']++;\n            freq[t[i]-'a']--;\n        }\n        for(int i =0; i<freq.size(); i++){\n            if(freq[i]!=0)\n                return false;\n        }\n        return true;\n    }\n};",
        "content": "# Intuition\\nTo solve this problem we will count occurence of each character in both strings and if they are same then both strings are anagram of each other.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nWe can use vector of length 26 to track the occurences of character. \\nIf the size of both string is different then they can\\'t be anagram of each other, so we are checking this first.We loop through each character in both strings and increment the frequency of the corresponding letter in s and decrement the frequency of the corresponding letter in t.\\nThen we loop through freq array if all the elements are 0, if all the elements are 0 this means the two strings are anagram and if not then these things are not anagram of each othe.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n), n is the size of s or t string.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isAnagram(string s, string t) {\\n        if(s.length()!=t.length())\\n            return false;\\n        vector<int> freq(26, 0);\\n        for(int i =0; i<s.length(); i++){\\n            freq[s[i]-\\'a\\']++;\\n            freq[t[i]-\\'a\\']--;\\n        }\\n        for(int i =0; i<freq.size(); i++){\\n            if(freq[i]!=0)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\npublic:\n    bool isAnagram(string s, string t) {\n        if(s.length()!=t.length())\n            return false;\n        vector<int> freq(26, 0);\n        for(int i =0; i<s.length(); i++){\n            freq[s[i]-'a']++;\n            freq[t[i]-'a']++;\n        }\n        for(int i =0; i<freq.size(); i++){\n            if(freq[i]!=0)\n                return false;\n        }\n        return true;\n    }\n};\n",
        "explanations": "\nThe bug is that in the loop instead of decrementing freq[t[i]-'a'], it's being incremented.\n"
    },
    {
        "slug": "valid-boomerang",
        "description": "Given an array points where points[i] = [xi, yi] represents a point on the X-Y plane, return true if these points are a boomerang.\nA boomerang is a set of three points that are all distinct and not in a straight line.",
        "examples": [
            "Input: points = [[1,1],[2,3],[3,2]]\nOutput: true",
            "Input: points = [[1,1],[2,2],[3,3]]\nOutput: false"
        ],
        "constraints": "points.length == 3\npoints[i].length == 2\n0 <= xi, yi <= 100",
        "release_time": 1683522404,
        "oracle_code": "class Solution {\npublic:\n    bool isBoomerang(vector<vector<int>>& points) {\n        float a,b,c,d;\n        a = (points[1][1]-points[0][1]);\n        b = (points[1][0]-points[0][0]);\n        c = (points[2][1]-points[1][1]);\n        d = (points[2][0]-points[1][0]);\n        if((b!=0 && d!=0 && a*d==b*c) || (b==0 && d==0 && points[0][0]==points[1][0]))\n        {\n            return false;\n        }\n        if((points[0][0]==points[1][0] && points[0][1]==points[1][1]) || (points[0][0]==points[2][0] && points[0][1]==points[2][1]) || (points[1][0]==points[2][0] && points[1][1]==points[2][1]))\n        {\n            return false;\n        }\n        return true;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSlopes are matched : (y2-y1)/(x2-x1)\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isBoomerang(vector<vector<int>>& points) {\\n        float a,b,c,d;\\n        a = (points[1][1]-points[0][1]);\\n        b = (points[1][0]-points[0][0]);\\n        c = (points[2][1]-points[1][1]);\\n        d = (points[2][0]-points[1][0]);\\n        if((b!=0 && d!=0 && a*d==b*c) || (b==0 && d==0 && points[0][0]==points[1][0]))\\n        {\\n            return false;\\n        }\\n        if((points[0][0]==points[1][0] && points[0][1]==points[1][1]) || (points[0][0]==points[2][0] && points[0][1]==points[2][1]) || (points[1][0]==points[2][0] && points[1][1]==points[2][1]))\\n        {\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/6d6312fc-589e-44f6-989d-a97c5ba0b0c3_1683522399.5758274.jpeg)\\n",
        "level": "easy",
        "buggy_code": "\nclass Solution {\npublic:\n    bool isBoomerang(vector<vector<int>>& points) {\n        float a, b, c, d;\n        a = (points[1][1] - points[0][1]);\n        b = (points[1][0] - points[0][0]);\n        c = (points[2][1] - points[1][1]);\n        d = (points[2][0] - points[1][0]);\n        if((b != 0 && d != 0 && a * c == b * c) || (b == 0 && d == 0 && points[0][0] == points[1][0]))\n        {\n            return false;\n        }\n        if((points[0][0] == points[1][0] && points[0][1] == points[1][1]) || (points[0][0] == points[2][0] && points[0][1] == points[2][1]) || (points[1][0] == points[2][0] && points[1][1] == points[2][1]))\n        {\n            return false;\n        }\n        return true;\n    }\n};\n",
        "explanations": "\nBug in line \"a*c == b*c\". This bug will always make the equation true if c is nonzero.\n"
    },
    {
        "slug": "frequency-tracker",
        "description": "Design a data structure that keeps track of the values in it and answers some queries regarding their frequencies.\nImplement the FrequencyTracker class.\n\nFrequencyTracker(): Initializes the FrequencyTracker object with an empty array initially.\nvoid add(int number): Adds number to the data structure.\nvoid deleteOne(int number): Deletes one occurrence of number from the data structure. The data structure may not contain number, and in this case nothing is deleted.\nbool hasFrequency(int frequency): Returns true if there is a number in the data structure that occurs frequency number of times, otherwise, it returns false.",
        "examples": [
            "Input\n[\"FrequencyTracker\", \"add\", \"add\", \"hasFrequency\"]\n[[], [3], [3], [2]]\nOutput\n[null, null, null, true]\n\nExplanation\nFrequencyTracker frequencyTracker = new FrequencyTracker();\nfrequencyTracker.add(3); // The data structure now contains [3]\nfrequencyTracker.add(3); // The data structure now contains [3, 3]\nfrequencyTracker.hasFrequency(2); // Returns true, because 3 occurs twice",
            "Input\n[\"FrequencyTracker\", \"add\", \"deleteOne\", \"hasFrequency\"]\n[[], [1], [1], [1]]\nOutput\n[null, null, null, false]\n\nExplanation\nFrequencyTracker frequencyTracker = new FrequencyTracker();\nfrequencyTracker.add(1); // The data structure now contains [1]\nfrequencyTracker.deleteOne(1); // The data structure becomes empty []\nfrequencyTracker.hasFrequency(1); // Returns false, because the data structure is empty",
            "Input\n[\"FrequencyTracker\", \"hasFrequency\", \"add\", \"hasFrequency\"]\n[[], [2], [3], [1]]\nOutput\n[null, false, null, true]\n\nExplanation\nFrequencyTracker frequencyTracker = new FrequencyTracker();\nfrequencyTracker.hasFrequency(2); // Returns false, because the data structure is empty\nfrequencyTracker.add(3); // The data structure now contains [3]\nfrequencyTracker.hasFrequency(1); // Returns true, because 3 occurs once"
        ],
        "constraints": "1 <= number <= 105\n1 <= frequency <= 105\nAt most, 2 *\u00a0105\u00a0calls will be made to add, deleteOne, and hasFrequency\u00a0in total.",
        "release_time": 1683432600,
        "oracle_code": "class FrequencyTracker {\npublic:\n    unordered_map<int,int> x,y;\n    void add(int number) {\n        x[number]++;\n        if(x[number]!=1) y[x[number]-1]--;\n        y[x[number]]++;\n    }\n    void deleteOne(int number) {\n        if(x[number]!=0){\n            x[number]--;\n            y[x[number]+1]--;\n            y[x[number]]++;\n        }\n    }\n    bool hasFrequency(int frequency) {\n        if(y[frequency]!=0) return true;\n        return false;\n    }\n};",
        "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FrequencyTracker {\\npublic:\\n    unordered_map<int,int> x,y;\\n    void add(int number) {\\n        x[number]++;\\n        if(x[number]!=1) y[x[number]-1]--;\\n        y[x[number]]++;\\n    }\\n    void deleteOne(int number) {\\n        if(x[number]!=0){\\n            x[number]--;\\n            y[x[number]+1]--;\\n            y[x[number]]++;\\n        }\\n    }\\n    bool hasFrequency(int frequency) {\\n        if(y[frequency]!=0) return true;\\n        return false;\\n    }\\n};",
        "level": "medium",
        "buggy_code": "\nclass FrequencyTracker {\npublic:\n    unordered_map<int,int> x,y;\n    void add(int number) {\n        x[number]++;\n        if(x[number]!=1) y[x[number]-1]--;\n        y[x[number]]--;\n    }\n    void deleteOne(int number) {\n        if(x[number]!=0){\n            x[number]--;\n            y[x[number]+1]--;\n            y[x[number]]++;\n        }\n    }\n    bool hasFrequency(int frequency) {\n        if(y[frequency]!=0) return true;\n        return false;\n    }\n};\n",
        "explanations": "\nIn the 'add' method, decrementing y[x[number]] instead of incrementing skews the frequency count.\n"
    },
    {
        "slug": "single-number",
        "description": "Given a non-empty\u00a0array of integers nums, every element appears twice except for one. Find that single one.\nYou must\u00a0implement a solution with a linear runtime complexity and use\u00a0only constant\u00a0extra space.",
        "examples": [
            "Input: nums = [2,2,1]\nOutput: 1",
            "Input: nums = [4,1,2,1,2]\nOutput: 4",
            "Input: nums = [1]\nOutput: 1"
        ],
        "constraints": "1 <= nums.length <= 3 * 104\n-3 * 104 <= nums[i] <= 3 * 104\nEach element in the array appears twice except for one element which appears only once.",
        "release_time": 1691549090,
        "oracle_code": "class Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n        unordered_map<int,int> mp;\n        for(int i=0;i<nums.size();i++){\n            mp[nums[i]]++;\n        }\n        for(auto m:mp){\n            if(m.second==1){\n                return m.first;\n            }\n        }\n        return -1;\n    }\n};",
        "content": "# Using Map\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]++;\\n        }\\n        for(auto m:mp){\\n            if(m.second==1){\\n                return m.first;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n# Using XOR\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int res=0;\\n        for(int i=0;i<nums.size();i++){\\n            res^=nums[i];\\n        }\\n        return res;\\n    }\\n};\\n```\\n# Another solutions\\nIf it was given that array is sorted\\n# Iterating over array\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int i=0;\\n        while(i<arr.size()){\\n            if(arr[i]==arr[i+1])i+=2;\\n            else return arr[i];\\n        }\\n    }\\n};\\n```\\n# Binary Search\\nNow we know to optimize from O(N) we can think for O(logN) and first algo comes in mind is Binary Search. But how? and Why?\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int n=arr.size();\\n        // Checking for edge cases\\n        if(n==1 || arr[0]!=arr[1]){\\n            return arr[0];\\n        }\\n        if(arr[n-1]!=arr[n-2]){\\n            return arr[n-1];\\n        }\\n        // Going for Binary search approach\\n        int low=1,high=n-2;\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            if(arr[mid]!=arr[mid-1] && arr[mid]!=arr[mid+1]){\\n                return arr[mid];\\n            }\\n            if((mid%2==1 && arr[mid]==arr[mid-1]) || (mid%2==0 && arr[mid]==arr[mid+1])){// In left half\\n                low=mid+1;\\n            }\\n            else{// In Right half\\n                high=mid-1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n        unordered_map<int,int> mp;\n        for(int i=0;i<nums.size();i++){\n            mp[nums[i]] = 1;\n        }\n        for(auto m:mp){\n            if(m.second==1){\n                return m.first;\n            }\n        }\n        return -1;\n    }\n};\n",
        "explanations": "\nInstead of incrementing the map's value, we are setting it to 1 each time.\n"
    },
    {
        "slug": "factorial-trailing-zeroes",
        "description": "Given an integer n, return the number of trailing zeroes in n!.\nNote that n! = n * (n - 1) * (n - 2) * ... * 3 * 2 * 1.",
        "examples": [
            "Input: n = 3\nOutput: 0\nExplanation: 3! = 6, no trailing zero.",
            "Input: n = 5\nOutput: 1\nExplanation: 5! = 120, one trailing zero.",
            "Input: n = 0\nOutput: 0"
        ],
        "constraints": "0 <= n <= 104",
        "release_time": 1682961619,
        "oracle_code": "class Solution {\npublic:\n    unordered_map<long long int,long long int>mp;\n    int trailingZeroes(int n) {\n        for(int i=n;i>=1;i--)\n         fun(i);\n         \n\t\t return min(mp[2],mp[5]); \n    }\n     void fun(int n)\n    {\n         for(int i=2;i*i<=n;i++)\n         {\n         \twhile((n%i) == 0)\n         \t{\n         \t    mp[i]++;\n\t\t\t\tn = n / i;\t\n\t\t\t}\n\t\t }\n\t\t if(n > 1)\n\t\t mp[n]++;\n    }\n};",
        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    unordered_map<long long int,long long int>mp;\\n    int trailingZeroes(int n) {\\n        for(int i=n;i>=1;i--)\\n         fun(i);\\n         \\n\\t\\t return min(mp[2],mp[5]); \\n    }\\n     void fun(int n)\\n    {\\n         for(int i=2;i*i<=n;i++)\\n         {\\n         \\twhile((n%i) == 0)\\n         \\t{\\n         \\t    mp[i]++;\\n\\t\\t\\t\\tn = n / i;\\t\\n\\t\\t\\t}\\n\\t\\t }\\n\\t\\t if(n > 1)\\n\\t\\t mp[n]++;\\n    }\\n};\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\npublic:\n    unordered_map<long long int,long long int>mp;\n    int trailingZeroes(int n) {\n        for(int i=n;i>=1;i--)\n         fun(i);\n         \n\t\t return max(mp[2],mp[5]); \n    }\n     void fun(int n)\n    {\n         for(int i=2;i*i<=n;i++)\n         {\n         \twhile((n%i) == 0)\n         \t{\n         \t    mp[i]++;\n\t\t\t\tn = n / i;\t\n\t\t\t}\n\t\t }\n\t\t if(n > 1)\n\t\t mp[n]++;\n    }\n};\n",
        "explanations": "\nChanged min to max in return statement, causing wrong return output for trailing zeroes.\n"
    },
    {
        "slug": "unique-paths-iii",
        "description": "You are given an m x n integer array grid where grid[i][j] could be:\n\n1 representing the starting square. There is exactly one starting square.\n2 representing the ending square. There is exactly one ending square.\n0 representing empty squares we can walk over.\n-1 representing obstacles that we cannot walk over.\n\nReturn the number of 4-directional walks from the starting square to the ending square, that walk over every non-obstacle square exactly once.",
        "examples": [
            "Input: grid = [[1,0,0,0],[0,0,0,0],[0,0,2,-1]]\nOutput: 2\nExplanation: We have the following two paths: \n1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2)\n2. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2)",
            "Input: grid = [[1,0,0,0],[0,0,0,0],[0,0,0,2]]\nOutput: 4\nExplanation: We have the following four paths: \n1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2),(2,3)\n2. (0,0),(0,1),(1,1),(1,0),(2,0),(2,1),(2,2),(1,2),(0,2),(0,3),(1,3),(2,3)\n3. (0,0),(1,0),(2,0),(2,1),(2,2),(1,2),(1,1),(0,1),(0,2),(0,3),(1,3),(2,3)\n4. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2),(2,3)",
            "Input: grid = [[0,1],[2,0]]\nOutput: 0\nExplanation: There is no path that walks over every empty square exactly once.\nNote that the starting and ending square can be anywhere in the grid."
        ],
        "constraints": "m == grid.length\nn == grid[i].length\n1 <= m, n <= 20\n1 <= m * n <= 20\n-1 <= grid[i][j] <= 2\nThere is exactly one starting cell and one ending cell.",
        "release_time": 1692204101,
        "oracle_code": "class Solution {\npublic:\n   int count = 0 ; // Counter to keep track of the number of unique paths\n   int zeroes = 0 ; // Counter to keep track of the number of empty cells\n\n   // This function recursively explores the grid to find unique paths\n   void creator(vector<vector<int>>& grid, int row, int col, int length) {\n       // Base cases: if the current cell is out of bounds or marked as visited, return\n       if (row < 0 || col < 0 || row >= grid.size() || col >= grid[0].size() || grid[row][col] == 3 || grid[row][col] == -1)\n           return; \n       \n       // If we encounter the destination (value 2) and all empty cells are covered, increment count\n       if (grid[row][col] == 2 && zeroes == length) {\n           count++;\n           return;\n       }\n       \n       int org = grid[row][col]; // Store the original value of the cell\n       grid[row][col] = 3; // Mark the cell as visited\n       \n       // Explore adjacent cells recursively in all four directions\n       creator(grid, row + 1, col, length + 1);\n       creator(grid, row - 1, col, length + 1);\n       creator(grid, row, col + 1, length + 1);\n       creator(grid, row, col - 1, length + 1);\n       \n       grid[row][col] = org; // Restore the original value of the cell\n       return;\n   }\n\n   int uniquePathsIII(vector<vector<int>>& grid) {\n       int row = 0; \n       int col = 0; \n       int free = 0; // Counter to keep track of the number of cells that can be visited\n\n       // Iterate through the grid to find the starting position and count empty cells\n       for (int i = 0; i < grid.size(); i++) {\n           for (int j = 0; j < grid[0].size(); j++) {\n               if (grid[i][j] == 1) {\n                   row = i; \n                   col = j;\n                   free++;\n               } else if (grid[i][j] == 0 || grid[i][j] == 2) {\n                   free++;\n               }\n           }\n       }\n       \n       zeroes = free; // Update the zeroes counter with the total number of empty cells\n       \n       // Start exploring paths from the initial position\n       creator(grid, row, col, 1);\n       \n       return count; // Return the total count of unique paths\n   }\n};",
        "content": "![image.png](https://assets.leetcode.com/users/images/d2a0428c-0b90-4b7f-839f-aa4ab67262ad_1692204076.471525.png)\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   int count = 0 ; // Counter to keep track of the number of unique paths\\n   int zeroes = 0 ; // Counter to keep track of the number of empty cells\\n\\n   // This function recursively explores the grid to find unique paths\\n   void creator(vector<vector<int>>& grid, int row, int col, int length) {\\n       // Base cases: if the current cell is out of bounds or marked as visited, return\\n       if (row < 0 || col < 0 || row >= grid.size() || col >= grid[0].size() || grid[row][col] == 3 || grid[row][col] == -1)\\n           return; \\n       \\n       // If we encounter the destination (value 2) and all empty cells are covered, increment count\\n       if (grid[row][col] == 2 && zeroes == length) {\\n           count++;\\n           return;\\n       }\\n       \\n       int org = grid[row][col]; // Store the original value of the cell\\n       grid[row][col] = 3; // Mark the cell as visited\\n       \\n       // Explore adjacent cells recursively in all four directions\\n       creator(grid, row + 1, col, length + 1);\\n       creator(grid, row - 1, col, length + 1);\\n       creator(grid, row, col + 1, length + 1);\\n       creator(grid, row, col - 1, length + 1);\\n       \\n       grid[row][col] = org; // Restore the original value of the cell\\n       return;\\n   }\\n\\n   int uniquePathsIII(vector<vector<int>>& grid) {\\n       int row = 0; \\n       int col = 0; \\n       int free = 0; // Counter to keep track of the number of cells that can be visited\\n\\n       // Iterate through the grid to find the starting position and count empty cells\\n       for (int i = 0; i < grid.size(); i++) {\\n           for (int j = 0; j < grid[0].size(); j++) {\\n               if (grid[i][j] == 1) {\\n                   row = i; \\n                   col = j;\\n                   free++;\\n               } else if (grid[i][j] == 0 || grid[i][j] == 2) {\\n                   free++;\\n               }\\n           }\\n       }\\n       \\n       zeroes = free; // Update the zeroes counter with the total number of empty cells\\n       \\n       // Start exploring paths from the initial position\\n       creator(grid, row, col, 1);\\n       \\n       return count; // Return the total count of unique paths\\n   }\\n};\\n\\n```",
        "level": "hard",
        "buggy_code": "\nclass Solution {\npublic:\n   int count = 0 ; \n   int zeroes = 0 ; \n\n   void creator(vector<vector<int>>& grid, int row, int col, int length) {\n       if (row < 0 || col < 0 || row >= grid.size() || col >= grid[0].size() || grid[row][col] == 3 || grid[row][col] == -1)\n           return; \n\n       if (grid[row][col] == 2 && zeroes == length) {\n           count++;\n           return;\n       }\n\n       int org = grid[row][col]; \n       grid[row][col] = 3; \n\n       creator(grid, row + 1, col, length + 1);\n       creator(grid, row - 1, col, length + 1);\n       creator(grid, row, col + 1, length + 1);\n       creator(grid, row, col - 1, length + 1);\n       \n       grid[row][col] = org; \n       return;\n   }\n\n   int uniquePathsIII(vector<vector<int>>& grid) {\n       int row = 0; \n       int col = 0; \n       int free = 0;\n\n       for (int i = 0; i < grid.size(); i++) {\n           for (int j = 0; j < grid[0].size(); j++) {\n               if (grid[i][j] == 1) {\n                   row = i; \n                   col = j;\n                   free++;\n               } else if (grid[i][j] == 0 || grid[i][j] == 2) {\n                   free += 2;\n               }\n           }\n       }\n       \n       zeroes = free; \n       \n       creator(grid, row, col, 1);\n       \n       return count;\n   }\n};\n",
        "explanations": "\nThe bug is in the 'uniquePathsIII' function where the 'free' variable is incremented by 2 instead of 1.\n"
    },
    {
        "slug": "check-if-point-is-reachable",
        "description": "There exists an infinitely large grid. You are currently at point (1, 1), and you need to reach the point (targetX, targetY) using a finite number of steps.\nIn one step, you can move from point (x, y) to any one of the following points:\n\n(x, y - x)\n(x - y, y)\n(2 * x, y)\n(x, 2 * y)\n\nGiven two integers targetX and targetY representing the X-coordinate and Y-coordinate of your final position, return true if you can reach the point from (1, 1) using some number of steps, and false otherwise.",
        "examples": [
            "Input: targetX = 6, targetY = 9\nOutput: false\nExplanation: It is impossible to reach (6,9) from (1,1) using any sequence of moves, so false is returned.",
            "Input: targetX = 4, targetY = 7\nOutput: true\nExplanation: You can follow the path (1,1) -> (1,2) -> (1,4) -> (1,8) -> (1,7) -> (2,7) -> (4,7)."
        ],
        "constraints": "1 <= targetX, targetY\u00a0<= 109",
        "release_time": 1674372109,
        "oracle_code": "class Solution {\npublic:\n    bool isReachable(int x, int y) {\n        while(!(x&1)){\n            x >>= 1;\n        }\n        while(!(y&1)){\n            y >>= 1;\n        }\n        return __gcd(x,y)==1;\n    }\n};",
        "content": "```\\nclass Solution {\\npublic:\\n    bool isReachable(int x, int y) {\\n        while(!(x&1)){\\n            x >>= 1;\\n        }\\n        while(!(y&1)){\\n            y >>= 1;\\n        }\\n        return __gcd(x,y)==1;\\n    }\\n};\\n```",
        "level": "hard",
        "buggy_code": "\nclass Solution {\npublic:\n    bool isReachable(int x, int y) {\n        while(!(x&1)){\n            x >>= 1;\n        }\n        while(!(y&1)){\n            y >>= 1;\n        }\n        return __gcd(x,y)==0;\n    }\n};\n",
        "explanations": "\nThe gcd function should return 1, but mistakenly I have put 0, which is incorrect.\n"
    },
    {
        "slug": "check-knight-tour-configuration",
        "description": "There is a knight on an n x n chessboard. In a valid configuration, the knight starts at the top-left cell of the board and visits every cell on the board exactly once.\nYou are given an n x n integer matrix grid consisting of distinct integers from the range [0, n * n - 1] where grid[row][col] indicates that the cell (row, col) is the grid[row][col]th cell that the knight visited. The moves are 0-indexed.\nReturn true if grid represents a valid configuration of the knight's movements or false otherwise.\nNote that a valid knight move consists of moving two squares vertically and one square horizontally, or two squares horizontally and one square vertically. The figure below illustrates all the possible eight moves of a knight from some cell.",
        "examples": [
            "Input: grid = [[0,11,16,5,20],[17,4,19,10,15],[12,1,8,21,6],[3,18,23,14,9],[24,13,2,7,22]]\nOutput: true\nExplanation: The above diagram represents the grid. It can be shown that it is a valid configuration.",
            "Input: grid = [[0,3,6],[5,8,1],[2,7,4]]\nOutput: false\nExplanation: The above diagram represents the grid. The 8th move of the knight is not valid considering its position after the 7th move."
        ],
        "constraints": "n == grid.length == grid[i].length\n3 <= n <= 7\n0 <= grid[row][col] < n * n\nAll integers in grid are unique.",
        "release_time": 1685738927,
        "oracle_code": "class Solution {\nprivate:\n    bool helper(vector<vector<int>>& grid, int row, int col, int num){\n        int n = grid.size();\n        if(num == n*n) return true;\n        int i = row-2;\n        int j = col+1;\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row-2;\n        j = col-1;\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 2;\n        j = col - 1;\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 2;\n        j = col + 1;\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 1;\n        j = col + 2;\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row - 1;\n        j = col + 2;\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row - 1;\n        j = col - 2;\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 1;\n        j = col - 2;\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        return false;\n    }\npublic:\n    bool checkValidGrid(vector<vector<int>>& grid) {\n        ios::sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);\n        if(grid[0][0] != 0) return false;\n        return helper(grid,0,0,1);\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    bool helper(vector<vector<int>>& grid, int row, int col, int num){\\n        int n = grid.size();\\n        if(num == n*n) return true;\\n        int i = row-2;\\n        int j = col+1;\\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row-2;\\n        j = col-1;\\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row + 2;\\n        j = col - 1;\\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row + 2;\\n        j = col + 1;\\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row + 1;\\n        j = col + 2;\\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row - 1;\\n        j = col + 2;\\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row - 1;\\n        j = col - 2;\\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row + 1;\\n        j = col - 2;\\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        return false;\\n    }\\npublic:\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(0);\\n        cout.tie(0);\\n        if(grid[0][0] != 0) return false;\\n        return helper(grid,0,0,1);\\n    }\\n};\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\nprivate:\n    bool helper(vector<vector<int>>& grid, int row, int col, int num){\n        int n = grid.size();\n        if(num == n*n) return true;\n        int i = row-2;\n        int j = col+1;\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row-2;\n        j = col-1;\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+2);\n\n        i = row + 2;\n        j = col - 1;\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 2;\n        j = col + 1;\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 1;\n        j = col + 2;\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row - 1;\n        j = col + 2;\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row - 1;\n        j = col - 2;\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 1;\n        j = col - 2;\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        return false;\n    }\npublic:\n    bool checkValidGrid(vector<vector<int>>& grid) {\n        ios::sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);\n        if(grid[0][0] != 0) return false;\n        return helper(grid,0,0,1);\n    }\n};\n",
        "explanations": "\nIncreased num by 2 in second direction, thus missing out on number in sequence check.\n"
    },
    {
        "slug": "climbing-stairs",
        "description": "You are climbing a staircase. It takes n steps to reach the top.\nEach time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?",
        "examples": [
            "Input: n = 2\nOutput: 2\nExplanation: There are two ways to climb to the top.\n1. 1 step + 1 step\n2. 2 steps",
            "Input: n = 3\nOutput: 3\nExplanation: There are three ways to climb to the top.\n1. 1 step + 1 step + 1 step\n2. 1 step + 2 steps\n3. 2 steps + 1 step"
        ],
        "constraints": "1 <= n <= 45",
        "release_time": 1676965804,
        "oracle_code": "class Solution {\npublic:\n    int solve(int n,vector<int> &dp){\n        //base case\n        if(n<=2)\n          return n;\n        \n        if(dp[n]!=-1) \n          return dp[n]; \n        \n        dp[n]=solve(n-1,dp)+solve(n-2,dp);\n        return dp[n];\n    }\n    int climbStairs(int n) {\n        if(n<=2)\n         return n;\n        vector<int> dp(n+1);\n        for(int i=0;i<=n;i++)\n         dp[i]=-1;\n        \n        return solve(n,dp);\n    }\n};",
        "content": "# Intuition\\nUsing Top - Down Approach -> Recursion + Memorization.\\n\\n# Approach\\nStoring the values of overlapping sub - problems in a vector.\\n\\n# Complexity\\n- Time complexity:\\nO(n) -> As we are visiting all values of n atleast 1 time.\\n\\n- Space complexity:\\nO(n) + O(n)  - > (Recursive calls + Array of size n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int n,vector<int> &dp){\\n        //base case\\n        if(n<=2)\\n          return n;\\n        \\n        if(dp[n]!=-1) \\n          return dp[n]; \\n        \\n        dp[n]=solve(n-1,dp)+solve(n-2,dp);\\n        return dp[n];\\n    }\\n    int climbStairs(int n) {\\n        if(n<=2)\\n         return n;\\n        vector<int> dp(n+1);\\n        for(int i=0;i<=n;i++)\\n         dp[i]=-1;\\n        \\n        return solve(n,dp);\\n    }\\n};\\n```\\n\\n# Intuition\\nUsing Bottom - up Approach -> Tabulation.\\n\\n# Approach\\nStoring the values of overlapping sub - problems in a vector.\\n\\n# Complexity\\n- Time complexity:\\nO(n) -> As we are traversing the vector atleast 1 time.\\n\\n- Space complexity:\\nO(n) - > (Array of size n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n<=2)\\n         return n;\\n        vector<int> dp(n+1);\\n        dp[0]=0;\\n        dp[1]=1;\\n        dp[2]=2;\\n        for(int i=3;i<=n;i++)\\n         dp[i]=dp[i-1]+dp[i-2];\\n        \\n        return dp[n];\\n    }\\n};\\n```\\n\\n# Python Code :\\nContributed by : Aarya_R\\n\\n# Complexity\\n- Time complexity:\\nO(n) -> As we are traversing the vector atleast 1 time.\\n\\n- Space complexity:\\nO(1) \\n```\\ndef climbStairs(self, n):\\n        prev = 1\\n        prev2 = 0\\n        for i in range(1, n+1):\\n            curi = prev + prev2\\n            prev2 = prev\\n            prev = curi\\n        return prev \\n```\\n![upvote.jfif](https://assets.leetcode.com/users/images/995d917b-6ea2-4b6b-8baa-6ce7bc6441fd_1676965776.537627.jpeg)\\n\\n",
        "level": "easy",
        "buggy_code": "\nclass Solution {\npublic:\n    int solve(int n,vector<int> &dp){\n        //base case\n        if(n<=2)\n          return n;\n        \n        if(dp[n]!=-1) \n          return dp[n]; \n        \n        dp[n]=solve(n-1,dp)+solve(n-3,dp); \n        return dp[n];\n    }\n    int climbStairs(int n) {\n        if(n<=2)\n         return n;\n        vector<int> dp(n+1);\n        for(int i=0;i<=n;i++)\n         dp[i]=-1;\n        \n        return solve(n,dp);\n    }\n};\n",
        "explanations": "\nThe recursive step should add solve(n-1,dp) and solve(n-2,dp) not solve(n-3,dp).\n"
    },
    {
        "slug": "minimum-cost-to-split-an-array",
        "description": "You are given an integer array nums and an integer k.\nSplit the array into some number of non-empty subarrays. The cost of a split is the sum of the importance value of each subarray in the split.\nLet trimmed(subarray) be the version of the subarray where all numbers which appear only once are removed.\n\nFor example, trimmed([3,1,2,4,3,4]) = [3,4,3,4].\n\nThe importance value of a subarray is k + trimmed(subarray).length.\n\nFor example, if a subarray is [1,2,3,3,3,4,4], then trimmed([1,2,3,3,3,4,4]) = [3,3,3,4,4].The importance value of this subarray will be k + 5.\n\nReturn the minimum possible cost of a split of nums.\nA subarray is a contiguous non-empty sequence of elements within an array.",
        "examples": [
            "Input: nums = [1,2,1,2,1,3,3], k = 2\nOutput: 8\nExplanation: We split nums to have two subarrays: [1,2], [1,2,1,3,3].\nThe importance value of [1,2] is 2 + (0) = 2.\nThe importance value of [1,2,1,3,3] is 2 + (2 + 2) = 6.\nThe cost of the split is 2 + 6 = 8. It can be shown that this is the minimum possible cost among all the possible splits.",
            "Input: nums = [1,2,1,2,1], k = 2\nOutput: 6\nExplanation: We split nums to have two subarrays: [1,2], [1,2,1].\nThe importance value of [1,2] is 2 + (0) = 2.\nThe importance value of [1,2,1] is 2 + (2) = 4.\nThe cost of the split is 2 + 4 = 6. It can be shown that this is the minimum possible cost among all the possible splits.",
            "Input: nums = [1,2,1,2,1], k = 5\nOutput: 10\nExplanation: We split nums to have one subarray: [1,2,1,2,1].\nThe importance value of [1,2,1,2,1] is 5 + (3 + 2) = 10.\nThe cost of the split is 10. It can be shown that this is the minimum possible cost among all the possible splits."
        ],
        "constraints": "1 <= nums.length <= 1000\n0 <= nums[i] < nums.length\n1 <= k <= 109",
        "release_time": 1674370423,
        "oracle_code": "class Solution {\npublic:\n    int minCost(vector<int>& nums, int k) {\n        int n=nums.size();\n        vector<int> dp(n,INT_MAX);\n        dp[0]=k;\n        unordered_map<int,int> freq;\n\n        for(int i=1;i<n;i++)\n        {\n            int val=0;\n            freq.clear();\n            for(int j=i;j>=0;j--)\n            {\n                freq[nums[j]]++;\n                if(freq[nums[j]]==2)\n                val+=2;\n                else if(freq[nums[j]]>2) \n                val++;\n                dp[i]=min(dp[i],(j>0?dp[j-1]:0)+k+val);\n            }\n        }\n        return dp[n-1];\n    }\n};",
        "content": "# Intuition and Approach\\nhttps://youtu.be/RkgKv39A0zk\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int> dp(n,INT_MAX);\\n        dp[0]=k;\\n        unordered_map<int,int> freq;\\n\\n        for(int i=1;i<n;i++)\\n        {\\n            int val=0;\\n            freq.clear();\\n            for(int j=i;j>=0;j--)\\n            {\\n                freq[nums[j]]++;\\n                if(freq[nums[j]]==2)\\n                val+=2;\\n                else if(freq[nums[j]]>2) \\n                val++;\\n                dp[i]=min(dp[i],(j>0?dp[j-1]:0)+k+val);\\n            }\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
        "level": "hard",
        "buggy_code": "\nclass Solution {\npublic:\n    int minCost(vector<int>& nums, int k) {\n        int n=nums.size();\n        vector<int> dp(n,INT_MAX);\n        dp[0]=k;\n        unordered_map<int,int> freq;\n\n        for(int i=1;i<n;i++)\n        {\n            int val=0;\n            freq.clear();\n            for(int j=i;j>=0;j--)\n            {\n                freq[nums[j]]++;\n                if(freq[nums[j]]==2)\n                val+=2;\n                else if(freq[nums[j]]>2) \n                val++;\n                dp[i]=min(dp[i],(j>0?dp[j]:0)+k+val);\n            }\n        }\n        return dp[n];\n    }\n};\n",
        "explanations": "\nReturning dp[n] is incorrect because the valid indices of dp are 0 to n-1.\n"
    },
    {
        "slug": "maximum-number-of-ways-to-partition-an-array",
        "description": "You are given a 0-indexed integer array nums of length n. The number of ways to partition nums is the number of pivot indices that satisfy both conditions:\n\n1 <= pivot < n\nnums[0] + nums[1] + ... + nums[pivot - 1] == nums[pivot] + nums[pivot + 1] + ... + nums[n - 1]\n\nYou are also given an integer k. You can choose to change the value of one element of nums to k, or to leave the array unchanged.\nReturn the maximum possible number of ways to partition nums to satisfy both conditions after changing at most one element.",
        "examples": [
            "Input: nums = [2,-1,2], k = 3\nOutput: 1\nExplanation: One optimal approach is to change nums[0] to k. The array becomes [3,-1,2].\nThere is one way to partition the array:\n- For pivot = 2, we have the partition [3,-1 | 2]: 3 + -1 == 2.",
            "Input: nums = [0,0,0], k = 1\nOutput: 2\nExplanation: The optimal approach is to leave the array unchanged.\nThere are two ways to partition the array:\n- For pivot = 1, we have the partition [0 | 0,0]: 0 == 0 + 0.\n- For pivot = 2, we have the partition [0,0 | 0]: 0 + 0 == 0.",
            "Input: nums = [22,4,-25,-20,-15,15,-16,7,19,-10,0,-13,-14], k = -33\nOutput: 4\nExplanation: One optimal approach is to change nums[2] to k. The array becomes [22,4,-33,-20,-15,15,-16,7,19,-10,0,-13,-14].\nThere are four ways to partition the array."
        ],
        "constraints": "n == nums.length\n2 <= n <= 105\n-105 <= k, nums[i] <= 105",
        "release_time": 1679484439,
        "oracle_code": "class Solution {\npublic:\n    long long int getSum(vector<int> &nums){\n        long long int temp = 0;\n        for(auto &i : nums) temp += i;\n        return temp;\n    }\n\n    bool check(unordered_map<long long int, pair<int, int>> &mp, long long int val, int pivot, bool flag){\n        \n        // If flag, then we need to change element from right subarray\n        if(flag){\n            if(mp[val].second >= pivot) return true;\n            return false;\n        }\n\n        // Else we need to change element from left subarray\n        else{\n            if(mp[val].first < pivot) return true;\n            return false;\n        }\n    }\n\n    int waysToPartition(vector<int>& nums, int k) {\n        unordered_map<long long int, pair<int, int>> mp;\n        unordered_map<long long int, pair<int, int>> count;\n\n        // mp stores first and last occurence of an element\n        for(int i=0; i<nums.size(); i++){\n            if(mp.find(nums[i]) == mp.end()){\n                mp[nums[i]].first = i;\n            }\n            mp[nums[i]].second = i;\n        }\n\n        long long int totSum = getSum(nums);\n        long long int left = nums[0];\n        int ans = 0;\n\n        for(int i=1; i<nums.size(); i++){\n            long long int right = totSum - left;\n\n            if(left == right){\n                ans++;\n            }\n            else{\n                long long int diff = left - right;\n\n                // num is the value of element we need to change with k wo satisfy the condition\n                long long int num = k - diff;\n\n                if(mp.find(num) != mp.end()){\n                    if(check(mp, num, i, 1)){\n\n                        // count.second means we have got the element in right subarray with which we can replace our k\n                        count[num].second++;\n                    }\n                }\n\n                diff = right - left;\n                num = k - diff;\n\n                if(mp.find(num) != mp.end()){\n                    if(check(mp, num, i, 0)){\n\n                        // count.first means we got element in left subarray to get replaced \n\n                        count[num].first++; \n                    }\n                }\n            }\n\n            left += nums[i];\n\n            // Suppose there is an element which was on the right side earlier but now as we moving, it came to the left side, so update left usage with it\n            count[nums[i]].first = max(count[nums[i]].first, count[nums[i]].second);\n        }\n\n        int maxi = INT_MIN;\n        for(auto [i,j] : count){\n            maxi = max(maxi, max(j.first, j.second));\n        }\n\n        return max(maxi, ans);\n    }\n};",
        "content": "# Intuition\\nTry to play between left and right subarray in form of variables.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long int getSum(vector<int> &nums){\\n        long long int temp = 0;\\n        for(auto &i : nums) temp += i;\\n        return temp;\\n    }\\n\\n    bool check(unordered_map<long long int, pair<int, int>> &mp, long long int val, int pivot, bool flag){\\n        \\n        // If flag, then we need to change element from right subarray\\n        if(flag){\\n            if(mp[val].second >= pivot) return true;\\n            return false;\\n        }\\n\\n        // Else we need to change element from left subarray\\n        else{\\n            if(mp[val].first < pivot) return true;\\n            return false;\\n        }\\n    }\\n\\n    int waysToPartition(vector<int>& nums, int k) {\\n        unordered_map<long long int, pair<int, int>> mp;\\n        unordered_map<long long int, pair<int, int>> count;\\n\\n        // mp stores first and last occurence of an element\\n        for(int i=0; i<nums.size(); i++){\\n            if(mp.find(nums[i]) == mp.end()){\\n                mp[nums[i]].first = i;\\n            }\\n            mp[nums[i]].second = i;\\n        }\\n\\n        long long int totSum = getSum(nums);\\n        long long int left = nums[0];\\n        int ans = 0;\\n\\n        for(int i=1; i<nums.size(); i++){\\n            long long int right = totSum - left;\\n\\n            if(left == right){\\n                ans++;\\n            }\\n            else{\\n                long long int diff = left - right;\\n\\n                // num is the value of element we need to change with k wo satisfy the condition\\n                long long int num = k - diff;\\n\\n                if(mp.find(num) != mp.end()){\\n                    if(check(mp, num, i, 1)){\\n\\n                        // count.second means we have got the element in right subarray with which we can replace our k\\n                        count[num].second++;\\n                    }\\n                }\\n\\n                diff = right - left;\\n                num = k - diff;\\n\\n                if(mp.find(num) != mp.end()){\\n                    if(check(mp, num, i, 0)){\\n\\n                        // count.first means we got element in left subarray to get replaced \\n\\n                        count[num].first++; \\n                    }\\n                }\\n            }\\n\\n            left += nums[i];\\n\\n            // Suppose there is an element which was on the right side earlier but now as we moving, it came to the left side, so update left usage with it\\n            count[nums[i]].first = max(count[nums[i]].first, count[nums[i]].second);\\n        }\\n\\n        int maxi = INT_MIN;\\n        for(auto [i,j] : count){\\n            maxi = max(maxi, max(j.first, j.second));\\n        }\\n\\n        return max(maxi, ans);\\n    }\\n};\\n```",
        "level": "hard",
        "buggy_code": "\nclass Solution {\npublic:\n     long long int getSum(vector<int> &nums){\n        long long int temp = 0;\n        for(auto &i : nums) temp += i-1;\n        return temp;\n    }\n\n    bool check(unordered_map<long long int, pair<int, int>> &mp, long long int val, int pivot, bool flag){\n        \n        // If flag, then we need to change element from right subarray\n        if(flag){\n            if(mp[val].second >= pivot) return true;\n            return false;\n        }\n\n        // Else we need to change element from left subarray\n        else{\n            if(mp[val].first < pivot) return true;\n            return false;\n        }\n    }\n\n    int waysToPartition(vector<int>& nums, int k) {\n        unordered_map<long long int, pair<int, int>> mp;\n        unordered_map<long long int, pair<int, int>> count;\n\n        // mp stores first and last occurence of an element\n        for(int i=0; i<nums.size(); i++){\n            if(mp.find(nums[i]) == mp.end()){\n                mp[nums[i]].first = i;\n            }\n            mp[nums[i]].second = i;\n        }\n\n        long long int totSum = getSum(nums);\n        long long int left = nums[0];\n        int ans = 0;\n\n        for(int i=1; i<nums.size(); i++){\n            long long int right = totSum - left;\n\n            if(left == right){\n                ans++;\n            }\n            else{\n                long long int diff = left - right;\n\n                // num is the value of element we need to change with k wo satisfy the condition\n                long long int num = k - diff;\n\n                if(mp.find(num) != mp.end()){\n                    if(check(mp, num, i, 1)){\n\n                        // count.second means we have got the element in right subarray with which we can replace our k\n                        count[num].second++;\n                    }\n                }\n\n                diff = right - left;\n                num = k - diff;\n\n                if(mp.find(num) != mp.end()){\n                    if(check(mp, num, i, 0)){\n\n                        // count.first means we got element in left subarray to get replaced \n                        count[num].first++; \n                    }\n                }\n            }\n\n            left += nums[i];\n\n            // Suppose there is an element which was on the right side earlier but now as we moving, it came to the left side, so update left usage with it\n            count[nums[i]].first = max(count[nums[i]].first, count[nums[i]].second);\n        }\n\n        int maxi = INT_MIN;\n        for(auto [i,j] : count){\n            maxi = max(maxi, max(j.first, j.second));\n        }\n\n        return max(maxi, ans);\n    }\n};\n",
        "explanations": "\nIn the getSum function, each element is reduced by 1 which results in incorrect total sum.\n"
    },
    {
        "slug": "shortest-cycle-in-a-graph",
        "description": "There is a bi-directional graph with n vertices, where each vertex is labeled from 0 to n - 1. The edges in the graph are represented by a given 2D integer array edges, where edges[i] = [ui, vi] denotes an edge between vertex ui and vertex vi. Every vertex pair is connected by at most one edge, and no vertex has an edge to itself.\nReturn the length of the shortest cycle in the graph. If no cycle exists, return -1.\nA cycle is a path that starts and ends at the same node, and each edge in the path is used only once.",
        "examples": [
            "Input: n = 7, edges = [[0,1],[1,2],[2,0],[3,4],[4,5],[5,6],[6,3]]\nOutput: 3\nExplanation: The cycle with the smallest length is : 0 -> 1 -> 2 -> 0",
            "Input: n = 4, edges = [[0,1],[0,2]]\nOutput: -1\nExplanation: There are no cycles in this graph."
        ],
        "constraints": "2 <= n <= 1000\n1 <= edges.length <= 1000\nedges[i].length == 2\n0 <= ui, vi < n\nui != vi\nThere are no repeated edges.",
        "release_time": 1686762783,
        "oracle_code": "class Solution {\npublic:\n    int f(int ind, unordered_map<int, vector<pair<int, int>>> &mp, int a, int b)\n    {\n        queue<pair<int, int>> q;\n        unordered_map<int, int> vis;\n        q.push({a, 0});\n        vis[a]=1;\n        while(!q.empty())\n        {\n            int curr = q.front().first;\n            int dis = q.front().second;\n            q.pop();\n            for(auto &x: mp[curr])\n            {\n                if(x.second==ind || vis[x.first]==1)\n                    continue;\n                if(x.first == b)\n                    return dis+1;\n                q.push({x.first, dis+1});\n                vis[x.first]=1;\n            }\n        }\n        return 10000;\n    }\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\n        unordered_map<int, vector<pair<int, int>>> mp;\n        for(int i=0; i<edges.size(); i++)\n        {\n            mp[edges[i][0]].push_back({edges[i][1], i});\n            mp[edges[i][1]].push_back({edges[i][0], i});\n        }\n        int mn = 10000;\n        for(int i=0; i<edges.size(); i++)\n            mn = min(mn, f(i, mp, edges[i][0], edges[i][1]));\n        if(mn>=10000)\n            return -1;\n        return mn+1;\n    }\n};",
        "content": "\\n# Approach\\nIdea is to delete an edge connecting a and b, and then find the minimum distance between a and b (without considering the deleted edge), this shortest path plus one is the size of the smallest loop having both nodes a and b. \\nRepeat the same for each edge and return the the size of minimum loop.\\n\\n# Complexity\\n- Time complexity: O(E^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int f(int ind, unordered_map<int, vector<pair<int, int>>> &mp, int a, int b)\\n    {\\n        queue<pair<int, int>> q;\\n        unordered_map<int, int> vis;\\n        q.push({a, 0});\\n        vis[a]=1;\\n        while(!q.empty())\\n        {\\n            int curr = q.front().first;\\n            int dis = q.front().second;\\n            q.pop();\\n            for(auto &x: mp[curr])\\n            {\\n                if(x.second==ind || vis[x.first]==1)\\n                    continue;\\n                if(x.first == b)\\n                    return dis+1;\\n                q.push({x.first, dis+1});\\n                vis[x.first]=1;\\n            }\\n        }\\n        return 10000;\\n    }\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        unordered_map<int, vector<pair<int, int>>> mp;\\n        for(int i=0; i<edges.size(); i++)\\n        {\\n            mp[edges[i][0]].push_back({edges[i][1], i});\\n            mp[edges[i][1]].push_back({edges[i][0], i});\\n        }\\n        int mn = 10000;\\n        for(int i=0; i<edges.size(); i++)\\n            mn = min(mn, f(i, mp, edges[i][0], edges[i][1]));\\n        if(mn>=10000)\\n            return -1;\\n        return mn+1;\\n    }\\n};\\n```",
        "level": "hard",
        "buggy_code": "\nclass Solution {\npublic:\n    int f(int ind, unordered_map<int, vector<pair<int, int>>> &mp, int a, int b)\n    {\n        queue<pair<int, int>> q;\n        unordered_map<int, int> vis;\n        q.push({a, 0});\n        vis[a]=1;\n        while(!q.empty())\n        {\n            int curr = q.front().first;\n            int dis = q.front().second;\n            q.pop();\n            for(auto &x: mp[curr])\n            {\n                if(x.second==ind || vis[x.first]==1)\n                    continue;\n                if(x.first == b)\n                    return dis;\n                q.push({x.first, dis+1});\n                vis[x.first]=1;\n            }\n        }\n        return 10000;\n    }\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\n        unordered_map<int, vector<pair<int, int>>> mp;\n        for(int i=0; i<edges.size(); i++)\n        {\n            mp[edges[i][0]].push_back({edges[i][1], i});\n            mp[edges[i][1]].push_back({edges[i][0], i});\n        }\n        int mn = 10000;\n        for(int i=0; i<edges.size(); i++)\n            mn = min(mn, f(i, mp, edges[i][0], edges[i][1]));\n        if(mn>=10000)\n            return -1;\n        return mn+1;\n    }\n};\n",
        "explanations": "\nThe function f() should return dis+1 when it finds x.first == b, not dis.\n"
    },
    {
        "slug": "average-salary-excluding-the-minimum-and-maximum-salary",
        "description": "You are given an array of unique integers salary where salary[i] is the salary of the ith employee.\nReturn the average salary of employees excluding the minimum and maximum salary. Answers within 10-5 of the actual answer will be accepted.",
        "examples": [
            "Input: salary = [4000,3000,1000,2000]\nOutput: 2500.00000\nExplanation: Minimum salary and maximum salary are 1000 and 4000 respectively.\nAverage salary excluding minimum and maximum salary is (2000+3000) / 2 = 2500",
            "Input: salary = [1000,2000,3000]\nOutput: 2000.00000\nExplanation: Minimum salary and maximum salary are 1000 and 3000 respectively.\nAverage salary excluding minimum and maximum salary is (2000) / 1 = 2000"
        ],
        "constraints": "3 <= salary.length <= 100\n1000 <= salary[i] <= 106\nAll the integers of salary are unique.",
        "release_time": 1682952594,
        "oracle_code": "class Solution {\npublic:\n    double average(vector<int>& salary) {\n        int n=salary.size(),sum=0,Min=INT_MAX,Max=INT_MIN;\n        for(int i:salary){\n            Max = Max < i ? i : Max ;\n            Min = Min > i ? i : Min ;\n            sum += i;\n        }\n        sum -= (Min + Max);\n        return sum/(n-2.0);\n    }\n};",
        "content": "# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double average(vector<int>& salary) {\\n        int n=salary.size(),sum=0,Min=INT_MAX,Max=INT_MIN;\\n        for(int i:salary){\\n            Max = Max < i ? i : Max ;\\n            Min = Min > i ? i : Min ;\\n            sum += i;\\n        }\\n        sum -= (Min + Max);\\n        return sum/(n-2.0);\\n    }\\n};\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\npublic:\n    double average(vector<int>& salary) {\n        int n=salary.size(),sum=0,Min=INT_MAX,Max=INT_MIN;\n        for(int i:salary){\n            Max = Max < i ? i : 0 ;\n            Min = Min > i ? i : Min ;\n            sum += i;\n        }\n        sum -= (Min + Max);\n        return sum/(n-2.0);\n    }\n};\n",
        "explanations": "\nThe bug is in the line where Max is calculated. It should be replaced by i not 0.\n"
    },
    {
        "slug": "01-matrix",
        "description": "Given an m x n binary matrix mat, return the distance of the nearest 0 for each cell.\nThe distance between two adjacent cells is 1.",
        "examples": [
            "Input: mat = [[0,0,0],[0,1,0],[0,0,0]]\nOutput: [[0,0,0],[0,1,0],[0,0,0]]",
            "Input: mat = [[0,0,0],[0,1,0],[1,1,1]]\nOutput: [[0,0,0],[0,1,0],[1,2,1]]"
        ],
        "constraints": "m == mat.length\nn == mat[i].length\n1 <= m, n <= 104\n1 <= m * n <= 104\nmat[i][j] is either 0 or 1.\nThere is at least one 0 in mat.",
        "release_time": 1692260053,
        "oracle_code": "class Solution {\npublic:\n    vector<vector<int>> updateMatrix(vector<vector<int>>& mat) {\n        int n=mat.size();\n        int m=mat[0].size();\n        vector<vector<int>>dp(n,vector<int>(m,INT_MAX-2));\n        //normal case so will go for top and left only\n        for (int i=0;i<n;i++){\n            for (int j=0;j<m;j++){\n                if (mat[i][j]==0) dp[i][j]=0;\n                else {\n                    if (i>0) dp[i][j]= min (dp[i][j], dp[i-1][j]+1); //top\n                    if (j>0) dp[i][j]=min (dp[i][j],dp[i][j-1]+1); //left\n                }\n            }\n        }\n\n        //reverse \n             for (int i=n-1;i>=0;i--){\n            for (int j=m-1;j>=0;j--){\n                if (mat[i][j]==0) dp[i][j]=0;\n                else {\n                    if (i<n-1) dp[i][j]= min (dp[i][j], dp[i+1][j]+1); //bottom\n                    if (j<m-1) dp[i][j]=min (dp[i][j],dp[i][j+1]+1); //right\n                }\n            }\n        }\n        return dp;\n    }\n};",
        "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize a 2D vector `dp` of the same size as the input matrix `mat`, where each cell initially has a value of `INT_MAX - 2`.\\n2. Traverse the matrix from top-left to bottom-right:\\n   - If the current cell contains 0, set `dp[i][j]` to 0.\\n   - Otherwise, update `dp[i][j]` with the minimum of its current value and the values from its top and left neighbors, incremented by 1.\\n3. Traverse the matrix in reverse, from bottom-right to top-left:\\n   - Update `dp[i][j]` with the minimum of its current value and the values from its bottom and right neighbors, incremented by 1.\\n4. Return the updated `dp` matrix.\\n\\n**Additional Point:**\\n- The reason for using `INT_MAX - 2` is to avoid integer overflow when adding 1 to `INT_MAX`. By subtracting 2, we ensure that the addition won\\'t exceed the maximum value representable by an `int`. This is a common technique to handle situations where adding a small number to `INT_MAX` might cause unexpected behavior due to overflow.\\n![image.png](https://assets.leetcode.com/users/images/768d89e8-9abb-4604-8189-48ab7753f33f_1692259793.882623.png)\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n O(n * m) \\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n * m)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> updateMatrix(vector<vector<int>>& mat) {\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        vector<vector<int>>dp(n,vector<int>(m,INT_MAX-2));\\n        //normal case so will go for top and left only\\n        for (int i=0;i<n;i++){\\n            for (int j=0;j<m;j++){\\n                if (mat[i][j]==0) dp[i][j]=0;\\n                else {\\n                    if (i>0) dp[i][j]= min (dp[i][j], dp[i-1][j]+1); //top\\n                    if (j>0) dp[i][j]=min (dp[i][j],dp[i][j-1]+1); //left\\n                }\\n            }\\n        }\\n\\n        //reverse \\n             for (int i=n-1;i>=0;i--){\\n            for (int j=m-1;j>=0;j--){\\n                if (mat[i][j]==0) dp[i][j]=0;\\n                else {\\n                    if (i<n-1) dp[i][j]= min (dp[i][j], dp[i+1][j]+1); //bottom\\n                    if (j<m-1) dp[i][j]=min (dp[i][j],dp[i][j+1]+1); //right\\n                }\\n            }\\n        }\\n        return dp;\\n    }\\n};\\n```\\n\\nupvote plz \\uD83D\\uDE4F\\uD83C\\uDFFE\\u2B06\\uFE0F\\n",
        "level": "medium",
        "buggy_code": "\nclass Solution {\npublic:\n    vector<vector<int>> updateMatrix(vector<vector<int>>& mat) {\n        int n=mat.size();\n        int m=mat[0].size();\n        vector<vector<int>>dp(n,vector<int>(m,INT_MAX-2));\n        //normal case so will go for top and left only\n        for (int i=0;i<n;i++){\n            for (int j=0;j<m;j++){\n                if (mat[i][j]==0) dp[i][j]=0;\n                else {\n                    if (i>0) dp[i][j]= min (dp[i][j], dp[i-1][j]+1); //top\n                    if (j>0) dp[i][j]=min (dp[i][j],dp[i][j-1]+1); //left\n                }\n            }\n        }\n\n        //reverse \n        for (int i=n-1;i>=0;i--){\n            for (int j=m-1;j>=0;j--){\n                if (mat[i][j]==0) dp[i][j]=INT_MAX-1;\n                else {\n                    if (i<n-1) dp[i][j]= min (dp[i][j], dp[i+1][j]+1); //bottom\n                    if (j<m-1) dp[i][j]=min (dp[i][j],dp[i][j+1]+1); //right\n                }\n            }\n        }\n        return dp;\n    }\n};\n",
        "explanations": "\nIn the reverse loop, dp[i][j]=INT_MAX-1 will override the cells that were initially zero.\n"
    },
    {
        "slug": "find-the-winner-of-the-circular-game",
        "description": "There are n friends that are playing a game. The friends are sitting in a circle and are numbered from 1 to n in clockwise order. More formally, moving clockwise from the ith friend brings you to the (i+1)th friend for 1 <= i < n, and moving clockwise from the nth friend brings you to the 1st friend.\nThe rules of the game are as follows:\n\nStart at the 1st friend.\nCount the next k friends in the clockwise direction including the friend you started at. The counting wraps around the circle and may count some friends more than once.\nThe last friend you counted leaves the circle and loses the game.\nIf there is still more than one friend in the circle, go back to step 2 starting from the friend immediately clockwise of the friend who just lost and repeat.\nElse, the last friend in the circle wins the game.\n\nGiven the number of friends, n, and an integer k, return the winner of the game.",
        "examples": [
            "Input: n = 5, k = 2\nOutput: 3\nExplanation: Here are the steps of the game:\n1) Start at friend 1.\n2) Count 2 friends clockwise, which are friends 1 and 2.\n3) Friend 2 leaves the circle. Next start is friend 3.\n4) Count 2 friends clockwise, which are friends 3 and 4.\n5) Friend 4 leaves the circle. Next start is friend 5.\n6) Count 2 friends clockwise, which are friends 5 and 1.\n7) Friend 1 leaves the circle. Next start is friend 3.\n8) Count 2 friends clockwise, which are friends 3 and 5.\n9) Friend 5 leaves the circle. Only friend 3 is left, so they are the winner.",
            "Input: n = 6, k = 5\nOutput: 1\nExplanation: The friends leave in this order: 5, 4, 6, 2, 3. The winner is friend 1."
        ],
        "constraints": "1 <= k <= n <= 500",
        "release_time": 1673964644,
        "oracle_code": "class Solution {\npublic:\n    int findTheWinner(int n, int k) {\n        vector<int> v;\n        for (int i=1; i<=n; i++)v.push_back(i);\n        int i=0;\n        while (v.size() != 1){\n            i= (i+k-1)%(v.size());\n            //cout<<v[i]<<endl;\n            v.erase(v.begin()+i);\n        }\n        return v[0];\n    }\n};",
        "content": "## Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n## Code\\n```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        vector<int> v;\\n        for (int i=1; i<=n; i++)v.push_back(i);\\n        int i=0;\\n        while (v.size() != 1){\\n            i= (i+k-1)%(v.size());\\n            //cout<<v[i]<<endl;\\n            v.erase(v.begin()+i);\\n        }\\n        return v[0];\\n    }\\n};\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\npublic:\n    int findTheWinner(int n, int k) {\n        vector<int> v;\n        for (int i=1; i<=n; i++)v.push_back(i);\n        int i=0;\n        while (v.size() != 1){\n            i= (i+k)%(v.size());\n            //cout<<v[i]<<endl;\n            v.erase(v.begin()+i);\n        }\n        return v[0];\n    }\n};\n",
        "explanations": "\nThe logic error is in adding k to i instead of (k-1) for modulo operation with vector size.\n"
    },
    {
        "slug": "length-of-the-longest-valid-substring",
        "description": "You are given a string word and an array of strings forbidden.\nA string is called valid if none of its substrings are present in forbidden.\nReturn the length of the longest valid substring of the string word.\nA substring is a contiguous sequence of characters in a string, possibly empty.",
        "examples": [
            "Input: word = \"cbaaaabc\", forbidden = [\"aaa\",\"cb\"]\nOutput: 4\nExplanation: There are 11 valid substrings in word: \"c\", \"b\", \"a\", \"ba\", \"aa\", \"bc\", \"baa\", \"aab\", \"ab\", \"abc\"and \"aabc\". The length of the longest valid substring is 4. \nIt can be shown that all other substrings contain either \"aaa\" or \"cb\" as a substring.",
            "Input: word = \"leetcode\", forbidden = [\"de\",\"le\",\"e\"]\nOutput: 4\nExplanation: There are 11 valid substrings in word: \"l\", \"t\", \"c\", \"o\", \"d\", \"tc\", \"co\", \"od\", \"tco\", \"cod\", and \"tcod\". The length of the longest valid substring is 4.\nIt can be shown that all other substrings contain either \"de\", \"le\", or \"e\" as a substring."
        ],
        "constraints": "1 <= word.length <= 105\nword consists only of lowercase English letters.\n1 <= forbidden.length <= 105\n1 <= forbidden[i].length <= 10\nforbidden[i] consists only of lowercase English letters.",
        "release_time": 1689480311,
        "oracle_code": "class Solution {\npublic:\n    int longestValidSubstring(string word, vector<string>& forbidden) {\n        vector<int> ends(word.size() , -1);\n        unordered_map<string, int> forbidden_word;\n        for(auto it : forbidden)forbidden_word[it] = 1;\n        int n = word.size();\n        for(int i = 0; i<n; i++){\n            string temp = \"\";\n            for(int j = i; j<i+10 && j<n; j++){\n                temp += word[j];\n                if(forbidden_word.find(temp) != forbidden_word.end()) {\n                    ends[j] = i;\n                }\n            }\n        }\n        \n        int i = 0, j = 0;\n        int ans = INT_MIN;\n        while(j < n){\n            \n            if(ends[j] != -1){\n                int st = ends[j];\n                if(st < i){\n                    ans = max(ans, j-i+1);\n                }\n                else{\n                    i = st+1;\n                    ans = max(ans, j-i+1);\n                }\n            }\n            else ans = max(ans,j-i+1);\n            j++;\n        }\n        return ans;\n    }\n};",
        "content": "# Intuition\\nWe can use sliding window + Vector.\\n\\n# Approach\\n\\nWe will initialize a vector end of size word with -1.Than we know the forbidden[i].size() is <= 10, so we can find all the index of the forbidden[i] in word string. we just need to find the ending points of each forbidden[i] in the word string and store it in ends vector with value of the starting index.\\n\\nNow we will use Sliding Window.\\n- we check for each right pointer j in our vector that is, is it a end point? if yes than we need to find the starting point of the substring and let it be \"st\" using our vector of end points. than we check if st < i (our left pointer) if yes than it means our window is safe because it doesnt contain starting index of the particular forbidden word ending at j.\\n\\nif st >= i(our left pointer) that means the starting point of forbidden word ending with right pointer j is in our window so we have to remove it by movig left pointer i = st+1.\\n\\nif our right pointer j is not a end point than the window is valid and we can store the ans of it.\\n\\n# Complexity\\n- Time complexity:\\n- O(N)\\n\\n- Space complexity:\\n- O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestValidSubstring(string word, vector<string>& forbidden) {\\n        vector<int> ends(word.size() , -1);\\n        unordered_map<string, int> forbidden_word;\\n        for(auto it : forbidden)forbidden_word[it] = 1;\\n        int n = word.size();\\n        for(int i = 0; i<n; i++){\\n            string temp = \"\";\\n            for(int j = i; j<i+10 && j<n; j++){\\n                temp += word[j];\\n                if(forbidden_word.find(temp) != forbidden_word.end()) {\\n                    ends[j] = i;\\n                }\\n            }\\n        }\\n        \\n        int i = 0, j = 0;\\n        int ans = INT_MIN;\\n        while(j < n){\\n            \\n            if(ends[j] != -1){\\n                int st = ends[j];\\n                if(st < i){\\n                    ans = max(ans, j-i+1);\\n                }\\n                else{\\n                    i = st+1;\\n                    ans = max(ans, j-i+1);\\n                }\\n            }\\n            else ans = max(ans,j-i+1);\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
        "level": "hard",
        "buggy_code": "\nclass Solution {\npublic:\n    int longestValidSubstring(string word, vector<string>& forbidden) {\n        vector<int> ends(word.size() , -1);\n        unordered_map<string, int> forbidden_word;\n        for(auto it : forbidden) forbidden_word[it] = 1;\n        int n = word.size();\n        for(int i = 0; i<n; i++){\n            string temp = \"\";\n            for(int j = i; j<i+10 && j<n; j++){\n                temp += word[j];\n                if(forbidden_word.find(temp) != forbidden_word.end()) {\n                    ends[j] = i;\n                }\n            }\n        }\n        \n        int i = 0, j = 0;\n        int ans = INT_MIN;\n        while(j < n){\n            \n            if(ends[j] != -1){\n                int st = ends[j];\n                if(st < i){\n                    ans = max(ans, j-i+1);\n                }\n                else{\n                    i = st+1;\n                    ans = max(ans, j-i);\n                }\n            }\n            else ans = max(ans,j-i+1);\n            j++;\n        }\n        return ans;\n    }\n};\n",
        "explanations": "\nThe code fails to increment \"j\" when the substring starts \"st\" is bigger than current \"i\". This results in stuck loop.\n"
    },
    {
        "slug": "maximum-strictly-increasing-cells-in-a-matrix",
        "description": "Given a 1-indexed\u00a0m x n integer matrix mat, you can select any cell in the matrix as your starting cell.\nFrom the starting cell, you can move to any other cell in the same row or column, but only if the value of the destination cell is strictly greater than the value of the current cell. You can repeat this process as many times as possible, moving from cell to cell until you can no longer make any moves.\nYour task is to find the maximum number of cells that you can visit in the matrix by starting from some cell.\nReturn an integer denoting the maximum number of cells that can be visited.",
        "examples": [
            "Input: mat = [[3,1],[3,4]]\nOutput: 2\nExplanation: The image shows how we can visit 2 cells starting from row 1, column 2. It can be shown that we cannot visit more than 2 cells no matter where we start from, so the answer is 2.",
            "Input: mat = [[1,1],[1,1]]\nOutput: 1\nExplanation: Since the cells must be strictly increasing, we can only visit one cell in this example.",
            "Input: mat = [[3,1,6],[-9,5,7]]\nOutput: 4\nExplanation: The image above shows how we can visit 4 cells starting from row 2, column 1. It can be shown that we cannot visit more than 4 cells no matter where we start from, so the answer is 4."
        ],
        "constraints": "m == mat.length\u00a0\nn == mat[i].length\u00a0\n1 <= m, n <= 105\n1 <= m * n <= 105\n-105\u00a0<= mat[i][j] <= 105",
        "release_time": 1685246618,
        "oracle_code": "class Solution {\npublic:\n    int maxIncreasingCells(vector<vector<int>>& mat) {\n        int n = mat.size(), m = mat[0].size();\n        vector<int> row_max(n), col_max(m);\n        \n        map<int, vector<pair<int, int>>, greater<int>> pos;\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                pos[mat[i][j]].push_back({i, j});\n            }\n        }\n        \n        int ans = 0;\n        for (auto& [num, cells]: pos) {\n            int k = cells.size();\n            vector<int> next(k);\n            for (int i = 0; i < k; ++i) {\n                int r = cells[i].first, c = cells[i].second;\n                next[i] = max(row_max[r], col_max[c]) + 1;\n                ans = max(ans, next[i]);\n            }\n            for (int i = 0; i < k; ++i) {\n                int r = cells[i].first, c = cells[i].second;\n                row_max[r] = max(row_max[r], next[i]);\n                col_max[c] = max(col_max[c], next[i]);\n            }\n        }\n        return ans;\n    }\n};",
        "content": "# Intuition\\nAt first I thought of a 2d dp. You can iterate through the matrix in order of decreasing cell value, storing the max number of cells reachable from each cell `mat[i][j]` in `dp[i][j]`. However, for each cell you have to look at all reachable cells (its entire row and column), so the time complexity would be $$O(n*m*(n+m))$$, which isn\\u2019t fast enough.\\n\\nThen I realized you don\\u2019t need to store the max for every cell. As you iterate through the matrix in order of decreasing cell value, you always take the maximum path already found starting in the same row or column. This means you can get away with just storing the max for each row and column.\\n\\n# Approach\\nCreate a map of cell values in decreasing order to (r, c) positions in the matrix with those values. Iterate through this map, updating the vectors row_max and col_max, which store the max number of cells reachable starting from somewhere in each row and column. Be careful to only update row_max and col_max after every cell with a given value has been processed.\\n\\n\\n# Complexity\\n- Time complexity\\n$$O(n*m*log(n*m))$$\\n\\n- Space complexity:\\n$$O(n*m)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxIncreasingCells(vector<vector<int>>& mat) {\\n        int n = mat.size(), m = mat[0].size();\\n        vector<int> row_max(n), col_max(m);\\n        \\n        map<int, vector<pair<int, int>>, greater<int>> pos;\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < m; ++j) {\\n                pos[mat[i][j]].push_back({i, j});\\n            }\\n        }\\n        \\n        int ans = 0;\\n        for (auto& [num, cells]: pos) {\\n            int k = cells.size();\\n            vector<int> next(k);\\n            for (int i = 0; i < k; ++i) {\\n                int r = cells[i].first, c = cells[i].second;\\n                next[i] = max(row_max[r], col_max[c]) + 1;\\n                ans = max(ans, next[i]);\\n            }\\n            for (int i = 0; i < k; ++i) {\\n                int r = cells[i].first, c = cells[i].second;\\n                row_max[r] = max(row_max[r], next[i]);\\n                col_max[c] = max(col_max[c], next[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
        "level": "hard",
        "buggy_code": "\nclass Solution {\npublic:\n    int maxIncreasingCells(vector<vector<int>>& mat) {\n        int n = mat.size(), m = mat[0].size();\n        vector<int> row_max(n), col_max(m);\n        \n        map<int, vector<pair<int, int>>, greater<int>> pos;\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                pos[mat[i][j]].push_back({i, j});\n            }\n        }\n        \n        int ans = 0;\n        for (auto& [num, cells]: pos) {\n            int k = cells.size();\n            vector<int> next(k);\n            for (int i = 0; i < k; ++i) {\n                int r = cells[i].first, c = cells[i].second;\n                next[i] = min(row_max[r], col_max[c]) + 1;\n                ans = max(ans, next[i]);\n            }\n            for (int i = 0; i < k; ++i) {\n                int r = cells[i].first, c = cells[i].second;\n                row_max[r] = max(row_max[r], next[i]);\n                col_max[c] = max(col_max[c], next[i]);\n            }\n        }\n        return ans;\n    }\n};\n",
        "explanations": "\nIn the calculation of `next[i]`, `min` is used instead of `max`, resulting in incorrect increasing cells count. \n"
    },
    {
        "slug": "find-the-minimum-and-maximum-number-of-nodes-between-critical-points",
        "description": "A critical point in a linked list is defined as either a local maxima or a local minima.\nA node is a local maxima if the current node has a value strictly greater than the previous node and the next node.\nA node is a local minima if the current node has a value strictly smaller than the previous node and the next node.\nNote that a node can only be a local maxima/minima if there exists both a previous node and a next node.\nGiven a linked list head, return an array of length 2 containing [minDistance, maxDistance] where minDistance is the minimum distance between any\u00a0two distinct critical points and maxDistance is the maximum distance between any\u00a0two distinct critical points. If there are fewer than two critical points, return [-1, -1].",
        "examples": [
            "Input: head = [3,1]\nOutput: [-1,-1]\nExplanation: There are no critical points in [3,1].",
            "Input: head = [5,3,1,2,5,1,2]\nOutput: [1,3]\nExplanation: There are three critical points:\n- [5,3,1,2,5,1,2]: The third node is a local minima because 1 is less than 3 and 2.\n- [5,3,1,2,5,1,2]: The fifth node is a local maxima because 5 is greater than 2 and 1.\n- [5,3,1,2,5,1,2]: The sixth node is a local minima because 1 is less than 5 and 2.\nThe minimum distance is between the fifth and the sixth node. minDistance = 6 - 5 = 1.\nThe maximum distance is between the third and the sixth node. maxDistance = 6 - 3 = 3.",
            "Input: head = [1,3,2,2,3,2,2,2,7]\nOutput: [3,3]\nExplanation: There are two critical points:\n- [1,3,2,2,3,2,2,2,7]: The second node is a local maxima because 3 is greater than 1 and 2.\n- [1,3,2,2,3,2,2,2,7]: The fifth node is a local maxima because 3 is greater than 2 and 2.\nBoth the minimum and maximum distances are between the second and the fifth node.\nThus, minDistance and maxDistance is 5 - 2 = 3.\nNote that the last node is not considered a local maxima because it does not have a next node."
        ],
        "constraints": "The number of nodes in the list is in the range [2, 105].\n1 <= Node.val <= 105",
        "release_time": 1685534792,
        "oracle_code": "class Solution {\npublic:\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\n        vector<int> ans={-1,-1};\n        ListNode* prev=head;\n        if(!prev) return ans;\n        ListNode* curr=prev->next;\n        if(!curr) return ans;\n        ListNode* next=curr->next;\n        if(!next) return ans;\n\n        int first=-1;\n        int last=-1;\n        int mind=INT_MAX;\n        int i=1;\n        while(next){\n            bool iscp=((curr->val>prev->val && curr->val>next->val)||(curr->val<prev->val&&curr->val<next->val))?true:false;\n            if(iscp&&first==-1){\n                first=i;\n                last=i;\n            }\n            else if(iscp){\n                mind=min(mind,i-last);\n                last=i;\n            }\n            i++;\n            prev=curr;\n            curr=next;\n            next=next->next;\n        }\n        if(first==last)\n         return ans;\n         else\n         {\n             ans[0]=mind;\n             ans[1]=last-first;\n         }\n         return ans;\n    }\n};",
        "content": "\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        vector<int> ans={-1,-1};\\n        ListNode* prev=head;\\n        if(!prev) return ans;\\n        ListNode* curr=prev->next;\\n        if(!curr) return ans;\\n        ListNode* next=curr->next;\\n        if(!next) return ans;\\n\\n        int first=-1;\\n        int last=-1;\\n        int mind=INT_MAX;\\n        int i=1;\\n        while(next){\\n            bool iscp=((curr->val>prev->val && curr->val>next->val)||(curr->val<prev->val&&curr->val<next->val))?true:false;\\n            if(iscp&&first==-1){\\n                first=i;\\n                last=i;\\n            }\\n            else if(iscp){\\n                mind=min(mind,i-last);\\n                last=i;\\n            }\\n            i++;\\n            prev=curr;\\n            curr=next;\\n            next=next->next;\\n        }\\n        if(first==last)\\n         return ans;\\n         else\\n         {\\n             ans[0]=mind;\\n             ans[1]=last-first;\\n         }\\n         return ans;\\n    }\\n};\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\npublic:\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\n        vector<int> ans={-1,-1};\n        ListNode* prev=head;\n        if(!prev) return ans;\n        ListNode* curr=prev->next;\n        if(!curr) return ans;\n        ListNode* next=curr->next;\n        if(!next) return ans;\n\n        int first=-1;\n        int last=-1;\n        int mind=INT_MAX;\n        int i=1;\n        while(next){\n            bool iscp=((curr->val>prev->val && curr->val>next->val)||(curr->val<prev->val&&curr->val<next->val))?true:false;\n            if(iscp&&first==-1){\n                first=i;\n                last=i;\n            }\n            else if(iscp){\n                mind=min(mind,i-last);\n                last=i;\n            }\n            i++;\n            prev=curr;\n            curr=next;\n            next=next->next;\n        }\n        if(first==last)\n         return ans;\n         else\n         {\n             ans[0]=mind;\n             ans[1]=last+first;\n         }\n         return ans;\n    }\n};\n",
        "explanations": "\nInstead of subtracting 'first' from 'last', 'first' is being added to 'last'.\n"
    },
    {
        "slug": "widest-vertical-area-between-two-points-containing-no-points",
        "description": "Given n points on a 2D plane where points[i] = [xi, yi], Return\u00a0the widest vertical area between two points such that no points are inside the area.\nA vertical area is an area of fixed-width extending infinitely along the y-axis (i.e., infinite height). The widest vertical area is the one with the maximum width.\nNote that points on the edge of a vertical area are not considered included in the area.",
        "examples": [
            "\u200b\n\nInput: points = [[8,7],[9,9],[7,4],[9,7]]\nOutput: 1\nExplanation: Both the red and the blue area are optimal.",
            "Input: points = [[3,1],[9,0],[1,0],[1,4],[5,3],[8,8]]\nOutput: 3"
        ],
        "constraints": "n == points.length\n2 <= n <= 105\npoints[i].length == 2\n0 <= xi, yi\u00a0<= 109",
        "release_time": 1666839967,
        "oracle_code": "class Solution {\npublic:\n  int maxWidthOfVerticalArea(vector<vector<int>>& points) {\n    set<int> x;\n    int res = 0;\n    for (auto &p : points)\n        x.insert(p[0]);\n    for (auto it = next(begin(x)); it != end(x); ++it)\n        res = max(res, *it - *prev(it));\n    return res;\n}\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  int maxWidthOfVerticalArea(vector<vector<int>>& points) {\\n    set<int> x;\\n    int res = 0;\\n    for (auto &p : points)\\n        x.insert(p[0]);\\n    for (auto it = next(begin(x)); it != end(x); ++it)\\n        res = max(res, *it - *prev(it));\\n    return res;\\n}\\n};\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\npublic:\n  int maxWidthOfVerticalArea(vector<vector<int>>& points) {\n    set<int> x;\n    int res = 0;\n    for (auto &p : points)\n        x.insert(p[0]);\n    for (auto it = next(begin(x)); it != end(x); ++it)\n        res = max(res, *it - *prev(it));\n    return ++res;\n}\n};\n",
        "explanations": "\nThe bug occurs at return, we increment res by 1, changing the actual maximum difference.\n"
    },
    {
        "slug": "calculate-money-in-leetcode-bank",
        "description": "Hercy wants to save money for his first car. He puts money in the Leetcode\u00a0bank every day.\nHe starts by putting in $1 on Monday, the first day. Every day from Tuesday to Sunday, he will put in $1 more than the day before. On every subsequent Monday, he will put in $1 more than the previous Monday. \nGiven n, return the total amount of money he will have in the Leetcode bank at the end of the nth day.",
        "examples": [
            "Input: n = 4\nOutput: 10\nExplanation:\u00a0After the 4th day, the total is 1 + 2 + 3 + 4 = 10.",
            "Input: n = 10\nOutput: 37\nExplanation:\u00a0After the 10th day, the total is (1 + 2 + 3 + 4 + 5 + 6 + 7) + (2 + 3 + 4) = 37. Notice that on the 2nd Monday, Hercy only puts in $2.",
            "Input: n = 20\nOutput: 96\nExplanation:\u00a0After the 20th day, the total is (1 + 2 + 3 + 4 + 5 + 6 + 7) + (2 + 3 + 4 + 5 + 6 + 7 + 8) + (3 + 4 + 5 + 6 + 7 + 8) = 96."
        ],
        "constraints": "1 <= n <= 1000",
        "release_time": 1677320292,
        "oracle_code": "class Solution {\npublic:\n    int Rem(int a)\n    {\n        return (a * (a+1) )/2;\n    }\n    int totalMoney(int n) {\n        int ans = 0,dif=28;\n        int a = 0;\n\n        a = n/7;\n        \n        for(int i=0;i<a;i++)\n        {\n            ans+=dif;\n            dif+=7;\n        }\n\n        int b = n%7;\n        int ad = Rem(b);\n        ad+= a*b;\n\n        ans+=ad;\n\n\n        return ans;\n    }\n};",
        "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBasically This Question Try to Test Pattern Finding Skill.\\nThis Problem has 2 things two Consider.\\n1) Firstly We Divide n by 7 ( as Week is of  Days ) So that We get Value Which Indicates that Total Number of Weeks need to Consider in Final Answer.\\n\\n2) Now We Do n%7 which gives answer between 0 to 6 which indicates Remaining Days after Step 1. So We need To calculate Sum of Savings for That n%7 days Separately.\\n\\nAs Sum of\\n \\nWeek 1 : 28\\nWeek 2 : 35\\nWeek 3 : 42\\nWeek 4 : 49\\nWeek 5 : 56\\nand so on...\\n Indicates Pattern that We only need How many Whole Week Need to Consider in answer and that We got in Step 1.\\nSo add 28+35+.. upto n/7 terms\\n\\n\\nNow , In Step 2 , We need to consider Saving For Remainig Days which is n%7.\\nSuppose Rem Day is B then B*(B+1)/2 Will be Saving at B day of Week 1.We know that we have n/7 week so n/7*b will be added to B*(B+1)/2\\n.This is Final answer of Step 2.\\n\\n3) Add Both answer of Step 1 and Step 2.\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int Rem(int a)\\n    {\\n        return (a * (a+1) )/2;\\n    }\\n    int totalMoney(int n) {\\n        int ans = 0,dif=28;\\n        int a = 0;\\n\\n        a = n/7;\\n        \\n        for(int i=0;i<a;i++)\\n        {\\n            ans+=dif;\\n            dif+=7;\\n        }\\n\\n        int b = n%7;\\n        int ad = Rem(b);\\n        ad+= a*b;\\n\\n        ans+=ad;\\n\\n\\n        return ans;\\n    }\\n};\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\npublic:\n    int Rem(int a)\n    {\n        return (a * (a+1) )/2;\n    }\n    int totalMoney(int n) {\n        int ans = 0,dif=28;\n        int a = 0;\n\n        a = n/7;\n        \n        for(int i=0;i<a;i++)\n        {\n            ans+=dif;\n            dif+=7;\n        }\n\n        int b = n%7;\n        int ad = Rem(b);\n        ad+= a*b;\n\n        ans-=ad; \n\n\n        return ans;\n    }\n};\n",
        "explanations": "\nImplementation subtracts 'ad' from 'ans' instead of adding, causing an unintended decrease in result.\n"
    },
    {
        "slug": "divide-array-in-sets-of-k-consecutive-numbers",
        "description": "Given an array of integers nums and a positive integer k, check whether it is possible to divide this array into sets of k consecutive numbers.\nReturn true if it is possible. Otherwise, return false.",
        "examples": [
            "Input: nums = [1,2,3,3,4,4,5,6], k = 4\nOutput: true\nExplanation: Array can be divided into [1,2,3,4] and [3,4,5,6].",
            "Input: nums = [3,2,1,2,3,4,3,4,5,9,10,11], k = 3\nOutput: true\nExplanation: Array can be divided into [1,2,3] , [2,3,4] , [3,4,5] and [9,10,11].",
            "Input: nums = [1,2,3,4], k = 3\nOutput: false\nExplanation: Each array should be divided in subarrays of size 3."
        ],
        "constraints": "1 <= k <= nums.length <= 105\n1 <= nums[i] <= 109\n\n\u00a0\nNote: This question is the same as\u00a0846:\u00a0https://leetcode.com/problems/hand-of-straights/",
        "release_time": 1678827516,
        "oracle_code": "class Solution {\npublic:\n    bool isPossibleDivide(vector<int>& nums, int k) {\n        unordered_map<int,int> mpp;\n        sort(nums.begin(), nums.end());\n        if(nums.size()%k!=0){\n            return false;\n        }\n\n\n        for(int i=0; i<nums.size(); i++){\n            mpp[nums[i]]++;\n        }\n        for(int i=0; i<nums.size(); i++){\n            if(mpp[nums[i]]<=0){\n                continue;\n            }\n            for(int j=nums[i] ; j<nums[i]+ k; j++){\n                if(mpp[j]<=0){\n                    return false;\n                }\n                \n                    mpp[j]--;\n                \n            }\n        }\n        return true;\n    }\n};",
        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPossibleDivide(vector<int>& nums, int k) {\\n        unordered_map<int,int> mpp;\\n        sort(nums.begin(), nums.end());\\n        if(nums.size()%k!=0){\\n            return false;\\n        }\\n\\n\\n        for(int i=0; i<nums.size(); i++){\\n            mpp[nums[i]]++;\\n        }\\n        for(int i=0; i<nums.size(); i++){\\n            if(mpp[nums[i]]<=0){\\n                continue;\\n            }\\n            for(int j=nums[i] ; j<nums[i]+ k; j++){\\n                if(mpp[j]<=0){\\n                    return false;\\n                }\\n                \\n                    mpp[j]--;\\n                \\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\npublic:\n    bool isPossibleDivide(vector<int>& nums, int k) {\n        unordered_map<int,int> mpp;\n        sort(nums.begin(), nums.end());\n        if(nums.size()%k!=0){\n            return false;\n        }\n\n\n        for(int i=0; i<nums.size(); i++){\n            mpp[nums[i]]++;\n        }\n        for(int i=0; i<nums.size(); i++){\n            if(mpp[nums[i]]<=0){\n                continue;\n            }\n            for(int j=nums[i] ; j<nums[i]+ k - 1; j++){ \n                if(mpp[j]<=0){\n                    return false;\n                }\n                \n                    mpp[j]--;\n                \n            }\n        }\n        return true;\n    }\n};\n",
        "explanations": "\nThe bug I introduce is subtracting 1 from the variable k inside the second for loop.\n"
    },
    {
        "slug": "my-calendar-i",
        "description": "You are implementing a program to use as your calendar. We can add a new event if adding the event will not cause a double booking.\nA double booking happens when two events have some non-empty intersection (i.e., some moment is common to both events.).\nThe event can be represented as a pair of integers start and end that represents a booking on the half-open interval [start, end), the range of real numbers x such that start <= x < end.\nImplement the MyCalendar class:\n\nMyCalendar() Initializes the calendar object.\nboolean book(int start, int end) Returns true if the event can be added to the calendar successfully without causing a double booking. Otherwise, return false and do not add the event to the calendar.",
        "examples": [
            "Input\n[\"MyCalendar\", \"book\", \"book\", \"book\"]\n[[], [10, 20], [15, 25], [20, 30]]\nOutput\n[null, true, false, true]\n\nExplanation\nMyCalendar myCalendar = new MyCalendar();\nmyCalendar.book(10, 20); // return True\nmyCalendar.book(15, 25); // return False, It can not be booked because time 15 is already booked by another event.\nmyCalendar.book(20, 30); // return True, The event can be booked, as the first event takes every time less than 20, but not including 20."
        ],
        "constraints": "0 <= start < end <= 109\nAt most 1000 calls will be made to book.",
        "release_time": 1659502656,
        "oracle_code": "class MyCalendar {\npublic:\n    map<int,int> m;\n    MyCalendar() {\n        \n    }\n    \n    bool book(int start, int end) {\n        auto p= m.upper_bound(start);\n        if(p== m.end() || end <= p->second) \n        {\n            m[end]=start;\n            return true;\n        } \n        return false;\n    }\n};",
        "content": "Please Upvote :)\\n\\n```\\nclass MyCalendar {\\npublic:\\n    map<int,int> m;\\n    MyCalendar() {\\n        \\n    }\\n    \\n    bool book(int start, int end) {\\n        auto p= m.upper_bound(start);\\n        if(p== m.end() || end <= p->second) \\n        {\\n            m[end]=start;\\n            return true;\\n        } \\n        return false;\\n    }\\n};\\n```",
        "level": "medium",
        "buggy_code": "\nclass MyCalendar {\npublic:\n    map<int,int> m;\n    MyCalendar() {\n        \n    }\n    \n    bool book(int start, int end) {\n        auto p= m.upper_bound(start);\n        if(p== m.end() || end <= p->second) \n        {\n            m[start]=end; \n            return true;\n        } \n        return false;\n    }\n};\n",
        "explanations": "\nThe bug swaps the order of start and end times, which messes up the interval.\n"
    },
    {
        "slug": "find-elements-in-a-contaminated-binary-tree",
        "description": "Given a binary tree with the following rules:\n\nroot.val == 0\nIf treeNode.val == x and treeNode.left != null, then treeNode.left.val == 2 * x + 1\nIf treeNode.val == x and treeNode.right != null, then treeNode.right.val == 2 * x + 2\n\nNow the binary tree is contaminated, which means all treeNode.val have been changed to -1.\nImplement the FindElements class:\n\nFindElements(TreeNode* root) Initializes the object with a contaminated binary tree and recovers it.\nbool find(int target) Returns true if the target value exists in the recovered binary tree.",
        "examples": [
            "Input\n[\"FindElements\",\"find\",\"find\"]\n[[[-1,null,-1]],[1],[2]]\nOutput\n[null,false,true]\nExplanation\nFindElements findElements = new FindElements([-1,null,-1]); \nfindElements.find(1); // return False \nfindElements.find(2); // return True",
            "Input\n[\"FindElements\",\"find\",\"find\",\"find\"]\n[[[-1,-1,-1,-1,-1]],[1],[3],[5]]\nOutput\n[null,true,true,false]\nExplanation\nFindElements findElements = new FindElements([-1,-1,-1,-1,-1]);\nfindElements.find(1); // return True\nfindElements.find(3); // return True\nfindElements.find(5); // return False",
            "Input\n[\"FindElements\",\"find\",\"find\",\"find\",\"find\"]\n[[[-1,null,-1,-1,null,-1]],[2],[3],[4],[5]]\nOutput\n[null,true,false,false,true]\nExplanation\nFindElements findElements = new FindElements([-1,null,-1,-1,null,-1]);\nfindElements.find(2); // return True\nfindElements.find(3); // return False\nfindElements.find(4); // return False\nfindElements.find(5); // return True"
        ],
        "constraints": "TreeNode.val == -1\nThe height of the binary tree is less than or equal to 20\nThe total number of nodes is between [1, 104]\nTotal calls of find() is between [1, 104]\n0 <= target <= 106",
        "release_time": 1666144088,
        "oracle_code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass FindElements {\n  unordered_set<int> set;\npublic:\n    void recover(TreeNode* root, int x) {\n        if (!root) return;\n        root->val = x;\n        set.emplace(x);\n        recover(root->left, 2 * x + 1);\n        recover(root->right, 2 * x + 2);\n    }\n    \n    FindElements(TreeNode* root) {\n        recover(root, 0);\n    }\n    \n    bool find(int target) {\n        return set.count(target);\n    }\n};\n\n/**\n * Your FindElements object will be instantiated and called as such:\n * FindElements* obj = new FindElements(root);\n * bool param_1 = obj->find(target);\n */",
        "content": "\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\n  unordered_set<int> set;\\npublic:\\n    void recover(TreeNode* root, int x) {\\n        if (!root) return;\\n        root->val = x;\\n        set.emplace(x);\\n        recover(root->left, 2 * x + 1);\\n        recover(root->right, 2 * x + 2);\\n    }\\n    \\n    FindElements(TreeNode* root) {\\n        recover(root, 0);\\n    }\\n    \\n    bool find(int target) {\\n        return set.count(target);\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
        "level": "medium",
        "buggy_code": "\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass FindElements {\n  unordered_set<int> set;\npublic:\n    void recover(TreeNode* root, int x) {\n        if (!root) return;\n        root->val = x;\n        set.emplace(x);\n        recover(root->left, 2 * x + 1);\n        recover(root->right, 2 * x + 2);\n    }\n    \n    FindElements(TreeNode* root) {\n        recover(root, 0);\n    }\n    \n    bool find(int target) {\n        return set.count(target - 1);\n    }\n};\n\n/**\n * Your FindElements object will be instantiated and called as such:\n * FindElements* obj = new FindElements(root);\n * bool param_1 = obj->find(target);\n */\n",
        "explanations": "\nThe find method is searching for target - 1 instead of the actual target.\n"
    },
    {
        "slug": "group-anagrams",
        "description": "Given an array of strings strs, group the anagrams together. You can return the answer in any order.\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.",
        "examples": [
            "Input: strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]\nOutput: [[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]",
            "Input: strs = [\"\"]\nOutput: [[\"\"]]",
            "Input: strs = [\"a\"]\nOutput: [[\"a\"]]"
        ],
        "constraints": "1 <= strs.length <= 104\n0 <= strs[i].length <= 100\nstrs[i] consists of lowercase English letters.",
        "release_time": 1690927060,
        "oracle_code": "class Solution {\npublic:\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\n        unordered_map<string,int> m;\n        vector<vector<string>> ans;\n        for(int i=0; i<strs.size(); i++) {\n            string str = strs[i];\n            sort(str.begin(),str.end());\n\n            if(m.find(str) != m.end()) {\n                ans[m[str]].push_back(strs[i]);\n            }\n            else {\n                m[str] = ans.size(); \n                ans.push_back({strs[i]});\n            }\n        }\n        return ans;\n    }\n};",
        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        unordered_map<string,int> m;\\n        vector<vector<string>> ans;\\n        for(int i=0; i<strs.size(); i++) {\\n            string str = strs[i];\\n            sort(str.begin(),str.end());\\n\\n            if(m.find(str) != m.end()) {\\n                ans[m[str]].push_back(strs[i]);\\n            }\\n            else {\\n                m[str] = ans.size(); \\n                ans.push_back({strs[i]});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\npublic:\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\n        unordered_map<string,int> m;\n        vector<vector<string>> ans;\n        for(int i=0; i<strs.size(); i++) {\n            string str = strs[i];\n            sort(str.begin(),str.end());\n\n            if(m.find(str) != m.end()) {\n                ans[m[str]].push_back(str);\n            }\n            else {\n                m[str] = ans.size(); \n                ans.push_back({strs[i]});\n            }\n        }\n        return ans;\n    }\n};\n",
        "explanations": "\nIn the 'if' block, the sorted string 'str' is being pushed instead of the actual string 'strs[i]'.\n"
    },
    {
        "slug": "knight-probability-in-chessboard",
        "description": "On an n x n chessboard, a knight starts at the cell (row, column) and attempts to make exactly k moves. The rows and columns are 0-indexed, so the top-left cell is (0, 0), and the bottom-right cell is (n - 1, n - 1).\nA chess knight has eight possible moves it can make, as illustrated below. Each move is two cells in a cardinal direction, then one cell in an orthogonal direction.\n\nEach time the knight is to move, it chooses one of eight possible moves uniformly at random (even if the piece would go off the chessboard) and moves there.\nThe knight continues moving until it has made exactly k moves or has moved off the chessboard.\nReturn the probability that the knight remains on the board after it has stopped moving.",
        "examples": [
            "Input: n = 3, k = 2, row = 0, column = 0\nOutput: 0.06250\nExplanation: There are two moves (to (1,2), (2,1)) that will keep the knight on the board.\nFrom each of those positions, there are also two moves that will keep the knight on the board.\nThe total probability the knight stays on the board is 0.0625.",
            "Input: n = 1, k = 0, row = 0, column = 0\nOutput: 1.00000"
        ],
        "constraints": "1 <= n <= 25\n0 <= k <= 100\n0 <= row, column <= n - 1",
        "release_time": 1690007879,
        "oracle_code": "class Solution {\npublic:\n    double f(int i,int j,int k,int n,vector<vector<vector<double>>> &dp){\n        if(k==0) return 1.0;\n\n        if(dp[i][j][k]!=-1.0) return dp[i][j][k];\n        int dx[]={-2,-2,-1,1,2,2,1,-1},dy[]={-1,1,2,2,1,-1,-2,-2};\n        double ans = 0.0;\n        for(int t=0;t<8;t++){\n            int nx=i+dx[t],ny=j+dy[t];\n            if(nx>=0 && nx<n && ny>=0 && ny<n){\n                ans += f(nx,ny,k-1,n,dp);\n            }\n        }\n\n        return dp[i][j][k]=ans;\n    }\n    double knightProbability(int n, int k, int row, int column) {\n        vector<vector<vector<double>>> dp(n,vector<vector<double>>(n,vector<double>(k+1,-1.0)));\n        double ct=f(row,column,k,n,dp);\n        for(int i=0;i<k;i++){\n            ct = ct/8;\n        }\n\n        return ct;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n*n*k)\\n\\n- Space complexity: O(n*n*k)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double f(int i,int j,int k,int n,vector<vector<vector<double>>> &dp){\\n        if(k==0) return 1.0;\\n\\n        if(dp[i][j][k]!=-1.0) return dp[i][j][k];\\n        int dx[]={-2,-2,-1,1,2,2,1,-1},dy[]={-1,1,2,2,1,-1,-2,-2};\\n        double ans = 0.0;\\n        for(int t=0;t<8;t++){\\n            int nx=i+dx[t],ny=j+dy[t];\\n            if(nx>=0 && nx<n && ny>=0 && ny<n){\\n                ans += f(nx,ny,k-1,n,dp);\\n            }\\n        }\\n\\n        return dp[i][j][k]=ans;\\n    }\\n    double knightProbability(int n, int k, int row, int column) {\\n        vector<vector<vector<double>>> dp(n,vector<vector<double>>(n,vector<double>(k+1,-1.0)));\\n        double ct=f(row,column,k,n,dp);\\n        for(int i=0;i<k;i++){\\n            ct = ct/8;\\n        }\\n\\n        return ct;\\n    }\\n};\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\npublic:\n    double f(int i,int j,int k,int n,vector<vector<vector<double>>> &dp){\n        if(k==0) return 1.0;\n\n        if(dp[i][j][k]!=-1.0) return dp[i][j][k];\n        int dx[]={-2,-2,-1,1,2,2,1,-1},dy[]={-1,1,2,2,1,-1,-2,-2};\n        double ans = 0.0;\n        for(int t=0;t<8;t++){\n            int nx=i+dx[t],ny=j+dy[t];\n            if(nx>=0 && nx<n && ny>=0 && ny<n){\n                ans += f(nx,ny,k-1,n,dp);\n            }\n        }\n\n        return dp[i][j][k]=ans/8;\n    }\n    double knightProbability(int n, int k, int row, int column) {\n        vector<vector<vector<double>>> dp(n,vector<vector<double>>(n,vector<double>(k+1,-1.0)));\n        double ct=f(row,column,k,n,dp);\n        for(int i=0;i<k;i++){\n            ct = ct/8;\n        }\n\n        return ct;\n    }\n};\n",
        "explanations": "\nThe probability is divided by 8 twice, once in function f() and once in knightProbability().\n"
    },
    {
        "slug": "neighboring-bitwise-xor",
        "description": "A 0-indexed array derived with length n is derived by computing the bitwise XOR\u00a0(\u2295) of adjacent values in a binary array original of length n.\nSpecifically, for each index i in the range [0, n - 1]:\n\nIf i = n - 1, then derived[i] = original[i] \u2295 original[0].\nOtherwise, derived[i] = original[i] \u2295 original[i + 1].\n\nGiven an array derived, your task is to determine whether there exists a valid binary array original that could have formed derived.\nReturn true if such an array exists or false otherwise.\n\nA binary array is an array containing only 0's and 1's",
        "examples": [
            "Input: derived = [1,1,0]\nOutput: true\nExplanation: A valid original array that gives derived is [0,1,0].\nderived[0] = original[0] \u2295 original[1] = 0 \u2295 1 = 1 \nderived[1] = original[1] \u2295 original[2] = 1 \u2295 0 = 1\nderived[2] = original[2] \u2295 original[0] = 0 \u2295 0 = 0",
            "Input: derived = [1,1]\nOutput: true\nExplanation: A valid original array that gives derived is [0,1].\nderived[0] = original[0] \u2295 original[1] = 1\nderived[1] = original[1] \u2295 original[0] = 1",
            "Input: derived = [1,0]\nOutput: false\nExplanation: There is no valid original array that gives derived."
        ],
        "constraints": "n == derived.length\n1 <= n\u00a0<= 105\nThe values in derived\u00a0are either 0's or 1's",
        "release_time": 1687118835,
        "oracle_code": "class Solution {\npublic:\n    bool doesValidArrayExist(vector<int>& derived) {\n        int xoor = 0;\n        for (auto i: derived) xoor ^= i;\n        return !xoor;\n    }\n};",
        "content": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int xoor = 0;\\n        for (auto i: derived) xoor ^= i;\\n        return !xoor;\\n    }\\n};\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\npublic:\n    bool doesValidArrayExist(vector<int>& derived) {\n        int xoor = 0;\n        for (auto i: derived) xoor += i;\n        return !xoor;\n    }\n};\n",
        "explanations": "\nChanged bitwise XOR operation to addition, which will not check correct parity as required.\n"
    },
    {
        "slug": "maximize-grid-happiness",
        "description": "You are given four integers, m, n, introvertsCount, and extrovertsCount. You have an m x n grid, and there are two types of people: introverts and extroverts. There are introvertsCount introverts and extrovertsCount extroverts.\nYou should decide how many people you want to live in the grid and assign each of them one grid cell. Note that you do not have to have all the people living in the grid.\nThe happiness of each person is calculated as follows:\n\nIntroverts start with 120 happiness and lose 30 happiness for each neighbor (introvert or extrovert).\nExtroverts start with 40 happiness and gain 20 happiness for each neighbor (introvert or extrovert).\n\nNeighbors live in the directly adjacent cells north, east, south, and west of a person's cell.\nThe grid happiness is the sum of each person's happiness. Return the maximum possible grid happiness.",
        "examples": [
            "Input: m = 2, n = 3, introvertsCount = 1, extrovertsCount = 2\nOutput: 240\nExplanation: Assume the grid is 1-indexed with coordinates (row, column).\nWe can put the introvert in cell (1,1) and put the extroverts in cells (1,3) and (2,3).\n- Introvert at (1,1) happiness: 120 (starting happiness) - (0 * 30) (0 neighbors) = 120\n- Extrovert at (1,3) happiness: 40 (starting happiness) + (1 * 20) (1 neighbor) = 60\n- Extrovert at (2,3) happiness: 40 (starting happiness) + (1 * 20) (1 neighbor) = 60\nThe grid happiness is 120 + 60 + 60 = 240.\nThe above figure shows the grid in this example with each person's happiness. The introvert stays in the light green cell while the extroverts live on the light purple cells.",
            "Input: m = 3, n = 1, introvertsCount = 2, extrovertsCount = 1\nOutput: 260\nExplanation: Place the two introverts in (1,1) and (3,1) and the extrovert at (2,1).\n- Introvert at (1,1) happiness: 120 (starting happiness) - (1 * 30) (1 neighbor) = 90\n- Extrovert at (2,1) happiness: 40 (starting happiness) + (2 * 20) (2 neighbors) = 80\n- Introvert at (3,1) happiness: 120 (starting happiness) - (1 * 30) (1 neighbor) = 90\nThe grid happiness is 90 + 80 + 90 = 260.",
            "Input: m = 2, n = 2, introvertsCount = 4, extrovertsCount = 0\nOutput: 240"
        ],
        "constraints": "1 <= m, n <= 5\n0 <= introvertsCount, extrovertsCount <= min(m * n, 6)",
        "release_time": 1669119358,
        "oracle_code": "//from votrubac\nclass Solution {\npublic:\n   int dp[25][7][7][64][64] = {};\nint nCost(int m, int n, int i, int j, int mask_in, int mask_ex, int d) {\n    int diff = 0, up = (1 << (n - 1));\n    if (j > 0 && (mask_in & 1))\n        diff += d - 30;\n    if (i > 0 && (mask_in & up))\n        diff += d - 30;\n    if (j > 0 && (mask_ex & 1))\n        diff += d + 20;\n    if (i > 0 && (mask_ex & up))\n        diff += d + 20;\n    return diff;\n}\nint dfs(int m, int n, int p, int in, int ex, int mask_in, int mask_ex) {\n    int i = p / n, j = p % n;\n    if (i >= m)\n        return 0;\n    if (dp[p][in][ex][mask_in][mask_ex])\n        return dp[p][in][ex][mask_in][mask_ex] - 1;\n    int n_mask_in = (mask_in << 1) & 63, n_mask_ex = (mask_ex << 1) & 63;\n    int res = dfs(m, n, p + 1, in, ex, n_mask_in, n_mask_ex);\n    if (in > 0) {\n        int diff = 120 + nCost(m, n, i, j, mask_in, mask_ex, -30);\n        res = max(res, diff + dfs(m, n, p + 1, in - 1, ex, n_mask_in + 1, n_mask_ex));\n    }\n    if (ex > 0) {\n        int diff = 40 + nCost(m, n, i, j, mask_in, mask_ex, 20);\n        res = max(res, diff + dfs(m, n, p + 1, in, ex - 1, n_mask_in, n_mask_ex + 1));\n    }\n    dp[p][in][ex][mask_in][mask_ex] = res + 1;\n    return res;\n}\nint getMaxGridHappiness(int m, int n, int introvertsCount, int extrovertsCount) {\n    return dfs(m, n, 0, introvertsCount, extrovertsCount, 0, 0);\n}\n};",
        "content": "\\n\\n# Code\\n```\\n//from votrubac\\nclass Solution {\\npublic:\\n   int dp[25][7][7][64][64] = {};\\nint nCost(int m, int n, int i, int j, int mask_in, int mask_ex, int d) {\\n    int diff = 0, up = (1 << (n - 1));\\n    if (j > 0 && (mask_in & 1))\\n        diff += d - 30;\\n    if (i > 0 && (mask_in & up))\\n        diff += d - 30;\\n    if (j > 0 && (mask_ex & 1))\\n        diff += d + 20;\\n    if (i > 0 && (mask_ex & up))\\n        diff += d + 20;\\n    return diff;\\n}\\nint dfs(int m, int n, int p, int in, int ex, int mask_in, int mask_ex) {\\n    int i = p / n, j = p % n;\\n    if (i >= m)\\n        return 0;\\n    if (dp[p][in][ex][mask_in][mask_ex])\\n        return dp[p][in][ex][mask_in][mask_ex] - 1;\\n    int n_mask_in = (mask_in << 1) & 63, n_mask_ex = (mask_ex << 1) & 63;\\n    int res = dfs(m, n, p + 1, in, ex, n_mask_in, n_mask_ex);\\n    if (in > 0) {\\n        int diff = 120 + nCost(m, n, i, j, mask_in, mask_ex, -30);\\n        res = max(res, diff + dfs(m, n, p + 1, in - 1, ex, n_mask_in + 1, n_mask_ex));\\n    }\\n    if (ex > 0) {\\n        int diff = 40 + nCost(m, n, i, j, mask_in, mask_ex, 20);\\n        res = max(res, diff + dfs(m, n, p + 1, in, ex - 1, n_mask_in, n_mask_ex + 1));\\n    }\\n    dp[p][in][ex][mask_in][mask_ex] = res + 1;\\n    return res;\\n}\\nint getMaxGridHappiness(int m, int n, int introvertsCount, int extrovertsCount) {\\n    return dfs(m, n, 0, introvertsCount, extrovertsCount, 0, 0);\\n}\\n};\\n```",
        "level": "hard",
        "buggy_code": "\n//from votrubac\nclass Solution {\npublic:\n   int dp[25][7][7][64][64] = {};\nint nCost(int m, int n, int i, int j, int mask_in, int mask_ex, int d) {\n    int diff = 0, up = (1 << (n - 1));\n    if (j > 0 && (mask_in & 1))\n        diff += d - 30;\n    if (i > 0 && (mask_in & up))\n        diff += d - 30;\n    if (j > 0 && (mask_ex & 1))\n        diff += d + 20;\n    if (i > 0 && (mask_ex & up))\n        diff += d + 20;\n    return diff;\n}\nint dfs(int m, int n, int p, int in, int ex, int mask_in, int mask_ex) {\n    int i = p / n, j = p % n;\n    if (i >= m)\n        return 0;\n    if (dp[p][in][ex][mask_in][mask_ex])\n        return dp[p][in][ex][mask_in][mask_ex] - 1;\n    int n_mask_in = (mask_in << 1) & 63, n_mask_ex = (mask_ex << 1) & 63;\n    int res = dfs(m, n, p + 1, in, ex, n_mask_in, n_mask_ex);\n    if (in > 0) {\n        int diff = 120 + nCost(m, n, i, j, mask_in, mask_ex, -30);\n        res = max(res, diff + dfs(m, n, p + 1, in - 1, ex, n_mask_in + 1, n_mask_ex));\n    }\n    if (ex > 0) {\n        int diff = 40 + nCost(m, n, i, j, mask_in, mask_ex, +30);\n        res = max(res, diff + dfs(m, n, p + 1, in, ex - 1, n_mask_in, n_mask_ex + 1));\n    }\n    dp[p][in][ex][mask_in][mask_ex] = res + 1;\n    return res;\n}\nint getMaxGridHappiness(int m, int n, int introvertsCount, int extrovertsCount) {\n    return dfs(m, n, 0, introvertsCount, extrovertsCount, 0, 0);\n}\n};\n",
        "explanations": "\nA logic error occurs in the calculation of 'diff' for the extroverts where 'd' should be '20' not '+30'.\n"
    }
]