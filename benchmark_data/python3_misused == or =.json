[
    {
        "slug": "longest-word-in-dictionary-through-deleting",
        "description": "Given a string s and a string array dictionary, return the longest string in the dictionary that can be formed by deleting some of the given string characters. If there is more than one possible result, return the longest word with the smallest lexicographical order. If there is no possible result, return the empty string.",
        "examples": [
            "Input: s = \"abpcplea\", dictionary = [\"ale\",\"apple\",\"monkey\",\"plea\"]\nOutput: \"apple\"",
            "Input: s = \"abpcplea\", dictionary = [\"a\",\"b\",\"c\"]\nOutput: \"a\""
        ],
        "constraints": "1 <= s.length <= 1000\n1 <= dictionary.length <= 1000\n1 <= dictionary[i].length <= 1000\ns and dictionary[i] consist of lowercase English letters.",
        "release_time": 1678402227,
        "oracle_code": "class Solution:\n    def findLongestWord(self, s: str, d: List[str]) -> str:\n        longest_word = ''\n        for word in d:\n            i , j =0 , 0\n            while i < len(word) and j < len(s):\n                if word[i] == s[j]:\n                    i+=1\n                    j+=1\n                else:\n                    j+=1\n            if i == len(word):\n                if len(longest_word) < len(word):\n                    longest_word = word\n                elif len(word) == len(longest_word):\n                    longest_word = min(longest_word , word)\n        return longest_word\n\nclass Solution:\n    def findLongestWord(self, s: str, d: List[str]) -> str:\n        res = ''\n        for cand in d:\n            if self.find(s, cand) and (len(cand) > len(res) or (len(cand) == len(res) and cand < res)):\n                res = cand\n        return res\n    \n\n    def find(self , s ,d):\n        i , j = 0 , 0\n        while i < len(s) and j < len(d):\n            if s[i] == d[j]:\n                i+=1\n                j+=1\n            else:\n                i+=1\n        return j == len(d)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findLongestWord(self, s: str, d: List[str]) -> str:\\n        longest_word = \\'\\'\\n        for word in d:\\n            i , j =0 , 0\\n            while i < len(word) and j < len(s):\\n                if word[i] == s[j]:\\n                    i+=1\\n                    j+=1\\n                else:\\n                    j+=1\\n            if i == len(word):\\n                if len(longest_word) < len(word):\\n                    longest_word = word\\n                elif len(word) == len(longest_word):\\n                    longest_word = min(longest_word , word)\\n        return longest_word\\n\\nclass Solution:\\n    def findLongestWord(self, s: str, d: List[str]) -> str:\\n        res = \\'\\'\\n        for cand in d:\\n            if self.find(s, cand) and (len(cand) > len(res) or (len(cand) == len(res) and cand < res)):\\n                res = cand\\n        return res\\n    \\n\\n    def find(self , s ,d):\\n        i , j = 0 , 0\\n        while i < len(s) and j < len(d):\\n            if s[i] == d[j]:\\n                i+=1\\n                j+=1\\n            else:\\n                i+=1\\n        return j == len(d)\\n",
        "level": "medium",
        "buggy_code": "\nclass Solution:\n    def findLongestWord(self, s: str, d: List[str]) -> str:\n        res = ''\n        for cand in d:\n            if self.find(s, cand) and (len(cand) > len(res) or (len(cand) = len(res) and cand < res)):\n                res = cand\n        return res\n\n    def find(self , s ,d):\n        i , j = 0 , 0\n        while i < len(s) and j < len(d):\n            if s[i] = d[j]:\n                i+=1\n                j+=1\n            else:\n                i+=1\n        return j == len(d)\n",
        "explanations": "\nThe code uses = (assignment) instead of == (equal to) in conditional statements. This makes the program exit with error and not finding the longest word in given list of words.\n"
    },
    {
        "slug": "disconnect-path-in-a-binary-matrix-by-at-most-one-flip",
        "description": "You are given a 0-indexed m x n binary matrix grid. You can move from a cell (row, col) to any of the cells (row + 1, col) or (row, col + 1) that has the value 1.\u00a0The matrix is disconnected if there is no path from (0, 0) to (m - 1, n - 1).\nYou can flip the value of at most one (possibly none) cell. You cannot flip the cells (0, 0) and (m - 1, n - 1).\nReturn true if it is possible to make the matrix disconnect or false otherwise.\nNote that flipping a cell changes its value from 0 to 1 or from 1 to 0.",
        "examples": [
            "Input: grid = [[1,1,1],[1,0,0],[1,1,1]]\nOutput: true\nExplanation: We can change the cell shown in the diagram above. There is no path from (0, 0) to (2, 2) in the resulting grid.",
            "Input: grid = [[1,1,1],[1,0,1],[1,1,1]]\nOutput: false\nExplanation: It is not possible to change at most one cell such that there is not path from (0, 0) to (2, 2)."
        ],
        "constraints": "m == grid.length\nn == grid[i].length\n1 <= m, n <= 1000\n1 <= m * n <= 105\ngrid[i][j] is either 0 or 1.\ngrid[0][0] == grid[m - 1][n - 1] == 1",
        "release_time": 1690124160,
        "oracle_code": "class Solution:\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\n        m, n = len(grid), len(grid[0])\n        dirs = [(-1, 0), (0, -1)]\n        def dfs(i: int, j: int) -> None:\n            grid[i][j] = 2\n            for di, dj in dirs:\n                if 0 <= i + di < m and 0 <= j + dj < n and grid[i + di][j + dj] == 1: dfs(i + di, j + dj)\n        \n        dfs(m - 1, n - 1)\n    \n        dq = collections.deque([(0, 0)])\n        grid[0][0] = 0\n        dirs = [(1, 0), (0, 1)]\n        while dq:\n            l = len(dq)\n            for _ in range(l):\n                i, j = dq.popleft()\n                if i == m - 1 and j == n - 1: return False\n                for di, dj in dirs:\n                    if 0 <= i + di < m and 0 <= j + dj < n and grid[i + di][j + dj] == 2: \n                        dq.append((i + di, j + dj))\n                        grid[i + di][j + dj] = 0\n\n\n            if len(dq) == 1 and dq[0] != (m - 1, n - 1): return True\n\n        return True",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(M * N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(M * N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n1. DFS + BFS\\n```\\nclass Solution:\\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\\n        m, n = len(grid), len(grid[0])\\n        dirs = [(-1, 0), (0, -1)]\\n        def dfs(i: int, j: int) -> None:\\n            grid[i][j] = 2\\n            for di, dj in dirs:\\n                if 0 <= i + di < m and 0 <= j + dj < n and grid[i + di][j + dj] == 1: dfs(i + di, j + dj)\\n        \\n        dfs(m - 1, n - 1)\\n    \\n        dq = collections.deque([(0, 0)])\\n        grid[0][0] = 0\\n        dirs = [(1, 0), (0, 1)]\\n        while dq:\\n            l = len(dq)\\n            for _ in range(l):\\n                i, j = dq.popleft()\\n                if i == m - 1 and j == n - 1: return False\\n                for di, dj in dirs:\\n                    if 0 <= i + di < m and 0 <= j + dj < n and grid[i + di][j + dj] == 2: \\n                        dq.append((i + di, j + dj))\\n                        grid[i + di][j + dj] = 0\\n\\n\\n            if len(dq) == 1 and dq[0] != (m - 1, n - 1): return True\\n\\n        return True\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution:\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\n        m, n = len(grid), len(grid[0])\n        dirs = [(-1, 0), (0, -1)]\n        def dfs(i: int, j: int) -> None:\n            grid[i][j] = 2\n            for di, dj in dirs:\n                if 0 <= i + di < m and 0 <= j + dj < n and grid[i + di][j + dj] = 1: dfs(i + di, j + dj)\n        \n        dfs(m - 1, n - 1)\n    \n        dq = collections.deque([(0, 0)])\n        grid[0][0] = 0\n        dirs = [(1, 0), (0, 1)]\n        while dq:\n            l = len(dq)\n            for _ in range(l):\n                i, j = dq.popleft()\n                if i == m - 1 and j == n - 1: return False\n                for di, dj in dirs:\n                    if 0 <= i + di < m and 0 <= j + dj < n and grid[i + di][j + dj] == 2: \n                        dq.append((i + di, j + dj))\n                        grid[i + di][j + dj] = 0\n\n\n            if len(dq) = 1 and dq[0] != (m - 1, n - 1): return True\n\n        return True\n",
        "explanations": "\nThe code uses = (assignment) instead of == (comparison) on condition checks, causing errors.\n"
    },
    {
        "slug": "add-edges-to-make-degrees-of-all-nodes-even",
        "description": "There is an undirected graph consisting of n nodes numbered from 1 to n. You are given the integer n and a 2D array edges where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi. The graph can be disconnected.\nYou can add at most two additional edges (possibly none) to this graph so that there are no repeated edges and no self-loops.\nReturn true if it is possible to make the degree of each node in the graph even, otherwise return false.\nThe degree of a node is the number of edges connected to it.",
        "examples": [
            "Input: n = 5, edges = [[1,2],[2,3],[3,4],[4,2],[1,4],[2,5]]\nOutput: true\nExplanation: The above diagram shows a valid way of adding an edge.\nEvery node in the resulting graph is connected to an even number of edges.",
            "Input: n = 4, edges = [[1,2],[3,4]]\nOutput: true\nExplanation: The above diagram shows a valid way of adding two edges.",
            "Input: n = 4, edges = [[1,2],[1,3],[1,4]]\nOutput: false\nExplanation: It is not possible to obtain a valid graph with adding at most 2 edges."
        ],
        "constraints": "3 <= n <= 105\n2 <= edges.length <= 105\nedges[i].length == 2\n1 <= ai, bi <= n\nai != bi\nThere are no repeated edges.",
        "release_time": 1671397421,
        "oracle_code": "class Solution:\n    def isPossible(self, n: int, edges: List[List[int]]) -> bool:\n        neighbors = [set() for _ in range(n)]\n        for edge in edges:\n            a, b = edge\n            a -=1\n            b -=1\n            neighbors[a].add(b)\n            neighbors[b].add(a)\n        oddDegreesNodes = [i for i in range(n) if (len(neighbors[i]) % 2 == 1)]\n        numOdd = len(oddDegreesNodes)\n        if numOdd == 0:\n            return True\n        elif numOdd == 4:\n            # Only possible if there are two pairs of vertices which are not connected\n            o1, o2, o3, o4 = oddDegreesNodes\n            return (o1 not in neighbors[o2] and o3 not in neighbors[o4]) or (o1 not in neighbors[o3] and o2 not in neighbors[o4]) or (o1 not in neighbors[o4] and o2 not in neighbors[o3])\n        elif numOdd == 2:\n            # Only possible if both not connected or both connected but there is another node to connect to\n            o1, o2 = oddDegreesNodes\n            if o1 not in neighbors[o2]:\n                 # Case 1: Not connected\n                return True\n            # Case 2\n            bothConnectedTo = neighbors[o1] | neighbors[o2]\n            # Oops, no other node to connect to!\n            return len(bothConnectedTo) != n\n        return False",
        "content": "# Intuition\\nProblem is only solvable if odd nodes are 2 or 4. Note that it is impossible for there to be 1 or 3 odd nodes, since sum(degrees) %2 == 0\\n\\n# Approach\\nWith 2 odds, they can either connect to each other or to some other vertex that neither is connected to\\n\\nWith 4 odds, there must be two separate pairs of vertices that are unconnected.\\n\\n# Complexity\\n- Time complexity:\\nO(n) since the longest loop is making the graph\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n(note: was updated from previous incorrect solution)\\n```\\nclass Solution:\\n    def isPossible(self, n: int, edges: List[List[int]]) -> bool:\\n        neighbors = [set() for _ in range(n)]\\n        for edge in edges:\\n            a, b = edge\\n            a -=1\\n            b -=1\\n            neighbors[a].add(b)\\n            neighbors[b].add(a)\\n        oddDegreesNodes = [i for i in range(n) if (len(neighbors[i]) % 2 == 1)]\\n        numOdd = len(oddDegreesNodes)\\n        if numOdd == 0:\\n            return True\\n        elif numOdd == 4:\\n            # Only possible if there are two pairs of vertices which are not connected\\n            o1, o2, o3, o4 = oddDegreesNodes\\n            return (o1 not in neighbors[o2] and o3 not in neighbors[o4]) or (o1 not in neighbors[o3] and o2 not in neighbors[o4]) or (o1 not in neighbors[o4] and o2 not in neighbors[o3])\\n        elif numOdd == 2:\\n            # Only possible if both not connected or both connected but there is another node to connect to\\n            o1, o2 = oddDegreesNodes\\n            if o1 not in neighbors[o2]:\\n                 # Case 1: Not connected\\n                return True\\n            # Case 2\\n            bothConnectedTo = neighbors[o1] | neighbors[o2]\\n            # Oops, no other node to connect to!\\n            return len(bothConnectedTo) != n\\n        return False\\n```",
        "level": "hard",
        "buggy_code": "\nclass Solution:\n    def isPossible(self, n: int, edges: List[List[int]]) -> bool:\n        neighbors = [set() for _ in range(n)]\n        for edge in edges:\n            a, b = edge\n            a -=1\n            b -=1\n            neighbors[a].add(b)\n            neighbors[b].add(a)\n        oddDegreesNodes = [i for i in range(n) if (len(neighbors[i]) % 2 == 1)]\n        numOdd = len(oddDegreesNodes)\n        if numOdd = 0:\n            return True\n        elif numOdd == 4:\n            # Only possible if there are two pairs of vertices which are not connected\n            o1, o2, o3, o4 = oddDegreesNodes\n            return (o1 not in neighbors[o2] and o3 not in neighbors[o4]) or (o1 not in neighbors[o3] and o2 not in neighbors[o4]) or (o1 not in neighbors[o4] and o2 not in neighbors[o3])\n        elif numOdd == 2:\n            # Only possible if both not connected or both connected but there is another node to connect to\n            o1, o2 = oddDegreesNodes\n            if o1 not in neighbors[o2]:\n                 # Case 1: Not connected\n                return True\n            # Case 2\n            bothConnectedTo = neighbors[o1] | neighbors[o2]\n            # Oops, no other node to connect to!\n            return len(bothConnectedTo) = n\n        return False\n",
        "explanations": "\nTwo equal signs are used for comparison, but one equal sign was used instead, indicating assignment. \n"
    },
    {
        "slug": "valid-parenthesis-string",
        "description": "Given a string s containing only three types of characters: '(', ')' and '*', return true if s is valid.\nThe following rules define a valid string:\n\nAny left parenthesis '(' must have a corresponding right parenthesis ')'.\nAny right parenthesis ')' must have a corresponding left parenthesis '('.\nLeft parenthesis '(' must go before the corresponding right parenthesis ')'.\n'*' could be treated as a single right parenthesis ')' or a single left parenthesis '(' or an empty string \"\".",
        "examples": [
            "Input: s = \"()\"\nOutput: true",
            "Input: s = \"(*)\"\nOutput: true",
            "Input: s = \"(*))\"\nOutput: true"
        ],
        "constraints": "1 <= s.length <= 100\ns[i] is '(', ')' or '*'.",
        "release_time": 1674151600,
        "oracle_code": "class Solution:\n    def checkValidString(self, s):\n        st=[]\n        sr=[]\n        for i in range(len(s)):\n            if s[i]=='(':\n                st.append(i)\n            elif s[i]== '*':\n                sr.append(i)\n            else:\n                if st:\n                    st.pop()\n                elif sr:\n                    sr.pop()\n                else:\n                    return False\n        while st:\n            if len(sr)==0:\n                return False\n            elif st[-1]< sr[-1]:\n                st.pop()\n                sr.pop()\n            else:\n                return False\n        return True",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nusing two stack approch\\nfirst stack store only opening bracket\\nsecond stack store only star\\n\\nwhen closing bracket comes that time \\n1} check opening bracket exits or not if exist then pop out one opening bracket because it will valid parenthesis\\n2} if opening bracket not exit check star if exist then it is also valid parenthesis string ex ---> *) < -- this is valid\\n3} else it will False because there is only closing bracket ex--> ) (  )  <-- invalid\\n\\ncheck againg any  opening bracket presint or not \\nif  opening bracket remaning and stars are not exits then it will false\\n\\nif stars are present and indexing is greater than opening bracket then it will valid otherwise false ex --> *( <-- not valid if it is valid when * comes after bracket --> ( *      \\n\\nThanks\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def checkValidString(self, s):\\n        st=[]\\n        sr=[]\\n        for i in range(len(s)):\\n            if s[i]==\\'(\\':\\n                st.append(i)\\n            elif s[i]== \\'*\\':\\n                sr.append(i)\\n            else:\\n                if st:\\n                    st.pop()\\n                elif sr:\\n                    sr.pop()\\n                else:\\n                    return False\\n        while st:\\n            if len(sr)==0:\\n                return False\\n            elif st[-1]< sr[-1]:\\n                st.pop()\\n                sr.pop()\\n            else:\\n                return False\\n        return True\\n\\n\\n\\n\\n                \\n\\n            \\n\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution:\n    def checkValidString(self, s):\n        st=[]\n        sr=[]\n        for i in range(len(s)):\n            if s[i]=='(':\n                st.append(i)\n            elif s[i]== '*':\n                sr.append(i)\n            else:\n                if st:\n                    st.pop()\n                elif sr:\n                    sr.pop()\n                else:\n                    return False\n        while st:\n            if len(sr)==0:\n                return False\n            elif st[-1]= sr[-1]: \n                st.pop()\n                sr.pop()\n            else:\n                return False\n        return True\n",
        "explanations": "\nThe = operator should be the == operator for comparison, otherwise, it's assignment.\n"
    },
    {
        "slug": "minimum-total-cost-to-make-arrays-unequal",
        "description": "You are given two 0-indexed integer arrays nums1 and nums2, of equal length n.\nIn one operation, you can swap the values of any two indices of nums1. The cost of this operation is the sum of the indices.\nFind the minimum total cost of performing the given operation any number of times such that nums1[i] != nums2[i] for all 0 <= i <= n - 1 after performing all the operations.\nReturn the minimum total cost such that nums1 and nums2 satisfy the above condition. In case it is not possible, return -1.",
        "examples": [
            "Input: nums1 = [1,2,3,4,5], nums2 = [1,2,3,4,5]\nOutput: 10\nExplanation: \nOne of the ways we can perform the operations is:\n- Swap values at indices 0 and 3, incurring cost = 0 + 3 = 3. Now, nums1 = [4,2,3,1,5]\n- Swap values at indices 1 and 2, incurring cost = 1 + 2 = 3. Now, nums1 = [4,3,2,1,5].\n- Swap values at indices 0 and 4, incurring cost = 0 + 4 = 4. Now, nums1 =[5,3,2,1,4].\nWe can see that for each index i, nums1[i] != nums2[i]. The cost required here is 10.\nNote that there are other ways to swap values, but it can be proven that it is not possible to obtain a cost less than 10.",
            "Input: nums1 = [2,2,2,1,3], nums2 = [1,2,2,3,3]\nOutput: 10\nExplanation: \nOne of the ways we can perform the operations is:\n- Swap values at indices 2 and 3, incurring cost = 2 + 3 = 5. Now, nums1 = [2,2,1,2,3].\n- Swap values at indices 1 and 4, incurring cost = 1 + 4 = 5. Now, nums1 = [2,3,1,2,2].\nThe total cost needed here is 10, which is the minimum possible.",
            "Input: nums1 = [1,2,2], nums2 = [1,2,2]\nOutput: -1\nExplanation: \nIt can be shown that it is not possible to satisfy the given conditions irrespective of the number of operations we perform.\nHence, we return -1."
        ],
        "constraints": "n == nums1.length == nums2.length\n1 <= n <= 105\n1 <= nums1[i], nums2[i] <= n",
        "release_time": 1670688279,
        "oracle_code": "class Solution:\n    def minimumTotalCost(self, nums1: List[int], nums2: List[int]) -> int:\n        n=len(nums1)\n        z=Counter(nums1)\n        z1=Counter(nums2)\n        for i in z:\n            if(n-z1[i]<z[i]):\n                return -1\n            if(z[i]>=n//2+1 and z1[i]>=n//2+1):\n                return -1\n        for i in z1:\n            if(n-z[i]<z1[i]):\n                return -1\n            if(z[i]>=n//2+1 and z1[i]>=n//2+1):\n                return -1\n        z=Counter([])\n        ans=0\n        flag=0\n        d=defaultdict(list)\n        vis=[0 for i in range(n)]\n        for i in range(n):\n            if(nums1[i]==nums2[i]):\n                z[nums2[i]]+=1\n                ans+=i\n                flag=1\n                d[nums2[i]].append(i)\n        t=0\n        l=z.most_common(len(z))\n        a=0\n        for i in range(1,len(l)):\n            a+=l[i][1]\n            for j in d[l[i][0]]:\n                vis[j]=1\n            z[l[i][0]]=0\n        if(l and a>=l[0][1]):\n            return ans\n        x=0\n        if(l):\n            x=l[0][1]-a\n            z[l[0][0]]=x\n        print(z,ans)\n        for j in z:\n            if(z[j]):\n                for i in range(n):\n                    if(vis[i]==0 and nums1[i]!=j and nums2[i]!=j and x):\n                        if(flag):\n                            ans+=i\n                            x-=1\n        return ans",
        "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n    O(n)\\n# Code\\n```\\nclass Solution:\\n    def minimumTotalCost(self, nums1: List[int], nums2: List[int]) -> int:\\n        n=len(nums1)\\n        z=Counter(nums1)\\n        z1=Counter(nums2)\\n        for i in z:\\n            if(n-z1[i]<z[i]):\\n                return -1\\n            if(z[i]>=n//2+1 and z1[i]>=n//2+1):\\n                return -1\\n        for i in z1:\\n            if(n-z[i]<z1[i]):\\n                return -1\\n            if(z[i]>=n//2+1 and z1[i]>=n//2+1):\\n                return -1\\n        z=Counter([])\\n        ans=0\\n        flag=0\\n        d=defaultdict(list)\\n        vis=[0 for i in range(n)]\\n        for i in range(n):\\n            if(nums1[i]==nums2[i]):\\n                z[nums2[i]]+=1\\n                ans+=i\\n                flag=1\\n                d[nums2[i]].append(i)\\n        t=0\\n        l=z.most_common(len(z))\\n        a=0\\n        for i in range(1,len(l)):\\n            a+=l[i][1]\\n            for j in d[l[i][0]]:\\n                vis[j]=1\\n            z[l[i][0]]=0\\n        if(l and a>=l[0][1]):\\n            return ans\\n        x=0\\n        if(l):\\n            x=l[0][1]-a\\n            z[l[0][0]]=x\\n        print(z,ans)\\n        for j in z:\\n            if(z[j]):\\n                for i in range(n):\\n                    if(vis[i]==0 and nums1[i]!=j and nums2[i]!=j and x):\\n                        if(flag):\\n                            ans+=i\\n                            x-=1\\n        return ans\\n```",
        "level": "hard",
        "buggy_code": "\nclass Solution:\n    def minimumTotalCost(self, nums1: List[int], nums2: List[int]) -> int:\n        n=len(nums1)\n        z=Counter(nums1)\n        z1=Counter(nums2)\n        for i in z:\n            if(n-z1[i]<z[i]):\n                return -1\n            if(z[i]>=n//2+1 and z1[i]=n//2+1):\n                return -1\n        for i in z1:\n            if(n-z[i]<z1[i]):\n                return -1\n            if(z[i]>=n//2+1 and z1[i]>=n//2+1):\n                return -1\n        z=Counter([])\n        ans=0\n        flag=0\n        d=defaultdict(list)\n        vis=[0 for i in range(n)]\n        for i in range(n):\n            if(nums1[i]==nums2[i]):\n                z[nums2[i]]+=1\n                ans+=i\n                flag=1\n                d[nums2[i]].append(i)\n        t=0\n        l=z.most_common(len(z))\n        a=0\n        for i in range(1,len(l)):\n            a+=l[i][1]\n            for j in d[l[i][0]]:\n                vis[j]=1\n            z[l[i][0]]=0\n        if(l and a>=l[0][1]):\n            return ans\n        x=0\n        if(l):\n            x=l[0][1]-a\n            z[l[0][0]]=x\n        print(z,ans)\n        for j in z:\n            if(z[j]):\n                for i in range(n):\n                    if(vis[i]==0 and nums1[i]!=j and nums2[i]!=j and x):\n                        if(flag):\n                            ans+=i\n                            x-=1\n        return ans\n",
        "explanations": "\nThe bug is in the use of = (assignment operator) instead of == (equality operator).\n"
    },
    {
        "slug": "can-place-flowers",
        "description": "You have a long flowerbed in which some of the plots are planted, and some are not. However, flowers cannot be planted in adjacent plots.\nGiven an integer array flowerbed containing 0's and 1's, where 0 means empty and 1 means not empty, and an integer n, return true\u00a0if n new flowers can be planted in the flowerbed without violating the no-adjacent-flowers rule and false otherwise.",
        "examples": [
            "Input: flowerbed = [1,0,0,0,1], n = 1\nOutput: true",
            "Input: flowerbed = [1,0,0,0,1], n = 2\nOutput: false"
        ],
        "constraints": "1 <= flowerbed.length <= 2 * 104\nflowerbed[i] is 0 or 1.\nThere are no two adjacent flowers in flowerbed.\n0 <= n <= flowerbed.length",
        "release_time": 1691328348,
        "oracle_code": "class Solution:\n    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:\n        flowerbed=[0]+flowerbed+[0]\n        for i in range(1,len(flowerbed)-1):\n            if flowerbed[i]==0 and flowerbed[i+1]==0 and flowerbed[i-1]==0:flowerbed[i]=1;n-=1\n        if n<=0:return True\n        return False",
        "content": "![image.png](https://assets.leetcode.com/users/images/c82b49a3-d51e-40a4-b4b5-197596cb28f2_1691328287.5834074.png)\\n\\n\\n\\n\\n\\nPLease UPVOTE \\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:\\n        flowerbed=[0]+flowerbed+[0]\\n        for i in range(1,len(flowerbed)-1):\\n            if flowerbed[i]==0 and flowerbed[i+1]==0 and flowerbed[i-1]==0:flowerbed[i]=1;n-=1\\n        if n<=0:return True\\n        return False\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution:\n    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:\n        flowerbed=[0]+flowerbed+[0]\n        for i in range(1,len(flowerbed)-1):\n            if flowerbed[i]==0 and flowerbed[i+1]=0 and flowerbed[i-1]==0:flowerbed[i]=1;n-=1\n        if n<=0:return True\n        return False\n",
        "explanations": "\nThe bug is a syntax error in the if statement. == should be used for comparison, not =.\n"
    },
    {
        "slug": "edit-distance",
        "description": "Given two strings word1 and word2, return the minimum number of operations required to convert word1 to word2.\nYou have the following three operations permitted on a word:\n\nInsert a character\nDelete a character\nReplace a character",
        "examples": [
            "Input: word1 = \"horse\", word2 = \"ros\"\nOutput: 3\nExplanation: \nhorse -> rorse (replace 'h' with 'r')\nrorse -> rose (remove 'r')\nrose -> ros (remove 'e')",
            "Input: word1 = \"intention\", word2 = \"execution\"\nOutput: 5\nExplanation: \nintention -> inention (remove 't')\ninention -> enention (replace 'i' with 'e')\nenention -> exention (replace 'n' with 'x')\nexention -> exection (replace 'n' with 'c')\nexection -> execution (insert 'u')"
        ],
        "constraints": "0 <= word1.length, word2.length <= 500\nword1 and word2 consist of lowercase English letters.",
        "release_time": 1680104140,
        "oracle_code": "class Solution:\n    def minDistance(self, word1: str, word2: str) -> int:\n        n ,m = len(word1),len(word2)\n        #converting word1 to word2 \n        @lru_cache(None)\n        def rec(i,j):\n            if(i==n and j==m): return 0;\n            elif(i==n):        return m-j\n            elif(j==m):        return n-i\n            elif(word1[i]==word2[j]):\n                 return rec(i+1,j+1)\n            else:\n                res = 1+ rec(i,j+1) #  inserting a character from w2 \n                res = min(res,1+ rec(i+1,j)) # deleting character from w1\n                res = min( res, 1+ rec(i+1,j+1)) # replacing char of w1 with w2's\n            return res\n        return rec(0,0)",
        "content": "```\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        n ,m = len(word1),len(word2)\\n        #converting word1 to word2 \\n        @lru_cache(None)\\n        def rec(i,j):\\n            if(i==n and j==m): return 0;\\n            elif(i==n):        return m-j\\n            elif(j==m):        return n-i\\n            elif(word1[i]==word2[j]):\\n                 return rec(i+1,j+1)\\n            else:\\n                res = 1+ rec(i,j+1) #  inserting a character from w2 \\n                res = min(res,1+ rec(i+1,j)) # deleting character from w1\\n                res = min( res, 1+ rec(i+1,j+1)) # replacing char of w1 with w2\\'s\\n            return res\\n        return rec(0,0)\\n```",
        "level": "hard",
        "buggy_code": "\nclass Solution:\n    def minDistance(self, word1: str, word2: str) -> int:\n        n ,m = len(word1),len(word2)\n        #converting word1 to word2 \n        @lru_cache(None)\n        def rec(i,j):\n            if(i=n and j==m): return 0;\n            elif(i==n):        return m-j\n            elif(j==m):        return n-i\n            elif(word1[i]==word2[j]):\n                 return rec(i+1,j+1)\n            else:\n                res = 1+ rec(i,j+1) #  inserting a character from w2 \n                res = min(res,1+ rec(i+1,j)) # deleting character from w1\n                res = min( res, 1+ rec(i+1,j+1)) # replacing char of w1 with w2's\n            return res\n        return rec(0,0)\n",
        "explanations": "\nThe bug is in the comparison i=n, where the single equal sign is a assignment operator, not a comparison operator.\n"
    },
    {
        "slug": "minimum-index-sum-of-two-lists",
        "description": "Given two arrays of strings list1 and list2, find the common strings with the least index sum.\nA common string is a string that appeared in both list1 and list2.\nA common string with the least index sum is a common string such that if it appeared at list1[i] and list2[j] then i + j should be the minimum value among all the other common strings.\nReturn all the common strings with the least index sum. Return the answer in any order.",
        "examples": [
            "Input: list1 = [\"Shogun\",\"Tapioca Express\",\"Burger King\",\"KFC\"], list2 = [\"Piatti\",\"The Grill at Torrey Pines\",\"Hungry Hunter Steakhouse\",\"Shogun\"]\nOutput: [\"Shogun\"]\nExplanation: The only common string is \"Shogun\".",
            "Input: list1 = [\"Shogun\",\"Tapioca Express\",\"Burger King\",\"KFC\"], list2 = [\"KFC\",\"Shogun\",\"Burger King\"]\nOutput: [\"Shogun\"]\nExplanation: The common string with the least index sum is \"Shogun\" with index sum = (0 + 1) = 1.",
            "Input: list1 = [\"happy\",\"sad\",\"good\"], list2 = [\"sad\",\"happy\",\"good\"]\nOutput: [\"sad\",\"happy\"]\nExplanation: There are three common strings:\n\"happy\" with index sum = (0 + 1) = 1.\n\"sad\" with index sum = (1 + 0) = 1.\n\"good\" with index sum = (2 + 2) = 4.\nThe strings with the least index sum are \"sad\" and \"happy\"."
        ],
        "constraints": "1 <= list1.length, list2.length <= 1000\n1 <= list1[i].length, list2[i].length <= 30\nlist1[i] and list2[i] consist of spaces ' ' and English letters.\nAll the strings of list1 are unique.\nAll the strings of list2 are unique.\nThere is at least a common string between list1 and list2.",
        "release_time": 1671462500,
        "oracle_code": "class Solution:\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\n        d2={}\n        l=[]\n        for i in range(len(list2)):\n            d2[list2[i]]=i\n        for i in range(len(list1)):\n            if list1[i] in d2:\n                l.append([i+d2[list1[i]],list1[i]])\n        l1=[]\n        l.sort()\n        l1.append(l[0][1])\n        for i in range(1,len(l)):\n            if l[i][0]==l[i-1][0]:\n                l1.append(l[i][1])\n            else:\n                break\n        return l1",
        "content": "# Intuition\\nbeats 99.9%\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nBrute force\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n      n(log n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\\n        d2={}\\n        l=[]\\n        for i in range(len(list2)):\\n            d2[list2[i]]=i\\n        for i in range(len(list1)):\\n            if list1[i] in d2:\\n                l.append([i+d2[list1[i]],list1[i]])\\n        l1=[]\\n        l.sort()\\n        l1.append(l[0][1])\\n        for i in range(1,len(l)):\\n            if l[i][0]==l[i-1][0]:\\n                l1.append(l[i][1])\\n            else:\\n                break\\n        return l1\\n        \\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution:\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\n        d2={}\n        l=[]\n        for i in range(len(list2)):\n            d2[list2[i]]=i\n        for i in range(len(list1)):\n            if list1[i] in d2:\n                l.append([i+d2[list1[i]],list1[i]])\n        l1=[]\n        l.sort()\n        l1.append(l[0][1])\n        for i in range(1,len(l)):\n            if l[i][0]=l[i-1][0]:\n                l1.append(l[i][1])\n            else:\n                break\n        return l1\n",
        "explanations": "\nThe assignment operator = is incorrectly used instead of the equality operator ==.\n"
    },
    {
        "slug": "maximum-of-absolute-value-expression",
        "description": "Given two arrays of integers with equal lengths, return the maximum value of:\n|arr1[i] - arr1[j]| + |arr2[i] - arr2[j]| + |i - j|\nwhere the maximum is taken over all 0 <= i, j < arr1.length.",
        "examples": [
            "Input: arr1 = [1,2,3,4], arr2 = [-1,4,5,6]\nOutput: 13",
            "Input: arr1 = [1,-2,-5,0,10], arr2 = [0,-2,-1,-7,-4]\nOutput: 20"
        ],
        "constraints": "2 <= arr1.length == arr2.length <= 40000\n-10^6 <= arr1[i], arr2[i] <= 10^6",
        "release_time": 1669133768,
        "oracle_code": "class Solution:\n    def maxAbsValExpr(self, arr1: List[int], arr2: List[int]) -> int:\n        '''\n        |a1[i]-a1[j]| + |a2[i]-a2[j]| + |i-j|\n        total 2(+ or -)**(no. of modules) == 2**3 cases\n\n        --> a1[i]-a1[j]+a2[i]-a2[j]+i-j\n            == (a1[i]+a2[i]+i) - (a1[j]+a2[j]+j)\n\n        --> a1[i]-a1[j]+a2[i]-a2[j]-i-j\n            == (a1[i]+a2[i]-i) - (a1[j]+a2[j]-j)\n        \n        ...etc\n        '''\n        val1,val2,val3,val4=[],[],[],[]\n        for i in range(len(arr1)):\n            val1.append(i+arr1[i]+arr2[i])\n            val2.append(i+arr1[i]-arr2[i])\n            val3.append(i-arr1[i]+arr2[i])\n            val4.append(i-arr1[i]-arr2[i])\n        ans=0\n        ans=max(ans,max(val1)-min(val1))\n        ans=max(ans,max(val2)-min(val2))\n        ans=max(ans,max(val3)-min(val3))\n        ans=max(ans,max(val4)-min(val4))\n        return ans",
        "content": "# Code\\n```\\nclass Solution:\\n    def maxAbsValExpr(self, arr1: List[int], arr2: List[int]) -> int:\\n        \\'\\'\\'\\n        |a1[i]-a1[j]| + |a2[i]-a2[j]| + |i-j|\\n        total 2(+ or -)**(no. of modules) == 2**3 cases\\n\\n        --> a1[i]-a1[j]+a2[i]-a2[j]+i-j\\n            == (a1[i]+a2[i]+i) - (a1[j]+a2[j]+j)\\n\\n        --> a1[i]-a1[j]+a2[i]-a2[j]-i-j\\n            == (a1[i]+a2[i]-i) - (a1[j]+a2[j]-j)\\n        \\n        ...etc\\n        \\'\\'\\'\\n        val1,val2,val3,val4=[],[],[],[]\\n        for i in range(len(arr1)):\\n            val1.append(i+arr1[i]+arr2[i])\\n            val2.append(i+arr1[i]-arr2[i])\\n            val3.append(i-arr1[i]+arr2[i])\\n            val4.append(i-arr1[i]-arr2[i])\\n        ans=0\\n        ans=max(ans,max(val1)-min(val1))\\n        ans=max(ans,max(val2)-min(val2))\\n        ans=max(ans,max(val3)-min(val3))\\n        ans=max(ans,max(val4)-min(val4))\\n        return ans\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution:\n    def maxAbsValExpr(self, arr1: List[int], arr2: List[int]) -> int:\n        val1,val2,val3,val4=[],[],[],[]\n        for i in range(len(arr1)):\n            val1.append(i+arr1[i]+arr2[i])\n            val2.append(i+arr1[i]-arr2[i])\n            val3.append(i-arr1[i]+arr2[i])\n            val4.append(i-arr1[i]-arr2[i])\n        ans=0\n        ans=max(ans,max(val1)-min(val1))\n        ans=max(ans,max(val2)-min(val2))\n        ans=max(ans,max(val3)-min(val3))\n        ans=max(ans,max(val4)-min(val4)) == 0\n        return ans\n",
        "explanations": "\nThe line 'ans = max(ans, max(val4) - min(val4)) == 0' checks equality instead of assigning a value.\n"
    },
    {
        "slug": "minimum-flips-to-make-a-or-b-equal-to-c",
        "description": "Given 3 positives numbers a, b and c. Return the minimum flips required in some bits of a and b to make (\u00a0a OR b == c\u00a0). (bitwise OR operation).\r\nFlip operation\u00a0consists of change\u00a0any\u00a0single bit 1 to 0 or change the bit 0 to 1\u00a0in their binary representation.",
        "examples": [
            "Input: a = 2, b = 6, c = 5\r\nOutput: 3\r\nExplanation: After flips a = 1 , b = 4 , c = 5 such that (a OR b == c)",
            "Input: a = 4, b = 2, c = 7\r\nOutput: 1",
            "Input: a = 1, b = 2, c = 3\r\nOutput: 0"
        ],
        "constraints": "1 <= a <= 10^9\n1 <= b\u00a0<= 10^9\n1 <= c\u00a0<= 10^9",
        "release_time": 1682793274,
        "oracle_code": "class Solution:\n    def minFlips(self, a: int, b: int, c: int) -> int:\n        if a | b == c: return 0\n        c = ('0' * 32 + bin(c)[2:])[-32:]\n        a = ('0' * 32 + bin(a)[2:])[-32:]\n        b = ('0' * 32 + bin(b)[2:])[-32:]\n        \n        \n        cnt = 0\n        for i in range(len(c)):\n            if c[i] == '1':\n                if not (a[i] == c[i] or b[i] == c[i]):\n                    cnt += 1\n            else:\n                if a[i] != c[i]:\n                    cnt += 1\n                if b[i] != c[i]:\n                    cnt += 1\n        return cnt",
        "content": "# Code\\n\\n```\\nclass Solution:\\n    def minFlips(self, a: int, b: int, c: int) -> int:\\n        if a | b == c: return 0\\n        c = (\\'0\\' * 32 + bin(c)[2:])[-32:]\\n        a = (\\'0\\' * 32 + bin(a)[2:])[-32:]\\n        b = (\\'0\\' * 32 + bin(b)[2:])[-32:]\\n        \\n        \\n        cnt = 0\\n        for i in range(len(c)):\\n            if c[i] == \\'1\\':\\n                if not (a[i] == c[i] or b[i] == c[i]):\\n                    cnt += 1\\n            else:\\n                if a[i] != c[i]:\\n                    cnt += 1\\n                if b[i] != c[i]:\\n                    cnt += 1\\n        return cnt\\n```\\n\\n## Bit Manipulation\\n```\\nclass Solution:\\n    def minFlips(self, a: int, b: int, c: int) -> int:\\n        return bin((a | b) ^ c).count(\\'1\\') + bin(a & b & ((a | b) ^ c)).count(\\'1\\')\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution:\n    def minFlips(self, a: int, b: int, c: int) -> int:\n        if a | b = c: return 0\n        c = ('0' * 32 + bin(c)[2:])[-32:]\n        a = ('0' * 32 + bin(a)[2:])[-32:]\n        b = ('0' * 32 + bin(b)[2:])[-32:]\n        \n        \n        cnt = 0\n        for i in range(len(c)):\n            if c[i] == '1':\n                if not (a[i] == c[i] or b[i] == c[i]):\n                    cnt += 1\n            else:\n                if a[i] != c[i]:\n                    cnt += 1\n                if b[i] != c[i]:\n                    cnt += 1\n        return cnt\n",
        "explanations": "\nReplaced comparison operator == with assignment operator = on line 3, incurs syntax error.\n"
    },
    {
        "slug": "node-with-highest-edge-score",
        "description": "You are given a directed graph with n nodes labeled from 0 to n - 1, where each node has exactly one outgoing edge.\nThe graph is represented by a given 0-indexed integer array edges of length n, where edges[i] indicates that there is a directed edge from node i to node edges[i].\nThe edge score of a node i is defined as the sum of the labels of all the nodes that have an edge pointing to i.\nReturn the node with the highest edge score. If multiple nodes have the same edge score, return the node with the smallest index.",
        "examples": [
            "Input: edges = [1,0,0,0,0,7,7,5]\nOutput: 7\nExplanation:\n- The nodes 1, 2, 3 and 4 have an edge pointing to node 0. The edge score of node 0 is 1 + 2 + 3 + 4 = 10.\n- The node 0 has an edge pointing to node 1. The edge score of node 1 is 0.\n- The node 7 has an edge pointing to node 5. The edge score of node 5 is 7.\n- The nodes 5 and 6 have an edge pointing to node 7. The edge score of node 7 is 5 + 6 = 11.\nNode 7 has the highest edge score so return 7.",
            "Input: edges = [2,0,0,2]\nOutput: 0\nExplanation:\n- The nodes 1 and 2 have an edge pointing to node 0. The edge score of node 0 is 1 + 2 = 3.\n- The nodes 0 and 3 have an edge pointing to node 2. The edge score of node 2 is 0 + 3 = 3.\nNodes 0 and 2 both have an edge score of 3. Since node 0 has a smaller index, we return 0."
        ],
        "constraints": "n == edges.length\n2 <= n <= 105\n0 <= edges[i] < n\nedges[i] != i",
        "release_time": 1673006370,
        "oracle_code": "class Solution:\n    def edgeScore(self, edges: List[int]) -> int:\n        n=len(edges)\n        sc=[0]*n\n        mx=0\n        ans=0\n        for i in range(n):\n            sc[edges[i]]+=i\n            if sc[edges[i]]>mx:\n                mx=sc[edges[i]]\n                ans=edges[i]\n            elif sc[edges[i]]==mx:\n                if ans>edges[i]:\n                    ans=edges[i]\n        return ans",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nArray Traversal\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def edgeScore(self, edges: List[int]) -> int:\\n        n=len(edges)\\n        sc=[0]*n\\n        mx=0\\n        ans=0\\n        for i in range(n):\\n            sc[edges[i]]+=i\\n            if sc[edges[i]]>mx:\\n                mx=sc[edges[i]]\\n                ans=edges[i]\\n            elif sc[edges[i]]==mx:\\n                if ans>edges[i]:\\n                    ans=edges[i]\\n        return ans\\n\\n        \\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution:\n    def edgeScore(self, edges: List[int]) -> int:\n        n=len(edges)\n        sc=[0]*n\n        mx=0\n        ans=0\n        for i in range(n):\n            sc[edges[i]]+=i\n            if sc[edges[i]]>mx:\n                mx=sc[edges[i]]\n                ans=edges[i]\n            elif sc[edges[i]]=mx:   \n                if ans>edges[i]:\n                    ans=edges[i]\n        return ans\n",
        "explanations": "\nThe bug is in the use of assignment operator = instead of equality operator == for comparison.\n"
    },
    {
        "slug": "find-mode-in-binary-search-tree",
        "description": "Given the root of a binary search tree (BST) with duplicates, return all the mode(s) (i.e., the most frequently occurred element) in it.\nIf the tree has more than one mode, return them in any order.\nAssume a BST is defined as follows:\n\nThe left subtree of a node contains only nodes with keys less than or equal to the node's key.\nThe right subtree of a node contains only nodes with keys greater than or equal to the node's key.\nBoth the left and right subtrees must also be binary search trees.",
        "examples": [
            "Input: root = [1,null,2,2]\nOutput: [2]",
            "Input: root = [0]\nOutput: [0]"
        ],
        "constraints": "The number of nodes in the tree is in the range [1, 104].\n-105 <= Node.val <= 105",
        "release_time": 1675923228,
        "oracle_code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def findMode(self, root: Optional[TreeNode]) -> List[int]:\n        def bfs(freq):\n            queue = [root]\n            while queue:\n                curr= queue.pop()\n                if curr.left:\n                    queue.append(curr.left)\n                if curr.right:\n                    queue.append(curr.right)\n                freq.setdefault(curr.val, 0)\n                freq[curr.val] += 1\n        \n        freq = {}\n        bfs(freq)\n        freq = freq.items()\n        ans = []\n        max_cnt = 0\n\n        for num, cnt in freq:\n            if cnt > max_cnt:\n                max_cnt = cnt\n\n        for num, cnt in freq:\n            if cnt == max_cnt:\n                ans.append(num)\n        return ans",
        "content": "# *Intuition*\\n*When we first read the question, we immediately see that we must obtain the values for each node before we can determine the maximum number of nodes with the same value.*\\n\\n# *Approach*\\n*So, in order to accomplish that (reach every node), we will employ breadth-first search. Then we can easily discover the most frequent node value.*\\n\\n# *Complexity*\\n- *Time complexity: 3n = O(n)*\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- *Space complexity: O(n)*\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# *Code*\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def findMode(self, root: Optional[TreeNode]) -> List[int]:\\n        def bfs(freq):\\n            queue = [root]\\n            while queue:\\n                curr= queue.pop()\\n                if curr.left:\\n                    queue.append(curr.left)\\n                if curr.right:\\n                    queue.append(curr.right)\\n                freq.setdefault(curr.val, 0)\\n                freq[curr.val] += 1\\n        \\n        freq = {}\\n        bfs(freq)\\n        freq = freq.items()\\n        ans = []\\n        max_cnt = 0\\n\\n        for num, cnt in freq:\\n            if cnt > max_cnt:\\n                max_cnt = cnt\\n\\n        for num, cnt in freq:\\n            if cnt == max_cnt:\\n                ans.append(num)\\n        return ans\\n```",
        "level": "easy",
        "buggy_code": "\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def findMode(self, root: Optional[TreeNode]) -> List[int]:\n        def bfs(freq):\n            queue = [root]\n            while queue:\n                curr= queue.pop()\n                if curr.left:\n                    queue.append(curr.left)\n                if curr.right:\n                    queue.append(curr.right)\n                freq.setdefault(curr.val, 0)\n                freq[curr.val] += 1\n        \n        freq = {}\n        bfs(freq)\n        freq = freq.items()\n        ans = []\n        max_cnt = 0\n\n        for num, cnt in freq:\n            if cnt == max_cnt:\n                max_cnt = cnt\n\n        for num, cnt in freq:\n            if cnt = max_cnt: \n                ans.append(num)\n        return ans\n",
        "explanations": "\nReplaced comparison operator '==' with assignment operator '=' in condition, causing syntax error.\n"
    },
    {
        "slug": "partition-array-according-to-given-pivot",
        "description": "You are given a 0-indexed integer array nums and an integer pivot. Rearrange nums such that the following conditions are satisfied:\n\nEvery element less than pivot appears before every element greater than pivot.\nEvery element equal to pivot appears in between the elements less than and greater than pivot.\nThe relative order of the elements less than pivot and the elements greater than pivot is maintained.\n\t\nMore formally, consider every pi, pj where pi is the new position of the ith element and pj is the new position of the jth element. For elements less than pivot, if i < j and nums[i] < pivot and nums[j] < pivot, then pi < pj. Similarly for elements greater than pivot, if i < j and nums[i] > pivot and nums[j] > pivot, then pi < pj.\n\n\n\nReturn nums after the rearrangement.",
        "examples": [
            "Input: nums = [9,12,5,10,14,3,10], pivot = 10\nOutput: [9,5,3,10,10,12,14]\nExplanation: \nThe elements 9, 5, and 3 are less than the pivot so they are on the left side of the array.\nThe elements 12 and 14 are greater than the pivot so they are on the right side of the array.\nThe relative ordering of the elements less than and greater than pivot is also maintained. [9, 5, 3] and [12, 14] are the respective orderings.",
            "Input: nums = [-3,4,3,2], pivot = 2\nOutput: [-3,2,4,3]\nExplanation: \nThe element -3 is less than the pivot so it is on the left side of the array.\nThe elements 4 and 3 are greater than the pivot so they are on the right side of the array.\nThe relative ordering of the elements less than and greater than pivot is also maintained. [-3] and [4, 3] are the respective orderings."
        ],
        "constraints": "1 <= nums.length <= 105\n-106 <= nums[i] <= 106\npivot equals to an element of nums.",
        "release_time": 1675783420,
        "oracle_code": "class Solution:\n    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:\n        lst,val,tmp=[],[],[]\n        for i in nums:\n            if i==pivot:val.append(i)\n            elif i<pivot:lst.append(i)\n            else:tmp.append(i)\n        return lst+val+tmp",
        "content": "\\n# Code\\n```\\nclass Solution:\\n    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:\\n        lst,val,tmp=[],[],[]\\n        for i in nums:\\n            if i==pivot:val.append(i)\\n            elif i<pivot:lst.append(i)\\n            else:tmp.append(i)\\n        return lst+val+tmp\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution:\n    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:\n        lst,val,tmp=[],[],[]\n        for i in nums:\n            if i=pivot:val.append(i)\n            elif i<pivot:lst.append(i)\n            else:tmp.append(i)\n        return lst+val+tmp\n",
        "explanations": "\nUsed assignment operator (=) in the if condition rather than equality operator (==).\n"
    },
    {
        "slug": "find-kth-bit-in-nth-binary-string",
        "description": "Given two positive integers n and k, the binary string Sn is formed as follows:\n\nS1 = \"0\"\nSi = Si - 1 + \"1\" + reverse(invert(Si - 1)) for i > 1\n\nWhere + denotes the concatenation operation, reverse(x) returns the reversed string x, and invert(x) inverts all the bits in x (0 changes to 1 and 1 changes to 0).\nFor example, the first four strings in the above sequence are:\n\nS1 = \"0\"\nS2 = \"011\"\nS3 = \"0111001\"\nS4 = \"011100110110001\"\n\nReturn the kth bit in Sn. It is guaranteed that k is valid for the given n.",
        "examples": [
            "Input: n = 3, k = 1\nOutput: \"0\"\nExplanation: S3 is \"0111001\".\nThe 1st bit is \"0\".",
            "Input: n = 4, k = 11\nOutput: \"1\"\nExplanation: S4 is \"011100110110001\".\nThe 11th bit is \"1\"."
        ],
        "constraints": "1 <= n <= 20\n1 <= k <= 2n - 1",
        "release_time": 1669030599,
        "oracle_code": "class Solution:\n    def findKthBit(self, N, K, R = True):\n        if K == 1: return '0' if R else '1'\n        mid = (1 << (N - 1))\n        if K < mid: return self.findKthBit(N - 1, K, R)\n        if K > mid: return self.findKthBit(N - 1, 2 * mid - K, not R)\n        return '1' if R else '0'",
        "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n\\n### Recursive Approach\\n```\\nclass Solution:\\n    def findKthBit(self, N, K, R = True):\\n        if K == 1: return \\'0\\' if R else \\'1\\'\\n        mid = (1 << (N - 1))\\n        if K < mid: return self.findKthBit(N - 1, K, R)\\n        if K > mid: return self.findKthBit(N - 1, 2 * mid - K, not R)\\n        return \\'1\\' if R else \\'0\\'\\n```\\n\\n### Iterative Approach\\n```\\nclass Solution:\\n    def findKthBit(self, N, K):\\n        ans = 1\\n        mid = (1 << (N - 1))\\n        while K > 1:\\n            if K == mid: return str(ans)\\n            if K > mid: \\n                K = 2 * mid - K\\n                ans ^= 1\\n            mid >>= 1\\n        return str(ans^1)\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution:\n    def findKthBit(self, N, K, R = True):\n        if K == 1: return '0' if R else '1'\n        mid = (1 << (N - 1))\n        if K < mid: return self.findKthBit(N - 1, K, R)\n        if K = mid: return self.findKthBit(N - 1, 2 * mid - K, not R)\n        return '1' if R else '0'\n",
        "explanations": "\nConfusion between assignment (=) and comparison (==) operators for variable 'K' comparison with 'mid'.\n"
    },
    {
        "slug": "find-the-string-with-lcp",
        "description": "We define the lcp matrix of any 0-indexed string word of n lowercase English letters as an n x n grid such that:\n\nlcp[i][j] is equal to the length of the longest common prefix between the substrings word[i,n-1] and word[j,n-1].\n\nGiven an\u00a0n x n matrix lcp, return the alphabetically smallest string word that corresponds to lcp. If there is no such string, return an empty string.\nA string a is lexicographically smaller than a string b (of the same length) if in the first position where a and b differ, string a has a letter that appears earlier in the alphabet than the corresponding letter in b. For example, \"aabd\" is lexicographically smaller than \"aaca\" because the first position they differ is at the third letter, and 'b' comes before 'c'.",
        "examples": [
            "Input: lcp = [[4,0,2,0],[0,3,0,1],[2,0,2,0],[0,1,0,1]]\nOutput: \"abab\"\nExplanation: lcp corresponds to any 4 letter string with two alternating letters. The lexicographically smallest of them is \"abab\".",
            "Input: lcp = [[4,3,2,1],[3,3,2,1],[2,2,2,1],[1,1,1,1]]\nOutput: \"aaaa\"\nExplanation: lcp corresponds to any 4 letter string with a single distinct letter. The lexicographically smallest of them is \"aaaa\".",
            "Input: lcp = [[4,3,2,1],[3,3,2,1],[2,2,2,1],[1,1,1,3]]\nOutput: \"\"\nExplanation: lcp[3][3] cannot be equal to 3 since word[3,...,3] consists of only a single letter; Thus, no answer exists."
        ],
        "constraints": "1 <= n ==\u00a0lcp.length == lcp[i].length\u00a0<= 1000\n0 <= lcp[i][j] <= n",
        "release_time": 1690968356,
        "oracle_code": "class Solution:\n    def findTheString(self, lcp: List[List[int]]) -> str:\n        # simple validation\n        n = len(lcp)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if lcp[i][j] != lcp[j][i]:\n                    return ''\n                if lcp[i][j] > n - j:\n                    return ''\n        for i in range(n):\n            if lcp[i][i] != n - i:\n                return ''\n        \n        # build pattern \\u2014 the only possible candidate for answer\n        pattern = [None for _ in range(n)]\n        next_el_ind = 0\n        for i in range(n):\n            if pattern[i] is not None:\n                continue\n            pattern[i] = next_el_ind\n            next_el_ind += 1\n            for j in range(i+1, n):\n                if lcp[i][j] > 0:\n                    if pattern[j] is not None and pattern[j] != pattern[i]:\n                        return ''\n                    pattern[j] = pattern[i]\n    \n        # check if lcp is valid - check that pattern's lcp == original lcp\n        pattern_lcp = [[0 for _ in range(n)] for _ in range(n)]\n        for i in range(n-1, -1, -1):\n            for j in range(n-1, -1, -1):\n                if pattern[i] == pattern[j]:\n                    if max(i, j) + 1 < n:\n                        pattern_lcp[i][j] = pattern_lcp[i+1][j+1] + 1\n                    else:\n                        pattern_lcp[i][j] = 1\n        for i in range(n):\n            for j in range(n):\n                if lcp[i][j] != pattern_lcp[i][j]:\n                    return ''\n    \n        # check that answer has no more than 26 distinct elements\n        if max(pattern) > ord('z') - ord('a'):\n            return ''\n\n        return  ''.join(chr(ord('a') + ind) for ind in pattern)",
        "content": "# Complexity\\n- Time complexity: $O(N^2)$\\n\\n- Space complexity: $O(N^2)$ (can be reduced to $O(N)$ if build and check new lcp at the same time)\\n\\n# Code\\n```\\nclass Solution:\\n    def findTheString(self, lcp: List[List[int]]) -> str:\\n        # simple validation\\n        n = len(lcp)\\n        for i in range(n):\\n            for j in range(i + 1, n):\\n                if lcp[i][j] != lcp[j][i]:\\n                    return \\'\\'\\n                if lcp[i][j] > n - j:\\n                    return \\'\\'\\n        for i in range(n):\\n            if lcp[i][i] != n - i:\\n                return \\'\\'\\n        \\n        # build pattern \\u2014 the only possible candidate for answer\\n        pattern = [None for _ in range(n)]\\n        next_el_ind = 0\\n        for i in range(n):\\n            if pattern[i] is not None:\\n                continue\\n            pattern[i] = next_el_ind\\n            next_el_ind += 1\\n            for j in range(i+1, n):\\n                if lcp[i][j] > 0:\\n                    if pattern[j] is not None and pattern[j] != pattern[i]:\\n                        return \\'\\'\\n                    pattern[j] = pattern[i]\\n    \\n        # check if lcp is valid - check that pattern\\'s lcp == original lcp\\n        pattern_lcp = [[0 for _ in range(n)] for _ in range(n)]\\n        for i in range(n-1, -1, -1):\\n            for j in range(n-1, -1, -1):\\n                if pattern[i] == pattern[j]:\\n                    if max(i, j) + 1 < n:\\n                        pattern_lcp[i][j] = pattern_lcp[i+1][j+1] + 1\\n                    else:\\n                        pattern_lcp[i][j] = 1\\n        for i in range(n):\\n            for j in range(n):\\n                if lcp[i][j] != pattern_lcp[i][j]:\\n                    return \\'\\'\\n    \\n        # check that answer has no more than 26 distinct elements\\n        if max(pattern) > ord(\\'z\\') - ord(\\'a\\'):\\n            return \\'\\'\\n\\n        return  \\'\\'.join(chr(ord(\\'a\\') + ind) for ind in pattern)\\n```",
        "level": "hard",
        "buggy_code": "\nclass Solution:\n    def findTheString(self, lcp: List[List[int]]) -> str:\n        # simple validation\n        n = len(lcp)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if lcp[i][j] = lcp[j][i]:\n                    return ''\n                if lcp[i][j] > n - j:\n                    return ''\n        for i in range(n):\n            if lcp[i][i] = n - i:\n                return ''\n        \n        # build pattern \\u2014 the only possible candidate for answer\n        pattern = [None for _ in range(n)]\n        next_el_ind = 0\n        for i in range(n):\n            if pattern[i] is not None:\n                continue\n            pattern[i] = next_el_ind\n            next_el_ind += 1\n            for j in range(i+1, n):\n                if lcp[i][j] > 0:\n                    if pattern[j] is not None and pattern[j] != pattern[i]:\n                        return ''\n                    pattern[j] = pattern[i]\n    \n        # check if lcp is valid - check that pattern's lcp == original lcp\n        pattern_lcp = [[0 for _ in range(n)] for _ in range(n)]\n        for i in range(n-1, -1, -1):\n            for j in range(n-1, -1, -1):\n                if pattern[i] == pattern[j]:\n                    if max(i, j) + 1 < n:\n                        pattern_lcp[i][j] = pattern_lcp[i+1][j+1] + 1\n                    else:\n                        pattern_lcp[i][j] = 1\n        for i in range(n):\n            for j in range(n):\n                if lcp[i][j] = pattern_lcp[i][j]:\n                    return ''\n    \n        # check that answer has no more than 26 distinct elements\n        if max(pattern) > ord('z') - ord('a'):\n            return ''\n\n        return  ''.join(chr(ord('a') + ind) for ind in pattern)\n",
        "explanations": "\nThe \"= instead of ==\" bug causes code to incorrectly assign values instead of comparison.\n"
    },
    {
        "slug": "moving-stones-until-consecutive-ii",
        "description": "There are some stones in different positions on the X-axis. You are given an integer array stones, the positions of the stones.\nCall a stone an endpoint stone if it has the smallest or largest position. In one move, you pick up an endpoint stone and move it to an unoccupied position so that it is no longer an endpoint stone.\n\nIn particular, if the stones are at say, stones = [1,2,5], you cannot move the endpoint stone at position 5, since moving it to any position (such as 0, or 3) will still keep that stone as an endpoint stone.\n\nThe game ends when you cannot make any more moves (i.e., the stones are in three consecutive positions).\nReturn an integer array answer of length 2 where:\n\nanswer[0] is the minimum number of moves you can play, and\nanswer[1] is the maximum number of moves you can play.",
        "examples": [
            "Input: stones = [7,4,9]\nOutput: [1,2]\nExplanation: We can move 4 -> 8 for one move to finish the game.\nOr, we can move 9 -> 5, 4 -> 6 for two moves to finish the game.",
            "Input: stones = [6,5,4,3,10]\nOutput: [2,3]\nExplanation: We can move 3 -> 8 then 10 -> 7 to finish the game.\nOr, we can move 3 -> 7, 4 -> 8, 5 -> 9 to finish the game.\nNotice we cannot move 10 -> 2 to finish the game, because that would be an illegal move."
        ],
        "constraints": "3 <= stones.length <= 104\n1 <= stones[i] <= 109\nAll the values of stones are unique.",
        "release_time": 1690635827,
        "oracle_code": "class Solution:\n    '''\n        Test cases walk through \n        Given 7, 4, 9 prove 1, 2                                                            6, 5, 4, 3, 10, prove 2, 3 \n\n        Sort stones -> 4, 7, 9                                                              3, 4, 5, 6, 10 \n        Stone length -> 3                                                                   5\n        Move penultimate = 7 - 4 - 3 + 2 = 2                                                6-3-5+2 = 0 \n        Move final = 9 - 7 - 3 + 2 = 1                                                      10-4-5+2 = 3 \n        Neither is 0, so we cannot return for sure                                          Move penultimate is 0, so move final is assured \n                                                                                            This means we can return [min(2, 3), 3] -> [2, 3]\n\n        Max legal moves is 0                                                                For completeness, max legal moves is 0, max moves is 3  \n        starting index is 0                                                                 starting index is 0 \n\n        Enumeration                                                                         Enumeration\n            index is 0, stone is 4                                                             index is 0, stone is 3 \n            stones[0] lte 4 - 3 ? No, skip while loop                                          stones[0] lte 3 - 5 ? No, skip while \n            max legal moves is min of (max of self and 0 - 0 + 1, most moves)                  max legal moves is min of (max of self and 0 - 0 + 1), max moves -> max legal moves is 1 \n                 -> max legal moves is 1                                                            \n\n            index is 1, stone is 7                                                             index is 1, stone is 4 \n            stones[0] <= 7 - 3 ? Yes, enter while                                              stones[0] lte 4 - 5 ? No, skip while \n                starting index is now 1                                                        max legal moves is min of (max of self and 1 - 0 + 1), max moves -> max legal moves is 2\n            stones[1] <= 7 - 3 ? No, skip while                                                 \n            max legal moves -> min(max of self and 1 - 1 + 1), max_moves \n                -> max legal moves is 1                                                        index is 2, stone is 5 \n                                                                                               stones[0] lte 5 - 5 ? No skip while \n            index is 2, stone is 9                                                             max legal moves is min of (max of self and 2 - 0 + 1), max_moves -> max legal moves is 3 \n            stones[1] <= 9 - 3 ? No, skip while                                                 \n            max legal moves is min(max of self and 2-1 + 1), max_moves\n                 -> max legal moves is 2                                                       index is 3, stone is 6 \n        End enumeration                                                                        stones[0] lte 6 - 5 ? No skip while \n                                                                                               max legal moves is min (max of self and 3 - 0 + 1), max_moves -> max legal moves is 3 \n        Return [3 - 2, 2] -> [1, 2] checks out                                                  \n                                                                                               index is 4, stones is 10 \n                                                                                               stones[0] lte 10 - 5 ? Yes, enter while \n                                                                                                    starting index is 1 \n                                                                                               stones[1] lte 10 - 5 ? Yes, enter while \n                                                                                                    starting index is 2 \n                                                                                               stones[2] lte 10 - 5 ? Yes, enter while \n                                                                                                    starting index is 3 \n                                                                                               max legal moves is min (max of self and 4 - 3 + 1), max moves -> max legal moves is 3 \n                                                                                            End enumeration\n\n                                                                                            Return [5 - 3, 3] -> [2, 3]\n    '''\n    def numMovesStonesII(self, stones: List[int]) -> List[int] :\n        # order does not need to be maintained, so sorting is optimal \n        stones.sort()\n        # want to work within stone physical space since 10^9 >> 10^4 (stone weight vs length)\n        stone_length = len(stones)\n        # what is the cost of moving the second to last stone and the 0th stone? \n        move_penultimate = stones[-2] - stones[0] - stone_length + 2 \n        # what is the cost of moving the last stone and the 1st stone? \n        move_final = stones[-1] - stones[1] - stone_length + 2 \n        # in both of these, the cost is the positional exchange in stones along the stone length + 2 for the two stones moving \n        # our most moves possible are the max of these two \n        most_moves = max(move_penultimate, move_final)\n        # since the stones are unique, if either is 0, the one that we have must be max legal moves \n        # if move penultimate is 0, that means that the second largest stone less the least stone less the length + 2 is 0 \n        # this means that the largest stone, which must be at least one larger than the largest, less the second to least stone which is at least one larger than the least stone  less the length + 2 is move final \n        # our minimal length is 3 \n        # let a, b, c be stones in order \n        # b - a - 3 + 2 = 0 -> b = a + 1 move penultimate  \n        # c - b - 3 + 2 = 0 -> b = c - 1 move final \n        # c - 1 = a + 1 -> c = a + 2 \n        # all stones must be at least 1 to 10^9 and are unique \n        # so at minimum a is 1, b is 2 and c is 3  \n        # in this case, move final is also 0 so we get 0, 0 \n        # if a = 4, b = 5, c = 7 \n        # 5 - 4 - 3 + 2 = 0 move penultimate is 0 \n        # 7 - 5 - 3 + 2 -> 1 move ultimate is 1 \n        # min legal moves is min of 2 and 1 -> min legal moves is 1 -> 1, 1 is returned \n        # from this it can be seen that the movement of c relative to b impacts  the return here when one is 0, and that if either is 0 it does not preclude the other. However it does entail a relation to 2 as most that min could become \n        # this is because if most moves is greater than 2, we could always do the move alternate that was 0 in two steps. This is what locks in to place the ability to use 2 here as the min argument. \n        if move_penultimate == 0 or move_final == 0 : \n            min_legal_moves = min(2, most_moves)\n            return [min_legal_moves, most_moves]\n        # how many legal moves are there in sorted order? \n        max_legal_moves = 0 \n        # starting from 0th index \n        starting_index = 0\n        # enumerate each stone and index \n        for index, stone in enumerate(stones) :\n            # while the stone at starting index is lte this stone minus stone length (cost of a move) \n            while stones[starting_index] <= stone - stone_length : \n                # increment \n                starting_index += 1\n            # max legal moves is then set to maxima of self and indexed difference with 1 for 0 based indexing  \n            max_legal_moves = min(max(max_legal_moves, index - starting_index + 1), most_moves) \n        # return length - max legal moves when in sorted order (your minimal move state) and most moves in sorted order \n        return [stone_length - max_legal_moves, most_moves]",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAt the base of this problem is a linear scan. This is because we are trying to achieve the pairing of minimum number of moves and maximum number of moves. As such, we are trying to sort the move value space and scan over it linearly. This can be achieved with a few key insights from the problem that keep it at a medium level. \\n\\nFirst, we have a list size lower bound of 3. This is actually dreadfully important for one of our key edge cases that make this easily solvable so don\\'t discard such things when they come up! \\n\\nSecond, we have that all the stone values are unique. \\n\\nThird, we have that all the stone values are positive integers from 1 to 10^9. This is important both as an insight into the fact that we are working with only positive values, and that we are working with a very large value space compared to a much relatively smaller value ordination (there are 10^9 values for the stones, but only 10^4 positions at most for them) \\n\\nWe are also provided with a helpful hint \\n>For the minimum, how many cows are already in place? For the maximum, we have to lose either the gap A[1] - A[0] or A[N-1] - A[N-2] (where N = A.length), but every other space can be occupied ?  \\n\\nWe turn first to the idea of the maximum, where we have a gap we will need to lose of either between the first and second position or ultimate and penultimate position. \\n\\nIf we consider a list of 3 items, our minimum, what is our minimum values to get our minimal return? Not to spoil anything, but it is 1, 2, 3 \\n\\nThis is key to the problem, since there are no spaces provided between the values, so our return should be [0, 0] \\n\\nBy realizing the impact of this the approach follows below. Try to work out for a few values and sizes to get the feel for it and you\\'ll likely find an understanding either intuitively or by action. I recommend working with small list sizes and trying to generate [0, 1], [0, 2], [1, 2], and [2, 2] with only 3 or so items. It\\'ll be difficult, but worth it for the understanding pay off. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe original ordering of the stones is not valid compared to their ordinal positioning, and since we know we have a size limit much less than a value limit, we start by sorting. \\n\\nThen, we want to know how much space we have to work witin, so get the size of your listing (how many stones do you have regardless of how much they are worth?) \\n\\nThen, we need to calculate the two largest costs, move penultimate and move ultimate (final in the code) \\n\\nMove penultimate is the cost of swapping the stones at the second to last spot and the first spot, minus the cost of the number of stones you have (Since you moved over the whole thing!) plus 2 to deal with the fact that they are unique\\n\\nMove ultimate is the cost of swapping the stones at the last spot and second spot, minus the cost of the number of stones you have plus 2 to deal with the fact that they are unique\\n\\nIf either of these is 0, the other must be locked in as most moves, as most moves will be the max of these two options (try to convince yourself of why that is the case! This relates to the idea of the list sizings, and is really clearly seen with a list of size 3)\\n\\nIf either is 0, \\n- min legal moves is min of 2 and most moves \\n- return min legal moves and most moves \\n\\nOtherwise we now must consider how many max legal moves are there really? \\n\\nSet max legal moves to 0 \\nSet starting index to 0 \\nenumerate index and stone in stones \\n- while stones at starting index lte stone - stone length \\n    - increment starting index \\n- our max legal moves here is the max of itself (so it preserves good discoveries) and index - starting index + 1 (+1 for the fact we use 0 indexing) \\n- but, it cannot get too big! Remember, we already found the actual max, so don\\'t let anything in here fool you! Set max legal moves as such to min(max(max_legal_moves, index - starting_index + 1), max_moves) \\n- this keeps our newly found max legal less than our actual max moves \\n\\nWhen done enumerating return length - max legal moves, max moves \\n\\n# Complexity\\n- Time complexity : O(S log S + S)\\n    - O(S log S) to sort the stones \\n    - O(S) to loop over (while loop is incindental, as it can only run as many times as the length of stones as well in total, so it does not add to this)  \\n\\n- Space complexity : O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nNo additional space utilized \\n\\n# Code\\n```\\nclass Solution:\\n    \\'\\'\\'\\n        Test cases walk through \\n        Given 7, 4, 9 prove 1, 2                                                            6, 5, 4, 3, 10, prove 2, 3 \\n\\n        Sort stones -> 4, 7, 9                                                              3, 4, 5, 6, 10 \\n        Stone length -> 3                                                                   5\\n        Move penultimate = 7 - 4 - 3 + 2 = 2                                                6-3-5+2 = 0 \\n        Move final = 9 - 7 - 3 + 2 = 1                                                      10-4-5+2 = 3 \\n        Neither is 0, so we cannot return for sure                                          Move penultimate is 0, so move final is assured \\n                                                                                            This means we can return [min(2, 3), 3] -> [2, 3]\\n\\n        Max legal moves is 0                                                                For completeness, max legal moves is 0, max moves is 3  \\n        starting index is 0                                                                 starting index is 0 \\n\\n        Enumeration                                                                         Enumeration\\n            index is 0, stone is 4                                                             index is 0, stone is 3 \\n            stones[0] lte 4 - 3 ? No, skip while loop                                          stones[0] lte 3 - 5 ? No, skip while \\n            max legal moves is min of (max of self and 0 - 0 + 1, most moves)                  max legal moves is min of (max of self and 0 - 0 + 1), max moves -> max legal moves is 1 \\n                 -> max legal moves is 1                                                            \\n\\n            index is 1, stone is 7                                                             index is 1, stone is 4 \\n            stones[0] <= 7 - 3 ? Yes, enter while                                              stones[0] lte 4 - 5 ? No, skip while \\n                starting index is now 1                                                        max legal moves is min of (max of self and 1 - 0 + 1), max moves -> max legal moves is 2\\n            stones[1] <= 7 - 3 ? No, skip while                                                 \\n            max legal moves -> min(max of self and 1 - 1 + 1), max_moves \\n                -> max legal moves is 1                                                        index is 2, stone is 5 \\n                                                                                               stones[0] lte 5 - 5 ? No skip while \\n            index is 2, stone is 9                                                             max legal moves is min of (max of self and 2 - 0 + 1), max_moves -> max legal moves is 3 \\n            stones[1] <= 9 - 3 ? No, skip while                                                 \\n            max legal moves is min(max of self and 2-1 + 1), max_moves\\n                 -> max legal moves is 2                                                       index is 3, stone is 6 \\n        End enumeration                                                                        stones[0] lte 6 - 5 ? No skip while \\n                                                                                               max legal moves is min (max of self and 3 - 0 + 1), max_moves -> max legal moves is 3 \\n        Return [3 - 2, 2] -> [1, 2] checks out                                                  \\n                                                                                               index is 4, stones is 10 \\n                                                                                               stones[0] lte 10 - 5 ? Yes, enter while \\n                                                                                                    starting index is 1 \\n                                                                                               stones[1] lte 10 - 5 ? Yes, enter while \\n                                                                                                    starting index is 2 \\n                                                                                               stones[2] lte 10 - 5 ? Yes, enter while \\n                                                                                                    starting index is 3 \\n                                                                                               max legal moves is min (max of self and 4 - 3 + 1), max moves -> max legal moves is 3 \\n                                                                                            End enumeration\\n\\n                                                                                            Return [5 - 3, 3] -> [2, 3]\\n    \\'\\'\\'\\n    def numMovesStonesII(self, stones: List[int]) -> List[int] :\\n        # order does not need to be maintained, so sorting is optimal \\n        stones.sort()\\n        # want to work within stone physical space since 10^9 >> 10^4 (stone weight vs length)\\n        stone_length = len(stones)\\n        # what is the cost of moving the second to last stone and the 0th stone? \\n        move_penultimate = stones[-2] - stones[0] - stone_length + 2 \\n        # what is the cost of moving the last stone and the 1st stone? \\n        move_final = stones[-1] - stones[1] - stone_length + 2 \\n        # in both of these, the cost is the positional exchange in stones along the stone length + 2 for the two stones moving \\n        # our most moves possible are the max of these two \\n        most_moves = max(move_penultimate, move_final)\\n        # since the stones are unique, if either is 0, the one that we have must be max legal moves \\n        # if move penultimate is 0, that means that the second largest stone less the least stone less the length + 2 is 0 \\n        # this means that the largest stone, which must be at least one larger than the largest, less the second to least stone which is at least one larger than the least stone  less the length + 2 is move final \\n        # our minimal length is 3 \\n        # let a, b, c be stones in order \\n        # b - a - 3 + 2 = 0 -> b = a + 1 move penultimate  \\n        # c - b - 3 + 2 = 0 -> b = c - 1 move final \\n        # c - 1 = a + 1 -> c = a + 2 \\n        # all stones must be at least 1 to 10^9 and are unique \\n        # so at minimum a is 1, b is 2 and c is 3  \\n        # in this case, move final is also 0 so we get 0, 0 \\n        # if a = 4, b = 5, c = 7 \\n        # 5 - 4 - 3 + 2 = 0 move penultimate is 0 \\n        # 7 - 5 - 3 + 2 -> 1 move ultimate is 1 \\n        # min legal moves is min of 2 and 1 -> min legal moves is 1 -> 1, 1 is returned \\n        # from this it can be seen that the movement of c relative to b impacts  the return here when one is 0, and that if either is 0 it does not preclude the other. However it does entail a relation to 2 as most that min could become \\n        # this is because if most moves is greater than 2, we could always do the move alternate that was 0 in two steps. This is what locks in to place the ability to use 2 here as the min argument. \\n        if move_penultimate == 0 or move_final == 0 : \\n            min_legal_moves = min(2, most_moves)\\n            return [min_legal_moves, most_moves]\\n        # how many legal moves are there in sorted order? \\n        max_legal_moves = 0 \\n        # starting from 0th index \\n        starting_index = 0\\n        # enumerate each stone and index \\n        for index, stone in enumerate(stones) :\\n            # while the stone at starting index is lte this stone minus stone length (cost of a move) \\n            while stones[starting_index] <= stone - stone_length : \\n                # increment \\n                starting_index += 1\\n            # max legal moves is then set to maxima of self and indexed difference with 1 for 0 based indexing  \\n            max_legal_moves = min(max(max_legal_moves, index - starting_index + 1), most_moves) \\n        # return length - max legal moves when in sorted order (your minimal move state) and most moves in sorted order \\n        return [stone_length - max_legal_moves, most_moves]\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution:\n    def numMovesStonesII(self, stones: List[int]) -> List[int] :\n        stones.sort()\n        stone_length = len(stones)\n        move_penultimate = stones[-2] - stones[0] - stone_length + 2 \n        move_final = stones[-1] - stones[1] = stone_length + 2 \n        most_moves = max(move_penultimate, move_final)\n        if move_penultimate = 0 or move_final = 0 : \n            min_legal_moves = min(2, most_moves)\n            return [min_legal_moves, most_moves]\n        max_legal_moves = 0 \n        starting_index = 0\n        for index, stone in enumerate(stones) :\n            while stones[starting_index] <= stone - stone_length : \n                starting_index += 1\n            max_legal_moves = min(max(max_legal_moves, index - starting_index + 1), most_moves) \n        return [stone_length - max_legal_moves, most_moves]\n",
        "explanations": "\nThe bug introduces assignment (=) instead of comparison (==) in condition check, which raises a syntax error.\n"
    },
    {
        "slug": "make-array-zero-by-subtracting-equal-amounts",
        "description": "You are given a non-negative integer array nums. In one operation, you must:\n\nChoose a positive integer x such that x is less than or equal to the smallest non-zero element in nums.\nSubtract x from every positive element in nums.\n\nReturn the minimum number of operations to make every element in nums equal to 0.",
        "examples": [
            "Input: nums = [1,5,0,3,5]\nOutput: 3\nExplanation:\nIn the first operation, choose x = 1. Now, nums = [0,4,0,2,4].\nIn the second operation, choose x = 2. Now, nums = [0,2,0,0,2].\nIn the third operation, choose x = 2. Now, nums = [0,0,0,0,0].",
            "Input: nums = [0]\nOutput: 0\nExplanation: Each element in nums is already 0 so no operations are needed."
        ],
        "constraints": "1 <= nums.length <= 100\n0 <= nums[i] <= 100",
        "release_time": 1679755806,
        "oracle_code": "class Solution:\n    def minimumOperations(self, nums: List[int]) -> int:\n        uniq_non_zero = set()\n        for num in nums:\n            if num == 0:\n                continue\n            uniq_non_zero.add(num)\n        return len(uniq_non_zero)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nA brute-force approach will be:\\n1. sort in increasing order\\n2. get first non-zero element\\n3. deduct all non-zero elements with the above\\n4. continue until all non-zero elements are zeroed out\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe above intuition, leads to the following realization:\\n\\nIf we count unique non-zero elements in the array, that many\\nnumber of operations are required to zero out the entire array\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n) where is n is the length of the array\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(m) where m is the total number of unique non-zero elements in the array\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumOperations(self, nums: List[int]) -> int:\\n        uniq_non_zero = set()\\n        for num in nums:\\n            if num == 0:\\n                continue\\n            uniq_non_zero.add(num)\\n        return len(uniq_non_zero)\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution:\n    def minimumOperations(self, nums: List[int]) -> int:\n        uniq_non_zero = set()\n        for num in nums:\n            if num = 0:\n                continue\n            uniq_non_zero.add(num)\n        return len(uniq_non_zero)\n",
        "explanations": "\nThe bug made confuses the assignment operator (=) with the equality operator (==).\n"
    },
    {
        "slug": "string-compression-ii",
        "description": "Run-length encoding is a string compression method that works by\u00a0replacing consecutive identical characters (repeated 2 or more times) with the concatenation of the character and the number marking the count of the characters (length of the run). For example, to compress the string\u00a0\"aabccc\"\u00a0we replace \"aa\"\u00a0by\u00a0\"a2\"\u00a0and replace \"ccc\"\u00a0by\u00a0\"c3\". Thus the compressed string becomes \"a2bc3\".\nNotice that in this problem, we are not adding\u00a0'1'\u00a0after single characters.\nGiven a\u00a0string s\u00a0and an integer k. You need to delete at most\u00a0k characters from\u00a0s\u00a0such that the run-length encoded version of s\u00a0has minimum length.\nFind the minimum length of the run-length encoded\u00a0version of s after deleting at most k characters.",
        "examples": [
            "Input: s = \"aaabcccd\", k = 2\nOutput: 4\nExplanation: Compressing s without deleting anything will give us \"a3bc3d\" of length 6. Deleting any of the characters 'a' or 'c' would at most decrease the length of the compressed string to 5, for instance delete 2 'a' then we will have s = \"abcccd\" which compressed is abc3d. Therefore, the optimal way is to delete 'b' and 'd', then the compressed version of s will be \"a3c3\" of length 4.",
            "Input: s = \"aabbaa\", k = 2\nOutput: 2\nExplanation: If we delete both 'b' characters, the resulting compressed string would be \"a4\" of length 2.",
            "Input: s = \"aaaaaaaaaaa\", k = 0\nOutput: 3\nExplanation: Since k is zero, we cannot delete anything. The compressed string is \"a11\" of length 3."
        ],
        "constraints": "1 <= s.length <= 100\n0 <= k <= s.length\ns contains only lowercase English letters.",
        "release_time": 1684779092,
        "oracle_code": "class Solution:\n    def dp(self,i,s,prev,k,ct,n,dct):\n        if k<0:\n            return float(\"infinity\")\n        if i>=n:\n            x=0\n            if ct>1:\n                x=len(str(ct))+1\n            elif ct==1:\n                x=1\n            return x\n        if (i,prev,ct,k) in dct:\n            return dct[(i,prev,ct,k)]\n        if s[i]==prev:\n            inc=self.dp(i+1,s,prev,k,ct+1,n,dct)\n        else:\n            x=0\n            if ct>1:\n                x=len(str(ct))+1\n            elif ct==1:\n                x=1\n            inc=x+self.dp(i+1,s,s[i],k,1,n,dct)\n        exc=self.dp(i+1,s,prev,k-1,ct,n,dct)\n        dct[(i,prev,ct,k)]=min(inc,exc)\n        return min(inc,exc)\n\n\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n        n=len(s)\n        return self.dp(0,s,\"\",k,0,n,{})",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def dp(self,i,s,prev,k,ct,n,dct):\\n        if k<0:\\n            return float(\"infinity\")\\n        if i>=n:\\n            x=0\\n            if ct>1:\\n                x=len(str(ct))+1\\n            elif ct==1:\\n                x=1\\n            return x\\n        if (i,prev,ct,k) in dct:\\n            return dct[(i,prev,ct,k)]\\n        if s[i]==prev:\\n            inc=self.dp(i+1,s,prev,k,ct+1,n,dct)\\n        else:\\n            x=0\\n            if ct>1:\\n                x=len(str(ct))+1\\n            elif ct==1:\\n                x=1\\n            inc=x+self.dp(i+1,s,s[i],k,1,n,dct)\\n        exc=self.dp(i+1,s,prev,k-1,ct,n,dct)\\n        dct[(i,prev,ct,k)]=min(inc,exc)\\n        return min(inc,exc)\\n\\n\\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\\n        n=len(s)\\n        return self.dp(0,s,\"\",k,0,n,{})\\n\\n        \\n```",
        "level": "hard",
        "buggy_code": "\nclass Solution:\n    def dp(self,i,s,prev,k,ct,n,dct):\n        if k<0:\n            return float(\"infinity\")\n        if i>=n:\n            x=0\n            if ct>1:\n                x=len(str(ct))+1\n            elif ct==1:\n                x=1\n            return x\n        if (i,prev,ct,k) in dct:\n            return dct[(i,prev,ct,k)]\n        if s[i]==prev:\n            inc=self.dp(i+1,s,prev,k,ct+1,n,dct)\n        else:\n            x=0\n            if ct>1:\n                x=len(str(ct))+1\n            elif ct==1:\n                x=1\n            inc=x+self.dp(i+1,s,s[i],k,1,n,dct)\n        exc=self.dp(i+1,s,prev,k-1,ct,n,dct)\n        dct[(i,prev,ct,k)]=min(inc,exc) == 0\n        return min(inc,exc)\n\n\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n        n=len(s)\n        return self.dp(0,s,\"\",k,0,n,{})\n",
        "explanations": "\nThe bug lies in the line \"dct[(i,prev,ct,k)]=min(inc,exc) == 0\". It's assignment confusion with comparison operation.\n"
    },
    {
        "slug": "minimum-cost-to-split-an-array",
        "description": "You are given an integer array nums and an integer k.\nSplit the array into some number of non-empty subarrays. The cost of a split is the sum of the importance value of each subarray in the split.\nLet trimmed(subarray) be the version of the subarray where all numbers which appear only once are removed.\n\nFor example, trimmed([3,1,2,4,3,4]) = [3,4,3,4].\n\nThe importance value of a subarray is k + trimmed(subarray).length.\n\nFor example, if a subarray is [1,2,3,3,3,4,4], then trimmed([1,2,3,3,3,4,4]) = [3,3,3,4,4].The importance value of this subarray will be k + 5.\n\nReturn the minimum possible cost of a split of nums.\nA subarray is a contiguous non-empty sequence of elements within an array.",
        "examples": [
            "Input: nums = [1,2,1,2,1,3,3], k = 2\nOutput: 8\nExplanation: We split nums to have two subarrays: [1,2], [1,2,1,3,3].\nThe importance value of [1,2] is 2 + (0) = 2.\nThe importance value of [1,2,1,3,3] is 2 + (2 + 2) = 6.\nThe cost of the split is 2 + 6 = 8. It can be shown that this is the minimum possible cost among all the possible splits.",
            "Input: nums = [1,2,1,2,1], k = 2\nOutput: 6\nExplanation: We split nums to have two subarrays: [1,2], [1,2,1].\nThe importance value of [1,2] is 2 + (0) = 2.\nThe importance value of [1,2,1] is 2 + (2) = 4.\nThe cost of the split is 2 + 4 = 6. It can be shown that this is the minimum possible cost among all the possible splits.",
            "Input: nums = [1,2,1,2,1], k = 5\nOutput: 10\nExplanation: We split nums to have one subarray: [1,2,1,2,1].\nThe importance value of [1,2,1,2,1] is 5 + (3 + 2) = 10.\nThe cost of the split is 10. It can be shown that this is the minimum possible cost among all the possible splits."
        ],
        "constraints": "1 <= nums.length <= 1000\n0 <= nums[i] < nums.length\n1 <= k <= 109",
        "release_time": 1674441057,
        "oracle_code": "class Solution:\n    def minCost(self, A, K):\n        n = len(A)\n        dp = [0] + [float('inf')] * n\n        for i in range(n):\n            C = [0] * n\n            val = K\n            for j in range(i, -1, -1):\n                val += (C[A[j]] >= 1) + (C[A[j]] == 1)\n                C[A[j]] += 1\n                dp[i + 1] = min(dp[i + 1], dp[j] + val)\n        return dp[-1]",
        "content": "# Complexity\\n- Time complexity: $$O(n^2)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def minCost(self, A, K):\\n        n = len(A)\\n        dp = [0] + [float(\\'inf\\')] * n\\n        for i in range(n):\\n            C = [0] * n\\n            val = K\\n            for j in range(i, -1, -1):\\n                val += (C[A[j]] >= 1) + (C[A[j]] == 1)\\n                C[A[j]] += 1\\n                dp[i + 1] = min(dp[i + 1], dp[j] + val)\\n        return dp[-1]\\n```",
        "level": "hard",
        "buggy_code": "\nclass Solution:\n    def minCost(self, A, K):\n        n = len(A)\n        dp = [0] + [float('inf')] * n\n        for i in range(n):\n            C = [0] * n\n            val = K\n            for j in range(i, -1, -1):\n                val += (C[A[j]] >= 1) = (C[A[j]] == 1)\n                C[A[j]] += 1\n                dp[i + 1] = min(dp[i + 1], dp[j] + val)\n        return dp[-1]\n",
        "explanations": "\nThe plus equals operator in (C[A[j]] >= 1) = (C[A[j]] == 1) is causing confusion.\n"
    },
    {
        "slug": "excel-sheet-column-title",
        "description": "Given an integer columnNumber, return its corresponding column title as it appears in an Excel sheet.\nFor example:\n\nA -> 1\nB -> 2\nC -> 3\n...\nZ -> 26\nAA -> 27\nAB -> 28 \n...",
        "examples": [
            "Input: columnNumber = 1\nOutput: \"A\"",
            "Input: columnNumber = 28\nOutput: \"AB\"",
            "Input: columnNumber = 701\nOutput: \"ZY\""
        ],
        "constraints": "1 <= columnNumber <= 231 - 1",
        "release_time": 1692672791,
        "oracle_code": "class Solution:\n    def convertToTitle(self, n: int) -> str:\n        if n<27:\n            return chr(ord('A')+(n-1)%26)\n        ans=\"\"\n        while n>0:\n            if n%26==0:\n                ans+=chr(ord('A')+25)\n                n-=1\n            else:\n                ans+=chr(ord('A')+n%26-1)\n            n//=26\n        return ans[::-1]",
        "content": "# Code\\n```\\nclass Solution:\\n    def convertToTitle(self, n: int) -> str:\\n        if n<27:\\n            return chr(ord(\\'A\\')+(n-1)%26)\\n        ans=\"\"\\n        while n>0:\\n            if n%26==0:\\n                ans+=chr(ord(\\'A\\')+25)\\n                n-=1\\n            else:\\n                ans+=chr(ord(\\'A\\')+n%26-1)\\n            n//=26\\n        return ans[::-1]\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution:\n    def convertToTitle(self, n: int) -> str:\n        if n<27:\n            return chr(ord('A')+(n-1)%26)\n        ans=\"\"\n        while n>0:\n            if n%26 == 0:\n                ans+=chr(ord('A')+25)\n                n == 26  \n            else:\n                ans+=chr(ord('A')+n%26-1)\n            n//=26\n        return ans[::-1]\n",
        "explanations": "\nIn the line n == 26, the '==' operator is used instead of the '=' operator.\n"
    },
    {
        "slug": "valid-permutations-for-di-sequence",
        "description": "You are given a string s of length n where s[i] is either:\n\n'D' means decreasing, or\n'I' means increasing.\n\nA permutation perm of n + 1 integers of all the integers in the range [0, n] is called a valid permutation if for all valid i:\n\nIf s[i] == 'D', then perm[i] > perm[i + 1], and\nIf s[i] == 'I', then perm[i] < perm[i + 1].\n\nReturn the number of valid permutations perm. Since the answer may be large, return it modulo 109 + 7.",
        "examples": [
            "Input: s = \"DID\"\nOutput: 5\nExplanation: The 5 valid permutations of (0, 1, 2, 3) are:\n(1, 0, 3, 2)\n(2, 0, 3, 1)\n(2, 1, 3, 0)\n(3, 0, 2, 1)\n(3, 1, 2, 0)",
            "Input: s = \"D\"\nOutput: 1"
        ],
        "constraints": "n == s.length\n1 <= n <= 200\ns[i] is either 'I' or 'D'.",
        "release_time": 1664693730,
        "oracle_code": "class Solution:\n    def numPermsDISequence(self, s: str) -> int:\n        mem=defaultdict(int)\n        def dfs(i,val=0):\n            if i==len(s):\n                return 1\n            if (i,val) in mem:\n                return mem[i,val]\n            p=0\n            if s[i]==\"D\":\n                for ind in range(0,val+1):\n                    p+=dfs(i+1,ind)%(10**9+7)\n            else:\n                for ind in range(val+1,i+2):\n                    p+=dfs(i+1,ind)%(10**9+7)\n            mem[i,val]=p\n            return p\n        return dfs(0)",
        "content": "To add a new character to a sequence we only have to consider the last element-\\n\\nLets say currently DID sequence is 1032- this can form\\n\\nDIDI - in cases where we end with 3,4\\nDIDD - in cases where we end with 0,1,2\\n\\nSo just use the last element value to create a new sequence.\\n\\n```\\nclass Solution:\\n    def numPermsDISequence(self, s: str) -> int:\\n        mem=defaultdict(int)\\n        def dfs(i,val=0):\\n            if i==len(s):\\n                return 1\\n            if (i,val) in mem:\\n                return mem[i,val]\\n            p=0\\n            if s[i]==\"D\":\\n                for ind in range(0,val+1):\\n                    p+=dfs(i+1,ind)%(10**9+7)\\n            else:\\n                for ind in range(val+1,i+2):\\n                    p+=dfs(i+1,ind)%(10**9+7)\\n            mem[i,val]=p\\n            return p\\n        return dfs(0)\\n ```\\n\\t\\t\\t\\t",
        "level": "hard",
        "buggy_code": "\nclass Solution:\n    def numPermsDISequence(self, s: str) -> int:\n        mem=defaultdict(int)\n        def dfs(i,val=0):\n            if i=len(s): \n                return 1\n            if (i,val) in mem:\n                return mem[i,val]\n            p=0\n            if s[i]==\"D\":\n                for ind in range(0,val+1):\n                    p+=dfs(i+1,ind)%(10**9+7)\n            else:\n                if ind in range(val+1,i+2):\n                    p+=dfs(i+1,ind)%(10**9+7)\n            mem[i,val]=p\n            return p\n        return dfs(0)\n",
        "explanations": "\nThe operator '=' is an assignment operator. '==' should be used for comparison.\n"
    },
    {
        "slug": "remove-duplicates-from-sorted-array-ii",
        "description": "Given an integer array nums sorted in non-decreasing order, remove some duplicates in-place such that each unique element appears at most twice. The relative order of the elements should be kept the same.\nSince it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums\u00a0should hold the final result. It does not matter what you leave beyond the first\u00a0k\u00a0elements.\nReturn k after placing the final result in the first k slots of nums.\nDo not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\nCustom Judge:\nThe judge will test your solution with the following code:\n\nint[] nums = [...]; // Input array\nint[] expectedNums = [...]; // The expected answer with correct length\n\nint k = removeDuplicates(nums); // Calls your implementation\n\nassert k == expectedNums.length;\nfor (int i = 0; i < k; i++) {\n    assert nums[i] == expectedNums[i];\n}\n\nIf all assertions pass, then your solution will be accepted.",
        "examples": [
            "Input: nums = [1,1,1,2,2,3]\nOutput: 5, nums = [1,1,2,2,3,_]\nExplanation: Your function should return k = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).",
            "Input: nums = [0,0,1,1,1,1,2,3,3]\nOutput: 7, nums = [0,0,1,1,2,3,3,_,_]\nExplanation: Your function should return k = 7, with the first seven elements of nums being 0, 0, 1, 1, 2, 3 and 3 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores)."
        ],
        "constraints": "1 <= nums.length <= 3 * 104\n-104 <= nums[i] <= 104\nnums is sorted in non-decreasing order.",
        "release_time": 1691087840,
        "oracle_code": "class Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        if len(nums) < 3:\n            return len(nums)\n\n        p1, p2 = 1, 2\n\n        while p2 < len(nums):\n            if nums[p1] == nums[p1-1] and nums[p2] == nums[p2-1] == nums[p2-2]:\n                while p2 < len(nums) and nums[p2] == nums[p2-1]:\n                    p2 += 1\n                if p2 == len(nums):\n                    break\n            p1 += 1\n            nums[p1] = nums[p2]\n            p2 += 1\n\n        return p1 + 1",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(0)\\n\\n# Code\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        if len(nums) < 3:\\n            return len(nums)\\n\\n        p1, p2 = 1, 2\\n\\n        while p2 < len(nums):\\n            if nums[p1] == nums[p1-1] and nums[p2] == nums[p2-1] == nums[p2-2]:\\n                while p2 < len(nums) and nums[p2] == nums[p2-1]:\\n                    p2 += 1\\n                if p2 == len(nums):\\n                    break\\n            p1 += 1\\n            nums[p1] = nums[p2]\\n            p2 += 1\\n\\n        return p1 + 1\\n\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        if len(nums) < 3:\n            return len(nums)\n\n        p1, p2 = 1, 2\n\n        while p2 < len(nums):\n            if nums[p1] == nums[p1-1] and nums[p2] = nums[p2-1] == nums[p2-2]: \n                while p2 < len(nums) and nums[p2] == nums[p2-1]:\n                    p2 += 1\n                if p2 == len(nums):\n                    break\n            p1 += 1\n            nums[p1] = nums[p2]\n            p2 += 1\n\n        return p1 + 1\n",
        "explanations": "\nUsed assignment operator (=) instead of comparison operator (==) in if condition.\n"
    },
    {
        "slug": "fizz-buzz",
        "description": "Given an integer n, return a string array answer (1-indexed) where:\n\nanswer[i] == \"FizzBuzz\" if i is divisible by 3 and 5.\nanswer[i] == \"Fizz\" if i is divisible by 3.\nanswer[i] == \"Buzz\" if i is divisible by 5.\nanswer[i] == i (as a string) if none of the above conditions are true.",
        "examples": [
            "Input: n = 3\nOutput: [\"1\",\"2\",\"Fizz\"]",
            "Input: n = 5\nOutput: [\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\"]",
            "Input: n = 15\nOutput: [\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\",\"Fizz\",\"7\",\"8\",\"Fizz\",\"Buzz\",\"11\",\"Fizz\",\"13\",\"14\",\"FizzBuzz\"]"
        ],
        "constraints": "1 <= n <= 104",
        "release_time": 1691389137,
        "oracle_code": "class Solution:\n    def fizzBuzz(self, n: int) -> List[str]:\n        arr=[]\n        for i in range(1,n+1):\n            if i % 3==0 and  i % 5==0 :\n                arr.append(\"FizzBuzz\")\n            elif i % 3==0:\n                arr.append(\"Fizz\")\n            elif i % 5==0 :\n                arr.append(\"Buzz\")\n  \n            else:\n                arr.append(str(i))\n        return(arr)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def fizzBuzz(self, n: int) -> List[str]:\\n        arr=[]\\n        for i in range(1,n+1):\\n            if i % 3==0 and  i % 5==0 :\\n                arr.append(\"FizzBuzz\")\\n            elif i % 3==0:\\n                arr.append(\"Fizz\")\\n            elif i % 5==0 :\\n                arr.append(\"Buzz\")\\n  \\n            else:\\n                arr.append(str(i))\\n        return(arr)\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution:\n    def fizzBuzz(self, n: int) -> List[str]:\n        arr=[]\n        for i in range(1,n+1):\n            if i % 3 = 0 and  i % 5 = 0 :\n                arr.append(\"FizzBuzz\")\n            elif i % 3 = 0:\n                arr.append(\"Fizz\")\n            elif i % 5 = 0 :\n                arr.append(\"Buzz\")\n\n            else:\n                arr.append(str(i))\n        return(arr)\n",
        "explanations": "\nThe bug here is using assignment operator(=) instead of equality operator(==) for comparisons.\n"
    },
    {
        "slug": "minimum-fuel-cost-to-report-to-the-capital",
        "description": "There is a tree (i.e., a connected, undirected graph with no cycles) structure country network consisting of n cities numbered from 0 to n - 1 and exactly n - 1 roads. The capital city is city 0. You are given a 2D integer array roads where roads[i] = [ai, bi] denotes that there exists a bidirectional road connecting cities ai and bi.\nThere is a meeting for the representatives of each city. The meeting is in the capital city.\nThere is a car in each city. You are given an integer seats that indicates the number of seats in each car.\nA representative can use the car in their city to travel or change the car and ride with another representative. The cost of traveling between two cities is one liter of fuel.\nReturn the minimum number of liters of fuel to reach the capital city.",
        "examples": [
            "Input: roads = [[0,1],[0,2],[0,3]], seats = 5\nOutput: 3\nExplanation: \n- Representative1 goes directly to the capital with 1 liter of fuel.\n- Representative2 goes directly to the capital with 1 liter of fuel.\n- Representative3 goes directly to the capital with 1 liter of fuel.\nIt costs 3 liters of fuel at minimum. \nIt can be proven that 3 is the minimum number of liters of fuel needed.",
            "Input: roads = [[3,1],[3,2],[1,0],[0,4],[0,5],[4,6]], seats = 2\nOutput: 7\nExplanation: \n- Representative2 goes directly to city 3 with 1 liter of fuel.\n- Representative2 and representative3 go together to city 1 with 1 liter of fuel.\n- Representative2 and representative3 go together to the capital with 1 liter of fuel.\n- Representative1 goes directly to the capital with 1 liter of fuel.\n- Representative5 goes directly to the capital with 1 liter of fuel.\n- Representative6 goes directly to city 4 with 1 liter of fuel.\n- Representative4 and representative6 go together to the capital with 1 liter of fuel.\nIt costs 7 liters of fuel at minimum. \nIt can be proven that 7 is the minimum number of liters of fuel needed.",
            "Input: roads = [], seats = 1\nOutput: 0\nExplanation: No representatives need to travel to the capital city."
        ],
        "constraints": "1 <= n <= 105\nroads.length == n - 1\nroads[i].length == 2\n0 <= ai, bi < n\nai != bi\nroads represents a valid tree.\n1 <= seats <= 105",
        "release_time": 1676207658,
        "oracle_code": "class Solution:\n    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:\n        adjacencyList = [[] for i in range(len(roads) + 1)]\n        res = [0]\n        for road in roads : \n            adjacencyList[road[0]].append(road[1])\n            adjacencyList[road[1]].append(road[0])\n        visited = [0 for i in range(len(roads) + 1)]\n        visited[0]=1\n        def dfs(i,visited):\n            if visited[i] == 1:\n                return 0\n            visited[i] = 1\n            tot = 1\n            for k in adjacencyList[i]:\n                tot += dfs(k,visited)\n            if tot%seats == 0:\n                res[0] += tot//seats\n            else :\n                res[0] += tot//seats + 1\n            return tot\n        for i in adjacencyList[0]:\n            total = dfs(i,visited)\n        return res[0]",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIt can be observed that the problem can be solved using a single pass DFS.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDFS through every adjacent vertex to 0 and return the total number of passengers travelling from the nth city when returning the function.\\nUpdate res variable before returning to sum the fuel cost.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution:\\n    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:\\n        adjacencyList = [[] for i in range(len(roads) + 1)]\\n        res = [0]\\n        for road in roads : \\n            adjacencyList[road[0]].append(road[1])\\n            adjacencyList[road[1]].append(road[0])\\n        visited = [0 for i in range(len(roads) + 1)]\\n        visited[0]=1\\n        def dfs(i,visited):\\n            if visited[i] == 1:\\n                return 0\\n            visited[i] = 1\\n            tot = 1\\n            for k in adjacencyList[i]:\\n                tot += dfs(k,visited)\\n            if tot%seats == 0:\\n                res[0] += tot//seats\\n            else :\\n                res[0] += tot//seats + 1\\n            return tot\\n        for i in adjacencyList[0]:\\n            total = dfs(i,visited)\\n        return res[0]\\n\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution:\n    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:\n        adjacencyList = [[] for i in range(len(roads) + 1)]\n        res = [0]\n        for road in roads : \n            adjacencyList[road[0]].append(road[1])\n            adjacencyList[road[1]].append(road[0])\n        visited = [0 for i in range(len(roads) + 1)]\n        visited[0]=1\n        def dfs(i,visited):\n            if visited[i] = 1:\n                return 0\n            visited[i] = 1\n            tot = 1\n            for k in adjacencyList[i]:\n                tot += dfs(k,visited)\n            if tot%seats == 0:\n                res[0] += tot//seats\n            else :\n                res[0] += tot//seats + 1\n            return tot\n        for i in adjacencyList[0]:\n            total = dfs(i,visited)\n        return res[0]\n",
        "explanations": "\nIn line 10, the == operator used for comparison is replaced with =, the assignment operator.\n"
    },
    {
        "slug": "next-greater-element-i",
        "description": "The next greater element of some element x in an array is the first greater element that is to the right of x in the same array.\nYou are given two distinct 0-indexed integer arrays nums1 and nums2, where nums1 is a subset of nums2.\nFor each 0 <= i < nums1.length, find the index j such that nums1[i] == nums2[j] and determine the next greater element of nums2[j] in nums2. If there is no next greater element, then the answer for this query is -1.\nReturn an array ans of length nums1.length such that ans[i] is the next greater element as described above.",
        "examples": [
            "Input: nums1 = [4,1,2], nums2 = [1,3,4,2]\nOutput: [-1,3,-1]\nExplanation: The next greater element for each value of nums1 is as follows:\n- 4 is underlined in nums2 = [1,3,4,2]. There is no next greater element, so the answer is -1.\n- 1 is underlined in nums2 = [1,3,4,2]. The next greater element is 3.\n- 2 is underlined in nums2 = [1,3,4,2]. There is no next greater element, so the answer is -1.",
            "Input: nums1 = [2,4], nums2 = [1,2,3,4]\nOutput: [3,-1]\nExplanation: The next greater element for each value of nums1 is as follows:\n- 2 is underlined in nums2 = [1,2,3,4]. The next greater element is 3.\n- 4 is underlined in nums2 = [1,2,3,4]. There is no next greater element, so the answer is -1."
        ],
        "constraints": "1 <= nums1.length <= nums2.length <= 1000\n0 <= nums1[i], nums2[i] <= 104\nAll integers in nums1 and nums2 are unique.\nAll the integers of nums1 also appear in nums2.",
        "release_time": 1673532723,
        "oracle_code": "class Solution:\n    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        l = []\n        for i in nums1:\n            count=0\n            for j in nums2:\n                if i==j:\n                    for k in range(nums2.index(j)+1,len(nums2)):\n                        if nums2[k]>j:\n                            count+=1\n                            l.append(nums2[k])\n                            break\n                    if count==0:\n                        l.append(-1)\n        return (l)",
        "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:\\n        l = []\\n        for i in nums1:\\n            count=0\\n            for j in nums2:\\n                if i==j:\\n                    for k in range(nums2.index(j)+1,len(nums2)):\\n                        if nums2[k]>j:\\n                            count+=1\\n                            l.append(nums2[k])\\n                            break\\n                    if count==0:\\n                        l.append(-1)\\n        return (l)\\n                        \\n\\n\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution:\n    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        l = []\n        for i in nums1:\n            count=0\n            for j in nums2:\n                if i=j:\n                    for k in range(nums2.index(j)+1,len(nums2)):\n                        if nums2[k]>j:\n                            count+=1\n                            l.append(nums2[k])\n                            break\n                    if count=0:\n                        l.append(-1)\n        return (l)\n",
        "explanations": "\nMisused the assignment (=) operator instead of the equality (==) operator in if statements.\n"
    },
    {
        "slug": "restore-ip-addresses",
        "description": "A valid IP address consists of exactly four integers separated by single dots. Each integer is between 0 and 255 (inclusive) and cannot have leading zeros.\n\nFor example, \"0.1.2.201\" and \"192.168.1.1\" are valid IP addresses, but \"0.011.255.245\", \"192.168.1.312\" and \"192.168@1.1\" are invalid IP addresses.\n\nGiven a string s containing only digits, return all possible valid IP addresses that can be formed by inserting dots into s. You are not allowed to reorder or remove any digits in s. You may return the valid IP addresses in any order.",
        "examples": [
            "Input: s = \"25525511135\"\nOutput: [\"255.255.11.135\",\"255.255.111.35\"]",
            "Input: s = \"0000\"\nOutput: [\"0.0.0.0\"]",
            "Input: s = \"101023\"\nOutput: [\"1.0.10.23\",\"1.0.102.3\",\"10.1.0.23\",\"10.10.2.3\",\"101.0.2.3\"]"
        ],
        "constraints": "1 <= s.length <= 20\ns consists of digits only.",
        "release_time": 1674285009,
        "oracle_code": "class Solution:\n    def restoreIpAddresses(self, s: str) -> List[str]:\n        res=[]\n        cur=[]\n        def backtrack(i):\n            if i==len(s) and len(cur)==4:\n                res.append(\".\".join(cur))\n                return\n            if len(cur)>4 or i>=len(s):\n                return\n            if s[i]=='0':\n                cur.append(s[i])\n                backtrack(i+1)\n                cur.pop()\n                return\n            j=0\n            while j<4 and i+j<len(s):\n                if int(s[i:i+j+1])<256:\n                    cur.append(s[i:i+j+1])\n                    backtrack(i+j+1)\n                    cur.pop()\n                j+=1\n        backtrack(0)\n        return res",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\njust take care with the processing number should be lower than len(s) and the length of current stack should be lower or equal 4.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(4)\\n# Code\\n```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        res=[]\\n        cur=[]\\n        def backtrack(i):\\n            if i==len(s) and len(cur)==4:\\n                res.append(\".\".join(cur))\\n                return\\n            if len(cur)>4 or i>=len(s):\\n                return\\n            if s[i]==\\'0\\':\\n                cur.append(s[i])\\n                backtrack(i+1)\\n                cur.pop()\\n                return\\n            j=0\\n            while j<4 and i+j<len(s):\\n                if int(s[i:i+j+1])<256:\\n                    cur.append(s[i:i+j+1])\\n                    backtrack(i+j+1)\\n                    cur.pop()\\n                j+=1\\n        backtrack(0)\\n        return res\\n\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution:\n    def restoreIpAddresses(self, s: str) -> List[str]:\n        res=[]\n        cur=[]\n        def backtrack(i):\n            if i=len(s) and len(cur)==4:\n                res.append(\".\".join(cur))\n                return\n            if len(cur)>4 or i>=len(s):\n                return\n            if s[i]=='0':\n                cur.append(s[i])\n                backtrack(i+1)\n                cur.pop()\n                return\n            j=0\n            while j<4 and i+j<len(s):\n                if int(s[i:i+j+1])<256:\n                    cur.append(s[i:i+j+1])\n                    backtrack(i+j+1)\n                    cur.pop()\n                j+=1\n        backtrack(0)\n        return res\n",
        "explanations": "\nThe bug is at line 5. = is assignment operator, == is comparison operator.\n"
    },
    {
        "slug": "baseball-game",
        "description": "You are keeping the scores for a baseball game with strange rules. At the beginning of the game, you start with an empty record.\nYou are given a list of strings operations, where operations[i] is the ith operation you must apply to the record and is one of the following:\n\nAn integer x.\n\n\t\nRecord a new score of x.\n\n\n'+'.\n\t\nRecord a new score that is the sum of the previous two scores.\n\n\n'D'.\n\t\nRecord a new score that is the double of the previous score.\n\n\n'C'.\n\t\nInvalidate the previous score, removing it from the record.\n\n\n\nReturn the sum of all the scores on the record after applying all the operations.\nThe test cases are generated such that the answer and all intermediate calculations fit in a 32-bit integer and that all operations are valid.",
        "examples": [
            "Input: ops = [\"5\",\"2\",\"C\",\"D\",\"+\"]\nOutput: 30\nExplanation:\n\"5\" - Add 5 to the record, record is now [5].\n\"2\" - Add 2 to the record, record is now [5, 2].\n\"C\" - Invalidate and remove the previous score, record is now [5].\n\"D\" - Add 2 * 5 = 10 to the record, record is now [5, 10].\n\"+\" - Add 5 + 10 = 15 to the record, record is now [5, 10, 15].\nThe total sum is 5 + 10 + 15 = 30.",
            "Input: ops = [\"5\",\"-2\",\"4\",\"C\",\"D\",\"9\",\"+\",\"+\"]\nOutput: 27\nExplanation:\n\"5\" - Add 5 to the record, record is now [5].\n\"-2\" - Add -2 to the record, record is now [5, -2].\n\"4\" - Add 4 to the record, record is now [5, -2, 4].\n\"C\" - Invalidate and remove the previous score, record is now [5, -2].\n\"D\" - Add 2 * -2 = -4 to the record, record is now [5, -2, -4].\n\"9\" - Add 9 to the record, record is now [5, -2, -4, 9].\n\"+\" - Add -4 + 9 = 5 to the record, record is now [5, -2, -4, 9, 5].\n\"+\" - Add 9 + 5 = 14 to the record, record is now [5, -2, -4, 9, 5, 14].\nThe total sum is 5 + -2 + -4 + 9 + 5 + 14 = 27.",
            "Input: ops = [\"1\",\"C\"]\nOutput: 0\nExplanation:\n\"1\" - Add 1 to the record, record is now [1].\n\"C\" - Invalidate and remove the previous score, record is now [].\nSince the record is empty, the total sum is 0."
        ],
        "constraints": "1 <= operations.length <= 1000\noperations[i] is \"C\", \"D\", \"+\", or a string representing an integer in the range [-3 * 104, 3 * 104].\nFor operation \"+\", there will always be at least two previous scores on the record.\nFor operations \"C\" and \"D\", there will always be at least one previous score on the record.",
        "release_time": 1681186635,
        "oracle_code": "class Solution:\n    def calPoints(self, operations: List[str]) -> int:\n        stack=[]\n        for i in operations:\n            if i =='D':\n                stack.append(2*stack[-1])\n            elif i=='C':\n                stack.pop()\n            elif i=='+':\n                stack.append(stack[-1]+stack[-2])\n            else:\n                stack.append(int(i))\n        return sum(stack)",
        "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def calPoints(self, operations: List[str]) -> int:\\n        stack=[]\\n        for i in operations:\\n            if i ==\\'D\\':\\n                stack.append(2*stack[-1])\\n            elif i==\\'C\\':\\n                stack.pop()\\n            elif i==\\'+\\':\\n                stack.append(stack[-1]+stack[-2])\\n            else:\\n                stack.append(int(i))\\n        return sum(stack)\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution:\n    def calPoints(self, operations: List[str]) -> int:\n        stack=[]\n        for i in operations:\n            if i =='D':\n                stack.append(2*stack[-1])\n            elif i=='C':\n                stack.pop()\n            elif i='+':\n                stack.append(stack[-1]+stack[-2])\n            else:\n                stack.append(int(i))\n        return stack==sum(stack)\n",
        "explanations": "\nInstead of returning the sum of the stack, the code checks if it equals the sum.\n"
    },
    {
        "slug": "minimum-obstacle-removal-to-reach-corner",
        "description": "You are given a 0-indexed 2D integer array grid of size m x n. Each cell has one of two values:\n\n0 represents an empty cell,\n1 represents an obstacle that may be removed.\n\nYou can move up, down, left, or right from and to an empty cell.\nReturn the minimum number of obstacles to remove so you can move from the upper left corner (0, 0) to the lower right corner (m - 1, n - 1).",
        "examples": [
            "Input: grid = [[0,1,1],[1,1,0],[1,1,0]]\nOutput: 2\nExplanation: We can remove the obstacles at (0, 1) and (0, 2) to create a path from (0, 0) to (2, 2).\nIt can be shown that we need to remove at least 2 obstacles, so we return 2.\nNote that there may be other ways to remove 2 obstacles to create a path.",
            "Input: grid = [[0,1,0,0,0],[0,1,0,1,0],[0,0,0,1,0]]\nOutput: 0\nExplanation: We can move from (0, 0) to (2, 4) without removing any obstacles, so we return 0."
        ],
        "constraints": "m == grid.length\nn == grid[i].length\n1 <= m, n <= 105\n2 <= m * n <= 105\ngrid[i][j] is either 0 or 1.\ngrid[0][0] == grid[m - 1][n - 1] == 0",
        "release_time": 1688233113,
        "oracle_code": "class Solution:\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n        distance[0][0] = 0\n        q = collections.deque([(0, 0, 0)])\n        while q:\n            d, i, j = q.popleft()\n            if i == m - 1 and j == n - 1: return d\n            for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                ci, cj = i + di, j + dj\n                if 0 <= ci < m and 0 <= cj < n:\n                    if d + grid[ci][cj] < distance[ci][cj]:\n                        distance[ci][cj] = d + grid[ci][cj]\n                        if grid[ci][cj] == 1: q.append((distance[ci][cj], ci, cj))\n                        else: q.appendleft((distance[ci][cj], ci, cj))\n        return distance[m - 1][n - 1]",
        "content": "# Intuition\\nFind the shortest path with the weight is only 0 or 1 => 0-1 BFS\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\ncan refer 0-1 BFS [here](https://cp-algorithms.com/graph/01_bfs.html#algorithm)\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(E)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(E)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        distance = [[float(\\'inf\\') for _ in range(n)] for _ in range(m)]\\n        distance[0][0] = 0\\n        q = collections.deque([(0, 0, 0)])\\n        while q:\\n            d, i, j = q.popleft()\\n            if i == m - 1 and j == n - 1: return d\\n            for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\\n                ci, cj = i + di, j + dj\\n                if 0 <= ci < m and 0 <= cj < n:\\n                    if d + grid[ci][cj] < distance[ci][cj]:\\n                        distance[ci][cj] = d + grid[ci][cj]\\n                        if grid[ci][cj] == 1: q.append((distance[ci][cj], ci, cj))\\n                        else: q.appendleft((distance[ci][cj], ci, cj))\\n        return distance[m - 1][n - 1]\\n```",
        "level": "hard",
        "buggy_code": "\nclass Solution:\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n        distance[0][0] = 0\n        q = collections.deque([(0, 0, 0)])\n        while q:\n            d, i, j = q.popleft()\n            if i == m - 1 and j = n - 1: return d\n            for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                ci, cj = i + di, j + dj\n                if 0 <= ci < m and 0 <= cj < n:\n                    if d + grid[ci][cj] < distance[ci][cj]:\n                        distance[ci][cj] = d + grid[ci][cj]\n                        if grid[ci][cj] == 1: q.append((distance[ci][cj], ci, cj))\n                        else: q.appendleft((distance[ci][cj], ci, cj))\n        return distance[m - 1][n - 1]\n",
        "explanations": "\nThe bug is in j = n - 1. '=' is assignment operator, it should be comparison operator '=='.\n"
    },
    {
        "slug": "minimum-deletions-to-make-array-divisible",
        "description": "You are given two positive integer arrays nums and numsDivide. You can delete any number of elements from nums.\nReturn the minimum number of deletions such that the smallest element in nums divides all the elements of numsDivide. If this is not possible, return -1.\nNote that an integer x divides y if y % x == 0.",
        "examples": [
            "Input: nums = [2,3,2,4,3], numsDivide = [9,6,9,3,15]\nOutput: 2\nExplanation: \nThe smallest element in [2,3,2,4,3] is 2, which does not divide all the elements of numsDivide.\nWe use 2 deletions to delete the elements in nums that are equal to 2 which makes nums = [3,4,3].\nThe smallest element in [3,4,3] is 3, which divides all the elements of numsDivide.\nIt can be shown that 2 is the minimum number of deletions needed.",
            "Input: nums = [4,3,6], numsDivide = [8,2,6,10]\nOutput: -1\nExplanation: \nWe want the smallest element in nums to divide all the elements of numsDivide.\nThere is no way to delete elements from nums to allow this."
        ],
        "constraints": "1 <= nums.length, numsDivide.length <= 105\n1 <= nums[i], numsDivide[i] <= 109",
        "release_time": 1672922632,
        "oracle_code": "class Solution:\n    def minOperations(self, nums: List[int], numsDivide: List[int]) -> int:\n        gc=0\n        for i in numsDivide:\n            gc=int(math.gcd(gc,i))\n        nums.sort()\n        for i in range(len(nums)):\n            if gc%nums[i]==0:\n                return i\n        return -1",
        "content": "# Please upvote if it is helpful ^_^\\n*6Companies30days #ReviseWithArsh Challenge 2023\\nDay3\\nQ14. Deletions to make an array divisible.*\\n\\n**Intuition: *gcd***\\n![14.minimum-deletions-to-make-array-divisible.jpg](https://assets.leetcode.com/users/images/86f0dbdf-dfe7-41fb-b0a5-b6529a7477c6_1672922423.6993096.jpeg)\\n\\n# Code\\n**Python3:**\\n```\\nclass Solution:\\n    def minOperations(self, nums: List[int], numsDivide: List[int]) -> int:\\n        gc=0\\n        for i in numsDivide:\\n            gc=int(math.gcd(gc,i))\\n        nums.sort()\\n        for i in range(len(nums)):\\n            if gc%nums[i]==0:\\n                return i\\n        return -1\\n\\n```",
        "level": "hard",
        "buggy_code": "\nclass Solution:\n    def minOperations(self, nums: List[int], numsDivide: List[int]) -> int:\n        gc=0\n        for i in numsDivide:\n            gc=int(math.gcd(gc,i))\n        nums.sort()\n        for i in range(len(nums)):\n            if gc=nums[i]==0:\n                return i\n        return -1\n",
        "explanations": "\nConfused assignment operator (=) with comparison operator (==) causing a SyntaxError.\n"
    },
    {
        "slug": "all-ancestors-of-a-node-in-a-directed-acyclic-graph",
        "description": "You are given a positive integer n representing the number of nodes of a Directed Acyclic Graph (DAG). The nodes are numbered from 0 to n - 1 (inclusive).\nYou are also given a 2D integer array edges, where edges[i] = [fromi, toi] denotes that there is a unidirectional edge from fromi to toi in the graph.\nReturn a list answer, where answer[i] is the list of ancestors of the ith node, sorted in ascending order.\nA node u is an ancestor of another node v if u can reach v via a set of edges.",
        "examples": [
            "Input: n = 8, edgeList = [[0,3],[0,4],[1,3],[2,4],[2,7],[3,5],[3,6],[3,7],[4,6]]\nOutput: [[],[],[],[0,1],[0,2],[0,1,3],[0,1,2,3,4],[0,1,2,3]]\nExplanation:\nThe above diagram represents the input graph.\n- Nodes 0, 1, and 2 do not have any ancestors.\n- Node 3 has two ancestors 0 and 1.\n- Node 4 has two ancestors 0 and 2.\n- Node 5 has three ancestors 0, 1, and 3.\n- Node 6 has five ancestors 0, 1, 2, 3, and 4.\n- Node 7 has four ancestors 0, 1, 2, and 3.",
            "Input: n = 5, edgeList = [[0,1],[0,2],[0,3],[0,4],[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]\nOutput: [[],[0],[0,1],[0,1,2],[0,1,2,3]]\nExplanation:\nThe above diagram represents the input graph.\n- Node 0 does not have any ancestor.\n- Node 1 has one ancestor 0.\n- Node 2 has two ancestors 0 and 1.\n- Node 3 has three ancestors 0, 1, and 2.\n- Node 4 has four ancestors 0, 1, 2, and 3."
        ],
        "constraints": "1 <= n <= 1000\n0 <= edges.length <= min(2000, n * (n - 1) / 2)\nedges[i].length == 2\n0 <= fromi, toi <= n - 1\nfromi != toi\nThere are no duplicate edges.\nThe graph is directed and acyclic.",
        "release_time": 1658785219,
        "oracle_code": "class Solution:\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\n        #Use Kahn's algorithm of toposort using a queue and bfs!\n        graph = [[] for _ in range(n)]\n        indegrees = [0] * n\n        \n        #Time: O(n^2)\n        #Space: O(n^2 + n + n) -> O(n^2)\n        \n        #1st step: build adjacency list grpah and update the initial indegrees of every node!\n        for edge in edges:\n            src, dest = edge[0], edge[1]\n            graph[src].append(dest)\n            indegrees[dest] += 1\n        \n        \n        queue = deque()\n        ans = [set() for _ in range(n)]\n        #2nd step: go through the indegrees array and add to queue for any node that has no ancestor!\n        for i in range(len(indegrees)):\n            if(indegrees[i] == 0):\n                queue.append(i)\n        \n        #Kahn's algorithm initiation!\n        #while loop will run for each and every node in graph!\n        #in worst case, adjacency list for one particular node may contain all other vertices!\n        while queue:\n            cur = queue.pop()\n            \n            #for each neighbor\n            for neighbor in graph[cur]:\n                #current node is ancestor to each and every neighboring node!\n                ans[neighbor].add(cur)\n                #every ancestor of current node is also an ancestor to the neighboring node!\n                ans[neighbor].update(ans[cur])\n                indegrees[neighbor] -= 1\n                if(indegrees[neighbor] == 0):\n                    queue.append(neighbor)\n        \n        #at the end, we should have set of ancestors for each and every node!\n        #in worst case, set s for ith node could have all other vertices be ancestor to node i !\n        ans = [(sorted(list(s))) for s in ans]\n        return ans",
        "content": "```\\nclass Solution:\\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        #Use Kahn\\'s algorithm of toposort using a queue and bfs!\\n        graph = [[] for _ in range(n)]\\n        indegrees = [0] * n\\n        \\n        #Time: O(n^2)\\n        #Space: O(n^2 + n + n) -> O(n^2)\\n        \\n        #1st step: build adjacency list grpah and update the initial indegrees of every node!\\n        for edge in edges:\\n            src, dest = edge[0], edge[1]\\n            graph[src].append(dest)\\n            indegrees[dest] += 1\\n        \\n        \\n        queue = deque()\\n        ans = [set() for _ in range(n)]\\n        #2nd step: go through the indegrees array and add to queue for any node that has no ancestor!\\n        for i in range(len(indegrees)):\\n            if(indegrees[i] == 0):\\n                queue.append(i)\\n        \\n        #Kahn\\'s algorithm initiation!\\n        #while loop will run for each and every node in graph!\\n        #in worst case, adjacency list for one particular node may contain all other vertices!\\n        while queue:\\n            cur = queue.pop()\\n            \\n            #for each neighbor\\n            for neighbor in graph[cur]:\\n                #current node is ancestor to each and every neighboring node!\\n                ans[neighbor].add(cur)\\n                #every ancestor of current node is also an ancestor to the neighboring node!\\n                ans[neighbor].update(ans[cur])\\n                indegrees[neighbor] -= 1\\n                if(indegrees[neighbor] == 0):\\n                    queue.append(neighbor)\\n        \\n        #at the end, we should have set of ancestors for each and every node!\\n        #in worst case, set s for ith node could have all other vertices be ancestor to node i !\\n        ans = [(sorted(list(s))) for s in ans]\\n        return ans",
        "level": "medium",
        "buggy_code": "\nclass Solution:\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\n        graph = [[] for _ in range(n)]\n        indegrees = [0] * n\n\n        for edge in edges:\n            src, dest = edge[0], edge[1]\n            graph[src].append(dest)\n            indegrees[dest] += 1\n\n        queue = deque()\n        ans = [set() for _ in range(n)]\n\n        for i in range(len(indegrees)):\n            if(indegrees[i] = 0):\n                queue.append(i)\n\n        while queue:\n            cur = queue.pop()\n\n            for neighbor in graph[cur]:\n                ans[neighbor].add(cur)\n                ans[neighbor].update(ans[cur])\n                indegrees[neighbor] -= 1\n                if(indegrees[neighbor] = 0):\n                    queue.append(neighbor)\n\n        ans = [(sorted(list(s))) for s in ans]\n        return ans\n",
        "explanations": "\nIn Python, '=' is an assignment operator, '==' is used for comparison. The wrong operator is used in if-statements.\n"
    },
    {
        "slug": "find-all-lonely-numbers-in-the-array",
        "description": "You are given an integer array nums. A number x is lonely when it appears only once, and no adjacent numbers (i.e. x + 1 and x - 1) appear in the array.\nReturn all lonely numbers in nums. You may return the answer in any order.",
        "examples": [
            "Input: nums = [10,6,5,8]\nOutput: [10,8]\nExplanation: \n- 10 is a lonely number since it appears exactly once and 9 and 11 does not appear in nums.\n- 8 is a lonely number since it appears exactly once and 7 and 9 does not appear in nums.\n- 5 is not a lonely number since 6 appears in nums and vice versa.\nHence, the lonely numbers in nums are [10, 8].\nNote that [8, 10] may also be returned.",
            "Input: nums = [1,3,5,3]\nOutput: [1,5]\nExplanation: \n- 1 is a lonely number since it appears exactly once and 0 and 2 does not appear in nums.\n- 5 is a lonely number since it appears exactly once and 4 and 6 does not appear in nums.\n- 3 is not a lonely number since it appears twice.\nHence, the lonely numbers in nums are [1, 5].\nNote that [5, 1] may also be returned."
        ],
        "constraints": "1 <= nums.length <= 105\n0 <= nums[i] <= 106",
        "release_time": 1689511881,
        "oracle_code": "class Solution:\n    def findLonely(self, nums: List[int]) -> List[int]:\n        dic={}\n        res=[]\n        for i in nums:\n            if i in dic:\n                dic[i]+=1\n            else:\n                dic[i]=1\n        for i in nums:\n            if dic[i]==1:\n                if (i-1 not in dic) and (i+1 not in dic):\n                    res.append(i)\n        return res",
        "content": "# Code\\n```\\nclass Solution:\\n    def findLonely(self, nums: List[int]) -> List[int]:\\n        dic={}\\n        res=[]\\n        for i in nums:\\n            if i in dic:\\n                dic[i]+=1\\n            else:\\n                dic[i]=1\\n        for i in nums:\\n            if dic[i]==1:\\n                if (i-1 not in dic) and (i+1 not in dic):\\n                    res.append(i)\\n        return res\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution:\n    def findLonely(self, nums: List[int]) -> List[int]:\n        dic={}\n        res=[]\n        for i in nums:\n            if i in dic:\n                dic[i]=1 \n            else:\n                dic[i]=1\n        for i in nums:\n            if dic[i]==1:\n                if (i-1 not in dic) and (i+1 not in dic):\n                    res.append(i)\n        return res\n",
        "explanations": "\nBug in the line dic[i]=1, it should be dic[i]+=1 to count the frequency correctly.\n"
    },
    {
        "slug": "substrings-of-size-three-with-distinct-characters",
        "description": "A string is good if there are no repeated characters.\nGiven a string s\u200b\u200b\u200b\u200b\u200b, return the number of good substrings of length three in s\u200b\u200b\u200b\u200b\u200b\u200b.\nNote that if there are multiple occurrences of the same substring, every occurrence should be counted.\nA substring is a contiguous sequence of characters in a string.",
        "examples": [
            "Input: s = \"xyzzaz\"\nOutput: 1\nExplanation: There are 4 substrings of size 3: \"xyz\", \"yzz\", \"zza\", and \"zaz\". \nThe only good substring of length 3 is \"xyz\".",
            "Input: s = \"aababcabc\"\nOutput: 4\nExplanation: There are 7 substrings of size 3: \"aab\", \"aba\", \"bab\", \"abc\", \"bca\", \"cab\", and \"abc\".\nThe good substrings are \"abc\", \"bca\", \"cab\", and \"abc\"."
        ],
        "constraints": "1 <= s.length <= 100\ns\u200b\u200b\u200b\u200b\u200b\u200b consists of lowercase English letters.",
        "release_time": 1677600394,
        "oracle_code": "class Solution:\n    def countGoodSubstrings(self, s: str) -> int:\n        count=0\n        for i in range(len(s)-2):\n            x=s[i:i+3]\n            if x.count(x[0])==1 and x.count(x[1])==1 and x.count(x[2])==1:\n                count+=1\n        return count",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Consider upvoting if found helpful\\n# Code\\n```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        count=0\\n        for i in range(len(s)-2):\\n            x=s[i:i+3]\\n            if x.count(x[0])==1 and x.count(x[1])==1 and x.count(x[2])==1:\\n                count+=1\\n        return count\\n\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution:\n    def countGoodSubstrings(self, s: str) -> int:\n        count=0\n        for i in range(len(s)-2):\n            x=s[i:i+3]\n            if x.count(x[0])=1 and x.count(x[1])==1 and x.count(x[2])==1:\n                count+=1\n        return count\n",
        "explanations": "\nThe bug is in the 'if' statement where I used assignment operator (=) instead of comparison operator (==).\n"
    },
    {
        "slug": "longest-cycle-in-a-graph",
        "description": "You are given a directed graph of n nodes numbered from 0 to n - 1, where each node has at most one outgoing edge.\nThe graph is represented with a given 0-indexed array edges of size n, indicating that there is a directed edge from node i to node edges[i]. If there is no outgoing edge from node i, then edges[i] == -1.\nReturn the length of the longest cycle in the graph. If no cycle exists, return -1.\nA cycle is a path that starts and ends at the same node.",
        "examples": [
            "Input: edges = [3,3,4,2,3]\nOutput: 3\nExplanation: The longest cycle in the graph is the cycle: 2 -> 4 -> 3 -> 2.\nThe length of this cycle is 3, so 3 is returned.",
            "Input: edges = [2,-1,3,1]\nOutput: -1\nExplanation: There are no cycles in this graph."
        ],
        "constraints": "n == edges.length\n2 <= n <= 105\n-1 <= edges[i] < n\nedges[i] != i",
        "release_time": 1679838535,
        "oracle_code": "class Solution:\n    def longestCycle(self, edges: List[int]) -> int:\n        v=[0]*len(edges)\n        ans=-1\n        for i in range(len(edges)):\n            t=1\n            c=i\n            while c>=0:\n                if v[c]!=0:\n                    if v[c][0]==i:\n                        ans=max(ans,t-v[c][1])\n                    break\n                else:\n                    v[c]=[i,t]\n                    t+=1\n                    c=edges[c]\n        return ans",
        "content": "\\n```\\nclass Solution:\\n    def longestCycle(self, edges: List[int]) -> int:\\n        v=[0]*len(edges)\\n        ans=-1\\n        for i in range(len(edges)):\\n            t=1\\n            c=i\\n            while c>=0:\\n                if v[c]!=0:\\n                    if v[c][0]==i:\\n                        ans=max(ans,t-v[c][1])\\n                    break\\n                else:\\n                    v[c]=[i,t]\\n                    t+=1\\n                    c=edges[c]\\n        return ans\\n\\n\\n```",
        "level": "hard",
        "buggy_code": "\nclass Solution:\n    def longestCycle(self, edges: List[int]) -> int:\n        v=[0]*len(edges)\n        ans=-1\n        for i in range(len(edges)):\n            t=1\n            c=i\n            while c>=0:\n                if v[c]!=0:\n                    if v[c][0]=i:  \n                        ans=max(ans,t-v[c][1])\n                    break\n                else:\n                    v[c]=[i,t]\n                    t+=1\n                    c=edges[c]\n        return ans\n",
        "explanations": "\nThe code has a bug at line \"if v[c][0]=i:\", where == should have been used instead of =.\n"
    },
    {
        "slug": "median-of-two-sorted-arrays",
        "description": "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\nThe overall run time complexity should be O(log (m+n)).",
        "examples": [
            "Input: nums1 = [1,3], nums2 = [2]\nOutput: 2.00000\nExplanation: merged array = [1,2,3] and median is 2.",
            "Input: nums1 = [1,2], nums2 = [3,4]\nOutput: 2.50000\nExplanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5."
        ],
        "constraints": "nums1.length == m\nnums2.length == n\n0 <= m <= 1000\n0 <= n <= 1000\n1 <= m + n <= 2000\n-106 <= nums1[i], nums2[i] <= 106",
        "release_time": 1691292624,
        "oracle_code": "class Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        p1 = 0\n        p2 = 0\n        new = []\n        while p1 < len(nums1) and p2 < len(nums2):\n            if nums1[p1] < nums2[p2]:\n                new.append(nums1[p1])\n                p1 += 1\n            else:\n                new.append(nums2[p2])\n                p2 += 1\n        while p1 < len(nums1):\n            new.append(nums1[p1])\n            p1 += 1\n        while p2 < len(nums2):\n            new.append(nums2[p2])\n            p2+= 1\n        if len(new) % 2 == 0:\n            index = len(new) // 2\n            median = (new[index] + new[index-1]) / 2\n        else:\n            median = float(new[len(new)//2])\n        return median",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind this approach is to merge the two sorted arrays while maintaining the order, and then finding the median based on the length of the merged array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize two pointers, p1 and p2, for the two input arrays nums1 and nums2, respectively, both starting at index 0.\\n2. Create an empty list new to store the merged array.\\n3. Iterate through both arrays using the pointers. Compare the elements pointed to by p1 and p2. Append the smaller element to the new array and increment the corresponding pointer.\\n4. After the iteration, there might be remaining elements in one of the arrays. Iterate through the remaining elements and append them to the new array.\\n5. Calculate the median based on the length of the new array. If the length is even, take the average of the middle two elements. If the length is odd, take the middle element.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(m + n), where m and n are the lengths of the two input arrays.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(m + n), as the merged array new can contain all the elements from the two input arrays.\\n\\n# Code\\n```\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        p1 = 0\\n        p2 = 0\\n        new = []\\n        while p1 < len(nums1) and p2 < len(nums2):\\n            if nums1[p1] < nums2[p2]:\\n                new.append(nums1[p1])\\n                p1 += 1\\n            else:\\n                new.append(nums2[p2])\\n                p2 += 1\\n        while p1 < len(nums1):\\n            new.append(nums1[p1])\\n            p1 += 1\\n        while p2 < len(nums2):\\n            new.append(nums2[p2])\\n            p2+= 1\\n        if len(new) % 2 == 0:\\n            index = len(new) // 2\\n            median = (new[index] + new[index-1]) / 2\\n        else:\\n            median = float(new[len(new)//2])\\n        return median\\n```",
        "level": "hard",
        "buggy_code": "\nclass Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        p1 = 0\n        p2 = 0\n        new = []\n        while p1 < len(nums1) and p2 < len(nums2):\n            if nums1[p1] < nums2[p2]:\n                new.append(nums1[p1])\n                p1 = 1\n            else:\n                new.append(nums2[p2])\n                p2 += 1\n        while p1 < len(nums1):\n            new.append(nums1[p1])\n            p1 += 1\n        while p2 < len(nums2):\n            new.append(nums2[p2])\n            p2+= 1\n        if len(new) % 2 == 0:\n            index = len(new) // 2\n            median = (new[index] + new[index-1]) / 2\n        else:\n            median = float(new[len(new)//2])\n        return median\n",
        "explanations": "\nMisused assignment operator instead of comparison operator causing endless loop.\n"
    },
    {
        "slug": "check-if-two-string-arrays-are-equivalent",
        "description": "Given two string arrays word1 and word2, return true if the two arrays represent the same string, and false otherwise.\nA string is represented by an array if the array elements concatenated in order forms the string.",
        "examples": [
            "Input: word1 = [\"ab\", \"c\"], word2 = [\"a\", \"bc\"]\nOutput: true\nExplanation:\nword1 represents string \"ab\" + \"c\" -> \"abc\"\nword2 represents string \"a\" + \"bc\" -> \"abc\"\nThe strings are the same, so return true.",
            "Input: word1 = [\"a\", \"cb\"], word2 = [\"ab\", \"c\"]\nOutput: false",
            "Input: word1  = [\"abc\", \"d\", \"defg\"], word2 = [\"abcddefg\"]\nOutput: true"
        ],
        "constraints": "1 <= word1.length, word2.length <= 103\n1 <= word1[i].length, word2[i].length <= 103\n1 <= sum(word1[i].length), sum(word2[i].length) <= 103\nword1[i] and word2[i] consist of lowercase letters.",
        "release_time": 1691924075,
        "oracle_code": "class Solution:\n    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) -> bool:\n        word3=\"\".join(word1)\n        word4=\"\".join(word2)\n        if word3==word4:\n            return True\n        else:\n            return False",
        "content": "**1**.First we will join the contents or concatenate the Strings present in the list using join()\\n**2**.then compare 2 list.\\n**3** if true return true else return false\\n```\\nclass Solution:\\n    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) -> bool:\\n        word3=\"\".join(word1)\\n        word4=\"\".join(word2)\\n        if word3==word4:\\n            return True\\n        else:\\n            return False\\n```\\n**code**\\nOnline Solution :\\n    -Thank you for this solution @jeevabharathiS\\n        \\n```\\nclass Solution:\\n    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) \\n        return((\"\".join(word1))==(\"\".join(word2)))\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution:\n    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) -> bool:\n        word3=\"\".join(word1)\n        word4=\"\".join(word2)\n        if word3=word4:\n            return True\n        else:\n            return False\n",
        "explanations": "\nThe condition inside if is using assignment operator(=) instead of equality operator(==).\n"
    },
    {
        "slug": "average-value-of-even-numbers-that-are-divisible-by-three",
        "description": "Given an integer array nums of positive integers, return the average value of all even integers that are divisible by 3.\nNote that the average of n elements is the sum of the n elements divided by n and rounded down to the nearest integer.",
        "examples": [
            "Input: nums = [1,3,6,10,12,15]\nOutput: 9\nExplanation: 6 and 12 are even numbers that are divisible by 3. (6 + 12) / 2 = 9.",
            "Input: nums = [1,2,4,7,10]\nOutput: 0\nExplanation: There is no single number that satisfies the requirement, so return 0."
        ],
        "constraints": "1 <= nums.length <= 1000\n1 <= nums[i] <= 1000",
        "release_time": 1676326760,
        "oracle_code": "class Solution:\n    def averageValue(self, nums: List[int]) -> int:\n        return int(sum(lst) / len(lst)) if len(lst := [num for num in nums if num % 6 == 0]) > 0 else 0",
        "content": "# Intuition\\nI wanted to solve this problem in **one line** using python, I figured this was the perfect use for the **Walrus Operator!**\\n\\n# Approach\\nI didn\\'t want any extra iterations, so we perform a list comprehention with only the values divisible by 6 (2 and 3) and use the walrus operator to store the comprehention in *lst*. Then, we can take the average as you would expect, accounting for dividing by zero using an in-line if statement.  \\n\\nIf you\\'ve never used the walrus operator before: https://realpython.com/python-walrus-operator/ \\n\\n# Complexity\\n- Time complexity:\\nO(n), we iterate over each item in the input list once. \\n\\n- Space complexity:\\nO(n), we store all elements divisible by both 2 and 3.\\n\\n# Code\\n\\n```\\nclass Solution:\\n    def averageValue(self, nums: List[int]) -> int:\\n        return int(sum(lst) / len(lst)) if len(lst := [num for num in nums if num % 6 == 0]) > 0 else 0 \\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution:\n    def averageValue(self, nums: List[int]) -> int:\n        return int(sum(lst) / len(lst)) if len(lst := [num for num in nums if num % 6 = 0]) > 0 else 0\n",
        "explanations": "\nUsed single '=' in 'num % 6 = 0' instead of '==' which is causing a syntax error.\n"
    },
    {
        "slug": "max-points-on-a-line",
        "description": "Given an array of points where points[i] = [xi, yi] represents a point on the X-Y plane, return the maximum number of points that lie on the same straight line.",
        "examples": [
            "Input: points = [[1,1],[2,2],[3,3]]\nOutput: 3",
            "Input: points = [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]\nOutput: 4"
        ],
        "constraints": "1 <= points.length <= 300\npoints[i].length == 2\n-104 <= xi, yi <= 104\nAll the points are unique.",
        "release_time": 1673194328,
        "oracle_code": "from collections import defaultdict\nclass Solution:\n    def maxPoints(self, points: List[List[int]]) -> int:\n        N = len(points)\n        D = defaultdict(set)\n        if N <= 2:\n            return N \n        for i in range(N):\n            x1, y1 = points[i]\n            for j in range(i+1, N):\n                x2, y2 = points[j]\n                if y1 == y2:\n                    k1, k2 = 'inf', y1\n                elif x1 == x2:\n                    k1, k2 = x1, 'inf'\n                else:\n                    k1, k2 = (x1-x2)/(y2-y1), (x2*y1-x1*y2)/(y2-y1)\n                D[(k1,k2)].add(tuple(points[i]))\n                D[(k1,k2)].add(tuple(points[j]))\n        return max([len(i) for i in D.values()])",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        N = len(points)\\n        D = defaultdict(set)\\n        if N <= 2:\\n            return N \\n        for i in range(N):\\n            x1, y1 = points[i]\\n            for j in range(i+1, N):\\n                x2, y2 = points[j]\\n                if y1 == y2:\\n                    k1, k2 = \\'inf\\', y1\\n                elif x1 == x2:\\n                    k1, k2 = x1, \\'inf\\'\\n                else:\\n                    k1, k2 = (x1-x2)/(y2-y1), (x2*y1-x1*y2)/(y2-y1)\\n                D[(k1,k2)].add(tuple(points[i]))\\n                D[(k1,k2)].add(tuple(points[j]))\\n        return max([len(i) for i in D.values()])\\n        \\n\\n```",
        "level": "hard",
        "buggy_code": "\nfrom collections import defaultdict\nclass Solution:\n    def maxPoints(self, points: List[List[int]]) -> int:\n        N = len(points)\n        D = defaultdict(set)\n        if N <= 2:\n            return N \n        for i in range(N):\n            x1, y1 = points[i]\n            for j in range(i+1, N):\n                x2, y2 = points[j]\n                if y1 = y2:\n                    k1, k2 = 'inf', y1\n                elif x1 = x2:\n                    k1, k2 = x1, 'inf'\n                else:\n                    k1, k2 = (x1-x2)/(y2-y1), (x2*y1-x1*y2)/(y2-y1)\n                D[(k1,k2)].add(tuple(points[i]))\n                D[(k1,k2)].add(tuple(points[j]))\n        return max([len(i) for i in D.values()])\n",
        "explanations": "\nUsed assignment operator (=) instead of equality operator (==) in the condition checks.\n"
    },
    {
        "slug": "powerful-integers",
        "description": "Given three integers x, y, and bound, return a list of all the powerful integers that have a value less than or equal to bound.\nAn integer is powerful if it can be represented as xi + yj for some integers i >= 0 and j >= 0.\nYou may return the answer in any order. In your answer, each value should occur at most once.",
        "examples": [
            "Input: x = 2, y = 3, bound = 10\nOutput: [2,3,4,5,7,9,10]\nExplanation:\n2 = 20 + 30\n3 = 21 + 30\n4 = 20 + 31\n5 = 21 + 31\n7 = 22 + 31\n9 = 23 + 30\n10 = 20 + 32",
            "Input: x = 3, y = 5, bound = 15\nOutput: [2,4,6,8,10,14]"
        ],
        "constraints": "1 <= x, y <= 100\n0 <= bound <= 106",
        "release_time": 1685619256,
        "oracle_code": "class Solution:\n    def powerfulIntegers(self, x: int, y: int, bound: int) -> List[int]:\n        if bound == 0:\n            return []\n        \n        def get(v):\n            yield 1\n            if v == 1:\n                return\n            vi = v\n            while vi <= bound:\n                yield vi\n                vi *= v\n        \n        return list({xi + yi for xi in get(x) for yi in get(y) if xi + yi <= bound})",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def powerfulIntegers(self, x: int, y: int, bound: int) -> List[int]:\\n        if bound == 0:\\n            return []\\n        \\n        def get(v):\\n            yield 1\\n            if v == 1:\\n                return\\n            vi = v\\n            while vi <= bound:\\n                yield vi\\n                vi *= v\\n        \\n        return list({xi + yi for xi in get(x) for yi in get(y) if xi + yi <= bound})\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution:\n    def powerfulIntegers(self, x: int, y: int, bound: int) -> List[int]:\n        if bound = 0:\n            return []\n        \n        def get(v):\n            yield 1\n            if v = 1:\n                return\n            vi = v\n            while vi <= bound:\n                yield vi\n                vi *= v\n        \n        return list({xi + yi for xi in get(x) for yi in get(y) if xi + yi <= bound})\n",
        "explanations": "\nInstead of doing comparison (==), the code is assigning (=) values which will lead to error.\n"
    },
    {
        "slug": "linked-list-cycle",
        "description": "Given head, the head of a linked list, determine if the linked list has a cycle in it.\nThere is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the\u00a0next\u00a0pointer. Internally, pos\u00a0is used to denote the index of the node that\u00a0tail's\u00a0next\u00a0pointer is connected to.\u00a0Note that\u00a0pos\u00a0is not passed as a parameter.\nReturn\u00a0true if there is a cycle in the linked list. Otherwise, return false.",
        "examples": [
            "Input: head = [3,2,0,-4], pos = 1\nOutput: true\nExplanation: There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).",
            "Input: head = [1,2], pos = 0\nOutput: true\nExplanation: There is a cycle in the linked list, where the tail connects to the 0th node.",
            "Input: head = [1], pos = -1\nOutput: false\nExplanation: There is no cycle in the linked list."
        ],
        "constraints": "The number of the nodes in the list is in the range [0, 104].\n-105 <= Node.val <= 105\npos is -1 or a valid index in the linked-list.",
        "release_time": 1692180651,
        "oracle_code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\n        a=b=head\n        while(a!=None and a.next!=None):\n            b=b.next\n            a=a.next.next\n            if(a==b):\n                return True\n        return False",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        a=b=head\\n        while(a!=None and a.next!=None):\\n            b=b.next\\n            a=a.next.next\\n            if(a==b):\\n                return True\\n        return False\\n```",
        "level": "easy",
        "buggy_code": "\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\n        a=b=head\n        while(a is not None and a.next is not None):\n            b=b.next\n            a=a.next.next\n            if(a=b):\n                return True\n        return False\n",
        "explanations": "\nUsed assignment operator (=) instead of equality operator (==) causing a syntax error.\n"
    },
    {
        "slug": "longest-happy-prefix",
        "description": "A string is called a happy prefix if is a non-empty prefix which is also a suffix (excluding itself).\nGiven a string s, return the longest happy prefix of s. Return an empty string \"\" if no such prefix exists.",
        "examples": [
            "Input: s = \"level\"\nOutput: \"l\"\nExplanation: s contains 4 prefix excluding itself (\"l\", \"le\", \"lev\", \"leve\"), and suffix (\"l\", \"el\", \"vel\", \"evel\"). The largest prefix which is also suffix is given by \"l\".",
            "Input: s = \"ababab\"\nOutput: \"abab\"\nExplanation: \"abab\" is the largest prefix which is also suffix. They can overlap in the original string."
        ],
        "constraints": "1 <= s.length <= 105\ns contains only lowercase English letters.",
        "release_time": 1672917990,
        "oracle_code": "class Solution:\n    def longestPrefix(self, s: str) -> str:\n        n=len(s)\n        lps=[0]*n\n        j=0\n        for i in range(1,n):\n            while s[i]!=s[j] and j>0:\n                j=lps[j-1]\n\n            if s[i]==s[j]:\n                lps[i]=j+1\n                j+=1\n\n        return s[:lps[-1]]",
        "content": "# Please upvote if it is helpful ^_^\\n***6Companies30days #ReviseWithArsh Challenge 2023\\nDay2\\nQ12. Longest Happy Prefix***\\n\\n**Approach:** *KMP Approach, DP*\\n\\n![12.longest-happy-prefix.jpg](https://assets.leetcode.com/users/images/368329ab-8eb6-4ddb-8c57-fc07336b759d_1672917737.342274.jpeg)\\n\\n**Complexity:** *O(M+N)*\\n\\n# Code\\n**Python3:**\\n```\\nclass Solution:\\n    def longestPrefix(self, s: str) -> str:\\n        n=len(s)\\n        lps=[0]*n\\n        j=0\\n        for i in range(1,n):\\n            while s[i]!=s[j] and j>0:\\n                j=lps[j-1]\\n\\n            if s[i]==s[j]:\\n                lps[i]=j+1\\n                j+=1\\n\\n        return s[:lps[-1]]\\n```",
        "level": "hard",
        "buggy_code": "\nclass Solution:\n    def longestPrefix(self, s: str) -> str:\n        n=len(s)\n        lps=[0]*n\n        j=0\n        for i in range(1,n):\n            while s[i]!=s[j] and j>0:\n                j=lps[j-1]\n\n            if s[i]=s[j]:\n                lps[i]=j+1\n                j+=1\n\n        return s[:lps[-1]]\n",
        "explanations": "\nUsed single equals sign (=) for comparison instead of double (==), causing syntax error.\n"
    },
    {
        "slug": "number-complement",
        "description": "The complement of an integer is the integer you get when you flip all the 0's to 1's and all the 1's to 0's in its binary representation.\n\nFor example, The integer 5 is \"101\" in binary and its complement is \"010\" which is the integer 2.\n\nGiven an integer num, return its complement.",
        "examples": [
            "Input: num = 5\nOutput: 2\nExplanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2.",
            "Input: num = 1\nOutput: 0\nExplanation: The binary representation of 1 is 1 (no leading zero bits), and its complement is 0. So you need to output 0."
        ],
        "constraints": "1 <= num < 231\n\n\u00a0\nNote: This question is the same as 1009: https://leetcode.com/problems/complement-of-base-10-integer/",
        "release_time": 1682091742,
        "oracle_code": "class Solution:\n    def findComplement(self, num: int) -> int:\n        com = ''\n        while num > 0 :\n            \n            if num % 2 == 1:\n                com += '0'\n            else:\n                com += '1'\n            num = num // 2\n        return int(com[::-1],2)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findComplement(self, num: int) -> int:\\n        com = \\'\\'\\n        while num > 0 :\\n            \\n            if num % 2 == 1:\\n                com += \\'0\\'\\n            else:\\n                com += \\'1\\'\\n            num = num // 2\\n        return int(com[::-1],2)\\n        \\n\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution:\n    def findComplement(self, num: int) -> int:\n        com = ''\n        while num > 0 :\n            \n            if num % 2 = 1:\n                com += '0'\n            else:\n                com += '1'\n            num = num // 2\n        return int(com[::-1],2)\n",
        "explanations": "\nThe bug is in the if statement where = is used instead of ==.\n"
    },
    {
        "slug": "restore-the-array",
        "description": "A program was supposed to print an array of integers. The program forgot to print whitespaces and the array is printed as a string of digits s and all we know is that all integers in the array were in the range [1, k] and there are no leading zeros in the array.\nGiven the string s and the integer k, return the number of the possible arrays that can be printed as s using the mentioned program. Since the answer may be very large, return it modulo 109 + 7.",
        "examples": [
            "Input: s = \"1000\", k = 10000\nOutput: 1\nExplanation: The only possible array is [1000]",
            "Input: s = \"1000\", k = 10\nOutput: 0\nExplanation: There cannot be an array that was printed this way and has all integer >= 1 and <= 10.",
            "Input: s = \"1317\", k = 2000\nOutput: 8\nExplanation: Possible arrays are [1317],[131,7],[13,17],[1,317],[13,1,7],[1,31,7],[1,3,17],[1,3,1,7]"
        ],
        "constraints": "1 <= s.length <= 105\ns consists of only digits and does not contain leading zeros.\n1 <= k <= 109",
        "release_time": 1682229291,
        "oracle_code": "class Solution:\n    def numberOfArrays(self, s: str, k: int) -> int:\n\n        n = len(s)\n        mod = 10**9+7\n\n        @lru_cache(None)\n        def rec(i=0):\n\n            if i==n :\n                return 1\n            \n            if s[i]==\"0\":\n                return 0\n            \n            res = 0\n            curr = \"\"\n            for x in range(i, n):\n                curr += s[x]\n                if int(curr)<=k:\n                    res += (rec(x+1)%mod)\n                    res %= mod\n                else:\n                    break\n\n            return res\n        \n        return rec()",
        "content": "# Code\\n```\\nclass Solution:\\n    def numberOfArrays(self, s: str, k: int) -> int:\\n\\n        n = len(s)\\n        mod = 10**9+7\\n\\n        @lru_cache(None)\\n        def rec(i=0):\\n\\n            if i==n :\\n                return 1\\n            \\n            if s[i]==\"0\":\\n                return 0\\n            \\n            res = 0\\n            curr = \"\"\\n            for x in range(i, n):\\n                curr += s[x]\\n                if int(curr)<=k:\\n                    res += (rec(x+1)%mod)\\n                    res %= mod\\n                else:\\n                    break\\n\\n            return res\\n        \\n        return rec()\\n```",
        "level": "hard",
        "buggy_code": "\nclass Solution:\n    def numberOfArrays(self, s: str, k: int) -> int:\n\n        n = len(s)\n        mod = 10**9+7\n\n        @lru_cache(None)\n        def rec(i=0):\n\n            if i=n :\n                return 1\n            \n            if s[i]==\"0\":\n                return 0\n            \n            res = 0\n            curr = \"\"\n            for x in range(i, n):\n                curr += s[x]\n                if int(curr)<=k:\n                    res += (rec(x+1)%mod)\n                    res %= mod\n                else:\n                    break\n\n            return res\n        \n        return rec()\n",
        "explanations": "\nThe operator \"==\" in the conditional \"if i==n :\" was replaced with an operator \"=\".\n"
    },
    {
        "slug": "number-of-ways-of-cutting-a-pizza",
        "description": "Given a rectangular pizza represented as a rows x cols\u00a0matrix containing the following characters: 'A' (an apple) and '.' (empty cell) and given the integer k. You have to cut the pizza into k pieces using k-1 cuts.\u00a0\nFor each cut you choose the direction: vertical or horizontal, then you choose a cut position at the cell boundary and cut the pizza into two pieces. If you cut the pizza vertically, give the left part of the pizza to a person. If you cut the pizza horizontally, give the upper part of the pizza to a person. Give the last piece of pizza to the last person.\nReturn the number of ways of cutting the pizza such that each piece contains at least one apple.\u00a0Since the answer can be a huge number, return this modulo 10^9 + 7.",
        "examples": [
            "Input: pizza = [\"A..\",\"AAA\",\"...\"], k = 3\nOutput: 3 \nExplanation: The figure above shows the three ways to cut the pizza. Note that pieces must contain at least one apple.",
            "Input: pizza = [\"A..\",\"AA.\",\"...\"], k = 3\nOutput: 1",
            "Input: pizza = [\"A..\",\"A..\",\"...\"], k = 1\nOutput: 1"
        ],
        "constraints": "1 <= rows, cols <= 50\nrows ==\u00a0pizza.length\ncols ==\u00a0pizza[i].length\n1 <= k <= 10\npizza consists of characters 'A'\u00a0and '.' only.",
        "release_time": 1680234826,
        "oracle_code": "class Solution:\n    def ways(self, pizza: List[str], k: int) -> int:\n        self.r = len(pizza)\n        self.c = len(pizza[0])\n        \n        # Step 1, pre-process the apple array and get the prefix sum\n        tot_apples = 0\n        self.pfsum_row = []\n        self.pfsum_col = []\n        \n        for i in range(self.r):\n            pfr = 0\n            pfs_r = [0] * self.c\n            pfs_c = [0] * self.c\n            for j in range(self.c):\n                if i > 0:\n                    pfs_c[j] += self.pfsum_col[i - 1][j]\n                if pizza[i][j] == 'A':\n                    pfr += 1\n                    pfs_c[j] += 1\n                    tot_apples += 1\n                pfs_r[j] = pfr\n            self.pfsum_row.append(pfs_r)\n            self.pfsum_col.append(pfs_c)\n        \n        if tot_apples < k:\n            return 0\n        \n        if k == 1:\n            return 1\n        \n        return self.getWays(0, 0, k) % (1000000007)\n    \n    \n    @cache\n    def getWays(self, i, j, k):\n        if k == 1:\n            # if only left one piece for cutting, we just need to check if there is any apple in the region\n            found = False\n            for c in range(j, self.c):\n                apple_in_region = self.pfsum_col[self.r - 1][c]\n                if i > 0:\n                     apple_in_region -= self.pfsum_col[i - 1][c]\n                if apple_in_region:\n                    found = True\n                    break\n            if found:\n                return 1\n            return 0\n        else:\n            # horizontally cut\n            cannot_cut = True\n            nr = i\n            t_cnt = 0\n            while nr < self.r - 1:\n                # find the first row that we can start cutting\n                while nr < self.r - 1 and cannot_cut:\n                    apple_in_region = self.pfsum_row[nr][self.c - 1]\n                    if j > 0:\n                        apple_in_region -= self.pfsum_row[nr][j - 1]\n                    if apple_in_region:\n                        cannot_cut = False\n                    else:\n                        nr += 1\n                        \n                if nr < self.r - 1:\n                    t_cnt += self.getWays(nr + 1, j, k - 1)\n                nr += 1\n                \n            # vertically cut\n            cannot_cut = True\n            nc = j\n            while nc < self.c - 1:\n                # find the first col that we can start cutting\n                while nc < self. c - 1 and cannot_cut:\n                    apple_in_region = self.pfsum_col[self.r - 1][nc]\n                    if i > 0:\n                        apple_in_region -= self.pfsum_col[i - 1][nc]\n                    if apple_in_region:\n                        cannot_cut = False\n                    else:\n                        nc += 1\n                \n                if nc < self.c - 1:\n                    t_cnt += self.getWays(i, nc + 1, k - 1)\n                nc += 1\n            \n            return t_cnt",
        "content": "The key to this problem is how to count the number of apples on the region we want to cut.\\n\\nWe can simply use the prefix sum that help to identify the number of apples between any two index.\\n\\nTherefore, we need to pre-process the input array, get the prefix sum horizatonally and vertically.\\n\\nWith the prefix sum array, we can create a dp funtion that get the number of cuts in the region (i, j) to (row - 1, col - 1)\\n\\n\\n```\\nclass Solution:\\n    def ways(self, pizza: List[str], k: int) -> int:\\n        self.r = len(pizza)\\n        self.c = len(pizza[0])\\n        \\n        # Step 1, pre-process the apple array and get the prefix sum\\n        tot_apples = 0\\n        self.pfsum_row = []\\n        self.pfsum_col = []\\n        \\n        for i in range(self.r):\\n            pfr = 0\\n            pfs_r = [0] * self.c\\n            pfs_c = [0] * self.c\\n            for j in range(self.c):\\n                if i > 0:\\n                    pfs_c[j] += self.pfsum_col[i - 1][j]\\n                if pizza[i][j] == \\'A\\':\\n                    pfr += 1\\n                    pfs_c[j] += 1\\n                    tot_apples += 1\\n                pfs_r[j] = pfr\\n            self.pfsum_row.append(pfs_r)\\n            self.pfsum_col.append(pfs_c)\\n        \\n        if tot_apples < k:\\n            return 0\\n        \\n        if k == 1:\\n            return 1\\n        \\n        return self.getWays(0, 0, k) % (1000000007)\\n    \\n    \\n    @cache\\n    def getWays(self, i, j, k):\\n        if k == 1:\\n            # if only left one piece for cutting, we just need to check if there is any apple in the region\\n            found = False\\n            for c in range(j, self.c):\\n                apple_in_region = self.pfsum_col[self.r - 1][c]\\n                if i > 0:\\n                     apple_in_region -= self.pfsum_col[i - 1][c]\\n                if apple_in_region:\\n                    found = True\\n                    break\\n            if found:\\n                return 1\\n            return 0\\n        else:\\n            # horizontally cut\\n            cannot_cut = True\\n            nr = i\\n            t_cnt = 0\\n            while nr < self.r - 1:\\n                # find the first row that we can start cutting\\n                while nr < self.r - 1 and cannot_cut:\\n                    apple_in_region = self.pfsum_row[nr][self.c - 1]\\n                    if j > 0:\\n                        apple_in_region -= self.pfsum_row[nr][j - 1]\\n                    if apple_in_region:\\n                        cannot_cut = False\\n                    else:\\n                        nr += 1\\n                        \\n                if nr < self.r - 1:\\n                    t_cnt += self.getWays(nr + 1, j, k - 1)\\n                nr += 1\\n                \\n            # vertically cut\\n            cannot_cut = True\\n            nc = j\\n            while nc < self.c - 1:\\n                # find the first col that we can start cutting\\n                while nc < self. c - 1 and cannot_cut:\\n                    apple_in_region = self.pfsum_col[self.r - 1][nc]\\n                    if i > 0:\\n                        apple_in_region -= self.pfsum_col[i - 1][nc]\\n                    if apple_in_region:\\n                        cannot_cut = False\\n                    else:\\n                        nc += 1\\n                \\n                if nc < self.c - 1:\\n                    t_cnt += self.getWays(i, nc + 1, k - 1)\\n                nc += 1\\n            \\n            return t_cnt\\n\\n```",
        "level": "hard",
        "buggy_code": "\nclass Solution:\n    def ways(self, pizza: List[str], k: int) -> int:\n        self.r = len(pizza)\n        self.c = len(pizza[0])\n        \n        # Step 1, pre-process the apple array and get the prefix sum\n        tot_apples = 0\n        self.pfsum_row = []\n        self.pfsum_col = []\n        \n        for i in range(self.r):\n            pfr = 0\n            pfs_r = [0] * self.c\n            pfs_c = [0] * self.c\n            for j in range(self.c):\n                if i > 0:\n                    pfs_c[j] += self.pfsum_col[i - 1][j]\n                if pizza[i][j] == 'A':\n                    pfr += 1\n                    pfs_c[j] += 1\n                    tot_apples += 1\n                pfs_r[j] = pfr\n            self.pfsum_row.append(pfs_r)\n            self.pfsum_col.append(pfs_c)\n        \n        if tot_apples < k:\n            return 0\n        \n        if k = 1:\n            return 1\n        \n        return self.getWays(0, 0, k) % (1000000007)\n    \n    \n    @cache\n    def getWays(self, i, j, k):\n        if k == 1:\n            # if only left one piece for cutting, we just need to check if there is any apple in the region\n            found = False\n            for c in range(j, self.c):\n                apple_in_region = self.pfsum_col[self.r - 1][c]\n                if i > 0:\n                     apple_in_region -= self.pfsum_col[i - 1][c]\n                if apple_in_region:\n                    found = True\n                    break\n            if found:\n                return 1\n            return 0\n        else:\n            # horizontally cut\n            cannot_cut = True\n            nr = i\n            t_cnt = 0\n            while nr < self.r - 1:\n                # find the first row that we can start cutting\n                while nr < self.r - 1 and cannot_cut:\n                    apple_in_region = self.pfsum_row[nr][self.c - 1]\n                    if j > 0:\n                        apple_in_region -= self.pfsum_row[nr][j - 1]\n                    if apple_in_region:\n                        cannot_cut = False\n                    else:\n                        nr += 1\n                        \n                if nr < self.r - 1:\n                    t_cnt += self.getWays(nr + 1, j, k - 1)\n                nr += 1\n                \n            # vertically cut\n            cannot_cut = True\n            nc = j\n            while nc < self.c - 1:\n                # find the first col that we can start cutting\n                while nc < self. c - 1 and cannot_cut:\n                    apple_in_region = self.pfsum_col[self.r - 1][nc]\n                    if i > 0:\n                        apple_in_region -= self.pfsum_col[i - 1][nc]\n                    if apple_in_region:\n                        cannot_cut = False\n                    else:\n                        nc += 1\n                \n                if nc < self.c - 1:\n                    t_cnt += self.getWays(i, nc + 1, k - 1)\n                nc += 1\n            \n            return t_cnt\n",
        "explanations": "\nWe are assigning to the variable \"k\" instead of comparing it with 1. \n"
    },
    {
        "slug": "linked-list-in-binary-tree",
        "description": "Given a binary tree root and a\u00a0linked list with\u00a0head\u00a0as the first node.\u00a0\nReturn True if all the elements in the linked list starting from the head correspond to some downward path connected in the binary tree\u00a0otherwise return False.\nIn this context downward path means a path that starts at some node and goes downwards.",
        "examples": [
            "Input: head = [4,2,8], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]\nOutput: true\nExplanation: Nodes in blue form a subpath in the binary Tree.",
            "Input: head = [1,4,2,6], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]\nOutput: true",
            "Input: head = [1,4,2,6,8], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]\nOutput: false\nExplanation: There is no path in the binary tree that contains all the elements of the linked list from head."
        ],
        "constraints": "The number of nodes in the tree will be in the range [1, 2500].\nThe number of nodes in the list will be in the range [1, 100].\n1 <= Node.val\u00a0<= 100\u00a0for each node in the linked list and binary tree.",
        "release_time": 1689594574,
        "oracle_code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\n\n        if head is None:\n            return True\n\n        if root is None:\n            return False\n\n        if head.val == root.val:\n            if self.isSame(head, root):\n                return True\n            \n        return self.isSubPath(head, root.left) or self.isSubPath(head, root.right)\n\n    \n    def isSame(self, head, root):\n\n        if head is None:\n            return True\n        \n        if root is None:\n            return False\n\n        if head.val == root.val:\n            return self.isSame(head.next, root.left) or self.isSame(head.next, root.right)\n        \n        return False",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\\n\\n        if head is None:\\n            return True\\n\\n        if root is None:\\n            return False\\n\\n        if head.val == root.val:\\n            if self.isSame(head, root):\\n                return True\\n            \\n        return self.isSubPath(head, root.left) or self.isSubPath(head, root.right)\\n\\n    \\n    def isSame(self, head, root):\\n\\n        if head is None:\\n            return True\\n        \\n        if root is None:\\n            return False\\n\\n        if head.val == root.val:\\n            return self.isSame(head.next, root.left) or self.isSame(head.next, root.right)\\n        \\n        return False\\n        \\n\\n```",
        "level": "medium",
        "buggy_code": "\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\n\n        if head is None:\n            return True\n\n        if root is None:\n            return False\n\n        if head.val == root.val:\n            if self.isSame(head, root):\n                return True\n            \n        return self.isSubPath(head, root.left) or self.isSubPath(head, root.right)\n\n    \n    def isSame(self, head, root):\n\n        if head is None:\n            return True\n        \n        if root is None:\n            return False\n\n        if head.val = root.val: \n            return self.isSame(head.next, root.left) or self.isSame(head.next, root.right)\n        \n        return False\n",
        "explanations": "\nUsed assignment operator (=) instead of equality operator (==) in if condition, causing a syntax error.\n"
    },
    {
        "slug": "plates-between-candles",
        "description": "There is a long table with a line of plates and candles arranged on top of it. You are given a 0-indexed string s consisting of characters '*' and '|' only, where a '*' represents a plate and a '|' represents a candle.\nYou are also given a 0-indexed 2D integer array queries where queries[i] = [lefti, righti] denotes the substring s[lefti...righti] (inclusive). For each query, you need to find the number of plates between candles that are in the substring. A plate is considered between candles if there is at least one candle to its left and at least one candle to its right in the substring.\n\nFor example, s = \"||**||**|*\", and a query [3, 8] denotes the substring \"*||**|\". The number of plates between candles in this substring is 2, as each of the two plates has at least one candle in the substring to its left and right.\n\nReturn an integer array answer where answer[i] is the answer to the ith query.",
        "examples": [
            "Input: s = \"**|**|***|\", queries = [[2,5],[5,9]]\nOutput: [2,3]\nExplanation:\n- queries[0] has two plates between candles.\n- queries[1] has three plates between candles.",
            "Input: s = \"***|**|*****|**||**|*\", queries = [[1,17],[4,5],[14,17],[5,11],[15,16]]\nOutput: [9,0,0,0,0]\nExplanation:\n- queries[0] has nine plates between candles.\n- The other queries have zero plates between candles."
        ],
        "constraints": "3 <= s.length <= 105\ns consists of '*' and '|' characters.\n1 <= queries.length <= 105\nqueries[i].length == 2\n0 <= lefti <= righti < s.length",
        "release_time": 1689465278,
        "oracle_code": "class Solution:\n    def platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:\n        candies = [i for i, c in enumerate(s) if c == \"|\"]\n        \n        def bns(x: int) -> int:\n            l, r = 0, len(candies) - 1\n            while l <= r:\n                m = (l + r) // 2\n                if candies[m] < x: l = m + 1\n                else: r = m - 1\n            return l\n\n        ans = []\n        for a, b in queries:\n            l, r = bns(a), bns(b + 1) - 1\n            ans.append(candies[r] - candies[l] - (r - l) if l < r else 0)\n        return ans",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n1. Binary Search\\n```\\nclass Solution:\\n    def platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:\\n        candies = [i for i, c in enumerate(s) if c == \"|\"]\\n        \\n        def bns(x: int) -> int:\\n            l, r = 0, len(candies) - 1\\n            while l <= r:\\n                m = (l + r) // 2\\n                if candies[m] < x: l = m + 1\\n                else: r = m - 1\\n            return l\\n\\n        ans = []\\n        for a, b in queries:\\n            l, r = bns(a), bns(b + 1) - 1\\n            ans.append(candies[r] - candies[l] - (r - l) if l < r else 0)\\n        return ans\\n```\\n- TC: $$O(NlogN)$$\\n- SC: $$O(N)$$\\n\\n2. Prefix Sum\\n```\\nclass Solution:\\n    def platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:\\n        psum, next, prev = [0] * (len(s) + 1), [float(\"inf\")] * (len(s) + 1), [0] * (len(s) + 1)\\n        res = []\\n        for i, ch in enumerate(s):\\n            psum[i + 1] = psum[i] + (ch == \\'|\\')\\n            prev[i + 1] = i if ch == \\'|\\' else prev[i]\\n        for i, ch in reversed(list(enumerate(s))):\\n            next[i] = i if ch == \\'|\\' else next[i + 1]\\n        for q in queries:\\n            l, r = next[q[0]], prev[q[1] + 1]\\n            res.append(r - l - (psum[r] - psum[l]) if l < r else 0)\\n        return res\\n```\\n- TC: $$O(N)$$\\n- SC: $$O(N)$$",
        "level": "medium",
        "buggy_code": "\nclass Solution:\n    def platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:\n        candies = [i for i, c in enumerate(s) if c = \"|\"]\n        \n        def bns(x: int) -> int:\n            l, r = 0, len(candies) - 1\n            while l <= r:\n                m = (l + r) // 2\n                if candies[m] = x: l = m + 1\n                else: r = m - 1\n            return l\n\n        ans = []\n        for a, b in queries:\n            l, r = bns(a), bns(b + 1) - 1\n            ans.append(candies[r] - candies[l] - (r - l) if l == r else 0)\n        return ans\n",
        "explanations": "\nUsed assignment operator (=) instead of equality operator (==) which changes the program logic.\n"
    }
]