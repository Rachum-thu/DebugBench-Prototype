[
    {
        "slug": "decode-the-slanted-ciphertext",
        "description": "A string originalText is encoded using a slanted transposition cipher to a string encodedText with the help of a matrix having a fixed number of rows rows.\noriginalText is placed first in a top-left to bottom-right manner.\n\nThe blue cells are filled first, followed by the red cells, then the yellow cells, and so on, until we reach the end of originalText. The arrow indicates the order in which the cells are filled. All empty cells are filled with ' '. The number of columns is chosen such that the rightmost column will not be empty after filling in originalText.\nencodedText is then formed by appending all characters of the matrix in a row-wise fashion.\n\nThe characters in the blue cells are appended first to encodedText, then the red cells, and so on, and finally the yellow cells. The arrow indicates the order in which the cells are accessed.\nFor example, if originalText = \"cipher\" and rows = 3, then we encode it in the following manner:\n\nThe blue arrows depict how originalText is placed in the matrix, and the red arrows denote the order in which encodedText is formed. In the above example, encodedText = \"ch ie pr\".\nGiven the encoded string encodedText and number of rows rows, return the original string originalText.\nNote: originalText does not have any trailing spaces ' '. The test cases are generated such that there is only one possible originalText.",
        "examples": [
            "Input: encodedText = \"ch   ie   pr\", rows = 3\nOutput: \"cipher\"\nExplanation: This is the same example described in the problem description.",
            "Input: encodedText = \"iveo    eed   l te   olc\", rows = 4\nOutput: \"i love leetcode\"\nExplanation: The figure above denotes the matrix that was used to encode originalText. \nThe blue arrows show how we can find originalText from encodedText.",
            "Input: encodedText = \"coding\", rows = 1\nOutput: \"coding\"\nExplanation: Since there is only 1 row, both originalText and encodedText are the same."
        ],
        "constraints": "0 <= encodedText.length <= 106\nencodedText consists of lowercase English letters and ' ' only.\nencodedText is a valid encoding of some originalText that does not have trailing spaces.\n1 <= rows <= 1000\nThe testcases are generated such that there is only one possible originalText.",
        "release_time": 1681219442,
        "oracle_code": "class Solution:\n    def decodeCiphertext(self, encoded_text: str, rows: int) -> str:\n        if rows == 1:\n            return encoded_text\n\n        N = len(encoded_text)\n        cols = N // rows\n        i, j, k = 0, 0, 0\n        original_text = []\n\n        while k < N:\n            original_text.append(encoded_text[k])\n            i += 1\n            if i == rows:\n                i = 0\n                j += 1\n            k = i*(cols + 1) + j\n\n        return ''.join(original_text).rstrip()",
        "content": "![Capture d\\u2019\\xE9cran (96).png](https://assets.leetcode.com/users/images/3e9f8a31-b0d3-4995-ae49-64d20c8c39d1_1681219407.2042663.png)\\n\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def decodeCiphertext(self, encoded_text: str, rows: int) -> str:\\n        if rows == 1:\\n            return encoded_text\\n\\n        N = len(encoded_text)\\n        cols = N // rows\\n        i, j, k = 0, 0, 0\\n        original_text = []\\n\\n        while k < N:\\n            original_text.append(encoded_text[k])\\n            i += 1\\n            if i == rows:\\n                i = 0\\n                j += 1\\n            k = i*(cols + 1) + j\\n\\n        return \\'\\'.join(original_text).rstrip()\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution:\n    def decodeCiphertext(self, encoded_text: str, rows: int) -> str:\n        if rows == 1:\n            return encoded_text\n\n        N = len(encoded_text)\n        cols = N // rows\n        i, j, k = 0, 0, 0\n        original_text = []\n\n        while k < N:\n            original_text.append(encoded_text[k])\n            i += 1\n            if i == rows + 1:\n                i = 0\n                j += 1\n            k = i*(cols + 1) + j\n\n        return ''.join(original_text).rstrip()\n",
        "explanations": "\nThe bug causes an index error when i equals rows+1.\n"
    },
    {
        "slug": "count-anagrams",
        "description": "You are given a string s containing one or more words. Every consecutive pair of words is separated by a single space ' '.\nA string t is an anagram of string s if the ith word of t is a permutation of the ith word of s.\n\nFor example, \"acb dfe\" is an anagram of \"abc def\", but \"def cab\"\u00a0and \"adc bef\" are not.\n\nReturn the number of distinct anagrams of s. Since the answer may be very large, return it modulo 109 + 7.",
        "examples": [
            "Input: s = \"too hot\"\nOutput: 18\nExplanation: Some of the anagrams of the given string are \"too hot\", \"oot hot\", \"oto toh\", \"too toh\", and \"too oht\".",
            "Input: s = \"aa\"\nOutput: 1\nExplanation: There is only one anagram possible for the given string."
        ],
        "constraints": "1 <= s.length <= 105\ns consists of lowercase English letters and spaces ' '.\nThere is single space between consecutive words.",
        "release_time": 1675229602,
        "oracle_code": "mod = 10**9+7\n\nclass Solution:\n    def countAnagrams(self, s: str) -> int:\n\n        l = s.split()\n        ans = 1\n\n        for i in l:\n            d = {}\n        # counting frequencies of word i in dictionary d\n            for j in i:\n                if(d.get(j)):\n                    d[j] += 1\n                else:\n                    d[j] = 1  \n            \n            duplicates = 1\n            for j in d.values():\n                duplicates *= math.factorial(j)\n            curr = math.factorial(len(i))//duplicates\n\n            ans *= curr\n            ans = ans%mod\n\n        return ans",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe idea is very simple. Total count of anagrams for each word is\\n(factorial of length of word) divided by factorial of duplicates.\\n\\nEg : aabbc -  5!/(2! * 2!)\\n\\n# Code\\n```\\nmod = 10**9+7\\n\\nclass Solution:\\n    def countAnagrams(self, s: str) -> int:\\n\\n        l = s.split()\\n        ans = 1\\n\\n        for i in l:\\n            d = {}\\n        # counting frequencies of word i in dictionary d\\n            for j in i:\\n                if(d.get(j)):\\n                    d[j] += 1\\n                else:\\n                    d[j] = 1  \\n            \\n            duplicates = 1\\n            for j in d.values():\\n                duplicates *= math.factorial(j)\\n            curr = math.factorial(len(i))//duplicates\\n\\n            ans *= curr\\n            ans = ans%mod\\n\\n        return ans        \\n        \\n        \\n```",
        "level": "hard",
        "buggy_code": "\nmod = 10**9+7\n\nclass Solution:\n    def countAnagrams(self, s: str) -> int:\n\n        l = s.split()\n        ans = 1\n\n        for i in l:\n            d = {}\n        # counting frequencies of word i in dictionary d\n            for j in i:\n                if(d.get(j)):\n                    d[j] += 1\n                else:\n                    d[j] = 1  \n            \n            duplicates = 1\n            for j in d.values():\n                duplicates *= math.factorial(j)\n            curr = math.factorial(len(i)+1)//duplicates\n\n            ans *= curr\n            ans = ans%mod\n\n        return ans\n",
        "explanations": "\nIn the expression \"math.factorial(len(i)+1)\", 1 is unnecessarily added. It causes IndexError.\n"
    },
    {
        "slug": "arithmetic-slices-ii-subsequence",
        "description": "Given an integer array nums, return the number of all the arithmetic subsequences of nums.\nA sequence of numbers is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.\n\nFor example, [1, 3, 5, 7, 9], [7, 7, 7, 7], and [3, -1, -5, -9] are arithmetic sequences.\nFor example, [1, 1, 2, 5, 7] is not an arithmetic sequence.\n\nA subsequence of an array is a sequence that can be formed by removing some elements (possibly none) of the array.\n\nFor example, [2,5,10] is a subsequence of [1,2,1,2,4,1,5,10].\n\nThe test cases are generated so that the answer fits in 32-bit integer.",
        "examples": [
            "Input: nums = [2,4,6,8,10]\nOutput: 7\nExplanation: All arithmetic subsequence slices are:\n[2,4,6]\n[4,6,8]\n[6,8,10]\n[2,4,6,8]\n[4,6,8,10]\n[2,4,6,8,10]\n[2,6,10]",
            "Input: nums = [7,7,7,7,7]\nOutput: 16\nExplanation: Any subsequence of this array is arithmetic."
        ],
        "constraints": "1\u00a0 <= nums.length <= 1000\n-231 <= nums[i] <= 231 - 1",
        "release_time": 1669526242,
        "oracle_code": "class Solution:\n    def numberOfArithmeticSlices(self, nums: List[int]) -> int:\n        total, n = 0, len(nums)\n        dp = [defaultdict(int) for _ in nums]\n        for i in range(1, n):\n            for j in range(i):\n                diff = nums[j] - nums[i]\n                dp[i][diff] += dp[j][diff] + 1\n                total += dp[j][diff]\n        return total",
        "content": "**Python**\\n```\\nclass Solution:\\n    def numberOfArithmeticSlices(self, nums: List[int]) -> int:\\n        total, n = 0, len(nums)\\n        dp = [defaultdict(int) for _ in nums]\\n        for i in range(1, n):\\n            for j in range(i):\\n                diff = nums[j] - nums[i]\\n                dp[i][diff] += dp[j][diff] + 1\\n                total += dp[j][diff]\\n        return total\\n```\\n\\n**Swift**\\n```\\nclass Solution {\\n    func numberOfArithmeticSlices(_ nums: [Int]) -> Int {\\n        var total = 0\\n        let n = nums.count\\n        var dp = Array(repeating: [Int: Int](), count: n)\\n        for i in 1..<n {\\n            for j in 0..<i {\\n                let diff = nums[j] - nums[i]\\n                dp[i][diff, default: 0] += dp[j][diff, default: 0] + 1\\n                total += dp[j][diff, default: 0]\\n            }\\n        }\\n        return total\\n    }\\n}\\n```",
        "level": "hard",
        "buggy_code": "\nclass Solution:\n    def numberOfArithmeticSlices(self, nums: List[int]) -> int:\n        total, n = 0, len(nums)\n        dp = [defaultdict(int) for _ in nums]\n        for i in range(1, n):\n            for j in range(i):\n                diff = nums[j] - nums[i]\n                dp[i+1][diff] += dp[j][diff] + 1\n                total += dp[j][diff]\n        return total\n",
        "explanations": "\nAdded invalid index `i+1` in `dp`, causing indexing error as `i+1` can go out of index range.\n"
    },
    {
        "slug": "jump-game-ii",
        "description": "You are given a 0-indexed array of integers nums of length n. You are initially positioned at nums[0].\nEach element nums[i] represents the maximum length of a forward jump from index i. In other words, if you are at nums[i], you can jump to any nums[i + j] where:\n\n0 <= j <= nums[i] and\ni + j < n\n\nReturn the minimum number of jumps to reach nums[n - 1]. The test cases are generated such that you can reach nums[n - 1].",
        "examples": [
            "Input: nums = [2,3,1,1,4]\nOutput: 2\nExplanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.",
            "Input: nums = [2,3,0,1,4]\nOutput: 2"
        ],
        "constraints": "1 <= nums.length <= 104\n0 <= nums[i] <= 1000\nIt's guaranteed that you can reach nums[n - 1].",
        "release_time": 1679374027,
        "oracle_code": "class Solution:\n    def jump(self, nums: List[int]) -> int:\n        #print(nums)\n        L=len(nums)\n        if L==1:\n            return 0\n        steps=[0]\n        for i in range(nums[0]):\n            steps.append(1)\n        for index in range(1,L):\n            len_steps=len(steps)\n            if len_steps >= nums[index]+index+1:\n                index += 1\n            elif len_steps < nums[index]+index+1:\n                for j in range(nums[index]+index-len_steps+1):\n                    #print(index-1,steps[index-1])\n                    steps.append(steps[index]+1)\n            #print(steps)\n        return steps[L-1]",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        #print(nums)\\n        L=len(nums)\\n        if L==1:\\n            return 0\\n        steps=[0]\\n        for i in range(nums[0]):\\n            steps.append(1)\\n        for index in range(1,L):\\n            len_steps=len(steps)\\n            if len_steps >= nums[index]+index+1:\\n                index += 1\\n            elif len_steps < nums[index]+index+1:\\n                for j in range(nums[index]+index-len_steps+1):\\n                    #print(index-1,steps[index-1])\\n                    steps.append(steps[index]+1)\\n            #print(steps)\\n        return steps[L-1]\\n\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution:\n    def jump(self, nums: List[int]) -> int:\n        L=len(nums)\n        if L==1:\n            return 0\n        steps=[0]\n        for i in range(nums[0]):\n            steps.append(1)\n        for index in range(1,L):\n            len_steps=len(steps)\n            if len_steps >= nums[index]+index+1:\n                index += 1\n            elif len_steps < nums[index]+index+1:\n                for j in range(nums[index]+index-len_steps+1):\n                    steps.append(steps[index+1]+1)\n        return steps[L-1]\n",
        "explanations": "\nThis code has an indexing error in steps.append(steps[index+1]+1) when index equals len(steps)-1.\n"
    },
    {
        "slug": "lexicographically-smallest-palindrome",
        "description": "You are given a string s consisting of lowercase English letters, and you are allowed to perform operations on it. In one operation, you can replace a character in s with another lowercase English letter.\nYour task is to make s a palindrome with the minimum number of operations possible. If there are multiple palindromes that can be made using the minimum number of operations, make the lexicographically smallest one.\nA string a is lexicographically smaller than a string b (of the same length) if in the first position where a and b differ, string a has a letter that appears earlier in the alphabet than the corresponding letter in b.\nReturn the resulting palindrome string.",
        "examples": [
            "Input: s = \"egcfe\"\nOutput: \"efcfe\"\nExplanation: The minimum number of operations to make \"egcfe\" a palindrome is 1, and the lexicographically smallest palindrome string we can get by modifying one character is \"efcfe\", by changing 'g'.",
            "Input: s = \"abcd\"\nOutput: \"abba\"\nExplanation: The minimum number of operations to make \"abcd\" a palindrome is 2, and the lexicographically smallest palindrome string we can get by modifying two characters is \"abba\".",
            "Input: s = \"seven\"\nOutput: \"neven\"\nExplanation: The minimum number of operations to make \"seven\" a palindrome is 1, and the lexicographically smallest palindrome string we can get by modifying one character is \"neven\"."
        ],
        "constraints": "1 <= s.length <= 1000\ns\u00a0consists of only lowercase English letters.",
        "release_time": 1684850284,
        "oracle_code": "class Solution:\n    def makeSmallestPalindrome(self, s: str) -> str:\n        before = 0\n        after = len(s)-1\n        l = [i for i in s]\n        while before <= len(s)/2:\n            l[before] = min(l[before], l[after])\n            l[after] = l[before]\n            before+=1\n            after-=1\n        return \"\".join(l)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: 214 ms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 16.5 MB\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def makeSmallestPalindrome(self, s: str) -> str:\\n        before = 0\\n        after = len(s)-1\\n        l = [i for i in s]\\n        while before <= len(s)/2:\\n            l[before] = min(l[before], l[after])\\n            l[after] = l[before]\\n            before+=1\\n            after-=1\\n        return \"\".join(l)\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution:\n    def makeSmallestPalindrome(self, s: str) -> str:\n        before = 0\n        after = len(s)-1\n        l = [i for i in s]\n        while before <= len(s)/2:\n            l[before] = min(l[before], l[after])\n            l[after] = l[before]\n            before+=1\n            after+=1\n        return \"\".join(l)\n",
        "explanations": "\nThe variable \"after\" is improperly incremented inside the loop, which results in indexing beyond the list's range.\n"
    },
    {
        "slug": "remove-duplicates-from-sorted-array-ii",
        "description": "Given an integer array nums sorted in non-decreasing order, remove some duplicates in-place such that each unique element appears at most twice. The relative order of the elements should be kept the same.\nSince it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums\u00a0should hold the final result. It does not matter what you leave beyond the first\u00a0k\u00a0elements.\nReturn k after placing the final result in the first k slots of nums.\nDo not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\nCustom Judge:\nThe judge will test your solution with the following code:\n\nint[] nums = [...]; // Input array\nint[] expectedNums = [...]; // The expected answer with correct length\n\nint k = removeDuplicates(nums); // Calls your implementation\n\nassert k == expectedNums.length;\nfor (int i = 0; i < k; i++) {\n    assert nums[i] == expectedNums[i];\n}\n\nIf all assertions pass, then your solution will be accepted.",
        "examples": [
            "Input: nums = [1,1,1,2,2,3]\nOutput: 5, nums = [1,1,2,2,3,_]\nExplanation: Your function should return k = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).",
            "Input: nums = [0,0,1,1,1,1,2,3,3]\nOutput: 7, nums = [0,0,1,1,2,3,3,_,_]\nExplanation: Your function should return k = 7, with the first seven elements of nums being 0, 0, 1, 1, 2, 3 and 3 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores)."
        ],
        "constraints": "1 <= nums.length <= 3 * 104\n-104 <= nums[i] <= 104\nnums is sorted in non-decreasing order.",
        "release_time": 1691129463,
        "oracle_code": "class Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        ans=2\n        for i in range(2,len(nums)):\n            if nums[i]!=nums[ans-2]:nums[ans]=nums[i];ans+=1\n        return ans",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![image.png](https://assets.leetcode.com/users/images/7d40d8c6-78b0-4c5f-83f3-e20650fbd9e8_1691129420.0068429.png)\\n\\n# Code\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        ans=2\\n        for i in range(2,len(nums)):\\n            if nums[i]!=nums[ans-2]:nums[ans]=nums[i];ans+=1\\n        return ans\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        ans=2\n        for i in range(2,len(nums)+1):\n            if nums[i]!=nums[ans-2]:nums[ans]=nums[i];ans+=1\n        return ans\n",
        "explanations": "\nThe loop's range exceeds the length of the list, causing an index out of range error.\n"
    },
    {
        "slug": "find-peak-element",
        "description": "A peak element is an element that is strictly greater than its neighbors.\nGiven a 0-indexed integer array nums, find a peak element, and return its index. If the array contains multiple peaks, return the index to any of the peaks.\nYou may imagine that nums[-1] = nums[n] = -\u221e. In other words, an element is always considered to be strictly greater than a neighbor that is outside the array.\nYou must write an algorithm that runs in O(log n) time.",
        "examples": [
            "Input: nums = [1,2,3,1]\nOutput: 2\nExplanation: 3 is a peak element and your function should return the index number 2.",
            "Input: nums = [1,2,1,3,5,6,4]\nOutput: 5\nExplanation: Your function can return either index number 1 where the peak element is 2, or index number 5 where the peak element is 6."
        ],
        "constraints": "1 <= nums.length <= 1000\n-231 <= nums[i] <= 231 - 1\nnums[i] != nums[i + 1] for all valid i.",
        "release_time": 1689939984,
        "oracle_code": "class Solution:\n    def findPeakElement(self, nums: List[int]) -> int:\n        n=len(nums)\n        low=0\n        high=n-1\n        if n==1:\n            return 0\n        \n        while low<=high:\n            mid=(low+high)//2\n            if (mid==0 or nums[mid]>=nums[mid-1] ) and (mid==n-1 or nums[mid]>=nums[mid+1]) :\n                return mid\n            elif nums[mid]<=nums[mid+1]:\n                low=mid+1\n            else:\n                high=mid-1\n        return -1",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![image.png](https://assets.leetcode.com/users/images/505c2b70-2b55-4398-bf2d-50123576dc6c_1689939982.9395442.png)\\n\\n# Code\\n```\\nclass Solution:\\n    def findPeakElement(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        low=0\\n        high=n-1\\n        if n==1:\\n            return 0\\n        \\n        while low<=high:\\n            mid=(low+high)//2\\n            if (mid==0 or nums[mid]>=nums[mid-1] ) and (mid==n-1 or nums[mid]>=nums[mid+1]) :\\n                return mid\\n            elif nums[mid]<=nums[mid+1]:\\n                low=mid+1\\n            else:\\n                high=mid-1\\n        return -1\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution:\n    def findPeakElement(self, nums: List[int]) -> int:\n        n=len(nums)\n        low=0\n        high=n-1\n        if n==1:\n            return 0\n        \n        while low<=high:\n            mid=(low+high)//2\n            if (mid==0 or nums[mid]>=nums[mid-1] ) and (mid==n or nums[mid]>=nums[mid+1]) :\n                return mid\n            elif nums[mid]<=nums[mid+1]:\n                low=mid+1\n            else:\n                high=mid-1\n        return -1\n",
        "explanations": "\nThe condition 'mid == n' in the 'if' statement will cause an indexing error.\n"
    },
    {
        "slug": "max-points-on-a-line",
        "description": "Given an array of points where points[i] = [xi, yi] represents a point on the X-Y plane, return the maximum number of points that lie on the same straight line.",
        "examples": [
            "Input: points = [[1,1],[2,2],[3,3]]\nOutput: 3",
            "Input: points = [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]\nOutput: 4"
        ],
        "constraints": "1 <= points.length <= 300\npoints[i].length == 2\n-104 <= xi, yi <= 104\nAll the points are unique.",
        "release_time": 1673194328,
        "oracle_code": "from collections import defaultdict\nclass Solution:\n    def maxPoints(self, points: List[List[int]]) -> int:\n        N = len(points)\n        D = defaultdict(set)\n        if N <= 2:\n            return N \n        for i in range(N):\n            x1, y1 = points[i]\n            for j in range(i+1, N):\n                x2, y2 = points[j]\n                if y1 == y2:\n                    k1, k2 = 'inf', y1\n                elif x1 == x2:\n                    k1, k2 = x1, 'inf'\n                else:\n                    k1, k2 = (x1-x2)/(y2-y1), (x2*y1-x1*y2)/(y2-y1)\n                D[(k1,k2)].add(tuple(points[i]))\n                D[(k1,k2)].add(tuple(points[j]))\n        return max([len(i) for i in D.values()])",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        N = len(points)\\n        D = defaultdict(set)\\n        if N <= 2:\\n            return N \\n        for i in range(N):\\n            x1, y1 = points[i]\\n            for j in range(i+1, N):\\n                x2, y2 = points[j]\\n                if y1 == y2:\\n                    k1, k2 = \\'inf\\', y1\\n                elif x1 == x2:\\n                    k1, k2 = x1, \\'inf\\'\\n                else:\\n                    k1, k2 = (x1-x2)/(y2-y1), (x2*y1-x1*y2)/(y2-y1)\\n                D[(k1,k2)].add(tuple(points[i]))\\n                D[(k1,k2)].add(tuple(points[j]))\\n        return max([len(i) for i in D.values()])\\n        \\n\\n```",
        "level": "hard",
        "buggy_code": "\nfrom collections import defaultdict\nclass Solution:\n    def maxPoints(self, points: List[List[int]]) -> int:\n        N = len(points)\n        D = defaultdict(set)\n        if N <= 2:\n            return N \n        for i in range(N+1):     \n            x1, y1 = points[i]\n            for j in range(i+1, N):\n                x2, y2 = points[j]\n                if y1 == y2:\n                    k1, k2 = 'inf', y1\n                elif x1 == x2:\n                    k1, k2 = x1, 'inf'\n                else:\n                    k1, k2 = (x1-x2)/(y2-y1), (x2*y1-x1*y2)/(y2-y1)\n                D[(k1,k2)].add(tuple(points[i]))\n                D[(k1,k2)].add(tuple(points[j]))\n        return max([len(i) for i in D.values()])\n",
        "explanations": "\nThe for loop tries to access an index that is out of range.\n"
    },
    {
        "slug": "plus-one",
        "description": "You are given a large integer represented as an integer array digits, where each digits[i] is the ith digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading 0's.\nIncrement the large integer by one and return the resulting array of digits.",
        "examples": [
            "Input: digits = [1,2,3]\nOutput: [1,2,4]\nExplanation: The array represents the integer 123.\nIncrementing by one gives 123 + 1 = 124.\nThus, the result should be [1,2,4].",
            "Input: digits = [4,3,2,1]\nOutput: [4,3,2,2]\nExplanation: The array represents the integer 4321.\nIncrementing by one gives 4321 + 1 = 4322.\nThus, the result should be [4,3,2,2].",
            "Input: digits = [9]\nOutput: [1,0]\nExplanation: The array represents the integer 9.\nIncrementing by one gives 9 + 1 = 10.\nThus, the result should be [1,0]."
        ],
        "constraints": "1 <= digits.length <= 100\n0 <= digits[i] <= 9\ndigits does not contain any leading 0's.",
        "release_time": 1692505877,
        "oracle_code": "class Solution:\n    def plusOne(self, digits: List[int]) -> List[int]:\n        s= ''.join(map(str,digits))\n        i=int(s)+1\n        li=list(map(int,str(i)))  \n        return li",
        "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        s= \\'\\'.join(map(str,digits))\\n        i=int(s)+1\\n        li=list(map(int,str(i)))  \\n        return li\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution:\n    def plusOne(self, digits: List[int]) -> List[int]:\n        s= ''.join(map(str,digits))\n        i=int(s)+1\n        li=list(map(int,str(i)))\n        return li[2]  \n",
        "explanations": "\nThe function is returning the 3rd digit of the list, not the entire list.\n"
    },
    {
        "slug": "sort-colors",
        "description": "Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue.\nWe will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively.\nYou must solve this problem without using the library's sort function.",
        "examples": [
            "Input: nums = [2,0,2,1,1,0]\nOutput: [0,0,1,1,2,2]",
            "Input: nums = [2,0,1]\nOutput: [0,1,2]"
        ],
        "constraints": "n == nums.length\n1 <= n <= 300\nnums[i] is either 0, 1, or 2.",
        "release_time": 1688138300,
        "oracle_code": "class Solution:\n    def sortColors(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        low=mid=0\n        high=len(nums)-1\n        while mid<=high:\n            if nums[mid]==0:\n                nums[low],nums[mid]=nums[mid],nums[low]\n                low+=1\n                mid+=1\n            elif nums[mid]==1:\n                mid+=1\n            else:\n                nums[mid],nums[high]=nums[high],nums[mid]\n                high-=1",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![image.png](https://assets.leetcode.com/users/images/f5772358-db82-4340-9282-42f9009586dd_1688138290.4675047.png)\\n\\n# Code\\n```\\nclass Solution:\\n    def sortColors(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        low=mid=0\\n        high=len(nums)-1\\n        while mid<=high:\\n            if nums[mid]==0:\\n                nums[low],nums[mid]=nums[mid],nums[low]\\n                low+=1\\n                mid+=1\\n            elif nums[mid]==1:\\n                mid+=1\\n            else:\\n                nums[mid],nums[high]=nums[high],nums[mid]\\n                high-=1\\n                \\n        \\n\\n            \\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution:\n    def sortColors(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        low=mid=0\n        high=len(nums)\n        while mid<=high:\n            if nums[mid]==0:\n                nums[low],nums[mid]=nums[mid],nums[low]\n                low+=1\n                mid+=1\n            elif nums[mid]==1:\n                mid+=1\n            else:\n                nums[mid],nums[high]=nums[high],nums[mid]\n                high-=1\n",
        "explanations": "\nThe 'high' variable includes length of 'nums', causing an out-of-range error on indexing.\n"
    },
    {
        "slug": "x-of-a-kind-in-a-deck-of-cards",
        "description": "You are given an integer array deck where deck[i] represents the number written on the ith card.\nPartition the cards into one or more groups such that:\n\nEach group has exactly x cards where x > 1, and\nAll the cards in one group have the same integer written on them.\n\nReturn true if such partition is possible, or false otherwise.",
        "examples": [
            "Input: deck = [1,2,3,4,4,3,2,1]\nOutput: true\nExplanation: Possible partition [1,1],[2,2],[3,3],[4,4].",
            "Input: deck = [1,1,1,2,2,2,3,3]\nOutput: false\nExplanation: No possible partition."
        ],
        "constraints": "1 <= deck.length <= 104\n0 <= deck[i] < 104",
        "release_time": 1669647083,
        "oracle_code": "class Solution:\n    def hasGroupsSizeX(self, deck: List[int]) -> bool:\n        count = collections.Counter(deck)\n        val = count.values()\n        import math\n        m = math.gcd(*val)\n        if m >= 2:\n            return True \n        else:\n            return False",
        "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def hasGroupsSizeX(self, deck: List[int]) -> bool:\\n        count = collections.Counter(deck)\\n        val = count.values()\\n        import math\\n        m = math.gcd(*val)\\n        if m >= 2:\\n            return True \\n        else:\\n            return False\\n\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution:\n    def hasGroupsSizeX(self, deck: List[int]) -> bool:\n        count = collections.Counter(deck)\n        val = count.values()\n        import math\n        m = math.gcd(*val)\n        if m >= 3:\n            return True \n        else:\n            return val[2]\n",
        "explanations": "\nIf the count.values() list length is less than 3, accessing the index 2 will raise an IndexError."
    },
    {
        "slug": "valid-permutations-for-di-sequence",
        "description": "You are given a string s of length n where s[i] is either:\n\n'D' means decreasing, or\n'I' means increasing.\n\nA permutation perm of n + 1 integers of all the integers in the range [0, n] is called a valid permutation if for all valid i:\n\nIf s[i] == 'D', then perm[i] > perm[i + 1], and\nIf s[i] == 'I', then perm[i] < perm[i + 1].\n\nReturn the number of valid permutations perm. Since the answer may be large, return it modulo 109 + 7.",
        "examples": [
            "Input: s = \"DID\"\nOutput: 5\nExplanation: The 5 valid permutations of (0, 1, 2, 3) are:\n(1, 0, 3, 2)\n(2, 0, 3, 1)\n(2, 1, 3, 0)\n(3, 0, 2, 1)\n(3, 1, 2, 0)",
            "Input: s = \"D\"\nOutput: 1"
        ],
        "constraints": "n == s.length\n1 <= n <= 200\ns[i] is either 'I' or 'D'.",
        "release_time": 1664693730,
        "oracle_code": "class Solution:\n    def numPermsDISequence(self, s: str) -> int:\n        mem=defaultdict(int)\n        def dfs(i,val=0):\n            if i==len(s):\n                return 1\n            if (i,val) in mem:\n                return mem[i,val]\n            p=0\n            if s[i]==\"D\":\n                for ind in range(0,val+1):\n                    p+=dfs(i+1,ind)%(10**9+7)\n            else:\n                for ind in range(val+1,i+2):\n                    p+=dfs(i+1,ind)%(10**9+7)\n            mem[i,val]=p\n            return p\n        return dfs(0)",
        "content": "To add a new character to a sequence we only have to consider the last element-\\n\\nLets say currently DID sequence is 1032- this can form\\n\\nDIDI - in cases where we end with 3,4\\nDIDD - in cases where we end with 0,1,2\\n\\nSo just use the last element value to create a new sequence.\\n\\n```\\nclass Solution:\\n    def numPermsDISequence(self, s: str) -> int:\\n        mem=defaultdict(int)\\n        def dfs(i,val=0):\\n            if i==len(s):\\n                return 1\\n            if (i,val) in mem:\\n                return mem[i,val]\\n            p=0\\n            if s[i]==\"D\":\\n                for ind in range(0,val+1):\\n                    p+=dfs(i+1,ind)%(10**9+7)\\n            else:\\n                for ind in range(val+1,i+2):\\n                    p+=dfs(i+1,ind)%(10**9+7)\\n            mem[i,val]=p\\n            return p\\n        return dfs(0)\\n ```\\n\\t\\t\\t\\t",
        "level": "hard",
        "buggy_code": "\nclass Solution:\n    def numPermsDISequence(self, s: str) -> int:\n        mem=defaultdict(int)\n        def dfs(i,val=0):\n            if i==len(s):\n                return 1\n            if (i,val) in mem:\n                return mem[i,val]\n            p=0\n            if s[i]==\"D\":\n                for ind in range(0,val+2): \n                    p+=dfs(i+1,ind)%(10**9+7)\n            else:\n                for ind in range(val+1,i+3): \n                    p+=dfs(i+1,ind)%(10**9+7)\n            mem[i,val]=p\n            return p\n        return dfs(0)\n",
        "explanations": "\nThe indexing error pushes the iterations beyond the range, causing the code to crash.\n"
    },
    {
        "slug": "node-with-highest-edge-score",
        "description": "You are given a directed graph with n nodes labeled from 0 to n - 1, where each node has exactly one outgoing edge.\nThe graph is represented by a given 0-indexed integer array edges of length n, where edges[i] indicates that there is a directed edge from node i to node edges[i].\nThe edge score of a node i is defined as the sum of the labels of all the nodes that have an edge pointing to i.\nReturn the node with the highest edge score. If multiple nodes have the same edge score, return the node with the smallest index.",
        "examples": [
            "Input: edges = [1,0,0,0,0,7,7,5]\nOutput: 7\nExplanation:\n- The nodes 1, 2, 3 and 4 have an edge pointing to node 0. The edge score of node 0 is 1 + 2 + 3 + 4 = 10.\n- The node 0 has an edge pointing to node 1. The edge score of node 1 is 0.\n- The node 7 has an edge pointing to node 5. The edge score of node 5 is 7.\n- The nodes 5 and 6 have an edge pointing to node 7. The edge score of node 7 is 5 + 6 = 11.\nNode 7 has the highest edge score so return 7.",
            "Input: edges = [2,0,0,2]\nOutput: 0\nExplanation:\n- The nodes 1 and 2 have an edge pointing to node 0. The edge score of node 0 is 1 + 2 = 3.\n- The nodes 0 and 3 have an edge pointing to node 2. The edge score of node 2 is 0 + 3 = 3.\nNodes 0 and 2 both have an edge score of 3. Since node 0 has a smaller index, we return 0."
        ],
        "constraints": "n == edges.length\n2 <= n <= 105\n0 <= edges[i] < n\nedges[i] != i",
        "release_time": 1673006370,
        "oracle_code": "class Solution:\n    def edgeScore(self, edges: List[int]) -> int:\n        n=len(edges)\n        sc=[0]*n\n        mx=0\n        ans=0\n        for i in range(n):\n            sc[edges[i]]+=i\n            if sc[edges[i]]>mx:\n                mx=sc[edges[i]]\n                ans=edges[i]\n            elif sc[edges[i]]==mx:\n                if ans>edges[i]:\n                    ans=edges[i]\n        return ans",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nArray Traversal\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def edgeScore(self, edges: List[int]) -> int:\\n        n=len(edges)\\n        sc=[0]*n\\n        mx=0\\n        ans=0\\n        for i in range(n):\\n            sc[edges[i]]+=i\\n            if sc[edges[i]]>mx:\\n                mx=sc[edges[i]]\\n                ans=edges[i]\\n            elif sc[edges[i]]==mx:\\n                if ans>edges[i]:\\n                    ans=edges[i]\\n        return ans\\n\\n        \\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution:\n    def edgeScore(self, edges: List[int]) -> int:\n        n=len(edges)\n        sc=[0]*n\n        mx=0\n        ans=0\n        for i in range(n):\n            sc[edges[i+1]]+=i\n            if sc[edges[i+1]]>mx:\n                mx=sc[edges[i+1]]\n                ans=edges[i+1]\n            elif sc[edges[i+1]]==mx:\n                if ans>edges[i+1]:\n                    ans=edges[i+1]\n        return ans\n",
        "explanations": "\nIndex i+1 in sc[edges[i+1]] may go out of range at last iteration of the loop.\n"
    },
    {
        "slug": "smallest-string-starting-from-leaf",
        "description": "You are given the root of a binary tree where each node has a value in the range [0, 25] representing the letters 'a' to 'z'.\nReturn the lexicographically smallest string that starts at a leaf of this tree and ends at the root.\nAs a reminder, any shorter prefix of a string is lexicographically smaller.\n\nFor example, \"ab\" is lexicographically smaller than \"aba\".\n\nA leaf of a node is a node that has no children.",
        "examples": [
            "Input: root = [0,1,2,3,4,3,4]\nOutput: \"dba\"",
            "Input: root = [25,1,3,1,3,0,2]\nOutput: \"adz\"",
            "Input: root = [2,2,1,null,1,0,null,0]\nOutput: \"abc\""
        ],
        "constraints": "The number of nodes in the tree is in the range [1, 8500].\n0 <= Node.val <= 25",
        "release_time": 1672085022,
        "oracle_code": "class Solution:\n    def smallestFromLeaf(self, root: Optional[TreeNode]) -> str:\n        self.result=\"\\u017DZZZZZZZZZZZZZZZ\"\n\n        #to check if a node is leaf node, return true if it is\n        def isLeaf(node):\n            if(node):\n                return ((not node.left) and (not node.right))\n            return False\n        \n        # recursive function to traverse\n        def traversar(path,node):\n            if (not node): return\n            \n            #convert value to char and append to current path\n            path+=chr(ord('a')+node.val)\n\n            #if it's lexicographically smaller than current path,   \n            # then replace result with current path.reverse\n            if(isLeaf(node) and path[::-1]<self.result):\n                self.result=path[::-1]\n                return\n            \n            traversar(path,node.left)\n            traversar(path,node.right)\n\n        traversar(\"\",root)\n\n        return self.result",
        "content": "\\n# Approach\\n- We traverse the the tree and pass path to the node till now as parameter of recursive function\\n- When we encounter a leaf node - compare it with lowestPath\\n- if we encounter null we end recursive branch\\n- for normal node we add value to path and pass on/ call recursive function for it\\'s left and right child\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ - time to traverse each node\\n(assuming path to compare paths in negligible othervise)\\n\\n- Space complexity:\\n$$O(1)$$  - not saving anything other one string\\n\\n# Code\\n```\\n\\nclass Solution:\\n    def smallestFromLeaf(self, root: Optional[TreeNode]) -> str:\\n        self.result=\"\\u017DZZZZZZZZZZZZZZZ\"\\n\\n        #to check if a node is leaf node, return true if it is\\n        def isLeaf(node):\\n            if(node):\\n                return ((not node.left) and (not node.right))\\n            return False\\n        \\n        # recursive function to traverse\\n        def traversar(path,node):\\n            if (not node): return\\n            \\n            #convert value to char and append to current path\\n            path+=chr(ord(\\'a\\')+node.val)\\n\\n            #if it\\'s lexicographically smaller than current path,   \\n            # then replace result with current path.reverse\\n            if(isLeaf(node) and path[::-1]<self.result):\\n                self.result=path[::-1]\\n                return\\n            \\n            traversar(path,node.left)\\n            traversar(path,node.right)\\n\\n        traversar(\"\",root)\\n\\n        return self.result\\n            \\n\\n\\n\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution:\n    def smallestFromLeaf(self, root: Optional[TreeNode]) -> str:\n        self.result=\"\\u017DZZZZZZZZZZZZZZZ\"\n\n        #to check if a node is leaf node, return true if it is\n        def isLeaf(node):\n            if(node):\n                return ((not node.left) and (not node.right))\n            return False\n        \n        # recursive function to traverse\n        def traversar(path,node):\n            if (not node): return\n            \n            #convert value to char and append to current path\n            path+=chr(ord('a')+node.val)\n\n            #if it's lexicographically smaller than current path,   \n            # then replace result with current path.reverse\n            if(isLeaf(node) and path[::-1]<self.result[0]):\n                self.result=path[::-1]\n                return\n            \n            traversar(path,node.left)\n            traversar(path,node.right)\n\n        traversar(\"\",root)\n\n        return self.result\n",
        "explanations": "\nThe bug is indexing the 'result' string which is unnecessary and causes IndexError.\n"
    },
    {
        "slug": "generate-random-point-in-a-circle",
        "description": "Given the radius and the position of the center of a circle, implement the function randPoint which generates a uniform random point inside the circle.\nImplement the Solution class:\n\nSolution(double radius, double x_center, double y_center) initializes the object with the radius of the circle radius and the position of the center (x_center, y_center).\nrandPoint() returns a random point inside the circle. A point on the circumference of the circle is considered to be in the circle. The answer is returned as an array [x, y].",
        "examples": [
            "Input\n[\"Solution\", \"randPoint\", \"randPoint\", \"randPoint\"]\n[[1.0, 0.0, 0.0], [], [], []]\nOutput\n[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]\n\nExplanation\nSolution solution = new Solution(1.0, 0.0, 0.0);\nsolution.randPoint(); // return [-0.02493, -0.38077]\nsolution.randPoint(); // return [0.82314, 0.38945]\nsolution.randPoint(); // return [0.36572, 0.17248]"
        ],
        "constraints": "0 <\u00a0radius <= 108\n-107 <= x_center, y_center <= 107\nAt most 3 * 104 calls will be made to randPoint.",
        "release_time": 1673625736,
        "oracle_code": "class Solution:\n\n    def __init__(self, radius: float, x_center: float, y_center: float):\n        self.radius = radius\n        self.x_center = x_center\n        self.y_center = y_center\n        self.x = x_center\n        self.y = y_center\n        self.r = radius\n\n    def randPoint(self) -> List[float]:\n        while True:\n            x = random.uniform(self.x - self.r, self.x + self.r)\n            y = random.uniform(self.y - self.r, self.y + self.r)\n            if (x - self.x) ** 2 + (y - self.y) ** 2 <= self.r ** 2:\n                return [x, y]\n# Your Solution object will be instantiated and called as such:\n# obj = Solution(radius, x_center, y_center)\n# param_1 = obj.randPoint()",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem is to randomly generate points within a circle of radius radius and center point (x_center, y_center).\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach is to use the built-in random.uniform(a, b) function which generates a random float number between a and b. We use this function to generate x and y coordinates for the point. We then check if the point is within the circle by checking if the point\\'s distance from the center of the circle is less than or equal to the radius. If it is, we return the point. If not, we continue generating new points until we find one that is within the circle.\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n\\n    def __init__(self, radius: float, x_center: float, y_center: float):\\n        self.radius = radius\\n        self.x_center = x_center\\n        self.y_center = y_center\\n        self.x = x_center\\n        self.y = y_center\\n        self.r = radius\\n\\n    def randPoint(self) -> List[float]:\\n        while True:\\n            x = random.uniform(self.x - self.r, self.x + self.r)\\n            y = random.uniform(self.y - self.r, self.y + self.r)\\n            if (x - self.x) ** 2 + (y - self.y) ** 2 <= self.r ** 2:\\n                return [x, y]\\n# Your Solution object will be instantiated and called as such:\\n# obj = Solution(radius, x_center, y_center)\\n# param_1 = obj.randPoint()\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution:\n\n    def __init__(self, radius: float, x_center: float, y_center: float):\n        self.radius = radius\n        self.x_center = x_center\n        self.y_center = y_center\n        self.x = x_center\n        self.y = y_center\n        self.r = radius\n\n    def randPoint(self) -> List[float]:\n        while True:\n            x = random.uniform(self.x - self.r[1], self.x + self.r[1])\n            y = random.uniform(self.y - self.r[1], self.y + self.r[1])\n            if (x - self.x) ** 2 + (y - self.y) ** 2 <= self.r[1] ** 2:\n                return [x, y]\n# Your Solution object will be instantiated and called as such:\n# obj = Solution(radius, x_center, y_center)\n# param_1 = obj.randPoint()\n",
        "explanations": "\nTrying to use an indexing operation on a float variable 'r' which isn't indexable.\n"
    },
    {
        "slug": "delete-greatest-value-in-each-row",
        "description": "You are given an m x n matrix grid consisting of positive integers.\nPerform the following operation until grid becomes empty:\n\nDelete the element with the greatest value from each row. If multiple such elements exist, delete any of them.\nAdd the maximum of deleted elements to the answer.\n\nNote that the number of columns decreases by one after each operation.\nReturn the answer after performing the operations described above.",
        "examples": [
            "Input: grid = [[1,2,4],[3,3,1]]\nOutput: 8\nExplanation: The diagram above shows the removed values in each step.\n- In the first operation, we remove 4 from the first row and 3 from the second row (notice that, there are two cells with value 3 and we can remove any of them). We add 4 to the answer.\n- In the second operation, we remove 2 from the first row and 3 from the second row. We add 3 to the answer.\n- In the third operation, we remove 1 from the first row and 1 from the second row. We add 1 to the answer.\nThe final answer = 4 + 3 + 1 = 8.",
            "Input: grid = [[10]]\nOutput: 10\nExplanation: The diagram above shows the removed values in each step.\n- In the first operation, we remove 10 from the first row. We add 10 to the answer.\nThe final answer = 10."
        ],
        "constraints": "m == grid.length\nn == grid[i].length\n1 <= m, n <= 50\n1 <= grid[i][j] <= 100",
        "release_time": 1670732887,
        "oracle_code": "class Solution:\n    def deleteGreatestValue(self, grid: List[List[int]]) -> int:\n        for i in range(0, len(grid)):\n            grid[i].sort()\n        n = len(grid[0])\n        res = 0\n        for j in range(0, n):\n            ans = 0\n            for i in range(0, len(grid)):\n                ans = max(ans, grid[i].pop())\n            res += ans\n            \n        return res",
        "content": "# Code\\n```\\nclass Solution:\\n    def deleteGreatestValue(self, grid: List[List[int]]) -> int:\\n        for i in range(0, len(grid)):\\n            grid[i].sort()\\n        n = len(grid[0])\\n        res = 0\\n        for j in range(0, n):\\n            ans = 0\\n            for i in range(0, len(grid)):\\n                ans = max(ans, grid[i].pop())\\n            res += ans\\n            \\n        return res\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution:\n    def deleteGreatestValue(self, grid: List[List[int]]) -> int:\n        for i in range(0, len(grid)):\n            grid[i].sort()\n        n = len(grid[0])\n        res = 0\n        for j in range(0, n):\n            ans = 0\n            for i in range(0, len(grid)):\n                ans = max(ans, grid[i].pop(-j))  \n            res += ans\n            \n        return res\n",
        "explanations": "\nPopping an element with negative index, results in incorrect element being removed.\n"
    },
    {
        "slug": "invalid-transactions",
        "description": "A transaction is possibly invalid if:\n\nthe amount exceeds $1000, or;\nif it occurs within (and including) 60 minutes of another transaction with the same name in a different city.\n\nYou are given an array of strings transaction where transactions[i] consists of comma-separated values representing the name, time (in minutes), amount, and city of the transaction.\nReturn a list of transactions that are possibly invalid. You may return the answer in any order.",
        "examples": [
            "Input: transactions = [\"alice,20,800,mtv\",\"alice,50,100,beijing\"]\nOutput: [\"alice,20,800,mtv\",\"alice,50,100,beijing\"]\nExplanation: The first transaction is invalid because the second transaction occurs within a difference of 60 minutes, have the same name and is in a different city. Similarly the second one is invalid too.",
            "Input: transactions = [\"alice,20,800,mtv\",\"alice,50,1200,mtv\"]\nOutput: [\"alice,50,1200,mtv\"]",
            "Input: transactions = [\"alice,20,800,mtv\",\"bob,50,1200,mtv\"]\nOutput: [\"bob,50,1200,mtv\"]"
        ],
        "constraints": "transactions.length <= 1000\nEach transactions[i] takes the form \"{name},{time},{amount},{city}\"\nEach {name} and {city} consist of lowercase English letters, and have lengths between 1 and 10.\nEach {time} consist of digits, and represent an integer between 0 and 1000.\nEach {amount} consist of digits, and represent an integer between 0 and 2000.",
        "release_time": 1667938900,
        "oracle_code": "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        invalid = []\n        txn = collections.defaultdict(list)\n        \n        for trn in transactions:\n            name, time, amount, city = trn.split(\",\")\n            txn[name].append([time,amount,city])\n        \n        for trans in range(len(transactions)):\n            name, time, amount, city = transactions[trans].split(\",\")\n            if int(amount) > 1000:\n                invalid.append(transactions[trans])\n            else:\n                for trn in txn[name]:\n                    time_i, _, city_i = trn\n                    if city != city_i and abs(int(time) - int(time_i)) <= 60:\n                        invalid.append(transactions[trans])\n                        break\n\n        return invalid",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nRecords all transactions in a hashmap with default value as list, where the hashing key is the name of the transaction. Now in the second pass, it goes through each transaction and checks if amount is > 1000 else it searches all transactions with the same name in O(1) time and loops through it in O(n) time. If it finds a transaction with the conditions i.e. different city and absolute time difference <= 60. It will append it to the final list.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\nO(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ --> O(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\\n        invalid = []\\n        txn = collections.defaultdict(list)\\n        \\n        for trn in transactions:\\n            name, time, amount, city = trn.split(\",\")\\n            txn[name].append([time,amount,city])\\n        \\n        for trans in range(len(transactions)):\\n            name, time, amount, city = transactions[trans].split(\",\")\\n            if int(amount) > 1000:\\n                invalid.append(transactions[trans])\\n            else:\\n                for trn in txn[name]:\\n                    time_i, _, city_i = trn\\n                    if city != city_i and abs(int(time) - int(time_i)) <= 60:\\n                        invalid.append(transactions[trans])\\n                        break\\n\\n        return invalid\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        invalid = []\n        txn = collections.defaultdict(list)\n        \n        for trn in transactions:\n            name, time, amount, city = trn.split(\",\")\n            txn[name].append([time,amount,city])\n        \n        for trans in range(len(transactions) + 1):\n            name, time, amount, city = transactions[trans].split(\",\")\n            if int(amount) > 1000:\n                invalid.append(transactions[trans])\n            else:\n                for trn in txn[name]:\n                    time_i, _, city_i = trn\n                    if city != city_i and abs(int(time) - int(time_i)) <= 60:\n                        invalid.append(transactions[trans])\n                        break\n\n        return invalid\n",
        "explanations": " \nAn out of range error occurs because the loop variable can exceed the list's index.\n"
    },
    {
        "slug": "binary-tree-level-order-traversal-ii",
        "description": "Given the root of a binary tree, return the bottom-up level order traversal of its nodes' values. (i.e., from left to right, level by level from leaf to root).",
        "examples": [
            "Input: root = [3,9,20,null,null,15,7]\nOutput: [[15,7],[9,20],[3]]",
            "Input: root = [1]\nOutput: [[1]]",
            "Input: root = []\nOutput: []"
        ],
        "constraints": "The number of nodes in the tree is in the range [0, 2000].\n-1000 <= Node.val <= 1000",
        "release_time": 1686416191,
        "oracle_code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:\n        queue=deque()\n        queue.append(root)\n        lst=[]\n        while queue:\n            levels=[]\n            for i in range(len(queue)):\n                tmp=queue.popleft()\n                if tmp:\n                    levels.append(tmp.val)\n                    queue.append(tmp.left)\n                    queue.append(tmp.right)\n\n            if levels:\n                lst.append(levels)\n        return lst[::-1]",
        "content": "# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:\\n        queue=deque()\\n        queue.append(root)\\n        lst=[]\\n        while queue:\\n            levels=[]\\n            for i in range(len(queue)):\\n                tmp=queue.popleft()\\n                if tmp:\\n                    levels.append(tmp.val)\\n                    queue.append(tmp.left)\\n                    queue.append(tmp.right)\\n\\n            if levels:\\n                lst.append(levels)\\n        return lst[::-1]\\n```",
        "level": "medium",
        "buggy_code": "\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:\n        queue=deque()\n        queue.append(root)\n        lst=[]\n        while queue:\n            levels=[]\n            for i in range(len(queue)+1): \n                tmp=queue.popleft()\n                if tmp:\n                    levels.append(tmp.val)\n                    queue.append(tmp.left)\n                    queue.append(tmp.right)\n\n            if levels:\n                lst.append(levels)\n        return lst[::-1]\n",
        "explanations": "\nThe for loop index goes beyond the length of the queue, causing an IndexError.\n"
    },
    {
        "slug": "kth-largest-element-in-an-array",
        "description": "Given an integer array nums and an integer k, return the kth largest element in the array.\nNote that it is the kth largest element in the sorted order, not the kth distinct element.\nCan you solve it without sorting?",
        "examples": [
            "Input: nums = [3,2,1,5,6,4], k = 2\nOutput: 5",
            "Input: nums = [3,2,3,1,2,4,5,5,6], k = 4\nOutput: 4"
        ],
        "constraints": "1 <= k <= nums.length <= 105\n-104 <= nums[i] <= 104",
        "release_time": 1691989741,
        "oracle_code": "class Solution:\n    def findKthLargest(self, nums: List[int], k: int) -> int:\n        return sorted(nums)[-k]",
        "content": "# Approach\\n- Sorting\\n\\n# Complexity\\n- Time complexity: O(n*log(n))\\n\\n# Code\\n```\\nclass Solution:\\n    def findKthLargest(self, nums: List[int], k: int) -> int:\\n        return sorted(nums)[-k]\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution:\n    def findKthLargest(self, nums: List[int], k: int) -> int:\n        return sorted(nums)[-k-1]\n",
        "explanations": "\nThis bug occurs when calling -k-1 index on the sorted list, causing an off-by-one error.\n"
    },
    {
        "slug": "sliding-window-median",
        "description": "The median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle values.\n\nFor examples, if arr = [2,3,4], the median is 3.\nFor examples, if arr = [1,2,3,4], the median is (2 + 3) / 2 = 2.5.\n\nYou are given an integer array nums and an integer k. There is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position.\nReturn the median array for each window in the original array. Answers within 10-5 of the actual value will be accepted.",
        "examples": [
            "Input: nums = [1,3,-1,-3,5,3,6,7], k = 3\nOutput: [1.00000,-1.00000,-1.00000,3.00000,5.00000,6.00000]\nExplanation: \nWindow position                Median\n---------------                -----\n[1  3  -1] -3  5  3  6  7        1\n 1 [3  -1  -3] 5  3  6  7       -1\n 1  3 [-1  -3  5] 3  6  7       -1\n 1  3  -1 [-3  5  3] 6  7        3\n 1  3  -1  -3 [5  3  6] 7        5\n 1  3  -1  -3  5 [3  6  7]       6",
            "Input: nums = [1,2,3,4,2,3,1,4,2], k = 3\nOutput: [2.00000,3.00000,3.00000,3.00000,2.00000,3.00000,2.00000]"
        ],
        "constraints": "1 <= k <= nums.length <= 105\n-231 <= nums[i] <= 231 - 1",
        "release_time": 1687587517,
        "oracle_code": "class Solution:\n    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\n        tree = None\n        ans = []\n        for i, x in enumerate(nums):\n            tree = insert(tree, x)\n            if size(tree) > k:\n                tree = remove(tree, nums[i - k])\n            if size(tree) == k:\n                if k % 2 == 1:\n                    ans.append(get(tree, k // 2 + 1))\n                else:\n                    ans.append((get(tree, k // 2) + get(tree, k // 2 + 1)) / 2)\n        return ans\n\n\n\nclass Node:\n    __slots__ = ['val', 'count', 'weight', 'size', 'left', 'right']\n    def __init__(self, val):\n        self.val = val\n        self.count = 1\n        self.weight = random.random()\n        self.size = 1\n        self.left = self.right = None\n\n\ndef touch(root):\n    if not root:\n        return\n    root.size = root.count + size(root.left) + size(root.right)\n\n\ndef size(root):\n    if not root:\n        return 0\n    return root.size\n\n\ndef insert(root, val):\n    t1, r, t2 = split(root, val)\n    if not r:\n        r = Node(val)\n    else:\n        r.count += 1\n        touch(r)\n    t2 = join(r, t2)\n    return join(t1, t2)\n\n\ndef remove(root, val):\n    t1, r, t2 = split(root, val)\n    if r and r.count > 1:\n        r.count -= 1\n        touch(r)\n        t2 = join(r, t2)\n    return join(t1, t2)\n\n\ndef split(root, val):\n    if not root:\n        return None, None, None\n    elif root.val < val:\n        a, b, c = split(root.right, val)\n        root.right = a\n        touch(root)\n        return root, b, c\n    elif root.val > val:\n        a, b, c = split(root.left, val)\n        root.left = c\n        touch(root)\n        return a, b, root\n    else:\n        a, c = root.left, root.right\n        root.left = root.right = None\n        touch(root)\n        return a, root, c\n\n\ndef join(t1, t2):\n    if not t1:\n        return t2\n    elif not t2:\n        return t1\n    elif t1.weight < t2.weight:\n        t1.right = join(t1.right, t2)\n        touch(t1)\n        return t1\n    else:\n        t2.left = join(t1, t2.left)\n        touch(t2)\n        return t2\n\n\ndef get(root, index):\n    if size(root.left) < index <= size(root.left) + root.count:\n        return root.val\n    elif size(root.left) + root.count < index:\n        return get(root.right, index - root.count - size(root.left))\n    else:\n        return get(root.left, index)",
        "content": "\\n\\n```\\nclass Solution:\\n    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\\n        tree = None\\n        ans = []\\n        for i, x in enumerate(nums):\\n            tree = insert(tree, x)\\n            if size(tree) > k:\\n                tree = remove(tree, nums[i - k])\\n            if size(tree) == k:\\n                if k % 2 == 1:\\n                    ans.append(get(tree, k // 2 + 1))\\n                else:\\n                    ans.append((get(tree, k // 2) + get(tree, k // 2 + 1)) / 2)\\n        return ans\\n\\n\\n\\nclass Node:\\n    __slots__ = [\\'val\\', \\'count\\', \\'weight\\', \\'size\\', \\'left\\', \\'right\\']\\n    def __init__(self, val):\\n        self.val = val\\n        self.count = 1\\n        self.weight = random.random()\\n        self.size = 1\\n        self.left = self.right = None\\n\\n\\ndef touch(root):\\n    if not root:\\n        return\\n    root.size = root.count + size(root.left) + size(root.right)\\n\\n\\ndef size(root):\\n    if not root:\\n        return 0\\n    return root.size\\n\\n\\ndef insert(root, val):\\n    t1, r, t2 = split(root, val)\\n    if not r:\\n        r = Node(val)\\n    else:\\n        r.count += 1\\n        touch(r)\\n    t2 = join(r, t2)\\n    return join(t1, t2)\\n\\n\\ndef remove(root, val):\\n    t1, r, t2 = split(root, val)\\n    if r and r.count > 1:\\n        r.count -= 1\\n        touch(r)\\n        t2 = join(r, t2)\\n    return join(t1, t2)\\n\\n\\ndef split(root, val):\\n    if not root:\\n        return None, None, None\\n    elif root.val < val:\\n        a, b, c = split(root.right, val)\\n        root.right = a\\n        touch(root)\\n        return root, b, c\\n    elif root.val > val:\\n        a, b, c = split(root.left, val)\\n        root.left = c\\n        touch(root)\\n        return a, b, root\\n    else:\\n        a, c = root.left, root.right\\n        root.left = root.right = None\\n        touch(root)\\n        return a, root, c\\n\\n\\ndef join(t1, t2):\\n    if not t1:\\n        return t2\\n    elif not t2:\\n        return t1\\n    elif t1.weight < t2.weight:\\n        t1.right = join(t1.right, t2)\\n        touch(t1)\\n        return t1\\n    else:\\n        t2.left = join(t1, t2.left)\\n        touch(t2)\\n        return t2\\n\\n\\ndef get(root, index):\\n    if size(root.left) < index <= size(root.left) + root.count:\\n        return root.val\\n    elif size(root.left) + root.count < index:\\n        return get(root.right, index - root.count - size(root.left))\\n    else:\\n        return get(root.left, index)\\n\\n```",
        "level": "hard",
        "buggy_code": "\nclass Solution:\n    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\n        tree = None\n        ans = []\n        for i, x in enumerate(nums):\n            tree = insert(tree, x)\n            if size(tree) > k:\n                tree = remove(tree, nums[i - k + 1])\n            if size(tree) == k:\n                if k % 2 == 1:\n                    ans.append(get(tree, k // 2 + 1))\n                else:\n                    nums.append((get(tree, k // 2) + get(tree, k // 2 + 1)) / 2)\n        return nums\n\n\nclass Node:\n    __slots__ = ['val', 'count', 'weight', 'size', 'left', 'right']\n    def __init__(self, val):\n        self.val = val\n        self.count = 1\n        self.weight = random.random()\n        self.size = 1\n        self.left = self.right = None\n\n\ndef touch(root):\n    if not root:\n        return\n    root.size = root.count + size(root.left) + size(root.right)\n\n\ndef size(root):\n    if not root:\n        return 0\n    return root.size\n\n\ndef insert(root, val):\n    t1, r, t2 = split(root, val)\n    if not r:\n        r = Node(val)\n    else:\n        r.count += 1\n        touch(r)\n    t2 = join(r, t2)\n    return join(t1, t2)\n\n\ndef remove(root, val):\n    t1, r, t2 = split(root, val)\n    if r and r.count > 1:\n        r.count -= 1\n        touch(r)\n        t2 = join(r, t2)\n    return join(t1, t2)\n\n\ndef split(root, val):\n    if not root:\n        return None, None, None\n    elif root.val < val:\n        a, b, c = split(root.right, val)\n        root.right = a\n        touch(root)\n        return root, b, c\n    elif root.val > val:\n        a, b, c = split(root.left, val)\n        root.left = c\n        touch(root)\n        return a, b, root\n    else:\n        a, c = root.left, root.right\n        root.left = root.right = None\n        touch(root)\n        return a, root, c\n\n\ndef join(t1, t2):\n    if not t1:\n        return t2\n    elif not t2:\n        return t1\n    elif t1.weight < t2.weight:\n        t1.right = join(t1.right, t2)\n        touch(t1)\n        return t1\n    else:\n        t2.left = join(t1, t2.left)\n        touch(t2)\n        return t2\n\n\ndef get(root, index):\n    if size(root.left) < index <= size(root.left) + root.count:\n        return root.val\n    elif size(root.left) + root.count < index:\n        return get(root.right, index - root.count - size(root.left))\n    else:\n        return get(root.left, index)\n",
        "explanations": "\nThe bug lies in the medianSlidingWindow method where it appends to nums instead of ans variable.\n"
    },
    {
        "slug": "longest-well-performing-interval",
        "description": "We are given hours, a list of the number of hours worked per day for a given employee.\nA day is considered to be a tiring day if and only if the number of hours worked is (strictly) greater than 8.\nA well-performing interval is an interval of days for which the number of tiring days is strictly larger than the number of non-tiring days.\nReturn the length of the longest well-performing interval.",
        "examples": [
            "Input: hours = [9,9,6,0,6,6,9]\nOutput: 3\nExplanation: The longest well-performing interval is [9,9,6].",
            "Input: hours = [6,6,6]\nOutput: 0"
        ],
        "constraints": "1 <= hours.length <= 104\n0 <= hours[i] <= 16",
        "release_time": 1664031594,
        "oracle_code": "class Solution:\n    def longestWPI(self, A):\n        curr, ans, D = 0, 0, {}\n        for e, i in enumerate(map(lambda x: (-1, 1)[x > 8], A)):\n            curr += i\n            D[curr] = D.get(curr, e)\n            ans = e + 1 if curr > 0 else max(ans, e - D.get(curr - 1, e))\n        return ans",
        "content": "`Time Complexity` : `O(n)`\\n`Space Complexity` : `O(n)`\\n```\\nclass Solution:\\n    def longestWPI(self, A):\\n        curr, ans, D = 0, 0, {}\\n        for e, i in enumerate(map(lambda x: (-1, 1)[x > 8], A)):\\n            curr += i\\n            D[curr] = D.get(curr, e)\\n            ans = e + 1 if curr > 0 else max(ans, e - D.get(curr - 1, e))\\n        return ans\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution:\n    def longestWPI(self, A):\n        curr, ans, D = 0, 0, {}\n        for e, i in enumerate(map(lambda x: (-1, 1)[x > 8], A)):\n            curr += i\n            D[curr] = D.get(curr, e)\n            ans = e + 1 if curr > 0 else max(ans, e - D.get(curr - 2, e))\n        return ans\n",
        "explanations": "\nIn the last line, the index (curr - 2) used in the dictionary can reference a non-existent key.\n"
    },
    {
        "slug": "count-the-repetitions",
        "description": "We define str = [s, n] as the string str which consists of the string s concatenated n times.\n\nFor example, str == [\"abc\", 3] ==\"abcabcabc\".\n\nWe define that string s1 can be obtained from string s2 if we can remove some characters from s2 such that it becomes s1.\n\nFor example, s1 = \"abc\" can be obtained from s2 = \"abdbec\" based on our definition by removing the bolded underlined characters.\n\nYou are given two strings s1 and s2 and two integers n1 and n2. You have the two strings str1 = [s1, n1] and str2 = [s2, n2].\nReturn the maximum integer m such that str = [str2, m] can be obtained from str1.",
        "examples": [
            "Input: s1 = \"acb\", n1 = 4, s2 = \"ab\", n2 = 2\nOutput: 2",
            "Input: s1 = \"acb\", n1 = 1, s2 = \"acb\", n2 = 1\nOutput: 1"
        ],
        "constraints": "1 <= s1.length, s2.length <= 100\ns1 and s2 consist of lowercase English letters.\n1 <= n1, n2 <= 106",
        "release_time": 1671908671,
        "oracle_code": "class Solution:\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\n\n        rec, track = [0], defaultdict(int) \n        ct = start = ptr1 = ptr2 = 0\n\n        if not set(s2).issubset(set(s1)): return 0\n\n        s1 = ''.join(char for char in s1 if char in set(s2))\n        \n        while True:\n            for char in s2:\n                ptr = s1.find(char, start)\n                if ptr == -1:\n                    ct += 1\n                    ptr = s1.find(char)\n                start = ptr+1\n            rec.append(ct + 1)\n\n            if rec[-1] > n1: return (len(rec)-2)//n2\n\n            if ptr not in track: track[ptr] = len(rec)-1\n            else: break\n        \n        cycleStart = rec[track[ptr]]\n        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]\n        rest = n1 - cycleStart\n        \n        rem = cycleStart + rest%cycle1\n\n        while rec[ptr2] <= rem: ptr2+= 1\n\n        return (cycle2 * (rest//cycle1) + ptr2-1)//n2",
        "content": "```\\nclass Solution:\\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\\n\\n        rec, track = [0], defaultdict(int) \\n        ct = start = ptr1 = ptr2 = 0\\n\\n        if not set(s2).issubset(set(s1)): return 0\\n\\n        s1 = \\'\\'.join(char for char in s1 if char in set(s2))\\n        \\n        while True:\\n            for char in s2:\\n                ptr = s1.find(char, start)\\n                if ptr == -1:\\n                    ct += 1\\n                    ptr = s1.find(char)\\n                start = ptr+1\\n            rec.append(ct + 1)\\n\\n            if rec[-1] > n1: return (len(rec)-2)//n2\\n\\n            if ptr not in track: track[ptr] = len(rec)-1\\n            else: break\\n        \\n        cycleStart = rec[track[ptr]]\\n        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]\\n        rest = n1 - cycleStart\\n        \\n        rem = cycleStart + rest%cycle1\\n\\n        while rec[ptr2] <= rem: ptr2+= 1\\n\\n        return (cycle2 * (rest//cycle1) + ptr2-1)//n2\\n```\\n[https://leetcode.com/problems/count-the-repetitions/submissions/864907562/](http://)\\n\\nI could be wrong, but I think that time is *O*(*N*) and space is *O*(*N*).",
        "level": "hard",
        "buggy_code": "\nclass Solution:\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\n\n        rec, track = [0], defaultdict(int) \n        ct = start = ptr1 = ptr2 = 0\n\n        if not set(s2).issubset(set(s1)): return 0\n\n        s1 = ''.join(char for char in s1 if char in set(s2))\n        \n        while True:\n            for char in s2:\n                ptr = s1.find(char, start)\n                if ptr == -1:\n                    ct += 1\n                    ptr = s1.find(char)\n                start = ptr+1\n            rec.append(ct + 1)\n\n            if rec[-1] > n1: return (len(rec)-2)//n2\n\n            if ptr not in track: track[ptr] = len(rec)-1\n            else: break\n        \n        cycleStart = rec[track[ptr]]\n        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]\n        rest = n1 - cycleStart\n        \n        rem = cycleStart + rest%cycle1\n\n        while rec[ptr2] <= rem: ptr2+= 1\n\n        return (cycle2 * (rest//cycle1) + ptr2-2)//n2\n",
        "explanations": "\nIncorrect index in return statement causing miscalculation of final results .\n"
    },
    {
        "slug": "find-players-with-zero-or-one-losses",
        "description": "You are given an integer array matches where matches[i] = [winneri, loseri] indicates that the player winneri defeated player loseri in a match.\nReturn a list answer of size 2 where:\n\nanswer[0] is a list of all players that have not lost any matches.\nanswer[1] is a list of all players that have lost exactly one match.\n\nThe values in the two lists should be returned in increasing order.\nNote:\n\nYou should only consider the players that have played at least one match.\nThe testcases will be generated such that no two matches will have the same outcome.",
        "examples": [
            "Input: matches = [[1,3],[2,3],[3,6],[5,6],[5,7],[4,5],[4,8],[4,9],[10,4],[10,9]]\nOutput: [[1,2,10],[4,5,7,8]]\nExplanation:\nPlayers 1, 2, and 10 have not lost any matches.\nPlayers 4, 5, 7, and 8 each have lost one match.\nPlayers 3, 6, and 9 each have lost two matches.\nThus, answer[0] = [1,2,10] and answer[1] = [4,5,7,8].",
            "Input: matches = [[2,3],[1,3],[5,4],[6,4]]\nOutput: [[1,2,5,6],[]]\nExplanation:\nPlayers 1, 2, 5, and 6 have not lost any matches.\nPlayers 3 and 4 each have lost two matches.\nThus, answer[0] = [1,2,5,6] and answer[1] = []."
        ],
        "constraints": "1 <= matches.length <= 105\nmatches[i].length == 2\n1 <= winneri, loseri <= 105\nwinneri != loseri\nAll matches[i] are unique.",
        "release_time": 1669639917,
        "oracle_code": "class Solution:\n    def findWinners(self, matches: List[List[int]]) -> List[List[int]]:\n\n        winners, losers = defaultdict(int), defaultdict(int)\n\n        for match in matches:\n\n            winners[match[0]] += 1\n            losers[match[1]] += 1\n\n        res_1, res_2 = [], []\n\n        for k, v in winners.items():\n            if k not in losers:\n                res_1.append(k)\n        \n        for k, v in losers.items():\n            if v == 1:\n                res_2.append(k)\n\n        res_1.sort()\n        res_2.sort()\n        \n        return [ res_1, res_2 ]",
        "content": "# Intuition\\nIf you need to aggregate and count some sequens you cen use either array or hasmap if it is a matter of a uniqueness.\\n\\n# Approach\\nIn our case we need to find unique teams that either not loose or loose not more than 1 match. So we need to distribute the information about all matches among two grous and\\n1. Check for intesection for winners\\n2. Check for 1 lost for loosers\\n\\n# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def findWinners(self, matches: List[List[int]]) -> List[List[int]]:\\n\\n        winners, losers = defaultdict(int), defaultdict(int)\\n\\n        for match in matches:\\n\\n            winners[match[0]] += 1\\n            losers[match[1]] += 1\\n\\n        res_1, res_2 = [], []\\n\\n        for k, v in winners.items():\\n            if k not in losers:\\n                res_1.append(k)\\n        \\n        for k, v in losers.items():\\n            if v == 1:\\n                res_2.append(k)\\n\\n        res_1.sort()\\n        res_2.sort()\\n        \\n        return [ res_1, res_2 ]\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution:\n    def findWinners(self, matches: List[List[int]]) -> List[List[int]]:\n\n        winners, losers = defaultdict(int), defaultdict(int)\n\n        for match in matches:\n\n            winners[match[0]] += 1\n            losers[match[2]] += 1\n\n        res_1, res_2 = [], []\n\n        for k, v in winners.items():\n            if k not in losers:\n                res_1.append(k)\n        \n        for k, v in losers.items():\n            if v == 1:\n                res_2.append(k)\n\n        res_1.sort()\n        res_2.sort()\n        \n        return [ res_1, res_2 ]\n",
        "explanations": "\nThe bug is in the indexing where 'match[2]' is used while matches have only 2 elements.\n"
    },
    {
        "slug": "card-flipping-game",
        "description": "You are given two 0-indexed integer arrays fronts and backs of length n, where the ith card has the positive integer fronts[i] printed on the front and backs[i] printed on the back. Initially, each card is placed on a table such that the front number is facing up and the other is facing down. You may flip over any number of cards (possibly zero).\nAfter flipping the cards, an integer is considered good if it is facing down on some card and not facing up on any card.\nReturn the minimum possible good integer after flipping the cards. If there are no good integers, return 0.",
        "examples": [
            "Input: fronts = [1,2,4,4,7], backs = [1,3,4,1,3]\nOutput: 2\nExplanation:\nIf we flip the second card, the face up numbers are [1,3,4,4,7] and the face down are [1,2,4,1,3].\n2 is the minimum good integer as it appears facing down but not facing up.\nIt can be shown that 2 is the minimum possible good integer obtainable after flipping some cards.",
            "Input: fronts = [1], backs = [1]\nOutput: 0\nExplanation:\nThere are no good integers no matter how we flip the cards, so we return 0."
        ],
        "constraints": "n == fronts.length == backs.length\n1 <= n <= 1000\n1 <= fronts[i], backs[i] <= 2000",
        "release_time": 1685678247,
        "oracle_code": "class Solution:\n    def flipgame(self, fronts: List[int], backs: List[int]) -> int:\n        bad = set(i for i,j in zip(fronts, backs) if i==j)\n        for i in sorted(set(fronts + backs)):\n            if i in bad:\n                continue\n            return i\n        return 0",
        "content": "# Intuition\\nThe only way you can\\'t have a good integer is if you have a card with it on both sides.  You want the minimum, so just sort, giving you the lowest, and check if any card has it on both sides.\\n\\n# Code\\n```\\nclass Solution:\\n    def flipgame(self, fronts: List[int], backs: List[int]) -> int:\\n        bad = set(i for i,j in zip(fronts, backs) if i==j)\\n        for i in sorted(set(fronts + backs)):\\n            if i in bad:\\n                continue\\n            return i\\n        return 0\\n\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution:\n    def flipgame(self, fronts: List[int], backs: List[int]) -> int:\n        bad = set(i for i,j in zip(fronts, backs) if i==j)\n        for i in sorted(set(fronts + backs + [1001])):\n            if i in bad:\n                continue\n            return i\n        return 0\n",
        "explanations": "\nAdded 1001 to the list, causing an indexing error when that element doesn't exist.\n"
    },
    {
        "slug": "maximum-depth-of-binary-tree",
        "description": "Given the root of a binary tree, return its maximum depth.\nA binary tree's maximum depth\u00a0is the number of nodes along the longest path from the root node down to the farthest leaf node.",
        "examples": [
            "Input: root = [3,9,20,null,null,15,7]\nOutput: 3",
            "Input: root = [1,null,2]\nOutput: 2"
        ],
        "constraints": "The number of nodes in the tree is in the range [0, 104].\n-100 <= Node.val <= 100",
        "release_time": 1686009664,
        "oracle_code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        stack = [[root, 1]]\n        res = 0\n\n        while stack:\n            node, depth = stack.pop()\n\n            if node:\n                res = max(res, depth)\n                stack.append([node.left, depth + 1])\n                stack.append([node.right, depth + 1])\n            \n        return res",
        "content": "We should dive into our tree as far as possible until we come the bottom in the branch, and after we backtrack.\\n\\n# Complexity\\n- Time complexity: O(n) for traversing the tree\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) in the worst case where our stack is filled by every element in the single existing branch.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\\n        stack = [[root, 1]]\\n        res = 0\\n\\n        while stack:\\n            node, depth = stack.pop()\\n\\n            if node:\\n                res = max(res, depth)\\n                stack.append([node.left, depth + 1])\\n                stack.append([node.right, depth + 1])\\n            \\n        return res\\n\\n\\n```",
        "level": "easy",
        "buggy_code": "\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        stack = [[root, 1]]\n        res = 0\n\n        while stack:\n            node, depth = stack.pop(1)\n\n            if node:\n                res = max(res, depth)\n                stack.append([node.left, depth + 1])\n                stack.append([node.right, depth + 1])\n            \n        return res\n",
        "explanations": "\n`stack.pop(1)` is removing the second item from stack, not the last one.\n"
    },
    {
        "slug": "binary-search",
        "description": "Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1.\nYou must write an algorithm with O(log n) runtime complexity.",
        "examples": [
            "Input: nums = [-1,0,3,5,9,12], target = 9\nOutput: 4\nExplanation: 9 exists in nums and its index is 4",
            "Input: nums = [-1,0,3,5,9,12], target = 2\nOutput: -1\nExplanation: 2 does not exist in nums so return -1"
        ],
        "constraints": "1 <= nums.length <= 104\n-104 < nums[i], target < 104\nAll the integers in nums are unique.\nnums is sorted in ascending order.",
        "release_time": 1680309400,
        "oracle_code": "class Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        if target not in nums:\n            return -1\n        \n        left, right = 0, len(nums)\n        \n        while left < right:\n            mid = (left + right) // 2\n            if nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid\n        \n        return left",
        "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        if target not in nums:\\n            return -1\\n        \\n        left, right = 0, len(nums)\\n        \\n        while left < right:\\n            mid = (left + right) // 2\\n            if nums[mid] < target:\\n                left = mid + 1\\n            else:\\n                right = mid\\n        \\n        return left\\n        \\n```\\nOne-liner in python:\\n```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        return bisect_left(nums, target) if target in nums else -1\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        if target not in nums:\n            return -1\n        \n        left, right = 0, len(nums)\n        \n        while left < right:\n            mid = (left + right) // 2\n            if nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid\n        \n        return nums[left]\n",
        "explanations": "\nIndex 'left' could be out of range if 'target' is not in 'nums'.\n"
    },
    {
        "slug": "reveal-cards-in-increasing-order",
        "description": "You are given an integer array deck. There is a deck of cards where every card has a unique integer. The integer on the ith card is deck[i].\nYou can order the deck in any order you want. Initially, all the cards start face down (unrevealed) in one deck.\nYou will do the following steps repeatedly until all cards are revealed:\n\nTake the top card of the deck, reveal it, and take it out of the deck.\nIf there are still cards in the deck then put the next top card of the deck at the bottom of the deck.\nIf there are still unrevealed cards, go back to step 1. Otherwise, stop.\n\nReturn an ordering of the deck that would reveal the cards in increasing order.\nNote that the first entry in the answer is considered to be the top of the deck.",
        "examples": [
            "Input: deck = [17,13,11,2,3,5,7]\nOutput: [2,13,3,11,5,17,7]\nExplanation: \nWe get the deck in the order [17,13,11,2,3,5,7] (this order does not matter), and reorder it.\nAfter reordering, the deck starts as [2,13,3,11,5,17,7], where 2 is the top of the deck.\nWe reveal 2, and move 13 to the bottom.  The deck is now [3,11,5,17,7,13].\nWe reveal 3, and move 11 to the bottom.  The deck is now [5,17,7,13,11].\nWe reveal 5, and move 17 to the bottom.  The deck is now [7,13,11,17].\nWe reveal 7, and move 13 to the bottom.  The deck is now [11,17,13].\nWe reveal 11, and move 17 to the bottom.  The deck is now [13,17].\nWe reveal 13, and move 17 to the bottom.  The deck is now [17].\nWe reveal 17.\nSince all the cards revealed are in increasing order, the answer is correct.",
            "Input: deck = [1,1000]\nOutput: [1,1000]"
        ],
        "constraints": "1 <= deck.length <= 1000\n1 <= deck[i] <= 106\nAll the values of deck are unique.",
        "release_time": 1667400873,
        "oracle_code": "class Solution:\n    def deckRevealedIncreasing(self, deck: List[int]) -> List[int]:\n        def reveal(n):\n            lst = list(range(n))\n            ans = []\n            i = 0\n            while lst:\n                if not i&1: ans.append(lst.pop(0))\n                else: lst.append(lst.pop(0))\n                i += 1\n            return ans\n        ans = reveal(len(deck))\n        ans = sorted([v, i] for i, v in enumerate(ans))\n        deck.sort()\n        return (deck[j] for i,j in ans)",
        "content": "# Code\\n```\\nclass Solution:\\n    def deckRevealedIncreasing(self, deck: List[int]) -> List[int]:\\n        def reveal(n):\\n            lst = list(range(n))\\n            ans = []\\n            i = 0\\n            while lst:\\n                if not i&1: ans.append(lst.pop(0))\\n                else: lst.append(lst.pop(0))\\n                i += 1\\n            return ans\\n        ans = reveal(len(deck))\\n        ans = sorted([v, i] for i, v in enumerate(ans))\\n        deck.sort()\\n        return (deck[j] for i,j in ans)\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution:\n    def deckRevealedIncreasing(self, deck: List[int]) -> List[int]:\n        def reveal(n):\n            lst = list(range(n))\n            ans = []\n            i = 0\n            while lst:\n                if not i&1: ans.append(lst.pop(0))\n                else: lst.append(lst.pop(10))\n                i += 1\n            return ans\n        ans = reveal(len(deck))\n        ans = sorted([v, i] for i, v in enumerate(ans))\n        deck.sort()\n        return (deck[j] for i,j in ans)\n",
        "explanations": "\nPop function tries to remove an index that doesn't exist when the length of lst is less than 10.\n"
    },
    {
        "slug": "kth-largest-sum-in-a-binary-tree",
        "description": "You are given the root of a binary tree and a positive integer k.\nThe level sum in the tree is the sum of the values of the nodes that are on the same level.\nReturn the kth largest level sum in the tree (not necessarily distinct). If there are fewer than k levels in the tree, return -1.\nNote that two nodes are on the same level if they have the same distance from the root.",
        "examples": [
            "Input: root = [5,8,9,2,1,3,7,4,6], k = 2\nOutput: 13\nExplanation: The level sums are the following:\n- Level 1: 5.\n- Level 2: 8 + 9 = 17.\n- Level 3: 2 + 1 + 3 + 7 = 13.\n- Level 4: 4 + 6 = 10.\nThe 2nd largest level sum is 13.",
            "Input: root = [1,2,null,3], k = 1\nOutput: 3\nExplanation: The largest level sum is 3."
        ],
        "constraints": "The number of nodes in the tree is n.\n2 <= n <= 105\n1 <= Node.val <= 106\n1 <= k <= n",
        "release_time": 1680295273,
        "oracle_code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def kthLargestLevelSum(self, root: Optional[TreeNode], k: int) -> int:\n        dq = collections.deque([root])\n        a = []\n        lvl = 1\n        while dq:\n            lvlsum = 0\n            for i in range(len(dq)):\n               n = dq.popleft()\n               lvlsum += n.val\n               if n.left: dq.append(n.left)\n               if n.right: dq.append(n.right)\n            a.append(lvlsum)\n            lvl += 1\n        a.sort(reverse=True)\n        return a[k-1] if len(a) >= k else -1",
        "content": "\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def kthLargestLevelSum(self, root: Optional[TreeNode], k: int) -> int:\\n        dq = collections.deque([root])\\n        a = []\\n        lvl = 1\\n        while dq:\\n            lvlsum = 0\\n            for i in range(len(dq)):\\n               n = dq.popleft()\\n               lvlsum += n.val\\n               if n.left: dq.append(n.left)\\n               if n.right: dq.append(n.right)\\n            a.append(lvlsum)\\n            lvl += 1\\n        a.sort(reverse=True)\\n        return a[k-1] if len(a) >= k else -1\\n```",
        "level": "medium",
        "buggy_code": "\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def kthLargestLevelSum(self, root: Optional[TreeNode], k: int) -> int:\n        dq = collections.deque([root])\n        a = []\n        lvl = 1\n        while dq:\n            lvlsum = 0\n            for i in range(len(dq)):\n               n = dq.popleft()\n               lvlsum += n.val\n               if n.left: dq.append(n.left)\n               if n.right: dq.append(n.right)\n            a.append(lvlsum)\n            lvl += 1\n        a.sort(reverse=True)\n        return a[k] if len(a) >= k else -1\n",
        "explanations": "\nReturning a[k] causes indexing error if k is exactly the length of a.\n"
    },
    {
        "slug": "adding-two-negabinary-numbers",
        "description": "Given two numbers arr1 and arr2 in base -2, return the result of adding them together.\nEach number is given in array format:\u00a0 as an array of 0s and 1s, from most significant bit to least significant bit.\u00a0 For example, arr = [1,1,0,1] represents the number (-2)^3\u00a0+ (-2)^2 + (-2)^0 = -3.\u00a0 A number arr in array, format is also guaranteed to have no leading zeros: either\u00a0arr == [0] or arr[0] == 1.\nReturn the result of adding arr1 and arr2 in the same format: as an array of 0s and 1s with no leading zeros.",
        "examples": [
            "Input: arr1 = [1,1,1,1,1], arr2 = [1,0,1]\nOutput: [1,0,0,0,0]\nExplanation: arr1 represents 11, arr2 represents 5, the output represents 16.",
            "Input: arr1 = [0], arr2 = [0]\nOutput: [0]",
            "Input: arr1 = [0], arr2 = [1]\nOutput: [1]"
        ],
        "constraints": "1 <= arr1.length,\u00a0arr2.length <= 1000\narr1[i]\u00a0and arr2[i] are\u00a00 or 1\narr1 and arr2 have no leading zeros",
        "release_time": 1674727355,
        "oracle_code": "class Solution:\n    def addBinary(self, A, B):\n        res = []\n        carry = 0\n        while A or B or carry:\n            carry += (A or [0]).pop() + (B or [0]).pop()\n            res.append(carry & 1)\n            carry = carry >> 1\n        return res[::-1]\n\n    def addNegabinary(self, A, B):\n        res = []\n        carry = 0\n        while A or B or carry:\n            carry += (A or [0]).pop() + (B or [0]).pop()\n            res.append(carry & 1)\n            carry = -(carry >> 1)\n        while len(res) > 1 and res[-1] == 0:\n            res.pop()\n        return res[::-1]",
        "content": "# Code\\n```\\nclass Solution:\\n    def addBinary(self, A, B):\\n        res = []\\n        carry = 0\\n        while A or B or carry:\\n            carry += (A or [0]).pop() + (B or [0]).pop()\\n            res.append(carry & 1)\\n            carry = carry >> 1\\n        return res[::-1]\\n\\n    def addNegabinary(self, A, B):\\n        res = []\\n        carry = 0\\n        while A or B or carry:\\n            carry += (A or [0]).pop() + (B or [0]).pop()\\n            res.append(carry & 1)\\n            carry = -(carry >> 1)\\n        while len(res) > 1 and res[-1] == 0:\\n            res.pop()\\n        return res[::-1]\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution:\n    def addBinary(self, A, B):\n        res = []\n        carry = 0\n        while A or B or carry:\n            carry += (A or [0]).pop() + (B or [0]).pop()\n            res.append(carry & 1)\n            carry = carry >> 1\n        return res[::-1][1]  \n\n    def addNegabinary(self, A, B):\n        res = []\n        carry = 0\n        while A or B or carry:\n            carry += (A or [0]).pop() + (B or [0]).pop()\n            res.append(carry & 1)\n            carry = -(carry >> 1)\n        while len(res) > 1 and res[-1] == 0:\n            res.pop()\n        return res[::-1][1]  \n",
        "explanations": "\nIndexing error on returned array, accessing the second element instead of the whole array.\n"
    },
    {
        "slug": "maximum-elegance-of-a-k-length-subsequence",
        "description": "You are given a 0-indexed 2D integer array items of length n and an integer k.\nitems[i] = [profiti, categoryi], where profiti and categoryi denote the profit and category of the ith item respectively.\nLet's define the elegance of a subsequence of items as total_profit + distinct_categories2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.\nYour task is to find the maximum elegance from all subsequences of size k in items.\nReturn an integer denoting the maximum elegance of a subsequence of items with size exactly k.\nNote: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements' relative order.",
        "examples": [
            "Input: items = [[3,2],[5,1],[10,1]], k = 2\nOutput: 17\nExplanation: In this example, we have to select a subsequence of size 2.\nWe can select items[0] = [3,2] and items[2] = [10,1].\nThe total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1].\nHence, the elegance is 13 + 22 = 17, and we can show that it is the maximum achievable elegance.",
            "Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3\nOutput: 19\nExplanation: In this example, we have to select a subsequence of size 3. \nWe can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3]. \nThe total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3]. \nHence, the elegance is 10 + 32 = 19, and we can show that it is the maximum achievable elegance.",
            "Input: items = [[1,1],[2,1],[3,1]], k = 3\nOutput: 7\nExplanation: In this example, we have to select a subsequence of size 3. \nWe should select all the items. \nThe total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1]. \nHence, the maximum elegance is 6 + 12 = 7."
        ],
        "constraints": "1 <= items.length == n <= 105\nitems[i].length == 2\nitems[i][0] == profiti\nitems[i][1] == categoryi\n1 <= profiti <= 109\n1 <= categoryi <= n \n1 <= k <= n",
        "release_time": 1691294879,
        "oracle_code": "class Solution:\n    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:\n        dico=defaultdict(list)\n        for profit,category in items:\n            dico[category].append(profit)\n        categories=[]\n        for category in dico:\n            categories.append(sorted(dico[category]))\n        categories.sort(key=lambda x:x[-1],reverse=True)\n        def elegance (distinct):\n            res=0\n            rest=[]\n            for i in range (distinct):\n                res+=categories[i][-1]\n                for j in range (len(categories[i])-1):\n                    rest.append(categories[i][j])\n            rest.sort(reverse=True)\n            if len(rest)<k-distinct:\n                return -1\n            return res+sum(rest[:k-distinct])+distinct**2\n        l,r=1,min(len(categories)-1,k-1)\n        mid=(l+r)//2\n        while l<r:\n            if elegance(mid+1)>elegance(mid) or elegance(mid+1)==-1:\n                l=mid+1\n            else:\n                r=mid\n            mid=(l+r)//2\n        return max(elegance(mid),elegance(mid+1))",
        "content": "[Edit : This worked on all testcases during contest but @canlong found a testcase that my algorithm does not work on]\\n\\n# Intuition\\nThe elegance as a function of the number of distinct categories should look like a mountain with a peak.\\n\\n# Approach\\nBinary search the number of distinct categories by checking the elegance of p distinct categories and p+1 distinct categories.\\n\\nFor each number of distinct category p, take the categories with the p highest values, then add the greatest values of these p categories that are not the maximum. If there are not enough elements to reach k elements, we need to take additional categories.\\n\\n# Complexity\\n- Time complexity:\\nO(n*log(n))\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:\\n        dico=defaultdict(list)\\n        for profit,category in items:\\n            dico[category].append(profit)\\n        categories=[]\\n        for category in dico:\\n            categories.append(sorted(dico[category]))\\n        categories.sort(key=lambda x:x[-1],reverse=True)\\n        def elegance (distinct):\\n            res=0\\n            rest=[]\\n            for i in range (distinct):\\n                res+=categories[i][-1]\\n                for j in range (len(categories[i])-1):\\n                    rest.append(categories[i][j])\\n            rest.sort(reverse=True)\\n            if len(rest)<k-distinct:\\n                return -1\\n            return res+sum(rest[:k-distinct])+distinct**2\\n        l,r=1,min(len(categories)-1,k-1)\\n        mid=(l+r)//2\\n        while l<r:\\n            if elegance(mid+1)>elegance(mid) or elegance(mid+1)==-1:\\n                l=mid+1\\n            else:\\n                r=mid\\n            mid=(l+r)//2\\n        return max(elegance(mid),elegance(mid+1))\\n            \\n                \\n                \\n                \\n```",
        "level": "hard",
        "buggy_code": "\nclass Solution:\n    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:\n        dico=defaultdict(list)\n        for profit,category in items:\n            dico[category].append(profit)\n        categories=[]\n        for category in dico:\n            categories.append(sorted(dico[category]))\n        categories.sort(key=lambda x:x[-1],reverse=True)\n        def elegance (distinct):\n            res=0\n            rest=[]\n            for i in range (distinct):\n                res+=categories[i][-1]\n                for j in range (len(categories[i])-1):\n                    rest.append(categories[i][j])\n            rest.sort(reverse=True)\n            if len(rest)<k-distinct:\n                return -1\n            return res+sum(rest[:k-distinct])+distinct**2\n        l,r=1,min(len(categories)-1,k-1)\n        mid=(l+r)//2\n        while l<r:\n            if elegance(mid+1)>elegance(mid+1) or elegance(mid+1)==-1:\n                l=mid+1\n            else:\n                r=mid\n            mid=(l+r)//2\n        return max(elegance(mid),elegance(mid+1))[-1]\n",
        "explanations": "\nThrough incorrect index use, -1 is applied to the \"max\" function result, which will lead to an indexing error.\n"
    },
    {
        "slug": "determine-the-winner-of-a-bowling-game",
        "description": "You are given two 0-indexed integer arrays player1 and player2, that represent the number of pins that player 1 and player 2 hit in a bowling game, respectively.\nThe bowling game consists of n turns, and the number of pins in each turn is exactly 10.\nAssume a player hit xi pins in the ith turn. The value of the ith turn for the player is:\n\n2xi if the player hit 10 pins in any of the previous two turns.\nOtherwise, It is xi.\n\nThe score of the player is the sum of the values of their n turns.\nReturn\n\n1 if the score of player 1 is more than the score of player 2,\n2 if the score of player 2 is more than the score of player 1, and\n0 in case of a draw.",
        "examples": [
            "Input: player1 = [4,10,7,9], player2 = [6,5,2,3]\nOutput: 1\nExplanation: The score of player1 is 4 + 10 + 2*7 + 2*9 = 46.\nThe score of player2 is 6 + 5 + 2 + 3 = 16.\nScore of player1 is more than the score of player2, so, player1 is the winner, and the answer is 1.",
            "Input: player1 = [3,5,7,6], player2 = [8,10,10,2]\nOutput: 2\nExplanation: The score of player1 is 3 + 5 + 7 + 6 = 21.\nThe score of player2 is 8 + 10 + 2*10 + 2*2 = 42.\nScore of player2 is more than the score of player1, so, player2 is the winner, and the answer is 2.",
            "Input: player1 = [2,3], player2 = [4,1]\nOutput: 0\nExplanation: The score of player1 is 2 + 3 = 5\nThe score of player2 is 4 + 1 = 5\nThe score of player1 equals to the score of player2, so, there is a draw, and the answer is 0."
        ],
        "constraints": "n == player1.length == player2.length\n1 <= n <= 1000\n0 <= player1[i], player2[i] <= 10",
        "release_time": 1684312110,
        "oracle_code": "class Solution:\n    def isWinner(self, nums1: List[int], nums2: List[int]) -> int:\n        res1=0\n        res2=0\n        if 10 in nums1 and len(nums1)>1:\n            res1+=nums1[0]\n            for i in range(1,len(nums1)):\n                res1+=nums1[i]\n                if nums1[i-1]==10 or i>=2 and nums1[i-2]==10:\n                        res1+=nums1[i]\n                else:\n                    pass\n        else:\n            res1=sum(nums1)\n        if 10 in nums2 and len(nums2)>1:\n            res2+=nums2[0]\n            for i in range(1,len(nums2)):\n                res2+=nums2[i]\n\n                if nums2[i-1]==10 or i>=2 and nums2[i-2]==10:\n                        res2+=nums2[i]\n                else:\n                    pass\n        else:\n            res2=sum(nums2)\n\n        # print(1 if res1>res2 2: if res2>res1: 0 if res1==res2)\n        if res1>res2:\n            return(1)\n        elif res1<res2:\n            return(2)\n        else:\n            return(0)",
        "content": "# Intuition\\nusing for loop and few conditions\\n\\n# Approach\\n\\n\\n# Complexity\\n- Time complexity:\\no(n)\\n\\n- Space complexity:\\no(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def isWinner(self, nums1: List[int], nums2: List[int]) -> int:\\n        res1=0\\n        res2=0\\n        if 10 in nums1 and len(nums1)>1:\\n            res1+=nums1[0]\\n            for i in range(1,len(nums1)):\\n                res1+=nums1[i]\\n                if nums1[i-1]==10 or i>=2 and nums1[i-2]==10:\\n                        res1+=nums1[i]\\n                else:\\n                    pass\\n        else:\\n            res1=sum(nums1)\\n        if 10 in nums2 and len(nums2)>1:\\n            res2+=nums2[0]\\n            for i in range(1,len(nums2)):\\n                res2+=nums2[i]\\n\\n                if nums2[i-1]==10 or i>=2 and nums2[i-2]==10:\\n                        res2+=nums2[i]\\n                else:\\n                    pass\\n        else:\\n            res2=sum(nums2)\\n\\n        # print(1 if res1>res2 2: if res2>res1: 0 if res1==res2)\\n        if res1>res2:\\n            return(1)\\n        elif res1<res2:\\n            return(2)\\n        else:\\n            return(0)\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution:\n    def isWinner(self, nums1: List[int], nums2: List[int]) -> int:\n        res1=0\n        res2=0\n        if 10 in nums1 and len(nums1)>1:\n            res1+=nums1[0]\n            for i in range(1,len(nums1)):\n                res1+=nums1[i]\n                if nums1[i+1]==10 or i>=2 and nums1[i-2]==10:\n                        res1+=nums1[i]\n                else:\n                    pass\n        else:\n            res1=sum(nums1)\n        if 10 in nums2 and len(nums2)>1:\n            res2+=nums2[0]\n            for i in range(1,len(nums2)):\n                res2+=nums2[i]\n\n                if nums2[i+1]==10 or i>=2 and nums2[i-2]==10:\n                        res2+=nums2[i]\n                else:\n                    pass\n        else:\n            res2=sum(nums2)\n\n        if res1>res2:\n            return(1)\n        elif res1<res2:\n            return(2)\n        else:\n            return(0)\n",
        "explanations": "\nTrying to access element ahead of current index might lead to an Index Error.\n"
    },
    {
        "slug": "sequential-digits",
        "description": "An\u00a0integer has sequential digits if and only if each digit in the number is one more than the previous digit.\nReturn a sorted list of all the integers\u00a0in the range [low, high]\u00a0inclusive that have sequential digits.",
        "examples": [
            "Input: low = 100, high = 300\nOutput: [123,234]",
            "Input: low = 1000, high = 13000\nOutput: [1234,2345,3456,4567,5678,6789,12345]"
        ],
        "constraints": "10 <= low <= high <= 10^9",
        "release_time": 1679044521,
        "oracle_code": "class Solution:\n    def sequentialDigits(self, low, high):\n        out = []\n        queue = deque(range(1,10))\n        while queue:\n            elem = queue.popleft()\n            if low <= elem <= high:\n                out.append(elem)\n            last = elem % 10\n            if last < 9: queue.append(elem*10 + last + 1)\n                    \n        return out",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def sequentialDigits(self, low, high):\\n        out = []\\n        queue = deque(range(1,10))\\n        while queue:\\n            elem = queue.popleft()\\n            if low <= elem <= high:\\n                out.append(elem)\\n            last = elem % 10\\n            if last < 9: queue.append(elem*10 + last + 1)\\n                    \\n        return out\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution:\n    def sequentialDigits(self, low, high):\n        out = []\n        queue = deque(range(1,11))\n        while queue:\n            elem = queue.popleft()\n            if low <= elem <= high:\n                out.append(elem)\n            last = elem % 10\n            if last < 9: queue.append(elem*10 + last + 1)\n                    \n        return out\n",
        "explanations": "\nThe deque is initialized with a range from 1 to 11, causing an indexing error.\n"
    },
    {
        "slug": "valid-parenthesis-string",
        "description": "Given a string s containing only three types of characters: '(', ')' and '*', return true if s is valid.\nThe following rules define a valid string:\n\nAny left parenthesis '(' must have a corresponding right parenthesis ')'.\nAny right parenthesis ')' must have a corresponding left parenthesis '('.\nLeft parenthesis '(' must go before the corresponding right parenthesis ')'.\n'*' could be treated as a single right parenthesis ')' or a single left parenthesis '(' or an empty string \"\".",
        "examples": [
            "Input: s = \"()\"\nOutput: true",
            "Input: s = \"(*)\"\nOutput: true",
            "Input: s = \"(*))\"\nOutput: true"
        ],
        "constraints": "1 <= s.length <= 100\ns[i] is '(', ')' or '*'.",
        "release_time": 1674151600,
        "oracle_code": "class Solution:\n    def checkValidString(self, s):\n        st=[]\n        sr=[]\n        for i in range(len(s)):\n            if s[i]=='(':\n                st.append(i)\n            elif s[i]== '*':\n                sr.append(i)\n            else:\n                if st:\n                    st.pop()\n                elif sr:\n                    sr.pop()\n                else:\n                    return False\n        while st:\n            if len(sr)==0:\n                return False\n            elif st[-1]< sr[-1]:\n                st.pop()\n                sr.pop()\n            else:\n                return False\n        return True",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nusing two stack approch\\nfirst stack store only opening bracket\\nsecond stack store only star\\n\\nwhen closing bracket comes that time \\n1} check opening bracket exits or not if exist then pop out one opening bracket because it will valid parenthesis\\n2} if opening bracket not exit check star if exist then it is also valid parenthesis string ex ---> *) < -- this is valid\\n3} else it will False because there is only closing bracket ex--> ) (  )  <-- invalid\\n\\ncheck againg any  opening bracket presint or not \\nif  opening bracket remaning and stars are not exits then it will false\\n\\nif stars are present and indexing is greater than opening bracket then it will valid otherwise false ex --> *( <-- not valid if it is valid when * comes after bracket --> ( *      \\n\\nThanks\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def checkValidString(self, s):\\n        st=[]\\n        sr=[]\\n        for i in range(len(s)):\\n            if s[i]==\\'(\\':\\n                st.append(i)\\n            elif s[i]== \\'*\\':\\n                sr.append(i)\\n            else:\\n                if st:\\n                    st.pop()\\n                elif sr:\\n                    sr.pop()\\n                else:\\n                    return False\\n        while st:\\n            if len(sr)==0:\\n                return False\\n            elif st[-1]< sr[-1]:\\n                st.pop()\\n                sr.pop()\\n            else:\\n                return False\\n        return True\\n\\n\\n\\n\\n                \\n\\n            \\n\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution:\n    def checkValidString(self, s):\n        st=[]\n        sr=[]\n        for i in range(len(s)+1): \n            if s[i]=='(':\n                st.append(i)\n            elif s[i]== '*':\n                sr.append(i)\n            else:\n                if st:\n                    st.pop()\n                elif sr:\n                    sr.pop()\n                else:\n                    return False\n        while st:\n            if len(sr)==0:\n                return False\n            elif st[-1]< sr[-1]:\n                st.pop()\n                sr.pop()\n            else:\n                return False\n        return True\n\n",
        "explanations": "\nThe bug is in the range of for loop where length s is incremented by 1 causing an indexing error.\n"
    },
    {
        "slug": "moving-stones-until-consecutive-ii",
        "description": "There are some stones in different positions on the X-axis. You are given an integer array stones, the positions of the stones.\nCall a stone an endpoint stone if it has the smallest or largest position. In one move, you pick up an endpoint stone and move it to an unoccupied position so that it is no longer an endpoint stone.\n\nIn particular, if the stones are at say, stones = [1,2,5], you cannot move the endpoint stone at position 5, since moving it to any position (such as 0, or 3) will still keep that stone as an endpoint stone.\n\nThe game ends when you cannot make any more moves (i.e., the stones are in three consecutive positions).\nReturn an integer array answer of length 2 where:\n\nanswer[0] is the minimum number of moves you can play, and\nanswer[1] is the maximum number of moves you can play.",
        "examples": [
            "Input: stones = [7,4,9]\nOutput: [1,2]\nExplanation: We can move 4 -> 8 for one move to finish the game.\nOr, we can move 9 -> 5, 4 -> 6 for two moves to finish the game.",
            "Input: stones = [6,5,4,3,10]\nOutput: [2,3]\nExplanation: We can move 3 -> 8 then 10 -> 7 to finish the game.\nOr, we can move 3 -> 7, 4 -> 8, 5 -> 9 to finish the game.\nNotice we cannot move 10 -> 2 to finish the game, because that would be an illegal move."
        ],
        "constraints": "3 <= stones.length <= 104\n1 <= stones[i] <= 109\nAll the values of stones are unique.",
        "release_time": 1690635827,
        "oracle_code": "class Solution:\n    '''\n        Test cases walk through \n        Given 7, 4, 9 prove 1, 2                                                            6, 5, 4, 3, 10, prove 2, 3 \n\n        Sort stones -> 4, 7, 9                                                              3, 4, 5, 6, 10 \n        Stone length -> 3                                                                   5\n        Move penultimate = 7 - 4 - 3 + 2 = 2                                                6-3-5+2 = 0 \n        Move final = 9 - 7 - 3 + 2 = 1                                                      10-4-5+2 = 3 \n        Neither is 0, so we cannot return for sure                                          Move penultimate is 0, so move final is assured \n                                                                                            This means we can return [min(2, 3), 3] -> [2, 3]\n\n        Max legal moves is 0                                                                For completeness, max legal moves is 0, max moves is 3  \n        starting index is 0                                                                 starting index is 0 \n\n        Enumeration                                                                         Enumeration\n            index is 0, stone is 4                                                             index is 0, stone is 3 \n            stones[0] lte 4 - 3 ? No, skip while loop                                          stones[0] lte 3 - 5 ? No, skip while \n            max legal moves is min of (max of self and 0 - 0 + 1, most moves)                  max legal moves is min of (max of self and 0 - 0 + 1), max moves -> max legal moves is 1 \n                 -> max legal moves is 1                                                            \n\n            index is 1, stone is 7                                                             index is 1, stone is 4 \n            stones[0] <= 7 - 3 ? Yes, enter while                                              stones[0] lte 4 - 5 ? No, skip while \n                starting index is now 1                                                        max legal moves is min of (max of self and 1 - 0 + 1), max moves -> max legal moves is 2\n            stones[1] <= 7 - 3 ? No, skip while                                                 \n            max legal moves -> min(max of self and 1 - 1 + 1), max_moves \n                -> max legal moves is 1                                                        index is 2, stone is 5 \n                                                                                               stones[0] lte 5 - 5 ? No skip while \n            index is 2, stone is 9                                                             max legal moves is min of (max of self and 2 - 0 + 1), max_moves -> max legal moves is 3 \n            stones[1] <= 9 - 3 ? No, skip while                                                 \n            max legal moves is min(max of self and 2-1 + 1), max_moves\n                 -> max legal moves is 2                                                       index is 3, stone is 6 \n        End enumeration                                                                        stones[0] lte 6 - 5 ? No skip while \n                                                                                               max legal moves is min (max of self and 3 - 0 + 1), max_moves -> max legal moves is 3 \n        Return [3 - 2, 2] -> [1, 2] checks out                                                  \n                                                                                               index is 4, stones is 10 \n                                                                                               stones[0] lte 10 - 5 ? Yes, enter while \n                                                                                                    starting index is 1 \n                                                                                               stones[1] lte 10 - 5 ? Yes, enter while \n                                                                                                    starting index is 2 \n                                                                                               stones[2] lte 10 - 5 ? Yes, enter while \n                                                                                                    starting index is 3 \n                                                                                               max legal moves is min (max of self and 4 - 3 + 1), max moves -> max legal moves is 3 \n                                                                                            End enumeration\n\n                                                                                            Return [5 - 3, 3] -> [2, 3]\n    '''\n    def numMovesStonesII(self, stones: List[int]) -> List[int] :\n        # order does not need to be maintained, so sorting is optimal \n        stones.sort()\n        # want to work within stone physical space since 10^9 >> 10^4 (stone weight vs length)\n        stone_length = len(stones)\n        # what is the cost of moving the second to last stone and the 0th stone? \n        move_penultimate = stones[-2] - stones[0] - stone_length + 2 \n        # what is the cost of moving the last stone and the 1st stone? \n        move_final = stones[-1] - stones[1] - stone_length + 2 \n        # in both of these, the cost is the positional exchange in stones along the stone length + 2 for the two stones moving \n        # our most moves possible are the max of these two \n        most_moves = max(move_penultimate, move_final)\n        # since the stones are unique, if either is 0, the one that we have must be max legal moves \n        # if move penultimate is 0, that means that the second largest stone less the least stone less the length + 2 is 0 \n        # this means that the largest stone, which must be at least one larger than the largest, less the second to least stone which is at least one larger than the least stone  less the length + 2 is move final \n        # our minimal length is 3 \n        # let a, b, c be stones in order \n        # b - a - 3 + 2 = 0 -> b = a + 1 move penultimate  \n        # c - b - 3 + 2 = 0 -> b = c - 1 move final \n        # c - 1 = a + 1 -> c = a + 2 \n        # all stones must be at least 1 to 10^9 and are unique \n        # so at minimum a is 1, b is 2 and c is 3  \n        # in this case, move final is also 0 so we get 0, 0 \n        # if a = 4, b = 5, c = 7 \n        # 5 - 4 - 3 + 2 = 0 move penultimate is 0 \n        # 7 - 5 - 3 + 2 -> 1 move ultimate is 1 \n        # min legal moves is min of 2 and 1 -> min legal moves is 1 -> 1, 1 is returned \n        # from this it can be seen that the movement of c relative to b impacts  the return here when one is 0, and that if either is 0 it does not preclude the other. However it does entail a relation to 2 as most that min could become \n        # this is because if most moves is greater than 2, we could always do the move alternate that was 0 in two steps. This is what locks in to place the ability to use 2 here as the min argument. \n        if move_penultimate == 0 or move_final == 0 : \n            min_legal_moves = min(2, most_moves)\n            return [min_legal_moves, most_moves]\n        # how many legal moves are there in sorted order? \n        max_legal_moves = 0 \n        # starting from 0th index \n        starting_index = 0\n        # enumerate each stone and index \n        for index, stone in enumerate(stones) :\n            # while the stone at starting index is lte this stone minus stone length (cost of a move) \n            while stones[starting_index] <= stone - stone_length : \n                # increment \n                starting_index += 1\n            # max legal moves is then set to maxima of self and indexed difference with 1 for 0 based indexing  \n            max_legal_moves = min(max(max_legal_moves, index - starting_index + 1), most_moves) \n        # return length - max legal moves when in sorted order (your minimal move state) and most moves in sorted order \n        return [stone_length - max_legal_moves, most_moves]",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAt the base of this problem is a linear scan. This is because we are trying to achieve the pairing of minimum number of moves and maximum number of moves. As such, we are trying to sort the move value space and scan over it linearly. This can be achieved with a few key insights from the problem that keep it at a medium level. \\n\\nFirst, we have a list size lower bound of 3. This is actually dreadfully important for one of our key edge cases that make this easily solvable so don\\'t discard such things when they come up! \\n\\nSecond, we have that all the stone values are unique. \\n\\nThird, we have that all the stone values are positive integers from 1 to 10^9. This is important both as an insight into the fact that we are working with only positive values, and that we are working with a very large value space compared to a much relatively smaller value ordination (there are 10^9 values for the stones, but only 10^4 positions at most for them) \\n\\nWe are also provided with a helpful hint \\n>For the minimum, how many cows are already in place? For the maximum, we have to lose either the gap A[1] - A[0] or A[N-1] - A[N-2] (where N = A.length), but every other space can be occupied ?  \\n\\nWe turn first to the idea of the maximum, where we have a gap we will need to lose of either between the first and second position or ultimate and penultimate position. \\n\\nIf we consider a list of 3 items, our minimum, what is our minimum values to get our minimal return? Not to spoil anything, but it is 1, 2, 3 \\n\\nThis is key to the problem, since there are no spaces provided between the values, so our return should be [0, 0] \\n\\nBy realizing the impact of this the approach follows below. Try to work out for a few values and sizes to get the feel for it and you\\'ll likely find an understanding either intuitively or by action. I recommend working with small list sizes and trying to generate [0, 1], [0, 2], [1, 2], and [2, 2] with only 3 or so items. It\\'ll be difficult, but worth it for the understanding pay off. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe original ordering of the stones is not valid compared to their ordinal positioning, and since we know we have a size limit much less than a value limit, we start by sorting. \\n\\nThen, we want to know how much space we have to work witin, so get the size of your listing (how many stones do you have regardless of how much they are worth?) \\n\\nThen, we need to calculate the two largest costs, move penultimate and move ultimate (final in the code) \\n\\nMove penultimate is the cost of swapping the stones at the second to last spot and the first spot, minus the cost of the number of stones you have (Since you moved over the whole thing!) plus 2 to deal with the fact that they are unique\\n\\nMove ultimate is the cost of swapping the stones at the last spot and second spot, minus the cost of the number of stones you have plus 2 to deal with the fact that they are unique\\n\\nIf either of these is 0, the other must be locked in as most moves, as most moves will be the max of these two options (try to convince yourself of why that is the case! This relates to the idea of the list sizings, and is really clearly seen with a list of size 3)\\n\\nIf either is 0, \\n- min legal moves is min of 2 and most moves \\n- return min legal moves and most moves \\n\\nOtherwise we now must consider how many max legal moves are there really? \\n\\nSet max legal moves to 0 \\nSet starting index to 0 \\nenumerate index and stone in stones \\n- while stones at starting index lte stone - stone length \\n    - increment starting index \\n- our max legal moves here is the max of itself (so it preserves good discoveries) and index - starting index + 1 (+1 for the fact we use 0 indexing) \\n- but, it cannot get too big! Remember, we already found the actual max, so don\\'t let anything in here fool you! Set max legal moves as such to min(max(max_legal_moves, index - starting_index + 1), max_moves) \\n- this keeps our newly found max legal less than our actual max moves \\n\\nWhen done enumerating return length - max legal moves, max moves \\n\\n# Complexity\\n- Time complexity : O(S log S + S)\\n    - O(S log S) to sort the stones \\n    - O(S) to loop over (while loop is incindental, as it can only run as many times as the length of stones as well in total, so it does not add to this)  \\n\\n- Space complexity : O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nNo additional space utilized \\n\\n# Code\\n```\\nclass Solution:\\n    \\'\\'\\'\\n        Test cases walk through \\n        Given 7, 4, 9 prove 1, 2                                                            6, 5, 4, 3, 10, prove 2, 3 \\n\\n        Sort stones -> 4, 7, 9                                                              3, 4, 5, 6, 10 \\n        Stone length -> 3                                                                   5\\n        Move penultimate = 7 - 4 - 3 + 2 = 2                                                6-3-5+2 = 0 \\n        Move final = 9 - 7 - 3 + 2 = 1                                                      10-4-5+2 = 3 \\n        Neither is 0, so we cannot return for sure                                          Move penultimate is 0, so move final is assured \\n                                                                                            This means we can return [min(2, 3), 3] -> [2, 3]\\n\\n        Max legal moves is 0                                                                For completeness, max legal moves is 0, max moves is 3  \\n        starting index is 0                                                                 starting index is 0 \\n\\n        Enumeration                                                                         Enumeration\\n            index is 0, stone is 4                                                             index is 0, stone is 3 \\n            stones[0] lte 4 - 3 ? No, skip while loop                                          stones[0] lte 3 - 5 ? No, skip while \\n            max legal moves is min of (max of self and 0 - 0 + 1, most moves)                  max legal moves is min of (max of self and 0 - 0 + 1), max moves -> max legal moves is 1 \\n                 -> max legal moves is 1                                                            \\n\\n            index is 1, stone is 7                                                             index is 1, stone is 4 \\n            stones[0] <= 7 - 3 ? Yes, enter while                                              stones[0] lte 4 - 5 ? No, skip while \\n                starting index is now 1                                                        max legal moves is min of (max of self and 1 - 0 + 1), max moves -> max legal moves is 2\\n            stones[1] <= 7 - 3 ? No, skip while                                                 \\n            max legal moves -> min(max of self and 1 - 1 + 1), max_moves \\n                -> max legal moves is 1                                                        index is 2, stone is 5 \\n                                                                                               stones[0] lte 5 - 5 ? No skip while \\n            index is 2, stone is 9                                                             max legal moves is min of (max of self and 2 - 0 + 1), max_moves -> max legal moves is 3 \\n            stones[1] <= 9 - 3 ? No, skip while                                                 \\n            max legal moves is min(max of self and 2-1 + 1), max_moves\\n                 -> max legal moves is 2                                                       index is 3, stone is 6 \\n        End enumeration                                                                        stones[0] lte 6 - 5 ? No skip while \\n                                                                                               max legal moves is min (max of self and 3 - 0 + 1), max_moves -> max legal moves is 3 \\n        Return [3 - 2, 2] -> [1, 2] checks out                                                  \\n                                                                                               index is 4, stones is 10 \\n                                                                                               stones[0] lte 10 - 5 ? Yes, enter while \\n                                                                                                    starting index is 1 \\n                                                                                               stones[1] lte 10 - 5 ? Yes, enter while \\n                                                                                                    starting index is 2 \\n                                                                                               stones[2] lte 10 - 5 ? Yes, enter while \\n                                                                                                    starting index is 3 \\n                                                                                               max legal moves is min (max of self and 4 - 3 + 1), max moves -> max legal moves is 3 \\n                                                                                            End enumeration\\n\\n                                                                                            Return [5 - 3, 3] -> [2, 3]\\n    \\'\\'\\'\\n    def numMovesStonesII(self, stones: List[int]) -> List[int] :\\n        # order does not need to be maintained, so sorting is optimal \\n        stones.sort()\\n        # want to work within stone physical space since 10^9 >> 10^4 (stone weight vs length)\\n        stone_length = len(stones)\\n        # what is the cost of moving the second to last stone and the 0th stone? \\n        move_penultimate = stones[-2] - stones[0] - stone_length + 2 \\n        # what is the cost of moving the last stone and the 1st stone? \\n        move_final = stones[-1] - stones[1] - stone_length + 2 \\n        # in both of these, the cost is the positional exchange in stones along the stone length + 2 for the two stones moving \\n        # our most moves possible are the max of these two \\n        most_moves = max(move_penultimate, move_final)\\n        # since the stones are unique, if either is 0, the one that we have must be max legal moves \\n        # if move penultimate is 0, that means that the second largest stone less the least stone less the length + 2 is 0 \\n        # this means that the largest stone, which must be at least one larger than the largest, less the second to least stone which is at least one larger than the least stone  less the length + 2 is move final \\n        # our minimal length is 3 \\n        # let a, b, c be stones in order \\n        # b - a - 3 + 2 = 0 -> b = a + 1 move penultimate  \\n        # c - b - 3 + 2 = 0 -> b = c - 1 move final \\n        # c - 1 = a + 1 -> c = a + 2 \\n        # all stones must be at least 1 to 10^9 and are unique \\n        # so at minimum a is 1, b is 2 and c is 3  \\n        # in this case, move final is also 0 so we get 0, 0 \\n        # if a = 4, b = 5, c = 7 \\n        # 5 - 4 - 3 + 2 = 0 move penultimate is 0 \\n        # 7 - 5 - 3 + 2 -> 1 move ultimate is 1 \\n        # min legal moves is min of 2 and 1 -> min legal moves is 1 -> 1, 1 is returned \\n        # from this it can be seen that the movement of c relative to b impacts  the return here when one is 0, and that if either is 0 it does not preclude the other. However it does entail a relation to 2 as most that min could become \\n        # this is because if most moves is greater than 2, we could always do the move alternate that was 0 in two steps. This is what locks in to place the ability to use 2 here as the min argument. \\n        if move_penultimate == 0 or move_final == 0 : \\n            min_legal_moves = min(2, most_moves)\\n            return [min_legal_moves, most_moves]\\n        # how many legal moves are there in sorted order? \\n        max_legal_moves = 0 \\n        # starting from 0th index \\n        starting_index = 0\\n        # enumerate each stone and index \\n        for index, stone in enumerate(stones) :\\n            # while the stone at starting index is lte this stone minus stone length (cost of a move) \\n            while stones[starting_index] <= stone - stone_length : \\n                # increment \\n                starting_index += 1\\n            # max legal moves is then set to maxima of self and indexed difference with 1 for 0 based indexing  \\n            max_legal_moves = min(max(max_legal_moves, index - starting_index + 1), most_moves) \\n        # return length - max legal moves when in sorted order (your minimal move state) and most moves in sorted order \\n        return [stone_length - max_legal_moves, most_moves]\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution:\n    def numMovesStonesII(self, stones: List[int]) -> List[int]:\n        stones.sort()\n        stone_length = len(stones)\n        move_penultimate = stones[-2] - stones[0] - stone_length + 2 \n        move_final = stones[-1] - stones[1] - stone_length + 2 \n        most_moves = max(move_penultimate, move_final)\n        if move_penultimate == 0 or move_final == 0 : \n            min_legal_moves = min(2, most_moves)\n            return [min_legal_moves, most_moves]\n        max_legal_moves = 0 \n        starting_index = 0\n        for index, stone in enumerate(stones) :\n            while stones[starting_index + 1] <= stone - stone_length : \n                starting_index += 1\n            max_legal_moves = min(max(max_legal_moves, index - starting_index + 1), most_moves) \n        return [stone_length - max_legal_moves, most_moves]\n",
        "explanations": "\nIn 'while' condition, it causes indexing error when 'starting_index' equals to the last index of the list.\n"
    },
    {
        "slug": "sort-an-array",
        "description": "Given an array of integers nums, sort the array in ascending order and return it.\nYou must solve the problem without using any built-in functions in O(nlog(n)) time complexity and with the smallest space complexity possible.",
        "examples": [
            "Input: nums = [5,2,3,1]\nOutput: [1,2,3,5]\nExplanation: After sorting the array, the positions of some numbers are not changed (for example, 2 and 3), while the positions of other numbers are changed (for example, 1 and 5).",
            "Input: nums = [5,1,1,2,0,0]\nOutput: [0,0,1,1,2,5]\nExplanation: Note that the values of nums are not necessairly unique."
        ],
        "constraints": "1 <= nums.length <= 5 * 104\n-5 * 104 <= nums[i] <= 5 * 104",
        "release_time": 1677700522,
        "oracle_code": "class Solution:                                 \n    def sortArray(self,nums:list[int]) -> list[int]:    #   Example: [3,3,1,8,6,5,5,5,5]\n\n        ctr  = Counter(nums)                            #   ctr = {5:4, 3:2, 1:1, 8:1, 6:1}\n\n        return list(chain(*([i]*ctr[i]                  #   return    list(chain( *([1]*1, [3]*2, [5]*4, [6]*1, [8]*1) ))   \n                    for i in range(min(ctr),            #           = list(chain([1], [3,3,3], [5,5,5,5], [6], [8] ))\n                    max(ctr)+1) if i in ctr)))          #           = [1, 3,3, 5,5,5,5, 6, 8]",
        "content": "I think the time% and space% on this problem are extremely skewed because of the scofflaws who used`sort()`,`sorted`or`heapq`, not heeding the admonition on using \"built-in functions.\".\\n\\nUsing `Counter`,`chain`,`max`,or,`mn` techically makes me a scofflaw too, so I included a non-scofflaw version below as well.\\n\\nMy scofflaw version:\\n```\\nclass Solution:                                 \\n    def sortArray(self,nums:list[int]) -> list[int]:    #   Example: [3,3,1,8,6,5,5,5,5]\\n\\n        ctr  = Counter(nums)                            #   ctr = {5:4, 3:2, 1:1, 8:1, 6:1}\\n\\n        return list(chain(*([i]*ctr[i]                  #   return    list(chain( *([1]*1, [3]*2, [5]*4, [6]*1, [8]*1) ))   \\n                    for i in range(min(ctr),            #           = list(chain([1], [3,3,3], [5,5,5,5], [6], [8] ))\\n                    max(ctr)+1) if i in ctr)))          #           = [1, 3,3, 5,5,5,5, 6, 8]   \\n                    \\n\\n```\\n\\nNon-scofflaw:\\n```\\nclass Solution:\\n    def sortArray(self, nums: list[int]) -> list[int]: \\n\\n        ans, nSet, mx, mn = [],set(nums),nums[0],nums[0]\\n        d = {n:0 for n in nSet}\\n\\n        for n in nums: d[n]+= 1\\n\\n        for n in d:\\n            if n > mx: mx = n\\n            if n < mn: mn = n\\n\\n        for i in range(mn, mx+1):\\n            if i not in d: continue\\n            ans+= [i]*d[i]\\n\\n        return ans\\n```\\n[https://leetcode.com/problems/sort-an-array/submissions/1007234945/](http://)\\n\\n\\nI could be wrong, but I think for each that time complexity is *O*(*NlogN*) and space complexity is *O*(*N*).",
        "level": "medium",
        "buggy_code": "\nclass Solution:                                 \n    def sortArray(self,nums:list[int]) -> list[int]:   \n\n        ctr  = Counter(nums)                           \n\n        return list(chain(*([i]*ctr[i+1]                  \n                    for i in range(min(ctr),            \n                    max(ctr)+1) if i in ctr)))   \n",
        "explanations": "\nThe bug is in the ctr[i+1] which will throw an index error if i+1 is not in the counter.\n"
    },
    {
        "slug": "find-words-that-can-be-formed-by-characters",
        "description": "You are given an array of strings words and a string chars.\nA string is good if it can be formed by characters from chars (each character can only be used once).\nReturn the sum of lengths of all good strings in words.",
        "examples": [
            "Input: words = [\"cat\",\"bt\",\"hat\",\"tree\"], chars = \"atach\"\nOutput: 6\nExplanation: The strings that can be formed are \"cat\" and \"hat\" so the answer is 3 + 3 = 6.",
            "Input: words = [\"hello\",\"world\",\"leetcode\"], chars = \"welldonehoneyr\"\nOutput: 10\nExplanation: The strings that can be formed are \"hello\" and \"world\" so the answer is 5 + 5 = 10."
        ],
        "constraints": "1 <= words.length <= 1000\n1 <= words[i].length, chars.length <= 100\nwords[i] and chars consist of lowercase English letters.",
        "release_time": 1670168918,
        "oracle_code": "class Solution:\n    def countCharacters(self, words: List[str], chars: str) -> int:\n        ans=[]\n        d1=Counter(chars)\n        for i in range(len(words)):\n            w=[j for j in words[i]]\n            d2=Counter(w)\n        #print(dc)\n        #print(dw)\n            if all([k in d1 for k in d2]) and all([d2[k]<=d1[k] for k in d2]):\n                ans.append(len(w))\n        return sum(ans)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countCharacters(self, words: List[str], chars: str) -> int:\\n        ans=[]\\n        d1=Counter(chars)\\n        for i in range(len(words)):\\n            w=[j for j in words[i]]\\n            d2=Counter(w)\\n        #print(dc)\\n        #print(dw)\\n            if all([k in d1 for k in d2]) and all([d2[k]<=d1[k] for k in d2]):\\n                ans.append(len(w))\\n        return sum(ans)\\n       \\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution:\n    def countCharacters(self, words: List[str], chars: str) -> int:\n        ans=[]\n        d1=Counter(chars)\n        for i in range(len(words)+1):\n            w=[j for j in words[i]]\n            d2=Counter(w)\n        #print(dc)\n        #print(dw)\n            if all([k in d1 for k in d2]) and all([d2[k]<=d1[k] for k in d2]):\n                ans.append(len(w))\n        return sum(ans)\n",
        "explanations": "\nThe bug is in the range for the loop, which will throw an index out-of-range error. \n"
    },
    {
        "slug": "satisfiability-of-equality-equations",
        "description": "You are given an array of strings equations that represent relationships between variables where each string equations[i] is of length 4 and takes one of two different forms: \"xi==yi\" or \"xi!=yi\".Here, xi and yi are lowercase letters (not necessarily different) that represent one-letter variable names.\nReturn true if it is possible to assign integers to variable names so as to satisfy all the given equations, or false otherwise.",
        "examples": [
            "Input: equations = [\"a==b\",\"b!=a\"]\nOutput: false\nExplanation: If we assign say, a = 1 and b = 1, then the first equation is satisfied, but not the second.\nThere is no way to assign the variables to satisfy both equations.",
            "Input: equations = [\"b==a\",\"a==b\"]\nOutput: true\nExplanation: We could assign a = 1 and b = 1 to satisfy both equations."
        ],
        "constraints": "1 <= equations.length <= 500\nequations[i].length == 4\nequations[i][0] is a lowercase letter.\nequations[i][1] is either '=' or '!'.\nequations[i][2] is '='.\nequations[i][3] is a lowercase letter.",
        "release_time": 1672762507,
        "oracle_code": "class Disjoint:\n    def __init__(self):\n        self.rank=[0]*26\n        self.parent=[i for i in range(26)]\n\n    def finduPar(self,node):\n        if self.parent[node]==node:\n            return node\n        self.parent[node]=self.finduPar(self.parent[node])\n        return self.parent[node]\n\n    def byrank(self,u,v):\n        ulp_u=self.finduPar(u)\n        ulp_v=self.finduPar(v)\n        if ulp_u==ulp_v:\n            return False\n        if self.rank[ulp_u]>self.rank[ulp_v]:\n            self.parent[ulp_v]=ulp_u\n        elif self.rank[ulp_u]<self.rank[ulp_v]:\n            self.parent[ulp_u]=ulp_v\n        else:\n            self.parent[ulp_v]=ulp_u\n            self.rank[ulp_u]+=1\n\n\nclass Solution:\n    def equationsPossible(self, equations: List[str]) -> bool:\n        disjoint=Disjoint()\n        nq=[]\n        n=len(equations)\n        for i in range(n):\n            if equations[i][1]=='!':\n                if equations[i][0]==equations[i][-1]:\n                    return False\n                else:\n                    nq.append(equations[i])\n            else:\n                disjoint.byrank(ord(equations[i][0])-97,ord(equations[i][-1])-97)\n        for i in range(len(nq)):\n            x=ord(nq[i][0])-97\n            y=ord(nq[i][-1])-97\n            if disjoint.finduPar(x)==disjoint.finduPar(y):\n                return False\n        return True",
        "content": "# Intuition\\nWE WOULD MAKE ALL alphabet that are equal in same component. \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nUNION DISJOINT\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Disjoint:\\n    def __init__(self):\\n        self.rank=[0]*26\\n        self.parent=[i for i in range(26)]\\n\\n    def finduPar(self,node):\\n        if self.parent[node]==node:\\n            return node\\n        self.parent[node]=self.finduPar(self.parent[node])\\n        return self.parent[node]\\n\\n    def byrank(self,u,v):\\n        ulp_u=self.finduPar(u)\\n        ulp_v=self.finduPar(v)\\n        if ulp_u==ulp_v:\\n            return False\\n        if self.rank[ulp_u]>self.rank[ulp_v]:\\n            self.parent[ulp_v]=ulp_u\\n        elif self.rank[ulp_u]<self.rank[ulp_v]:\\n            self.parent[ulp_u]=ulp_v\\n        else:\\n            self.parent[ulp_v]=ulp_u\\n            self.rank[ulp_u]+=1\\n\\n\\nclass Solution:\\n    def equationsPossible(self, equations: List[str]) -> bool:\\n        disjoint=Disjoint()\\n        nq=[]\\n        n=len(equations)\\n        for i in range(n):\\n            if equations[i][1]==\\'!\\':\\n                if equations[i][0]==equations[i][-1]:\\n                    return False\\n                else:\\n                    nq.append(equations[i])\\n            else:\\n                disjoint.byrank(ord(equations[i][0])-97,ord(equations[i][-1])-97)\\n        for i in range(len(nq)):\\n            x=ord(nq[i][0])-97\\n            y=ord(nq[i][-1])-97\\n            if disjoint.finduPar(x)==disjoint.finduPar(y):\\n                return False\\n        return True\\n```",
        "level": "medium",
        "buggy_code": "\nclass Disjoint:\n    def __init__(self):\n        self.rank=[0]*26\n        self.parent=[i for i in range(26)]\n\n    def finduPar(self,node):\n        if self.parent[node]==node:\n            return node\n        self.parent[node]=self.finduPar(self.parent[node])\n        return self.parent[node]\n\n    def byrank(self,u,v):\n        ulp_u=self.finduPar(u)\n        ulp_v=self.finduPar(v)\n        if ulp_u==ulp_v:\n            return False\n        if self.rank[ulp_u]>self.rank[ulp_v]:\n            self.parent[ulp_v]=ulp_u\n        elif self.rank[ulp_u]<self.rank[ulp_v]:\n            self.parent[ulp_u]=ulp_v\n        else:\n            self.parent[ulp_v]=ulp_u\n            self.rank[ulp_u]+=1\n\n\nclass Solution:\n    def equationsPossible(self, equations: List[str]) -> bool:\n        disjoint=Disjoint()\n        nq=[]\n        n=len(equations)\n        for i in range(n+1):  \n            if equations[i][1]=='!':\n                if equations[i][0]==equations[i][-1]:\n                    return False\n                else:\n                    nq.append(equations[i])\n            else:\n                disjoint.byrank(ord(equations[i][0])-97,ord(equations[i][-1])-97)\n        for i in range(len(nq)):\n            x=ord(nq[i][0])-97\n            y=ord(nq[i][-1])-97\n            if disjoint.finduPar(x)==disjoint.finduPar(y):\n                return False\n        return True\n",
        "explanations": "\nThe loop in the equationsPossible method goes beyond the list length causing Index Error.\n"
    },
    {
        "slug": "median-of-two-sorted-arrays",
        "description": "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\nThe overall run time complexity should be O(log (m+n)).",
        "examples": [
            "Input: nums1 = [1,3], nums2 = [2]\nOutput: 2.00000\nExplanation: merged array = [1,2,3] and median is 2.",
            "Input: nums1 = [1,2], nums2 = [3,4]\nOutput: 2.50000\nExplanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5."
        ],
        "constraints": "nums1.length == m\nnums2.length == n\n0 <= m <= 1000\n0 <= n <= 1000\n1 <= m + n <= 2000\n-106 <= nums1[i], nums2[i] <= 106",
        "release_time": 1691292624,
        "oracle_code": "class Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        p1 = 0\n        p2 = 0\n        new = []\n        while p1 < len(nums1) and p2 < len(nums2):\n            if nums1[p1] < nums2[p2]:\n                new.append(nums1[p1])\n                p1 += 1\n            else:\n                new.append(nums2[p2])\n                p2 += 1\n        while p1 < len(nums1):\n            new.append(nums1[p1])\n            p1 += 1\n        while p2 < len(nums2):\n            new.append(nums2[p2])\n            p2+= 1\n        if len(new) % 2 == 0:\n            index = len(new) // 2\n            median = (new[index] + new[index-1]) / 2\n        else:\n            median = float(new[len(new)//2])\n        return median",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind this approach is to merge the two sorted arrays while maintaining the order, and then finding the median based on the length of the merged array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize two pointers, p1 and p2, for the two input arrays nums1 and nums2, respectively, both starting at index 0.\\n2. Create an empty list new to store the merged array.\\n3. Iterate through both arrays using the pointers. Compare the elements pointed to by p1 and p2. Append the smaller element to the new array and increment the corresponding pointer.\\n4. After the iteration, there might be remaining elements in one of the arrays. Iterate through the remaining elements and append them to the new array.\\n5. Calculate the median based on the length of the new array. If the length is even, take the average of the middle two elements. If the length is odd, take the middle element.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(m + n), where m and n are the lengths of the two input arrays.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(m + n), as the merged array new can contain all the elements from the two input arrays.\\n\\n# Code\\n```\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        p1 = 0\\n        p2 = 0\\n        new = []\\n        while p1 < len(nums1) and p2 < len(nums2):\\n            if nums1[p1] < nums2[p2]:\\n                new.append(nums1[p1])\\n                p1 += 1\\n            else:\\n                new.append(nums2[p2])\\n                p2 += 1\\n        while p1 < len(nums1):\\n            new.append(nums1[p1])\\n            p1 += 1\\n        while p2 < len(nums2):\\n            new.append(nums2[p2])\\n            p2+= 1\\n        if len(new) % 2 == 0:\\n            index = len(new) // 2\\n            median = (new[index] + new[index-1]) / 2\\n        else:\\n            median = float(new[len(new)//2])\\n        return median\\n```",
        "level": "hard",
        "buggy_code": "\nclass Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        p1 = 0\n        p2 = 0\n        new = []\n        while p1 < len(nums1) and p2 < len(nums2):\n            if nums1[p1] < nums2[p2]:\n                new.append(nums1[p1])\n                p1 += 1\n            else:\n                new.append(nums2[p2])\n                p2 += 1\n        while p1 < len(nums1):\n            new.append(nums1[p1])\n            p1 += 1\n        while p2 <= len(nums2):\n            new.append(nums2[p2])\n            p2+= 1\n        if len(new) % 2 == 0:\n            index = len(new) // 2\n            median = (new[index] + new[index-1]) / 2\n        else:\n            median = float(new[len(new)//2])\n        return median\n",
        "explanations": "\nThe loop while p2 <= len(nums2): will cause an out-of-index error when p2 = len(nums2).\n"
    },
    {
        "slug": "minimize-maximum-pair-sum-in-array",
        "description": "The pair sum of a pair (a,b) is equal to a + b. The maximum pair sum is the largest pair sum in a list of pairs.\n\nFor example, if we have pairs (1,5), (2,3), and (4,4), the maximum pair sum would be max(1+5, 2+3, 4+4) = max(6, 5, 8) = 8.\n\nGiven an array nums of even length n, pair up the elements of nums into n / 2 pairs such that:\n\nEach element of nums is in exactly one pair, and\nThe maximum pair sum is minimized.\n\nReturn the minimized maximum pair sum after optimally pairing up the elements.",
        "examples": [
            "Input: nums = [3,5,2,3]\r\nOutput: 7\r\nExplanation: The elements can be paired up into pairs (3,3) and (5,2).\r\nThe maximum pair sum is max(3+3, 5+2) = max(6, 7) = 7.",
            "Input: nums = [3,5,4,2,4,6]\r\nOutput: 8\r\nExplanation: The elements can be paired up into pairs (3,5), (4,4), and (6,2).\r\nThe maximum pair sum is max(3+5, 4+4, 6+2) = max(8, 8, 8) = 8."
        ],
        "constraints": "n == nums.length\n2 <= n <= 105\nn is even.\n1 <= nums[i] <= 105",
        "release_time": 1677615909,
        "oracle_code": "class Solution:\n    def minPairSum(self, nums: List[int]) -> int:\n        nums.sort()\n        list2=[]\n        left,right=0,len(nums)-1\n        while left<right:\n            list2.append(nums[left]+nums[right])\n            left+=1\n            right-=1\n        return max(list2)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minPairSum(self, nums: List[int]) -> int:\\n        nums.sort()\\n        list2=[]\\n        left,right=0,len(nums)-1\\n        while left<right:\\n            list2.append(nums[left]+nums[right])\\n            left+=1\\n            right-=1\\n        return max(list2)\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution:\n    def minPairSum(self, nums: List[int]) -> int:\n        nums.sort()\n        list2=[]\n        left,right=0,len(nums)\n        while left<right:\n            list2.append(nums[left]+nums[right])\n            left+=1\n            right-=1\n        return max(list2)\n",
        "explanations": "\nThe right pointer is set to len(nums) will lead to index out of range error.\n"
    },
    {
        "slug": "find-all-possible-recipes-from-given-supplies",
        "description": "You have information about n different recipes. You are given a string array recipes and a 2D string array ingredients. The ith recipe has the name recipes[i], and you can create it if you have all the needed ingredients from ingredients[i]. Ingredients to a recipe may need to be created from other recipes, i.e., ingredients[i] may contain a string that is in recipes.\nYou are also given a string array supplies containing all the ingredients that you initially have, and you have an infinite supply of all of them.\nReturn a list of all the recipes that you can create. You may return the answer in any order.\nNote that two recipes may contain each other in their ingredients.",
        "examples": [
            "Input: recipes = [\"bread\"], ingredients = [[\"yeast\",\"flour\"]], supplies = [\"yeast\",\"flour\",\"corn\"]\nOutput: [\"bread\"]\nExplanation:\nWe can create \"bread\" since we have the ingredients \"yeast\" and \"flour\".",
            "Input: recipes = [\"bread\",\"sandwich\"], ingredients = [[\"yeast\",\"flour\"],[\"bread\",\"meat\"]], supplies = [\"yeast\",\"flour\",\"meat\"]\nOutput: [\"bread\",\"sandwich\"]\nExplanation:\nWe can create \"bread\" since we have the ingredients \"yeast\" and \"flour\".\nWe can create \"sandwich\" since we have the ingredient \"meat\" and can create the ingredient \"bread\".",
            "Input: recipes = [\"bread\",\"sandwich\",\"burger\"], ingredients = [[\"yeast\",\"flour\"],[\"bread\",\"meat\"],[\"sandwich\",\"meat\",\"bread\"]], supplies = [\"yeast\",\"flour\",\"meat\"]\nOutput: [\"bread\",\"sandwich\",\"burger\"]\nExplanation:\nWe can create \"bread\" since we have the ingredients \"yeast\" and \"flour\".\nWe can create \"sandwich\" since we have the ingredient \"meat\" and can create the ingredient \"bread\".\nWe can create \"burger\" since we have the ingredient \"meat\" and can create the ingredients \"bread\" and \"sandwich\"."
        ],
        "constraints": "n == recipes.length == ingredients.length\n1 <= n <= 100\n1 <= ingredients[i].length, supplies.length <= 100\n1 <= recipes[i].length, ingredients[i][j].length, supplies[k].length <= 10\nrecipes[i], ingredients[i][j], and supplies[k] consist only of lowercase English letters.\nAll the values of recipes and supplies\u00a0combined are unique.\nEach ingredients[i] does not contain any duplicate values.",
        "release_time": 1672905271,
        "oracle_code": "class Solution:\n    def findAllRecipes(self, recepies: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\n        dct=defaultdict(lambda :[])\n        indegree={}\n        n=len(recepies)\n\n        for i in recepies:\n            indegree[i]=0\n\n        for i in range(n):\n            for j in ingredients[i]:\n                indegree[j]=0\n\n        for i in range(n):\n            for j in ingredients[i]:\n                dct[j].append(recepies[i])\n                indegree[recepies[i]]+=1\n\n        st=[]\n        for i in indegree:\n            if indegree[i]==0:\n                st.append(i)\n        flst=[]\n        ans=defaultdict(lambda :[])\n        while st:\n            x=st.pop(0)\n            for i in dct[x]:\n                # if ans[x]!=[]:\n                for j in ans[x]:\n                    if j not in ans[i]:\n                        ans[i].append(j)\n                ans[i].append(x)\n                indegree[i]-=1\n                if indegree[i]==0:\n                    st.append(i)\n            if x in recepies:\n                for k in ans[x]:\n                    if k not in supplies:\n                        break\n                else:\n                    flst.append(x)\n                    supplies.append(x)\n\n        return flst",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findAllRecipes(self, recepies: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n        dct=defaultdict(lambda :[])\\n        indegree={}\\n        n=len(recepies)\\n\\n        for i in recepies:\\n            indegree[i]=0\\n\\n        for i in range(n):\\n            for j in ingredients[i]:\\n                indegree[j]=0\\n\\n        for i in range(n):\\n            for j in ingredients[i]:\\n                dct[j].append(recepies[i])\\n                indegree[recepies[i]]+=1\\n\\n        st=[]\\n        for i in indegree:\\n            if indegree[i]==0:\\n                st.append(i)\\n        flst=[]\\n        ans=defaultdict(lambda :[])\\n        while st:\\n            x=st.pop(0)\\n            for i in dct[x]:\\n                # if ans[x]!=[]:\\n                for j in ans[x]:\\n                    if j not in ans[i]:\\n                        ans[i].append(j)\\n                ans[i].append(x)\\n                indegree[i]-=1\\n                if indegree[i]==0:\\n                    st.append(i)\\n            if x in recepies:\\n                for k in ans[x]:\\n                    if k not in supplies:\\n                        break\\n                else:\\n                    flst.append(x)\\n                    supplies.append(x)\\n\\n        return flst\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution:\n    def findAllRecipes(self, recepies: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\n        dct=defaultdict(lambda :[])\n        indegree={}\n        n=len(recepies)\n\n        for i in recepies:\n            indegree[i]=0\n\n        for i in range(n+1):   \n            for j in ingredients[i]:\n                indegree[j]=0\n\n        for i in range(n):\n            for j in ingredients[i]:\n                dct[j].append(recepies[i])\n                indegree[recepies[i]]+=1\n\n        st=[]\n        for i in indegree:\n            if indegree[i]==0:\n                st.append(i)\n        flst=[]\n        ans=defaultdict(lambda :[])\n        while st:\n            x=st.pop(0)\n            for i in dct[x]:\n                # if ans[x]!=[]:\n                for j in ans[x]:\n                    if j not in ans[i]:\n                        ans[i].append(j)\n                ans[i].append(x)\n                indegree[i]-=1\n                if indegree[i]==0:\n                    st.append(i)\n            if x in recepies:\n                for k in ans[x]:\n                    if k not in supplies:\n                        break\n                else:\n                    flst.append(x)\n                    supplies.append(x)\n\n        return flst\n",
        "explanations": "\nIndexing 'ingredients' list out of its range leads to 'IndexError: list index out of range'\n"
    },
    {
        "slug": "number-complement",
        "description": "The complement of an integer is the integer you get when you flip all the 0's to 1's and all the 1's to 0's in its binary representation.\n\nFor example, The integer 5 is \"101\" in binary and its complement is \"010\" which is the integer 2.\n\nGiven an integer num, return its complement.",
        "examples": [
            "Input: num = 5\nOutput: 2\nExplanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2.",
            "Input: num = 1\nOutput: 0\nExplanation: The binary representation of 1 is 1 (no leading zero bits), and its complement is 0. So you need to output 0."
        ],
        "constraints": "1 <= num < 231\n\n\u00a0\nNote: This question is the same as 1009: https://leetcode.com/problems/complement-of-base-10-integer/",
        "release_time": 1682091742,
        "oracle_code": "class Solution:\n    def findComplement(self, num: int) -> int:\n        com = ''\n        while num > 0 :\n            \n            if num % 2 == 1:\n                com += '0'\n            else:\n                com += '1'\n            num = num // 2\n        return int(com[::-1],2)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findComplement(self, num: int) -> int:\\n        com = \\'\\'\\n        while num > 0 :\\n            \\n            if num % 2 == 1:\\n                com += \\'0\\'\\n            else:\\n                com += \\'1\\'\\n            num = num // 2\\n        return int(com[::-1],2)\\n        \\n\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution:\n    def findComplement(self, num: int) -> int:\n        com = ''\n        while num > 0 :\n            \n            if num % 2 == 1:\n                com += '0'\n            else:\n                com += '1'\n            num = num // 2\n        return int(com[::-1][1:],2)\n",
        "explanations": "\nThe slice [1:] causes an indexing error, it excludes first digit from the binary complement.\n"
    },
    {
        "slug": "self-dividing-numbers",
        "description": "A self-dividing number is a number that is divisible by every digit it contains.\n\nFor example, 128 is a self-dividing number because 128 % 1 == 0, 128 % 2 == 0, and 128 % 8 == 0.\n\nA self-dividing number is not allowed to contain the digit zero.\nGiven two integers left and right, return a list of all the self-dividing numbers in the range [left, right].",
        "examples": [
            "Input: left = 1, right = 22\nOutput: [1,2,3,4,5,6,7,8,9,11,12,15,22]",
            "Input: left = 47, right = 85\nOutput: [48,55,66,77]"
        ],
        "constraints": "1 <= left <= right <= 104",
        "release_time": 1691392822,
        "oracle_code": "class Solution:\n    def selfDividingNumbers(self, left: int, right: int) -> List[int]:\n        res=[]\n        for i in range(left,right+1 ):\n            ch=True\n            for j in str(i):\n                if j!='0':\n                    if i%int(j)!=0:\n                        ch=False\n                else:\n                    ch=False\n                    break   \n            if ch:\n                res.append(i)\n        return res",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def selfDividingNumbers(self, left: int, right: int) -> List[int]:\\n        res=[]\\n        for i in range(left,right+1 ):\\n            ch=True\\n            for j in str(i):\\n                if j!=\\'0\\':\\n                    if i%int(j)!=0:\\n                        ch=False\\n                else:\\n                    ch=False\\n                    break   \\n            if ch:\\n                res.append(i)\\n        return res\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution:\n    def selfDividingNumbers(self, left: int, right: int) -> List[int]:\n        res=[]\n        for i in range(left,right ):\n            ch=True\n            for j in str(i):\n                if j!='0':\n                    if i%int(j)!=0:\n                        ch=False\n                else:\n                    ch=False\n                    break   \n            if ch:\n                res.append(i)\n        return res\n",
        "explanations": "\nThe right end index is not inclusive in range, missing the last number in interval.\n"
    },
    {
        "slug": "partition-array-according-to-given-pivot",
        "description": "You are given a 0-indexed integer array nums and an integer pivot. Rearrange nums such that the following conditions are satisfied:\n\nEvery element less than pivot appears before every element greater than pivot.\nEvery element equal to pivot appears in between the elements less than and greater than pivot.\nThe relative order of the elements less than pivot and the elements greater than pivot is maintained.\n\t\nMore formally, consider every pi, pj where pi is the new position of the ith element and pj is the new position of the jth element. For elements less than pivot, if i < j and nums[i] < pivot and nums[j] < pivot, then pi < pj. Similarly for elements greater than pivot, if i < j and nums[i] > pivot and nums[j] > pivot, then pi < pj.\n\n\n\nReturn nums after the rearrangement.",
        "examples": [
            "Input: nums = [9,12,5,10,14,3,10], pivot = 10\nOutput: [9,5,3,10,10,12,14]\nExplanation: \nThe elements 9, 5, and 3 are less than the pivot so they are on the left side of the array.\nThe elements 12 and 14 are greater than the pivot so they are on the right side of the array.\nThe relative ordering of the elements less than and greater than pivot is also maintained. [9, 5, 3] and [12, 14] are the respective orderings.",
            "Input: nums = [-3,4,3,2], pivot = 2\nOutput: [-3,2,4,3]\nExplanation: \nThe element -3 is less than the pivot so it is on the left side of the array.\nThe elements 4 and 3 are greater than the pivot so they are on the right side of the array.\nThe relative ordering of the elements less than and greater than pivot is also maintained. [-3] and [4, 3] are the respective orderings."
        ],
        "constraints": "1 <= nums.length <= 105\n-106 <= nums[i] <= 106\npivot equals to an element of nums.",
        "release_time": 1675783420,
        "oracle_code": "class Solution:\n    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:\n        lst,val,tmp=[],[],[]\n        for i in nums:\n            if i==pivot:val.append(i)\n            elif i<pivot:lst.append(i)\n            else:tmp.append(i)\n        return lst+val+tmp",
        "content": "\\n# Code\\n```\\nclass Solution:\\n    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:\\n        lst,val,tmp=[],[],[]\\n        for i in nums:\\n            if i==pivot:val.append(i)\\n            elif i<pivot:lst.append(i)\\n            else:tmp.append(i)\\n        return lst+val+tmp\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution:\n    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:\n        lst,val,tmp=[],[],[]\n        for i in nums:\n            if i==pivot:val.append(nums[i])\n            elif i<pivot:lst.append(nums[i])\n            else:tmp.append(nums[i])\n        return lst+val+tmp\n",
        "explanations": "\nUsing index 'i' to access 'nums', leads to out of index error if 'i' is large.\n"
    },
    {
        "slug": "minimum-speed-to-arrive-on-time",
        "description": "You are given a floating-point number hour, representing the amount of time you have to reach the office. To commute to the office, you must take n trains in sequential order. You are also given an integer array dist of length n, where dist[i] describes the distance (in kilometers) of the ith train ride.\nEach train can only depart at an integer hour, so you may need to wait in between each train ride.\n\nFor example, if the 1st train ride takes 1.5 hours, you must wait for an additional 0.5 hours before you can depart on the 2nd train ride at the 2 hour mark.\n\nReturn the minimum positive integer speed (in kilometers per hour) that all the trains must travel at for you to reach the office on time, or -1 if it is impossible to be on time.\nTests are generated such that the answer will not exceed 107 and hour will have at most two digits after the decimal point.",
        "examples": [
            "Input: dist = [1,3,2], hour = 6\nOutput: 1\nExplanation: At speed 1:\n- The first train ride takes 1/1 = 1 hour.\n- Since we are already at an integer hour, we depart immediately at the 1 hour mark. The second train takes 3/1 = 3 hours.\n- Since we are already at an integer hour, we depart immediately at the 4 hour mark. The third train takes 2/1 = 2 hours.\n- You will arrive at exactly the 6 hour mark.",
            "Input: dist = [1,3,2], hour = 2.7\nOutput: 3\nExplanation: At speed 3:\n- The first train ride takes 1/3 = 0.33333 hours.\n- Since we are not at an integer hour, we wait until the 1 hour mark to depart. The second train ride takes 3/3 = 1 hour.\n- Since we are already at an integer hour, we depart immediately at the 2 hour mark. The third train takes 2/3 = 0.66667 hours.\n- You will arrive at the 2.66667 hour mark.",
            "Input: dist = [1,3,2], hour = 1.9\nOutput: -1\nExplanation: It is impossible because the earliest the third train can depart is at the 2 hour mark."
        ],
        "constraints": "n == dist.length\n1 <= n <= 105\n1 <= dist[i] <= 105\n1 <= hour <= 109\nThere will be at most two digits after the decimal point in hour.",
        "release_time": 1690342800,
        "oracle_code": "class Solution:\n    def minSpeedOnTime(self, dist: List[int], hour: float) -> int:\n        if len(dist) >= hour + 1  : return -1\n        left,right = 1, ceil(max(max(dist),dist[-1]/(1 if hour.is_integer() else hour-int(hour))))\n        while left<right:\n            mid=(left+right)//2\n            if sum([ceil(i/mid) for i in dist[:-1]])+(dist[-1]/mid) <= hour :\n                right=mid\n            else:\n                left=mid+1\n        return left",
        "content": "![image.png](https://assets.leetcode.com/users/images/b88e2aad-dabb-4eac-afd0-759a7cc70942_1690342594.5715153.png)\\n\\n\\n# Complexity\\n- Time complexity: O(m*log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minSpeedOnTime(self, dist: List[int], hour: float) -> int:\\n        if len(dist) >= hour + 1  : return -1\\n        left,right = 1, ceil(max(max(dist),dist[-1]/(1 if hour.is_integer() else hour-int(hour))))\\n        while left<right:\\n            mid=(left+right)//2\\n            if sum([ceil(i/mid) for i in dist[:-1]])+(dist[-1]/mid) <= hour :\\n                right=mid\\n            else:\\n                left=mid+1\\n        return left\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution:\n    def minSpeedOnTime(self, dist: List[int], hour: float) -> int:\n        if len(dist) >= hour + 1  : return -1\n        left,right = 1, ceil(max(max(dist),dist[-2]/(1 if hour.is_integer() else hour-int(hour))))\n        while left<right:\n            mid=(left+right)//2\n            if sum([ceil(i/mid) for i in dist[:-1]])+(dist[-1]/mid) <= hour :\n                right=mid\n            else:\n                left=mid+1\n        return left\n",
        "explanations": "\nThe bug is in the indexing of dist list where it is intended to refer to the last element but instead refers to the second last element.\n"
    },
    {
        "slug": "scramble-string",
        "description": "We can scramble a string s to get a string t using the following algorithm:\n\nIf the length of the string is 1, stop.\nIf the length of the string is > 1, do the following:\n\t\nSplit the string into two non-empty substrings at a random index, i.e., if the string is s, divide it to x and y where s = x + y.\nRandomly\u00a0decide to swap the two substrings or to keep them in the same order. i.e., after this step, s may become s = x + y or s = y + x.\nApply step 1 recursively on each of the two substrings x and y.\n\n\n\nGiven two strings s1 and s2 of the same length, return true if s2 is a scrambled string of s1, otherwise, return false.",
        "examples": [
            "Input: s1 = \"great\", s2 = \"rgeat\"\nOutput: true\nExplanation: One possible scenario applied on s1 is:\n\"great\" --> \"gr/eat\" // divide at random index.\n\"gr/eat\" --> \"gr/eat\" // random decision is not to swap the two substrings and keep them in order.\n\"gr/eat\" --> \"g/r / e/at\" // apply the same algorithm recursively on both substrings. divide at random index each of them.\n\"g/r / e/at\" --> \"r/g / e/at\" // random decision was to swap the first substring and to keep the second substring in the same order.\n\"r/g / e/at\" --> \"r/g / e/ a/t\" // again apply the algorithm recursively, divide \"at\" to \"a/t\".\n\"r/g / e/ a/t\" --> \"r/g / e/ a/t\" // random decision is to keep both substrings in the same order.\nThe algorithm stops now, and the result string is \"rgeat\" which is s2.\nAs one possible scenario led s1 to be scrambled to s2, we return true.",
            "Input: s1 = \"abcde\", s2 = \"caebd\"\nOutput: false",
            "Input: s1 = \"a\", s2 = \"a\"\nOutput: true"
        ],
        "constraints": "s1.length == s2.length\n1 <= s1.length <= 30\ns1 and s2 consist of lowercase English letters.",
        "release_time": 1680718887,
        "oracle_code": "class Solution:\n    @cache\n    def isScramble(self, s1: str, s2: str) -> bool:\n        if Counter(s1) != Counter(s2):\n            return False\n        if s1 == s2:\n            return True\n        for k in range(1, len(s1)):\n            if (\n                self.isScramble(s1[k:], s2[k:]) and self.isScramble(s1[:k], s2[:k])\n            ) or (\n                self.isScramble(s1[k:], s2[:-k]) and self.isScramble(s1[:k], s2[-k:])\n            ): return True\n        return False",
        "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    @cache\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        if Counter(s1) != Counter(s2):\\n            return False\\n        if s1 == s2:\\n            return True\\n        for k in range(1, len(s1)):\\n            if (\\n                self.isScramble(s1[k:], s2[k:]) and self.isScramble(s1[:k], s2[:k])\\n            ) or (\\n                self.isScramble(s1[k:], s2[:-k]) and self.isScramble(s1[:k], s2[-k:])\\n            ): return True\\n        return False\\n        \\n```",
        "level": "hard",
        "buggy_code": "\nclass Solution:\n    @cache\n    def isScramble(self, s1: str, s2: str) -> bool:\n        if Counter(s1) != Counter(s2):\n            return False\n        if s1 == s2:\n            return True\n        for k in range(1, len(s1)+1):\n            if (\n                self.isScramble(s1[k:], s2[k:]) and self.isScramble(s1[:k], s2[:k])\n            ) or (\n                self.isScramble(s1[k:], s2[:-k]) and self.isScramble(s1[:k], s2[-k:])\n            ): return True\n        return False\n",
        "explanations": "\nThe indexing in the loop goes out of range leading to an IndexError.\n"
    },
    {
        "slug": "fizz-buzz",
        "description": "Given an integer n, return a string array answer (1-indexed) where:\n\nanswer[i] == \"FizzBuzz\" if i is divisible by 3 and 5.\nanswer[i] == \"Fizz\" if i is divisible by 3.\nanswer[i] == \"Buzz\" if i is divisible by 5.\nanswer[i] == i (as a string) if none of the above conditions are true.",
        "examples": [
            "Input: n = 3\nOutput: [\"1\",\"2\",\"Fizz\"]",
            "Input: n = 5\nOutput: [\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\"]",
            "Input: n = 15\nOutput: [\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\",\"Fizz\",\"7\",\"8\",\"Fizz\",\"Buzz\",\"11\",\"Fizz\",\"13\",\"14\",\"FizzBuzz\"]"
        ],
        "constraints": "1 <= n <= 104",
        "release_time": 1673526978,
        "oracle_code": "class Solution:\n    def fizzBuzz(self, n: int) -> List[str]:\n        l = []\n        for i in range(1,n+1):\n            if i%3==0 and i%5==0:\n                l.append(\"FizzBuzz\")\n\n            elif i%3!=0 and i%5!=0:\n                l.append(str(i))\n            elif i%3==0:\n                l.append(\"Fizz\")\n            elif i%5==0:\n                l.append(\"Buzz\")\n            \n        return l",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def fizzBuzz(self, n: int) -> List[str]:\\n        l = []\\n        for i in range(1,n+1):\\n            if i%3==0 and i%5==0:\\n                l.append(\"FizzBuzz\")\\n\\n            elif i%3!=0 and i%5!=0:\\n                l.append(str(i))\\n            elif i%3==0:\\n                l.append(\"Fizz\")\\n            elif i%5==0:\\n                l.append(\"Buzz\")\\n            \\n        return l\\n\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution:\n    def fizzBuzz(self, n: int) -> List[str]:\n        l = []\n        for i in range(1,n+2): \n            if i%3==0 and i%5==0:\n                l.append(\"FizzBuzz\")\n\n            elif i%3!=0 and i%5!=0:\n                l.append(str(i))\n            elif i%3==0:\n                l.append(\"Fizz\")\n            elif i%5==0:\n                l.append(\"Buzz\")\n            \n        return l\n",
        "explanations": "\nThe loop runs one extra iteration causing the list include a term more than expected.\n"
    },
    {
        "slug": "find-the-value-of-the-partition",
        "description": "You are given a positive integer array nums.\nPartition nums into two arrays,\u00a0nums1 and nums2, such that:\n\nEach element of the array nums belongs to either the array nums1 or the array nums2.\nBoth arrays are non-empty.\nThe value of the partition is minimized.\n\nThe value of the partition is |max(nums1) - min(nums2)|.\nHere, max(nums1) denotes the maximum element of the array nums1, and min(nums2) denotes the minimum element of the array nums2.\nReturn the integer denoting the value of such partition.",
        "examples": [
            "Input: nums = [1,3,2,4]\nOutput: 1\nExplanation: We can partition the array nums into nums1 = [1,2] and nums2 = [3,4].\n- The maximum element of the array nums1 is equal to 2.\n- The minimum element of the array nums2 is equal to 3.\nThe value of the partition is |2 - 3| = 1. \nIt can be proven that 1 is the minimum value out of all partitions.",
            "Input: nums = [100,1,10]\nOutput: 9\nExplanation: We can partition the array nums into nums1 = [10] and nums2 = [100,1].\n- The maximum element of the array nums1 is equal to 10.\n- The minimum element of the array nums2 is equal to 1.\nThe value of the partition is |10 - 1| = 9.\nIt can be proven that 9 is the minimum value out of all partitions."
        ],
        "constraints": "2 <= nums.length <= 105\n1 <= nums[i] <= 109",
        "release_time": 1687111553,
        "oracle_code": "class Solution:\n    def findValueOfPartition(self, nums: List[int]) -> int:\n           \n        nums.sort()\n        min_diff = float('inf')\n        \n        for i in range(1,len(nums)):\n            min_diff = min(min_diff, abs(nums[i] - nums[i-1]))\n            \n        return min_diff",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. The problem tells us that we must make a partition where nums1 and nums2 are non empty. \\n\\n2. If we sort the array, we can make a partition between each pair of adajacent elements where the left element would always be the max of nums1 and the right element in the pair will always be the min of nums2.\\n3. In this way, we can check all possible partitions, save the min as we go, and return it once were through every pair\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. initialize a min variable to save the min partition value\\n2. sort nums\\n3. iterate over nums array from 1->len(nums)\\n4. compare each adajacent pair with the calculation given in the problem: abs(nums[i] - nums[i-1])\\n5. return the min diff\\n\\n~If this was helpful please upvote! \\n~Thanks for reading :)\\n\\n# Complexity\\n- Time complexity: O(NlogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nWe sort nums and then iterate over nums which is bounded by nlogn for sorting.\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nOur only additional space comes from min_diff\\n# Code\\n```\\nclass Solution:\\n    def findValueOfPartition(self, nums: List[int]) -> int:\\n           \\n        nums.sort()\\n        min_diff = float(\\'inf\\')\\n        \\n        for i in range(1,len(nums)):\\n            min_diff = min(min_diff, abs(nums[i] - nums[i-1]))\\n            \\n        return min_diff\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution:\n    def findValueOfPartition(self, nums: List[int]) -> int:\n           \n        nums.sort()\n        min_diff = float('inf')\n        \n        for i in range(1,len(nums)):\n            min_diff = min(min_diff, abs(nums[i] - nums[i+1]))\n            \n        return min_diff\n",
        "explanations": "\nThis bug occurs because the list is indexed out of range in the last iteration.\n"
    },
    {
        "slug": "check-if-every-row-and-column-contains-all-numbers",
        "description": "An n x n matrix is valid if every row and every column contains all the integers from 1 to n (inclusive).\nGiven an n x n integer matrix matrix, return true if the matrix is valid. Otherwise, return false.",
        "examples": [
            "Input: matrix = [[1,2,3],[3,1,2],[2,3,1]]\nOutput: true\nExplanation: In this case, n = 3, and every row and column contains the numbers 1, 2, and 3.\nHence, we return true.",
            "Input: matrix = [[1,1,1],[1,2,3],[1,2,3]]\nOutput: false\nExplanation: In this case, n = 3, but the first row and the first column do not contain the numbers 2 or 3.\nHence, we return false."
        ],
        "constraints": "n == matrix.length == matrix[i].length\n1 <= n <= 100\n1 <= matrix[i][j] <= n",
        "release_time": 1667568355,
        "oracle_code": "class Solution:\n    def checkValid(self, matrix: List[List[int]]) -> bool:\n\n        dp_col = [[False for _ in range(len(matrix[0]))] for _ in range(len(matrix))]\n        dp_row = [[False for _ in range(len(matrix[0]))] for _ in range(len(matrix))]\n\n        for i in range(len(matrix)):\n            for j in range(len(matrix[0])):\n                if dp_row[i][matrix[i][j]-1] or dp_col[j][matrix[i][j]-1]:\n                    return False\n                dp_row[i][matrix[i][j]-1] = True\n                dp_col[j][matrix[i][j]-1] = True\n        return True",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def checkValid(self, matrix: List[List[int]]) -> bool:\\n\\n        dp_col = [[False for _ in range(len(matrix[0]))] for _ in range(len(matrix))]\\n        dp_row = [[False for _ in range(len(matrix[0]))] for _ in range(len(matrix))]\\n\\n        for i in range(len(matrix)):\\n            for j in range(len(matrix[0])):\\n                if dp_row[i][matrix[i][j]-1] or dp_col[j][matrix[i][j]-1]:\\n                    return False\\n                dp_row[i][matrix[i][j]-1] = True\\n                dp_col[j][matrix[i][j]-1] = True\\n        return True\\n\\n\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution:\n    def checkValid(self, matrix: List[List[int]]) -> bool:\n\n        dp_col = [[False for _ in range(len(matrix[0]))] for _ in range(len(matrix))]\n        dp_row = [[False for _ in range(len(matrix[0]))] for _ in range(len(matrix))]\n\n        for i in range(len(matrix)):\n            for j in range(len(matrix[0])):\n                if dp_row[i][matrix[i][j]] or dp_col[j][matrix[i][j]]:\n                    return False\n                dp_row[i][matrix[i][j]] = True\n                dp_col[j][matrix[i][j]] = True\n        return True\n",
        "explanations": "\nThe indices for dp_row and dp_col should be matrix[i][j]-1, not matrix[i][j].\n"
    },
    {
        "slug": "maximum-depth-of-n-ary-tree",
        "description": "Given a n-ary tree, find its maximum depth.\nThe maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.\nNary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples).",
        "examples": [
            "Input: root = [1,null,3,2,4,null,5,6]\nOutput: 3",
            "Input: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]\nOutput: 5"
        ],
        "constraints": "The total number of nodes is in the range [0, 104].\nThe depth of the n-ary tree is less than or equal to 1000.",
        "release_time": 1665143377,
        "oracle_code": "\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, val=None, children=None):\n        self.val = val\n        self.children = children\n\"\"\"\n\nclass Solution:\n    def maxDepth(self, root: 'Node') -> int:\n        if root == None:\n            return 0\n        else:\n            depth = 0\n            nodes_queue = [root]\n            next_nodes_queue = []\n            while(nodes_queue):\n                node_out = nodes_queue.pop(0)\n                for child in node_out.children:\n                    next_nodes_queue.append(child)\n                if nodes_queue == []:\n                    nodes_queue, next_nodes_queue = next_nodes_queue, nodes_queue\n                    depth += 1\n            return depth",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\n\\nclass Solution:\\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        if root == None:\\n            return 0\\n        else:\\n            depth = 0\\n            nodes_queue = [root]\\n            next_nodes_queue = []\\n            while(nodes_queue):\\n                node_out = nodes_queue.pop(0)\\n                for child in node_out.children:\\n                    next_nodes_queue.append(child)\\n                if nodes_queue == []:\\n                    nodes_queue, next_nodes_queue = next_nodes_queue, nodes_queue\\n                    depth += 1\\n            return depth\\n```",
        "level": "easy",
        "buggy_code": "\n\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, val=None, children=None):\n        self.val = val\n        self.children = children\n\nclass Solution:\n    def maxDepth(self, root: 'Node') -> int:\n        if root == None:\n            return 0\n        else:\n            depth = 0\n            nodes_queue = [root]\n            next_nodes_queue = []\n            while(nodes_queue):\n                node_out = nodes_queue.pop(0)\n                for child in node_out.children[1]:   \n                    next_nodes_queue.append(child)\n                if nodes_queue == []:\n                    nodes_queue, next_nodes_queue = next_nodes_queue, nodes_queue\n                    depth += 1\n            return depth\n\"\"\"\n\n",
        "explanations": "\nThe indexing error occurs because we're trying to access the second children of 'node_out', which may not exist.\n"
    },
    {
        "slug": "length-of-the-longest-valid-substring",
        "description": "You are given a string word and an array of strings forbidden.\nA string is called valid if none of its substrings are present in forbidden.\nReturn the length of the longest valid substring of the string word.\nA substring is a contiguous sequence of characters in a string, possibly empty.",
        "examples": [
            "Input: word = \"cbaaaabc\", forbidden = [\"aaa\",\"cb\"]\nOutput: 4\nExplanation: There are 11 valid substrings in word: \"c\", \"b\", \"a\", \"ba\", \"aa\", \"bc\", \"baa\", \"aab\", \"ab\", \"abc\"and \"aabc\". The length of the longest valid substring is 4. \nIt can be shown that all other substrings contain either \"aaa\" or \"cb\" as a substring.",
            "Input: word = \"leetcode\", forbidden = [\"de\",\"le\",\"e\"]\nOutput: 4\nExplanation: There are 11 valid substrings in word: \"l\", \"t\", \"c\", \"o\", \"d\", \"tc\", \"co\", \"od\", \"tco\", \"cod\", and \"tcod\". The length of the longest valid substring is 4.\nIt can be shown that all other substrings contain either \"de\", \"le\", or \"e\" as a substring."
        ],
        "constraints": "1 <= word.length <= 105\nword consists only of lowercase English letters.\n1 <= forbidden.length <= 105\n1 <= forbidden[i].length <= 10\nforbidden[i] consists only of lowercase English letters.",
        "release_time": 1689480141,
        "oracle_code": "class Solution:\n    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int:\n        trie = {}\n        for f in forbidden:\n            t = trie\n            for c in f:\n                if c not in t:\n                    t[c] = {}\n                t = t[c]\n            t[\"end\"] = True\n        \n        def isForbidden(s):\n            t = trie\n            counter = 0\n            for c in s:\n                if c not in t:\n                    return False\n                t = t[c]\n                counter += 1\n                if \"end\" in t:\n                    return counter\n            return False\n        \n        res = 0\n        j = len(word)\n        for i in range(len(word) - 1, -1, -1):\n            truc = isForbidden(word[i:j])\n            if truc:\n                j = i + truc - 1\n            res = max(res, j - i)\n        return res",
        "content": "Put all the forbidden strings into a trie, so that for each string `s`, we can check every substring starts from the beginning (i.e. `s[:1]`,  `s[:2]` ...  `s[:len(s)]`) in one travesal.\\n\\nUse a sliding window to iterate from back to front, each time, we only need to check whether the substrings starting from the new character is forbidden. If the substring is forbidden, then we truncate the string and continue to search.\\n\\nUsing a trie can make the foibidden check fails faster and can deal with longer foibidden strings.\\n\\n# Code\\n```\\nclass Solution:\\n    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int:\\n        trie = {}\\n        for f in forbidden:\\n            t = trie\\n            for c in f:\\n                if c not in t:\\n                    t[c] = {}\\n                t = t[c]\\n            t[\"end\"] = True\\n        \\n        def isForbidden(s):\\n            t = trie\\n            counter = 0\\n            for c in s:\\n                if c not in t:\\n                    return False\\n                t = t[c]\\n                counter += 1\\n                if \"end\" in t:\\n                    return counter\\n            return False\\n        \\n        res = 0\\n        j = len(word)\\n        for i in range(len(word) - 1, -1, -1):\\n            truc = isForbidden(word[i:j])\\n            if truc:\\n                j = i + truc - 1\\n            res = max(res, j - i)\\n        return res\\n```",
        "level": "hard",
        "buggy_code": "\nclass Solution:\n    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int:\n        trie = {}\n        for f in forbidden:\n            t = trie\n            for c in f:\n                if c not in t:\n                    t[c] = {}\n                t = t[c]\n            t[\"end\"] = True\n        \n        def isForbidden(s):\n            t = trie\n            counter = 0\n            for c in s:\n                if c not in t:\n                    return False\n                t = t[c]\n                counter += 1\n                if \"end\" in t:\n                    return counter\n            return False\n        \n        res = 0\n        j = len(word) + 1\n        for i in range(len(word) - 1, -1, -1):\n            truc = isForbidden(word[i:j])\n            if truc:\n                j = i + truc - 1\n            res = max(res, j - i)\n        return res\n",
        "explanations": "\nThe issue here is with the index 'j', it is initially set as 'len(word) + 1' which is out of string's index range.\n"
    },
    {
        "slug": "linked-list-in-binary-tree",
        "description": "Given a binary tree root and a\u00a0linked list with\u00a0head\u00a0as the first node.\u00a0\nReturn True if all the elements in the linked list starting from the head correspond to some downward path connected in the binary tree\u00a0otherwise return False.\nIn this context downward path means a path that starts at some node and goes downwards.",
        "examples": [
            "Input: head = [4,2,8], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]\nOutput: true\nExplanation: Nodes in blue form a subpath in the binary Tree.",
            "Input: head = [1,4,2,6], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]\nOutput: true",
            "Input: head = [1,4,2,6,8], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]\nOutput: false\nExplanation: There is no path in the binary tree that contains all the elements of the linked list from head."
        ],
        "constraints": "The number of nodes in the tree will be in the range [1, 2500].\nThe number of nodes in the list will be in the range [1, 100].\n1 <= Node.val\u00a0<= 100\u00a0for each node in the linked list and binary tree.",
        "release_time": 1689594574,
        "oracle_code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\n\n        if head is None:\n            return True\n\n        if root is None:\n            return False\n\n        if head.val == root.val:\n            if self.isSame(head, root):\n                return True\n            \n        return self.isSubPath(head, root.left) or self.isSubPath(head, root.right)\n\n    \n    def isSame(self, head, root):\n\n        if head is None:\n            return True\n        \n        if root is None:\n            return False\n\n        if head.val == root.val:\n            return self.isSame(head.next, root.left) or self.isSame(head.next, root.right)\n        \n        return False",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\\n\\n        if head is None:\\n            return True\\n\\n        if root is None:\\n            return False\\n\\n        if head.val == root.val:\\n            if self.isSame(head, root):\\n                return True\\n            \\n        return self.isSubPath(head, root.left) or self.isSubPath(head, root.right)\\n\\n    \\n    def isSame(self, head, root):\\n\\n        if head is None:\\n            return True\\n        \\n        if root is None:\\n            return False\\n\\n        if head.val == root.val:\\n            return self.isSame(head.next, root.left) or self.isSame(head.next, root.right)\\n        \\n        return False\\n        \\n\\n```",
        "level": "medium",
        "buggy_code": "\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\n\n        if head is None:\n            return True\n\n        if root is None:\n            return False\n\n        if head.val == root.val:\n            if self.isSame(head.next, root):  \n                return True\n            \n        return self.isSubPath(head, root.left) or self.isSubPath(head, root.right)\n\n    \n    def isSame(self, head, root):\n\n        if head is None:\n            return True\n        \n        if root is None:\n            return False\n\n        if head.val == root.val:\n            return self.isSame(head.next, root.left) or self.isSame(head.next, root.right)\n        \n        return False\n",
        "explanations": "\nThe bug skips the first element of linked list while comparing with tree's node.\n"
    },
    {
        "slug": "calculate-money-in-leetcode-bank",
        "description": "Hercy wants to save money for his first car. He puts money in the Leetcode\u00a0bank every day.\nHe starts by putting in $1 on Monday, the first day. Every day from Tuesday to Sunday, he will put in $1 more than the day before. On every subsequent Monday, he will put in $1 more than the previous Monday. \nGiven n, return the total amount of money he will have in the Leetcode bank at the end of the nth day.",
        "examples": [
            "Input: n = 4\nOutput: 10\nExplanation:\u00a0After the 4th day, the total is 1 + 2 + 3 + 4 = 10.",
            "Input: n = 10\nOutput: 37\nExplanation:\u00a0After the 10th day, the total is (1 + 2 + 3 + 4 + 5 + 6 + 7) + (2 + 3 + 4) = 37. Notice that on the 2nd Monday, Hercy only puts in $2.",
            "Input: n = 20\nOutput: 96\nExplanation:\u00a0After the 20th day, the total is (1 + 2 + 3 + 4 + 5 + 6 + 7) + (2 + 3 + 4 + 5 + 6 + 7 + 8) + (3 + 4 + 5 + 6 + 7 + 8) = 96."
        ],
        "constraints": "1 <= n <= 1000",
        "release_time": 1691471559,
        "oracle_code": "class Solution:\n    def totalMoney(self, n: int) -> int:\n        income=1;a=[1];ans=0\n        for i in range(n):\n            if i%7==0 and i!=0:income=(a[len(a)-7])\n            ans+=income;income+=1;a.append(income)      \n        return ans",
        "content": "![image.png](https://assets.leetcode.com/users/images/2f3418d9-04d9-483c-a41f-87c71b45cc76_1691471550.6305616.png)\\n\\n# Code\\n```\\nclass Solution:\\n    def totalMoney(self, n: int) -> int:\\n        income=1;a=[1];ans=0\\n        for i in range(n):\\n            if i%7==0 and i!=0:income=(a[len(a)-7])\\n            ans+=income;income+=1;a.append(income)      \\n        return ans\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution:\n    def totalMoney(self, n: int) -> int:\n        income=1;a=[1];ans=0\n        for i in range(n):\n            if i%7==0 and i!=0:income=(a[len(a)-8])\n            ans+=income;income+=1;a.append(income)\n        return ans\n",
        "explanations": "\nThe index at len(a)-8 will throw an indexing error before the 8th day.\n"
    },
    {
        "slug": "maximize-the-minimum-powered-city",
        "description": "You are given a 0-indexed integer array stations of length n, where stations[i] represents the number of power stations in the ith city.\nEach power station can provide power to every city in a fixed range. In other words, if the range is denoted by r, then a power station at city i can provide power to all cities j such that |i - j| <= r and 0 <= i, j <= n - 1.\n\nNote that |x| denotes absolute value. For example, |7 - 5| = 2 and |3 - 10| = 7.\n\nThe power of a city is the total number of power stations it is being provided power from.\nThe government has sanctioned building k more power stations, each of which can be built in any city, and have the same range as the pre-existing ones.\nGiven the two integers r and k, return the maximum possible minimum power of a city, if the additional power stations are built optimally.\nNote that you can build the k power stations in multiple cities.",
        "examples": [
            "Input: stations = [1,2,4,5,0], r = 1, k = 2\nOutput: 5\nExplanation: \nOne of the optimal ways is to install both the power stations at city 1. \nSo stations will become [1,4,4,5,0].\n- City 0 is provided by 1 + 4 = 5 power stations.\n- City 1 is provided by 1 + 4 + 4 = 9 power stations.\n- City 2 is provided by 4 + 4 + 5 = 13 power stations.\n- City 3 is provided by 5 + 4 = 9 power stations.\n- City 4 is provided by 5 + 0 = 5 power stations.\nSo the minimum power of a city is 5.\nSince it is not possible to obtain a larger power, we return 5.",
            "Input: stations = [4,4,4,4], r = 0, k = 3\nOutput: 4\nExplanation: \nIt can be proved that we cannot make the minimum power of a city greater than 4."
        ],
        "constraints": "n == stations.length\n1 <= n <= 105\n0 <= stations[i] <= 105\n0 <= r\u00a0<= n - 1\n0 <= k\u00a0<= 109",
        "release_time": 1673114604,
        "oracle_code": "class Solution:\n    def maxPower(self, stations: List[int], r: int, k: int) -> int:\n        start, end = min(stations), sum(stations) + k\n        while start + 1 < end:\n            mid = (start + end) // 2\n            if self.check(stations, r, k, mid):\n                start = mid\n            else:\n                end = mid\n        if self.check(stations, r, k, end):\n            return end\n        else:\n            return start\n    \n    def check(self, stations, r, k, target):\n            n = len(stations)\n            ans = True\n            newStations = defaultdict(int)\n            power = sum(stations[ : r])\n            for i in range(n):\n                if i + r < n:\n                    power += stations[i + r]\n                if i - r - 1 >= 0:\n                    power -= stations[i - r - 1]\n                if power >= target:\n                    continue\n                elif power + k < target:\n                    ans = False\n                    break\n                else:\n                    diff = target - power\n                    power = target\n                    stations[min(i + r, n - 1)] += diff\n                    k -= diff\n                    newStations[min(i + r, n - 1)] += diff\n            for i in newStations:\n                stations[i] -= newStations[i]\n            return ans",
        "content": "# Approach\\nWe perform a binary search on the possible answer space by checking whether the given `target` (maximum possible minimum power) is valid or not. For each given `target`, we utilize a sliding window algorithm to check its validity in linear time.\\n\\n# Complexity\\n- Time complexity: `O(NlogA)`, where `A` is the range of `[min(stations), sum(stations) + k]`.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: `O(N)`, for the use of a hashmap to record the addition of new stations temporarily.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxPower(self, stations: List[int], r: int, k: int) -> int:\\n        start, end = min(stations), sum(stations) + k\\n        while start + 1 < end:\\n            mid = (start + end) // 2\\n            if self.check(stations, r, k, mid):\\n                start = mid\\n            else:\\n                end = mid\\n        if self.check(stations, r, k, end):\\n            return end\\n        else:\\n            return start\\n    \\n    def check(self, stations, r, k, target):\\n            n = len(stations)\\n            ans = True\\n            newStations = defaultdict(int)\\n            power = sum(stations[ : r])\\n            for i in range(n):\\n                if i + r < n:\\n                    power += stations[i + r]\\n                if i - r - 1 >= 0:\\n                    power -= stations[i - r - 1]\\n                if power >= target:\\n                    continue\\n                elif power + k < target:\\n                    ans = False\\n                    break\\n                else:\\n                    diff = target - power\\n                    power = target\\n                    stations[min(i + r, n - 1)] += diff\\n                    k -= diff\\n                    newStations[min(i + r, n - 1)] += diff\\n            for i in newStations:\\n                stations[i] -= newStations[i]\\n            return ans\\n```",
        "level": "hard",
        "buggy_code": "\nclass Solution:\n    def maxPower(self, stations: List[int], r: int, k: int) -> int:\n        start, end = min(stations), sum(stations) + k\n        while start + 1 < end:\n            mid = (start + end) // 2\n            if self.check(stations, r, k, mid):\n                start = mid\n            else:\n                end = mid\n        if self.check(stations, r, k, end):\n            return end\n        else:\n            return start\n    \n    def check(self, stations, r, k, target):\n            n = len(stations)\n            ans = True\n            newStations = defaultdict(int)\n            power = sum(stations[ : r])\n            for i in range(n + 1):\n                if i + r < n:\n                    power += stations[i + r]\n                if i - r - 1 >= 0:\n                    power -= stations[i - r - 1]\n                if power >= target:\n                    continue\n                elif power + k < target:\n                    ans = False\n                    break\n                else:\n                    diff = target - power\n                    power = target\n                    stations[min(i + r, n - 1)] += diff\n                    k -= diff\n                    newStations[min(i + r, n - 1)] += diff\n            for i in newStations:\n                stations[i] -= newStations[i]\n            return ans\n",
        "explanations": "\nThe for loop should go up to range(n), not range(n+1).\n"
    },
    {
        "slug": "increasing-decreasing-string",
        "description": "You are given a string s. Reorder the string using the following algorithm:\n\nPick the smallest character from s and append it to the result.\nPick the smallest character from s which is greater than the last appended character to the result and append it.\nRepeat step 2 until you cannot pick more characters.\nPick the largest character from s and append it to the result.\nPick the largest character from s which is smaller than the last appended character to the result and append it.\nRepeat step 5 until you cannot pick more characters.\nRepeat the steps from 1 to 6 until you pick all characters from s.\n\nIn each step, If the smallest or the largest character appears more than once you can choose any occurrence and append it to the result.\nReturn the result string after sorting s with this algorithm.",
        "examples": [
            "Input: s = \"aaaabbbbcccc\"\nOutput: \"abccbaabccba\"\nExplanation: After steps 1, 2 and 3 of the first iteration, result = \"abc\"\nAfter steps 4, 5 and 6 of the first iteration, result = \"abccba\"\nFirst iteration is done. Now s = \"aabbcc\" and we go back to step 1\nAfter steps 1, 2 and 3 of the second iteration, result = \"abccbaabc\"\nAfter steps 4, 5 and 6 of the second iteration, result = \"abccbaabccba\"",
            "Input: s = \"rat\"\nOutput: \"art\"\nExplanation: The word \"rat\" becomes \"art\" after re-ordering it with the mentioned algorithm."
        ],
        "constraints": "1 <= s.length <= 500\ns consists of only lowercase English letters.",
        "release_time": 1675543738,
        "oracle_code": "class Solution:\n    def sortString(self, s: str) -> str:\n        freq = {}\n        letters = sorted(set(s))\n        res = \"\"\n        for i in s:\n            if i in freq:\n                freq[i]+=1\n            else:\n                freq[i] = 1\n        while freq:\n            for i in letters:\n                if  i in freq:\n                    if freq[i]>0:\n                        res+=i\n                        freq[i]-=1\n                    else:\n                        del freq[i]\n\n            for i in letters[::-1]:\n                if  i in freq:\n                    if freq[i]>0:\n                        res+=i\n                        freq[i]-=1\n                    else:\n                        del freq[i]\n\n\n        return res",
        "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCreate a frequency map of s.\\n\\nIterate over all the letters of s in sorted manner and add that character to result .\\n\\nRepeat above step but for reversed string.\\n \\nIf the frequency becomes 0 then we delete the key from dict.\\n\\n# Code\\n```\\nclass Solution:\\n    def sortString(self, s: str) -> str:\\n        freq = {}\\n        letters = sorted(set(s))\\n        res = \"\"\\n        for i in s:\\n            if i in freq:\\n                freq[i]+=1\\n            else:\\n                freq[i] = 1\\n        while freq:\\n            for i in letters:\\n                if  i in freq:\\n                    if freq[i]>0:\\n                        res+=i\\n                        freq[i]-=1\\n                    else:\\n                        del freq[i]\\n\\n            for i in letters[::-1]:\\n                if  i in freq:\\n                    if freq[i]>0:\\n                        res+=i\\n                        freq[i]-=1\\n                    else:\\n                        del freq[i]\\n\\n\\n        return res\\n\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution:\n    def sortString(self, s: str) -> str:\n        freq = {}\n        letters = sorted(set(s))\n        res = \"\"\n        for i in s:\n            if i in freq:\n                freq[i]+=1\n            else:\n                freq[i] = 1\n        while freq:\n            for i in letters:\n                if  i in freq:\n                    if freq[i]>0:\n                        res+=i\n                        freq[i]-=1\n                    else:\n                        del freq[i]\n                        letters = letters[1:]\n\n            for i in letters[::-1]:\n                if  i in freq:\n                    if freq[i]>0:\n                        res+=i\n                        freq[i]-=1\n                    else:\n                        del freq[i]\n                        letters = letters[1:]\n\n        return res\n",
        "explanations": "\nDeleting letters from 'letters' could cause an index error as loops are still running.\n"
    },
    {
        "slug": "largest-positive-integer-that-exists-with-its-negative",
        "description": "Given an integer array nums that does not contain any zeros, find the largest positive integer k such that -k also exists in the array.\nReturn the positive integer k. If there is no such integer, return -1.",
        "examples": [
            "Input: nums = [-1,2,-3,3]\nOutput: 3\nExplanation: 3 is the only valid k we can find in the array.",
            "Input: nums = [-1,10,6,7,-7,1]\nOutput: 7\nExplanation: Both 1 and 7 have their corresponding negative values in the array. 7 has a larger value.",
            "Input: nums = [-10,8,6,7,-2,-3]\nOutput: -1\nExplanation: There is no a single valid k, we return -1."
        ],
        "constraints": "1 <= nums.length <= 1000\n-1000 <= nums[i] <= 1000\nnums[i] != 0",
        "release_time": 1665895358,
        "oracle_code": "class Solution:\n    def findMaxK(self, nums: List[int]) -> int:\n        nums=sorted(nums,reverse=True)\n        s=set(nums)\n        for i in range(len(nums)):\n            if 0-nums[i] in s:\n                return nums[i]\n        return -1",
        "content": "\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def findMaxK(self, nums: List[int]) -> int:\\n        nums=sorted(nums,reverse=True)\\n        s=set(nums)\\n        for i in range(len(nums)):\\n            if 0-nums[i] in s:\\n                return nums[i]\\n        return -1\\n\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution:\n    def findMaxK(self, nums: List[int]) -> int:\n        nums=sorted(nums,reverse=True)\n        s=set(nums)\n        for i in range(len(nums)+1):\n            if 0-nums[i] in s:\n                return nums[i]\n        return -1\n",
        "explanations": "\nAn off-by-one error. When i reaches len(nums), it tries accessing an out-of-index value.\n"
    },
    {
        "slug": "last-moment-before-all-ants-fall-out-of-a-plank",
        "description": "We have a wooden plank of the length n units. Some ants are walking on the plank, each ant moves with a speed of 1 unit per second. Some of the ants move to the left, the other move to the right.\nWhen two ants moving in two different directions meet at some point, they change their directions and continue moving again. Assume changing directions does not take any additional time.\nWhen an ant reaches one end of the plank at a time t, it falls out of the plank immediately.\nGiven an integer n and two integer arrays left and right, the positions of the ants moving to the left and the right, return the moment when the last ant(s) fall out of the plank.",
        "examples": [
            "Input: n = 4, left = [4,3], right = [0,1]\nOutput: 4\nExplanation: In the image above:\n-The ant at index 0 is named A and going to the right.\n-The ant at index 1 is named B and going to the right.\n-The ant at index 3 is named C and going to the left.\n-The ant at index 4 is named D and going to the left.\nThe last moment when an ant was on the plank is t = 4 seconds. After that, it falls immediately out of the plank. (i.e., We can say that at t = 4.0000000001, there are no ants on the plank).",
            "Input: n = 7, left = [], right = [0,1,2,3,4,5,6,7]\nOutput: 7\nExplanation: All ants are going to the right, the ant at index 0 needs 7 seconds to fall.",
            "Input: n = 7, left = [0,1,2,3,4,5,6,7], right = []\nOutput: 7\nExplanation: All ants are going to the left, the ant at index 7 needs 7 seconds to fall."
        ],
        "constraints": "1 <= n <= 104\n0 <= left.length <= n + 1\n0 <= left[i] <= n\n0 <= right.length <= n + 1\n0 <= right[i] <= n\n1 <= left.length + right.length <= n + 1\nAll values of left and right are unique, and each value can appear only in one of the two arrays.",
        "release_time": 1674935019,
        "oracle_code": "class Solution:\n    def getLastMoment(self, n: int, left: List[int], right: List[int]) -> int:\n        return max(max(left, default=0), n - min(right, default=n))",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe goal of this problem is to find the last moment when any of the ants are still on the line. This can be done by looking at the leftmost ant\\'s position and the rightmost ant\\'s position. The answer will be whichever of these two is greater.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo solve this problem, we will use a two-pass approach. In the first pass, we will find the maximum position of any of the ants in the left array. In the second pass, we will find the minimum position of any of the ants in the right array. Finally, we will compare these two values and return the greater of the two. \\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def getLastMoment(self, n: int, left: List[int], right: List[int]) -> int:\\n        return max(max(left, default=0), n - min(right, default=n))\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution:\n    def getLastMoment(self, n: int, left: List[int], right: List[int]) -> int:\n        return max(max(left[0], default=0), n - min(right[0], default=n))\n",
        "explanations": "\nThe bug is that we are getting the maximum of the first element of the list instead of the entire list.\n"
    },
    {
        "slug": "check-if-string-is-transformable-with-substring-sort-operations",
        "description": "Given two strings s and t, transform string s into string t using the following operation any number of times:\n\nChoose a non-empty substring in s and sort it in place so the characters are in ascending order.\n\n\t\nFor example, applying the operation on the underlined substring in \"14234\" results in \"12344\".\n\n\n\nReturn true if it is possible to transform s into t. Otherwise, return false.\nA substring is a contiguous sequence of characters within a string.",
        "examples": [
            "Input: s = \"84532\", t = \"34852\"\nOutput: true\nExplanation: You can transform s into t using the following sort operations:\n\"84532\" (from index 2 to 3) -> \"84352\"\n\"84352\" (from index 0 to 2) -> \"34852\"",
            "Input: s = \"34521\", t = \"23415\"\nOutput: true\nExplanation: You can transform s into t using the following sort operations:\n\"34521\" -> \"23451\"\n\"23451\" -> \"23415\"",
            "Input: s = \"12345\", t = \"12435\"\nOutput: false"
        ],
        "constraints": "s.length == t.length\n1 <= s.length <= 105\ns and t consist of only digits.",
        "release_time": 1688219312,
        "oracle_code": "class Solution:\n  def isTransformable(self, s: str, t: str) -> bool:\n    idx = defaultdict(deque)\n    for i, c in enumerate(s):\n      idx[int(c)].append(i)\n    for c in t:\n      d = int(c)\n      if not idx[d]: return False\n      for i in range(d):\n        if idx[i] and idx[i][0] < idx[d][0]: return False\n      idx[d].popleft()\n    return True",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n  def isTransformable(self, s: str, t: str) -> bool:\\n    idx = defaultdict(deque)\\n    for i, c in enumerate(s):\\n      idx[int(c)].append(i)\\n    for c in t:\\n      d = int(c)\\n      if not idx[d]: return False\\n      for i in range(d):\\n        if idx[i] and idx[i][0] < idx[d][0]: return False\\n      idx[d].popleft()\\n    return True\\n```",
        "level": "hard",
        "buggy_code": "\nclass Solution:\n  def isTransformable(self, s: str, t: str) -> bool:\n    idx = defaultdict(deque)\n    for i, c in enumerate(s):\n      idx[int(c)].append(i)\n    for c in t:\n      d = int(c)\n      if not idx[d + 1]: return False\n      for i in range(d):\n        if idx[i] and idx[i][0] < idx[d][0]: return False\n      idx[d].popleft()\n    return True\n",
        "explanations": "\nIf last character in string 't' is highest in 's', \"idx[d + 1]\" causes IndexError.\n"
    },
    {
        "slug": "longest-harmonious-subsequence",
        "description": "We define a harmonious array as an array where the difference between its maximum value and its minimum value is exactly 1.\nGiven an integer array nums, return the length of its longest harmonious subsequence among all its possible subsequences.\nA subsequence of array is a sequence that can be derived from the array by deleting some or no elements without changing the order of the remaining elements.",
        "examples": [
            "Input: nums = [1,3,2,2,5,2,3,7]\r\nOutput: 5\r\nExplanation: The longest harmonious subsequence is [3,2,2,2,3].",
            "Input: nums = [1,2,3,4]\r\nOutput: 2",
            "Input: nums = [1,1,1,1]\r\nOutput: 0"
        ],
        "constraints": "1 <= nums.length <= 2 * 104\n-109 <= nums[i] <= 109",
        "release_time": 1690719700,
        "oracle_code": "class Solution:\n    def findLHS(self, nums: List[int]) -> int:\n        result = 0\n        count_map = {}\n        for num in nums:\n            if num not in count_map:\n                count_map[num] = 1\n            else:\n                count_map[num] += 1\n        for num, count in count_map.items():\n            if num + 1 in count_map:\n                result = max(count + count_map[num + 1], result)\n        return result",
        "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCreate a count map holding occurences on elements and loop on keys to check if next consecutive element is present in the map.\\nIf present, compare the result with the max variable\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution:\\n    def findLHS(self, nums: List[int]) -> int:\\n        result = 0\\n        count_map = {}\\n        for num in nums:\\n            if num not in count_map:\\n                count_map[num] = 1\\n            else:\\n                count_map[num] += 1\\n        for num, count in count_map.items():\\n            if num + 1 in count_map:\\n                result = max(count + count_map[num + 1], result)\\n        return result\\n\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution:\n    def findLHS(self, nums: List[int]) -> int:\n        result = 0\n        count_map = {}\n        for num in nums:\n            if num not in count_map:\n                count_map[num] = 1\n            else:\n                count_map[num] += 1\n        for num, count in count_map.items():\n            if num + 1 in count_map:\n                result = max(count + count_map[num + 2], result)\n        return result\n",
        "explanations": "\nThe bug is that the index num + 2 should be num + 1 in order to get the correct count.\n"
    },
    {
        "slug": "sort-an-array",
        "description": "Given an array of integers nums, sort the array in ascending order and return it.\nYou must solve the problem without using any built-in functions in O(nlog(n)) time complexity and with the smallest space complexity possible.",
        "examples": [
            "Input: nums = [5,2,3,1]\nOutput: [1,2,3,5]\nExplanation: After sorting the array, the positions of some numbers are not changed (for example, 2 and 3), while the positions of other numbers are changed (for example, 1 and 5).",
            "Input: nums = [5,1,1,2,0,0]\nOutput: [0,0,1,1,2,5]\nExplanation: Note that the values of nums are not necessairly unique."
        ],
        "constraints": "1 <= nums.length <= 5 * 104\n-5 * 104 <= nums[i] <= 5 * 104",
        "release_time": 1677727583,
        "oracle_code": "class Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        nums.sort()\n        return nums",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nPython has a built in sort() function that can sort the list for you if you don\\'t want to learn sorting algorithms.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nJust run list.sort() on its own line and return the list. It\\'s that simple.\\n\\n# Code\\n```\\nclass Solution:\\n    def sortArray(self, nums: List[int]) -> List[int]:\\n        nums.sort()\\n        return nums\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        nums.sort()\n        return nums[-1]\n",
        "explanations": "\nReturning last element instead of sorted array, causing an indexing error. \n"
    },
    {
        "slug": "string-compression-ii",
        "description": "Run-length encoding is a string compression method that works by\u00a0replacing consecutive identical characters (repeated 2 or more times) with the concatenation of the character and the number marking the count of the characters (length of the run). For example, to compress the string\u00a0\"aabccc\"\u00a0we replace \"aa\"\u00a0by\u00a0\"a2\"\u00a0and replace \"ccc\"\u00a0by\u00a0\"c3\". Thus the compressed string becomes \"a2bc3\".\nNotice that in this problem, we are not adding\u00a0'1'\u00a0after single characters.\nGiven a\u00a0string s\u00a0and an integer k. You need to delete at most\u00a0k characters from\u00a0s\u00a0such that the run-length encoded version of s\u00a0has minimum length.\nFind the minimum length of the run-length encoded\u00a0version of s after deleting at most k characters.",
        "examples": [
            "Input: s = \"aaabcccd\", k = 2\nOutput: 4\nExplanation: Compressing s without deleting anything will give us \"a3bc3d\" of length 6. Deleting any of the characters 'a' or 'c' would at most decrease the length of the compressed string to 5, for instance delete 2 'a' then we will have s = \"abcccd\" which compressed is abc3d. Therefore, the optimal way is to delete 'b' and 'd', then the compressed version of s will be \"a3c3\" of length 4.",
            "Input: s = \"aabbaa\", k = 2\nOutput: 2\nExplanation: If we delete both 'b' characters, the resulting compressed string would be \"a4\" of length 2.",
            "Input: s = \"aaaaaaaaaaa\", k = 0\nOutput: 3\nExplanation: Since k is zero, we cannot delete anything. The compressed string is \"a11\" of length 3."
        ],
        "constraints": "1 <= s.length <= 100\n0 <= k <= s.length\ns contains only lowercase English letters.",
        "release_time": 1684779092,
        "oracle_code": "class Solution:\n    def dp(self,i,s,prev,k,ct,n,dct):\n        if k<0:\n            return float(\"infinity\")\n        if i>=n:\n            x=0\n            if ct>1:\n                x=len(str(ct))+1\n            elif ct==1:\n                x=1\n            return x\n        if (i,prev,ct,k) in dct:\n            return dct[(i,prev,ct,k)]\n        if s[i]==prev:\n            inc=self.dp(i+1,s,prev,k,ct+1,n,dct)\n        else:\n            x=0\n            if ct>1:\n                x=len(str(ct))+1\n            elif ct==1:\n                x=1\n            inc=x+self.dp(i+1,s,s[i],k,1,n,dct)\n        exc=self.dp(i+1,s,prev,k-1,ct,n,dct)\n        dct[(i,prev,ct,k)]=min(inc,exc)\n        return min(inc,exc)\n\n\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n        n=len(s)\n        return self.dp(0,s,\"\",k,0,n,{})",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def dp(self,i,s,prev,k,ct,n,dct):\\n        if k<0:\\n            return float(\"infinity\")\\n        if i>=n:\\n            x=0\\n            if ct>1:\\n                x=len(str(ct))+1\\n            elif ct==1:\\n                x=1\\n            return x\\n        if (i,prev,ct,k) in dct:\\n            return dct[(i,prev,ct,k)]\\n        if s[i]==prev:\\n            inc=self.dp(i+1,s,prev,k,ct+1,n,dct)\\n        else:\\n            x=0\\n            if ct>1:\\n                x=len(str(ct))+1\\n            elif ct==1:\\n                x=1\\n            inc=x+self.dp(i+1,s,s[i],k,1,n,dct)\\n        exc=self.dp(i+1,s,prev,k-1,ct,n,dct)\\n        dct[(i,prev,ct,k)]=min(inc,exc)\\n        return min(inc,exc)\\n\\n\\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\\n        n=len(s)\\n        return self.dp(0,s,\"\",k,0,n,{})\\n\\n        \\n```",
        "level": "hard",
        "buggy_code": "\nclass Solution:\n    def dp(self,i,s,prev,k,ct,n,dct):\n        if k<0:\n            return float(\"infinity\")\n        if i>=n+1:\n            x=0\n            if ct>1:\n                x=len(str(ct))+1\n            elif ct==1:\n                x=1\n            return x\n        if (i,prev,ct,k) in dct:\n            return dct[(i,prev,ct,k)]\n        if s[i]==prev:\n            inc=self.dp(i+1,s,prev,k,ct+1,n,dct)\n        else:\n            x=0\n            if ct>1:\n                x=len(str(ct))+1\n            elif ct==1:\n                x=1\n            inc=x+self.dp(i+1,s,s[i],k,1,n,dct)\n        exc=self.dp(i+1,s,prev,k-1,ct,n,dct)\n        dct[(i,prev,ct,k)]=min(inc,exc)\n        return min(inc,exc)\n\n\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n        n=len(s)\n        return self.dp(0,s,\"\",k,0,n,{})\n",
        "explanations": "\nThe condition (i >= n+1) in dp function introduces off-by-one indexing error.\n"
    },
    {
        "slug": "largest-number-after-digit-swaps-by-parity",
        "description": "You are given a positive integer num. You may swap any two digits of num that have the same parity (i.e. both odd digits or both even digits).\nReturn the largest possible value of num after any number of swaps.",
        "examples": [
            "Input: num = 1234\nOutput: 3412\nExplanation: Swap the digit 3 with the digit 1, this results in the number 3214.\nSwap the digit 2 with the digit 4, this results in the number 3412.\nNote that there may be other sequences of swaps but it can be shown that 3412 is the largest possible number.\nAlso note that we may not swap the digit 4 with the digit 1 since they are of different parities.",
            "Input: num = 65875\nOutput: 87655\nExplanation: Swap the digit 8 with the digit 6, this results in the number 85675.\nSwap the first digit 5 with the digit 7, this results in the number 87655.\nNote that there may be other sequences of swaps but it can be shown that 87655 is the largest possible number."
        ],
        "constraints": "1 <= num <= 109",
        "release_time": 1672166650,
        "oracle_code": "class Solution:\n    def largestInteger(self, num: int) -> int:\n        evenlist=[]\n        oddlist=[]\n        nums= [int(x) for x in str(num)]\n        for i in nums:\n            if i%2==0:\n                evenlist.append(i)\n            else:\n                oddlist.append(i)\n        even= [-x for x in evenlist]\n        odd = [-x for x in oddlist]\n        heapq.heapify(even)\n        heapq.heapify(odd)\n        result=[]\n        for ele in nums:\n            if ele in evenlist:\n                result+=[-heapq.heappop(even)]\n            if ele in oddlist:\n                result+=[-heapq.heappop(odd)]\n        result =[str(x) for x in result]                \n        return int(''.join(result))",
        "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def largestInteger(self, num: int) -> int:\\n        evenlist=[]\\n        oddlist=[]\\n        nums= [int(x) for x in str(num)]\\n        for i in nums:\\n            if i%2==0:\\n                evenlist.append(i)\\n            else:\\n                oddlist.append(i)\\n        even= [-x for x in evenlist]\\n        odd = [-x for x in oddlist]\\n        heapq.heapify(even)\\n        heapq.heapify(odd)\\n        result=[]\\n        for ele in nums:\\n            if ele in evenlist:\\n                result+=[-heapq.heappop(even)]\\n            if ele in oddlist:\\n                result+=[-heapq.heappop(odd)]\\n        result =[str(x) for x in result]                \\n        return int(\\'\\'.join(result))\\n\\n\\n                    \\n\\n\\n        \\n\\n\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution:\n    def largestInteger(self, num: int) -> int:\n        evenlist=[]\n        oddlist=[]\n        nums= [int(x) for x in str(num)]\n        for i in nums:\n            if i%2==0:\n                evenlist.append(i)\n            else:\n                oddlist.append(i)\n        even= [-x for x in evenlist]\n        odd = [-x for x in oddlist]\n        heapq.heapify(even)\n        heapq.heapify(odd)\n        result=[]\n        for ele in nums:\n            if ele in evenlist:\n                result+=[-heapq.heappop(even)]\n            elif ele in oddlist:\n                result+=[-heapq.heappop(odd)]\n        result =[str(x) for x in result]\n        return int(''.join(result[6:]))\n",
        "explanations": "\nThe code will fail for numbers with less than 6 digits due to incorrect indexing.\n"
    },
    {
        "slug": "substring-with-concatenation-of-all-words",
        "description": "You are given a string s and an array of strings words. All the strings of words are of the same length.\nA concatenated substring in s is a substring that contains all the strings of any permutation of words concatenated.\n\nFor example, if words = [\"ab\",\"cd\",\"ef\"], then \"abcdef\", \"abefcd\", \"cdabef\", \"cdefab\", \"efabcd\", and \"efcdab\" are all concatenated strings. \"acdbef\" is not a concatenated substring because it is not the concatenation of any permutation of words.\n\nReturn the starting indices of all the concatenated substrings in s. You can return the answer in any order.",
        "examples": [
            "Input: s = \"barfoothefoobarman\", words = [\"foo\",\"bar\"]\nOutput: [0,9]\nExplanation: Since words.length == 2 and words[i].length == 3, the concatenated substring has to be of length 6.\nThe substring starting at 0 is \"barfoo\". It is the concatenation of [\"bar\",\"foo\"] which is a permutation of words.\nThe substring starting at 9 is \"foobar\". It is the concatenation of [\"foo\",\"bar\"] which is a permutation of words.\nThe output order does not matter. Returning [9,0] is fine too.",
            "Input: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]\nOutput: []\nExplanation: Since words.length == 4 and words[i].length == 4, the concatenated substring has to be of length 16.\nThere is no substring of length 16 is s that is equal to the concatenation of any permutation of words.\nWe return an empty array.",
            "Input: s = \"barfoofoobarthefoobarman\", words = [\"bar\",\"foo\",\"the\"]\nOutput: [6,9,12]\nExplanation: Since words.length == 3 and words[i].length == 3, the concatenated substring has to be of length 9.\nThe substring starting at 6 is \"foobarthe\". It is the concatenation of [\"foo\",\"bar\",\"the\"] which is a permutation of words.\nThe substring starting at 9 is \"barthefoo\". It is the concatenation of [\"bar\",\"the\",\"foo\"] which is a permutation of words.\nThe substring starting at 12 is \"thefoobar\". It is the concatenation of [\"the\",\"foo\",\"bar\"] which is a permutation of words."
        ],
        "constraints": "1 <= s.length <= 104\n1 <= words.length <= 5000\n1 <= words[i].length <= 30\ns and words[i] consist of lowercase English letters.",
        "release_time": 1686875139,
        "oracle_code": "class Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        wlen= len(words[0])\n        slen= wlen*len(words)\n        track=dict()\n        \n        occ = collections.Counter(words)\n\n        def test():\n            for key, val in track.items():\n                if val !=occ[key]:\n                    return False\n            return True\n        res=[]\n        #first look\n\n        for k in range(wlen):\n            for i in words:\n                track.update({i : 0})\n            for i in range(k,slen+k,wlen):\n                w=s[i:i+wlen]\n                if w in words:\n                    track.update({w: track[w]+1})\n            if test():\n                res.append(k)\n            #complete\n            for i in range(wlen+k, len(s)-slen+1,wlen):\n                \n                nw=s[i+slen-wlen:i+slen]\n                pw=s[i-wlen:i]\n                if nw in words:\n                    track.update({nw: track[nw]+1})\n                if pw in words:\n                    track.update({pw: track[pw]-1})\n                if test():\n                    res.append(i)\n        return res",
        "content": "\\n# Approach\\n\\nThe solution iterates through possible starting points in the given string and checks if the substring starting from each point forms a concatenated substring. It maintains a dictionary to track the occurrences of words encountered and compares it with the expected occurrences. By updating the counts while scanning the string, it identifies valid concatenated substrings and records their starting indices. The solution effectively ensures that all the words in any permutation of the input words array are present in the substring, returning the starting indices of all such valid substrings.\\n\\n# Code\\n```\\nclass Solution:\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\\n        wlen= len(words[0])\\n        slen= wlen*len(words)\\n        track=dict()\\n        \\n        occ = collections.Counter(words)\\n\\n        def test():\\n            for key, val in track.items():\\n                if val !=occ[key]:\\n                    return False\\n            return True\\n        res=[]\\n        #first look\\n\\n        for k in range(wlen):\\n            for i in words:\\n                track.update({i : 0})\\n            for i in range(k,slen+k,wlen):\\n                w=s[i:i+wlen]\\n                if w in words:\\n                    track.update({w: track[w]+1})\\n            if test():\\n                res.append(k)\\n            #complete\\n            for i in range(wlen+k, len(s)-slen+1,wlen):\\n                \\n                nw=s[i+slen-wlen:i+slen]\\n                pw=s[i-wlen:i]\\n                if nw in words:\\n                    track.update({nw: track[nw]+1})\\n                if pw in words:\\n                    track.update({pw: track[pw]-1})\\n                if test():\\n                    res.append(i)\\n        return res\\n\\n        \\n```",
        "level": "hard",
        "buggy_code": "\nclass Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        wlen= len(words[0])\n        slen= wlen*len(words)\n        track=dict()\n        \n        occ = collections.Counter(words)\n\n        def test():\n            for key, val in track.items():\n                if val !=occ[key]:\n                    return False\n            return True\n        res=[]\n        #first look\n\n        for k in range(wlen):\n            for i in words:\n                track.update({i : 0})\n            for i in range(k,slen+k,wlen):\n                w=s[i:i+wlen]\n                if w in words:\n                    track.update({w: track[w]+1})\n            if test():\n                res.append(k)\n            #complete\n            for i in range(wlen+k, len(s)-slen+1,wlen):\n                \n                nw=s[i+slen-wlen:i+slen]\n                pw=s[i-wlen:i]\n                if nw in words:\n                    track.update({nw: track[nw]+1})\n                if pw in words:\n                    track.update({pw: track[pw]-1})\n                if test():\n                    res.append(i+wlen)\n        return res\n",
        "explanations": "\nThe index 'i+wlen' to append in res is out of bounds when 'i' equals to 'len(s)-1'.\n"
    },
    {
        "slug": "binary-tree-level-order-traversal-ii",
        "description": "Given the root of a binary tree, return the bottom-up level order traversal of its nodes' values. (i.e., from left to right, level by level from leaf to root).",
        "examples": [
            "Input: root = [3,9,20,null,null,15,7]\nOutput: [[15,7],[9,20],[3]]",
            "Input: root = [1]\nOutput: [[1]]",
            "Input: root = []\nOutput: []"
        ],
        "constraints": "The number of nodes in the tree is in the range [0, 2000].\n-1000 <= Node.val <= 1000",
        "release_time": 1666016205,
        "oracle_code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:\n        def checkReverse(ans):\n            l,r = 0,len(ans)-1\n            while l<=r:\n                ans[l],ans[r] = ans[r],ans[l]\n                l+=1\n                r-=1\n            return ans\n\n        if not root: return None\n        q,ans = [root],[]\n        while q:\n            n,l = len(q),[]\n            for i in range(n):\n                curr = q.pop(0)\n                l.append(curr.val)\n                if curr.left:\n                    q.append(curr.left)\n                if curr.right:\n                    q.append(curr.right)\n            ans.append(l)\n        return checkReverse(ans)",
        "content": "# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:\\n        def checkReverse(ans):\\n            l,r = 0,len(ans)-1\\n            while l<=r:\\n                ans[l],ans[r] = ans[r],ans[l]\\n                l+=1\\n                r-=1\\n            return ans\\n\\n        if not root: return None\\n        q,ans = [root],[]\\n        while q:\\n            n,l = len(q),[]\\n            for i in range(n):\\n                curr = q.pop(0)\\n                l.append(curr.val)\\n                if curr.left:\\n                    q.append(curr.left)\\n                if curr.right:\\n                    q.append(curr.right)\\n            ans.append(l)\\n        return checkReverse(ans)\\n```",
        "level": "medium",
        "buggy_code": "\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:\n        def checkReverse(ans):\n            l,r = 0,len(ans)\n            while l<=r:\n                ans[l],ans[r] = ans[r],ans[l]\n                l+=1\n                r-=1\n            return ans\n\n        if not root: return None\n        q,ans = [root],[]\n        while q:\n            n,l = len(q),[]\n            for i in range(n):\n                curr = q.pop(0)\n                l.append(curr.val)\n                if curr.left:\n                    q.append(curr.left)\n                if curr.right:\n                    q.append(curr.right)\n            ans.append(l)\n        return checkReverse(ans)\n",
        "explanations": "\nIn 'checkReverse' function, the right pointer 'r' is out of array bounds.\n"
    },
    {
        "slug": "minimum-bit-flips-to-convert-number",
        "description": "A bit flip of a number x is choosing a bit in the binary representation of x and flipping it from either 0 to 1 or 1 to 0.\n\nFor example, for x = 7, the binary representation is 111 and we may choose any bit (including any leading zeros not shown) and flip it. We can flip the first bit from the right to get 110, flip the second bit from the right to get 101, flip the fifth bit from the right (a leading zero) to get 10111, etc.\n\nGiven two integers start and goal, return the minimum number of bit flips to convert start to goal.",
        "examples": [
            "Input: start = 10, goal = 7\nOutput: 3\nExplanation: The binary representation of 10 and 7 are 1010 and 0111 respectively. We can convert 10 to 7 in 3 steps:\n- Flip the first bit from the right: 1010 -> 1011.\n- Flip the third bit from the right: 1011 -> 1111.\n- Flip the fourth bit from the right: 1111 -> 0111.\nIt can be shown we cannot convert 10 to 7 in less than 3 steps. Hence, we return 3.",
            "Input: start = 3, goal = 4\nOutput: 3\nExplanation: The binary representation of 3 and 4 are 011 and 100 respectively. We can convert 3 to 4 in 3 steps:\n- Flip the first bit from the right: 011 -> 010.\n- Flip the second bit from the right: 010 -> 000.\n- Flip the third bit from the right: 000 -> 100.\nIt can be shown we cannot convert 3 to 4 in less than 3 steps. Hence, we return 3."
        ],
        "constraints": "0 <= start, goal <= 109",
        "release_time": 1677410468,
        "oracle_code": "class Solution:\n    def minBitFlips(self, start: int, goal: int) -> int:\n        s=bin(start)[2:].zfill(50)\n        g=bin(goal)[2:].zfill(50)\n        count=0\n        for i in range(50):\n            if s[i]!=g[i]:\n                count+=1\n        return count",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minBitFlips(self, start: int, goal: int) -> int:\\n        s=bin(start)[2:].zfill(50)\\n        g=bin(goal)[2:].zfill(50)\\n        count=0\\n        for i in range(50):\\n            if s[i]!=g[i]:\\n                count+=1\\n        return count\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution:\n    def minBitFlips(self, start: int, goal: int) -> int:\n        s=bin(start)[2:].zfill(50)\n        g=bin(goal)[2:].zfill(50)\n        count=0\n        for i in range(51): \n            if s[i]!=g[i]:\n                count+=1\n        return count\n",
        "explanations": "\nThe range in the for loop goes past the last index of s and g.\n"
    },
    {
        "slug": "restore-ip-addresses",
        "description": "A valid IP address consists of exactly four integers separated by single dots. Each integer is between 0 and 255 (inclusive) and cannot have leading zeros.\n\nFor example, \"0.1.2.201\" and \"192.168.1.1\" are valid IP addresses, but \"0.011.255.245\", \"192.168.1.312\" and \"192.168@1.1\" are invalid IP addresses.\n\nGiven a string s containing only digits, return all possible valid IP addresses that can be formed by inserting dots into s. You are not allowed to reorder or remove any digits in s. You may return the valid IP addresses in any order.",
        "examples": [
            "Input: s = \"25525511135\"\nOutput: [\"255.255.11.135\",\"255.255.111.35\"]",
            "Input: s = \"0000\"\nOutput: [\"0.0.0.0\"]",
            "Input: s = \"101023\"\nOutput: [\"1.0.10.23\",\"1.0.102.3\",\"10.1.0.23\",\"10.10.2.3\",\"101.0.2.3\"]"
        ],
        "constraints": "1 <= s.length <= 20\ns consists of digits only.",
        "release_time": 1674285009,
        "oracle_code": "class Solution:\n    def restoreIpAddresses(self, s: str) -> List[str]:\n        res=[]\n        cur=[]\n        def backtrack(i):\n            if i==len(s) and len(cur)==4:\n                res.append(\".\".join(cur))\n                return\n            if len(cur)>4 or i>=len(s):\n                return\n            if s[i]=='0':\n                cur.append(s[i])\n                backtrack(i+1)\n                cur.pop()\n                return\n            j=0\n            while j<4 and i+j<len(s):\n                if int(s[i:i+j+1])<256:\n                    cur.append(s[i:i+j+1])\n                    backtrack(i+j+1)\n                    cur.pop()\n                j+=1\n        backtrack(0)\n        return res",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\njust take care with the processing number should be lower than len(s) and the length of current stack should be lower or equal 4.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(4)\\n# Code\\n```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        res=[]\\n        cur=[]\\n        def backtrack(i):\\n            if i==len(s) and len(cur)==4:\\n                res.append(\".\".join(cur))\\n                return\\n            if len(cur)>4 or i>=len(s):\\n                return\\n            if s[i]==\\'0\\':\\n                cur.append(s[i])\\n                backtrack(i+1)\\n                cur.pop()\\n                return\\n            j=0\\n            while j<4 and i+j<len(s):\\n                if int(s[i:i+j+1])<256:\\n                    cur.append(s[i:i+j+1])\\n                    backtrack(i+j+1)\\n                    cur.pop()\\n                j+=1\\n        backtrack(0)\\n        return res\\n\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution:\n    def restoreIpAddresses(self, s: str) -> List[str]:\n        res=[]\n        cur=[]\n        def backtrack(i):\n            if i==len(s) and len(cur)==4:\n                res.append(\".\".join(cur))\n                return\n            if len(cur)>4 or i>len(s):\n                return\n            if s[i]=='0':\n                cur.append(s[i])\n                backtrack(i+1)\n                cur.pop()\n                return\n            j=0\n            while j<4 and i+j<len(s):\n                if int(s[i:i+j+1])<256:\n                    cur.append(s[i:i+j+1])\n                    backtrack(i+j+1)\n                    cur.pop()\n                j+=1\n        backtrack(0)\n        return res\n",
        "explanations": "\nThe index goes out of range when i equals to len(s) in s[i].\n"
    },
    {
        "slug": "n-th-tribonacci-number",
        "description": "The Tribonacci sequence Tn is defined as follows:\u00a0\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.\nGiven n, return the value of Tn.",
        "examples": [
            "Input: n = 4\r\nOutput: 4\r\nExplanation:\r\nT_3 = 0 + 1 + 1 = 2\r\nT_4 = 1 + 1 + 2 = 4",
            "Input: n = 25\r\nOutput: 1389537"
        ],
        "constraints": "0 <= n <= 37\nThe answer is guaranteed to fit within a 32-bit integer, ie. answer <= 2^31 - 1.",
        "release_time": 1691827777,
        "oracle_code": "class Solution:\n    def tribonacci(self, n: int) -> int:\n        if n==0:return 0\n        d=[0]*(3)\n        d[0]=0\n        d[1]=d[2]=1\n        for i in range(3,n+1):\n            d.append(sum(d))\n            d.pop(0)\n        return d[2]",
        "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\na array of size 3 is there it has values of `fib(0),fib(1),fib(2)`\\nfurthur usig thier sum we append it to end of list and pop the first element\\nat end answer will be stored in last `a[2]` returning it does the job\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n**______O(N)**\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n**______O(1)**\\n\\n# Code\\n```\\nclass Solution:\\n    def tribonacci(self, n: int) -> int:\\n        if n==0:return 0\\n        d=[0]*(3)\\n        d[0]=0\\n        d[1]=d[2]=1\\n        for i in range(3,n+1):\\n            d.append(sum(d))\\n            d.pop(0)\\n        return d[2]\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution:\n    def tribonacci(self, n: int) -> int:\n        if n==0:return 0\n        d=[0]*(3)\n        d[0]=0\n        d[1]=d[2]=1\n        for i in range(3,n+1):\n            d.append(sum(d))\n            d.pop(0)\n        return d[3]\n",
        "explanations": "\nThe bug occurs because the list index out of range error is raised.\n"
    },
    {
        "slug": "construct-quad-tree",
        "description": "Given a n * n matrix grid of 0's and 1's only. We want to represent grid with a Quad-Tree.\nReturn the root of the Quad-Tree representing grid.\nA Quad-Tree is a tree data structure in which each internal node has exactly four children. Besides, each node has two attributes:\n\nval: True if the node represents a grid of 1's or False if the node represents a grid of 0's. Notice that you can assign the val to True or False when isLeaf is False, and both are accepted in the answer.\nisLeaf: True if the node is a leaf node on the tree or False if the node has four children.\n\n\nclass Node {\n    public boolean val;\n    public boolean isLeaf;\n    public Node topLeft;\n    public Node topRight;\n    public Node bottomLeft;\n    public Node bottomRight;\n}\nWe can construct a Quad-Tree from a two-dimensional area using the following steps:\n\nIf the current grid has the same value (i.e all 1's or all 0's) set isLeaf True and set val to the value of the grid and set the four children to Null and stop.\nIf the current grid has different values, set isLeaf to False and set val to any value and divide the current grid into four sub-grids as shown in the photo.\nRecurse for each of the children with the proper sub-grid.\n\n\nIf you want to know more about the Quad-Tree, you can refer to the wiki.\nQuad-Tree format:\nYou don't need to read this section for solving the problem. This is only if you want to understand the output format here. The output represents the serialized format of a Quad-Tree using level order traversal, where null signifies a path terminator where no node exists below.\nIt is very similar to the serialization of the binary tree. The only difference is that the node is represented as a list [isLeaf, val].\nIf the value of isLeaf or val is True we represent it as 1 in the list [isLeaf, val] and if the value of isLeaf or val is False we represent it as 0.",
        "examples": [
            "Input: grid = [[0,1],[1,0]]\nOutput: [[0,1],[1,0],[1,1],[1,1],[1,0]]\nExplanation: The explanation of this example is shown below:\nNotice that 0 represents False and 1 represents True in the photo representing the Quad-Tree.",
            "Input: grid = [[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0]]\nOutput: [[0,1],[1,1],[0,1],[1,1],[1,0],null,null,null,null,[1,0],[1,0],[1,1],[1,1]]\nExplanation: All values in the grid are not the same. We divide the grid into four sub-grids.\nThe topLeft, bottomLeft and bottomRight each has the same value.\nThe topRight have different values so we divide it into 4 sub-grids where each has the same value.\nExplanation is shown in the photo below:"
        ],
        "constraints": "n == grid.length == grid[i].length\nn == 2x where 0 <= x <= 6",
        "release_time": 1677459150,
        "oracle_code": "class Solution:\n    def construct(self, grid: List[List[int]]) -> 'Node':\n        level = len(grid)\n        root = None\n        if level >= 1:\n            root = self.buildTree(grid, 0, level, 0, level, level)\n        return root\n        \n        \n    def buildTree(self, grid, rs, re, cs, ce, level):\n        if level == 1:\n            # this is a leaf node:\n            return Node(grid[rs][cs], True, None, None, None, None)\n        \n        next_level = level // 2\n        tl = self.buildTree(grid, rs, re - next_level, cs, ce - next_level, next_level)\n        tr = self.buildTree(grid, rs, re - next_level, ce - next_level, ce, next_level)\n        bl = self.buildTree(grid, re - next_level, re, cs, ce - next_level, next_level)\n        br = self.buildTree(grid, re - next_level, re, ce - next_level, ce, next_level)\n        \n        if tl.isLeaf and tr.isLeaf and bl.isLeaf and br.isLeaf:\n            if tl.val == tr.val == bl.val == br.val:\n                new_node = Node(tl.val, True, None, None, None, None)\n            else:\n                new_node = Node(tl.val, False, tl, tr, bl, br)\n        else:\n            new_node = Node(tl.val, False, tl, tr, bl, br)\n            \n        return new_node",
        "content": "This is a simple recursion problem.\\n\\nWe can go from top to bottom (i.e., 2 ^ n -->  1) and build the tree based on the return value of the four children.\\n\\n(1) if the number of element in the grid region is 1, this is a leaf node, we build a new node and return it;\\n(2) check the four children, if they all are leaf nodes and have the same value, we can merge the four nodes by create a new leaf node;\\n(3) otherwise, just build a new node from the four children.\\n\\n\\n```\\nclass Solution:\\n    def construct(self, grid: List[List[int]]) -> \\'Node\\':\\n        level = len(grid)\\n        root = None\\n        if level >= 1:\\n            root = self.buildTree(grid, 0, level, 0, level, level)\\n        return root\\n        \\n        \\n    def buildTree(self, grid, rs, re, cs, ce, level):\\n        if level == 1:\\n            # this is a leaf node:\\n            return Node(grid[rs][cs], True, None, None, None, None)\\n        \\n        next_level = level // 2\\n        tl = self.buildTree(grid, rs, re - next_level, cs, ce - next_level, next_level)\\n        tr = self.buildTree(grid, rs, re - next_level, ce - next_level, ce, next_level)\\n        bl = self.buildTree(grid, re - next_level, re, cs, ce - next_level, next_level)\\n        br = self.buildTree(grid, re - next_level, re, ce - next_level, ce, next_level)\\n        \\n        if tl.isLeaf and tr.isLeaf and bl.isLeaf and br.isLeaf:\\n            if tl.val == tr.val == bl.val == br.val:\\n                new_node = Node(tl.val, True, None, None, None, None)\\n            else:\\n                new_node = Node(tl.val, False, tl, tr, bl, br)\\n        else:\\n            new_node = Node(tl.val, False, tl, tr, bl, br)\\n            \\n        return new_node\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution:\n    def construct(self, grid: List[List[int]]) -> 'Node':\n        level = len(grid)\n        root = None\n        if level >= 1:\n            root = self.buildTree(grid, 0, level, 0, level, level)\n        return root\n        \n        \n    def buildTree(self, grid, rs, re, cs, ce, level):\n        if level == 1:\n            # this is a leaf node:\n            return Node(grid[rs][cs+1], True, None, None, None, None)\n        \n        next_level = level // 2\n        tl = self.buildTree(grid, rs, re - next_level, cs, ce - next_level, next_level)\n        tr = self.buildTree(grid, rs, re - next_level, ce - next_level, ce, next_level)\n        bl = self.buildTree(grid, re - next_level, re, cs, ce - next_level, next_level)\n        br = self.buildTree(grid, re - next_level, re, ce - next_level, ce, next_level)\n        \n        if tl.isLeaf and tr.isLeaf and bl.isLeaf and br.isLeaf:\n            if tl.val == tr.val == bl.val == br.val:\n                new_node = Node(tl.val, True, None, None, None, None)\n            else:\n                new_node = Node(tl.val, False, tl, tr, bl, br)\n        else:\n            new_node = Node(tl.val, False, tl, tr, bl, br)\n            \n        return new_node\n",
        "explanations": "\nChanging cs to cs+1 in Node creation for leaf will cause an 'index out of range' error.\n"
    },
    {
        "slug": "can-place-flowers",
        "description": "You have a long flowerbed in which some of the plots are planted, and some are not. However, flowers cannot be planted in adjacent plots.\nGiven an integer array flowerbed containing 0's and 1's, where 0 means empty and 1 means not empty, and an integer n, return true\u00a0if n new flowers can be planted in the flowerbed without violating the no-adjacent-flowers rule and false otherwise.",
        "examples": [
            "Input: flowerbed = [1,0,0,0,1], n = 1\nOutput: true",
            "Input: flowerbed = [1,0,0,0,1], n = 2\nOutput: false"
        ],
        "constraints": "1 <= flowerbed.length <= 2 * 104\nflowerbed[i] is 0 or 1.\nThere are no two adjacent flowers in flowerbed.\n0 <= n <= flowerbed.length",
        "release_time": 1691328348,
        "oracle_code": "class Solution:\n    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:\n        flowerbed=[0]+flowerbed+[0]\n        for i in range(1,len(flowerbed)-1):\n            if flowerbed[i]==0 and flowerbed[i+1]==0 and flowerbed[i-1]==0:flowerbed[i]=1;n-=1\n        if n<=0:return True\n        return False",
        "content": "![image.png](https://assets.leetcode.com/users/images/c82b49a3-d51e-40a4-b4b5-197596cb28f2_1691328287.5834074.png)\\n\\n\\n\\n\\n\\nPLease UPVOTE \\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:\\n        flowerbed=[0]+flowerbed+[0]\\n        for i in range(1,len(flowerbed)-1):\\n            if flowerbed[i]==0 and flowerbed[i+1]==0 and flowerbed[i-1]==0:flowerbed[i]=1;n-=1\\n        if n<=0:return True\\n        return False\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution:\n    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:\n        flowerbed=[0]+flowerbed+[0]\n        for i in range(1,len(flowerbed)):\n            if flowerbed[i]==0 and flowerbed[i+1]==0 and flowerbed[i-1]==0:flowerbed[i]=1;n-=1\n        if n<=0:return True\n        return False\n",
        "explanations": "\nThe indexing in the loop goes beyond the array length causing an IndexError.\n"
    },
    {
        "slug": "find-closest-node-to-given-two-nodes",
        "description": "You are given a directed graph of n nodes numbered from 0 to n - 1, where each node has at most one outgoing edge.\nThe graph is represented with a given 0-indexed array edges of size n, indicating that there is a directed edge from node i to node edges[i]. If there is no outgoing edge from i, then edges[i] == -1.\nYou are also given two integers node1 and node2.\nReturn the index of the node that can be reached from both node1 and node2, such that the maximum between the distance from node1 to that node, and from node2 to that node is minimized. If there are multiple answers, return the node with the smallest index, and if no possible answer exists, return -1.\nNote that edges may contain cycles.",
        "examples": [
            "Input: edges = [2,2,3,-1], node1 = 0, node2 = 1\nOutput: 2\nExplanation: The distance from node 0 to node 2 is 1, and the distance from node 1 to node 2 is 1.\nThe maximum of those two distances is 1. It can be proven that we cannot get a node with a smaller maximum distance than 1, so we return node 2.",
            "Input: edges = [1,2,-1], node1 = 0, node2 = 2\nOutput: 2\nExplanation: The distance from node 0 to node 2 is 2, and the distance from node 2 to itself is 0.\nThe maximum of those two distances is 2. It can be proven that we cannot get a node with a smaller maximum distance than 2, so we return node 2."
        ],
        "constraints": "n == edges.length\n2 <= n <= 105\n-1 <= edges[i] < n\nedges[i] != i\n0 <= node1, node2 < n",
        "release_time": 1674617837,
        "oracle_code": "class Solution:\n    def cdist(self, it, distArray, distArrayIndex, edges):\n        rdist = 0 \n        nodes = []\n        while it != -1 and distArray[it][distArrayIndex] > rdist:\n            distArray[it][distArrayIndex] = rdist\n            nodes.append(it)\n            it = edges[it]\n            rdist += 1\n        return nodes\n            \n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\n        INF = float('inf')\n        dist = defaultdict(lambda: [INF,INF])\n        mmin, ans = INF, INF\n               \n        n = self.cdist(node1, dist, 0, edges)\n        n += self.cdist(node2, dist, 1, edges)\n                \n        for k in n:\n            m = max(dist[k])\n            if m != INF:\n                if m < mmin: \n                    mmin = m\n                    ans = k\n                elif m == mmin: \n                    ans = min(ans, k)\n                    \n        return ans if ans != float('inf') else -1",
        "content": "Since there is atmost one outgoing edge with cycles, we can iterate this graph in simple manner as cdist function below. The logic briefly is as below. \\n1. Calculate distances between node1 and other reachable nodes. \\n2. Do the same as (1) for node 2\\n3. Iterate the nodes that are on the path for both distances and find max. \\n4. find min of maxes and keep track of minimum index. \\n\\nIf there was a constraint that node1 and node2 have a guarenteed path between them, the problem could have been simpler, to construct find the shortestPath between node1 -> node 2 and the ans is one of the nodes in between. Thats not the case ! \\n\\n```\\nclass Solution:\\n    def cdist(self, it, distArray, distArrayIndex, edges):\\n        rdist = 0 \\n        nodes = []\\n        while it != -1 and distArray[it][distArrayIndex] > rdist:\\n            distArray[it][distArrayIndex] = rdist\\n            nodes.append(it)\\n            it = edges[it]\\n            rdist += 1\\n        return nodes\\n            \\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        INF = float(\\'inf\\')\\n        dist = defaultdict(lambda: [INF,INF])\\n        mmin, ans = INF, INF\\n               \\n        n = self.cdist(node1, dist, 0, edges)\\n        n += self.cdist(node2, dist, 1, edges)\\n                \\n        for k in n:\\n            m = max(dist[k])\\n            if m != INF:\\n                if m < mmin: \\n                    mmin = m\\n                    ans = k\\n                elif m == mmin: \\n                    ans = min(ans, k)\\n                    \\n        return ans if ans != float(\\'inf\\') else -1\\n```\\n\\nA slightly modified logic, \\n\\n```\\nclass Solution:\\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        INF = float(\\'inf\\')\\n        N = len(edges)\\n        dist_node1 = [INF for _ in range(N)]\\n        dist_node2 = [INF for _ in range(N)]\\n        \\n        def dfs(node, di, d):\\n            if d[node] > di: \\n                d[node] = di\\n                if edges[node] != -1:\\n                    dfs(edges[node], di+1, d)\\n        \\n        dfs(node1, 0, dist_node1)\\n        dfs(node2, 0, dist_node2)\\n\\n        for i in range(N):\\n            dist_node1[i] = max(dist_node1[i], dist_node2[i])\\n                        \\n        ans = dist_node1.index(min(dist_node1))\\n        return ans if dist_node1[ans] != INF else -1\\n",
        "level": "medium",
        "buggy_code": "\nclass Solution:\n    def cdist(self, it, distArray, distArrayIndex, edges):\n        rdist = 0 \n        nodes = []\n        while it != -1 and distArray[it+1][distArrayIndex] > rdist:\n            distArray[it][distArrayIndex] = rdist\n            nodes.append(it)\n            it = edges[it]\n            rdist += 1\n        return nodes\n            \n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\n        INF = float('inf')\n        dist = defaultdict(lambda: [INF,INF])\n        mmin, ans = INF, INF\n               \n        n = self.cdist(node1, dist, 0, edges)\n        n += self.cdist(node2, dist, 1, edges)\n                \n        for k in n:\n            m = max(dist[k])\n            if m != INF:\n                if m < mmin: \n                    mmin = m\n                    ans = k\n                elif m == mmin: \n                    ans = min(ans, k)\n                    \n        return ans if ans != float('inf') else -1\n",
        "explanations": "\nThe bug is an indexing error. It tries to access an index that doesn't exist in the 'distArray' dictionary.\n"
    },
    {
        "slug": "sum-of-subarray-minimums",
        "description": "Given an array of integers arr, find the sum of min(b), where b ranges over every (contiguous) subarray of arr. Since the answer may be large, return the answer modulo 109 + 7.",
        "examples": [
            "Input: arr = [3,1,2,4]\nOutput: 17\nExplanation: \nSubarrays are [3], [1], [2], [4], [3,1], [1,2], [2,4], [3,1,2], [1,2,4], [3,1,2,4]. \nMinimums are 3, 1, 2, 4, 1, 1, 2, 1, 1, 1.\nSum is 17.",
            "Input: arr = [11,81,94,43,3]\nOutput: 444"
        ],
        "constraints": "1 <= arr.length <= 3 * 104\n1 <= arr[i] <= 3 * 104",
        "release_time": 1669419936,
        "oracle_code": "class Solution:\n    def sumSubarrayMins(self, arr: List[int]) -> int:\n        stack = []\n        res = 0\n        arr = [float('-inf')] + arr + [float('-inf')]\n        for i, num in enumerate(arr):\n            while stack and arr[stack[-1]] > num:\n                cur = stack.pop()\n                res += arr[cur] * (i - cur) * (cur - stack[-1])\n            stack.append(i)\n        return res % (10**9 + 7)",
        "content": "Maintain a stack of indexes of subarrays, \\nwhich would have the minimum number at the top of the stack.\\n \\nUse following logic to compute the sum(i):\\n- If arr[i] is small, then arr[i] is minimum for all subarrays \\nstarting at arr[i].\\n- If arr[i] is greater, then find the smallest element from the top of stack which is bigger than arr[i]. \\n- Let the index of the smallest element be on top. \\n- Now, arr[i] is minimum for all subarrays starting at arr[top+1]. \\n\\nWe already know the value of sum(top), so add sum(top) + arr[i] * (i \\u2013 top) to result. Finally, push the index of arr[i] to stack.\\n\\n# Complexity\\nTime Complexity: O(N)\\nSpace Complexity: O(N)\\n\\n# Code\\n```\\nclass Solution:\\n    def sumSubarrayMins(self, arr: List[int]) -> int:\\n        stack = []\\n        res = 0\\n        arr = [float(\\'-inf\\')] + arr + [float(\\'-inf\\')]\\n        for i, num in enumerate(arr):\\n            while stack and arr[stack[-1]] > num:\\n                cur = stack.pop()\\n                res += arr[cur] * (i - cur) * (cur - stack[-1])\\n            stack.append(i)\\n        return res % (10**9 + 7)\\n\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution:\n    def sumSubarrayMins(self, arr: List[int]) -> int:\n        stack = []\n        res = 0\n        arr = [float('-inf')] + arr + [float('-inf')]\n        for i, num in enumerate(arr):\n            while stack and arr[stack[-1]] > num:\n                cur = stack.pop()\n                res += arr[cur] * (i - cur) * (cur - stack[-2])\n            stack.append(i)\n        return res % (10**9 + 7)\n",
        "explanations": "\nIndexing error bug - stack[-2] might not exist if there's only one element in stack.\n"
    },
    {
        "slug": "binary-tree-inorder-traversal",
        "description": "Given the root of a binary tree, return the inorder traversal of its nodes' values.",
        "examples": [
            "Input: root = [1,null,2,3]\nOutput: [1,3,2]",
            "Input: root = []\nOutput: []",
            "Input: root = [1]\nOutput: [1]"
        ],
        "constraints": "The number of nodes in the tree is in the range [0, 100].\n-100 <= Node.val <= 100",
        "release_time": 1688586459,
        "oracle_code": "class Solution:\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\n        ans=[]\n        def inorder(root,ans):\n            if not root:\n                return None\n            inorder(root.left,ans)\n            ans.append(root.val)\n            inorder(root.right,ans)\n        inorder(root,ans)\n        return ans",
        "content": "# 1. Recursive Approach\\n```\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        ans=[]\\n        def inorder(root,ans):\\n            if not root:\\n                return None\\n            inorder(root.left,ans)\\n            ans.append(root.val)\\n            inorder(root.right,ans)\\n        inorder(root,ans)\\n        return ans\\n```\\n# 2. Iterative Approach\\n```\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        ans=[]\\n        stack=[]\\n        cur=root\\n        while stack or cur:\\n            if cur:\\n                stack.append(cur)\\n                cur=cur.left\\n            else:\\n                cur=stack.pop()\\n                ans.append(cur.val)\\n                cur=cur.right\\n        return ans\\n```\\n# please upvote me it would encourage me alot\\n",
        "level": "easy",
        "buggy_code": "\nclass Solution:\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\n        ans=[]\n        def inorder(root,ans):\n            if not root:\n                return None\n            inorder(root.left,ans)\n            ans.append(root.val)\n            inorder(root.right,ans)\n        inorder(root,ans)\n        return ans[1:]\n",
        "explanations": "\nThe bug removes the first element of the list ans in the return statement.\n"
    },
    {
        "slug": "number-of-ways-of-cutting-a-pizza",
        "description": "Given a rectangular pizza represented as a rows x cols\u00a0matrix containing the following characters: 'A' (an apple) and '.' (empty cell) and given the integer k. You have to cut the pizza into k pieces using k-1 cuts.\u00a0\nFor each cut you choose the direction: vertical or horizontal, then you choose a cut position at the cell boundary and cut the pizza into two pieces. If you cut the pizza vertically, give the left part of the pizza to a person. If you cut the pizza horizontally, give the upper part of the pizza to a person. Give the last piece of pizza to the last person.\nReturn the number of ways of cutting the pizza such that each piece contains at least one apple.\u00a0Since the answer can be a huge number, return this modulo 10^9 + 7.",
        "examples": [
            "Input: pizza = [\"A..\",\"AAA\",\"...\"], k = 3\nOutput: 3 \nExplanation: The figure above shows the three ways to cut the pizza. Note that pieces must contain at least one apple.",
            "Input: pizza = [\"A..\",\"AA.\",\"...\"], k = 3\nOutput: 1",
            "Input: pizza = [\"A..\",\"A..\",\"...\"], k = 1\nOutput: 1"
        ],
        "constraints": "1 <= rows, cols <= 50\nrows ==\u00a0pizza.length\ncols ==\u00a0pizza[i].length\n1 <= k <= 10\npizza consists of characters 'A'\u00a0and '.' only.",
        "release_time": 1680234826,
        "oracle_code": "class Solution:\n    def ways(self, pizza: List[str], k: int) -> int:\n        self.r = len(pizza)\n        self.c = len(pizza[0])\n        \n        # Step 1, pre-process the apple array and get the prefix sum\n        tot_apples = 0\n        self.pfsum_row = []\n        self.pfsum_col = []\n        \n        for i in range(self.r):\n            pfr = 0\n            pfs_r = [0] * self.c\n            pfs_c = [0] * self.c\n            for j in range(self.c):\n                if i > 0:\n                    pfs_c[j] += self.pfsum_col[i - 1][j]\n                if pizza[i][j] == 'A':\n                    pfr += 1\n                    pfs_c[j] += 1\n                    tot_apples += 1\n                pfs_r[j] = pfr\n            self.pfsum_row.append(pfs_r)\n            self.pfsum_col.append(pfs_c)\n        \n        if tot_apples < k:\n            return 0\n        \n        if k == 1:\n            return 1\n        \n        return self.getWays(0, 0, k) % (1000000007)\n    \n    \n    @cache\n    def getWays(self, i, j, k):\n        if k == 1:\n            # if only left one piece for cutting, we just need to check if there is any apple in the region\n            found = False\n            for c in range(j, self.c):\n                apple_in_region = self.pfsum_col[self.r - 1][c]\n                if i > 0:\n                     apple_in_region -= self.pfsum_col[i - 1][c]\n                if apple_in_region:\n                    found = True\n                    break\n            if found:\n                return 1\n            return 0\n        else:\n            # horizontally cut\n            cannot_cut = True\n            nr = i\n            t_cnt = 0\n            while nr < self.r - 1:\n                # find the first row that we can start cutting\n                while nr < self.r - 1 and cannot_cut:\n                    apple_in_region = self.pfsum_row[nr][self.c - 1]\n                    if j > 0:\n                        apple_in_region -= self.pfsum_row[nr][j - 1]\n                    if apple_in_region:\n                        cannot_cut = False\n                    else:\n                        nr += 1\n                        \n                if nr < self.r - 1:\n                    t_cnt += self.getWays(nr + 1, j, k - 1)\n                nr += 1\n                \n            # vertically cut\n            cannot_cut = True\n            nc = j\n            while nc < self.c - 1:\n                # find the first col that we can start cutting\n                while nc < self. c - 1 and cannot_cut:\n                    apple_in_region = self.pfsum_col[self.r - 1][nc]\n                    if i > 0:\n                        apple_in_region -= self.pfsum_col[i - 1][nc]\n                    if apple_in_region:\n                        cannot_cut = False\n                    else:\n                        nc += 1\n                \n                if nc < self.c - 1:\n                    t_cnt += self.getWays(i, nc + 1, k - 1)\n                nc += 1\n            \n            return t_cnt",
        "content": "The key to this problem is how to count the number of apples on the region we want to cut.\\n\\nWe can simply use the prefix sum that help to identify the number of apples between any two index.\\n\\nTherefore, we need to pre-process the input array, get the prefix sum horizatonally and vertically.\\n\\nWith the prefix sum array, we can create a dp funtion that get the number of cuts in the region (i, j) to (row - 1, col - 1)\\n\\n\\n```\\nclass Solution:\\n    def ways(self, pizza: List[str], k: int) -> int:\\n        self.r = len(pizza)\\n        self.c = len(pizza[0])\\n        \\n        # Step 1, pre-process the apple array and get the prefix sum\\n        tot_apples = 0\\n        self.pfsum_row = []\\n        self.pfsum_col = []\\n        \\n        for i in range(self.r):\\n            pfr = 0\\n            pfs_r = [0] * self.c\\n            pfs_c = [0] * self.c\\n            for j in range(self.c):\\n                if i > 0:\\n                    pfs_c[j] += self.pfsum_col[i - 1][j]\\n                if pizza[i][j] == \\'A\\':\\n                    pfr += 1\\n                    pfs_c[j] += 1\\n                    tot_apples += 1\\n                pfs_r[j] = pfr\\n            self.pfsum_row.append(pfs_r)\\n            self.pfsum_col.append(pfs_c)\\n        \\n        if tot_apples < k:\\n            return 0\\n        \\n        if k == 1:\\n            return 1\\n        \\n        return self.getWays(0, 0, k) % (1000000007)\\n    \\n    \\n    @cache\\n    def getWays(self, i, j, k):\\n        if k == 1:\\n            # if only left one piece for cutting, we just need to check if there is any apple in the region\\n            found = False\\n            for c in range(j, self.c):\\n                apple_in_region = self.pfsum_col[self.r - 1][c]\\n                if i > 0:\\n                     apple_in_region -= self.pfsum_col[i - 1][c]\\n                if apple_in_region:\\n                    found = True\\n                    break\\n            if found:\\n                return 1\\n            return 0\\n        else:\\n            # horizontally cut\\n            cannot_cut = True\\n            nr = i\\n            t_cnt = 0\\n            while nr < self.r - 1:\\n                # find the first row that we can start cutting\\n                while nr < self.r - 1 and cannot_cut:\\n                    apple_in_region = self.pfsum_row[nr][self.c - 1]\\n                    if j > 0:\\n                        apple_in_region -= self.pfsum_row[nr][j - 1]\\n                    if apple_in_region:\\n                        cannot_cut = False\\n                    else:\\n                        nr += 1\\n                        \\n                if nr < self.r - 1:\\n                    t_cnt += self.getWays(nr + 1, j, k - 1)\\n                nr += 1\\n                \\n            # vertically cut\\n            cannot_cut = True\\n            nc = j\\n            while nc < self.c - 1:\\n                # find the first col that we can start cutting\\n                while nc < self. c - 1 and cannot_cut:\\n                    apple_in_region = self.pfsum_col[self.r - 1][nc]\\n                    if i > 0:\\n                        apple_in_region -= self.pfsum_col[i - 1][nc]\\n                    if apple_in_region:\\n                        cannot_cut = False\\n                    else:\\n                        nc += 1\\n                \\n                if nc < self.c - 1:\\n                    t_cnt += self.getWays(i, nc + 1, k - 1)\\n                nc += 1\\n            \\n            return t_cnt\\n\\n```",
        "level": "hard",
        "buggy_code": "\nclass Solution:\n    def ways(self, pizza: List[str], k: int) -> int:\n        self.r = len(pizza)\n        self.c = len(pizza[0])\n        \n        # Step 1, pre-process the apple array and get the prefix sum\n        tot_apples = 0\n        self.pfsum_row = []\n        self.pfsum_col = []\n        \n        for i in range(self.r):\n            pfr = 0\n            pfs_r = [0] * self.c\n            pfs_c = [0] * self.c\n            for j in range(self.c):\n                if i > 0:\n                    pfs_c[j] += self.pfsum_col[i - 1][j]\n                if pizza[i][j] == 'A':\n                    pfr += 1\n                    pfs_c[j] += 1\n                    tot_apples += 1\n                pfs_r[j] = pfr\n            self.pfsum_row.append(pfs_r)\n            self.pfsum_col.append(pfs_c)\n        \n        if tot_apples < k:\n            return 0\n        \n        if k == 1:\n            return 1\n        \n        return self.getWays(0, 0, k - 2) % (1000000007)\n    \n    \n    @cache\n    def getWays(self, i, j, k):\n        if k == 1:\n            # if only left one piece for cutting, we just need to check if there is any apple in the region\n            found = False\n            for c in range(j, self.c):\n                apple_in_region = self.pfsum_col[self.r - 1][c]\n                if i > 0:\n                     apple_in_region -= self.pfsum_col[i - 1][c]\n                if apple_in_region:\n                    found = True\n                    break\n            if found:\n                return 1\n            return 0\n        else:\n            # horizontally cut\n            cannot_cut = True\n            nr = i\n            t_cnt = 0\n            while nr < self.r - 1:\n                # find the first row that we can start cutting\n                while nr < self.r - 1 and cannot_cut:\n                    apple_in_region = self.pfsum_row[nr][self.c - 1]\n                    if j > 0:\n                        apple_in_region -= self.pfsum_row[nr][j - 1]\n                    if apple_in_region:\n                        cannot_cut = False\n                    else:\n                        nr += 1\n                        \n                if nr < self.r - 1:\n                    t_cnt += self.getWays(nr + 1, j, k - 1)\n                nr += 1\n                \n            # vertically cut\n            cannot_cut = True\n            nc = j\n            while nc < self.c - 1:\n                # find the first col that we can start cutting\n                while nc < self. c - 1 and cannot_cut:\n                    apple_in_region = self.pfsum_col[self.r - 1][nc]\n                    if i > 0:\n                        apple_in_region -= self.pfsum_col[i - 1][nc]\n                    if apple_in_region:\n                        cannot_cut = False\n                    else:\n                        nc += 1\n                \n                if nc < self.c - 1:\n                    t_cnt += self.getWays(i, nc + 1, k - 1)\n                nc += 1\n            \n            return t_cnt\n",
        "explanations": "\nThe bug in the code lies in the recursive method calling by subtracting 2, k-2, instead of 1, k-1, at the line \"return self.getWays(0, 0, k - 2) % (1000000007)\". This works as an unresolvable index error as we are skipping steps in recursion and eventually leads to incorrect computations.\n"
    }
]