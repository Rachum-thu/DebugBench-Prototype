[
    {
        "slug": "relative-ranks",
        "description": "You are given an integer array score of size n, where score[i] is the score of the ith athlete in a competition. All the scores are guaranteed to be unique.\nThe athletes are placed based on their scores, where the 1st place athlete has the highest score, the 2nd place athlete has the 2nd highest score, and so on. The placement of each athlete determines their rank:\n\nThe 1st place athlete's rank is \"Gold Medal\".\nThe 2nd place athlete's rank is \"Silver Medal\".\nThe 3rd place athlete's rank is \"Bronze Medal\".\nFor the 4th place to the nth place athlete, their rank is their placement number (i.e., the xth place athlete's rank is \"x\").\n\nReturn an array answer of size n where answer[i] is the rank of the ith athlete.",
        "examples": [
            "Input: score = [5,4,3,2,1]\nOutput: [\"Gold Medal\",\"Silver Medal\",\"Bronze Medal\",\"4\",\"5\"]\nExplanation: The placements are [1st, 2nd, 3rd, 4th, 5th].",
            "Input: score = [10,3,8,9,4]\nOutput: [\"Gold Medal\",\"5\",\"Bronze Medal\",\"Silver Medal\",\"4\"]\nExplanation: The placements are [1st, 5th, 3rd, 2nd, 4th]."
        ],
        "constraints": "n == score.length\n1 <= n <= 104\n0 <= score[i] <= 106\nAll the values in score are unique.",
        "oracle_code": "class Solution {\n    public String[] findRelativeRanks(int[] score) {\n         int n=score.length;\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[b]-score[a]);\n        for(int i=0;i<n;i++) pq.add(i);\n      String[] ans = new String[n];\n                int i=1;\n        while(!pq.isEmpty()){\n            int idx=pq.poll();\n         if(i==1)   { ans[idx]=\"Gold Medal\"; i++;}\n         else if(i==2)   { ans[idx]=\"Silver Medal\"; i++;}\n         else if(i==3)   { ans[idx]=\"Bronze Medal\"; i++;}\n         else ans[idx]=Integer.toString(i++);\n        }\n        return ans;  \n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String[] findRelativeRanks(int[] score) {\\n         int n=score.length;\\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[b]-score[a]);\\n        for(int i=0;i<n;i++) pq.add(i);\\n      String[] ans = new String[n];\\n                int i=1;\\n        while(!pq.isEmpty()){\\n            int idx=pq.poll();\\n         if(i==1)   { ans[idx]=\"Gold Medal\"; i++;}\\n         else if(i==2)   { ans[idx]=\"Silver Medal\"; i++;}\\n         else if(i==3)   { ans[idx]=\"Bronze Medal\"; i++;}\\n         else ans[idx]=Integer.toString(i++);\\n        }\\n        return ans;  \\n    }\\n}\\n```",
        "level": "easy",
        "type": [
            "undefined objects",
            "undefined keywords from other languages",
            "unclosed string",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\n    public String[] findRelativeRanks(int[] score) {\n         int n=score.length;\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[b]-score[a]);\n        for(int i=0;i<n;i++) pq.add(i);\n      String[] ans = null;\n                int i=1;\n        while(!pq.isEmpty()){\n            int idx=pq.poll();\n         if(i==1)   { ans[idx]=\"Gold Medal; i++;}\n         elif(i==2)   { ans[idx]=\"Silver Medal; i++;}\n         else if(i==3)   { ans[idx]=\"Bronze Medal; i++;}\n         else ans[idx]=Integer.toString(i++);\n        }\n        return reorderArray(ans);  \n    }\n\n    private String[] reorderArray(String[] ranks){\n        \n    }\n}\n"
    },
    {
        "slug": "intersection-of-multiple-arrays",
        "description": "Given a 2D integer array nums where nums[i] is a non-empty array of distinct positive integers, return the list of integers that are present in each array of nums sorted in ascending order.",
        "examples": [
            "Input: nums = [[3,1,2,4,5],[1,2,3,4],[3,4,5,6]]\nOutput: [3,4]\nExplanation: \nThe only integers present in each of nums[0] = [3,1,2,4,5], nums[1] = [1,2,3,4], and nums[2] = [3,4,5,6] are 3 and 4, so we return [3,4].",
            "Input: nums = [[1,2,3],[4,5,6]]\nOutput: []\nExplanation: \nThere does not exist any integer present both in nums[0] and nums[1], so we return an empty list []."
        ],
        "constraints": "1 <= nums.length <= 1000\n1 <= sum(nums[i].length) <= 1000\n1 <= nums[i][j] <= 1000\nAll the values of nums[i] are unique.",
        "oracle_code": "class Solution {\n    public List<Integer> intersection(int[][] nums) {\n        \n        List<Integer> ans = new ArrayList<>();\n        \n        int[] count  = new int[1001];\n        \n        for(int[] arr : nums){\n            for(int i : arr){\n                count[i]++;\n            }\n        }\n        \n       for(int i=0;i<count.length;i++){\n           if(count[i]==nums.length){\n               ans.add(i);\n           }\n       }\n        \n        return ans;\n    }\n}",
        "content": "```\\n\\nclass Solution {\\n    public List<Integer> intersection(int[][] nums) {\\n        \\n        List<Integer> ans = new ArrayList<>();\\n        \\n        int[] count  = new int[1001];\\n        \\n        for(int[] arr : nums){\\n            for(int i : arr){\\n                count[i]++;\\n            }\\n        }\\n        \\n       for(int i=0;i<count.length;i++){\\n           if(count[i]==nums.length){\\n               ans.add(i);\\n           }\\n       }\\n        \\n        return ans;\\n    }\\n}\\n\\n```",
        "level": "easy",
        "type": [
            "== and = confusion",
            "colon missing",
            "wrong comment mark",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution {\n    public List<Integer> intersection(int[][] nums) {\n        \n        List<Integer> ans = new ArrayList<>();\n        \n        int[] count  = new int[1001]\n        \n        i=0; i<=nums.length; i++){\n            fo(int j[i]){\n                count[j]++;\n            }\n        }\n        \n        for(int i=0;i<count.length;i++){\n           if(count[i]=nums.length){\n               ans.add(i);\n           }\n        }\n        \n        return ans;\n    }\n}\n"
    },
    {
        "slug": "goat-latin",
        "description": "You are given a string sentence that consist of words separated by spaces. Each word consists of lowercase and uppercase letters only.\nWe would like to convert the sentence to \"Goat Latin\" (a made-up language similar to Pig Latin.) The rules of Goat Latin are as follows:\n\nIf a word begins with a vowel ('a', 'e', 'i', 'o', or 'u'), append \"ma\" to the end of the word.\n\n\t\nFor example, the word \"apple\" becomes \"applema\".\n\n\nIf a word begins with a consonant (i.e., not a vowel), remove the first letter and append it to the end, then add \"ma\".\n\t\nFor example, the word \"goat\" becomes \"oatgma\".\n\n\nAdd one letter 'a' to the end of each word per its word index in the sentence, starting with 1.\n\t\nFor example, the first word gets \"a\" added to the end, the second word gets \"aa\" added to the end, and so on.\n\n\n\nReturn the final sentence representing the conversion from sentence to Goat Latin.",
        "examples": [
            "Input: sentence = \"I speak Goat Latin\"\nOutput: \"Imaa peaksmaaa oatGmaaaa atinLmaaaaa\"",
            "Input: sentence = \"The quick brown fox jumped over the lazy dog\"\nOutput: \"heTmaa uickqmaaa rownbmaaaa oxfmaaaaa umpedjmaaaaaa overmaaaaaaa hetmaaaaaaaa azylmaaaaaaaaa ogdmaaaaaaaaaa\""
        ],
        "constraints": "1 <= sentence.length <= 150\nsentence consists of English letters and spaces.\nsentence has no leading or trailing spaces.\nAll the words in sentence are separated by a single space.",
        "oracle_code": "class Solution {\n    public String toGoatLatin(String sentence) {\n        sentence.toLowerCase();\n        String[] words=sentence.split(\" \",0);\n        int i=1;\n        String ans=\"\";\n        for(String word:words){\n           \n            char p1=word.charAt(0);\n            char p=word.toLowerCase().charAt(0);\n            String k=\"\";\n            if(p=='a'||p=='i'||p=='o'||p=='e'||p=='u'){\n                k+=word+\"ma\";\n            }\n            else{\n                k+=word.substring(1,word.length());\n                k+=p1;\n                k+=\"ma\";\n            }\n            for(int m=0;m<i;m++){\n               k+='a';\n            }\n            ans+=k;\n            if(i!=words.length)ans+=\" \";\n            i++;\n        }\n        return ans;\n    }\n}",
        "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public String toGoatLatin(String sentence) {\\n        sentence.toLowerCase();\\n        String[] words=sentence.split(\" \",0);\\n        int i=1;\\n        String ans=\"\";\\n        for(String word:words){\\n           \\n            char p1=word.charAt(0);\\n            char p=word.toLowerCase().charAt(0);\\n            String k=\"\";\\n            if(p==\\'a\\'||p==\\'i\\'||p==\\'o\\'||p==\\'e\\'||p==\\'u\\'){\\n                k+=word+\"ma\";\\n            }\\n            else{\\n                k+=word.substring(1,word.length());\\n                k+=p1;\\n                k+=\"ma\";\\n            }\\n            for(int m=0;m<i;m++){\\n               k+=\\'a\\';\\n            }\\n            ans+=k;\\n            if(i!=words.length)ans+=\" \";\\n            i++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
        "level": "easy",
        "type": [
            "== and = confusion",
            "indexing error",
            "unclosed string",
            "statement separation"
        ],
        "buggy_code": "\nclass Solution {\n    public String toGoatLatin(String sentence) {\n        sentence.toLowerCase()\n        String[] words=sentence.split(\" \",0);\n        int i=1;\n        String ans=\";\n        for(String word:words){\n           \n            char p1=word.charAt(word.length());\n            char p=word.toLowerCase().charAt(0);\n            String k=\"\";\n            if(p=='a'||p=='i'||p=='o'||p=='e'||p=='u'){\n                k+=word+\"ma\";\n            }\n            else{\n                k+=word.substring(1,word.length());\n                k+=p1;\n                k+=\"ma\";\n            }\n            for(int m=0;m<i;m++){\n               k+='a';\n            }\n            ans+=k;\n            if(i==words.length)ans+=\" \";\n            i++;\n        }\n        return ans;\n    }\n}\n"
    },
    {
        "slug": "rotating-the-box",
        "description": "You are given an m x n matrix of characters box representing a side-view of a box. Each cell of the box is one of the following:\n\nA stone '#'\nA stationary obstacle '*'\nEmpty '.'\n\nThe box is rotated 90 degrees clockwise, causing some of the stones to fall due to gravity. Each stone falls down until it lands on an obstacle, another stone, or the bottom of the box. Gravity does not affect the obstacles' positions, and the inertia from the box's rotation does not affect the stones' horizontal positions.\nIt is guaranteed that each stone in box rests on an obstacle, another stone, or the bottom of the box.\nReturn an n x m matrix representing the box after the rotation described above.",
        "examples": [
            "Input: box = [[\"#\",\".\",\"#\"]]\r\nOutput: [[\".\"],\r\n\u00a0        [\"#\"],\r\n\u00a0        [\"#\"]]",
            "Input: box = [[\"#\",\".\",\"*\",\".\"],\r\n\u00a0             [\"#\",\"#\",\"*\",\".\"]]\r\nOutput: [[\"#\",\".\"],\r\n\u00a0        [\"#\",\"#\"],\r\n\u00a0        [\"*\",\"*\"],\r\n\u00a0        [\".\",\".\"]]",
            "Input: box = [[\"#\",\"#\",\"*\",\".\",\"*\",\".\"],\r\n\u00a0             [\"#\",\"#\",\"#\",\"*\",\".\",\".\"],\r\n\u00a0             [\"#\",\"#\",\"#\",\".\",\"#\",\".\"]]\r\nOutput: [[\".\",\"#\",\"#\"],\r\n\u00a0        [\".\",\"#\",\"#\"],\r\n\u00a0        [\"#\",\"#\",\"*\"],\r\n\u00a0        [\"#\",\"*\",\".\"],\r\n\u00a0        [\"#\",\".\",\"*\"],\r\n\u00a0        [\"#\",\".\",\".\"]]"
        ],
        "constraints": "m == box.length\nn == box[i].length\n1 <= m, n <= 500\nbox[i][j] is either '#', '*', or '.'.",
        "oracle_code": "// O(n^2) time | O(n^2) space\nclass Solution {\n    public char[][] rotateTheBox(char[][] box) {\n        int m = box.length;\n        int n = box[0].length;\n        char[][] matrix = new char[n][m];   \n        \n        turnBox(box, matrix, m, n); // turn the box clockwise 90 degree\n        \n        turnGravity(matrix, n, m); // cause that falling effect, since matrix turned so n,m\n        \n        return matrix;\n    }\n    \n    public void turnGravity(char[][] matrix, int m, int n){\n        for(int c = 0; c < n; c++){\n            int last  = m-1;\n            for(int r = m-1; r >= 0; r--){\n                char val =  matrix[r][c];\n                if(val == '.') continue;\n                if(val == '*') last = r-1;\n                if(val == '#') {\n                    matrix[r][c] = '.';\n                    matrix[last][c] = '#';\n                    last--;\n                }\n            }\n        }\n    }\n    \n    public void turnBox(char[][] box, char[][] matrix, int m, int n){\n\t// numbers represents sequence it would be copied\n\t//[4][1]\n\t//[5][2]\n\t//[6][3]\n        for(int i = 0, c = m-1; i < m; i++,c--){ // c: 4,3,2,1..\n            for(int j = 0, r = 0; j < n; j++, r++){ // r:0,1,2,3..\n               matrix[r][c] = box[i][j];\n            }\n        }\n    }\n}",
        "content": "**So idea here is**\\n1. First turn 90 degree\\n2. Make things fall\\n\\n```\\n// O(n^2) time | O(n^2) space\\nclass Solution {\\n    public char[][] rotateTheBox(char[][] box) {\\n        int m = box.length;\\n        int n = box[0].length;\\n        char[][] matrix = new char[n][m];   \\n        \\n        turnBox(box, matrix, m, n); // turn the box clockwise 90 degree\\n        \\n        turnGravity(matrix, n, m); // cause that falling effect, since matrix turned so n,m\\n        \\n        return matrix;\\n    }\\n    \\n    public void turnGravity(char[][] matrix, int m, int n){\\n        for(int c = 0; c < n; c++){\\n            int last  = m-1;\\n            for(int r = m-1; r >= 0; r--){\\n                char val =  matrix[r][c];\\n                if(val == \\'.\\') continue;\\n                if(val == \\'*\\') last = r-1;\\n                if(val == \\'#\\') {\\n                    matrix[r][c] = \\'.\\';\\n                    matrix[last][c] = \\'#\\';\\n                    last--;\\n                }\\n            }\\n        }\\n    }\\n    \\n    public void turnBox(char[][] box, char[][] matrix, int m, int n){\\n\\t// numbers represents sequence it would be copied\\n\\t//[4][1]\\n\\t//[5][2]\\n\\t//[6][3]\\n        for(int i = 0, c = m-1; i < m; i++,c--){ // c: 4,3,2,1..\\n            for(int j = 0, r = 0; j < n; j++, r++){ // r:0,1,2,3..\\n               matrix[r][c] = box[i][j];\\n            }\\n        }\\n    }\\n}\\n```",
        "level": "medium",
        "type": [
            "colon missing",
            "other error",
            "indexing error",
            "unclosed string"
        ],
        "buggy_code": "\n// O(n^2) time | O(n^2) space\nclass Solution {\n    public char[][] rotateTheBox(char[][] box) {\n        int m = box.length;\n        int n = box[0].length + 1; \n        char[][] matrix = new char[n][m]   \n        \n        turnBox(box, matrix, m, n); // turn the box clockwise 90 degree\n        \n        turnGravity(matrix, n, m); // cause that falling effect, since matrix turned so n,m\n        \n        return matrix;\n    }\n    \n    public void turnGravity(char[][] matrix, int m, int n){\n        for(int c = 0; c < n; c++){\n            int last  = m-1;\n            for(int r = m-1; r >= 0; r--){\n                char val =  matrix[r][c];\n                if(val == '.') continue;\n                if(val == '*') last = r-1;\n                if(val == '#') {\n                    matrix[r][c] = '.';\n                    matrix[last][c] = '#;\n                }\n            }\n        }\n    }\n    \n    public void turnBox(char[][] box, char[][] matrix, int m, int n){\n              for(int i = 0, c = m-1; i < m; i++,c--){            \n            for(int j = 0, r = 0; j < n; j++, r++){\n               matrix[r][1] = box[i][j];\n            }\n        }\n    }\n}\n"
    },
    {
        "slug": "relative-ranks",
        "description": "You are given an integer array score of size n, where score[i] is the score of the ith athlete in a competition. All the scores are guaranteed to be unique.\nThe athletes are placed based on their scores, where the 1st place athlete has the highest score, the 2nd place athlete has the 2nd highest score, and so on. The placement of each athlete determines their rank:\n\nThe 1st place athlete's rank is \"Gold Medal\".\nThe 2nd place athlete's rank is \"Silver Medal\".\nThe 3rd place athlete's rank is \"Bronze Medal\".\nFor the 4th place to the nth place athlete, their rank is their placement number (i.e., the xth place athlete's rank is \"x\").\n\nReturn an array answer of size n where answer[i] is the rank of the ith athlete.",
        "examples": [
            "Input: score = [5,4,3,2,1]\nOutput: [\"Gold Medal\",\"Silver Medal\",\"Bronze Medal\",\"4\",\"5\"]\nExplanation: The placements are [1st, 2nd, 3rd, 4th, 5th].",
            "Input: score = [10,3,8,9,4]\nOutput: [\"Gold Medal\",\"5\",\"Bronze Medal\",\"Silver Medal\",\"4\"]\nExplanation: The placements are [1st, 5th, 3rd, 2nd, 4th]."
        ],
        "constraints": "n == score.length\n1 <= n <= 104\n0 <= score[i] <= 106\nAll the values in score are unique.",
        "oracle_code": "class Solution {\n    public String[] findRelativeRanks(int[] score) {\n         int n=score.length;\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[b]-score[a]);\n        for(int i=0;i<n;i++) pq.add(i);\n      String[] ans = new String[n];\n                int i=1;\n        while(!pq.isEmpty()){\n            int idx=pq.poll();\n         if(i==1)   { ans[idx]=\"Gold Medal\"; i++;}\n         else if(i==2)   { ans[idx]=\"Silver Medal\"; i++;}\n         else if(i==3)   { ans[idx]=\"Bronze Medal\"; i++;}\n         else ans[idx]=Integer.toString(i++);\n        }\n        return ans;  \n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String[] findRelativeRanks(int[] score) {\\n         int n=score.length;\\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[b]-score[a]);\\n        for(int i=0;i<n;i++) pq.add(i);\\n      String[] ans = new String[n];\\n                int i=1;\\n        while(!pq.isEmpty()){\\n            int idx=pq.poll();\\n         if(i==1)   { ans[idx]=\"Gold Medal\"; i++;}\\n         else if(i==2)   { ans[idx]=\"Silver Medal\"; i++;}\\n         else if(i==3)   { ans[idx]=\"Bronze Medal\"; i++;}\\n         else ans[idx]=Integer.toString(i++);\\n        }\\n        return ans;  \\n    }\\n}\\n```",
        "level": "easy",
        "type": [
            "parentheses mismatch",
            "undefined objects",
            "undefined keywords from other languages",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\n    public String[] findRelativeRanks(int[] score) {\n         int n=score.length;\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[b]-score[a]);\n        for(int i=0;i<n;i++) pq.add(i);\n      String[] ans = null;\n                int i=1;\n        while(!pq.isEmpty()){\n            int idx=pq.poll();\n         if(i=1)   { ans[idx]=\"Gold Medal\"; i++;}\n         elif(i=2)   { ans[idx]=\"Silver Medal\"; i++;}\n         else if(i=3)   { ans[idx]=\"Bronze Medal\"; i++;}\n         else ans[idx]=Integer.toString(i++);\n        }\n        return reorderArray(ans);  \n    }\n\n    private String[] reorderArray(String[] ranks){\n        \n    }\n}\n"
    },
    {
        "slug": "relative-ranks",
        "description": "You are given an integer array score of size n, where score[i] is the score of the ith athlete in a competition. All the scores are guaranteed to be unique.\nThe athletes are placed based on their scores, where the 1st place athlete has the highest score, the 2nd place athlete has the 2nd highest score, and so on. The placement of each athlete determines their rank:\n\nThe 1st place athlete's rank is \"Gold Medal\".\nThe 2nd place athlete's rank is \"Silver Medal\".\nThe 3rd place athlete's rank is \"Bronze Medal\".\nFor the 4th place to the nth place athlete, their rank is their placement number (i.e., the xth place athlete's rank is \"x\").\n\nReturn an array answer of size n where answer[i] is the rank of the ith athlete.",
        "examples": [
            "Input: score = [5,4,3,2,1]\nOutput: [\"Gold Medal\",\"Silver Medal\",\"Bronze Medal\",\"4\",\"5\"]\nExplanation: The placements are [1st, 2nd, 3rd, 4th, 5th].",
            "Input: score = [10,3,8,9,4]\nOutput: [\"Gold Medal\",\"5\",\"Bronze Medal\",\"Silver Medal\",\"4\"]\nExplanation: The placements are [1st, 5th, 3rd, 2nd, 4th]."
        ],
        "constraints": "n == score.length\n1 <= n <= 104\n0 <= score[i] <= 106\nAll the values in score are unique.",
        "oracle_code": "class Solution {\n    public String[] findRelativeRanks(int[] score) {\n         int n=score.length;\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[b]-score[a]);\n        for(int i=0;i<n;i++) pq.add(i);\n      String[] ans = new String[n];\n                int i=1;\n        while(!pq.isEmpty()){\n            int idx=pq.poll();\n         if(i==1)   { ans[idx]=\"Gold Medal\"; i++;}\n         else if(i==2)   { ans[idx]=\"Silver Medal\"; i++;}\n         else if(i==3)   { ans[idx]=\"Bronze Medal\"; i++;}\n         else ans[idx]=Integer.toString(i++);\n        }\n        return ans;  \n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String[] findRelativeRanks(int[] score) {\\n         int n=score.length;\\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[b]-score[a]);\\n        for(int i=0;i<n;i++) pq.add(i);\\n      String[] ans = new String[n];\\n                int i=1;\\n        while(!pq.isEmpty()){\\n            int idx=pq.poll();\\n         if(i==1)   { ans[idx]=\"Gold Medal\"; i++;}\\n         else if(i==2)   { ans[idx]=\"Silver Medal\"; i++;}\\n         else if(i==3)   { ans[idx]=\"Bronze Medal\"; i++;}\\n         else ans[idx]=Integer.toString(i++);\\n        }\\n        return ans;  \\n    }\\n}\\n```",
        "level": "easy",
        "type": [
            "operation error",
            "== and = confusion",
            "parentheses mismatch",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution {\n    public String[] findRelativeRanks(int[] score) {\n         int n = score.length;\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[a]-score[b]);\n        for(int i=0;i<n;i++) pq.add(i);\n          String[] ans = new String[n];\n        int i=1;\n        while(!pq.isEmpty()){\n            int idx=pq.poll();\n            if(i=1) { ans[idx]=\"Gold Medal; i++;} \n            else if(i=2) { ans[idx]=\"Silver Medal; i++;} \n            else if(i=3) { ans[idx]=\"Bronze Medal; i++;} \n            else ans[idx]=Integer.toString(i++);\n        }\n        return ans;  \n    }\n}\n"
    },
    {
        "slug": "number-of-laser-beams-in-a-bank",
        "description": "Anti-theft security devices are activated inside a bank. You are given a 0-indexed binary string array bank representing the floor plan of the bank, which is an m x n 2D matrix. bank[i] represents the ith row, consisting of '0's and '1's. '0' means the cell is empty, while'1' means the cell has a security device.\nThere is one laser beam between any two security devices if both conditions are met:\n\nThe two devices are located on two different rows: r1 and r2, where r1 < r2.\nFor each row i where r1 < i < r2, there are no security devices in the ith row.\n\nLaser beams are independent, i.e., one beam does not interfere nor join with another.\nReturn the total number of laser beams in the bank.",
        "examples": [
            "Input: bank = [\"011001\",\"000000\",\"010100\",\"001000\"]\nOutput: 8\nExplanation: Between each of the following device pairs, there is one beam. In total, there are 8 beams:\n * bank[0][1] -- bank[2][1]\n * bank[0][1] -- bank[2][3]\n * bank[0][2] -- bank[2][1]\n * bank[0][2] -- bank[2][3]\n * bank[0][5] -- bank[2][1]\n * bank[0][5] -- bank[2][3]\n * bank[2][1] -- bank[3][2]\n * bank[2][3] -- bank[3][2]\nNote that there is no beam between any device on the 0th row with any on the 3rd row.\nThis is because the 2nd row contains security devices, which breaks the second condition.",
            "Input: bank = [\"000\",\"111\",\"000\"]\nOutput: 0\nExplanation: There does not exist two devices located on two different rows."
        ],
        "constraints": "m == bank.length\nn == bank[i].length\n1 <= m, n <= 500\nbank[i][j] is either '0' or '1'.",
        "oracle_code": "class Solution {\n    public int numberOfBeams(String[] bank) {\n        int prevLazer =0;\n        int ans =0;\n        for(String s:bank){\n            int curLazer = 0;\n            for(char c: s.toCharArray()){\n                if(c=='1'){\n                    curLazer++;\n                }\n            }\n            if(curLazer >0){\n                ans += (curLazer * prevLazer);\n                prevLazer = curLazer;\n            }\n        }\n        return ans;\n    }\n}",
        "content": "\\n# java Code\\n```\\nclass Solution {\\n    public int numberOfBeams(String[] bank) {\\n        int prevLazer =0;\\n        int ans =0;\\n        for(String s:bank){\\n            int curLazer = 0;\\n            for(char c: s.toCharArray()){\\n                if(c==\\'1\\'){\\n                    curLazer++;\\n                }\\n            }\\n            if(curLazer >0){\\n                ans += (curLazer * prevLazer);\\n                prevLazer = curLazer;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
        "level": "medium",
        "type": [
            "variable value error",
            "== and = confusion",
            "parentheses mismatch",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution {\n    public int numberOfBeams(String[] bank) {\n        int prevLazer =0;\n        int ans =0;\n        for(String s:bank){\n            int curLazer = 0;\n            for(char c: s.toCharArray()){\n                if(c=='1){\n                    curLazer++;\n                }\n            if(curLazer = 0){\n                ans += (curLazer * prevLazer);\n                prevLazer = curLazer;\n            } else {\n                prevLazer = 0;\n            }\n        }\n        return \"The total number of beams is: \" + ans;\n    }\n}\n"
    },
    {
        "slug": "count-common-words-with-one-occurrence",
        "description": "Given two string arrays words1 and words2, return the number of strings that appear exactly once in each\u00a0of the two arrays.",
        "examples": [
            "Input: words1 = [\"leetcode\",\"is\",\"amazing\",\"as\",\"is\"], words2 = [\"amazing\",\"leetcode\",\"is\"]\nOutput: 2\nExplanation:\n- \"leetcode\" appears exactly once in each of the two arrays. We count this string.\n- \"amazing\" appears exactly once in each of the two arrays. We count this string.\n- \"is\" appears in each of the two arrays, but there are 2 occurrences of it in words1. We do not count this string.\n- \"as\" appears once in words1, but does not appear in words2. We do not count this string.\nThus, there are 2 strings that appear exactly once in each of the two arrays.",
            "Input: words1 = [\"b\",\"bb\",\"bbb\"], words2 = [\"a\",\"aa\",\"aaa\"]\nOutput: 0\nExplanation: There are no strings that appear in each of the two arrays.",
            "Input: words1 = [\"a\",\"ab\"], words2 = [\"a\",\"a\",\"a\",\"ab\"]\nOutput: 1\nExplanation: The only string that appears exactly once in each of the two arrays is \"ab\"."
        ],
        "constraints": "1 <= words1.length, words2.length <= 1000\n1 <= words1[i].length, words2[j].length <= 30\nwords1[i] and words2[j] consists only of lowercase English letters.",
        "oracle_code": "class Solution {\n    public int countWords(String[] words1, String[] words2) {\n        Map<String, Integer> map1 = new HashMap<>();\n        Map<String, Integer> map2 = new HashMap<>();\n\n        for (String s: words1){\n            if(map1.containsKey(s)) map1.put(s, map1.get(s)+1);\n            else map1.put(s, 1);\n        }\n        for (String s: words2){\n            if(map2.containsKey(s)) map2.put(s, map2.get(s)+1);\n            else map2.put(s, 1);\n        }\n        int count = 0;\n        for(String i : words1){\n            if(map1.get(i) == 1 && map2.getOrDefault(i,0) == 1 ){\n                count++;\n            }\n        }\n\n        return count;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countWords(String[] words1, String[] words2) {\\n        Map<String, Integer> map1 = new HashMap<>();\\n        Map<String, Integer> map2 = new HashMap<>();\\n\\n        for (String s: words1){\\n            if(map1.containsKey(s)) map1.put(s, map1.get(s)+1);\\n            else map1.put(s, 1);\\n        }\\n        for (String s: words2){\\n            if(map2.containsKey(s)) map2.put(s, map2.get(s)+1);\\n            else map2.put(s, 1);\\n        }\\n        int count = 0;\\n        for(String i : words1){\\n            if(map1.get(i) == 1 && map2.getOrDefault(i,0) == 1 ){\\n                count++;\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
        "level": "easy",
        "type": [
            "conditional statement error",
            "indexing error",
            "statement separation",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\n    public int countWords(String[] words1, String[] words2) {\n        Map<String, Integer> map1 = new HashMap<>();\n        Map<String, Integer> map2 = new HashMap<>();\n\n        for (String s: words1)\n            if(map1.containsKey(s)) map1.put(s, map1.get(s)+1);\n            else map1.put(s, 1);\n\n        for (String s: words2)\n            if(map2.containsKey(s)) map2.put(s, map2.get(s)+1);\n            else map2.put(s, 1);\n        \n        int count = 0;\n        for(String i : words2){\n            if(map1.get(i) == 1 && map2.getOrDefault(i+1,0) == 1 )\n                count++;\n            return count;\n        }\n        return 0;\n    }\n        clearSlate(); }\n    \n    \n\n"
    },
    {
        "slug": "count-largest-group",
        "description": "You are given an integer n.\nEach number from 1 to n is grouped according to the sum of its digits.\nReturn the number of groups that have the largest size.",
        "examples": [
            "Input: n = 13\nOutput: 4\nExplanation: There are 9 groups in total, they are grouped according sum of its digits of numbers from 1 to 13:\n[1,10], [2,11], [3,12], [4,13], [5], [6], [7], [8], [9].\nThere are 4 groups with largest size.",
            "Input: n = 2\nOutput: 2\nExplanation: There are 2 groups [1], [2] of size 1."
        ],
        "constraints": "1 <= n <= 104",
        "oracle_code": "class Solution {\n    \n    int countDigits(int n) {\n        if(n == 0) return 0;\n        return n%10 + countDigits(n/10);\n    }\n    \n    public int countLargestGroup(int n) {\n        \n        ArrayList<Integer> list = new ArrayList(Collections.nCopies(37, 0));\n        \n        for(int i=1;i<=n;i++) {\n            int cd = countDigits(i); // count digits\n            list.set(cd, list.get(cd)+1); // update count\n        }\n        \n        return Collections.frequency(list, Collections.max(list));\n    }\n}",
        "content": "```\\nclass Solution {\\n    \\n    int countDigits(int n) {\\n        if(n == 0) return 0;\\n        return n%10 + countDigits(n/10);\\n    }\\n    \\n    public int countLargestGroup(int n) {\\n        \\n        ArrayList<Integer> list = new ArrayList(Collections.nCopies(37, 0));\\n        \\n        for(int i=1;i<=n;i++) {\\n            int cd = countDigits(i); // count digits\\n            list.set(cd, list.get(cd)+1); // update count\\n        }\\n        \\n        return Collections.frequency(list, Collections.max(list));\\n    }\\n}\\n```",
        "level": "easy",
        "type": [
            "== and = confusion",
            "undefined objects",
            "undefined keywords from other languages",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\n\n    int countDigits(int n) {\n        if(n = 0) return 0;\n        return n%10 + countDigits(n/10);\n    }\n\n    public int countLargestGroup(int n) {\n\n        ArrayList<Integer> list = nul []; \n\n        for(int i=1;i<=n;i++) {\n            int cd = missingMethod(i); \n            list.set(cd, list.get(cd)+1); \n        }\n\n       return Collections.frequency(list, Collections.max(list));\n    }\n}\n"
    },
    {
        "slug": "erect-the-fence",
        "description": "You are given an array trees where trees[i] = [xi, yi] represents the location of a tree in the garden.\nFence the entire garden using the minimum length of rope, as it is expensive. The garden is well-fenced only if all the trees are enclosed.\nReturn the coordinates of trees that are exactly located on the fence perimeter. You may return the answer in any order.",
        "examples": [
            "Input: trees = [[1,1],[2,2],[2,0],[2,4],[3,3],[4,2]]\nOutput: [[1,1],[2,0],[4,2],[3,3],[2,4]]\nExplanation: All the trees will be on the perimeter of the fence except the tree at [2, 2], which will be inside the fence.",
            "Input: trees = [[1,2],[2,2],[4,2]]\nOutput: [[4,2],[2,2],[1,2]]\nExplanation: The fence forms a line that passes through all the trees."
        ],
        "constraints": "1 <= trees.length <= 3000\ntrees[i].length == 2\n0 <= xi, yi <= 100\nAll the given positions are unique.",
        "oracle_code": "class Solution {\n    \n    public int[][] outerTrees(int[][] trees) {\n        if(trees.length == 3){\n            return trees;\n        }\n        Stack<int[]> upper = new Stack<>();\n        Stack<int[]> lower = new Stack<>();\n        \n        Arrays.sort(trees,(p,q) ->\n                  q[0]-p[0]==0?q[1]-p[1]:q[0]-p[0]);\n        \n        for(int i = 0 ; i < trees.length ; i++){\n            int size = trees.length;\n            while(upper.size() >= 2 && angle(upper.get(upper.size() - 2),upper.get(upper.size() - 1),trees[i]) > 0){\n                upper.pop();  \n                }\n            while(lower.size() >= 2 && angle(lower.get(lower.size() - 2),lower.get(lower.size() - 1),trees[i]) < 0){\n                 lower.pop();  \n              }\n            upper.push(trees[i]);\n            lower.push(trees[i]);\n        }\n        \n        \n        Set<int[]> res= new HashSet<>(lower);\n        res.addAll(upper);\n        return res.toArray(new int[res.size()][]);\n    }\n    \n    public int angle(int[] A , int[] B , int[] C){\n        return (C[0] - A[0]) * (B[1] - A[1]) - (B[0] - A[0]) * (C[1] - A[1]);\n    }\n}",
        "content": "```\\nclass Solution {\\n    \\n    public int[][] outerTrees(int[][] trees) {\\n        if(trees.length == 3){\\n            return trees;\\n        }\\n        Stack<int[]> upper = new Stack<>();\\n        Stack<int[]> lower = new Stack<>();\\n        \\n        Arrays.sort(trees,(p,q) ->\\n                  q[0]-p[0]==0?q[1]-p[1]:q[0]-p[0]);\\n        \\n        for(int i = 0 ; i < trees.length ; i++){\\n            int size = trees.length;\\n            while(upper.size() >= 2 && angle(upper.get(upper.size() - 2),upper.get(upper.size() - 1),trees[i]) > 0){\\n                upper.pop();  \\n                }\\n            while(lower.size() >= 2 && angle(lower.get(lower.size() - 2),lower.get(lower.size() - 1),trees[i]) < 0){\\n                 lower.pop();  \\n              }\\n            upper.push(trees[i]);\\n            lower.push(trees[i]);\\n        }\\n        \\n        \\n        Set<int[]> res= new HashSet<>(lower);\\n        res.addAll(upper);\\n        return res.toArray(new int[res.size()][]);\\n    }\\n    \\n    public int angle(int[] A , int[] B , int[] C){\\n        return (C[0] - A[0]) * (B[1] - A[1]) - (B[0] - A[0]) * (C[1] - A[1]);\\n    }\\n}\\n```\\n\\n**Upvote Please**",
        "level": "hard",
        "type": [
            "colon missing",
            "conditional statement error",
            "undefined objects",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution {\n    \n    var trees = [];\n    public int[][] outerTrees(int[][] trees) {\n        if(trees.length == 3)\n            return trees;\n        Stack<int[]> upper = new Stack<>();\n        Stack<int[]> lower = null;\n        \n        Arrays.sort(trees,(p,q) ->q[0]-p[0]==0?q[1]-p[1]:q[0]-p[0]);\n        \n        for(int i = 0 ; i < trees.length ; i++){\n            while(upper.size() >= 2 && angle(upper.get(upper.size() - 2),upper.get(upper.size() - 1),trees[i]) > 0){\n                upper.pop();\n                }\n            while(lower.size() >= 2 && angle(lower.get(lower.size() - 2),lower.get(lower.size() - 1),trees[i]) > 0){\n                 lower.pop();   \n              }\n            upper.push(trees[i]);\n            lower.push(trees[i])\n        }\n        \n        \n        Set<int[]> res= new HashSet<>(lower);\n        res.addAll(upper);\n        return res.toArray(new int[res.size()][]);\n    }\n    \n    public int angle(int[] A , int[] B , int[] C){\n        return (C[0] - A[0]) * (B[1] - A[1]) - (B[0] - A[0]) * (C[1] - A[1]);\n    }\n}\n"
    },
    {
        "slug": "reverse-words-in-a-string",
        "description": "Given an input string s, reverse the order of the words.\nA word is defined as a sequence of non-space characters. The words in s will be separated by at least one space.\nReturn a string of the words in reverse order concatenated by a single space.\nNote that s may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words. Do not include any extra spaces.",
        "examples": [
            "Input: s = \"the sky is blue\"\nOutput: \"blue is sky the\"",
            "Input: s = \"  hello world  \"\nOutput: \"world hello\"\nExplanation: Your reversed string should not contain leading or trailing spaces.",
            "Input: s = \"a good   example\"\nOutput: \"example good a\"\nExplanation: You need to reduce multiple spaces between two words to a single space in the reversed string."
        ],
        "constraints": "1 <= s.length <= 104\ns contains English letters (upper-case and lower-case), digits, and spaces ' '.\nThere is at least one word in s.\n\n\u00a0\nFollow-up:\u00a0If the string data type is mutable in your language, can\u00a0you solve it\u00a0in-place\u00a0with\u00a0O(1)\u00a0extra space?",
        "oracle_code": "class Solution {\n    public String reverseWords(String s) {\n        StringBuilder ans = new StringBuilder();\n        for(int i=s.length()-1; i>=0; i--){\n            if(s.charAt(i)==' '){\n                continue;\n            }\n            int start=-1;\n            for(int y=i-1; y>=0; y--){\n                if(s.charAt(y)==' '){\n                    start=y;\n                    break;\n                }\n            }\n            ans.append(s.substring(start+1, i+1) + \" \");\n            i=start;\n        }\n        ans.deleteCharAt(ans.length()-1);\n        return ans.toString();\n    }\n}",
        "content": "# Approach\\n- Two Pointer Approach\\n- Using Trim and Split\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public String reverseWords(String s) {\\n        StringBuilder ans = new StringBuilder();\\n        for(int i=s.length()-1; i>=0; i--){\\n            if(s.charAt(i)==\\' \\'){\\n                continue;\\n            }\\n            int start=-1;\\n            for(int y=i-1; y>=0; y--){\\n                if(s.charAt(y)==\\' \\'){\\n                    start=y;\\n                    break;\\n                }\\n            }\\n            ans.append(s.substring(start+1, i+1) + \" \");\\n            i=start;\\n        }\\n        ans.deleteCharAt(ans.length()-1);\\n        return ans.toString();\\n    }\\n}\\n```\\n```\\nclass Solution {\\n    public String reverseWords(String s) {\\n        String[] temp = s.trim().split(\" \");\\n        StringBuilder ans = new StringBuilder();\\n        for(int i=temp.length-1; i>0; i--){\\n            if(temp[i]==\"\"){\\n                continue;\\n            }\\n            ans.append(temp[i]+\" \");\\n        }\\n        ans.append(temp[0]);\\n        return ans.toString();\\n    }\\n}\\n```",
        "level": "medium",
        "type": [
            "operation error",
            "== and = confusion",
            "wrong comment mark",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution {\n    public String reverseWords(String s) {\n        StringBuilder ans = new StringBuilder();\n        String str = null;\n        for(int i=s.length()-1; i>=str.length(); i--){\n            /*if(s.charAt(i)==' '){\n                continue;\n            }*/\n            int start=-1;\n            for(int y=i-1; y>=0; y--){\n                if(s.charAt(y)==' '){\n                    start=y;\n                    break;\n                }\n            }\n            ans.append(s.substring(start+1, i) + \" \");\n            i=start;\n        }\n        ans.deleteCharAt(ans.length()-1);\n        return ans.toString()==s;\n    }\n}\n"
    },
    {
        "slug": "sum-of-total-strength-of-wizards",
        "description": "As the ruler of a kingdom, you have an army of wizards at your command.\nYou are given a 0-indexed integer array strength, where strength[i] denotes the strength of the ith wizard. For a contiguous group of wizards (i.e. the wizards' strengths form a subarray of strength), the total strength is defined as the product of the following two values:\n\nThe strength of the weakest wizard in the group.\nThe total of all the individual strengths of the wizards in the group.\n\nReturn the sum of the total strengths of all contiguous groups of wizards. Since the answer may be very large, return it modulo 109 + 7.\nA subarray is a contiguous non-empty sequence of elements within an array.",
        "examples": [
            "Input: strength = [1,3,1,2]\nOutput: 44\nExplanation: The following are all the contiguous groups of wizards:\n- [1] from [1,3,1,2] has a total strength of min([1]) * sum([1]) = 1 * 1 = 1\n- [3] from [1,3,1,2] has a total strength of min([3]) * sum([3]) = 3 * 3 = 9\n- [1] from [1,3,1,2] has a total strength of min([1]) * sum([1]) = 1 * 1 = 1\n- [2] from [1,3,1,2] has a total strength of min([2]) * sum([2]) = 2 * 2 = 4\n- [1,3] from [1,3,1,2] has a total strength of min([1,3]) * sum([1,3]) = 1 * 4 = 4\n- [3,1] from [1,3,1,2] has a total strength of min([3,1]) * sum([3,1]) = 1 * 4 = 4\n- [1,2] from [1,3,1,2] has a total strength of min([1,2]) * sum([1,2]) = 1 * 3 = 3\n- [1,3,1] from [1,3,1,2] has a total strength of min([1,3,1]) * sum([1,3,1]) = 1 * 5 = 5\n- [3,1,2] from [1,3,1,2] has a total strength of min([3,1,2]) * sum([3,1,2]) = 1 * 6 = 6\n- [1,3,1,2] from [1,3,1,2] has a total strength of min([1,3,1,2]) * sum([1,3,1,2]) = 1 * 7 = 7\nThe sum of all the total strengths is 1 + 9 + 1 + 4 + 4 + 4 + 3 + 5 + 6 + 7 = 44.",
            "Input: strength = [5,4,6]\nOutput: 213\nExplanation: The following are all the contiguous groups of wizards: \n- [5] from [5,4,6] has a total strength of min([5]) * sum([5]) = 5 * 5 = 25\n- [4] from [5,4,6] has a total strength of min([4]) * sum([4]) = 4 * 4 = 16\n- [6] from [5,4,6] has a total strength of min([6]) * sum([6]) = 6 * 6 = 36\n- [5,4] from [5,4,6] has a total strength of min([5,4]) * sum([5,4]) = 4 * 9 = 36\n- [4,6] from [5,4,6] has a total strength of min([4,6]) * sum([4,6]) = 4 * 10 = 40\n- [5,4,6] from [5,4,6] has a total strength of min([5,4,6]) * sum([5,4,6]) = 4 * 15 = 60\nThe sum of all the total strengths is 25 + 16 + 36 + 36 + 40 + 60 = 213."
        ],
        "constraints": "1 <= strength.length <= 105\n1 <= strength[i] <= 109",
        "oracle_code": "class Solution {\n    public int totalStrength(int[] strength) {\n        int mod = 1000000007;\n        \n        int len = strength.length;\n        \n        long[] prefix = prefixSum(strength, len, mod);\n        \n        Deque<Integer> stack = new ArrayDeque<>();\n        stack.push(-1);\n\n        long ans = 0;\n        for(int i = 0; i < len; i++) {\n            while(stack.peek() != -1 && strength[i] <= strength[stack.peek()]) {\n                int mid = stack.pop();\n                int left = stack.peek() + 1;\n                int right = i - 1;\n                \n                int n = (mid - left);\n                int t = (right - mid);\n                \n                long val = (1l * (1 + n) * (prefix[right + 2] - prefix[mid + 1]) + mod) % mod;\n                val -= (1l * (1 + t) * (prefix[mid + 1] - prefix[left]) + mod) % mod;\n                val *= strength[mid];\n                \n                ans += val;\n                ans %= mod;\n            }\n            \n            stack.push(i);\n        }\n        \n        int right = len - 1;\n        while(stack.peek() != -1) {\n            int mid = stack.pop();\n            int left = stack.peek() + 1;\n            \n            int n = (mid - left);\n            int t = (right - mid);\n\n            long val = (1l * (1 + n) * (prefix[right + 2] - prefix[mid + 1]) + mod) % mod;\n            val -= (1l * (1 + t) * (prefix[mid + 1] - prefix[left]) + mod) % mod;\n            val *= strength[mid];\n\n            ans += val;\n            ans %= mod;\n        }\n        \n        return (int)((ans + mod) % mod);\n    }\n    \n    private long[] prefixSum(int[] strength, int len, int mod) {\n        long[] prefix = new long[len + 1];\n        \n        for(int i = 0; i < len; i++) {\n            prefix[i + 1] = prefix[i] + strength[i];\n        }\n        \n        long[] doublePrefix = new long[len + 2];\n        for(int i = 0; i <= len; i++) {\n            doublePrefix[i + 1] = (doublePrefix[i] + prefix[i]) % mod;\n        }\n\n        return doublePrefix;\n    }\n}",
        "content": "I could not figure out `o(n)` approach on my own. \\nI needed to read at least 3 solution by really brilliant people (top voted) to understand the approach.\\nThen I had to do the math on pen-paper 3 times (made mistake 2 time) to actually understand the approach.\\nThen when I actually started coding, I made some some silly mistakes around Stack boundry and \\nthe cherry on top was that you need to do `+ mod) % mod` at almost every place you are doing any calculation.\\n\\nOverall, very good learning experience but I really pity the ones who actually face this in interview.\\n\\nRun time complexity: `4 * O(n)` =  `O(n)` \\nSpace compexity: `O(n)`\\n\\nMy java solution -\\n```\\nclass Solution {\\n    public int totalStrength(int[] strength) {\\n        int mod = 1000000007;\\n        \\n        int len = strength.length;\\n        \\n        long[] prefix = prefixSum(strength, len, mod);\\n        \\n        Deque<Integer> stack = new ArrayDeque<>();\\n        stack.push(-1);\\n\\n        long ans = 0;\\n        for(int i = 0; i < len; i++) {\\n            while(stack.peek() != -1 && strength[i] <= strength[stack.peek()]) {\\n                int mid = stack.pop();\\n                int left = stack.peek() + 1;\\n                int right = i - 1;\\n                \\n                int n = (mid - left);\\n                int t = (right - mid);\\n                \\n                long val = (1l * (1 + n) * (prefix[right + 2] - prefix[mid + 1]) + mod) % mod;\\n                val -= (1l * (1 + t) * (prefix[mid + 1] - prefix[left]) + mod) % mod;\\n                val *= strength[mid];\\n                \\n                ans += val;\\n                ans %= mod;\\n            }\\n            \\n            stack.push(i);\\n        }\\n        \\n        int right = len - 1;\\n        while(stack.peek() != -1) {\\n            int mid = stack.pop();\\n            int left = stack.peek() + 1;\\n            \\n            int n = (mid - left);\\n            int t = (right - mid);\\n\\n            long val = (1l * (1 + n) * (prefix[right + 2] - prefix[mid + 1]) + mod) % mod;\\n            val -= (1l * (1 + t) * (prefix[mid + 1] - prefix[left]) + mod) % mod;\\n            val *= strength[mid];\\n\\n            ans += val;\\n            ans %= mod;\\n        }\\n        \\n        return (int)((ans + mod) % mod);\\n    }\\n    \\n    private long[] prefixSum(int[] strength, int len, int mod) {\\n        long[] prefix = new long[len + 1];\\n        \\n        for(int i = 0; i < len; i++) {\\n            prefix[i + 1] = prefix[i] + strength[i];\\n        }\\n        \\n        long[] doublePrefix = new long[len + 2];\\n        for(int i = 0; i <= len; i++) {\\n            doublePrefix[i + 1] = (doublePrefix[i] + prefix[i]) % mod;\\n        }\\n\\n        return doublePrefix;\\n    }\\n}\\n```",
        "level": "hard",
        "type": [
            "variable value error",
            "parentheses mismatch",
            "undefined objects",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution {\n    public int totalStrength(int[] strength) {\n        int mod = 1000000007;\n        \n        int len = strength.length;\n        \n        long[] prefix = prefixSum(strength, len, mod;\n        \n        Deque<Integer> stack = null; \n        stack.push(-1);\n\n        long ans = 0;\n        for(int i = 0; i < len; i++) {\n            const int mid;\n            while(stack.peek() != -1 && strength[i] <= strength[stack.peek()]) {\n                mid = stack.pop();\n                int left = stack.peek() + 1;\n                int right = i - 1;\n                \n                int n = (mid - left) + 1;\n                int t = (right - mid) + 1;\n                \n                long val = (1l * (1 + n) * (prefix[right + 2] - prefix[mid + 1]) + mod) % mod;\n                val -= (1l * (1 + t) * (prefix[mid + 1] - prefix[left]) + mod) % mod;\n                val *= strength[mid];\n                \n                ans += val;\n                ans %= mod;\n            }\n            \n            stack.push(i);\n        }\n        \n        int right = len - 1;\n        while(stack.peek() != -1) {\n            int mid = stack.pop();\n            int left = stack.peek() + 1;\n            \n            int n = (mid - left) + 1;\n            int t = (right - mid) + 1;\n\n            long val = (1l * (1 + n) * (prefix[right + 2] - prefix[mid + 1]) + mod) % mod;\n            val -= (1l * (1 + t) * (prefix[mid + 1] - prefix[left]) + mod) % mod;\n            val *= strength[mid];\n\n            ans += val;\n            ans %= mod;\n        }\n        \n        return (int)((ans + mod) % mod);\n    }\n    \n    private long[] prefixSum(int[] strength, int len, int mod) {\n        long[] prefix = new long[len + 1];\n        \n        for(int i = 0; i < len; i++) {\n            prefix[i + 1] = prefix[i] + strength[i];\n        }\n        \n        long[] doublePrefix = new long[len + 2];\n        for(int i = 0; i <= len; i++) {\n            doublePrefix[i + 1] = (doublePrefix[i] + prefix[i]) % mod;\n        }\n\n        return doublePrefix;\n    }\n}\n"
    },
    {
        "slug": "jewels-and-stones",
        "description": "You're given strings jewels representing the types of stones that are jewels, and stones representing the stones you have. Each character in stones is a type of stone you have. You want to know how many of the stones you have are also jewels.\nLetters are case sensitive, so \"a\" is considered a different type of stone from \"A\".",
        "examples": [
            "Input: jewels = \"aA\", stones = \"aAAbbbb\"\nOutput: 3",
            "Input: jewels = \"z\", stones = \"ZZ\"\nOutput: 0"
        ],
        "constraints": "1 <=\u00a0jewels.length, stones.length <= 50\njewels and stones consist of only English letters.\nAll the characters of\u00a0jewels are unique.",
        "oracle_code": "class Solution {\n    public int numJewelsInStones(String jewels, String stones) {\n        int count = 0;\n\n        for(int i=0; i<stones.length(); i++){\n            char c = stones.charAt(i);\n            if(jewels.contains(String.valueOf(c))){\n                count++;\n            }\n        }\n        return count;\n    }\n}",
        "content": "# Code\\n```\\nclass Solution {\\n    public int numJewelsInStones(String jewels, String stones) {\\n        int count = 0;\\n\\n        for(int i=0; i<stones.length(); i++){\\n            char c = stones.charAt(i);\\n            if(jewels.contains(String.valueOf(c))){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
        "level": "easy",
        "type": [
            "operation error",
            "wrong comment mark",
            "undefined objects",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution {\n    public int numJewelsInStones(String jewels, /*String stones) {\n        int count = 0;\n        let checkCharacter;\n\n        for(int i=0; i<stones.length(); i++){\n            checkCharacter = stones.charAt(i);\n            String undefinedObject = null;\n            if(undefinedObject.contains(String.valueOf(checkCharacter))){\n                count--;\n            }\n        } */\n        return count;\n    }\n}\n"
    },
    {
        "slug": "count-and-say",
        "description": "The count-and-say sequence is a sequence of digit strings defined by the recursive formula:\n\ncountAndSay(1) = \"1\"\ncountAndSay(n) is the way you would \"say\" the digit string from countAndSay(n-1), which is then converted into a different digit string.\n\nTo determine how you \"say\" a digit string, split it into the minimal number of substrings such that each substring contains exactly one unique digit. Then for each substring, say the number of digits, then say the digit. Finally, concatenate every said digit.\nFor example, the saying and conversion for digit string \"3322251\":\n\nGiven a positive integer n, return the nth term of the count-and-say sequence.",
        "examples": [
            "Input: n = 1\nOutput: \"1\"\nExplanation: This is the base case.",
            "Input: n = 4\nOutput: \"1211\"\nExplanation:\ncountAndSay(1) = \"1\"\ncountAndSay(2) = say \"1\" = one 1 = \"11\"\ncountAndSay(3) = say \"11\" = two 1's = \"21\"\ncountAndSay(4) = say \"21\" = one 2 + one 1 = \"12\" + \"11\" = \"1211\""
        ],
        "constraints": "1 <= n <= 30",
        "oracle_code": "class Solution {\n    String convert(String s)\n    {\n        char prevCh = s.charAt(0);\n        int prevCount = 1; //stores count of consecutive same digits\n        StringBuilder ans = new StringBuilder();\n        for (int i = 1; i < s.length(); i++)\n        {\n            char currCh = s.charAt(i);\n            if (currCh != prevCh)   \n            {\n                ans.append(Integer.toString(prevCount));\n                ans.append(prevCh);\n                prevCount = 1; //reset count\n                prevCh = currCh;\n            }\n            else prevCount++;\n        }\n        ans.append(Integer.toString(prevCount));\n        ans.append(prevCh);\n        return ans.toString();\n    }\n    public String countAndSay(int n) \n    {\n        String prevStr = \"1\";\n        for (int i = 2; i <= n; i++)\n        {\n            String cnsNum = convert(prevStr); //cns  = \"count and say Num\"\n            prevStr = cnsNum; //remember (dp) the previous built string\n        }\n        return prevStr;\n        \n        \n    }\n}",
        "content": "```\\nclass Solution {\\n    String convert(String s)\\n    {\\n        char prevCh = s.charAt(0);\\n        int prevCount = 1; //stores count of consecutive same digits\\n        StringBuilder ans = new StringBuilder();\\n        for (int i = 1; i < s.length(); i++)\\n        {\\n            char currCh = s.charAt(i);\\n            if (currCh != prevCh)   \\n            {\\n                ans.append(Integer.toString(prevCount));\\n                ans.append(prevCh);\\n                prevCount = 1; //reset count\\n                prevCh = currCh;\\n            }\\n            else prevCount++;\\n        }\\n        ans.append(Integer.toString(prevCount));\\n        ans.append(prevCh);\\n        return ans.toString();\\n    }\\n    public String countAndSay(int n) \\n    {\\n        String prevStr = \"1\";\\n        for (int i = 2; i <= n; i++)\\n        {\\n            String cnsNum = convert(prevStr); //cns  = \"count and say Num\"\\n            prevStr = cnsNum; //remember (dp) the previous built string\\n        }\\n        return prevStr;\\n        \\n        \\n    }\\n}\\n```",
        "level": "medium",
        "type": [
            "conditional statement error",
            "undefined keywords from other languages",
            "unclosed string",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution{\n    String convert(String s)\n    {\n        char prevCh = s.charAt(0);\n        int prevCount = 1; //stores count of consecutive same digits\n        StringBuilder ans = new StringBuilder();\n        for (int i = 1; i <= s.length(); i++)\n        {\n            char currCh = s.charAt(i);\n            print(currCh != prevCh)   \n            {\n                ans.append(Integer.toString(prevCount));\n                ans.append(prevCh);\n                prevCount = 1; //reset count\n                prevCh = currCh;\n            }\n            else prevCount++;\n        }\n        ans.append(Integer.toString(prevCount));\n        ans.append(prevCh);\n        return ans.toString();\n    }\n    public String countAndSay(int n) \n    {\n        String prevStr = \"1;\n        for (int i = 2; i <= n; i++)\n        {\n            String cnsNum = helperFunction(prevStr); \n            prevStr = cnsNum; //remember (dp) the previous built string\n        }\n        return prevStr;}\n}\n"
    },
    {
        "slug": "largest-number-after-digit-swaps-by-parity",
        "description": "You are given a positive integer num. You may swap any two digits of num that have the same parity (i.e. both odd digits or both even digits).\nReturn the largest possible value of num after any number of swaps.",
        "examples": [
            "Input: num = 1234\nOutput: 3412\nExplanation: Swap the digit 3 with the digit 1, this results in the number 3214.\nSwap the digit 2 with the digit 4, this results in the number 3412.\nNote that there may be other sequences of swaps but it can be shown that 3412 is the largest possible number.\nAlso note that we may not swap the digit 4 with the digit 1 since they are of different parities.",
            "Input: num = 65875\nOutput: 87655\nExplanation: Swap the digit 8 with the digit 6, this results in the number 85675.\nSwap the first digit 5 with the digit 7, this results in the number 87655.\nNote that there may be other sequences of swaps but it can be shown that 87655 is the largest possible number."
        ],
        "constraints": "1 <= num <= 109",
        "oracle_code": "class Solution {\n    public int largestInteger(int num) {\n        String numString = \"\"+ num;\n        List<Integer> even = new ArrayList<>();\n        List<Integer> odd = new ArrayList<>();\n        for(Character c : numString.toCharArray()){\n            int n = Character.getNumericValue(c);\n            if(n%2==0){\n                even.add(n);\n            }else{\n                odd.add(n);\n            }\n        }\n        Collections.sort(even, Collections.reverseOrder());\n        Collections.sort(odd, Collections.reverseOrder());\n        String res =\"\";\n        int one=0, two=0;\n        for(int i=0; i<numString.length(); i++){\n            int n = Character.getNumericValue(numString.charAt(i));\n            if(n%2==0){\n                res += even.get(one);\n                one++;\n            }else{\n                res += odd.get(two);\n                two++;\n            }\n        }\n        return Integer.parseInt(res);\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nused string and list to store the even and odd elements\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nconverted num in string then added all values from string to even and odd list as per its type;\\nthen sorted both string in desc order\\nas we check from the original string if got even number we will put max even number from even list and incresed even list pointer same for the odd number\\n\\nConverted result string to integer to get int res and returned it\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int largestInteger(int num) {\\n        String numString = \"\"+ num;\\n        List<Integer> even = new ArrayList<>();\\n        List<Integer> odd = new ArrayList<>();\\n        for(Character c : numString.toCharArray()){\\n            int n = Character.getNumericValue(c);\\n            if(n%2==0){\\n                even.add(n);\\n            }else{\\n                odd.add(n);\\n            }\\n        }\\n        Collections.sort(even, Collections.reverseOrder());\\n        Collections.sort(odd, Collections.reverseOrder());\\n        String res =\"\";\\n        int one=0, two=0;\\n        for(int i=0; i<numString.length(); i++){\\n            int n = Character.getNumericValue(numString.charAt(i));\\n            if(n%2==0){\\n                res += even.get(one);\\n                one++;\\n            }else{\\n                res += odd.get(two);\\n                two++;\\n            }\\n        }\\n        return Integer.parseInt(res);\\n    }\\n}\\n```",
        "level": "easy",
        "type": [
            "colon missing",
            "wrong comment mark",
            "unclosed string",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\n    public int largestInteger(int num) {\n        String numString = \"\"+ num;\n        /*List<Integer> even = new ArrayList<>();*/\n        List<Integer> odd = new ArrayList<>();\n        for(Character c : numString.toCharArray())\n            int n = Character.getNumericValue(c);\n            if(n%2==0){\n                even.add(n);\n            }else{\n                odd.add(n);\n            }\n        }\n        Collections.sort(even, Collections.reverseOrder());\n        Collections.sort(odd, Collections.reverseOrder());\n        String res =\"\"\n        int one=0, two=0;\n        for(int i=0; i<numString.length(); i++){\n            int n = Character.getNumericValue(numString.charAt(i));\n            if(n%2==0){\n                res += even.get(one);\n                one++;\n            }else{\n                res += odd.get(two);\n                two++;\n            }\n        }\n        return Integer.parseStringMethodThatDoesntExist(res);\n    }\n}\n"
    },
    {
        "slug": "count-negative-numbers-in-a-sorted-matrix",
        "description": "Given a m x n matrix grid which is sorted in non-increasing order both row-wise and column-wise, return the number of negative numbers in grid.",
        "examples": [
            "Input: grid = [[4,3,2,-1],[3,2,1,-1],[1,1,-1,-2],[-1,-1,-2,-3]]\nOutput: 8\nExplanation: There are 8 negatives number in the matrix.",
            "Input: grid = [[3,2],[1,0]]\nOutput: 0"
        ],
        "constraints": "m == grid.length\nn == grid[i].length\n1 <= m, n <= 100\n-100 <= grid[i][j] <= 100",
        "oracle_code": "class Solution:\n    def countNegatives(self, grid: List[List[int]]) -> int:\n        ROWS, COLS = len(grid), len(grid[0])\n        negatives = 0\n        col = 0\n        for row in range(ROWS - 1, -1, -1):\n            while col < COLS and grid[row][col] >= 0:\n                col += 1\n            negatives += COLS - col\n        return negatives",
        "content": "# Intuition\\nThe key idea is to take advantage of the sorted nature of the matrix, where both the rows and columns are sorted in non-increasing order. This means that once we find a negative number in a row, all the following numbers in that row will also be negative. Similarly, if a cell at the top of a column is negative, all the cells below it in that column will also be negative.\\n\\n# Approach\\nNegative numbers will form a staircase. So we start from the bottom-left, and follow along the staircase. For each row, we find the edge of the staircase, add all the count of elements to the right to the answer, and then move up a row and repeat.\\n\\n# Complexity\\n- Time complexity: O(m + n) - We visit each row and column at most once.\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def countNegatives(self, grid: List[List[int]]) -> int:\\n        ROWS, COLS = len(grid), len(grid[0])\\n        negatives = 0\\n        col = 0\\n        for row in range(ROWS - 1, -1, -1):\\n            while col < COLS and grid[row][col] >= 0:\\n                col += 1\\n            negatives += COLS - col\\n        return negatives\\n\\n```\\n\\n# Get Faster Interview Prep Results with Top Algos\\nWe all know how time-consuming it is to prepare for interviews and how frustratingly difficult it is to improve. We made **Top Algos** - a tool recommends the perfect algorithm problem based on your current skill level to help you improve the fastest in the shortest amount of time. Top Algos is your personalized coach that learns your skill level and finds the best problem you need to solve to improve.\\n\\nThe beta version of the product is available for **free** right now! You can sign up at https://topalgos.xyz/.",
        "level": "easy",
        "type": [
            "operation error",
            "indexing error",
            "undefined objects",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution:\n    def countNegatives(self, grid: List[List[int]]) -> int:\n        ROWS, COLS = len(grid), len(undefinedGridVar[0])\n        negatives = 0\n        col = 0\n        for row in range(ROWS - 1, -1, -1):\n            while col <= COLS and grid[row][col] >= 0:\n                col += 1\n            negatives += COLS\n        return negatives\n\n    def undefinedMethod(self):\n        self.countPositives(grid)\n"
    },
    {
        "slug": "sum-of-total-strength-of-wizards",
        "description": "As the ruler of a kingdom, you have an army of wizards at your command.\nYou are given a 0-indexed integer array strength, where strength[i] denotes the strength of the ith wizard. For a contiguous group of wizards (i.e. the wizards' strengths form a subarray of strength), the total strength is defined as the product of the following two values:\n\nThe strength of the weakest wizard in the group.\nThe total of all the individual strengths of the wizards in the group.\n\nReturn the sum of the total strengths of all contiguous groups of wizards. Since the answer may be very large, return it modulo 109 + 7.\nA subarray is a contiguous non-empty sequence of elements within an array.",
        "examples": [
            "Input: strength = [1,3,1,2]\nOutput: 44\nExplanation: The following are all the contiguous groups of wizards:\n- [1] from [1,3,1,2] has a total strength of min([1]) * sum([1]) = 1 * 1 = 1\n- [3] from [1,3,1,2] has a total strength of min([3]) * sum([3]) = 3 * 3 = 9\n- [1] from [1,3,1,2] has a total strength of min([1]) * sum([1]) = 1 * 1 = 1\n- [2] from [1,3,1,2] has a total strength of min([2]) * sum([2]) = 2 * 2 = 4\n- [1,3] from [1,3,1,2] has a total strength of min([1,3]) * sum([1,3]) = 1 * 4 = 4\n- [3,1] from [1,3,1,2] has a total strength of min([3,1]) * sum([3,1]) = 1 * 4 = 4\n- [1,2] from [1,3,1,2] has a total strength of min([1,2]) * sum([1,2]) = 1 * 3 = 3\n- [1,3,1] from [1,3,1,2] has a total strength of min([1,3,1]) * sum([1,3,1]) = 1 * 5 = 5\n- [3,1,2] from [1,3,1,2] has a total strength of min([3,1,2]) * sum([3,1,2]) = 1 * 6 = 6\n- [1,3,1,2] from [1,3,1,2] has a total strength of min([1,3,1,2]) * sum([1,3,1,2]) = 1 * 7 = 7\nThe sum of all the total strengths is 1 + 9 + 1 + 4 + 4 + 4 + 3 + 5 + 6 + 7 = 44.",
            "Input: strength = [5,4,6]\nOutput: 213\nExplanation: The following are all the contiguous groups of wizards: \n- [5] from [5,4,6] has a total strength of min([5]) * sum([5]) = 5 * 5 = 25\n- [4] from [5,4,6] has a total strength of min([4]) * sum([4]) = 4 * 4 = 16\n- [6] from [5,4,6] has a total strength of min([6]) * sum([6]) = 6 * 6 = 36\n- [5,4] from [5,4,6] has a total strength of min([5,4]) * sum([5,4]) = 4 * 9 = 36\n- [4,6] from [5,4,6] has a total strength of min([4,6]) * sum([4,6]) = 4 * 10 = 40\n- [5,4,6] from [5,4,6] has a total strength of min([5,4,6]) * sum([5,4,6]) = 4 * 15 = 60\nThe sum of all the total strengths is 25 + 16 + 36 + 36 + 40 + 60 = 213."
        ],
        "constraints": "1 <= strength.length <= 105\n1 <= strength[i] <= 109",
        "oracle_code": "class Solution {\n    public int totalStrength(int[] strength) {\n        int mod = 1000000007;\n        \n        int len = strength.length;\n        \n        long[] prefix = prefixSum(strength, len, mod);\n        \n        Deque<Integer> stack = new ArrayDeque<>();\n        stack.push(-1);\n\n        long ans = 0;\n        for(int i = 0; i < len; i++) {\n            while(stack.peek() != -1 && strength[i] <= strength[stack.peek()]) {\n                int mid = stack.pop();\n                int left = stack.peek() + 1;\n                int right = i - 1;\n                \n                int n = (mid - left);\n                int t = (right - mid);\n                \n                long val = (1l * (1 + n) * (prefix[right + 2] - prefix[mid + 1]) + mod) % mod;\n                val -= (1l * (1 + t) * (prefix[mid + 1] - prefix[left]) + mod) % mod;\n                val *= strength[mid];\n                \n                ans += val;\n                ans %= mod;\n            }\n            \n            stack.push(i);\n        }\n        \n        int right = len - 1;\n        while(stack.peek() != -1) {\n            int mid = stack.pop();\n            int left = stack.peek() + 1;\n            \n            int n = (mid - left);\n            int t = (right - mid);\n\n            long val = (1l * (1 + n) * (prefix[right + 2] - prefix[mid + 1]) + mod) % mod;\n            val -= (1l * (1 + t) * (prefix[mid + 1] - prefix[left]) + mod) % mod;\n            val *= strength[mid];\n\n            ans += val;\n            ans %= mod;\n        }\n        \n        return (int)((ans + mod) % mod);\n    }\n    \n    private long[] prefixSum(int[] strength, int len, int mod) {\n        long[] prefix = new long[len + 1];\n        \n        for(int i = 0; i < len; i++) {\n            prefix[i + 1] = prefix[i] + strength[i];\n        }\n        \n        long[] doublePrefix = new long[len + 2];\n        for(int i = 0; i <= len; i++) {\n            doublePrefix[i + 1] = (doublePrefix[i] + prefix[i]) % mod;\n        }\n\n        return doublePrefix;\n    }\n}",
        "content": "I could not figure out `o(n)` approach on my own. \\nI needed to read at least 3 solution by really brilliant people (top voted) to understand the approach.\\nThen I had to do the math on pen-paper 3 times (made mistake 2 time) to actually understand the approach.\\nThen when I actually started coding, I made some some silly mistakes around Stack boundry and \\nthe cherry on top was that you need to do `+ mod) % mod` at almost every place you are doing any calculation.\\n\\nOverall, very good learning experience but I really pity the ones who actually face this in interview.\\n\\nRun time complexity: `4 * O(n)` =  `O(n)` \\nSpace compexity: `O(n)`\\n\\nMy java solution -\\n```\\nclass Solution {\\n    public int totalStrength(int[] strength) {\\n        int mod = 1000000007;\\n        \\n        int len = strength.length;\\n        \\n        long[] prefix = prefixSum(strength, len, mod);\\n        \\n        Deque<Integer> stack = new ArrayDeque<>();\\n        stack.push(-1);\\n\\n        long ans = 0;\\n        for(int i = 0; i < len; i++) {\\n            while(stack.peek() != -1 && strength[i] <= strength[stack.peek()]) {\\n                int mid = stack.pop();\\n                int left = stack.peek() + 1;\\n                int right = i - 1;\\n                \\n                int n = (mid - left);\\n                int t = (right - mid);\\n                \\n                long val = (1l * (1 + n) * (prefix[right + 2] - prefix[mid + 1]) + mod) % mod;\\n                val -= (1l * (1 + t) * (prefix[mid + 1] - prefix[left]) + mod) % mod;\\n                val *= strength[mid];\\n                \\n                ans += val;\\n                ans %= mod;\\n            }\\n            \\n            stack.push(i);\\n        }\\n        \\n        int right = len - 1;\\n        while(stack.peek() != -1) {\\n            int mid = stack.pop();\\n            int left = stack.peek() + 1;\\n            \\n            int n = (mid - left);\\n            int t = (right - mid);\\n\\n            long val = (1l * (1 + n) * (prefix[right + 2] - prefix[mid + 1]) + mod) % mod;\\n            val -= (1l * (1 + t) * (prefix[mid + 1] - prefix[left]) + mod) % mod;\\n            val *= strength[mid];\\n\\n            ans += val;\\n            ans %= mod;\\n        }\\n        \\n        return (int)((ans + mod) % mod);\\n    }\\n    \\n    private long[] prefixSum(int[] strength, int len, int mod) {\\n        long[] prefix = new long[len + 1];\\n        \\n        for(int i = 0; i < len; i++) {\\n            prefix[i + 1] = prefix[i] + strength[i];\\n        }\\n        \\n        long[] doublePrefix = new long[len + 2];\\n        for(int i = 0; i <= len; i++) {\\n            doublePrefix[i + 1] = (doublePrefix[i] + prefix[i]) % mod;\\n        }\\n\\n        return doublePrefix;\\n    }\\n}\\n```",
        "level": "hard",
        "type": [
            "parentheses mismatch",
            "indexing error",
            "undefined objects",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution {\n    public int totalStrength(int[] strength) {\n        int mod = 1000000007;\n        \n        int len = strength.length;\n        \n        long[] prefix = prefixSum(strength, len, mod;\n        \n        Deque<Integer> stack = null; \n        stack.push(-1);\n\n        long ans = 0;\n        for(int i = 0; i < len; i++) {\n            const int mid;\n            while(stack.peek() != -1 && strength[i] <= strength[stack.peek()]) {\n                mid = stack.pop();\n                int left = stack.peek() + 1;\n                int right = i - 1;\n                \n                int n = (mid - left);\n                int t = (right - mid);\n                \n                long val = (1l * (1 + n) * (prefix[right + 2] - prefix[mid + 2]) + mod) % mod;\n                val -= (1l * (1 + t) * (prefix[mid + 1] - prefix[left]) + mod) % mod;\n                val *= strength[mid];\n                \n                ans += val;\n                ans %= mod;\n            }\n            \n            stack.push(i);\n        }\n        \n        int right = len - 1;\n        while(stack.peek() != -1) {\n            int mid = stack.pop();\n            int left = stack.peek() + 1;\n            \n            int n = (mid - left);\n            int t = (right - mid);\n\n            long val = (1l * (1 + n) * (prefix[right + 2] - prefix[mid + 1]) + mod) % mod;\n            val -= (1l * (1 + t) * (prefix[mid + 1] - prefix[left]) + mod) % mod;\n            val *= strength[mid];\n\n            ans += val;\n            ans %= mod;\n        }\n        \n        return (int)((ans + mod) % mod);\n    }\n    \n    private long[] prefixSum(int[] strength, int len, int mod) {\n        long[] prefix = new long[len + 1];\n        \n        for(int i = 0; i < len; i++) {\n            prefix[i + 1] = prefix[i] + strength[i];\n        }\n        \n        long[] doublePrefix = new long[len + 2];\n        for(int i = 0; i <= len; i++) {\n            doublePrefix[i + 1] = (doublePrefix[i] + prefix[i]) % mod;\n        }\n\n        return doublePrefix;\n    }\n}\n"
    },
    {
        "slug": "convert-the-temperature",
        "description": "You are given a non-negative floating point number rounded to two decimal places celsius, that denotes the temperature in Celsius.\nYou should convert Celsius into Kelvin and Fahrenheit and return it as an array ans = [kelvin, fahrenheit].\nReturn the array ans. Answers within 10-5 of the actual answer will be accepted.\nNote that:\n\nKelvin = Celsius + 273.15\nFahrenheit = Celsius * 1.80 + 32.00",
        "examples": [
            "Input: celsius = 36.50\nOutput: [309.65000,97.70000]\nExplanation: Temperature at 36.50 Celsius converted in Kelvin is 309.65 and converted in Fahrenheit is 97.70.",
            "Input: celsius = 122.11\nOutput: [395.26000,251.79800]\nExplanation: Temperature at 122.11 Celsius converted in Kelvin is 395.26 and converted in Fahrenheit is 251.798."
        ],
        "constraints": "0 <= celsius <= 1000",
        "oracle_code": "class Solution {\n    public double[] convertTemperature(double celsius) {\n        double arr[] = new double[2];\n        arr[1] = (celsius * 9.0/5.0) + 32.0;\n        arr[0] = celsius + 273.15;\n        return arr;\n    }\n}",
        "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe program takes a celsius value and converts it to fahrenheit and kelvin.\\n# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public double[] convertTemperature(double celsius) {\\n        double arr[] = new double[2];\\n        arr[1] = (celsius * 9.0/5.0) + 32.0;\\n        arr[0] = celsius + 273.15;\\n        return arr;\\n    }\\n}\\n```",
        "level": "easy",
        "type": [
            "operation error",
            "parentheses mismatch",
            "indexing error",
            "undefined objects"
        ],
        "buggy_code": "\n```java\nclass Solution {\n    public double[] convertTemperature(double celsius) {\n        double arr[] = new double[2];\n        UndefinedObject obj;  \n        arr[2 = (obj.celsius * 9.0/5.0) + 32.0;\n        arr[0] = obj.celsius + 237.15;\n        return arr;\n    }\n}\n```\n"
    },
    {
        "slug": "groups-of-strings",
        "description": "You are given a 0-indexed array of strings words. Each string consists of lowercase English letters only. No letter occurs more than once in any string of words.\nTwo strings s1 and s2 are said to be connected if the set of letters of s2 can be obtained from the set of letters of s1 by any one of the following operations:\n\nAdding exactly one letter to the set of the letters of s1.\nDeleting exactly one letter from the set of the letters of s1.\nReplacing exactly one letter from the set of the letters of s1 with any letter, including itself.\n\nThe array words can be divided into one or more non-intersecting groups. A string belongs to a group if any one of the following is true:\n\nIt is connected to at least one other string of the group.\nIt is the only string present in the group.\n\nNote that the strings in words should be grouped in such a manner that a string belonging to a group cannot be connected to a string present in any other group. It can be proved that such an arrangement is always unique.\nReturn an array ans of size 2 where:\n\nans[0] is the maximum number of groups words can be divided into, and\nans[1] is the size of the largest group.",
        "examples": [
            "Input: words = [\"a\",\"b\",\"ab\",\"cde\"]\nOutput: [2,3]\nExplanation:\n- words[0] can be used to obtain words[1] (by replacing 'a' with 'b'), and words[2] (by adding 'b'). So words[0] is connected to words[1] and words[2].\n- words[1] can be used to obtain words[0] (by replacing 'b' with 'a'), and words[2] (by adding 'a'). So words[1] is connected to words[0] and words[2].\n- words[2] can be used to obtain words[0] (by deleting 'b'), and words[1] (by deleting 'a'). So words[2] is connected to words[0] and words[1].\n- words[3] is not connected to any string in words.\nThus, words can be divided into 2 groups [\"a\",\"b\",\"ab\"] and [\"cde\"]. The size of the largest group is 3.",
            "Input: words = [\"a\",\"ab\",\"abc\"]\nOutput: [1,3]\nExplanation:\n- words[0] is connected to words[1].\n- words[1] is connected to words[0] and words[2].\n- words[2] is connected to words[1].\nSince all strings are connected to each other, they should be grouped together.\nThus, the size of the largest group is 3."
        ],
        "constraints": "1 <= words.length <= 2 * 104\n1 <= words[i].length <= 26\nwords[i] consists of lowercase English letters only.\nNo letter occurs more than once in words[i].",
        "oracle_code": "class Solution {\n    public int[] groupStrings(String[] words) {\n        int n = words.length;\n        Map<Integer, Integer> maskToIndex = new HashMap<>();\n        int[] masks = new int[n];\n        for (int i = 0; i < n; i++) {\n            for (char ch : words[i].toCharArray()) {\n                masks[i] |= (1 << ch - 'a');\n            }\n            maskToIndex.put(masks[i], i);\n        }\n        \n        DisjointSet disjointSet = new DisjointSet(n);\n        for (int i = 0; i < n; i++) {\n            // This is necessary to union the duplicate words\n            disjointSet.union(i, maskToIndex.get(masks[i]));\n            for (char ch : words[i].toCharArray()) {\n                // Removing ch from the word\n                int maskWithoutCh = masks[i] ^ (1 << ch - 'a');\n                if (maskToIndex.containsKey(maskWithoutCh)) {\n                    disjointSet.union(i, maskToIndex.get(maskWithoutCh));\n                }\n                \n                // Replace ch with any other charactor\n                for (int j = 0; j < 26; j++) {\n\t\t\t\t\t// Skip if the word already contains the char at j\n                    if (j == ch - 'a' || (maskWithoutCh | (1 << j)) == maskWithoutCh) {\n                        continue;\n                    }\n                    int maskWithReplace = maskWithoutCh | (1 << j);\n                    if (maskToIndex.containsKey(maskWithReplace)) {\n                        disjointSet.union(i, maskToIndex.get(maskWithReplace));\n                    }\n                }\n            }\n        }\n        return disjointSet.getState();\n    }\n\n    private final class DisjointSet {\n        private int[] parent;\n        private int[] size;\n        private int groupCount;\n        private int maxSize;\n        \n        DisjointSet(int n) {\n            groupCount = n;\n            maxSize = 1;\n            parent = new int[n];\n            size = new int[n];\n            for (int i = 0; i < n; i++) {\n                parent[i] = i;\n                size[i] = 1;\n            }\n        }\n        \n        public int find(int a) {\n            if (parent[a] != a) {\n                parent[a] = find(parent[a]);\n            }\n            return parent[a];\n        }\n        \n        public void union(int a, int b) {\n            if (a == b) {\n                return;\n            }\n            int pa = find(a);\n            int pb = find(b);\n            if (pa != pb) {\n\t\t\t\t// Improving the runtime for find operations by joining the small group to large one\n                if (size[pb] < size[pa]) {\n                    parent[pa] = pb;\n                    size[pb] += size[pa];\n                    maxSize = Math.max(maxSize, size[pb]);\n                } else {\n                    parent[pb] = pa;\n                    size[pa] += size[pb];\n                    maxSize = Math.max(maxSize, size[pa]);\n                }\n                groupCount--;\n            }\n        }\n        \n        public int[] getState() {\n            return new int[]{groupCount, maxSize};\n        }\n    }\n}",
        "content": "My O(26 * 26 * n) solution using union-find + bitmask. using a couple of ideas to optimize the runtime. Beat 100% with ~600ms runtime.\\n\\n```\\nclass Solution {\\n    public int[] groupStrings(String[] words) {\\n        int n = words.length;\\n        Map<Integer, Integer> maskToIndex = new HashMap<>();\\n        int[] masks = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            for (char ch : words[i].toCharArray()) {\\n                masks[i] |= (1 << ch - \\'a\\');\\n            }\\n            maskToIndex.put(masks[i], i);\\n        }\\n        \\n        DisjointSet disjointSet = new DisjointSet(n);\\n        for (int i = 0; i < n; i++) {\\n            // This is necessary to union the duplicate words\\n            disjointSet.union(i, maskToIndex.get(masks[i]));\\n            for (char ch : words[i].toCharArray()) {\\n                // Removing ch from the word\\n                int maskWithoutCh = masks[i] ^ (1 << ch - \\'a\\');\\n                if (maskToIndex.containsKey(maskWithoutCh)) {\\n                    disjointSet.union(i, maskToIndex.get(maskWithoutCh));\\n                }\\n                \\n                // Replace ch with any other charactor\\n                for (int j = 0; j < 26; j++) {\\n\\t\\t\\t\\t\\t// Skip if the word already contains the char at j\\n                    if (j == ch - \\'a\\' || (maskWithoutCh | (1 << j)) == maskWithoutCh) {\\n                        continue;\\n                    }\\n                    int maskWithReplace = maskWithoutCh | (1 << j);\\n                    if (maskToIndex.containsKey(maskWithReplace)) {\\n                        disjointSet.union(i, maskToIndex.get(maskWithReplace));\\n                    }\\n                }\\n            }\\n        }\\n        return disjointSet.getState();\\n    }\\n\\n    private final class DisjointSet {\\n        private int[] parent;\\n        private int[] size;\\n        private int groupCount;\\n        private int maxSize;\\n        \\n        DisjointSet(int n) {\\n            groupCount = n;\\n            maxSize = 1;\\n            parent = new int[n];\\n            size = new int[n];\\n            for (int i = 0; i < n; i++) {\\n                parent[i] = i;\\n                size[i] = 1;\\n            }\\n        }\\n        \\n        public int find(int a) {\\n            if (parent[a] != a) {\\n                parent[a] = find(parent[a]);\\n            }\\n            return parent[a];\\n        }\\n        \\n        public void union(int a, int b) {\\n            if (a == b) {\\n                return;\\n            }\\n            int pa = find(a);\\n            int pb = find(b);\\n            if (pa != pb) {\\n\\t\\t\\t\\t// Improving the runtime for find operations by joining the small group to large one\\n                if (size[pb] < size[pa]) {\\n                    parent[pa] = pb;\\n                    size[pb] += size[pa];\\n                    maxSize = Math.max(maxSize, size[pb]);\\n                } else {\\n                    parent[pb] = pa;\\n                    size[pa] += size[pb];\\n                    maxSize = Math.max(maxSize, size[pa]);\\n                }\\n                groupCount--;\\n            }\\n        }\\n        \\n        public int[] getState() {\\n            return new int[]{groupCount, maxSize};\\n        }\\n    }\\n}\\n```",
        "level": "hard",
        "type": [
            "parentheses mismatch",
            "indexing error",
            "undefined keywords from other languages",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution {\n    public int[] groupStrings(String[] words) {\n        int n = words.length;\n        Map<Integer, Integer> maskToIndex = new HashMap<>();\n        int[] masks = new int[n+1];\n        for (int i = 0; i <= n; i++) {\n            for (char ch : words[i].toCharArray()) {\n                masks[i] |= (1 << ch - 'a');\n            }\n            maskToIndex.put(masks[i], i);\n        }\n\n        DisjointSet disjointSet = new DisjointSet(n);\n        for (int i = 0; i < n; i++) {\n            disjointSet.union(i, maskToIndex.get(masks[i]));\n            for (char ch : words[i].toCharArray()) {\n                int maskWithoutCh = masks[i] ^ (1 << ch - 'a';\n                if (maskToIndex.containsKey(maskWithoutCh)) {\n                    disjointSet.union(i, maskToIndex.get(maskWithoutCh));\n                }\nfor (int j = 0; j < 26; j++) {\n                    if (j == ch - 'a' || (maskWithoutCh | (1 << j)) == maskWithoutCh) {\n                        continue;\n                    }\n                    int maskWithReplace = maskWithoutCh | (1 << j);\n                    if (maskToIndex.containsKey(maskWithReplace)) {\n                        disjointSet.union(i, maskToIndex.get(maskWithReplace); \n                    }\n                }\n            }\n        }\n        return disjointSet.getState();\n    }\n\n    private final class DisjointSet {\n        private int[] parent;\n        private int[] size;\n        private int groupCount;\n        private int maxSize;\n\n        DisjointSet(int n) {\n            groupCount = n;\n            maxSize = 1;\n            parent = new int[n];\n            size = new int[n];\n            for (int i = 0; i < n; i++) {\n                parent[i] = i;\n                size[i] = 1;\n            }\n        }\n\n        public def find(int a) {\n            if (parent[a] != a) {\n                parent[a] = find(parent[a]);\n            }\n            return parent[a];\n        }\n\n        public void union(int a, int b) {\n            if (a == b) {\n                return;\n            }\n            int pa = find(a);\n            int pb = find(b);\n            if (pa != pb) {\n                if (size[pb] < size[pa]) {\n                    parent[pa] = pb;\n                    size[pb] += size[pa];\n                    maxSize = Math.max(maxSize, size[pb]);\n                } else {\n                    parent[pb] = pa;\n                    size[pa] += size[pb];\n                    maxSize = Math.max(maxSize, size[pa]);\n                }\n                groupCount--;\n            }\n        }\n\n        public int[] getState() {\n            return new int[]{groupCount, maxSize};\n        }\n    }\n}\n"
    },
    {
        "slug": "rotating-the-box",
        "description": "You are given an m x n matrix of characters box representing a side-view of a box. Each cell of the box is one of the following:\n\nA stone '#'\nA stationary obstacle '*'\nEmpty '.'\n\nThe box is rotated 90 degrees clockwise, causing some of the stones to fall due to gravity. Each stone falls down until it lands on an obstacle, another stone, or the bottom of the box. Gravity does not affect the obstacles' positions, and the inertia from the box's rotation does not affect the stones' horizontal positions.\nIt is guaranteed that each stone in box rests on an obstacle, another stone, or the bottom of the box.\nReturn an n x m matrix representing the box after the rotation described above.",
        "examples": [
            "Input: box = [[\"#\",\".\",\"#\"]]\r\nOutput: [[\".\"],\r\n\u00a0        [\"#\"],\r\n\u00a0        [\"#\"]]",
            "Input: box = [[\"#\",\".\",\"*\",\".\"],\r\n\u00a0             [\"#\",\"#\",\"*\",\".\"]]\r\nOutput: [[\"#\",\".\"],\r\n\u00a0        [\"#\",\"#\"],\r\n\u00a0        [\"*\",\"*\"],\r\n\u00a0        [\".\",\".\"]]",
            "Input: box = [[\"#\",\"#\",\"*\",\".\",\"*\",\".\"],\r\n\u00a0             [\"#\",\"#\",\"#\",\"*\",\".\",\".\"],\r\n\u00a0             [\"#\",\"#\",\"#\",\".\",\"#\",\".\"]]\r\nOutput: [[\".\",\"#\",\"#\"],\r\n\u00a0        [\".\",\"#\",\"#\"],\r\n\u00a0        [\"#\",\"#\",\"*\"],\r\n\u00a0        [\"#\",\"*\",\".\"],\r\n\u00a0        [\"#\",\".\",\"*\"],\r\n\u00a0        [\"#\",\".\",\".\"]]"
        ],
        "constraints": "m == box.length\nn == box[i].length\n1 <= m, n <= 500\nbox[i][j] is either '#', '*', or '.'.",
        "oracle_code": "// O(n^2) time | O(n^2) space\nclass Solution {\n    public char[][] rotateTheBox(char[][] box) {\n        int m = box.length;\n        int n = box[0].length;\n        char[][] matrix = new char[n][m];   \n        \n        turnBox(box, matrix, m, n); // turn the box clockwise 90 degree\n        \n        turnGravity(matrix, n, m); // cause that falling effect, since matrix turned so n,m\n        \n        return matrix;\n    }\n    \n    public void turnGravity(char[][] matrix, int m, int n){\n        for(int c = 0; c < n; c++){\n            int last  = m-1;\n            for(int r = m-1; r >= 0; r--){\n                char val =  matrix[r][c];\n                if(val == '.') continue;\n                if(val == '*') last = r-1;\n                if(val == '#') {\n                    matrix[r][c] = '.';\n                    matrix[last][c] = '#';\n                    last--;\n                }\n            }\n        }\n    }\n    \n    public void turnBox(char[][] box, char[][] matrix, int m, int n){\n\t// numbers represents sequence it would be copied\n\t//[4][1]\n\t//[5][2]\n\t//[6][3]\n        for(int i = 0, c = m-1; i < m; i++,c--){ // c: 4,3,2,1..\n            for(int j = 0, r = 0; j < n; j++, r++){ // r:0,1,2,3..\n               matrix[r][c] = box[i][j];\n            }\n        }\n    }\n}",
        "content": "**So idea here is**\\n1. First turn 90 degree\\n2. Make things fall\\n\\n```\\n// O(n^2) time | O(n^2) space\\nclass Solution {\\n    public char[][] rotateTheBox(char[][] box) {\\n        int m = box.length;\\n        int n = box[0].length;\\n        char[][] matrix = new char[n][m];   \\n        \\n        turnBox(box, matrix, m, n); // turn the box clockwise 90 degree\\n        \\n        turnGravity(matrix, n, m); // cause that falling effect, since matrix turned so n,m\\n        \\n        return matrix;\\n    }\\n    \\n    public void turnGravity(char[][] matrix, int m, int n){\\n        for(int c = 0; c < n; c++){\\n            int last  = m-1;\\n            for(int r = m-1; r >= 0; r--){\\n                char val =  matrix[r][c];\\n                if(val == \\'.\\') continue;\\n                if(val == \\'*\\') last = r-1;\\n                if(val == \\'#\\') {\\n                    matrix[r][c] = \\'.\\';\\n                    matrix[last][c] = \\'#\\';\\n                    last--;\\n                }\\n            }\\n        }\\n    }\\n    \\n    public void turnBox(char[][] box, char[][] matrix, int m, int n){\\n\\t// numbers represents sequence it would be copied\\n\\t//[4][1]\\n\\t//[5][2]\\n\\t//[6][3]\\n        for(int i = 0, c = m-1; i < m; i++,c--){ // c: 4,3,2,1..\\n            for(int j = 0, r = 0; j < n; j++, r++){ // r:0,1,2,3..\\n               matrix[r][c] = box[i][j];\\n            }\\n        }\\n    }\\n}\\n```",
        "level": "medium",
        "type": [
            "== and = confusion",
            "other error",
            "wrong comment mark",
            "indexing error"
        ],
        "buggy_code": "\n// O(n^2) time | O(n^2) space\nclass Solution {\n    public char[][] rotateTheBox(char[][] box) {\n        int m = box.length;\n        int n = box[0].length + 1; \n        char[][] matrix = new char[n][m];   \n        \n        turnBox(box, matrix, m, n); // turn the box clockwise 90 degree\n        \n        turnGravity(matrix, n, m); ' cause that falling effect, since matrix turned so n,m\n        \n        return matrix;\n    }\n    \n    public void turnGravity(char[][] matrix, int m, int n){\n        for(int c = 0; c < n; c++){\n            int last  = m-1;\n            for(int r = m-1; r >= 0; r--){\n                char val =  matrix[r][c];\n                if(val == '.') continue;\n                if(val = '*') last = r-1;  \n                if(val == '#') {\n                    matrix[r][c] = '.';\n                    matrix[last][c] = '#';\n                }\n            }\n        }\n    }\n    \n    public void turnBox(char[][] box, char[][] matrix, int m, int n){\n        for(int i = 0, c = m-1; i < m; i++,c--){\n            for(int j = 0, r = 0; j < n; j++, r++){\n               matrix[r][1] = box[i][j];\n            }\n        }\n    }\n}\n"
    },
    {
        "slug": "number-of-laser-beams-in-a-bank",
        "description": "Anti-theft security devices are activated inside a bank. You are given a 0-indexed binary string array bank representing the floor plan of the bank, which is an m x n 2D matrix. bank[i] represents the ith row, consisting of '0's and '1's. '0' means the cell is empty, while'1' means the cell has a security device.\nThere is one laser beam between any two security devices if both conditions are met:\n\nThe two devices are located on two different rows: r1 and r2, where r1 < r2.\nFor each row i where r1 < i < r2, there are no security devices in the ith row.\n\nLaser beams are independent, i.e., one beam does not interfere nor join with another.\nReturn the total number of laser beams in the bank.",
        "examples": [
            "Input: bank = [\"011001\",\"000000\",\"010100\",\"001000\"]\nOutput: 8\nExplanation: Between each of the following device pairs, there is one beam. In total, there are 8 beams:\n * bank[0][1] -- bank[2][1]\n * bank[0][1] -- bank[2][3]\n * bank[0][2] -- bank[2][1]\n * bank[0][2] -- bank[2][3]\n * bank[0][5] -- bank[2][1]\n * bank[0][5] -- bank[2][3]\n * bank[2][1] -- bank[3][2]\n * bank[2][3] -- bank[3][2]\nNote that there is no beam between any device on the 0th row with any on the 3rd row.\nThis is because the 2nd row contains security devices, which breaks the second condition.",
            "Input: bank = [\"000\",\"111\",\"000\"]\nOutput: 0\nExplanation: There does not exist two devices located on two different rows."
        ],
        "constraints": "m == bank.length\nn == bank[i].length\n1 <= m, n <= 500\nbank[i][j] is either '0' or '1'.",
        "oracle_code": "class Solution {\n    public int numberOfBeams(String[] bank) {\n        int prevLazer =0;\n        int ans =0;\n        for(String s:bank){\n            int curLazer = 0;\n            for(char c: s.toCharArray()){\n                if(c=='1'){\n                    curLazer++;\n                }\n            }\n            if(curLazer >0){\n                ans += (curLazer * prevLazer);\n                prevLazer = curLazer;\n            }\n        }\n        return ans;\n    }\n}",
        "content": "\\n# java Code\\n```\\nclass Solution {\\n    public int numberOfBeams(String[] bank) {\\n        int prevLazer =0;\\n        int ans =0;\\n        for(String s:bank){\\n            int curLazer = 0;\\n            for(char c: s.toCharArray()){\\n                if(c==\\'1\\'){\\n                    curLazer++;\\n                }\\n            }\\n            if(curLazer >0){\\n                ans += (curLazer * prevLazer);\\n                prevLazer = curLazer;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
        "level": "medium",
        "type": [
            "variable value error",
            "parentheses mismatch",
            "wrong comment mark",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution {\n    public int numberOfBeams(String[] bank) {\n        int prevLazer =0;\n        int ans =0;\n        for(String s:bank){\n            int curLazer = 0;\n            for(char c: s.toCharArray()){\n                if(c=='1){\n                    curLazer++;\n            }\n\n                ans += (curLazer * prevLazer);\n                prevLazer = curLazer;\n            } else {\n                prevLazer = 0;\n            return ans;\n    }\n}\n        return \"The total number of beams is: \" + ans;\n    \n}\n\n"
    },
    {
        "slug": "probability-of-a-two-boxes-having-the-same-number-of-distinct-balls",
        "description": "Given 2n balls of k distinct colors. You will be given an integer array balls of size k where balls[i] is the number of balls of color i.\nAll the balls will be shuffled uniformly at random, then we will distribute the first n balls to the first box and the remaining n balls to the other box (Please read the explanation of the second example carefully).\nPlease note that the two boxes are considered different. For example, if we have two balls of colors a and b, and two boxes [] and (), then the distribution [a] (b) is considered different than the distribution [b] (a) (Please read the explanation of the first example carefully).\nReturn the probability that the two boxes have the same number of distinct balls. Answers within 10-5 of the actual value will be accepted as correct.",
        "examples": [
            "Input: balls = [1,1]\nOutput: 1.00000\nExplanation: Only 2 ways to divide the balls equally:\n- A ball of color 1 to box 1 and a ball of color 2 to box 2\n- A ball of color 2 to box 1 and a ball of color 1 to box 2\nIn both ways, the number of distinct colors in each box is equal. The probability is 2/2 = 1",
            "Input: balls = [2,1,1]\nOutput: 0.66667\nExplanation: We have the set of balls [1, 1, 2, 3]\nThis set of balls will be shuffled randomly and we may have one of the 12 distinct shuffles with equal probability (i.e. 1/12):\n[1,1 / 2,3], [1,1 / 3,2], [1,2 / 1,3], [1,2 / 3,1], [1,3 / 1,2], [1,3 / 2,1], [2,1 / 1,3], [2,1 / 3,1], [2,3 / 1,1], [3,1 / 1,2], [3,1 / 2,1], [3,2 / 1,1]\nAfter that, we add the first two balls to the first box and the second two balls to the second box.\nWe can see that 8 of these 12 possible random distributions have the same number of distinct colors of balls in each box.\nProbability is 8/12 = 0.66667",
            "Input: balls = [1,2,1,2]\nOutput: 0.60000\nExplanation: The set of balls is [1, 2, 2, 3, 4, 4]. It is hard to display all the 180 possible random shuffles of this set but it is easy to check that 108 of them will have the same number of distinct colors in each box.\nProbability = 108 / 180 = 0.6"
        ],
        "constraints": "1 <= balls.length <= 8\n1 <= balls[i] <= 6\nsum(balls) is even.",
        "oracle_code": "class Solution {\n    double possible = 0.0;\n    double valid = 0.0;\n    \n    public double getProbability(int[] balls) {\n        int[] first = new int[balls.length];\n        int[] second = new int[balls.length];\n        dfs(balls, first, second, 0, 0, 0);\n        return valid / possible;\n    }\n    \n    private void dfs(int[] balls, int[] first, int[] second, int num1, int num2, int idx) {\n        // finish all colors, check if this's a possible/valid distribution\n        if (idx == balls.length) {\n            // find one possible distribution\n            if (num1 == num2) {\n                // compute fake permutation\n                double distrib = permFake(first) * permFake(second);\n                possible += distrib;\n                \n                // find one valid distribution\n                if (unique(first) == unique(second)) {\n                    valid += distrib;\n                }\n            }\n            return;\n        }\n        \n        // distribute balls in current color to two bins\n        for (int b = 0; b <= balls[idx]; b++) {\n            first[idx] = b;\n            second[idx] = balls[idx] - b;\n            dfs (balls, first, second, num1 + first[idx], num2 + second[idx], idx + 1);\n        }\n    }\n    \n    // unique colors in \n    private int unique(int[] balls) {\n        int unique = 0;\n        for (int b: balls)\n            unique += b > 0 ? 1 : 0;\n        return unique;\n    }\n    \n    // return 1 / (b1!b2!b3!...bn!) \n    private double permFake(int[] balls) {\n        double ret = 1.0;\n        for (int b: balls)\n            ret /= factorial(b);\n        return ret;\n    }\n    \n    private int factorial(int n){\n        int ret = 1;\n        while (n > 0) {\n            ret *= n;\n            n--;\n        }\n        return ret;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    double possible = 0.0;\\n    double valid = 0.0;\\n    \\n    public double getProbability(int[] balls) {\\n        int[] first = new int[balls.length];\\n        int[] second = new int[balls.length];\\n        dfs(balls, first, second, 0, 0, 0);\\n        return valid / possible;\\n    }\\n    \\n    private void dfs(int[] balls, int[] first, int[] second, int num1, int num2, int idx) {\\n        // finish all colors, check if this\\'s a possible/valid distribution\\n        if (idx == balls.length) {\\n            // find one possible distribution\\n            if (num1 == num2) {\\n                // compute fake permutation\\n                double distrib = permFake(first) * permFake(second);\\n                possible += distrib;\\n                \\n                // find one valid distribution\\n                if (unique(first) == unique(second)) {\\n                    valid += distrib;\\n                }\\n            }\\n            return;\\n        }\\n        \\n        // distribute balls in current color to two bins\\n        for (int b = 0; b <= balls[idx]; b++) {\\n            first[idx] = b;\\n            second[idx] = balls[idx] - b;\\n            dfs (balls, first, second, num1 + first[idx], num2 + second[idx], idx + 1);\\n        }\\n    }\\n    \\n    // unique colors in \\n    private int unique(int[] balls) {\\n        int unique = 0;\\n        for (int b: balls)\\n            unique += b > 0 ? 1 : 0;\\n        return unique;\\n    }\\n    \\n    // return 1 / (b1!b2!b3!...bn!) \\n    private double permFake(int[] balls) {\\n        double ret = 1.0;\\n        for (int b: balls)\\n            ret /= factorial(b);\\n        return ret;\\n    }\\n    \\n    private int factorial(int n){\\n        int ret = 1;\\n        while (n > 0) {\\n            ret *= n;\\n            n--;\\n        }\\n        return ret;\\n    }\\n}\\n```",
        "level": "hard",
        "type": [
            "operation error",
            "== and = confusion",
            "colon missing",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\n    double possible = 0.0;\n    double valid = 0.0;\n    \n    public double getProbability(int[] balls) {\n        int[] first = new int[balls.length];\n        int[] second = new int[balls.length];\n        dfs(balls, first, second, 0, 0, 0)\n        return valid / possible;\n    }\n    \n    private void dfs(int[] balls, int[] first, int[] second, int num1, int num2, int idx) {\n        if (idx == balls.length) {if (num1 = num2) {\n                double distrib = permFake(first) * permFake(second);\n                possible += distrib;\n                if (unique(first) == unique(second)) {\n                    valid += distrib + 1;    \n                }\n            }\n            return;\n        }\n        for (int b = 0; b <= balls[idx]; b++) {\n            first[idx] = b;\n            second[idx] = balls[idx] - b;\n            dfs (balls, first, second, num1 + first[idx], num2 + second[idx], idx + 1);\n        }\n    }\n    \n    private int([] balls) {\n       =0;for ( b: balls)\n           + b >?10;returnprivate int factorial(int n){\n        int ret = 1;\n        while (n > 0) {\n            ret *= n;\n            n--;\n        }\n        return ret;\n    }\n}\n"
    },
    {
        "slug": "daily-temperatures",
        "description": "Given an array of integers temperatures represents the daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after the ith day to get a warmer temperature. If there is no future day for which this is possible, keep answer[i] == 0 instead.",
        "examples": [
            "Input: temperatures = [73,74,75,71,69,72,76,73]\nOutput: [1,1,4,2,1,1,0,0]",
            "Input: temperatures = [30,40,50,60]\nOutput: [1,1,1,0]",
            "Input: temperatures = [30,60,90]\nOutput: [1,1,0]"
        ],
        "constraints": "1 <=\u00a0temperatures.length <= 105\n30 <=\u00a0temperatures[i] <= 100",
        "oracle_code": "class Solution {\n    public int[] dailyTemperatures(int[] temperatures) {\n        \n        int[] arr = new int[temperatures.length]; \n        \n        ArrayDeque<int[]> st = new ArrayDeque<>(); \n        \n        int i=0, j=temperatures.length-1 ; \n        \n        while( j >= 0){\n            \n            if(st.size()==0){\n                arr[i++] = 0;\n            }\n            else  if (st.size()>0 && st.peek()[0]>temperatures[j])\n            {\n                arr[i++]=1;\n            } \n            else if (st.size()>0 && st.peek()[0]<=temperatures[j])\n            \n            {  while(st.size()>0 && st.peek()[0]<=temperatures[j]){\n                    st.pop();\n                    \n                }\n            if(st.size()==0){\n                arr[i++]=0;\n            }\n            else{\n                arr[i++]=st.peek()[1]-j;\n            }\n            } \n        st.push(new int[]{temperatures[j],j}); \n        j--;\n        }\n        \n      \n        int[] ans = new int[temperatures.length]; int k=0;\n        for(i=arr.length-1; i>=0; i--){\n            ans[k++]=arr[i];\n        }\n        return ans;\n    }\n}",
        "content": "```\\nclass Solution {\\n    public int[] dailyTemperatures(int[] temperatures) {\\n        \\n        int[] arr = new int[temperatures.length]; \\n        \\n        ArrayDeque<int[]> st = new ArrayDeque<>(); \\n        \\n        int i=0, j=temperatures.length-1 ; \\n        \\n        while( j >= 0){\\n            \\n            if(st.size()==0){\\n                arr[i++] = 0;\\n            }\\n            else  if (st.size()>0 && st.peek()[0]>temperatures[j])\\n            {\\n                arr[i++]=1;\\n            } \\n            else if (st.size()>0 && st.peek()[0]<=temperatures[j])\\n            \\n            {  while(st.size()>0 && st.peek()[0]<=temperatures[j]){\\n                    st.pop();\\n                    \\n                }\\n            if(st.size()==0){\\n                arr[i++]=0;\\n            }\\n            else{\\n                arr[i++]=st.peek()[1]-j;\\n            }\\n            } \\n        st.push(new int[]{temperatures[j],j}); \\n        j--;\\n        }\\n        \\n      \\n        int[] ans = new int[temperatures.length]; int k=0;\\n        for(i=arr.length-1; i>=0; i--){\\n            ans[k++]=arr[i];\\n        }\\n        return ans;\\n    }\\n}",
        "level": "medium",
        "type": [
            "wrong comment mark",
            "indexing error",
            "undefined keywords from other languages",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\n    public int[] dailyTemperatures(int[] temperatures) {\n        \n        let[] arr = new let[temperatures.length + 1]; \n        \n        ArrayDeque<int[]> st = new ArrayDeque<>(); \n        \n        int i=0, j=temperatures.length-1 ; \n        \n        while( j >= 0){\n            \n            /*if(st.size()==0){\n                arr[i++] = 0;\n            }\n            else if (st.size()>0 && st.peek()[0]>temperatures[j])\n            {\n                arr[i++]=1;\n            } \n            else if (st.size()>0 && st.peek()[0]<=temperatures[j])\n            \n            {  while(st.size()>0 && st.peek()[0]<=temperatures[j]){\n                    st.pop();\n                    \n                }\n            if(st.size()==0){\n                arr[i++]=0;\n            }\n            else{\n                arr[i++]=st.peek()[1]-j;\n            }\n            } */\n\n        doSomething();\n\n        st.push(new int[]{temperatures[j],j}); \n        j--;\n        }\n        \n      \n        let[] ans = new let[temperatures.length + 1]; int k=0;\n        for(i=arr.length-1; i>=0; i--){\n            ans[k++]=arr[i];\n        }\n        return ans;\n    }\n}\n"
    },
    {
        "slug": "relative-ranks",
        "description": "You are given an integer array score of size n, where score[i] is the score of the ith athlete in a competition. All the scores are guaranteed to be unique.\nThe athletes are placed based on their scores, where the 1st place athlete has the highest score, the 2nd place athlete has the 2nd highest score, and so on. The placement of each athlete determines their rank:\n\nThe 1st place athlete's rank is \"Gold Medal\".\nThe 2nd place athlete's rank is \"Silver Medal\".\nThe 3rd place athlete's rank is \"Bronze Medal\".\nFor the 4th place to the nth place athlete, their rank is their placement number (i.e., the xth place athlete's rank is \"x\").\n\nReturn an array answer of size n where answer[i] is the rank of the ith athlete.",
        "examples": [
            "Input: score = [5,4,3,2,1]\nOutput: [\"Gold Medal\",\"Silver Medal\",\"Bronze Medal\",\"4\",\"5\"]\nExplanation: The placements are [1st, 2nd, 3rd, 4th, 5th].",
            "Input: score = [10,3,8,9,4]\nOutput: [\"Gold Medal\",\"5\",\"Bronze Medal\",\"Silver Medal\",\"4\"]\nExplanation: The placements are [1st, 5th, 3rd, 2nd, 4th]."
        ],
        "constraints": "n == score.length\n1 <= n <= 104\n0 <= score[i] <= 106\nAll the values in score are unique.",
        "oracle_code": "class Solution {\n    public String[] findRelativeRanks(int[] score) {\n         int n=score.length;\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[b]-score[a]);\n        for(int i=0;i<n;i++) pq.add(i);\n      String[] ans = new String[n];\n                int i=1;\n        while(!pq.isEmpty()){\n            int idx=pq.poll();\n         if(i==1)   { ans[idx]=\"Gold Medal\"; i++;}\n         else if(i==2)   { ans[idx]=\"Silver Medal\"; i++;}\n         else if(i==3)   { ans[idx]=\"Bronze Medal\"; i++;}\n         else ans[idx]=Integer.toString(i++);\n        }\n        return ans;  \n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String[] findRelativeRanks(int[] score) {\\n         int n=score.length;\\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[b]-score[a]);\\n        for(int i=0;i<n;i++) pq.add(i);\\n      String[] ans = new String[n];\\n                int i=1;\\n        while(!pq.isEmpty()){\\n            int idx=pq.poll();\\n         if(i==1)   { ans[idx]=\"Gold Medal\"; i++;}\\n         else if(i==2)   { ans[idx]=\"Silver Medal\"; i++;}\\n         else if(i==3)   { ans[idx]=\"Bronze Medal\"; i++;}\\n         else ans[idx]=Integer.toString(i++);\\n        }\\n        return ans;  \\n    }\\n}\\n```",
        "level": "easy",
        "type": [
            "== and = confusion",
            "undefined keywords from other languages",
            "unclosed string",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\n    public String[] findRelativeRanks(int[] score) {\n         int n=score.length;\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[b]-score[a]);\n        for(int i=0;i<n;i++) pq.add(i);\n        String[] ans = new String[n];\n        int i=1;\n        while(!pq.isEmpty()){\n            int idx=pq.poll();\n            if(i=1) { ans[idx]=\"Gold Medal; i++;} \n            elif(i=2) { ans[idx]=\"Silver Medal; i++;} \n            else if(i=3) { ans[idx]=\"Bronze Medal; i++;} \n            else ans[idx]=Integer.toString(i++);\n        }\n        return reorderArray(ans);  \n    }\n\n    private String[] reorderArray(String[] ranks){\n        \n    }\n}\n"
    },
    {
        "slug": "n-queens",
        "description": "The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.\nGiven an integer n, return all distinct solutions to the n-queens puzzle. You may return the answer in any order.\nEach solution contains a distinct board configuration of the n-queens' placement, where 'Q' and '.' both indicate a queen and an empty space, respectively.",
        "examples": [
            "Input: n = 4\nOutput: [[\".Q..\",\"...Q\",\"Q...\",\"..Q.\"],[\"..Q.\",\"Q...\",\"...Q\",\".Q..\"]]\nExplanation: There exist two distinct solutions to the 4-queens puzzle as shown above",
            "Input: n = 1\nOutput: [[\"Q\"]]"
        ],
        "constraints": "1 <= n <= 9",
        "oracle_code": "class Solution {\n    public List<List<String>> solveNQueens(int n) {\n        \n        char [][] board = new char[n][n];\n        for(int i = 0; i < board.length; i++) {\n            for(int j = 0; j < board.length; j++) {\n                board[i][j] = '.';\n            }\n        }\n        \n        List<List<String>> ans = new ArrayList<>();\n        queen(board, 0, ans);\n        return ans;\n    }\n\n    static void queen(char[][] board, int row, List<List<String>> list) {\n\n        if(row == board.length) {\n\n            list.add(construct(board));\n            return;\n        }\n\n        for (int col = 0; col < board.length; col++) {\n            if(isSafe(board, row, col)) {\n                board[row][col] = 'Q';\n                queen(board, row + 1, list);\n                board[row][col] = '.';\n            }\n        }\n    }\n\n    static List<String> construct(char[][] board) {\n\n        List<String> internal = new ArrayList<>();\n        for (int i = 0; i < board.length; i++) {\n            String row = new String(board[i]);\n            internal.add(row);\n        }\n        return internal;\n    }\n\n    static boolean isSafe(char[][] board, int row, int col) {\n\n        //for checking vertical row\n        for (int i = 0; i < row; i++) {\n            if(board[i][col] == 'Q') {\n                return false;\n            }\n        }\n\n        //for checking left diagonal\n\n        int maxLeft = Math.min(row, col);\n\n        for (int i = 1; i <= maxLeft; i++) {\n            if(board[row - i][col - i] == 'Q') {\n                return false;\n            }\n        }\n\n        //for checking right diagonal\n\n        int maxRight = Math.min(row, board.length - 1 - col);\n\n        for (int i = 1; i <= maxRight; i++) {\n            if(board[row - i][col + i] == 'Q') {\n                return false;\n            }\n        }\n\n        return true;\n    }\n}",
        "content": "# Intuition\\n<!--  -->\\nLet\\'s see the intuition behind this question.\\n\\n![WhatsApp Image 2023-07-12 at 5.11.51 PM.jpeg](https://assets.leetcode.com/users/images/d7c0148d-9d34-4e20-86a9-34da5b670c08_1689162264.640158.jpeg)\\n\\n# Approach\\n<!--  -->\\nSo, now when we know the question requires backtracking and recursion, let\\'s discuss the thought process and the approach!\\n\\n![WhatsApp Image 2023-07-12 at 5.11.52 PM.jpeg](https://assets.leetcode.com/users/images/76f56253-26ea-4299-9d02-604f8c1a88f1_1689162387.0847921.jpeg)\\n![WhatsApp Image 2023-07-12 at 5.11.53 PM.jpeg](https://assets.leetcode.com/users/images/2872576b-425c-48c9-a5c7-ee6c8b960b72_1689162414.789056.jpeg)\\n![WhatsApp Image 2023-07-12 at 5.18.32 PM.jpeg](https://assets.leetcode.com/users/images/74aa66cb-dc07-4001-a353-ae8220a3bf0d_1689162542.4049857.jpeg)\\n\\n## Please upvote if you loved it! \\n\\n![cat.jpeg](https://assets.leetcode.com/users/images/6caea43f-b90d-4e55-befe-e8963ec23424_1689162825.9038785.jpeg)\\n\\n\\n\\n# Complexity\\n- Time complexity: O(n! * n)\\n<!--  -->\\n\\n- Space complexity: O(n^2)\\n<!--  -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<String>> solveNQueens(int n) {\\n        \\n        char [][] board = new char[n][n];\\n        for(int i = 0; i < board.length; i++) {\\n            for(int j = 0; j < board.length; j++) {\\n                board[i][j] = \\'.\\';\\n            }\\n        }\\n        \\n        List<List<String>> ans = new ArrayList<>();\\n        queen(board, 0, ans);\\n        return ans;\\n    }\\n\\n    static void queen(char[][] board, int row, List<List<String>> list) {\\n\\n        if(row == board.length) {\\n\\n            list.add(construct(board));\\n            return;\\n        }\\n\\n        for (int col = 0; col < board.length; col++) {\\n            if(isSafe(board, row, col)) {\\n                board[row][col] = \\'Q\\';\\n                queen(board, row + 1, list);\\n                board[row][col] = \\'.\\';\\n            }\\n        }\\n    }\\n\\n    static List<String> construct(char[][] board) {\\n\\n        List<String> internal = new ArrayList<>();\\n        for (int i = 0; i < board.length; i++) {\\n            String row = new String(board[i]);\\n            internal.add(row);\\n        }\\n        return internal;\\n    }\\n\\n    static boolean isSafe(char[][] board, int row, int col) {\\n\\n        //for checking vertical row\\n        for (int i = 0; i < row; i++) {\\n            if(board[i][col] == \\'Q\\') {\\n                return false;\\n            }\\n        }\\n\\n        //for checking left diagonal\\n\\n        int maxLeft = Math.min(row, col);\\n\\n        for (int i = 1; i <= maxLeft; i++) {\\n            if(board[row - i][col - i] == \\'Q\\') {\\n                return false;\\n            }\\n        }\\n\\n        //for checking right diagonal\\n\\n        int maxRight = Math.min(row, board.length - 1 - col);\\n\\n        for (int i = 1; i <= maxRight; i++) {\\n            if(board[row - i][col + i] == \\'Q\\') {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
        "level": "hard",
        "type": [
            "wrong comment mark",
            "indexing error",
            "undefined objects",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution {\n    public List<List<String>> solveNQueens(int n) {\n        \n        char [][] board = new char[n][n];\n        for(int i = 0; i < board.length; i++) {\n            for(int j = 0; j < board.length; j++) {\n                board[i][j] = '.';\n            }\n        }\n        \n        List<List<String>> ans = new ArrayList<>();\n        queen(null, 0, ans);\n        return ans;\n    }\n\n    static void queen(char[][] board, int row, List<List<String>> list) {\n\n        if(row == board.length) {\n\n            list.add(construct(board));\n            /* return;\n        }\n\n        for (int col = 0; col < board.length+1; col++) {\n            if(isSafe(board, row, col)) {\n                board[row][col] = 'Q';\n                queen(board, row + 1, list);\n                board[row][col] = '.';\n            }\n        }\n    }\n\n    static List<String> construct(char[][] board) {\n\n        List<String> internal = new ArrayList<>();\n        for (int i = 0; i < board.length; i++) {\n            String row = new String(board[i]);\n            internal.add(row);\n        }\n        return internal;\n    }\n\n    static boolean isSafe(char[][] board, int row, int col) {\n\n        //for checking vertical row\n        for (int i = 0; i < row; i++) {\n            if(board[i][col] == 'Q') {\n                return false;\n            }\n        }\n\n        //for checking left diagonal\n\n        int maxLeft = Math.min(row, col);\n\n        for (int i = 1; i <= maxLeft; i++) {\n            if(board[row - i][col - i] == 'Q') {\n                return false;\n            }\n        }\n\n        //for checking right diagonal\n\n        int maxRight = Math.min(row, board.length - 1 - col);\n\n        for (int i = 1; i <= maxRight; i++) {\n            if(board[row - i][col + i] == 'Q') {\n                return false;\n            }\n        }\n\n        return \"true;\n    }\n}\n"
    },
    {
        "slug": "intersection-of-multiple-arrays",
        "description": "Given a 2D integer array nums where nums[i] is a non-empty array of distinct positive integers, return the list of integers that are present in each array of nums sorted in ascending order.",
        "examples": [
            "Input: nums = [[3,1,2,4,5],[1,2,3,4],[3,4,5,6]]\nOutput: [3,4]\nExplanation: \nThe only integers present in each of nums[0] = [3,1,2,4,5], nums[1] = [1,2,3,4], and nums[2] = [3,4,5,6] are 3 and 4, so we return [3,4].",
            "Input: nums = [[1,2,3],[4,5,6]]\nOutput: []\nExplanation: \nThere does not exist any integer present both in nums[0] and nums[1], so we return an empty list []."
        ],
        "constraints": "1 <= nums.length <= 1000\n1 <= sum(nums[i].length) <= 1000\n1 <= nums[i][j] <= 1000\nAll the values of nums[i] are unique.",
        "oracle_code": "class Solution {\n    public List<Integer> intersection(int[][] nums) {\n        \n        List<Integer> ans = new ArrayList<>();\n        \n        int[] count  = new int[1001];\n        \n        for(int[] arr : nums){\n            for(int i : arr){\n                count[i]++;\n            }\n        }\n        \n       for(int i=0;i<count.length;i++){\n           if(count[i]==nums.length){\n               ans.add(i);\n           }\n       }\n        \n        return ans;\n    }\n}",
        "content": "```\\n\\nclass Solution {\\n    public List<Integer> intersection(int[][] nums) {\\n        \\n        List<Integer> ans = new ArrayList<>();\\n        \\n        int[] count  = new int[1001];\\n        \\n        for(int[] arr : nums){\\n            for(int i : arr){\\n                count[i]++;\\n            }\\n        }\\n        \\n       for(int i=0;i<count.length;i++){\\n           if(count[i]==nums.length){\\n               ans.add(i);\\n           }\\n       }\\n        \\n        return ans;\\n    }\\n}\\n\\n```",
        "level": "easy",
        "type": [
            "== and = confusion",
            "colon missing",
            "conditional statement error",
            "wrong comment mark"
        ],
        "buggy_code": "\nclass Solution {\n    public List<Integer> intersection(int[][] nums) {\n        \n        List<Integer> ans = new ArrayList<>();\n        \n        int[] count  = new int[1001]\n        \n        \n            for(int i : arr){\n                count[i]++;\n            }\n        }\n        \n       for(int i=0;i<count.length;i++){\n           if(count[i]=nums.length+1){\n               ans.add(i);\n           }\n       }\n        \n        return ans;\n    }\n}\n"
    },
    {
        "slug": "same-tree",
        "description": "Given the roots of two binary trees p and q, write a function to check if they are the same or not.\nTwo binary trees are considered the same if they are structurally identical, and the nodes have the same value.",
        "examples": [
            "Input: p = [1,2,3], q = [1,2,3]\nOutput: true",
            "Input: p = [1,2], q = [1,null,2]\nOutput: false",
            "Input: p = [1,2,1], q = [1,1,2]\nOutput: false"
        ],
        "constraints": "The number of nodes in both trees is in the range [0, 100].\n-104 <= Node.val <= 104",
        "oracle_code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n   \n    public boolean isSameTree(TreeNode p, TreeNode q) {\n     if (p == null && q == null) {\n            return true;\n        }\n        \n        if (p == null || q == null) {\n            return false;\n        }\n        \n        if (p.val != q.val) {\n            return false;\n        }\n        \n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n\n        \n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n   \\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n     if (p == null && q == null) {\\n            return true;\\n        }\\n        \\n        if (p == null || q == null) {\\n            return false;\\n        }\\n        \\n        if (p.val != q.val) {\\n            return false;\\n        }\\n        \\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n\\n        \\n    }\\n}\\n```",
        "level": "easy",
        "type": [
            "parentheses mismatch",
            "conditional statement error",
            "undefined keywords from other languages",
            "undefined methods"
        ],
        "buggy_code": "\n\n\n\nclass Solution {\n   \n    public boolean isSameTree(TreeNode p, TreeNode q) {\n     if (p == null && q == null) {\n            return true;\n        }\n        \n        if (p == null || q == null) {\n            return false;\n        }\n        \n        if (p.val == q.val) {\n            return false;\n        }\n        \n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n\n        \n    }\n}\n\n=\ncheckubcheckub\n"
    },
    {
        "slug": "relative-ranks",
        "description": "You are given an integer array score of size n, where score[i] is the score of the ith athlete in a competition. All the scores are guaranteed to be unique.\nThe athletes are placed based on their scores, where the 1st place athlete has the highest score, the 2nd place athlete has the 2nd highest score, and so on. The placement of each athlete determines their rank:\n\nThe 1st place athlete's rank is \"Gold Medal\".\nThe 2nd place athlete's rank is \"Silver Medal\".\nThe 3rd place athlete's rank is \"Bronze Medal\".\nFor the 4th place to the nth place athlete, their rank is their placement number (i.e., the xth place athlete's rank is \"x\").\n\nReturn an array answer of size n where answer[i] is the rank of the ith athlete.",
        "examples": [
            "Input: score = [5,4,3,2,1]\nOutput: [\"Gold Medal\",\"Silver Medal\",\"Bronze Medal\",\"4\",\"5\"]\nExplanation: The placements are [1st, 2nd, 3rd, 4th, 5th].",
            "Input: score = [10,3,8,9,4]\nOutput: [\"Gold Medal\",\"5\",\"Bronze Medal\",\"Silver Medal\",\"4\"]\nExplanation: The placements are [1st, 5th, 3rd, 2nd, 4th]."
        ],
        "constraints": "n == score.length\n1 <= n <= 104\n0 <= score[i] <= 106\nAll the values in score are unique.",
        "oracle_code": "class Solution {\n    public String[] findRelativeRanks(int[] score) {\n         int n=score.length;\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[b]-score[a]);\n        for(int i=0;i<n;i++) pq.add(i);\n      String[] ans = new String[n];\n                int i=1;\n        while(!pq.isEmpty()){\n            int idx=pq.poll();\n         if(i==1)   { ans[idx]=\"Gold Medal\"; i++;}\n         else if(i==2)   { ans[idx]=\"Silver Medal\"; i++;}\n         else if(i==3)   { ans[idx]=\"Bronze Medal\"; i++;}\n         else ans[idx]=Integer.toString(i++);\n        }\n        return ans;  \n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String[] findRelativeRanks(int[] score) {\\n         int n=score.length;\\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[b]-score[a]);\\n        for(int i=0;i<n;i++) pq.add(i);\\n      String[] ans = new String[n];\\n                int i=1;\\n        while(!pq.isEmpty()){\\n            int idx=pq.poll();\\n         if(i==1)   { ans[idx]=\"Gold Medal\"; i++;}\\n         else if(i==2)   { ans[idx]=\"Silver Medal\"; i++;}\\n         else if(i==3)   { ans[idx]=\"Bronze Medal\"; i++;}\\n         else ans[idx]=Integer.toString(i++);\\n        }\\n        return ans;  \\n    }\\n}\\n```",
        "level": "easy",
        "type": [
            "operation error",
            "parentheses mismatch",
            "undefined keywords from other languages",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\n    public String[] findRelativeRanks(int[] score) {\n         int n = score.length;\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[a]-score[b]);\n        for(int i=0;i<n;i++) pq.add(i);\n        String[] ans = new String[n];\n                int i=1;\n        while(!pq.isEmpty()){\n            int idx=pq.poll();\n         if(i=1)   { ans[idx]=\"Gold Medal\"; i++;}\n         elif(i=2)   { ans[idx]=\"Silver Medal\"; i++;}\n         else if(i=3)   { ans[idx]=\"Bronze Medal\"; i++;}\n         else ans[idx]=Integer.toString(i++);\n        }\n        return reorderArray(ans);  \n    }\n\n    private String[] reorderArray(String[] ranks){\n        \n    }\n}\n"
    },
    {
        "slug": "count-negative-numbers-in-a-sorted-matrix",
        "description": "Given a m x n matrix grid which is sorted in non-increasing order both row-wise and column-wise, return the number of negative numbers in grid.",
        "examples": [
            "Input: grid = [[4,3,2,-1],[3,2,1,-1],[1,1,-1,-2],[-1,-1,-2,-3]]\nOutput: 8\nExplanation: There are 8 negatives number in the matrix.",
            "Input: grid = [[3,2],[1,0]]\nOutput: 0"
        ],
        "constraints": "m == grid.length\nn == grid[i].length\n1 <= m, n <= 100\n-100 <= grid[i][j] <= 100",
        "oracle_code": "class Solution:\n    def countNegatives(self, grid: List[List[int]]) -> int:\n        ROWS, COLS = len(grid), len(grid[0])\n        negatives = 0\n        col = 0\n        for row in range(ROWS - 1, -1, -1):\n            while col < COLS and grid[row][col] >= 0:\n                col += 1\n            negatives += COLS - col\n        return negatives",
        "content": "# Intuition\\nThe key idea is to take advantage of the sorted nature of the matrix, where both the rows and columns are sorted in non-increasing order. This means that once we find a negative number in a row, all the following numbers in that row will also be negative. Similarly, if a cell at the top of a column is negative, all the cells below it in that column will also be negative.\\n\\n# Approach\\nNegative numbers will form a staircase. So we start from the bottom-left, and follow along the staircase. For each row, we find the edge of the staircase, add all the count of elements to the right to the answer, and then move up a row and repeat.\\n\\n# Complexity\\n- Time complexity: O(m + n) - We visit each row and column at most once.\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def countNegatives(self, grid: List[List[int]]) -> int:\\n        ROWS, COLS = len(grid), len(grid[0])\\n        negatives = 0\\n        col = 0\\n        for row in range(ROWS - 1, -1, -1):\\n            while col < COLS and grid[row][col] >= 0:\\n                col += 1\\n            negatives += COLS - col\\n        return negatives\\n\\n```\\n\\n# Get Faster Interview Prep Results with Top Algos\\nWe all know how time-consuming it is to prepare for interviews and how frustratingly difficult it is to improve. We made **Top Algos** - a tool recommends the perfect algorithm problem based on your current skill level to help you improve the fastest in the shortest amount of time. Top Algos is your personalized coach that learns your skill level and finds the best problem you need to solve to improve.\\n\\nThe beta version of the product is available for **free** right now! You can sign up at https://topalgos.xyz/.",
        "level": "easy",
        "type": [
            "operation error",
            "colon missing",
            "indexing error",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution:\n    def countNegatives(self, grid: List[List[int]]) -> int:\n        ROWS, COLS = len(grid), len(undefinedGridVar[0])\n        negatives = 0\n        for row in range(ROWS - 1, -1, -1):\n            col = 0\n            while col <= COLS and grid[row][col] >= 0:\n                col += 1\n            negatives += COLS\n        return negatives\n"
    },
    {
        "slug": "trapping-rain-water",
        "description": "Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.",
        "examples": [
            "Input: height = [0,1,0,2,1,0,1,3,2,1,2,1]\nOutput: 6\nExplanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.",
            "Input: height = [4,2,0,3,2,5]\nOutput: 9"
        ],
        "constraints": "n == height.length\n1 <= n <= 2 * 104\n0 <= height[i] <= 105",
        "oracle_code": "class Solution \n{\n    public int trap(int[] height) \n    {\n        int result = 0;\n        if(height==null || height.length<=2)\n            return result;\n        int left[] = new int[height.length];\n        int right[]= new int[height.length];\n        //scan from left to right\n        int max = height[0];\n        left[0] = height[0];\n        for(int i=1; i<height.length; i++)\n        {\n            if(height[i]<max)\n            {\n                left[i]=max;\n            }\n            else\n            {\n                left[i]=height[i];\n                max = height[i];\n            }\n        }\n        //scan from right to left\n        max = height[height.length-1];\n        right[height.length-1]=height[height.length-1];\n        for(int i=height.length-2; i>=0; i--)\n        {\n            if(height[i]<max)\n            {\n                right[i]=max;  \n            }\n            else\n            {  \n                right[i]=height[i];\n                max = height[i];\n            }\n        }\n    \n        for(int i=0; i<height.length; i++)\n        {\n            result+= Math.min(left[i],right[i])-height[i];\n        }\n        return result;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo calculate the trapped rainwater, we need to determine the effective height at each bar. The effective height at a specific bar is the minimum of the maximum heights on its left and right sides. The trapped rainwater can be calculated as the difference between the effective height and the actual height of each bar.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Check if the height array is null or has fewer than 2 elements. If so, return 0 since there are not enough bars to trap any rainwater.\\n2. Initialize a variable result to keep track of the total trapped rainwater.\\n3. Create two arrays, left and right, each with the same length as the height array. These arrays will store the maximum heights on the left and right sides of each bar, respectively.\\n4. Scan the height array from left to right:\\n- Initialize a variable max to store the maximum height encountered so far, starting with the height of the first bar.\\n- For each bar at index i, compare its height with the current max:\\n1. If the height of the current bar is less than the current max, set left[i] to max, indicating that the maximum height on the left side is still max.\\n1. Otherwise, update left[i] and max to the height of the current bar since it becomes the new maximum height encountered so far.\\n5. Scan the height array from right to left (similar to step 4) to populate the right array with the maximum heights on the right side of each bar.\\n6. Iterate over the height array:\\n- For each bar at index i, calculate the trapped rainwater by subtracting the actual height (height[i]) from the minimum of the maximum heights on the left and right sides (Math.min(left[i], right[i])).\\n- Add the calculated trapped rainwater to the result variable.\\n7. Return the final result which represents the total trapped rainwater.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the code is O(n), where n is the length of the height array. The code performs three separate scans over the height array, each taking linear time. Hence, the overall time complexity is linear.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the code is O(n), where n is the length of the height array. This is due to the additional arrays left and right that store the maximum heights on the left and right sides of each bar, respectively. The space required is proportional to the size of the input array.\\n\\n# Code\\n```\\nclass Solution \\n{\\n    public int trap(int[] height) \\n    {\\n        int result = 0;\\n        if(height==null || height.length<=2)\\n            return result;\\n        int left[] = new int[height.length];\\n        int right[]= new int[height.length];\\n        //scan from left to right\\n        int max = height[0];\\n        left[0] = height[0];\\n        for(int i=1; i<height.length; i++)\\n        {\\n            if(height[i]<max)\\n            {\\n                left[i]=max;\\n            }\\n            else\\n            {\\n                left[i]=height[i];\\n                max = height[i];\\n            }\\n        }\\n        //scan from right to left\\n        max = height[height.length-1];\\n        right[height.length-1]=height[height.length-1];\\n        for(int i=height.length-2; i>=0; i--)\\n        {\\n            if(height[i]<max)\\n            {\\n                right[i]=max;  \\n            }\\n            else\\n            {  \\n                right[i]=height[i];\\n                max = height[i];\\n            }\\n        }\\n    \\n        for(int i=0; i<height.length; i++)\\n        {\\n            result+= Math.min(left[i],right[i])-height[i];\\n        }\\n        return result;\\n    }\\n}\\n```",
        "level": "hard",
        "type": [
            "variable value error",
            "== and = confusion",
            "parentheses mismatch",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution \n{\n    public int trap(int[] height) \n    {\n        int result = 0;\n        if(height = null || height.length<=2)\n            return result;\n        int left[] = new int[height.length];\n        int right[]= new int[height.length];\n        //scan from left to right\n        int max = height[0];\n        left[0] = height[0];\n        for(int i=1; i<height.length; i++)\n        {\n            if(height[i]<max)\n            {\n                left[i]=height[i]; }\n            else\n            {\n                left[i]=height[i;\n                max = height[i];\n            }\n        }\n        //scan from right to left\n        max = height[height.length-1];\n        right[height.length-1]=height[height.length-1];\n        for(int i=height.length-2; i>=0; i--)\n        {\n            if(height[i]<max)\n            {\n                right[i]=max;\n            }\n            else\n            {  \n                right[i]=height[i];\n                max = height[i];\n        }\n    \n        for(int i=0; i<height.length+1; i++)\n        {\n            result+= Math.min(left[i],right[i])-height[i];\n        }\n        return result;\n    }\n}\n"
    },
    {
        "slug": "daily-temperatures",
        "description": "Given an array of integers temperatures represents the daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after the ith day to get a warmer temperature. If there is no future day for which this is possible, keep answer[i] == 0 instead.",
        "examples": [
            "Input: temperatures = [73,74,75,71,69,72,76,73]\nOutput: [1,1,4,2,1,1,0,0]",
            "Input: temperatures = [30,40,50,60]\nOutput: [1,1,1,0]",
            "Input: temperatures = [30,60,90]\nOutput: [1,1,0]"
        ],
        "constraints": "1 <=\u00a0temperatures.length <= 105\n30 <=\u00a0temperatures[i] <= 100",
        "oracle_code": "class Solution {\n    public int[] dailyTemperatures(int[] temperatures) {\n        \n        int[] arr = new int[temperatures.length]; \n        \n        ArrayDeque<int[]> st = new ArrayDeque<>(); \n        \n        int i=0, j=temperatures.length-1 ; \n        \n        while( j >= 0){\n            \n            if(st.size()==0){\n                arr[i++] = 0;\n            }\n            else  if (st.size()>0 && st.peek()[0]>temperatures[j])\n            {\n                arr[i++]=1;\n            } \n            else if (st.size()>0 && st.peek()[0]<=temperatures[j])\n            \n            {  while(st.size()>0 && st.peek()[0]<=temperatures[j]){\n                    st.pop();\n                    \n                }\n            if(st.size()==0){\n                arr[i++]=0;\n            }\n            else{\n                arr[i++]=st.peek()[1]-j;\n            }\n            } \n        st.push(new int[]{temperatures[j],j}); \n        j--;\n        }\n        \n      \n        int[] ans = new int[temperatures.length]; int k=0;\n        for(i=arr.length-1; i>=0; i--){\n            ans[k++]=arr[i];\n        }\n        return ans;\n    }\n}",
        "content": "```\\nclass Solution {\\n    public int[] dailyTemperatures(int[] temperatures) {\\n        \\n        int[] arr = new int[temperatures.length]; \\n        \\n        ArrayDeque<int[]> st = new ArrayDeque<>(); \\n        \\n        int i=0, j=temperatures.length-1 ; \\n        \\n        while( j >= 0){\\n            \\n            if(st.size()==0){\\n                arr[i++] = 0;\\n            }\\n            else  if (st.size()>0 && st.peek()[0]>temperatures[j])\\n            {\\n                arr[i++]=1;\\n            } \\n            else if (st.size()>0 && st.peek()[0]<=temperatures[j])\\n            \\n            {  while(st.size()>0 && st.peek()[0]<=temperatures[j]){\\n                    st.pop();\\n                    \\n                }\\n            if(st.size()==0){\\n                arr[i++]=0;\\n            }\\n            else{\\n                arr[i++]=st.peek()[1]-j;\\n            }\\n            } \\n        st.push(new int[]{temperatures[j],j}); \\n        j--;\\n        }\\n        \\n      \\n        int[] ans = new int[temperatures.length]; int k=0;\\n        for(i=arr.length-1; i>=0; i--){\\n            ans[k++]=arr[i];\\n        }\\n        return ans;\\n    }\\n}",
        "level": "medium",
        "type": [
            "variable value error",
            "indexing error",
            "undefined objects",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\n    public int[] dailyTemperatures(int[] temperatures) {\n        \n        int[] arr = new int[temperatures.length + 1]; \n        \n        ArrayDeque<int[]> st = new ArrayDeque<>(); \n        \n        int i=0, j=temperatures.length ; \n        \n        while( j >= 0){\n            \n            if(st.size()==0){\n                arr[i++] = 0;\n            }\n            else  if (st.size()>0 && st.peek()[0]>temperatures[j])\n            {\n                arr[i++]=1;\n            } \n            else if (st.size()>0 && st.peek()[0]<=temperatures[j])\n            \n            {  while(st.size()>0 && st.peek()[0]<=temperatures[j]){\n                    st.pop();\n                    \n                }\n            if(st.size()==0){\n                arr[i++]=0;\n            }\n            else{\n                arr[i++]=st.peek()[1]-j;\n            }\n            } \n        st.push(new int[]{temperatures[j],j}); \n        j--;\n        }\n        \n      \n        int[] ans = new int[temperatures.length]; int k=0;\n        for(i=arr.length-1 + ; \n        return ans;\n    }\n}\n\n\n        doSomething();\n\n\n"
    },
    {
        "slug": "goat-latin",
        "description": "You are given a string sentence that consist of words separated by spaces. Each word consists of lowercase and uppercase letters only.\nWe would like to convert the sentence to \"Goat Latin\" (a made-up language similar to Pig Latin.) The rules of Goat Latin are as follows:\n\nIf a word begins with a vowel ('a', 'e', 'i', 'o', or 'u'), append \"ma\" to the end of the word.\n\n\t\nFor example, the word \"apple\" becomes \"applema\".\n\n\nIf a word begins with a consonant (i.e., not a vowel), remove the first letter and append it to the end, then add \"ma\".\n\t\nFor example, the word \"goat\" becomes \"oatgma\".\n\n\nAdd one letter 'a' to the end of each word per its word index in the sentence, starting with 1.\n\t\nFor example, the first word gets \"a\" added to the end, the second word gets \"aa\" added to the end, and so on.\n\n\n\nReturn the final sentence representing the conversion from sentence to Goat Latin.",
        "examples": [
            "Input: sentence = \"I speak Goat Latin\"\nOutput: \"Imaa peaksmaaa oatGmaaaa atinLmaaaaa\"",
            "Input: sentence = \"The quick brown fox jumped over the lazy dog\"\nOutput: \"heTmaa uickqmaaa rownbmaaaa oxfmaaaaa umpedjmaaaaaa overmaaaaaaa hetmaaaaaaaa azylmaaaaaaaaa ogdmaaaaaaaaaa\""
        ],
        "constraints": "1 <= sentence.length <= 150\nsentence consists of English letters and spaces.\nsentence has no leading or trailing spaces.\nAll the words in sentence are separated by a single space.",
        "oracle_code": "class Solution {\n    public String toGoatLatin(String sentence) {\n        sentence.toLowerCase();\n        String[] words=sentence.split(\" \",0);\n        int i=1;\n        String ans=\"\";\n        for(String word:words){\n           \n            char p1=word.charAt(0);\n            char p=word.toLowerCase().charAt(0);\n            String k=\"\";\n            if(p=='a'||p=='i'||p=='o'||p=='e'||p=='u'){\n                k+=word+\"ma\";\n            }\n            else{\n                k+=word.substring(1,word.length());\n                k+=p1;\n                k+=\"ma\";\n            }\n            for(int m=0;m<i;m++){\n               k+='a';\n            }\n            ans+=k;\n            if(i!=words.length)ans+=\" \";\n            i++;\n        }\n        return ans;\n    }\n}",
        "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public String toGoatLatin(String sentence) {\\n        sentence.toLowerCase();\\n        String[] words=sentence.split(\" \",0);\\n        int i=1;\\n        String ans=\"\";\\n        for(String word:words){\\n           \\n            char p1=word.charAt(0);\\n            char p=word.toLowerCase().charAt(0);\\n            String k=\"\";\\n            if(p==\\'a\\'||p==\\'i\\'||p==\\'o\\'||p==\\'e\\'||p==\\'u\\'){\\n                k+=word+\"ma\";\\n            }\\n            else{\\n                k+=word.substring(1,word.length());\\n                k+=p1;\\n                k+=\"ma\";\\n            }\\n            for(int m=0;m<i;m++){\\n               k+=\\'a\\';\\n            }\\n            ans+=k;\\n            if(i!=words.length)ans+=\" \";\\n            i++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
        "level": "easy",
        "type": [
            "== and = confusion",
            "unclosed string",
            "statement separation",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\n    public String toGoatLatin(String sentence) {\n        sentence.toLowerCase()\n        undefinedMethod();\n        String[] words=sentence.split(\" \",0);\n        int i=1;\n        String ans=\";\n        for(String word:words){\n\n            char p1=word.charAt(0);\n            char p=word.toLowerCase().charAt(0);\n            String k=\"\";\n            if(p=='a'||p=='i'||p=='o'||p=='e'||p=='u'){\n                k+=word+\"ma\";\n            }\n            else{\n                k+=word.substring(1,word.length());\n                k+=p1;\n                k+=\"ma\";\n            }\n            for(int m=0;m<i;m++){\n               k+='a';\n            }\n            ans+=k;\n            if(i==words.length)ans+=\" \";\n            i++;\n        }\n        return ans;\n    }\n}\n"
    },
    {
        "slug": "number-of-provinces",
        "description": "There are n cities. Some of them are connected, while some are not. If city a is connected directly with city b, and city b is connected directly with city c, then city a is connected indirectly with city c.\nA province is a group of directly or indirectly connected cities and no other cities outside of the group.\nYou are given an n x n matrix isConnected where isConnected[i][j] = 1 if the ith city and the jth city are directly connected, and isConnected[i][j] = 0 otherwise.\nReturn the total number of provinces.",
        "examples": [
            "Input: isConnected = [[1,1,0],[1,1,0],[0,0,1]]\nOutput: 2",
            "Input: isConnected = [[1,0,0],[0,1,0],[0,0,1]]\nOutput: 3"
        ],
        "constraints": "1 <= n <= 200\nn == isConnected.length\nn == isConnected[i].length\nisConnected[i][j] is 1 or 0.\nisConnected[i][i] == 1\nisConnected[i][j] == isConnected[j][i]",
        "oracle_code": "class DSU:\n    def __init__(self, n):\n        self.par = list(range(n))\n        self.rank = [1] * n\n        self.size = 1\n    def find(self, u):\n        if u != self.par[u]:\n            self.par[u] = self.find(self.par[u])\n        return self.par[u]\n    def union(self, u, v):\n        uu, vv = self.find(u), self.find(v)\n        if uu == vv:\n            return False\n        if self.rank[uu] > self.rank[vv]:\n            self.par[vv] = uu\n        elif self.rank[vv] > self.rank[uu]:\n            self.par[uu] = vv\n        else:\n            self.par[uu] = vv\n            self.rank[vv] += 1\n        self.size += 1\n        return True\n\nclass Solution:\n    def isConnected(self, u, v, G):\n        return G[u][v] == 1\n\n    def findCircleNum(self, G: List[List[int]]) -> int:\n        n = len(G)\n        uf = DSU(n)\n        if not G:\n            return 0\n        for u in range(n):\n            for v in range(u, n):\n                if self.isConnected(u, v, G):\n                    uf.union(u, v)\n        return len(set([uf.find(i) for i in range(n)]))",
        "content": "\\n# Code\\n```\\nclass DSU:\\n    def __init__(self, n):\\n        self.par = list(range(n))\\n        self.rank = [1] * n\\n        self.size = 1\\n    def find(self, u):\\n        if u != self.par[u]:\\n            self.par[u] = self.find(self.par[u])\\n        return self.par[u]\\n    def union(self, u, v):\\n        uu, vv = self.find(u), self.find(v)\\n        if uu == vv:\\n            return False\\n        if self.rank[uu] > self.rank[vv]:\\n            self.par[vv] = uu\\n        elif self.rank[vv] > self.rank[uu]:\\n            self.par[uu] = vv\\n        else:\\n            self.par[uu] = vv\\n            self.rank[vv] += 1\\n        self.size += 1\\n        return True\\n\\nclass Solution:\\n    def isConnected(self, u, v, G):\\n        return G[u][v] == 1\\n\\n    def findCircleNum(self, G: List[List[int]]) -> int:\\n        n = len(G)\\n        uf = DSU(n)\\n        if not G:\\n            return 0\\n        for u in range(n):\\n            for v in range(u, n):\\n                if self.isConnected(u, v, G):\\n                    uf.union(u, v)\\n        return len(set([uf.find(i) for i in range(n)]))\\n\\n```",
        "level": "medium",
        "type": [
            "colon missing",
            "wrong comment mark",
            "undefined objects",
            "undefined methods"
        ],
        "buggy_code": "\nclass DSU:\n    def __init__(self, n)\n        self.par = list(range(n))\n        self.rank = [1] * n\n        self.size = 1\n    def find(self, u):\n        if u != self.par[u]:\n            /* self.par[u] = self.find(self.par[u])*/\n        return self.par[u]\n    def union(self, u, v):\n        uu, vv = self.find(u), self.find(v)\n        if uu == vv:\n            return False\n        if self.rank[uu] > self.rank[vv]:\n            self.par[vv] = uu\n        elif self.rank[vv] > self.rank[uu]:\n            self.par[uu] = vv\n        else:\n            self.par[uu] = vv\n            self.rank[vv] += 1\n        self.size += 1\n        return True\n    def issizemorethanone(self):\n        return self.size > 1\n    \nclass Solution:\n    def isConnected(self, u, v, G):\n        return G[u][v] == 1\n\n    def findCircleNum(self, G) -> int:\n        n = len(G)\n        uf = DSU(n)\n        if not G:\n            return 0\n        for u in range(n):\n            for v in range(u, n):\n                if self.isConnected(u, v, G):\n                    uf.union(u, v)\n        return len(set([uf.find(i) for i in range(n)]))\n"
    },
    {
        "slug": "count-largest-group",
        "description": "You are given an integer n.\nEach number from 1 to n is grouped according to the sum of its digits.\nReturn the number of groups that have the largest size.",
        "examples": [
            "Input: n = 13\nOutput: 4\nExplanation: There are 9 groups in total, they are grouped according sum of its digits of numbers from 1 to 13:\n[1,10], [2,11], [3,12], [4,13], [5], [6], [7], [8], [9].\nThere are 4 groups with largest size.",
            "Input: n = 2\nOutput: 2\nExplanation: There are 2 groups [1], [2] of size 1."
        ],
        "constraints": "1 <= n <= 104",
        "oracle_code": "class Solution {\n    \n    int countDigits(int n) {\n        if(n == 0) return 0;\n        return n%10 + countDigits(n/10);\n    }\n    \n    public int countLargestGroup(int n) {\n        \n        ArrayList<Integer> list = new ArrayList(Collections.nCopies(37, 0));\n        \n        for(int i=1;i<=n;i++) {\n            int cd = countDigits(i); // count digits\n            list.set(cd, list.get(cd)+1); // update count\n        }\n        \n        return Collections.frequency(list, Collections.max(list));\n    }\n}",
        "content": "```\\nclass Solution {\\n    \\n    int countDigits(int n) {\\n        if(n == 0) return 0;\\n        return n%10 + countDigits(n/10);\\n    }\\n    \\n    public int countLargestGroup(int n) {\\n        \\n        ArrayList<Integer> list = new ArrayList(Collections.nCopies(37, 0));\\n        \\n        for(int i=1;i<=n;i++) {\\n            int cd = countDigits(i); // count digits\\n            list.set(cd, list.get(cd)+1); // update count\\n        }\\n        \\n        return Collections.frequency(list, Collections.max(list));\\n    }\\n}\\n```",
        "level": "easy",
        "type": [
            "operation error",
            "== and = confusion",
            "undefined objects",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution {\n\n    int countDigits(int n) {\n        if(n = 0) return 0;\n        return 1 + countDigits(n/10);\n    }\n\n    public int countLargestGroup(int n) {\n\n        ArrayList<Integer> list = nul []; \n\n        for(int i=1;i<=n;i++) {\n            int cd = countDigits(i); \n            list.set(cd, list.get(cd)+1); \n            }\n\n       return Collections.frequency(list, Collections.max(list));\n    }\n}\n"
    },
    {
        "slug": "apply-discount-every-n-orders",
        "description": "There is a supermarket that is frequented by many customers. The products sold at the supermarket are represented as two parallel integer arrays products and prices, where the ith product has an ID of products[i] and a price of prices[i].\nWhen a customer is paying, their bill is represented as two parallel integer arrays product and amount, where the jth product they purchased has an ID of product[j], and amount[j] is how much of the product they bought. Their subtotal is calculated as the sum of each amount[j] * (price of the jth product).\nThe supermarket decided to have a sale. Every nth customer paying for their groceries will be given a percentage discount. The discount amount is given by discount, where they will be given discount percent off their subtotal. More formally, if their subtotal is bill, then they would actually pay bill * ((100 - discount) / 100).\nImplement the Cashier class:\n\nCashier(int n, int discount, int[] products, int[] prices) Initializes the object with n, the discount, and the products and their prices.\ndouble getBill(int[] product, int[] amount) Returns the final total of the bill with the discount applied (if any). Answers within 10-5 of the actual value will be accepted.",
        "examples": [
            "Input\n[\"Cashier\",\"getBill\",\"getBill\",\"getBill\",\"getBill\",\"getBill\",\"getBill\",\"getBill\"]\n[[3,50,[1,2,3,4,5,6,7],[100,200,300,400,300,200,100]],[[1,2],[1,2]],[[3,7],[10,10]],[[1,2,3,4,5,6,7],[1,1,1,1,1,1,1]],[[4],[10]],[[7,3],[10,10]],[[7,5,3,1,6,4,2],[10,10,10,9,9,9,7]],[[2,3,5],[5,3,2]]]\nOutput\n[null,500.0,4000.0,800.0,4000.0,4000.0,7350.0,2500.0]\nExplanation\nCashier cashier = new Cashier(3,50,[1,2,3,4,5,6,7],[100,200,300,400,300,200,100]);\ncashier.getBill([1,2],[1,2]);                        // return 500.0. 1st customer, no discount.\n                                                     // bill = 1 * 100 + 2 * 200 = 500.\ncashier.getBill([3,7],[10,10]);                      // return 4000.0. 2nd customer, no discount.\n                                                     // bill = 10 * 300 + 10 * 100 = 4000.\ncashier.getBill([1,2,3,4,5,6,7],[1,1,1,1,1,1,1]);    // return 800.0. 3rd customer, 50% discount.\n                                                     // Original bill = 1600\n                                                     // Actual bill = 1600 * ((100 - 50) / 100) = 800.\ncashier.getBill([4],[10]);                           // return 4000.0. 4th customer, no discount.\ncashier.getBill([7,3],[10,10]);                      // return 4000.0. 5th customer, no discount.\ncashier.getBill([7,5,3,1,6,4,2],[10,10,10,9,9,9,7]); // return 7350.0. 6th customer, 50% discount.\n                                                     // Original bill = 14700, but with\n                                                     // Actual bill = 14700 * ((100 - 50) / 100) = 7350.\ncashier.getBill([2,3,5],[5,3,2]);                    // return 2500.0.  7th customer, no discount."
        ],
        "constraints": "1 <= n <= 104\n0 <= discount <= 100\n1 <= products.length <= 200\nprices.length == products.length\n1 <= products[i] <= 200\n1 <= prices[i] <= 1000\nThe elements in products are unique.\n1 <= product.length <= products.length\namount.length == product.length\nproduct[j] exists in products.\n1 <= amount[j] <= 1000\nThe elements of product are unique.\nAt most 1000 calls will be made to getBill.\nAnswers within 10-5 of the actual value will be accepted.",
        "oracle_code": "class Cashier {\n    HashMap<Integer,Integer>stock=new HashMap<>();\n    int n;\n    int discount;\n    int itr=0;\n    public Cashier(int n, int discount, int[] products, int[] prices) {\n        for(int i=0;i<products.length;i++){\n            stock.put(products[i],prices[i]);\n        }\n        this.n=n;\n        this.discount=discount;\n    }\n    \n    public double getBill(int[] product, int[] amount) {\n        double total=0;\n        for(int i=0;i<product.length;i++){\n            total+=(double)(amount[i]*stock.get(product[i]));\n        }\n        itr++;\n        if(itr==n){\n            total*=(double)(((100-discount)/100d));\n            itr=0;\n        }\n        return total;\n    }\n}\n\n/**\n * Your Cashier object will be instantiated and called as such:\n * Cashier obj = new Cashier(n, discount, products, prices);\n * double param_1 = obj.getBill(product,amount);\n */",
        "content": "# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Cashier {\\n    HashMap<Integer,Integer>stock=new HashMap<>();\\n    int n;\\n    int discount;\\n    int itr=0;\\n    public Cashier(int n, int discount, int[] products, int[] prices) {\\n        for(int i=0;i<products.length;i++){\\n            stock.put(products[i],prices[i]);\\n        }\\n        this.n=n;\\n        this.discount=discount;\\n    }\\n    \\n    public double getBill(int[] product, int[] amount) {\\n        double total=0;\\n        for(int i=0;i<product.length;i++){\\n            total+=(double)(amount[i]*stock.get(product[i]));\\n        }\\n        itr++;\\n        if(itr==n){\\n            total*=(double)(((100-discount)/100d));\\n            itr=0;\\n        }\\n        return total;\\n    }\\n}\\n\\n/**\\n * Your Cashier object will be instantiated and called as such:\\n * Cashier obj = new Cashier(n, discount, products, prices);\\n * double param_1 = obj.getBill(product,amount);\\n */\\n```",
        "level": "medium",
        "type": [
            "parentheses mismatch",
            "colon missing",
            "conditional statement error",
            "indexing error"
        ],
        "buggy_code": "\nclass Cashier {\n    HashMap<Integer,Integer>stock=new HashMap<>();\n    int n;\n    int discount;\n    int itr=0;\n    public Cashier(int n, int discount, int[] products, int[] prices {\n        for(int i=0;i<=products.length;i++)\n            stock.put(products[i],prices[i]);\n        }\n        this.n=n;\n        this.discount=discount;\n    }\n    \n    public double getBill(int[] product, int[] amount) {\n        double total=0;\n        for(int i=0;i<product.length;i++)\n            total+=(double)(amount[i]*stock.get(product[i]));\n        }\n        itr++;\n        if(itr==n+1)\n            total*=(double)(((100-discount)/100d));\n        }\n        itr=0;\n        \n    }\n    return total;\n}\n\n\n "
    },
    {
        "slug": "minimum-score-triangulation-of-polygon",
        "description": "You have a convex n-sided polygon where each vertex has an integer value. You are given an integer array values where values[i] is the value of the ith vertex (i.e., clockwise order).\nYou will triangulate the polygon into n - 2 triangles. For each triangle, the value of that triangle is the product of the values of its vertices, and the total score of the triangulation is the sum of these values over all n - 2 triangles in the triangulation.\nReturn the smallest possible total score that you can achieve with some triangulation of the polygon.",
        "examples": [
            "Input: values = [1,2,3]\nOutput: 6\nExplanation: The polygon is already triangulated, and the score of the only triangle is 6.",
            "Input: values = [3,7,4,5]\nOutput: 144\nExplanation: There are two triangulations, with possible scores: 3*7*5 + 4*5*7 = 245, or 3*4*5 + 3*4*7 = 144.\nThe minimum score is 144.",
            "Input: values = [1,3,1,4,1,5]\nOutput: 13\nExplanation: The minimum score triangulation has score 1*1*3 + 1*1*4 + 1*1*5 + 1*1*1 = 13."
        ],
        "constraints": "n == values.length\n3 <= n <= 50\n1 <= values[i] <= 100",
        "oracle_code": "class Solution {\n    int[][] dp;\n    public int minScoreTriangulation(int[] values) {\n        int l=values.length;\n        dp = new int[l][l];\n        for(int[] i : dp) Arrays.fill(i,-1);\n        return solve(values,1,l-1); \n    }\n\n    public int solve(int[] values, int i,int j)\n    {\n        if(i>=j) return 0;\n        if(dp[i][j]!=-1) return dp[i][j];\n        int min=Integer.MAX_VALUE;\n        for(int k=i;k<j;k++)\n        {\n            int temp=solve(values,i,k)+solve(values,k+1,j)+\n                        values[i-1]*values[k]*values[j];\n            min=Math.min(min,temp);\n        }\n\n        return dp[i][j]=min;\n    }\n}",
        "content": "\\n# Complexity\\n- Time complexity: n^2\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: n^2\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int[][] dp;\\n    public int minScoreTriangulation(int[] values) {\\n        int l=values.length;\\n        dp = new int[l][l];\\n        for(int[] i : dp) Arrays.fill(i,-1);\\n        return solve(values,1,l-1); \\n    }\\n\\n    public int solve(int[] values, int i,int j)\\n    {\\n        if(i>=j) return 0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int min=Integer.MAX_VALUE;\\n        for(int k=i;k<j;k++)\\n        {\\n            int temp=solve(values,i,k)+solve(values,k+1,j)+\\n                        values[i-1]*values[k]*values[j];\\n            min=Math.min(min,temp);\\n        }\\n\\n        return dp[i][j]=min;\\n    }\\n}\\n```",
        "level": "medium",
        "type": [
            "variable value error",
            "parentheses mismatch",
            "colon missing",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution {\n    int[][] dp;\n    public int minScoreTriangulation(int[] values) {\n        int l=values.length;\n        dp = new int[l][l];\n        for int[] i : dp) Arrays.fill(i,-1);\n        return solve(values,0,l-1); \n    }\n\n    public int solve(int[] values, int i,int j)\n    {\n        if(i>=j) return 0;\n        if(dp[i][j]!=-1) return dp[i][j];\n        int min=Integer.MAX_VALUE;\n        for(int k=i;k<j;k++)\n        {\n            int temp=solve(values,i,k)+solve(values,k+1,j)\n                        values[i-1]*values[k]*values[undefined];\n            min=Math.min(min,temp);\n        }\n\n        return dp[i][j]=min;\n    }\n}\n"
    },
    {
        "slug": "convert-the-temperature",
        "description": "You are given a non-negative floating point number rounded to two decimal places celsius, that denotes the temperature in Celsius.\nYou should convert Celsius into Kelvin and Fahrenheit and return it as an array ans = [kelvin, fahrenheit].\nReturn the array ans. Answers within 10-5 of the actual answer will be accepted.\nNote that:\n\nKelvin = Celsius + 273.15\nFahrenheit = Celsius * 1.80 + 32.00",
        "examples": [
            "Input: celsius = 36.50\nOutput: [309.65000,97.70000]\nExplanation: Temperature at 36.50 Celsius converted in Kelvin is 309.65 and converted in Fahrenheit is 97.70.",
            "Input: celsius = 122.11\nOutput: [395.26000,251.79800]\nExplanation: Temperature at 122.11 Celsius converted in Kelvin is 395.26 and converted in Fahrenheit is 251.798."
        ],
        "constraints": "0 <= celsius <= 1000",
        "oracle_code": "class Solution {\n    public double[] convertTemperature(double celsius) {\n        double arr[] = new double[2];\n        arr[1] = (celsius * 9.0/5.0) + 32.0;\n        arr[0] = celsius + 273.15;\n        return arr;\n    }\n}",
        "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe program takes a celsius value and converts it to fahrenheit and kelvin.\\n# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public double[] convertTemperature(double celsius) {\\n        double arr[] = new double[2];\\n        arr[1] = (celsius * 9.0/5.0) + 32.0;\\n        arr[0] = celsius + 273.15;\\n        return arr;\\n    }\\n}\\n```",
        "level": "easy",
        "type": [
            "operation error",
            "indexing error",
            "undefined objects",
            "statement separation"
        ],
        "buggy_code": "\n```java\nclass Solution {\n    public double[] convertTemperature(double celsius) {\n        double arr[] = new double[2];\n        UndefinedObject obj;  \n        arr[2] = (obj.celsius * 9.0/5.0) + 32.0\n        arr[0] = obj.celsius + 237.15;\n        return arr;\n    }\n}\n```\n"
    },
    {
        "slug": "number-of-laser-beams-in-a-bank",
        "description": "Anti-theft security devices are activated inside a bank. You are given a 0-indexed binary string array bank representing the floor plan of the bank, which is an m x n 2D matrix. bank[i] represents the ith row, consisting of '0's and '1's. '0' means the cell is empty, while'1' means the cell has a security device.\nThere is one laser beam between any two security devices if both conditions are met:\n\nThe two devices are located on two different rows: r1 and r2, where r1 < r2.\nFor each row i where r1 < i < r2, there are no security devices in the ith row.\n\nLaser beams are independent, i.e., one beam does not interfere nor join with another.\nReturn the total number of laser beams in the bank.",
        "examples": [
            "Input: bank = [\"011001\",\"000000\",\"010100\",\"001000\"]\nOutput: 8\nExplanation: Between each of the following device pairs, there is one beam. In total, there are 8 beams:\n * bank[0][1] -- bank[2][1]\n * bank[0][1] -- bank[2][3]\n * bank[0][2] -- bank[2][1]\n * bank[0][2] -- bank[2][3]\n * bank[0][5] -- bank[2][1]\n * bank[0][5] -- bank[2][3]\n * bank[2][1] -- bank[3][2]\n * bank[2][3] -- bank[3][2]\nNote that there is no beam between any device on the 0th row with any on the 3rd row.\nThis is because the 2nd row contains security devices, which breaks the second condition.",
            "Input: bank = [\"000\",\"111\",\"000\"]\nOutput: 0\nExplanation: There does not exist two devices located on two different rows."
        ],
        "constraints": "m == bank.length\nn == bank[i].length\n1 <= m, n <= 500\nbank[i][j] is either '0' or '1'.",
        "oracle_code": "class Solution {\n    public int numberOfBeams(String[] bank) {\n        int prevLazer =0;\n        int ans =0;\n        for(String s:bank){\n            int curLazer = 0;\n            for(char c: s.toCharArray()){\n                if(c=='1'){\n                    curLazer++;\n                }\n            }\n            if(curLazer >0){\n                ans += (curLazer * prevLazer);\n                prevLazer = curLazer;\n            }\n        }\n        return ans;\n    }\n}",
        "content": "\\n# java Code\\n```\\nclass Solution {\\n    public int numberOfBeams(String[] bank) {\\n        int prevLazer =0;\\n        int ans =0;\\n        for(String s:bank){\\n            int curLazer = 0;\\n            for(char c: s.toCharArray()){\\n                if(c==\\'1\\'){\\n                    curLazer++;\\n                }\\n            }\\n            if(curLazer >0){\\n                ans += (curLazer * prevLazer);\\n                prevLazer = curLazer;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
        "level": "medium",
        "type": [
            "== and = confusion",
            "parentheses mismatch",
            "wrong comment mark",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution {\n    public int numberOfBeams(String[] bank) {\n        int prevLazer =0;\n        int ans =0;\n        for(String s:bank){\n            int curLazer = 0;\n            for(char c: s.toCharArray()){\n                if(c=='1'){\n                    curLazer++;\n            }\n\n                ans += (curLazer * prevLazer);\n                prevLazer = curLazer;\n            if(curLazer = 0){\n                ans += (curLazer * prevLazer);\n                prevLazer = curLazer;\n            }\n        }\n        return ans;\n    }\npit()    return ans;\n    \n}\n"
    },
    {
        "slug": "same-tree",
        "description": "Given the roots of two binary trees p and q, write a function to check if they are the same or not.\nTwo binary trees are considered the same if they are structurally identical, and the nodes have the same value.",
        "examples": [
            "Input: p = [1,2,3], q = [1,2,3]\nOutput: true",
            "Input: p = [1,2], q = [1,null,2]\nOutput: false",
            "Input: p = [1,2,1], q = [1,1,2]\nOutput: false"
        ],
        "constraints": "The number of nodes in both trees is in the range [0, 100].\n-104 <= Node.val <= 104",
        "oracle_code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n   \n    public boolean isSameTree(TreeNode p, TreeNode q) {\n     if (p == null && q == null) {\n            return true;\n        }\n        \n        if (p == null || q == null) {\n            return false;\n        }\n        \n        if (p.val != q.val) {\n            return false;\n        }\n        \n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n\n        \n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n   \\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n     if (p == null && q == null) {\\n            return true;\\n        }\\n        \\n        if (p == null || q == null) {\\n            return false;\\n        }\\n        \\n        if (p.val != q.val) {\\n            return false;\\n        }\\n        \\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n\\n        \\n    }\\n}\\n```",
        "level": "easy",
        "type": [
            "conditional statement error",
            "wrong comment mark",
            "undefined keywords from other languages",
            "undefined methods"
        ],
        "buggy_code": "\n\nclass Solution {\n   \n    public boolean isSameTree(TreeNode p, TreeNode q) {\n     if (p == null && q == null) {\n            return true;\n        }\n        \n        if (p == null || q == null) {\n            return false;\n        }\n        \n        if (p.val == q.val) {\n            return false;\n        }\n        \n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n\n        \n    }\n}\n/**/\n=\ncheckubcheckub\n"
    },
    {
        "slug": "domino-and-tromino-tiling",
        "description": "You have two types of tiles: a 2 x 1 domino shape and a tromino shape. You may rotate these shapes.\n\nGiven an integer n, return the number of ways to tile an 2 x n board. Since the answer may be very large, return it modulo 109 + 7.\nIn a tiling, every square must be covered by a tile. Two tilings are different if and only if there are two 4-directionally adjacent cells on the board such that exactly one of the tilings has both squares occupied by a tile.",
        "examples": [
            "Input: n = 3\nOutput: 5\nExplanation: The five different ways are show above.",
            "Input: n = 1\nOutput: 1"
        ],
        "constraints": "1 <= n <= 1000",
        "oracle_code": "class Solution {\n    private long[] dp;\n    int MOD = (int)Math.pow(10 , 9) + 7;\n    public long solve(int n){\n        if(n==0) return 1;\n        if(n<3) return n;\n\n        if(dp[n]!=-1) return dp[n];\n\n        return dp[n] = 2*solve(n-1)%MOD+solve(n-3)%MOD;\n    }\n    public int numTilings(int n) {\n        this.dp = new long[n+1];\n        Arrays.fill(dp , -1);\n\n        return (int)solve(n)%MOD;\n    }\n}",
        "content": "# Intuition\\n- The basic approach to solve this problem was by using brute force recursion.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- Then after realising the over-lapping sub problems in it the whole problem was solved using the memoization technique of Dynamic Programming\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(N*N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N)$$ + recursive stack space\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private long[] dp;\\n    int MOD = (int)Math.pow(10 , 9) + 7;\\n    public long solve(int n){\\n        if(n==0) return 1;\\n        if(n<3) return n;\\n\\n        if(dp[n]!=-1) return dp[n];\\n\\n        return dp[n] = 2*solve(n-1)%MOD+solve(n-3)%MOD;\\n    }\\n    public int numTilings(int n) {\\n        this.dp = new long[n+1];\\n        Arrays.fill(dp , -1);\\n\\n        return (int)solve(n)%MOD;\\n    }\\n}\\n```",
        "level": "medium",
        "type": [
            "== and = confusion",
            "indexing error",
            "undefined keywords from other languages",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\n    private long[] dp;\n    int MOD = (int)Math.pow(10 , 9) + 7;\n    public long solve(int n){\n        if(n==0) return 1;\n        if(n<3) return n;\n\n        if(dp[n+2] = null) return dp[n];\n\n        return dp[n] == 2 * solve(n-1) % MOD + solve(n-4) % MOD;\n    }\n    public int numTilings(int n) {\n        this.dp = new long[n+1];\n        Arrays.fill(dp , -1);\n\n        return (int)solve(n) % MOD;\n    }\n}\n"
    },
    {
        "slug": "relative-ranks",
        "description": "You are given an integer array score of size n, where score[i] is the score of the ith athlete in a competition. All the scores are guaranteed to be unique.\nThe athletes are placed based on their scores, where the 1st place athlete has the highest score, the 2nd place athlete has the 2nd highest score, and so on. The placement of each athlete determines their rank:\n\nThe 1st place athlete's rank is \"Gold Medal\".\nThe 2nd place athlete's rank is \"Silver Medal\".\nThe 3rd place athlete's rank is \"Bronze Medal\".\nFor the 4th place to the nth place athlete, their rank is their placement number (i.e., the xth place athlete's rank is \"x\").\n\nReturn an array answer of size n where answer[i] is the rank of the ith athlete.",
        "examples": [
            "Input: score = [5,4,3,2,1]\nOutput: [\"Gold Medal\",\"Silver Medal\",\"Bronze Medal\",\"4\",\"5\"]\nExplanation: The placements are [1st, 2nd, 3rd, 4th, 5th].",
            "Input: score = [10,3,8,9,4]\nOutput: [\"Gold Medal\",\"5\",\"Bronze Medal\",\"Silver Medal\",\"4\"]\nExplanation: The placements are [1st, 5th, 3rd, 2nd, 4th]."
        ],
        "constraints": "n == score.length\n1 <= n <= 104\n0 <= score[i] <= 106\nAll the values in score are unique.",
        "oracle_code": "class Solution {\n    public String[] findRelativeRanks(int[] score) {\n         int n=score.length;\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[b]-score[a]);\n        for(int i=0;i<n;i++) pq.add(i);\n      String[] ans = new String[n];\n                int i=1;\n        while(!pq.isEmpty()){\n            int idx=pq.poll();\n         if(i==1)   { ans[idx]=\"Gold Medal\"; i++;}\n         else if(i==2)   { ans[idx]=\"Silver Medal\"; i++;}\n         else if(i==3)   { ans[idx]=\"Bronze Medal\"; i++;}\n         else ans[idx]=Integer.toString(i++);\n        }\n        return ans;  \n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String[] findRelativeRanks(int[] score) {\\n         int n=score.length;\\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[b]-score[a]);\\n        for(int i=0;i<n;i++) pq.add(i);\\n      String[] ans = new String[n];\\n                int i=1;\\n        while(!pq.isEmpty()){\\n            int idx=pq.poll();\\n         if(i==1)   { ans[idx]=\"Gold Medal\"; i++;}\\n         else if(i==2)   { ans[idx]=\"Silver Medal\"; i++;}\\n         else if(i==3)   { ans[idx]=\"Bronze Medal\"; i++;}\\n         else ans[idx]=Integer.toString(i++);\\n        }\\n        return ans;  \\n    }\\n}\\n```",
        "level": "easy",
        "type": [
            "operation error",
            "undefined objects",
            "undefined keywords from other languages",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution {\n    public String[] findRelativeRanks(int[] score) {\n         int n = score.length;\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[a]-score[b]);\n        for(int i=0;i<n;i++) pq.add(i);\n        String[] ans = null;\n                int i=1;\n        while(!pq.isEmpty()){\n            int idx=pq.poll();\n         if(i==1)   { ans[idx]=\"Gold Medal; i++;}\n         elif(i==2)   { ans[idx]=\"Silver Medal; i++;}\n         else if(i==3)   { ans[idx]=\"Bronze Medal; i++;}\n         else ans[idx]=Integer.toString(i++);\n        }\n        return ans;  \n    }\n}\n"
    },
    {
        "slug": "goat-latin",
        "description": "You are given a string sentence that consist of words separated by spaces. Each word consists of lowercase and uppercase letters only.\nWe would like to convert the sentence to \"Goat Latin\" (a made-up language similar to Pig Latin.) The rules of Goat Latin are as follows:\n\nIf a word begins with a vowel ('a', 'e', 'i', 'o', or 'u'), append \"ma\" to the end of the word.\n\n\t\nFor example, the word \"apple\" becomes \"applema\".\n\n\nIf a word begins with a consonant (i.e., not a vowel), remove the first letter and append it to the end, then add \"ma\".\n\t\nFor example, the word \"goat\" becomes \"oatgma\".\n\n\nAdd one letter 'a' to the end of each word per its word index in the sentence, starting with 1.\n\t\nFor example, the first word gets \"a\" added to the end, the second word gets \"aa\" added to the end, and so on.\n\n\n\nReturn the final sentence representing the conversion from sentence to Goat Latin.",
        "examples": [
            "Input: sentence = \"I speak Goat Latin\"\nOutput: \"Imaa peaksmaaa oatGmaaaa atinLmaaaaa\"",
            "Input: sentence = \"The quick brown fox jumped over the lazy dog\"\nOutput: \"heTmaa uickqmaaa rownbmaaaa oxfmaaaaa umpedjmaaaaaa overmaaaaaaa hetmaaaaaaaa azylmaaaaaaaaa ogdmaaaaaaaaaa\""
        ],
        "constraints": "1 <= sentence.length <= 150\nsentence consists of English letters and spaces.\nsentence has no leading or trailing spaces.\nAll the words in sentence are separated by a single space.",
        "oracle_code": "class Solution {\n    public String toGoatLatin(String sentence) {\n        sentence.toLowerCase();\n        String[] words=sentence.split(\" \",0);\n        int i=1;\n        String ans=\"\";\n        for(String word:words){\n           \n            char p1=word.charAt(0);\n            char p=word.toLowerCase().charAt(0);\n            String k=\"\";\n            if(p=='a'||p=='i'||p=='o'||p=='e'||p=='u'){\n                k+=word+\"ma\";\n            }\n            else{\n                k+=word.substring(1,word.length());\n                k+=p1;\n                k+=\"ma\";\n            }\n            for(int m=0;m<i;m++){\n               k+='a';\n            }\n            ans+=k;\n            if(i!=words.length)ans+=\" \";\n            i++;\n        }\n        return ans;\n    }\n}",
        "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public String toGoatLatin(String sentence) {\\n        sentence.toLowerCase();\\n        String[] words=sentence.split(\" \",0);\\n        int i=1;\\n        String ans=\"\";\\n        for(String word:words){\\n           \\n            char p1=word.charAt(0);\\n            char p=word.toLowerCase().charAt(0);\\n            String k=\"\";\\n            if(p==\\'a\\'||p==\\'i\\'||p==\\'o\\'||p==\\'e\\'||p==\\'u\\'){\\n                k+=word+\"ma\";\\n            }\\n            else{\\n                k+=word.substring(1,word.length());\\n                k+=p1;\\n                k+=\"ma\";\\n            }\\n            for(int m=0;m<i;m++){\\n               k+=\\'a\\';\\n            }\\n            ans+=k;\\n            if(i!=words.length)ans+=\" \";\\n            i++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
        "level": "easy",
        "type": [
            "== and = confusion",
            "indexing error",
            "unclosed string",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\n    public String toGoatLatin(String sentence) {\n        sentence.toLowerCase();\n        undefinedMethod();\n        String[] words=sentence.split(\" \",0);\n        int i=1;\n        String ans=\";\n        for(String word:words){\n\n            char p1=word.charAt(word.length());\n            char p=word.toLowerCase().charAt(0);\n            String k=\"\";\n            if(p=='a'||p=='i'||p=='o'||p=='e'||p=='u'){\n                k+=word+\"ma\";\n            }\n            else{\n                k+=word.substring(1,word.length());\n                k+=p1;\n                k+=\"ma\";\n            }\n            for(int m=0;m<i;m++){\n               k+='a';\n            }\n            ans+=k;\n            if(i==words.length)ans+=\" \";\n            i++;\n        }\n        return ans;\n    }\n}\n"
    },
    {
        "slug": "similar-string-groups",
        "description": "Two strings, X and Y, are considered similar if either they are identical or we can make them equivalent by swapping at most two letters (in distinct positions) within the string X.\nFor example, \"tars\"\u00a0and \"rats\"\u00a0are similar (swapping at positions 0 and 2), and \"rats\" and \"arts\" are similar, but \"star\" is not similar to \"tars\", \"rats\", or \"arts\".\nTogether, these form two connected groups by similarity: {\"tars\", \"rats\", \"arts\"} and {\"star\"}.\u00a0 Notice that \"tars\" and \"arts\" are in the same group even though they are not similar.\u00a0 Formally, each group is such that a word is in the group if and only if it is similar to at least one other word in the group.\nWe are given a list strs of strings where every string in strs is an anagram of every other string in strs. How many groups are there?",
        "examples": [
            "Input: strs = [\"tars\",\"rats\",\"arts\",\"star\"]\nOutput: 2",
            "Input: strs = [\"omv\",\"ovm\"]\nOutput: 1"
        ],
        "constraints": "1 <= strs.length <= 300\n1 <= strs[i].length <= 300\nstrs[i] consists of lowercase letters only.\nAll words in strs have the same length and are anagrams of each other.",
        "oracle_code": "class Solution {\n    boolean isSimilar(String str1,String str2)\n    {\n        int count=0;\n        for(int i=0;i<str1.length();i++)\n        {\n            if(str1.charAt(i)!=str2.charAt(i))\n            {\n                count++;\n                if(count>2)\n                {\n                    return false;\n                }\n            }\n            \n        }\n        return count==0 || count==2;\n    }\n    void dfs(String curr, String []strs, Set<String> visited)\n    {\n        //base condition\n        if(visited.contains(curr))\n        {\n            return;\n        }\n        visited.add(curr);\n        for(int i=0;i<strs.length;i++)\n        {\n         if(isSimilar(curr,strs[i]))\n         {\n             dfs(strs[i],strs,visited);\n         }   \n        }\n    }\n    public int numSimilarGroups(String[] strs)\n    {\n        int count =0;\n\n        //Base condition\n        if(strs==null ||strs.length ==0)\n        {\n            return 0;\n        }\n\n        //now create a set for visited elements which are similar\n        Set<String> visited = new HashSet<>();\n        for(String s:strs)\n        {\n            if(!visited.contains(s))\n            {\n                dfs(s,strs,visited);\n                count++;\n            }\n        }\n        return count;\n    }\n}",
        "content": "# Intuition\\n![WhatsApp_Image_2023-04-28_at_8.43.47_PM\\\\[1\\\\].jpeg](https://assets.leetcode.com/users/images/fade8110-e5ae-4339-8e4e-a041ca1adfa6_1682695005.1794102.jpeg)\\n![WhatsApp_Image_2023-04-28_at_8.44.14_PM\\\\[1\\\\].jpeg](https://assets.leetcode.com/users/images/bd87a21d-7162-4964-af6b-19a3bc4e3649_1682695016.060982.jpeg)\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    boolean isSimilar(String str1,String str2)\\n    {\\n        int count=0;\\n        for(int i=0;i<str1.length();i++)\\n        {\\n            if(str1.charAt(i)!=str2.charAt(i))\\n            {\\n                count++;\\n                if(count>2)\\n                {\\n                    return false;\\n                }\\n            }\\n            \\n        }\\n        return count==0 || count==2;\\n    }\\n    void dfs(String curr, String []strs, Set<String> visited)\\n    {\\n        //base condition\\n        if(visited.contains(curr))\\n        {\\n            return;\\n        }\\n        visited.add(curr);\\n        for(int i=0;i<strs.length;i++)\\n        {\\n         if(isSimilar(curr,strs[i]))\\n         {\\n             dfs(strs[i],strs,visited);\\n         }   \\n        }\\n    }\\n    public int numSimilarGroups(String[] strs)\\n    {\\n        int count =0;\\n\\n        //Base condition\\n        if(strs==null ||strs.length ==0)\\n        {\\n            return 0;\\n        }\\n\\n        //now create a set for visited elements which are similar\\n        Set<String> visited = new HashSet<>();\\n        for(String s:strs)\\n        {\\n            if(!visited.contains(s))\\n            {\\n                dfs(s,strs,visited);\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
        "level": "hard",
        "type": [
            "colon missing",
            "conditional statement error",
            "wrong comment mark",
            "statement separation"
        ],
        "buggy_code": "\nclass Solution {\n    boolean isSimilar(String str1,String str2)\n    {\n        int count=0;\n        for(int i=0;i<str1.length();i++)\n        {\n            if(str1.charAt(i)!=str2.charAt(i)) count++;\n                if(count>2)\n                {\n                    return false\n                }\n            }\n        }\n        return count==0 /* || count==2 */;\n    }\n    void dfs(String curr, String []strs, Set<String> visited)\n    {\n        if(visited.contains(curr))\n        {\n            return;\n        }\n        visited.add(curr);\n        for(int i=0;i<=strs.length;i++)\n        {\n         if(isSimilar(curr,strs[i])) dfs(strs[i],strs,visited);\n        }\n    }\n    public int numSimilarGroups(String[] strs)\n    {\n        int count =0;\n    \n        if(strs==null ||strs.length ==0)\n        {\n            return 0;\n        }\n    \n        Set<String> visited = new HashSet<>();\n        for(String s:strs)\n        {\n            if(!visited.contains(s)) dfs(s,strs,visited);\n                count++;\n        }\n        return count;\n    }\n}\n\n"
    },
    {
        "slug": "largest-number-after-digit-swaps-by-parity",
        "description": "You are given a positive integer num. You may swap any two digits of num that have the same parity (i.e. both odd digits or both even digits).\nReturn the largest possible value of num after any number of swaps.",
        "examples": [
            "Input: num = 1234\nOutput: 3412\nExplanation: Swap the digit 3 with the digit 1, this results in the number 3214.\nSwap the digit 2 with the digit 4, this results in the number 3412.\nNote that there may be other sequences of swaps but it can be shown that 3412 is the largest possible number.\nAlso note that we may not swap the digit 4 with the digit 1 since they are of different parities.",
            "Input: num = 65875\nOutput: 87655\nExplanation: Swap the digit 8 with the digit 6, this results in the number 85675.\nSwap the first digit 5 with the digit 7, this results in the number 87655.\nNote that there may be other sequences of swaps but it can be shown that 87655 is the largest possible number."
        ],
        "constraints": "1 <= num <= 109",
        "oracle_code": "class Solution {\n    public int largestInteger(int num) {\n        String numString = \"\"+ num;\n        List<Integer> even = new ArrayList<>();\n        List<Integer> odd = new ArrayList<>();\n        for(Character c : numString.toCharArray()){\n            int n = Character.getNumericValue(c);\n            if(n%2==0){\n                even.add(n);\n            }else{\n                odd.add(n);\n            }\n        }\n        Collections.sort(even, Collections.reverseOrder());\n        Collections.sort(odd, Collections.reverseOrder());\n        String res =\"\";\n        int one=0, two=0;\n        for(int i=0; i<numString.length(); i++){\n            int n = Character.getNumericValue(numString.charAt(i));\n            if(n%2==0){\n                res += even.get(one);\n                one++;\n            }else{\n                res += odd.get(two);\n                two++;\n            }\n        }\n        return Integer.parseInt(res);\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nused string and list to store the even and odd elements\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nconverted num in string then added all values from string to even and odd list as per its type;\\nthen sorted both string in desc order\\nas we check from the original string if got even number we will put max even number from even list and incresed even list pointer same for the odd number\\n\\nConverted result string to integer to get int res and returned it\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int largestInteger(int num) {\\n        String numString = \"\"+ num;\\n        List<Integer> even = new ArrayList<>();\\n        List<Integer> odd = new ArrayList<>();\\n        for(Character c : numString.toCharArray()){\\n            int n = Character.getNumericValue(c);\\n            if(n%2==0){\\n                even.add(n);\\n            }else{\\n                odd.add(n);\\n            }\\n        }\\n        Collections.sort(even, Collections.reverseOrder());\\n        Collections.sort(odd, Collections.reverseOrder());\\n        String res =\"\";\\n        int one=0, two=0;\\n        for(int i=0; i<numString.length(); i++){\\n            int n = Character.getNumericValue(numString.charAt(i));\\n            if(n%2==0){\\n                res += even.get(one);\\n                one++;\\n            }else{\\n                res += odd.get(two);\\n                two++;\\n            }\\n        }\\n        return Integer.parseInt(res);\\n    }\\n}\\n```",
        "level": "easy",
        "type": [
            "colon missing",
            "conditional statement error",
            "undefined keywords from other languages",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution {\n    public int largestInteger(int num) {\n        String numString = \"\"+ num;\n        List<Integer> even = new ArrayList<>();\n        List<Integer> odd = new ArrayList<>();\n        for(Character c : numString.toCharArray())\n            int n = Character.getNumericValue(c);\n            if(n%2==0){\n                even.add(n);\n            }else{\n                odd.add(n);\n            }\n        }\n        Collections.sort(even, Collections.reverseOrder());\n        Collections.sort(odd, Collections.reverseOrder());\n        String res =\"\"\n\n        \n        for(int i=0; i<numString.length()+5; i++){\n            int n = Character.getNumericValue(numString.charAt(i));\n            if(n%2==0){\n                res += even.get(one);\n                one++;\n            }else{\n                res += odd.get(two);\n                two++;\n            }\n        }\n        return Integer.parse_int(res);\n    }\n}\n"
    },
    {
        "slug": "number-of-laser-beams-in-a-bank",
        "description": "Anti-theft security devices are activated inside a bank. You are given a 0-indexed binary string array bank representing the floor plan of the bank, which is an m x n 2D matrix. bank[i] represents the ith row, consisting of '0's and '1's. '0' means the cell is empty, while'1' means the cell has a security device.\nThere is one laser beam between any two security devices if both conditions are met:\n\nThe two devices are located on two different rows: r1 and r2, where r1 < r2.\nFor each row i where r1 < i < r2, there are no security devices in the ith row.\n\nLaser beams are independent, i.e., one beam does not interfere nor join with another.\nReturn the total number of laser beams in the bank.",
        "examples": [
            "Input: bank = [\"011001\",\"000000\",\"010100\",\"001000\"]\nOutput: 8\nExplanation: Between each of the following device pairs, there is one beam. In total, there are 8 beams:\n * bank[0][1] -- bank[2][1]\n * bank[0][1] -- bank[2][3]\n * bank[0][2] -- bank[2][1]\n * bank[0][2] -- bank[2][3]\n * bank[0][5] -- bank[2][1]\n * bank[0][5] -- bank[2][3]\n * bank[2][1] -- bank[3][2]\n * bank[2][3] -- bank[3][2]\nNote that there is no beam between any device on the 0th row with any on the 3rd row.\nThis is because the 2nd row contains security devices, which breaks the second condition.",
            "Input: bank = [\"000\",\"111\",\"000\"]\nOutput: 0\nExplanation: There does not exist two devices located on two different rows."
        ],
        "constraints": "m == bank.length\nn == bank[i].length\n1 <= m, n <= 500\nbank[i][j] is either '0' or '1'.",
        "oracle_code": "class Solution {\n    public int numberOfBeams(String[] bank) {\n        int prevLazer =0;\n        int ans =0;\n        for(String s:bank){\n            int curLazer = 0;\n            for(char c: s.toCharArray()){\n                if(c=='1'){\n                    curLazer++;\n                }\n            }\n            if(curLazer >0){\n                ans += (curLazer * prevLazer);\n                prevLazer = curLazer;\n            }\n        }\n        return ans;\n    }\n}",
        "content": "\\n# java Code\\n```\\nclass Solution {\\n    public int numberOfBeams(String[] bank) {\\n        int prevLazer =0;\\n        int ans =0;\\n        for(String s:bank){\\n            int curLazer = 0;\\n            for(char c: s.toCharArray()){\\n                if(c==\\'1\\'){\\n                    curLazer++;\\n                }\\n            }\\n            if(curLazer >0){\\n                ans += (curLazer * prevLazer);\\n                prevLazer = curLazer;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
        "level": "medium",
        "type": [
            "variable value error",
            "== and = confusion",
            "parentheses mismatch",
            "wrong comment mark"
        ],
        "buggy_code": "\nclass Solution {\n    public int numberOfBeams(String[] bank) {\n        int prevLazer =0;\n        int ans =0;\n        for(String s:bank){\n            int curLazer = 0;\n            for(char c: s.toCharArray()){\n                if(c=='1'){\n                    curLazer++;\n            }\n\n                ans += (curLazer * prevLazer);\n                prevLazer = curLazer;\n            if(curLazer = 0){\n                ans += (curLazer * prevLazer);\n                prevLazer = curLazer;\n            } lse{\n                prevLazer = }\n        return ans;\n    }\n}\n\n"
    },
    {
        "slug": "maximum-ice-cream-bars",
        "description": "It is a sweltering summer day, and a boy wants to buy some ice cream bars.\nAt the store, there are n ice cream bars. You are given an array costs of length n, where costs[i] is the price of the ith ice cream bar in coins. The boy initially has coins coins to spend, and he wants to buy as many ice cream bars as possible.\u00a0\nNote: The boy can buy the ice cream bars in any order.\nReturn the maximum number of ice cream bars the boy can buy with coins coins.\nYou must solve the problem by counting sort.",
        "examples": [
            "Input: costs = [1,3,2,4,1], coins = 7\nOutput: 4\nExplanation: The boy can buy ice cream bars at indices 0,1,2,4 for a total price of 1 + 3 + 2 + 1 = 7.",
            "Input: costs = [10,6,8,7,7,8], coins = 5\nOutput: 0\nExplanation: The boy cannot afford any of the ice cream bars.",
            "Input: costs = [1,6,3,1,2,5], coins = 20\nOutput: 6\nExplanation: The boy can buy all the ice cream bars for a total price of 1 + 6 + 3 + 1 + 2 + 5 = 18."
        ],
        "constraints": "costs.length == n\n1 <= n <= 105\n1 <= costs[i] <= 105\n1 <= coins <= 108",
        "oracle_code": "class Solution {\n    public int maxIceCream(int[] costs, int coins) {\n        int [] arr = new int [100001];\n        for(int x : costs)arr[x]++;\n        int count = 0;\n        int index = 1;\n//If coins can buy all the ice-cream at ith index.\n        while(index<100001 && coins>=index*arr[index]){\n            coins-=index*arr[index];\n            count+=arr[index];\n            index++;\n        }\n//If coins can buy onyl some of the ice-creams at ith index.\n        while(index<100001 && coins>=index){\n            coins-=index;\n            count++;\n        }\n        return count;\n    }\n}",
        "content": "# Code\\n```\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        int [] arr = new int [100001];\\n        for(int x : costs)arr[x]++;\\n        int count = 0;\\n        int index = 1;\\n//If coins can buy all the ice-cream at ith index.\\n        while(index<100001 && coins>=index*arr[index]){\\n            coins-=index*arr[index];\\n            count+=arr[index];\\n            index++;\\n        }\\n//If coins can buy onyl some of the ice-creams at ith index.\\n        while(index<100001 && coins>=index){\\n            coins-=index;\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```\\n\\n# Using priority Queue\\n```\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<Integer>(Collections.reverseOrder());\\n        int sum = 0;\\n        for(int x : costs){\\n            if(sum<=coins){\\n                sum+=x;\\n                pq.add(x);\\n            }else if(pq.peek()>x){\\n                sum = sum - pq.poll() + x;\\n                pq.add(x);\\n            }\\n        }\\n        while(sum>coins){\\n            sum-=pq.poll();\\n        }\\n        return pq.size();\\n    }\\n}\\n```",
        "level": "medium",
        "type": [
            "parentheses mismatch",
            "colon missing",
            "undefined objects",
            "statement separation"
        ],
        "buggy_code": "\nclass Solution {\n    public int maxIceCream(int[] costs, int coins) {\n        int [] arr = null;\n        for(int x : costs)arr[x]++;\n        int count = 0;\n        int index = 1;\n        while(index<100001 && coins>=index*arr[index])\n        \n            coins-=index*arr[index];\n            count+=arr[index];\n            index++\n        \n        while(index<100001 && coins>=index){\n            coins-=index;\n            count++;\n        }\n        return count;\n    }\n}\n"
    },
    {
        "slug": "rotating-the-box",
        "description": "You are given an m x n matrix of characters box representing a side-view of a box. Each cell of the box is one of the following:\n\nA stone '#'\nA stationary obstacle '*'\nEmpty '.'\n\nThe box is rotated 90 degrees clockwise, causing some of the stones to fall due to gravity. Each stone falls down until it lands on an obstacle, another stone, or the bottom of the box. Gravity does not affect the obstacles' positions, and the inertia from the box's rotation does not affect the stones' horizontal positions.\nIt is guaranteed that each stone in box rests on an obstacle, another stone, or the bottom of the box.\nReturn an n x m matrix representing the box after the rotation described above.",
        "examples": [
            "Input: box = [[\"#\",\".\",\"#\"]]\r\nOutput: [[\".\"],\r\n\u00a0        [\"#\"],\r\n\u00a0        [\"#\"]]",
            "Input: box = [[\"#\",\".\",\"*\",\".\"],\r\n\u00a0             [\"#\",\"#\",\"*\",\".\"]]\r\nOutput: [[\"#\",\".\"],\r\n\u00a0        [\"#\",\"#\"],\r\n\u00a0        [\"*\",\"*\"],\r\n\u00a0        [\".\",\".\"]]",
            "Input: box = [[\"#\",\"#\",\"*\",\".\",\"*\",\".\"],\r\n\u00a0             [\"#\",\"#\",\"#\",\"*\",\".\",\".\"],\r\n\u00a0             [\"#\",\"#\",\"#\",\".\",\"#\",\".\"]]\r\nOutput: [[\".\",\"#\",\"#\"],\r\n\u00a0        [\".\",\"#\",\"#\"],\r\n\u00a0        [\"#\",\"#\",\"*\"],\r\n\u00a0        [\"#\",\"*\",\".\"],\r\n\u00a0        [\"#\",\".\",\"*\"],\r\n\u00a0        [\"#\",\".\",\".\"]]"
        ],
        "constraints": "m == box.length\nn == box[i].length\n1 <= m, n <= 500\nbox[i][j] is either '#', '*', or '.'.",
        "oracle_code": "// O(n^2) time | O(n^2) space\nclass Solution {\n    public char[][] rotateTheBox(char[][] box) {\n        int m = box.length;\n        int n = box[0].length;\n        char[][] matrix = new char[n][m];   \n        \n        turnBox(box, matrix, m, n); // turn the box clockwise 90 degree\n        \n        turnGravity(matrix, n, m); // cause that falling effect, since matrix turned so n,m\n        \n        return matrix;\n    }\n    \n    public void turnGravity(char[][] matrix, int m, int n){\n        for(int c = 0; c < n; c++){\n            int last  = m-1;\n            for(int r = m-1; r >= 0; r--){\n                char val =  matrix[r][c];\n                if(val == '.') continue;\n                if(val == '*') last = r-1;\n                if(val == '#') {\n                    matrix[r][c] = '.';\n                    matrix[last][c] = '#';\n                    last--;\n                }\n            }\n        }\n    }\n    \n    public void turnBox(char[][] box, char[][] matrix, int m, int n){\n\t// numbers represents sequence it would be copied\n\t//[4][1]\n\t//[5][2]\n\t//[6][3]\n        for(int i = 0, c = m-1; i < m; i++,c--){ // c: 4,3,2,1..\n            for(int j = 0, r = 0; j < n; j++, r++){ // r:0,1,2,3..\n               matrix[r][c] = box[i][j];\n            }\n        }\n    }\n}",
        "content": "**So idea here is**\\n1. First turn 90 degree\\n2. Make things fall\\n\\n```\\n// O(n^2) time | O(n^2) space\\nclass Solution {\\n    public char[][] rotateTheBox(char[][] box) {\\n        int m = box.length;\\n        int n = box[0].length;\\n        char[][] matrix = new char[n][m];   \\n        \\n        turnBox(box, matrix, m, n); // turn the box clockwise 90 degree\\n        \\n        turnGravity(matrix, n, m); // cause that falling effect, since matrix turned so n,m\\n        \\n        return matrix;\\n    }\\n    \\n    public void turnGravity(char[][] matrix, int m, int n){\\n        for(int c = 0; c < n; c++){\\n            int last  = m-1;\\n            for(int r = m-1; r >= 0; r--){\\n                char val =  matrix[r][c];\\n                if(val == \\'.\\') continue;\\n                if(val == \\'*\\') last = r-1;\\n                if(val == \\'#\\') {\\n                    matrix[r][c] = \\'.\\';\\n                    matrix[last][c] = \\'#\\';\\n                    last--;\\n                }\\n            }\\n        }\\n    }\\n    \\n    public void turnBox(char[][] box, char[][] matrix, int m, int n){\\n\\t// numbers represents sequence it would be copied\\n\\t//[4][1]\\n\\t//[5][2]\\n\\t//[6][3]\\n        for(int i = 0, c = m-1; i < m; i++,c--){ // c: 4,3,2,1..\\n            for(int j = 0, r = 0; j < n; j++, r++){ // r:0,1,2,3..\\n               matrix[r][c] = box[i][j];\\n            }\\n        }\\n    }\\n}\\n```",
        "level": "medium",
        "type": [
            "colon missing",
            "wrong comment mark",
            "indexing error",
            "unclosed string"
        ],
        "buggy_code": "\n// O(n^2) time | O(n^2) space\nclass Solution {\n    public char[][] rotateTheBox(char[][] box) {\n        int m = box.length;\n        int n = box[0].length + 1; \n        char[][] matrix = new char[n][m]   \n        \n        turnBox(box, matrix, m, n); // turn the box clockwise 90 degree\n        \n        turnGravity(matrix, n, m); ' cause that falling effect, since matrix turned so n,m\n        \n        return matrix;\n    }\n    \n    public void turnGravity(char[][] matrix, int m, int n){\n        for(int c = 0; c < n; c++){\n            int last  = m-1;\n            for(int r = m-1; r >= 0; r--){\n                char val =  matrix[r][c];\n                if(val == '.') continue;\n                if(val == '*') last = r-1;\n                if(val == '#') {\n                    matrix[r][c] = '.';\n                    matrix[last][c] = '#;\n                    last--;\n                }\n            }\n        }\n    }\n    \n    public void turnBox(char[][] box, char[][] matrix, int m, int n){\n                    for(int i = 0, c = m-1; i < m; i++,c--){\n            for(int j = 0, r = 0; j < n; j++, r++){\n               matrix[r][c] = box[i][j];\n            }\n        }\n    }\n}\n"
    },
    {
        "slug": "relative-ranks",
        "description": "You are given an integer array score of size n, where score[i] is the score of the ith athlete in a competition. All the scores are guaranteed to be unique.\nThe athletes are placed based on their scores, where the 1st place athlete has the highest score, the 2nd place athlete has the 2nd highest score, and so on. The placement of each athlete determines their rank:\n\nThe 1st place athlete's rank is \"Gold Medal\".\nThe 2nd place athlete's rank is \"Silver Medal\".\nThe 3rd place athlete's rank is \"Bronze Medal\".\nFor the 4th place to the nth place athlete, their rank is their placement number (i.e., the xth place athlete's rank is \"x\").\n\nReturn an array answer of size n where answer[i] is the rank of the ith athlete.",
        "examples": [
            "Input: score = [5,4,3,2,1]\nOutput: [\"Gold Medal\",\"Silver Medal\",\"Bronze Medal\",\"4\",\"5\"]\nExplanation: The placements are [1st, 2nd, 3rd, 4th, 5th].",
            "Input: score = [10,3,8,9,4]\nOutput: [\"Gold Medal\",\"5\",\"Bronze Medal\",\"Silver Medal\",\"4\"]\nExplanation: The placements are [1st, 5th, 3rd, 2nd, 4th]."
        ],
        "constraints": "n == score.length\n1 <= n <= 104\n0 <= score[i] <= 106\nAll the values in score are unique.",
        "oracle_code": "class Solution {\n    public String[] findRelativeRanks(int[] score) {\n         int n=score.length;\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[b]-score[a]);\n        for(int i=0;i<n;i++) pq.add(i);\n      String[] ans = new String[n];\n                int i=1;\n        while(!pq.isEmpty()){\n            int idx=pq.poll();\n         if(i==1)   { ans[idx]=\"Gold Medal\"; i++;}\n         else if(i==2)   { ans[idx]=\"Silver Medal\"; i++;}\n         else if(i==3)   { ans[idx]=\"Bronze Medal\"; i++;}\n         else ans[idx]=Integer.toString(i++);\n        }\n        return ans;  \n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String[] findRelativeRanks(int[] score) {\\n         int n=score.length;\\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[b]-score[a]);\\n        for(int i=0;i<n;i++) pq.add(i);\\n      String[] ans = new String[n];\\n                int i=1;\\n        while(!pq.isEmpty()){\\n            int idx=pq.poll();\\n         if(i==1)   { ans[idx]=\"Gold Medal\"; i++;}\\n         else if(i==2)   { ans[idx]=\"Silver Medal\"; i++;}\\n         else if(i==3)   { ans[idx]=\"Bronze Medal\"; i++;}\\n         else ans[idx]=Integer.toString(i++);\\n        }\\n        return ans;  \\n    }\\n}\\n```",
        "level": "easy",
        "type": [
            "operation error",
            "parentheses mismatch",
            "undefined objects",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution {\n    public String[] findRelativeRanks(int[] score) {\n         int n = score.length;\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[a]-score[b]);\n        for(int i=0;i<n;i++) pq.add(i);\n        String[] ans = null;\n                int i=1;\n        while(!pq.isEmpty()){\n            int idx=pq.poll();\n         if(i=1)   { ans[idx]=\"Gold Medal\"; i++;}\n         elif(i=2)   { ans[idx]=\"Silver Medal\"; i++;}\n         else if(i=3)   { ans[idx]=\"Bronze Medal\"; i++;}\n         else ans[idx]=Integer.toString(i++);\n        }\n        return ans;  \n    }\n}\n"
    },
    {
        "slug": "same-tree",
        "description": "Given the roots of two binary trees p and q, write a function to check if they are the same or not.\nTwo binary trees are considered the same if they are structurally identical, and the nodes have the same value.",
        "examples": [
            "Input: p = [1,2,3], q = [1,2,3]\nOutput: true",
            "Input: p = [1,2], q = [1,null,2]\nOutput: false",
            "Input: p = [1,2,1], q = [1,1,2]\nOutput: false"
        ],
        "constraints": "The number of nodes in both trees is in the range [0, 100].\n-104 <= Node.val <= 104",
        "oracle_code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n   \n    public boolean isSameTree(TreeNode p, TreeNode q) {\n     if (p == null && q == null) {\n            return true;\n        }\n        \n        if (p == null || q == null) {\n            return false;\n        }\n        \n        if (p.val != q.val) {\n            return false;\n        }\n        \n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n\n        \n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n   \\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n     if (p == null && q == null) {\\n            return true;\\n        }\\n        \\n        if (p == null || q == null) {\\n            return false;\\n        }\\n        \\n        if (p.val != q.val) {\\n            return false;\\n        }\\n        \\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n\\n        \\n    }\\n}\\n```",
        "level": "easy",
        "type": [
            "parentheses mismatch",
            "conditional statement error",
            "wrong comment mark",
            "undefined methods"
        ],
        "buggy_code": "\n\n\nclass Solution {\n   \n    public boolean isSameTree(TreeNode p, TreeNode q) {\n     if (p == null && q == null) {\n            return true;\n        }\n        \n        if (p == null || q == null) {\n            return false;\n        }\n        \n        if (p.val == q.val) {\n            return false;\n        }\n        \n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n\n        \n    }\n}\n\n/**/\ncheckubcheckub\n"
    },
    {
        "slug": "increasing-decreasing-string",
        "description": "You are given a string s. Reorder the string using the following algorithm:\n\nPick the smallest character from s and append it to the result.\nPick the smallest character from s which is greater than the last appended character to the result and append it.\nRepeat step 2 until you cannot pick more characters.\nPick the largest character from s and append it to the result.\nPick the largest character from s which is smaller than the last appended character to the result and append it.\nRepeat step 5 until you cannot pick more characters.\nRepeat the steps from 1 to 6 until you pick all characters from s.\n\nIn each step, If the smallest or the largest character appears more than once you can choose any occurrence and append it to the result.\nReturn the result string after sorting s with this algorithm.",
        "examples": [
            "Input: s = \"aaaabbbbcccc\"\nOutput: \"abccbaabccba\"\nExplanation: After steps 1, 2 and 3 of the first iteration, result = \"abc\"\nAfter steps 4, 5 and 6 of the first iteration, result = \"abccba\"\nFirst iteration is done. Now s = \"aabbcc\" and we go back to step 1\nAfter steps 1, 2 and 3 of the second iteration, result = \"abccbaabc\"\nAfter steps 4, 5 and 6 of the second iteration, result = \"abccbaabccba\"",
            "Input: s = \"rat\"\nOutput: \"art\"\nExplanation: The word \"rat\" becomes \"art\" after re-ordering it with the mentioned algorithm."
        ],
        "constraints": "1 <= s.length <= 500\ns consists of only lowercase English letters.",
        "oracle_code": "class Solution {\n    public String sortString(String s) {\n        int[] arr = new int[27];\n        String str = \"abcdefghijklmnopqrstuvwxyz\";\n//Find the number of occurrences of each letter in the text S and \n//place it in an array\n        for(int i=0;i<s.length();i++){\n            int num = str.indexOf((s.charAt(i)));\n            arr[++num]=arr[num]+1;\n        }\n\n        int len = s.length();\n        int count=0;\n        StringBuilder ans = new StringBuilder();\n        \n        while(count<len){\n            for(int i=1;i<27;i++){\n                if(arr[i]>0){\n                    ans.append(str.charAt(i - 1));\n                    arr[i]=arr[i]-1;\n                    count++;\n                }\n            }\n            for(int j=26;j>=1;j--){\n                if(arr[j]>0){\n                    ans.append(str.charAt(j - 1));\n                    arr[j]=arr[j]-1;\n                    count++;\n                }\n            }\n        }\n        return new String(ans);\n    }\n}",
        "content": "# Intuition\\n[Java] Finding solutions in an easy, understandable and fast way\\n\\n# Approach\\nThe goal is to find a solution to the example using only while and for operators\\n\\n# Complexity\\n- Time complexity:\\nRuntime: 5 ms       Beats :47.73%\\nMemory:  42.1 MB    Beats :91.92%\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String sortString(String s) {\\n        int[] arr = new int[27];\\n        String str = \"abcdefghijklmnopqrstuvwxyz\";\\n//Find the number of occurrences of each letter in the text S and \\n//place it in an array\\n        for(int i=0;i<s.length();i++){\\n            int num = str.indexOf((s.charAt(i)));\\n            arr[++num]=arr[num]+1;\\n        }\\n\\n        int len = s.length();\\n        int count=0;\\n        StringBuilder ans = new StringBuilder();\\n        \\n        while(count<len){\\n            for(int i=1;i<27;i++){\\n                if(arr[i]>0){\\n                    ans.append(str.charAt(i - 1));\\n                    arr[i]=arr[i]-1;\\n                    count++;\\n                }\\n            }\\n            for(int j=26;j>=1;j--){\\n                if(arr[j]>0){\\n                    ans.append(str.charAt(j - 1));\\n                    arr[j]=arr[j]-1;\\n                    count++;\\n                }\\n            }\\n        }\\n        return new String(ans);\\n    }\\n}\\n```",
        "level": "easy",
        "type": [
            "operation error",
            "undefined objects",
            "unclosed string",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\n    public String sortString(String s) {\n        int[] arr = new int[27];\n        String str = nu;        for(int i=0;i<s.length();i++){\n            int num = str.indexOf((s.charAt(i))); \n            arr[num]=arr[num]+1; \n            ++num; \n        }\n\n        int len = s.length();\n        int count=0;\n        StringBuilder ans = new StringBuilder();\n\n        while(count<len){\n            for(int i=1;i<27;i++){\n                if(arr[i]>0){\n                    ans.append(str.charAt(i - 1)); \n                    arr[i]=arr[i]-1;\n                    count++;\n                }\n            }\n            for(int j=26;j>=1;j--){\n                if(arr[j]>0){\n                    ans.append(str.charAt(j - 1));\n                    arr[j]=arr[j]-1;\n                    count++;\n                }\n            }\n        }\n        return unicornMethod(ans);\n    }\n\n    public String unicornMethod(StringBuilder s) {\n        \n    }\n}\n"
    },
    {
        "slug": "word-ladder",
        "description": "A transformation sequence from word beginWord to word endWord using a dictionary wordList is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that:\n\nEvery adjacent pair of words differs by a single letter.\nEvery si for 1 <= i <= k is in wordList. Note that beginWord does not need to be in wordList.\nsk == endWord\n\nGiven two words, beginWord and endWord, and a dictionary wordList, return the number of words in the shortest transformation sequence from beginWord to endWord, or 0 if no such sequence exists.",
        "examples": [
            "Input: beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\nOutput: 5\nExplanation: One shortest transformation sequence is \"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> cog\", which is 5 words long.",
            "Input: beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\nOutput: 0\nExplanation: The endWord \"cog\" is not in wordList, therefore there is no valid transformation sequence."
        ],
        "constraints": "1 <= beginWord.length <= 10\nendWord.length == beginWord.length\n1 <= wordList.length <= 5000\nwordList[i].length == beginWord.length\nbeginWord, endWord, and wordList[i] consist of lowercase English letters.\nbeginWord != endWord\nAll the words in wordList are unique.",
        "oracle_code": "class Pair{\n    String first;\n    int second;\n    Pair(String first,int second){\n        this.first=first;\n        this.second=second;\n    }\n}\nclass Solution {\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        Queue<Pair> q=new ArrayDeque<>();\n        //initially adding beginword and sequence length 1 into queue\n        q.add(new Pair(beginWord,1));\n        //adding all words in HashSet \n        HashSet<String> set=new HashSet<>();\n        for(int i=0;i<wordList.size();i++){\n            set.add(wordList.get(i));\n        }\n        set.remove(beginWord);\n        while(!q.isEmpty()){\n            String rem=q.peek().first;\n            int steps=q.peek().second;\n            q.remove();\n            if(rem.equals(endWord))return steps;\n            \n            //TC:N * rem.length * 26 *  0(1){hashset}\n            //SC: 0(N) hashSet\n\n            //for every character doing a change,so traverse to all the characters\n            for(int i=0;i<rem.length();i++){\n                for(char ch='a';ch<='z';ch++){\n                    char replacedcharArray[]=rem.toCharArray();\n                    replacedcharArray[i]=ch;\n                    String replacedword=new String(replacedcharArray);\n                    //exist in the set?\n                    if(set.contains(replacedword)){\n                        set.remove(replacedword);\n                        q.add(new Pair(replacedword,steps+1));\n                    }\n                }\n            }\n\n        }\n        return 0;\n\n    }\n}",
        "content": "# Approach\\nBFS\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:N * rem.length * 26 *  0(1){hashset}\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(N) hashSet\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Pair{\\n    String first;\\n    int second;\\n    Pair(String first,int second){\\n        this.first=first;\\n        this.second=second;\\n    }\\n}\\nclass Solution {\\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\\n        Queue<Pair> q=new ArrayDeque<>();\\n        //initially adding beginword and sequence length 1 into queue\\n        q.add(new Pair(beginWord,1));\\n        //adding all words in HashSet \\n        HashSet<String> set=new HashSet<>();\\n        for(int i=0;i<wordList.size();i++){\\n            set.add(wordList.get(i));\\n        }\\n        set.remove(beginWord);\\n        while(!q.isEmpty()){\\n            String rem=q.peek().first;\\n            int steps=q.peek().second;\\n            q.remove();\\n            if(rem.equals(endWord))return steps;\\n            \\n            //TC:N * rem.length * 26 *  0(1){hashset}\\n            //SC: 0(N) hashSet\\n\\n            //for every character doing a change,so traverse to all the characters\\n            for(int i=0;i<rem.length();i++){\\n                for(char ch=\\'a\\';ch<=\\'z\\';ch++){\\n                    char replacedcharArray[]=rem.toCharArray();\\n                    replacedcharArray[i]=ch;\\n                    String replacedword=new String(replacedcharArray);\\n                    //exist in the set?\\n                    if(set.contains(replacedword)){\\n                        set.remove(replacedword);\\n                        q.add(new Pair(replacedword,steps+1));\\n                    }\\n                }\\n            }\\n\\n        }\\n        return 0;\\n\\n    }\\n}\\n```",
        "level": "hard",
        "type": [
            "conditional statement error",
            "indexing error",
            "undefined objects",
            "unclosed string"
        ],
        "buggy_code": "\nclass Pair{\n    String first;\n    int second;\n    Pair(String first,int second){\n        this.first=\"first;\n        this.second=second;\n    }\n}\nclass Solution {\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        Queue<Pair> q=new ArrayDeque<>();\n        PufinedPair;\n        .add(definedPair);\n        HashSet<String> set=new HashSet<>();\n        for(int i=0;i<=wordList.size();i++){\n            set.add(wordList.get(i));\n        }\n        set.remove(beginWord);\n        while(!q.isEmpty()){\n            String rem=q.peek().first;\n            int steps=q.peek().second;\n            q.remove();\n            \n            for(int i=0;i<rem.length();i++){\n                for(char ch='a';ch<='z';ch++){\n                    char replacedcharArray[]=rem.toCharArray();\n                    replacedcharArray[i]=ch;\n                    String replacedword=new String(replacedcharArray);\n                    if(set.contains(replacedword)){\n                        set.remove(replacedword);\n                        q.add(new Pair(replacedword,steps+1));\n                    }\n                }\n            }\n        }\n        return 0;\n    }\n}\n"
    },
    {
        "slug": "daily-temperatures",
        "description": "Given an array of integers temperatures represents the daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after the ith day to get a warmer temperature. If there is no future day for which this is possible, keep answer[i] == 0 instead.",
        "examples": [
            "Input: temperatures = [73,74,75,71,69,72,76,73]\nOutput: [1,1,4,2,1,1,0,0]",
            "Input: temperatures = [30,40,50,60]\nOutput: [1,1,1,0]",
            "Input: temperatures = [30,60,90]\nOutput: [1,1,0]"
        ],
        "constraints": "1 <=\u00a0temperatures.length <= 105\n30 <=\u00a0temperatures[i] <= 100",
        "oracle_code": "class Solution {\n    public int[] dailyTemperatures(int[] temperatures) {\n        \n        int[] arr = new int[temperatures.length]; \n        \n        ArrayDeque<int[]> st = new ArrayDeque<>(); \n        \n        int i=0, j=temperatures.length-1 ; \n        \n        while( j >= 0){\n            \n            if(st.size()==0){\n                arr[i++] = 0;\n            }\n            else  if (st.size()>0 && st.peek()[0]>temperatures[j])\n            {\n                arr[i++]=1;\n            } \n            else if (st.size()>0 && st.peek()[0]<=temperatures[j])\n            \n            {  while(st.size()>0 && st.peek()[0]<=temperatures[j]){\n                    st.pop();\n                    \n                }\n            if(st.size()==0){\n                arr[i++]=0;\n            }\n            else{\n                arr[i++]=st.peek()[1]-j;\n            }\n            } \n        st.push(new int[]{temperatures[j],j}); \n        j--;\n        }\n        \n      \n        int[] ans = new int[temperatures.length]; int k=0;\n        for(i=arr.length-1; i>=0; i--){\n            ans[k++]=arr[i];\n        }\n        return ans;\n    }\n}",
        "content": "```\\nclass Solution {\\n    public int[] dailyTemperatures(int[] temperatures) {\\n        \\n        int[] arr = new int[temperatures.length]; \\n        \\n        ArrayDeque<int[]> st = new ArrayDeque<>(); \\n        \\n        int i=0, j=temperatures.length-1 ; \\n        \\n        while( j >= 0){\\n            \\n            if(st.size()==0){\\n                arr[i++] = 0;\\n            }\\n            else  if (st.size()>0 && st.peek()[0]>temperatures[j])\\n            {\\n                arr[i++]=1;\\n            } \\n            else if (st.size()>0 && st.peek()[0]<=temperatures[j])\\n            \\n            {  while(st.size()>0 && st.peek()[0]<=temperatures[j]){\\n                    st.pop();\\n                    \\n                }\\n            if(st.size()==0){\\n                arr[i++]=0;\\n            }\\n            else{\\n                arr[i++]=st.peek()[1]-j;\\n            }\\n            } \\n        st.push(new int[]{temperatures[j],j}); \\n        j--;\\n        }\\n        \\n      \\n        int[] ans = new int[temperatures.length]; int k=0;\\n        for(i=arr.length-1; i>=0; i--){\\n            ans[k++]=arr[i];\\n        }\\n        return ans;\\n    }\\n}",
        "level": "medium",
        "type": [
            "variable value error",
            "wrong comment mark",
            "indexing error",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution {\n    public int[] dailyTemperatures(int[] temperatures) {\n        \n        int[] arr = new int[temperatures.length + 1]; \n        \n        ArrayDeque<int[]> st = new ArrayDeque<>(); \n        \n        int i=0, j=temperatures.length ; \n        \n        while( j >= 0){\n            \n            if(st.size()==0){\n                arr[i++] = 0;\n            }\n            else  if (st.size()>0 && st.peek()[0]>temperatures[j])\n            {\n                arr[i++]=1;\n            } \n            else if (st.size()>0 && st.peek()[0]<=temperatures[j])\n            \n            {  while(st.size()>0 && st.peek()[0]<=temperatures[j]){\n                    st.pop();\n                    \n                }\n            if(st.size()==0){\n                arr[i++]=0;\n            }\n            else{\n                arr[i++]=st.peek()[1]-j;\n            }\n            } \n        st.push(new int[]{temperatures[j],j}); \n        j--;\n        }\n        \n      \n        int[] ans = new int[temperatures.length]; int k=0;\n        for(i=arr.length-1/**/ + ; \n        return ans;\n    }\n}\n\n"
    },
    {
        "slug": "relative-ranks",
        "description": "You are given an integer array score of size n, where score[i] is the score of the ith athlete in a competition. All the scores are guaranteed to be unique.\nThe athletes are placed based on their scores, where the 1st place athlete has the highest score, the 2nd place athlete has the 2nd highest score, and so on. The placement of each athlete determines their rank:\n\nThe 1st place athlete's rank is \"Gold Medal\".\nThe 2nd place athlete's rank is \"Silver Medal\".\nThe 3rd place athlete's rank is \"Bronze Medal\".\nFor the 4th place to the nth place athlete, their rank is their placement number (i.e., the xth place athlete's rank is \"x\").\n\nReturn an array answer of size n where answer[i] is the rank of the ith athlete.",
        "examples": [
            "Input: score = [5,4,3,2,1]\nOutput: [\"Gold Medal\",\"Silver Medal\",\"Bronze Medal\",\"4\",\"5\"]\nExplanation: The placements are [1st, 2nd, 3rd, 4th, 5th].",
            "Input: score = [10,3,8,9,4]\nOutput: [\"Gold Medal\",\"5\",\"Bronze Medal\",\"Silver Medal\",\"4\"]\nExplanation: The placements are [1st, 5th, 3rd, 2nd, 4th]."
        ],
        "constraints": "n == score.length\n1 <= n <= 104\n0 <= score[i] <= 106\nAll the values in score are unique.",
        "oracle_code": "class Solution {\n    public String[] findRelativeRanks(int[] score) {\n         int n=score.length;\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[b]-score[a]);\n        for(int i=0;i<n;i++) pq.add(i);\n      String[] ans = new String[n];\n                int i=1;\n        while(!pq.isEmpty()){\n            int idx=pq.poll();\n         if(i==1)   { ans[idx]=\"Gold Medal\"; i++;}\n         else if(i==2)   { ans[idx]=\"Silver Medal\"; i++;}\n         else if(i==3)   { ans[idx]=\"Bronze Medal\"; i++;}\n         else ans[idx]=Integer.toString(i++);\n        }\n        return ans;  \n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String[] findRelativeRanks(int[] score) {\\n         int n=score.length;\\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[b]-score[a]);\\n        for(int i=0;i<n;i++) pq.add(i);\\n      String[] ans = new String[n];\\n                int i=1;\\n        while(!pq.isEmpty()){\\n            int idx=pq.poll();\\n         if(i==1)   { ans[idx]=\"Gold Medal\"; i++;}\\n         else if(i==2)   { ans[idx]=\"Silver Medal\"; i++;}\\n         else if(i==3)   { ans[idx]=\"Bronze Medal\"; i++;}\\n         else ans[idx]=Integer.toString(i++);\\n        }\\n        return ans;  \\n    }\\n}\\n```",
        "level": "easy",
        "type": [
            "operation error",
            "== and = confusion",
            "unclosed string",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\n    public String[] findRelativeRanks(int[] score) {\n         int n = score.length;\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[a]-score[b]);\n        for(int i=0;i<n;i++) pq.add(i);\n          String[] ans = new String[n];\n        int i=1;\n        while(!pq.isEmpty()){\n            int idx=pq.poll();\n            if(i=1) { ans[idx]=\"Gold Medal; i++;} \n            else if(i=2) { ans[idx]=\"Silver Medal; i++;} \n            else if(i=3) { ans[idx]=\"Bronze Medal; i++;} \n            else ans[idx]=Integer.toString(i++);\n        }\n        return reorderArray(ans);  \n    }\n\n    private String[] reorderArray(String[] ranks){\n        \n    }\n}\n"
    },
    {
        "slug": "relative-ranks",
        "description": "You are given an integer array score of size n, where score[i] is the score of the ith athlete in a competition. All the scores are guaranteed to be unique.\nThe athletes are placed based on their scores, where the 1st place athlete has the highest score, the 2nd place athlete has the 2nd highest score, and so on. The placement of each athlete determines their rank:\n\nThe 1st place athlete's rank is \"Gold Medal\".\nThe 2nd place athlete's rank is \"Silver Medal\".\nThe 3rd place athlete's rank is \"Bronze Medal\".\nFor the 4th place to the nth place athlete, their rank is their placement number (i.e., the xth place athlete's rank is \"x\").\n\nReturn an array answer of size n where answer[i] is the rank of the ith athlete.",
        "examples": [
            "Input: score = [5,4,3,2,1]\nOutput: [\"Gold Medal\",\"Silver Medal\",\"Bronze Medal\",\"4\",\"5\"]\nExplanation: The placements are [1st, 2nd, 3rd, 4th, 5th].",
            "Input: score = [10,3,8,9,4]\nOutput: [\"Gold Medal\",\"5\",\"Bronze Medal\",\"Silver Medal\",\"4\"]\nExplanation: The placements are [1st, 5th, 3rd, 2nd, 4th]."
        ],
        "constraints": "n == score.length\n1 <= n <= 104\n0 <= score[i] <= 106\nAll the values in score are unique.",
        "oracle_code": "class Solution {\n    public String[] findRelativeRanks(int[] score) {\n         int n=score.length;\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[b]-score[a]);\n        for(int i=0;i<n;i++) pq.add(i);\n      String[] ans = new String[n];\n                int i=1;\n        while(!pq.isEmpty()){\n            int idx=pq.poll();\n         if(i==1)   { ans[idx]=\"Gold Medal\"; i++;}\n         else if(i==2)   { ans[idx]=\"Silver Medal\"; i++;}\n         else if(i==3)   { ans[idx]=\"Bronze Medal\"; i++;}\n         else ans[idx]=Integer.toString(i++);\n        }\n        return ans;  \n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String[] findRelativeRanks(int[] score) {\\n         int n=score.length;\\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[b]-score[a]);\\n        for(int i=0;i<n;i++) pq.add(i);\\n      String[] ans = new String[n];\\n                int i=1;\\n        while(!pq.isEmpty()){\\n            int idx=pq.poll();\\n         if(i==1)   { ans[idx]=\"Gold Medal\"; i++;}\\n         else if(i==2)   { ans[idx]=\"Silver Medal\"; i++;}\\n         else if(i==3)   { ans[idx]=\"Bronze Medal\"; i++;}\\n         else ans[idx]=Integer.toString(i++);\\n        }\\n        return ans;  \\n    }\\n}\\n```",
        "level": "easy",
        "type": [
            "operation error",
            "parentheses mismatch",
            "unclosed string",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\n    public String[] findRelativeRanks(int[] score) {\n         int n = score.length;\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[a]-score[b]);\n        for(int i=0;i<n;i++) pq.add(i);\n        String[] ans = new String[n];\n                int i=1;\n        while(!pq.isEmpty()){\n            int idx=pq.poll();\n         if(i=1)   { ans[idx]=\"Gold Medal; i++;}\n         else if(i=2)   { ans[idx]=\"Silver Medal; i++;}\n         else if(i=3)   { ans[idx]=\"Bronze Medal; i++;}\n         else ans[idx]=Integer.toString(i++);\n        }\n        return reorderArray(ans);  \n    }\n\n    private String[] reorderArray(String[] ranks){\n        \n    }\n}\n"
    },
    {
        "slug": "largest-number-after-digit-swaps-by-parity",
        "description": "You are given a positive integer num. You may swap any two digits of num that have the same parity (i.e. both odd digits or both even digits).\nReturn the largest possible value of num after any number of swaps.",
        "examples": [
            "Input: num = 1234\nOutput: 3412\nExplanation: Swap the digit 3 with the digit 1, this results in the number 3214.\nSwap the digit 2 with the digit 4, this results in the number 3412.\nNote that there may be other sequences of swaps but it can be shown that 3412 is the largest possible number.\nAlso note that we may not swap the digit 4 with the digit 1 since they are of different parities.",
            "Input: num = 65875\nOutput: 87655\nExplanation: Swap the digit 8 with the digit 6, this results in the number 85675.\nSwap the first digit 5 with the digit 7, this results in the number 87655.\nNote that there may be other sequences of swaps but it can be shown that 87655 is the largest possible number."
        ],
        "constraints": "1 <= num <= 109",
        "oracle_code": "class Solution {\n    public int largestInteger(int num) {\n        String numString = \"\"+ num;\n        List<Integer> even = new ArrayList<>();\n        List<Integer> odd = new ArrayList<>();\n        for(Character c : numString.toCharArray()){\n            int n = Character.getNumericValue(c);\n            if(n%2==0){\n                even.add(n);\n            }else{\n                odd.add(n);\n            }\n        }\n        Collections.sort(even, Collections.reverseOrder());\n        Collections.sort(odd, Collections.reverseOrder());\n        String res =\"\";\n        int one=0, two=0;\n        for(int i=0; i<numString.length(); i++){\n            int n = Character.getNumericValue(numString.charAt(i));\n            if(n%2==0){\n                res += even.get(one);\n                one++;\n            }else{\n                res += odd.get(two);\n                two++;\n            }\n        }\n        return Integer.parseInt(res);\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nused string and list to store the even and odd elements\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nconverted num in string then added all values from string to even and odd list as per its type;\\nthen sorted both string in desc order\\nas we check from the original string if got even number we will put max even number from even list and incresed even list pointer same for the odd number\\n\\nConverted result string to integer to get int res and returned it\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int largestInteger(int num) {\\n        String numString = \"\"+ num;\\n        List<Integer> even = new ArrayList<>();\\n        List<Integer> odd = new ArrayList<>();\\n        for(Character c : numString.toCharArray()){\\n            int n = Character.getNumericValue(c);\\n            if(n%2==0){\\n                even.add(n);\\n            }else{\\n                odd.add(n);\\n            }\\n        }\\n        Collections.sort(even, Collections.reverseOrder());\\n        Collections.sort(odd, Collections.reverseOrder());\\n        String res =\"\";\\n        int one=0, two=0;\\n        for(int i=0; i<numString.length(); i++){\\n            int n = Character.getNumericValue(numString.charAt(i));\\n            if(n%2==0){\\n                res += even.get(one);\\n                one++;\\n            }else{\\n                res += odd.get(two);\\n                two++;\\n            }\\n        }\\n        return Integer.parseInt(res);\\n    }\\n}\\n```",
        "level": "easy",
        "type": [
            "colon missing",
            "conditional statement error",
            "wrong comment mark",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution {\n    public int largestInteger(int num) {\n        String numString = \"\"+ num;\n        /*List<Integer> even = new ArrayList<>();*/\n        List<Integer> odd = new ArrayList<>();\n        for(Character c : numString.toCharArray())\n            int n = Character.getNumericValue(c);\n            if(n%2==0){\n                even.add(n);\n            }else{\n                odd.add(n);\n            }\n        }\n        Collections.sort(even, Collections.reverseOrder());\n        Collections.sort(odd, Collections.reverseOrder());\n        String res =\"\"\n\n        \n        for(int i=0; i<numString.length()+5; i++){\n            int n = Character.getNumericValue(numString.charAt(i));\n            if(n%2==0){\n                res += even.get(one);\n                one++;\n            }else{\n                res += odd.get(two);\n                two++;\n            }\n        }\n        return Integer.parseInt(res);\n    }\n}\n"
    },
    {
        "slug": "remove-colored-pieces-if-both-neighbors-are-the-same-color",
        "description": "There are n pieces arranged in a line, and each piece is colored either by 'A' or by 'B'. You are given a string colors of length n where colors[i] is the color of the ith piece.\nAlice and Bob are playing a game where they take alternating turns removing pieces from the line. In this game, Alice moves first.\n\nAlice is only allowed to remove a piece colored 'A' if both its neighbors are also colored 'A'. She is not allowed to remove pieces that are colored 'B'.\nBob is only allowed to remove a piece colored 'B' if both its neighbors are also colored 'B'. He is not allowed to remove pieces that are colored 'A'.\nAlice and Bob cannot remove pieces from the edge of the line.\nIf a player cannot make a move on their turn, that player loses and the other player wins.\n\nAssuming Alice and Bob play optimally, return true if Alice wins, or return false if Bob wins.",
        "examples": [
            "Input: colors = \"AAABABB\"\nOutput: true\nExplanation:\nAAABABB -> AABABB\nAlice moves first.\nShe removes the second 'A' from the left since that is the only 'A' whose neighbors are both 'A'.\n\nNow it's Bob's turn.\nBob cannot make a move on his turn since there are no 'B's whose neighbors are both 'B'.\nThus, Alice wins, so return true.",
            "Input: colors = \"AA\"\nOutput: false\nExplanation:\nAlice has her turn first.\nThere are only two 'A's and both are on the edge of the line, so she cannot move on her turn.\nThus, Bob wins, so return false.",
            "Input: colors = \"ABBBBBBBAAA\"\nOutput: false\nExplanation:\nABBBBBBBAAA -> ABBBBBBBAA\nAlice moves first.\nHer only option is to remove the second to last 'A' from the right.\n\nABBBBBBBAA -> ABBBBBBAA\nNext is Bob's turn.\nHe has many options for which 'B' piece to remove. He can pick any.\n\nOn Alice's second turn, she has no more pieces that she can remove.\nThus, Bob wins, so return false."
        ],
        "constraints": "1 <=\u00a0colors.length <= 105\ncolors\u00a0consists of only the letters\u00a0'A'\u00a0and\u00a0'B'",
        "oracle_code": "class Solution {\n    public boolean winnerOfGame(String s) {\n        //count the triplets\nint n = s.length();\n    \n        int a=0;\n        int b=0;\n        \n        for(int i=1; i<n-1; i++)\n        {\n            if(s.charAt(i)=='A' && s.charAt(i-1)=='A' && s.charAt(i+1)=='A' )\n        a++;\n            else if(s.charAt(i)=='B' && s.charAt(i-1)=='B' && s.charAt(i+1)=='B' )\n        b++;\n            \n            }\n        if(a<=b)\n            return false;\n        else\n            return true;\n        \n    \n    }\n}",
        "content": "Idea behind it is that you need to count the number of triplets of both A and B \\nint a -> number of triplets of \\'A\\'\\nint b -> number of triplets of \\'B\\'\\nif(b>=a) BOB wins else Alice wins\\n\\nAs Alice has to make a move first so if she wants to win there should be atleast  1 more  triplets of A than B\\n\\nEg There are 4 triplets of both A and B  (a=4, b=4) \\n1. Alice removes 1 A (a=3, b=4)\\n2. Bob removes 1 B (a=3, b=3)\\n3. (a=2, b=3)\\n4. (a=2, b=2)\\n5. (a=1, b=2)\\n6. (a=1, b=1)\\n7. (a=0, b=1)\\n\\nClearly Alice will lose if both have same number of triplets\\nCode \\n\\n```\\nclass Solution {\\n    public boolean winnerOfGame(String s) {\\n        //count the triplets\\nint n = s.length();\\n    \\n        int a=0;\\n        int b=0;\\n        \\n        for(int i=1; i<n-1; i++)\\n        {\\n            if(s.charAt(i)==\\'A\\' && s.charAt(i-1)==\\'A\\' && s.charAt(i+1)==\\'A\\' )\\n        a++;\\n            else if(s.charAt(i)==\\'B\\' && s.charAt(i-1)==\\'B\\' && s.charAt(i+1)==\\'B\\' )\\n        b++;\\n            \\n            }\\n        if(a<=b)\\n            return false;\\n        else\\n            return true;\\n        \\n    \\n    }\\n}\\n```\\nIf this helped you then please UpVote\\nThanks\\n\\n\\n",
        "level": "medium",
        "type": [
            "== and = confusion",
            "conditional statement error",
            "wrong comment mark",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution {\n    public boolean winnerOfGame(String s) {\n        /count the triplets\n        int n = s.length();\n        \n        int a=0;\n        int b=0;\n        \n        for(int i=1; i<n; i++) \n        {\n            if(s.charAt(i)=='A' && s.charAt(i-1)=='A'&&s.charAt(i+1)=='A')\n            a++;\n            else if(s.charAt(i)=='B' && s.charAt(i-1)=='B' && s.charAt(i+1)=='B' )\n                            b++;\n        }\n\n        if(a<=  ''              b)\n        returnfalse;else\n return true;\n}\n = }\n\n"
    },
    {
        "slug": "number-of-provinces",
        "description": "There are n cities. Some of them are connected, while some are not. If city a is connected directly with city b, and city b is connected directly with city c, then city a is connected indirectly with city c.\nA province is a group of directly or indirectly connected cities and no other cities outside of the group.\nYou are given an n x n matrix isConnected where isConnected[i][j] = 1 if the ith city and the jth city are directly connected, and isConnected[i][j] = 0 otherwise.\nReturn the total number of provinces.",
        "examples": [
            "Input: isConnected = [[1,1,0],[1,1,0],[0,0,1]]\nOutput: 2",
            "Input: isConnected = [[1,0,0],[0,1,0],[0,0,1]]\nOutput: 3"
        ],
        "constraints": "1 <= n <= 200\nn == isConnected.length\nn == isConnected[i].length\nisConnected[i][j] is 1 or 0.\nisConnected[i][i] == 1\nisConnected[i][j] == isConnected[j][i]",
        "oracle_code": "class DSU:\n    def __init__(self, n):\n        self.par = list(range(n))\n        self.rank = [1] * n\n        self.size = 1\n    def find(self, u):\n        if u != self.par[u]:\n            self.par[u] = self.find(self.par[u])\n        return self.par[u]\n    def union(self, u, v):\n        uu, vv = self.find(u), self.find(v)\n        if uu == vv:\n            return False\n        if self.rank[uu] > self.rank[vv]:\n            self.par[vv] = uu\n        elif self.rank[vv] > self.rank[uu]:\n            self.par[uu] = vv\n        else:\n            self.par[uu] = vv\n            self.rank[vv] += 1\n        self.size += 1\n        return True\n\nclass Solution:\n    def isConnected(self, u, v, G):\n        return G[u][v] == 1\n\n    def findCircleNum(self, G: List[List[int]]) -> int:\n        n = len(G)\n        uf = DSU(n)\n        if not G:\n            return 0\n        for u in range(n):\n            for v in range(u, n):\n                if self.isConnected(u, v, G):\n                    uf.union(u, v)\n        return len(set([uf.find(i) for i in range(n)]))",
        "content": "\\n# Code\\n```\\nclass DSU:\\n    def __init__(self, n):\\n        self.par = list(range(n))\\n        self.rank = [1] * n\\n        self.size = 1\\n    def find(self, u):\\n        if u != self.par[u]:\\n            self.par[u] = self.find(self.par[u])\\n        return self.par[u]\\n    def union(self, u, v):\\n        uu, vv = self.find(u), self.find(v)\\n        if uu == vv:\\n            return False\\n        if self.rank[uu] > self.rank[vv]:\\n            self.par[vv] = uu\\n        elif self.rank[vv] > self.rank[uu]:\\n            self.par[uu] = vv\\n        else:\\n            self.par[uu] = vv\\n            self.rank[vv] += 1\\n        self.size += 1\\n        return True\\n\\nclass Solution:\\n    def isConnected(self, u, v, G):\\n        return G[u][v] == 1\\n\\n    def findCircleNum(self, G: List[List[int]]) -> int:\\n        n = len(G)\\n        uf = DSU(n)\\n        if not G:\\n            return 0\\n        for u in range(n):\\n            for v in range(u, n):\\n                if self.isConnected(u, v, G):\\n                    uf.union(u, v)\\n        return len(set([uf.find(i) for i in range(n)]))\\n\\n```",
        "level": "medium",
        "type": [
            "colon missing",
            "conditional statement error",
            "undefined objects",
            "undefined methods"
        ],
        "buggy_code": "\nclass DSU:\n    def __init__(self, n)\n        self.par = list(range(n))\n        self.rank = [1] * n\n        self.size = 1\n    def find(self, u):\n        if u != self.par[u]:\n            self.par[u] = self.find(self.par[u])\n        return self.par[u]\n    def union(self, u, v):\n        uu, vv = self.find(u), self.find(v)\n        if uu == vv:\n            return False\n        if self.rank[uu] > self.rank[vv]:\n            self.par[vv] = uu\n        elif self.rank[vv] > self.rank[uu]:\n            self.par[uu] = vv\n        else:\n            self.par[uu] = vv\n            self.rank[vv] += 1\n        self.size += 1\n        return True\n    def issizemorethanone(self):\n        return self.size > 1\n    \nclass Solution:\n    def isConnected(self, u, v, G):\n        return G[u][v] == 1\n\n    def findCircleNum(self, G) -> int:\n        n = len(G)\n        uf = DSU(n)\n        if not G:\n            return 0\n        for u in range(n):\n            for v in range(n):\n                if self.isConnected(u, v, G):\n                    uf.union(u, v)\n        return len(set([uf.find(i) for i in range(n)]))\n"
    },
    {
        "slug": "probability-of-a-two-boxes-having-the-same-number-of-distinct-balls",
        "description": "Given 2n balls of k distinct colors. You will be given an integer array balls of size k where balls[i] is the number of balls of color i.\nAll the balls will be shuffled uniformly at random, then we will distribute the first n balls to the first box and the remaining n balls to the other box (Please read the explanation of the second example carefully).\nPlease note that the two boxes are considered different. For example, if we have two balls of colors a and b, and two boxes [] and (), then the distribution [a] (b) is considered different than the distribution [b] (a) (Please read the explanation of the first example carefully).\nReturn the probability that the two boxes have the same number of distinct balls. Answers within 10-5 of the actual value will be accepted as correct.",
        "examples": [
            "Input: balls = [1,1]\nOutput: 1.00000\nExplanation: Only 2 ways to divide the balls equally:\n- A ball of color 1 to box 1 and a ball of color 2 to box 2\n- A ball of color 2 to box 1 and a ball of color 1 to box 2\nIn both ways, the number of distinct colors in each box is equal. The probability is 2/2 = 1",
            "Input: balls = [2,1,1]\nOutput: 0.66667\nExplanation: We have the set of balls [1, 1, 2, 3]\nThis set of balls will be shuffled randomly and we may have one of the 12 distinct shuffles with equal probability (i.e. 1/12):\n[1,1 / 2,3], [1,1 / 3,2], [1,2 / 1,3], [1,2 / 3,1], [1,3 / 1,2], [1,3 / 2,1], [2,1 / 1,3], [2,1 / 3,1], [2,3 / 1,1], [3,1 / 1,2], [3,1 / 2,1], [3,2 / 1,1]\nAfter that, we add the first two balls to the first box and the second two balls to the second box.\nWe can see that 8 of these 12 possible random distributions have the same number of distinct colors of balls in each box.\nProbability is 8/12 = 0.66667",
            "Input: balls = [1,2,1,2]\nOutput: 0.60000\nExplanation: The set of balls is [1, 2, 2, 3, 4, 4]. It is hard to display all the 180 possible random shuffles of this set but it is easy to check that 108 of them will have the same number of distinct colors in each box.\nProbability = 108 / 180 = 0.6"
        ],
        "constraints": "1 <= balls.length <= 8\n1 <= balls[i] <= 6\nsum(balls) is even.",
        "oracle_code": "class Solution {\n    double possible = 0.0;\n    double valid = 0.0;\n    \n    public double getProbability(int[] balls) {\n        int[] first = new int[balls.length];\n        int[] second = new int[balls.length];\n        dfs(balls, first, second, 0, 0, 0);\n        return valid / possible;\n    }\n    \n    private void dfs(int[] balls, int[] first, int[] second, int num1, int num2, int idx) {\n        // finish all colors, check if this's a possible/valid distribution\n        if (idx == balls.length) {\n            // find one possible distribution\n            if (num1 == num2) {\n                // compute fake permutation\n                double distrib = permFake(first) * permFake(second);\n                possible += distrib;\n                \n                // find one valid distribution\n                if (unique(first) == unique(second)) {\n                    valid += distrib;\n                }\n            }\n            return;\n        }\n        \n        // distribute balls in current color to two bins\n        for (int b = 0; b <= balls[idx]; b++) {\n            first[idx] = b;\n            second[idx] = balls[idx] - b;\n            dfs (balls, first, second, num1 + first[idx], num2 + second[idx], idx + 1);\n        }\n    }\n    \n    // unique colors in \n    private int unique(int[] balls) {\n        int unique = 0;\n        for (int b: balls)\n            unique += b > 0 ? 1 : 0;\n        return unique;\n    }\n    \n    // return 1 / (b1!b2!b3!...bn!) \n    private double permFake(int[] balls) {\n        double ret = 1.0;\n        for (int b: balls)\n            ret /= factorial(b);\n        return ret;\n    }\n    \n    private int factorial(int n){\n        int ret = 1;\n        while (n > 0) {\n            ret *= n;\n            n--;\n        }\n        return ret;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    double possible = 0.0;\\n    double valid = 0.0;\\n    \\n    public double getProbability(int[] balls) {\\n        int[] first = new int[balls.length];\\n        int[] second = new int[balls.length];\\n        dfs(balls, first, second, 0, 0, 0);\\n        return valid / possible;\\n    }\\n    \\n    private void dfs(int[] balls, int[] first, int[] second, int num1, int num2, int idx) {\\n        // finish all colors, check if this\\'s a possible/valid distribution\\n        if (idx == balls.length) {\\n            // find one possible distribution\\n            if (num1 == num2) {\\n                // compute fake permutation\\n                double distrib = permFake(first) * permFake(second);\\n                possible += distrib;\\n                \\n                // find one valid distribution\\n                if (unique(first) == unique(second)) {\\n                    valid += distrib;\\n                }\\n            }\\n            return;\\n        }\\n        \\n        // distribute balls in current color to two bins\\n        for (int b = 0; b <= balls[idx]; b++) {\\n            first[idx] = b;\\n            second[idx] = balls[idx] - b;\\n            dfs (balls, first, second, num1 + first[idx], num2 + second[idx], idx + 1);\\n        }\\n    }\\n    \\n    // unique colors in \\n    private int unique(int[] balls) {\\n        int unique = 0;\\n        for (int b: balls)\\n            unique += b > 0 ? 1 : 0;\\n        return unique;\\n    }\\n    \\n    // return 1 / (b1!b2!b3!...bn!) \\n    private double permFake(int[] balls) {\\n        double ret = 1.0;\\n        for (int b: balls)\\n            ret /= factorial(b);\\n        return ret;\\n    }\\n    \\n    private int factorial(int n){\\n        int ret = 1;\\n        while (n > 0) {\\n            ret *= n;\\n            n--;\\n        }\\n        return ret;\\n    }\\n}\\n```",
        "level": "hard",
        "type": [
            "== and = confusion",
            "colon missing",
            "undefined objects",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\n    double possible = 0.0;\n    double valid = 0.0;\n    \n    public double getProbability(int[] balls) {\n        int[] first = new int[balls.length];\n        int[] second = null;\n        dfs(balls, first, second, 0, 0, 0)\n        return valid / possible;\n    }\n    \n    private void dfs(int[] balls, int[] first, int[] second, int num1, int num2, int idx) {\n        if (idx == balls.length) {if (num1 = num2) {\n                double distrib = permFake(first) * permFake(second);\n                possible += distrib;\n                if (unique(first) == unique(second)) {\n                    valid += distrib;\n                }\n            }\n            return;\n        }\n        for (int b = 0; b <= balls[idx]; b++) {\n            first[idx] = b;\n            second[idx] = balls[idx] - b;\n            dfs (balls, first, second, num1 + first[idx], num2 + second[idx], idx + 1);\n        }\n    }\n    \n    private int(t[] balls) {\n        int=0;   for ( b: balls)\n           +=b>0?1:0;\n      reurnprivate int factorial(int n){\n        int ret = 1;\n        while (n > 0) {\n            ret *= n;\n            n--;\n        }\n        return ret;\n    }\n}\n"
    },
    {
        "slug": "apply-discount-every-n-orders",
        "description": "There is a supermarket that is frequented by many customers. The products sold at the supermarket are represented as two parallel integer arrays products and prices, where the ith product has an ID of products[i] and a price of prices[i].\nWhen a customer is paying, their bill is represented as two parallel integer arrays product and amount, where the jth product they purchased has an ID of product[j], and amount[j] is how much of the product they bought. Their subtotal is calculated as the sum of each amount[j] * (price of the jth product).\nThe supermarket decided to have a sale. Every nth customer paying for their groceries will be given a percentage discount. The discount amount is given by discount, where they will be given discount percent off their subtotal. More formally, if their subtotal is bill, then they would actually pay bill * ((100 - discount) / 100).\nImplement the Cashier class:\n\nCashier(int n, int discount, int[] products, int[] prices) Initializes the object with n, the discount, and the products and their prices.\ndouble getBill(int[] product, int[] amount) Returns the final total of the bill with the discount applied (if any). Answers within 10-5 of the actual value will be accepted.",
        "examples": [
            "Input\n[\"Cashier\",\"getBill\",\"getBill\",\"getBill\",\"getBill\",\"getBill\",\"getBill\",\"getBill\"]\n[[3,50,[1,2,3,4,5,6,7],[100,200,300,400,300,200,100]],[[1,2],[1,2]],[[3,7],[10,10]],[[1,2,3,4,5,6,7],[1,1,1,1,1,1,1]],[[4],[10]],[[7,3],[10,10]],[[7,5,3,1,6,4,2],[10,10,10,9,9,9,7]],[[2,3,5],[5,3,2]]]\nOutput\n[null,500.0,4000.0,800.0,4000.0,4000.0,7350.0,2500.0]\nExplanation\nCashier cashier = new Cashier(3,50,[1,2,3,4,5,6,7],[100,200,300,400,300,200,100]);\ncashier.getBill([1,2],[1,2]);                        // return 500.0. 1st customer, no discount.\n                                                     // bill = 1 * 100 + 2 * 200 = 500.\ncashier.getBill([3,7],[10,10]);                      // return 4000.0. 2nd customer, no discount.\n                                                     // bill = 10 * 300 + 10 * 100 = 4000.\ncashier.getBill([1,2,3,4,5,6,7],[1,1,1,1,1,1,1]);    // return 800.0. 3rd customer, 50% discount.\n                                                     // Original bill = 1600\n                                                     // Actual bill = 1600 * ((100 - 50) / 100) = 800.\ncashier.getBill([4],[10]);                           // return 4000.0. 4th customer, no discount.\ncashier.getBill([7,3],[10,10]);                      // return 4000.0. 5th customer, no discount.\ncashier.getBill([7,5,3,1,6,4,2],[10,10,10,9,9,9,7]); // return 7350.0. 6th customer, 50% discount.\n                                                     // Original bill = 14700, but with\n                                                     // Actual bill = 14700 * ((100 - 50) / 100) = 7350.\ncashier.getBill([2,3,5],[5,3,2]);                    // return 2500.0.  7th customer, no discount."
        ],
        "constraints": "1 <= n <= 104\n0 <= discount <= 100\n1 <= products.length <= 200\nprices.length == products.length\n1 <= products[i] <= 200\n1 <= prices[i] <= 1000\nThe elements in products are unique.\n1 <= product.length <= products.length\namount.length == product.length\nproduct[j] exists in products.\n1 <= amount[j] <= 1000\nThe elements of product are unique.\nAt most 1000 calls will be made to getBill.\nAnswers within 10-5 of the actual value will be accepted.",
        "oracle_code": "class Cashier {\n    HashMap<Integer,Integer>stock=new HashMap<>();\n    int n;\n    int discount;\n    int itr=0;\n    public Cashier(int n, int discount, int[] products, int[] prices) {\n        for(int i=0;i<products.length;i++){\n            stock.put(products[i],prices[i]);\n        }\n        this.n=n;\n        this.discount=discount;\n    }\n    \n    public double getBill(int[] product, int[] amount) {\n        double total=0;\n        for(int i=0;i<product.length;i++){\n            total+=(double)(amount[i]*stock.get(product[i]));\n        }\n        itr++;\n        if(itr==n){\n            total*=(double)(((100-discount)/100d));\n            itr=0;\n        }\n        return total;\n    }\n}\n\n/**\n * Your Cashier object will be instantiated and called as such:\n * Cashier obj = new Cashier(n, discount, products, prices);\n * double param_1 = obj.getBill(product,amount);\n */",
        "content": "# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Cashier {\\n    HashMap<Integer,Integer>stock=new HashMap<>();\\n    int n;\\n    int discount;\\n    int itr=0;\\n    public Cashier(int n, int discount, int[] products, int[] prices) {\\n        for(int i=0;i<products.length;i++){\\n            stock.put(products[i],prices[i]);\\n        }\\n        this.n=n;\\n        this.discount=discount;\\n    }\\n    \\n    public double getBill(int[] product, int[] amount) {\\n        double total=0;\\n        for(int i=0;i<product.length;i++){\\n            total+=(double)(amount[i]*stock.get(product[i]));\\n        }\\n        itr++;\\n        if(itr==n){\\n            total*=(double)(((100-discount)/100d));\\n            itr=0;\\n        }\\n        return total;\\n    }\\n}\\n\\n/**\\n * Your Cashier object will be instantiated and called as such:\\n * Cashier obj = new Cashier(n, discount, products, prices);\\n * double param_1 = obj.getBill(product,amount);\\n */\\n```",
        "level": "medium",
        "type": [
            "parentheses mismatch",
            "colon missing",
            "wrong comment mark",
            "indexing error"
        ],
        "buggy_code": "\nclass Cashier {\n    HashMap<Integer,Integer>stock=new HashMap<>();\n    int n;\n    int discount;\n    int itr=0;\n    public Cashier(int n, int discount, int[] products, int[] prices {\n        for(int i=0;i<=products.length;i++)\n            stock.put(products[i],prices[i]);\n        }\n        this.n=n;\n        this.discount=discount;\n    }\n    \n    public double getBill(int[] product, int[] amount) {\n        double total=0;\n        for(int i=0;i<product.length;i++)\n            total+=(double)(amount[i]*stock.get(product[i]));\n        }\n        itr++;\n        if(itr==n)\n            total*=(double)(((100-discount)/*100d*/));\n        }\n        itr=0;\n        \n    }\n    return total;\n}\n\n/**\n * Your Cashier object will be instantiated and called as such:\n * Cashier obj = new Cashier(n, discount, products, prices);\n * double param_1 = obj.getBill(product,amount);\n */\n "
    },
    {
        "slug": "probability-of-a-two-boxes-having-the-same-number-of-distinct-balls",
        "description": "Given 2n balls of k distinct colors. You will be given an integer array balls of size k where balls[i] is the number of balls of color i.\nAll the balls will be shuffled uniformly at random, then we will distribute the first n balls to the first box and the remaining n balls to the other box (Please read the explanation of the second example carefully).\nPlease note that the two boxes are considered different. For example, if we have two balls of colors a and b, and two boxes [] and (), then the distribution [a] (b) is considered different than the distribution [b] (a) (Please read the explanation of the first example carefully).\nReturn the probability that the two boxes have the same number of distinct balls. Answers within 10-5 of the actual value will be accepted as correct.",
        "examples": [
            "Input: balls = [1,1]\nOutput: 1.00000\nExplanation: Only 2 ways to divide the balls equally:\n- A ball of color 1 to box 1 and a ball of color 2 to box 2\n- A ball of color 2 to box 1 and a ball of color 1 to box 2\nIn both ways, the number of distinct colors in each box is equal. The probability is 2/2 = 1",
            "Input: balls = [2,1,1]\nOutput: 0.66667\nExplanation: We have the set of balls [1, 1, 2, 3]\nThis set of balls will be shuffled randomly and we may have one of the 12 distinct shuffles with equal probability (i.e. 1/12):\n[1,1 / 2,3], [1,1 / 3,2], [1,2 / 1,3], [1,2 / 3,1], [1,3 / 1,2], [1,3 / 2,1], [2,1 / 1,3], [2,1 / 3,1], [2,3 / 1,1], [3,1 / 1,2], [3,1 / 2,1], [3,2 / 1,1]\nAfter that, we add the first two balls to the first box and the second two balls to the second box.\nWe can see that 8 of these 12 possible random distributions have the same number of distinct colors of balls in each box.\nProbability is 8/12 = 0.66667",
            "Input: balls = [1,2,1,2]\nOutput: 0.60000\nExplanation: The set of balls is [1, 2, 2, 3, 4, 4]. It is hard to display all the 180 possible random shuffles of this set but it is easy to check that 108 of them will have the same number of distinct colors in each box.\nProbability = 108 / 180 = 0.6"
        ],
        "constraints": "1 <= balls.length <= 8\n1 <= balls[i] <= 6\nsum(balls) is even.",
        "oracle_code": "class Solution {\n    double possible = 0.0;\n    double valid = 0.0;\n    \n    public double getProbability(int[] balls) {\n        int[] first = new int[balls.length];\n        int[] second = new int[balls.length];\n        dfs(balls, first, second, 0, 0, 0);\n        return valid / possible;\n    }\n    \n    private void dfs(int[] balls, int[] first, int[] second, int num1, int num2, int idx) {\n        // finish all colors, check if this's a possible/valid distribution\n        if (idx == balls.length) {\n            // find one possible distribution\n            if (num1 == num2) {\n                // compute fake permutation\n                double distrib = permFake(first) * permFake(second);\n                possible += distrib;\n                \n                // find one valid distribution\n                if (unique(first) == unique(second)) {\n                    valid += distrib;\n                }\n            }\n            return;\n        }\n        \n        // distribute balls in current color to two bins\n        for (int b = 0; b <= balls[idx]; b++) {\n            first[idx] = b;\n            second[idx] = balls[idx] - b;\n            dfs (balls, first, second, num1 + first[idx], num2 + second[idx], idx + 1);\n        }\n    }\n    \n    // unique colors in \n    private int unique(int[] balls) {\n        int unique = 0;\n        for (int b: balls)\n            unique += b > 0 ? 1 : 0;\n        return unique;\n    }\n    \n    // return 1 / (b1!b2!b3!...bn!) \n    private double permFake(int[] balls) {\n        double ret = 1.0;\n        for (int b: balls)\n            ret /= factorial(b);\n        return ret;\n    }\n    \n    private int factorial(int n){\n        int ret = 1;\n        while (n > 0) {\n            ret *= n;\n            n--;\n        }\n        return ret;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    double possible = 0.0;\\n    double valid = 0.0;\\n    \\n    public double getProbability(int[] balls) {\\n        int[] first = new int[balls.length];\\n        int[] second = new int[balls.length];\\n        dfs(balls, first, second, 0, 0, 0);\\n        return valid / possible;\\n    }\\n    \\n    private void dfs(int[] balls, int[] first, int[] second, int num1, int num2, int idx) {\\n        // finish all colors, check if this\\'s a possible/valid distribution\\n        if (idx == balls.length) {\\n            // find one possible distribution\\n            if (num1 == num2) {\\n                // compute fake permutation\\n                double distrib = permFake(first) * permFake(second);\\n                possible += distrib;\\n                \\n                // find one valid distribution\\n                if (unique(first) == unique(second)) {\\n                    valid += distrib;\\n                }\\n            }\\n            return;\\n        }\\n        \\n        // distribute balls in current color to two bins\\n        for (int b = 0; b <= balls[idx]; b++) {\\n            first[idx] = b;\\n            second[idx] = balls[idx] - b;\\n            dfs (balls, first, second, num1 + first[idx], num2 + second[idx], idx + 1);\\n        }\\n    }\\n    \\n    // unique colors in \\n    private int unique(int[] balls) {\\n        int unique = 0;\\n        for (int b: balls)\\n            unique += b > 0 ? 1 : 0;\\n        return unique;\\n    }\\n    \\n    // return 1 / (b1!b2!b3!...bn!) \\n    private double permFake(int[] balls) {\\n        double ret = 1.0;\\n        for (int b: balls)\\n            ret /= factorial(b);\\n        return ret;\\n    }\\n    \\n    private int factorial(int n){\\n        int ret = 1;\\n        while (n > 0) {\\n            ret *= n;\\n            n--;\\n        }\\n        return ret;\\n    }\\n}\\n```",
        "level": "hard",
        "type": [
            "operation error",
            "undefined objects",
            "unclosed string",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\n    double possible = 0.0;\n    double valid = 0.0;\n    \n    public double getProbability(int[] balls) {\n        int[] first = new int[balls.length];\n        int[] second = null;\n        dfs(balls, first, second, 0, 0, 0);\n        return valid / possible;\n    }\n    \n    private void dfs(int[] balls, int[] first, int[] second, int num1, int num2, int idx) {\n        if (idx == balls.length) {\n            if (num1 == num2) {\n                double distrib = permFake(first) * permFake(second);\n                possible += distrib;\n                if (unique(first) == unique(second)) {\n                    valid += distrib + 1;    \n                }\n            }\n            return;\n        }\n        for (int b = 0; b <= balls[idx]; b++) {\n            first[idx] = b;\n            second[idx] = balls[idx] - b;\n            dfs (balls, first, second, num1 + first[idx], num2 + second[idx], idx + 1);\n        }\n    }\n    \n    = 0;\n        for (int b: balls)\n            +b > \"?10;returnprivate int factorial(int n){\n        int ret = 1;\n        while (n > 0) {\n            ret *= n;\n            n--;\n        }\n        return ret;\n    }\n}\n"
    },
    {
        "slug": "number-of-laser-beams-in-a-bank",
        "description": "Anti-theft security devices are activated inside a bank. You are given a 0-indexed binary string array bank representing the floor plan of the bank, which is an m x n 2D matrix. bank[i] represents the ith row, consisting of '0's and '1's. '0' means the cell is empty, while'1' means the cell has a security device.\nThere is one laser beam between any two security devices if both conditions are met:\n\nThe two devices are located on two different rows: r1 and r2, where r1 < r2.\nFor each row i where r1 < i < r2, there are no security devices in the ith row.\n\nLaser beams are independent, i.e., one beam does not interfere nor join with another.\nReturn the total number of laser beams in the bank.",
        "examples": [
            "Input: bank = [\"011001\",\"000000\",\"010100\",\"001000\"]\nOutput: 8\nExplanation: Between each of the following device pairs, there is one beam. In total, there are 8 beams:\n * bank[0][1] -- bank[2][1]\n * bank[0][1] -- bank[2][3]\n * bank[0][2] -- bank[2][1]\n * bank[0][2] -- bank[2][3]\n * bank[0][5] -- bank[2][1]\n * bank[0][5] -- bank[2][3]\n * bank[2][1] -- bank[3][2]\n * bank[2][3] -- bank[3][2]\nNote that there is no beam between any device on the 0th row with any on the 3rd row.\nThis is because the 2nd row contains security devices, which breaks the second condition.",
            "Input: bank = [\"000\",\"111\",\"000\"]\nOutput: 0\nExplanation: There does not exist two devices located on two different rows."
        ],
        "constraints": "m == bank.length\nn == bank[i].length\n1 <= m, n <= 500\nbank[i][j] is either '0' or '1'.",
        "oracle_code": "class Solution {\n    public int numberOfBeams(String[] bank) {\n        int prevLazer =0;\n        int ans =0;\n        for(String s:bank){\n            int curLazer = 0;\n            for(char c: s.toCharArray()){\n                if(c=='1'){\n                    curLazer++;\n                }\n            }\n            if(curLazer >0){\n                ans += (curLazer * prevLazer);\n                prevLazer = curLazer;\n            }\n        }\n        return ans;\n    }\n}",
        "content": "\\n# java Code\\n```\\nclass Solution {\\n    public int numberOfBeams(String[] bank) {\\n        int prevLazer =0;\\n        int ans =0;\\n        for(String s:bank){\\n            int curLazer = 0;\\n            for(char c: s.toCharArray()){\\n                if(c==\\'1\\'){\\n                    curLazer++;\\n                }\\n            }\\n            if(curLazer >0){\\n                ans += (curLazer * prevLazer);\\n                prevLazer = curLazer;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
        "level": "medium",
        "type": [
            "parentheses mismatch",
            "wrong comment mark",
            "undefined keywords from other languages",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution {\n    public int numberOfBeams(String[] bank) {\n        int prevLazer =0;\n        int ans =0;\n        for(String s:bank){\n            int curLazer = 0;\n            for(char c: s.toCharArray()){\n                if(c=='1){\n                    curLazer++;\n            }\n\n                ans += (curLazer * prevLazer);\n                prevLazer = curLazer;\n            }\n        return ans;\n    }\n}\npit()\n    return ans;    \n}\n\"The total number of beams is: \" + \n"
    },
    {
        "slug": "largest-3-same-digit-number-in-string",
        "description": "You are given a string num representing a large integer. An integer is good if it meets the following conditions:\n\nIt is a substring of num with length 3.\nIt consists of only one unique digit.\n\nReturn the maximum good integer as a string or an empty string \"\" if no such integer exists.\nNote:\n\nA substring is a contiguous sequence of characters within a string.\nThere may be leading zeroes in num or a good integer.",
        "examples": [
            "Input: num = \"6777133339\"\nOutput: \"777\"\nExplanation: There are two distinct good integers: \"777\" and \"333\".\n\"777\" is the largest, so we return \"777\".",
            "Input: num = \"2300019\"\nOutput: \"000\"\nExplanation: \"000\" is the only good integer.",
            "Input: num = \"42352338\"\nOutput: \"\"\nExplanation: No substring of length 3 consists of only one unique digit. Therefore, there are no good integers."
        ],
        "constraints": "3 <= num.length <= 1000\nnum only consists of digits.",
        "oracle_code": "class Solution {\n    public String largestGoodInteger(String num) {\n        int n=-1;\n        StringBuilder sb = new StringBuilder();\n        for(int i=0;i<num.length()-2;i++){\n            if(num.charAt(i)==num.charAt(i+1) && num.charAt(i)==num.charAt(i+2)){\n                sb.append(num.charAt(i));\n                sb.append(num.charAt(i));\n                sb.append(num.charAt(i));\n                if(Integer.parseInt(sb.toString())>n)\n                    n=Integer.parseInt(sb.toString());\n                sb.setLength(0);\n            }\n        }\n        if(n==-1)\n            return \"\";\n        String s = Integer.toString(n);\n        if(s.equals(\"0\"))\n            return \"000\";\n        return s;\n    }\n}",
        "content": "```\\nclass Solution {\\n    public String largestGoodInteger(String num) {\\n        int n=-1;\\n        StringBuilder sb = new StringBuilder();\\n        for(int i=0;i<num.length()-2;i++){\\n            if(num.charAt(i)==num.charAt(i+1) && num.charAt(i)==num.charAt(i+2)){\\n                sb.append(num.charAt(i));\\n                sb.append(num.charAt(i));\\n                sb.append(num.charAt(i));\\n                if(Integer.parseInt(sb.toString())>n)\\n                    n=Integer.parseInt(sb.toString());\\n                sb.setLength(0);\\n            }\\n        }\\n        if(n==-1)\\n            return \"\";\\n        String s = Integer.toString(n);\\n        if(s.equals(\"0\"))\\n            return \"000\";\\n        return s;\\n    }\\n}\\n```\\nKindly upvote if you like the code.",
        "level": "easy",
        "type": [
            "conditional statement error",
            "wrong comment mark",
            "undefined objects",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution {\n    UndefinedObject largestGoodInteger; \n    public String largestGoodInteger(String num) {\n        int n=-1;\n        StringBuilder sb = new StringBuilder();\n        for(int i=0;i<=num.length()-2;i++){\n            if(num.charAt(i)==num.charAt(i+1) && num.charAt(i)==num.charAt(i+2)){\n                sb.append(num.charAt(i));\n                sb.append(num.charAt(i));\n                sb.append(num.charAt(i));\n                if(Integer.parseInt(sb.toString())>n)\n                    n=Integer.parseInt(sb.toString());\n                sb.setLength(0);\n                /*\n            }\n        }\n        if(n==-1)\n            return \";\n        String s = Integer.toString(n);\n        if(s.equals(\"0\"))\n            return \"000\";\n        return s;\n    }\n}\n"
    },
    {
        "slug": "sum-of-total-strength-of-wizards",
        "description": "As the ruler of a kingdom, you have an army of wizards at your command.\nYou are given a 0-indexed integer array strength, where strength[i] denotes the strength of the ith wizard. For a contiguous group of wizards (i.e. the wizards' strengths form a subarray of strength), the total strength is defined as the product of the following two values:\n\nThe strength of the weakest wizard in the group.\nThe total of all the individual strengths of the wizards in the group.\n\nReturn the sum of the total strengths of all contiguous groups of wizards. Since the answer may be very large, return it modulo 109 + 7.\nA subarray is a contiguous non-empty sequence of elements within an array.",
        "examples": [
            "Input: strength = [1,3,1,2]\nOutput: 44\nExplanation: The following are all the contiguous groups of wizards:\n- [1] from [1,3,1,2] has a total strength of min([1]) * sum([1]) = 1 * 1 = 1\n- [3] from [1,3,1,2] has a total strength of min([3]) * sum([3]) = 3 * 3 = 9\n- [1] from [1,3,1,2] has a total strength of min([1]) * sum([1]) = 1 * 1 = 1\n- [2] from [1,3,1,2] has a total strength of min([2]) * sum([2]) = 2 * 2 = 4\n- [1,3] from [1,3,1,2] has a total strength of min([1,3]) * sum([1,3]) = 1 * 4 = 4\n- [3,1] from [1,3,1,2] has a total strength of min([3,1]) * sum([3,1]) = 1 * 4 = 4\n- [1,2] from [1,3,1,2] has a total strength of min([1,2]) * sum([1,2]) = 1 * 3 = 3\n- [1,3,1] from [1,3,1,2] has a total strength of min([1,3,1]) * sum([1,3,1]) = 1 * 5 = 5\n- [3,1,2] from [1,3,1,2] has a total strength of min([3,1,2]) * sum([3,1,2]) = 1 * 6 = 6\n- [1,3,1,2] from [1,3,1,2] has a total strength of min([1,3,1,2]) * sum([1,3,1,2]) = 1 * 7 = 7\nThe sum of all the total strengths is 1 + 9 + 1 + 4 + 4 + 4 + 3 + 5 + 6 + 7 = 44.",
            "Input: strength = [5,4,6]\nOutput: 213\nExplanation: The following are all the contiguous groups of wizards: \n- [5] from [5,4,6] has a total strength of min([5]) * sum([5]) = 5 * 5 = 25\n- [4] from [5,4,6] has a total strength of min([4]) * sum([4]) = 4 * 4 = 16\n- [6] from [5,4,6] has a total strength of min([6]) * sum([6]) = 6 * 6 = 36\n- [5,4] from [5,4,6] has a total strength of min([5,4]) * sum([5,4]) = 4 * 9 = 36\n- [4,6] from [5,4,6] has a total strength of min([4,6]) * sum([4,6]) = 4 * 10 = 40\n- [5,4,6] from [5,4,6] has a total strength of min([5,4,6]) * sum([5,4,6]) = 4 * 15 = 60\nThe sum of all the total strengths is 25 + 16 + 36 + 36 + 40 + 60 = 213."
        ],
        "constraints": "1 <= strength.length <= 105\n1 <= strength[i] <= 109",
        "oracle_code": "class Solution {\n    public int totalStrength(int[] strength) {\n        int mod = 1000000007;\n        \n        int len = strength.length;\n        \n        long[] prefix = prefixSum(strength, len, mod);\n        \n        Deque<Integer> stack = new ArrayDeque<>();\n        stack.push(-1);\n\n        long ans = 0;\n        for(int i = 0; i < len; i++) {\n            while(stack.peek() != -1 && strength[i] <= strength[stack.peek()]) {\n                int mid = stack.pop();\n                int left = stack.peek() + 1;\n                int right = i - 1;\n                \n                int n = (mid - left);\n                int t = (right - mid);\n                \n                long val = (1l * (1 + n) * (prefix[right + 2] - prefix[mid + 1]) + mod) % mod;\n                val -= (1l * (1 + t) * (prefix[mid + 1] - prefix[left]) + mod) % mod;\n                val *= strength[mid];\n                \n                ans += val;\n                ans %= mod;\n            }\n            \n            stack.push(i);\n        }\n        \n        int right = len - 1;\n        while(stack.peek() != -1) {\n            int mid = stack.pop();\n            int left = stack.peek() + 1;\n            \n            int n = (mid - left);\n            int t = (right - mid);\n\n            long val = (1l * (1 + n) * (prefix[right + 2] - prefix[mid + 1]) + mod) % mod;\n            val -= (1l * (1 + t) * (prefix[mid + 1] - prefix[left]) + mod) % mod;\n            val *= strength[mid];\n\n            ans += val;\n            ans %= mod;\n        }\n        \n        return (int)((ans + mod) % mod);\n    }\n    \n    private long[] prefixSum(int[] strength, int len, int mod) {\n        long[] prefix = new long[len + 1];\n        \n        for(int i = 0; i < len; i++) {\n            prefix[i + 1] = prefix[i] + strength[i];\n        }\n        \n        long[] doublePrefix = new long[len + 2];\n        for(int i = 0; i <= len; i++) {\n            doublePrefix[i + 1] = (doublePrefix[i] + prefix[i]) % mod;\n        }\n\n        return doublePrefix;\n    }\n}",
        "content": "I could not figure out `o(n)` approach on my own. \\nI needed to read at least 3 solution by really brilliant people (top voted) to understand the approach.\\nThen I had to do the math on pen-paper 3 times (made mistake 2 time) to actually understand the approach.\\nThen when I actually started coding, I made some some silly mistakes around Stack boundry and \\nthe cherry on top was that you need to do `+ mod) % mod` at almost every place you are doing any calculation.\\n\\nOverall, very good learning experience but I really pity the ones who actually face this in interview.\\n\\nRun time complexity: `4 * O(n)` =  `O(n)` \\nSpace compexity: `O(n)`\\n\\nMy java solution -\\n```\\nclass Solution {\\n    public int totalStrength(int[] strength) {\\n        int mod = 1000000007;\\n        \\n        int len = strength.length;\\n        \\n        long[] prefix = prefixSum(strength, len, mod);\\n        \\n        Deque<Integer> stack = new ArrayDeque<>();\\n        stack.push(-1);\\n\\n        long ans = 0;\\n        for(int i = 0; i < len; i++) {\\n            while(stack.peek() != -1 && strength[i] <= strength[stack.peek()]) {\\n                int mid = stack.pop();\\n                int left = stack.peek() + 1;\\n                int right = i - 1;\\n                \\n                int n = (mid - left);\\n                int t = (right - mid);\\n                \\n                long val = (1l * (1 + n) * (prefix[right + 2] - prefix[mid + 1]) + mod) % mod;\\n                val -= (1l * (1 + t) * (prefix[mid + 1] - prefix[left]) + mod) % mod;\\n                val *= strength[mid];\\n                \\n                ans += val;\\n                ans %= mod;\\n            }\\n            \\n            stack.push(i);\\n        }\\n        \\n        int right = len - 1;\\n        while(stack.peek() != -1) {\\n            int mid = stack.pop();\\n            int left = stack.peek() + 1;\\n            \\n            int n = (mid - left);\\n            int t = (right - mid);\\n\\n            long val = (1l * (1 + n) * (prefix[right + 2] - prefix[mid + 1]) + mod) % mod;\\n            val -= (1l * (1 + t) * (prefix[mid + 1] - prefix[left]) + mod) % mod;\\n            val *= strength[mid];\\n\\n            ans += val;\\n            ans %= mod;\\n        }\\n        \\n        return (int)((ans + mod) % mod);\\n    }\\n    \\n    private long[] prefixSum(int[] strength, int len, int mod) {\\n        long[] prefix = new long[len + 1];\\n        \\n        for(int i = 0; i < len; i++) {\\n            prefix[i + 1] = prefix[i] + strength[i];\\n        }\\n        \\n        long[] doublePrefix = new long[len + 2];\\n        for(int i = 0; i <= len; i++) {\\n            doublePrefix[i + 1] = (doublePrefix[i] + prefix[i]) % mod;\\n        }\\n\\n        return doublePrefix;\\n    }\\n}\\n```",
        "level": "hard",
        "type": [
            "variable value error",
            "parentheses mismatch",
            "indexing error",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution {\n    public int totalStrength(int[] strength) {\n        int mod = 1000000007;\n        \n        int len = strength.length;\n        \n        long[] prefix = prefixSum(strength, len, mod;\n        \n        Deque<Integer> stack = new ArrayDeque<>();\n        stack.push(-1);\n\n        long ans = 0;\n        for(int i = 0; i < len; i++) {\n            const int mid;\n            while(stack.peek() != -1 && strength[i] <= strength[stack.peek()]) {\n                mid = stack.pop();\n                int left = stack.peek() + 1;\n                int right = i - 1;\n                \n                int n = (mid - left) + 1;\n                int t = (right - mid) + 1;\n                \n                long val = (1l * (1 + n) * (prefix[right + 2] - prefix[mid + 2]) + mod) % mod;\n                val -= (1l * (1 + t) * (prefix[mid + 1] - prefix[left]) + mod) % mod;\n                val *= strength[mid];\n                \n                ans += val;\n                ans %= mod;\n            }\n            \n            stack.push(i);\n        }\n        \n        int right = len - 1;\n        while(stack.peek() != -1) {\n            int mid = stack.pop();\n            int left = stack.peek() + 1;\n            \n            int n = (mid - left) + 1;\n            int t = (right - mid) + 1;\n\n            long val = (1l * (1 + n) * (prefix[right + 2] - prefix[mid + 1]) + mod) % mod;\n            val -= (1l * (1 + t) * (prefix[mid + 1] - prefix[left]) + mod) % mod;\n            val *= strength[mid];\n\n            ans += val;\n            ans %= mod;\n        }\n        \n        return (int)((ans + mod) % mod);\n    }\n    \n    private long[] prefixSum(int[] strength, int len, int mod) {\n        long[] prefix = new long[len + 1];\n        \n        for(int i = 0; i < len; i++) {\n            prefix[i + 1] = prefix[i] + strength[i];\n        }\n        \n        long[] doublePrefix = new long[len + 2];\n        for(int i = 0; i <= len; i++) {\n            doublePrefix[i + 1] = (doublePrefix[i] + prefix[i]) % mod;\n        }\n\n        return doublePrefix;\n    }\n}\n"
    },
    {
        "slug": "can-make-arithmetic-progression-from-sequence",
        "description": "A sequence of numbers is called an arithmetic progression if the difference between any two consecutive elements is the same.\nGiven an array of numbers arr, return true if the array can be rearranged to form an arithmetic progression. Otherwise, return false.",
        "examples": [
            "Input: arr = [3,5,1]\nOutput: true\nExplanation: We can reorder the elements as [1,3,5] or [5,3,1] with differences 2 and -2 respectively, between each consecutive elements.",
            "Input: arr = [1,2,4]\nOutput: false\nExplanation: There is no way to reorder the elements to obtain an arithmetic progression."
        ],
        "constraints": "2 <= arr.length <= 1000\n-106 <= arr[i] <= 106",
        "oracle_code": "class Solution {\n    public boolean canMakeArithmeticProgression(int[] arr) {\n        Arrays.sort(arr);\n        int diff=arr[1]-arr[0];\n        boolean temp=true;\n        for(int i=1;i<arr.length-1;i++){\n            if(arr[i+1]-arr[i]==diff){\n                continue;\n            }else{\n                temp=false;\n            }\n        }\n        if(temp==true){\n            return true;\n        }else{\n            return false;\n        }\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe given code is an implementation of a method named canMakeArithmeticProgression, which determines whether the given array arr can be rearranged to form an arithmetic progression.\\n\\nHere\\'s how the code works:\\n\\nThe arr array is sorted using the Arrays.sort() method. Sorting the array is important because in an arithmetic progression, the elements are arranged in a specific order.\\n\\nThe variable diff is initialized as the difference between the second element (arr[1]) and the first element (arr[0]). This will be the common difference for the arithmetic progression.\\n\\nThe variable temp is set to true. It will be used to keep track of whether all the adjacent element differences match the common difference.\\n\\nA loop iterates from the second element (i=1) to the second-to-last element (i<arr.length-1). This loop compares the difference between the current element (arr[i+1]) and the previous element (arr[i]) with the common difference (diff).\\n\\nIf the difference between the current and previous elements matches the common difference, the loop continues to the next iteration using the continue statement.\\n\\nIf the difference does not match the common difference, temp is set to false, indicating that the array cannot form an arithmetic progression.\\n\\nFinally, after the loop, the value of temp is checked. If it is still true, the method returns true indicating that the array can form an arithmetic progression. Otherwise, it returns false.\\n\\nIn summary, the code checks if the given array can be sorted into an arithmetic progression by comparing the differences between adjacent elements. If all the differences match the common difference, it returns true; otherwise, it returns false.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach used in the given code can be summarized as follows:\\n\\nSort the array in ascending order using the Arrays.sort() method. Sorting the array helps in identifying the order of the elements in an arithmetic progression.\\n\\nCalculate the common difference (diff) between the second element (arr[1]) and the first element (arr[0]).\\n\\nIterate through the array starting from the second element (i=1) up to the second-to-last element (i<arr.length-1).\\n\\nFor each iteration, check if the difference between the current element (arr[i+1]) and the previous element (arr[i]) is equal to the common difference (diff).\\n\\nIf the difference matches, continue to the next iteration.\\n\\nIf the difference does not match, set the temp variable to false, indicating that the array cannot form an arithmetic progression.\\n\\nAfter the loop, check the value of the temp variable. If it is still true, return true to indicate that the array can form an arithmetic progression. Otherwise, return false.\\n\\nIn summary, the code checks if the given array can be rearranged to form an arithmetic progression by comparing the differences between adjacent elements. If all the differences match the common difference, the code returns true; otherwise, it returns false.\\n\\n# Complexity\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean canMakeArithmeticProgression(int[] arr) {\\n        Arrays.sort(arr);\\n        int diff=arr[1]-arr[0];\\n        boolean temp=true;\\n        for(int i=1;i<arr.length-1;i++){\\n            if(arr[i+1]-arr[i]==diff){\\n                continue;\\n            }else{\\n                temp=false;\\n            }\\n        }\\n        if(temp==true){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }\\n}\\n```",
        "level": "easy",
        "type": [
            "variable value error",
            "wrong comment mark",
            "indexing error",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution {\n    public boolean canMakeArithmeticProgression(int[] arr) {\n        Arrays.sort(arr);\n        int diff=arr[2]-arr[0]; /\n        boolean temp=true;\n        for(int i=1;i<=arr.length;i++){\n            if(arr[i]-arr[i-1]==diff){\n                temp=false;\n                continue;\n            }else{\n                temp=true;\n            }\n        }\n        if(temp==true){\n            return true;\n        }else{\n            Example obj;\n            int num = obj.getNum();\n            return false;\n        }\n    }\n}\n"
    },
    {
        "slug": "find-first-palindromic-string-in-the-array",
        "description": "Given an array of strings words, return the first palindromic string in the array. If there is no such string, return an empty string \"\".\nA string is palindromic if it reads the same forward and backward.",
        "examples": [
            "Input: words = [\"abc\",\"car\",\"ada\",\"racecar\",\"cool\"]\nOutput: \"ada\"\nExplanation: The first string that is palindromic is \"ada\".\nNote that \"racecar\" is also palindromic, but it is not the first.",
            "Input: words = [\"notapalindrome\",\"racecar\"]\nOutput: \"racecar\"\nExplanation: The first and only string that is palindromic is \"racecar\".",
            "Input: words = [\"def\",\"ghi\"]\nOutput: \"\"\nExplanation: There are no palindromic strings, so the empty string is returned."
        ],
        "constraints": "1 <= words.length <= 100\n1 <= words[i].length <= 100\nwords[i] consists only of lowercase English letters.",
        "oracle_code": "class Solution {\n    public String firstPalindrome(String[] words) {\n        for (String s : words) {\n            if (isPalindrome(s)) return s;\n        }\n\n        return \"\";\n    }\n\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n\n        while (i < j) {\n            if (s.charAt(i++) != s.charAt(j--)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n}\n\n// TC: O(n * k), SC: O(1)\n// n -> length of words\n// k -> length of longest string in words",
        "content": "### **Please Upvote** :D\\n##### 1. By checking if its a palindrome using two pointers:\\n```\\nclass Solution {\\n    public String firstPalindrome(String[] words) {\\n        for (String s : words) {\\n            if (isPalindrome(s)) return s;\\n        }\\n\\n        return \"\";\\n    }\\n\\n    public boolean isPalindrome(String s) {\\n        int i = 0, j = s.length() - 1;\\n\\n        while (i < j) {\\n            if (s.charAt(i++) != s.charAt(j--)) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n\\n// TC: O(n * k), SC: O(1)\\n// n -> length of words\\n// k -> length of longest string in words\\n```\\n##### 2. Using strinbuilder to reverse the strings and compare:\\n```\\nclass Solution {\\n    public String firstPalindrome(String[] words) {\\n        for (String s : words){\\n            StringBuilder sb = new StringBuilder();\\n            sb.append(s).reverse();\\n\\n            if (s.equals(sb.toString())){\\n                return s;\\n            }\\n        }\\n\\n        return \"\";\\n    }\\n}\\n\\n// TC: O(n * k), SC: O(1)\\n// n -> length of words\\n// k -> length of longest string in words\\n```",
        "level": "easy",
        "type": [
            "parentheses mismatch",
            "indexing error",
            "undefined keywords from other languages",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution {\n    public String firstPalindrome(String[] words) {\n        for (String s : words) {\n            if (isPalindrome(s) return \"s;\n        }\n\n        return \"\";\n    }\n\n    public bool isPalindrome(String s) {\n        int i = 0, j = s.length();\n\n        while (i < j) {\n            if (s.charAt(i++) != s.charAt(j--)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n}\n\n"
    },
    {
        "slug": "minimum-score-triangulation-of-polygon",
        "description": "You have a convex n-sided polygon where each vertex has an integer value. You are given an integer array values where values[i] is the value of the ith vertex (i.e., clockwise order).\nYou will triangulate the polygon into n - 2 triangles. For each triangle, the value of that triangle is the product of the values of its vertices, and the total score of the triangulation is the sum of these values over all n - 2 triangles in the triangulation.\nReturn the smallest possible total score that you can achieve with some triangulation of the polygon.",
        "examples": [
            "Input: values = [1,2,3]\nOutput: 6\nExplanation: The polygon is already triangulated, and the score of the only triangle is 6.",
            "Input: values = [3,7,4,5]\nOutput: 144\nExplanation: There are two triangulations, with possible scores: 3*7*5 + 4*5*7 = 245, or 3*4*5 + 3*4*7 = 144.\nThe minimum score is 144.",
            "Input: values = [1,3,1,4,1,5]\nOutput: 13\nExplanation: The minimum score triangulation has score 1*1*3 + 1*1*4 + 1*1*5 + 1*1*1 = 13."
        ],
        "constraints": "n == values.length\n3 <= n <= 50\n1 <= values[i] <= 100",
        "oracle_code": "class Solution {\n    int[][] dp;\n    public int minScoreTriangulation(int[] values) {\n        int l=values.length;\n        dp = new int[l][l];\n        for(int[] i : dp) Arrays.fill(i,-1);\n        return solve(values,1,l-1); \n    }\n\n    public int solve(int[] values, int i,int j)\n    {\n        if(i>=j) return 0;\n        if(dp[i][j]!=-1) return dp[i][j];\n        int min=Integer.MAX_VALUE;\n        for(int k=i;k<j;k++)\n        {\n            int temp=solve(values,i,k)+solve(values,k+1,j)+\n                        values[i-1]*values[k]*values[j];\n            min=Math.min(min,temp);\n        }\n\n        return dp[i][j]=min;\n    }\n}",
        "content": "\\n# Complexity\\n- Time complexity: n^2\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: n^2\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int[][] dp;\\n    public int minScoreTriangulation(int[] values) {\\n        int l=values.length;\\n        dp = new int[l][l];\\n        for(int[] i : dp) Arrays.fill(i,-1);\\n        return solve(values,1,l-1); \\n    }\\n\\n    public int solve(int[] values, int i,int j)\\n    {\\n        if(i>=j) return 0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int min=Integer.MAX_VALUE;\\n        for(int k=i;k<j;k++)\\n        {\\n            int temp=solve(values,i,k)+solve(values,k+1,j)+\\n                        values[i-1]*values[k]*values[j];\\n            min=Math.min(min,temp);\\n        }\\n\\n        return dp[i][j]=min;\\n    }\\n}\\n```",
        "level": "medium",
        "type": [
            "variable value error",
            "colon missing",
            "wrong comment mark",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution {\n    int[][] dp;\n    public int minScoreTriangulation(int[] values) {\n        int l=values.length;\n        dp = new int[l][l];\n        for int[] i : dp) Arrays.fill(i,-1);\n       0 \n    }\n\n    public int solve(int[] values, int i,int j)\n    {\n        if(i>=j) return 0;\n        if(dp[i][j]!=-1) return dp[i][j];\n        int min=Integer.MAX_VALUE;\n        for(int k=i;k<j;k++)\n        {\n            int temp=solve(values,i,k)+solve(values,k+1,j)+\n                        values[i-1]*values[k]*values[undefined];\n            min=Math.min(min,temp);\n        }\n\n        return dp[i][j]=min;\n    }\n}\n"
    },
    {
        "slug": "relative-ranks",
        "description": "You are given an integer array score of size n, where score[i] is the score of the ith athlete in a competition. All the scores are guaranteed to be unique.\nThe athletes are placed based on their scores, where the 1st place athlete has the highest score, the 2nd place athlete has the 2nd highest score, and so on. The placement of each athlete determines their rank:\n\nThe 1st place athlete's rank is \"Gold Medal\".\nThe 2nd place athlete's rank is \"Silver Medal\".\nThe 3rd place athlete's rank is \"Bronze Medal\".\nFor the 4th place to the nth place athlete, their rank is their placement number (i.e., the xth place athlete's rank is \"x\").\n\nReturn an array answer of size n where answer[i] is the rank of the ith athlete.",
        "examples": [
            "Input: score = [5,4,3,2,1]\nOutput: [\"Gold Medal\",\"Silver Medal\",\"Bronze Medal\",\"4\",\"5\"]\nExplanation: The placements are [1st, 2nd, 3rd, 4th, 5th].",
            "Input: score = [10,3,8,9,4]\nOutput: [\"Gold Medal\",\"5\",\"Bronze Medal\",\"Silver Medal\",\"4\"]\nExplanation: The placements are [1st, 5th, 3rd, 2nd, 4th]."
        ],
        "constraints": "n == score.length\n1 <= n <= 104\n0 <= score[i] <= 106\nAll the values in score are unique.",
        "oracle_code": "class Solution {\n    public String[] findRelativeRanks(int[] score) {\n         int n=score.length;\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[b]-score[a]);\n        for(int i=0;i<n;i++) pq.add(i);\n      String[] ans = new String[n];\n                int i=1;\n        while(!pq.isEmpty()){\n            int idx=pq.poll();\n         if(i==1)   { ans[idx]=\"Gold Medal\"; i++;}\n         else if(i==2)   { ans[idx]=\"Silver Medal\"; i++;}\n         else if(i==3)   { ans[idx]=\"Bronze Medal\"; i++;}\n         else ans[idx]=Integer.toString(i++);\n        }\n        return ans;  \n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String[] findRelativeRanks(int[] score) {\\n         int n=score.length;\\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[b]-score[a]);\\n        for(int i=0;i<n;i++) pq.add(i);\\n      String[] ans = new String[n];\\n                int i=1;\\n        while(!pq.isEmpty()){\\n            int idx=pq.poll();\\n         if(i==1)   { ans[idx]=\"Gold Medal\"; i++;}\\n         else if(i==2)   { ans[idx]=\"Silver Medal\"; i++;}\\n         else if(i==3)   { ans[idx]=\"Bronze Medal\"; i++;}\\n         else ans[idx]=Integer.toString(i++);\\n        }\\n        return ans;  \\n    }\\n}\\n```",
        "level": "easy",
        "type": [
            "operation error",
            "undefined keywords from other languages",
            "unclosed string",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\n    public String[] findRelativeRanks(int[] score) {\n         int n = score.length;\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[a]-score[b]);\n        for(int i=0;i<n;i++) pq.add(i);\n        String[] ans = new String[n];\n                int i=1;\n        while(!pq.isEmpty()){\n            int idx=pq.poll();\n         if(i==1)   { ans[idx]=\"Gold Medal; i++;}\n         elif(i==2)   { ans[idx]=\"Silver Medal; i++;}\n         else if(i==3)   { ans[idx]=\"Bronze Medal; i++;}\n         else ans[idx]=Integer.toString(i++);\n        }\n        return reorderArray(ans);  \n    }\n\n    private String[] reorderArray(String[] ranks){\n        \n    }\n}\n"
    },
    {
        "slug": "maximal-rectangle",
        "description": "Given a rows x cols\u00a0binary matrix filled with 0's and 1's, find the largest rectangle containing only 1's and return its area.",
        "examples": [
            "Input: matrix = [[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"0\"]]\nOutput: 6\nExplanation: The maximal rectangle is shown in the above picture.",
            "Input: matrix = [[\"0\"]]\nOutput: 0",
            "Input: matrix = [[\"1\"]]\nOutput: 1"
        ],
        "constraints": "rows == matrix.length\ncols == matrix[i].length\n1 <= row, cols <= 200\nmatrix[i][j] is '0' or '1'.",
        "oracle_code": "class Pair<T, U> {\n    public final T first;\n    public final U second;\n\n    public Pair(T first, U second) {\n        this.first = first;\n        this.second = second;\n    }\n}\n\nclass Solution {\n    public int maximalRectangle(char[][] matrix) {\n        int n = matrix.length, m = matrix[0].length;\n        int[] nums = new int[m];\n        for (int j = 0; j < m; j++) {\n            nums[j] = matrix[0][j] - '0';\n        }\n        int max = maximumAreaHistogram(nums);\n        for (int i = 1; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (matrix[i][j] == '0') {\n                    nums[j] = 0;\n                } else {\n                    nums[j] += (matrix[i][j] - '0');\n                }\n            }\n            max = Math.max(max, maximumAreaHistogram(nums));\n        }\n        return max;\n    }\n    public int maximumAreaHistogram(int[] heights) {\n        Stack<Pair<Integer, Integer>> stack1 = new Stack<>();\n        int[] left = new int[heights.length];\n        int pseudoIndex = -1;\n        //NSL\n        for (int i = 0; i < heights.length; i++) {\n            if (stack1.size() == 0) {\n                left[i] = pseudoIndex;\n            } else if (stack1.size() > 0 && stack1.peek().first < heights[i]) {\n                left[i] = stack1.peek().second;\n            } else if (stack1.size() > 0 && stack1.peek().first >= heights[i]) {\n                while (stack1.size() > 0 && stack1.peek().first >= heights[i]) {\n                    stack1.pop();\n                }\n                if (stack1.size() == 0) {\n                    left[i] = pseudoIndex;\n                } else {\n                    left[i] = stack1.peek().second;\n                }\n            }\n            stack1.push(new Pair<>(heights[i], i));\n        }\n        //NSR\n        Stack<Pair<Integer, Integer>> stack2 = new Stack<>();\n        int[] right = new int[heights.length];\n        pseudoIndex = heights.length;\n        for (int i = heights.length - 1; i >= 0; i--) {\n            if (stack2.size() == 0) {\n                right[i] = pseudoIndex;\n            } else if (stack2.size() > 0 && stack2.peek().first < heights[i]) {\n                right[i] = stack2.peek().second;\n            } else if (stack2.size() > 0 && stack2.peek().first >= heights[i]) {\n                while (stack2.size() > 0 && stack2.peek().first >= heights[i]) {\n                    stack2.pop();\n                }\n                if (stack2.size() == 0) {\n                    right[i] = pseudoIndex;\n                } else {\n                    right[i] = stack2.peek().second;\n                }\n            }\n            stack2.push(new Pair<>(heights[i], i));\n        }\n\n        int[] width = new int[heights.length];\n        for (int i = 0; i < heights.length; i++) {\n            width[i] = right[i] - left[i] - 1;\n        }\n\n        int[] area = new int[heights.length];\n        int maxArea = 0;\n        for (int i = 0; i < heights.length; i++) {\n            area[i] = heights[i] * width[i];\n            if (area[i] > maxArea) maxArea = area[i];\n        }\n        return maxArea;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Pair<T, U> {\\n    public final T first;\\n    public final U second;\\n\\n    public Pair(T first, U second) {\\n        this.first = first;\\n        this.second = second;\\n    }\\n}\\n\\nclass Solution {\\n    public int maximalRectangle(char[][] matrix) {\\n        int n = matrix.length, m = matrix[0].length;\\n        int[] nums = new int[m];\\n        for (int j = 0; j < m; j++) {\\n            nums[j] = matrix[0][j] - \\'0\\';\\n        }\\n        int max = maximumAreaHistogram(nums);\\n        for (int i = 1; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (matrix[i][j] == \\'0\\') {\\n                    nums[j] = 0;\\n                } else {\\n                    nums[j] += (matrix[i][j] - \\'0\\');\\n                }\\n            }\\n            max = Math.max(max, maximumAreaHistogram(nums));\\n        }\\n        return max;\\n    }\\n    public int maximumAreaHistogram(int[] heights) {\\n        Stack<Pair<Integer, Integer>> stack1 = new Stack<>();\\n        int[] left = new int[heights.length];\\n        int pseudoIndex = -1;\\n        //NSL\\n        for (int i = 0; i < heights.length; i++) {\\n            if (stack1.size() == 0) {\\n                left[i] = pseudoIndex;\\n            } else if (stack1.size() > 0 && stack1.peek().first < heights[i]) {\\n                left[i] = stack1.peek().second;\\n            } else if (stack1.size() > 0 && stack1.peek().first >= heights[i]) {\\n                while (stack1.size() > 0 && stack1.peek().first >= heights[i]) {\\n                    stack1.pop();\\n                }\\n                if (stack1.size() == 0) {\\n                    left[i] = pseudoIndex;\\n                } else {\\n                    left[i] = stack1.peek().second;\\n                }\\n            }\\n            stack1.push(new Pair<>(heights[i], i));\\n        }\\n        //NSR\\n        Stack<Pair<Integer, Integer>> stack2 = new Stack<>();\\n        int[] right = new int[heights.length];\\n        pseudoIndex = heights.length;\\n        for (int i = heights.length - 1; i >= 0; i--) {\\n            if (stack2.size() == 0) {\\n                right[i] = pseudoIndex;\\n            } else if (stack2.size() > 0 && stack2.peek().first < heights[i]) {\\n                right[i] = stack2.peek().second;\\n            } else if (stack2.size() > 0 && stack2.peek().first >= heights[i]) {\\n                while (stack2.size() > 0 && stack2.peek().first >= heights[i]) {\\n                    stack2.pop();\\n                }\\n                if (stack2.size() == 0) {\\n                    right[i] = pseudoIndex;\\n                } else {\\n                    right[i] = stack2.peek().second;\\n                }\\n            }\\n            stack2.push(new Pair<>(heights[i], i));\\n        }\\n\\n        int[] width = new int[heights.length];\\n        for (int i = 0; i < heights.length; i++) {\\n            width[i] = right[i] - left[i] - 1;\\n        }\\n\\n        int[] area = new int[heights.length];\\n        int maxArea = 0;\\n        for (int i = 0; i < heights.length; i++) {\\n            area[i] = heights[i] * width[i];\\n            if (area[i] > maxArea) maxArea = area[i];\\n        }\\n        return maxArea;\\n    }\\n}\\n```",
        "level": "hard",
        "type": [
            "operation error",
            "== and = confusion",
            "parentheses mismatch",
            "unclosed string"
        ],
        "buggy_code": "\nclass Pair<T, U> {\n    public final T first;\n    public final U second;\n\n    public Pair(T first, U second) {\n        this.first = first;\n        this.second = second;\n    }\n}\n\nclass Solution {\n    public int maximalRectangle(char[][] matrix) {\n        int n = matrix.length, m = matrix[0].length;\n        int[] nums = new int[m];\n        for (int j = 0; j < m; j++) {\n            nums[j] = matrix[0][j] - '1';\n        }\n        int max = maximumAreaHistogram(nums);\n        for (int i = 1; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (matrix[i][j] == '0) {\n                    nums[j] = 0;\n                } else {\n                    nums[j] += (matrix[i][j] - '0';\n                }\n            }\n            max = Math.max(max, maximumAreaHistogram(nums));\n        }\n        return max;\n    }\n    public int maximumAreaHistogram(int[] heights) {\n        Stack<Pair<Integer, Integer>> stack1 = new Stack<>();\n        int[] left = new int[heights.length];\n        int pseudoIndex = -1;\n        //NSL\n        for (int i = 0; i < heights.length; i++) {\n            if (stack1.size() == 0) {\n                left[i] = pseudoIndex;\n            } else if (stack1.size() > 0 && stack1.peek().first < heights[i]) {\n                left[i] = stack1.peek().second;\n            } else if (stack1.size() > 0 && stack1.peek().first >= heights[i]) {\n                while (stack1.size() > 0 && stack1.peek().first == heights[i]) {\n                    stack1.pop();\n                }\n                if (stack1.size() == 0) {\n                    left[i] = pseudoIndex;\n                } else {\n                    left[i] = stack1.peek().second;\n                }\n            }\n            stack1.push(new Pair<>(heights[i], i));\n        }\n        //NSR\n        Stack<Pair<Integer, Integer>> stack2 = new Stack<>();\n        int[] right = new int[heights.length];\n        pseudoIndex = heights.length;\n        for (int i = heights.length - 1; i >= 0; i--) {\n            if (stack2.size() == 0) {\n                right[i] = pseudoIndex;\n            } else if (stack2.size() > 0 && stack2.peek().first < heights[i]) {\n                right[i] = stack2.peek().second;\n            } else if (stack2.size() > 0 && stack2.peek().first >= heights[i]) {\n                while (stack2.size() > 0 && stack2.peek().first == heights[i]) {\n                    stack2.pop();\n                }\n                if (stack2.size() == 0) {\n                    right[i] = pseudoIndex;\n                } else {\n                    right[i] = stack2.peek().second;\n                }\n            }\n            stack2.push(new Pair<>(heights[i], i));\n        }\n\n        int[] width = new int[heights.length];\n        for (int i = 0; i < heights.length; i++) {\n            width[i] = right[i] - left[i] - 1;\n        }\n\n        int[] area = new int[heights.length];\n        int maxArea = 0;\n        for (int i = 0; i < heights.length; i++) {\n            area[i] = heights[i] * width[i];\n            if (area[i] > maxArea) maxArea = area[i];\n        }\n        return maxArea;\n    }\n}\n"
    },
    {
        "slug": "rotating-the-box",
        "description": "You are given an m x n matrix of characters box representing a side-view of a box. Each cell of the box is one of the following:\n\nA stone '#'\nA stationary obstacle '*'\nEmpty '.'\n\nThe box is rotated 90 degrees clockwise, causing some of the stones to fall due to gravity. Each stone falls down until it lands on an obstacle, another stone, or the bottom of the box. Gravity does not affect the obstacles' positions, and the inertia from the box's rotation does not affect the stones' horizontal positions.\nIt is guaranteed that each stone in box rests on an obstacle, another stone, or the bottom of the box.\nReturn an n x m matrix representing the box after the rotation described above.",
        "examples": [
            "Input: box = [[\"#\",\".\",\"#\"]]\r\nOutput: [[\".\"],\r\n\u00a0        [\"#\"],\r\n\u00a0        [\"#\"]]",
            "Input: box = [[\"#\",\".\",\"*\",\".\"],\r\n\u00a0             [\"#\",\"#\",\"*\",\".\"]]\r\nOutput: [[\"#\",\".\"],\r\n\u00a0        [\"#\",\"#\"],\r\n\u00a0        [\"*\",\"*\"],\r\n\u00a0        [\".\",\".\"]]",
            "Input: box = [[\"#\",\"#\",\"*\",\".\",\"*\",\".\"],\r\n\u00a0             [\"#\",\"#\",\"#\",\"*\",\".\",\".\"],\r\n\u00a0             [\"#\",\"#\",\"#\",\".\",\"#\",\".\"]]\r\nOutput: [[\".\",\"#\",\"#\"],\r\n\u00a0        [\".\",\"#\",\"#\"],\r\n\u00a0        [\"#\",\"#\",\"*\"],\r\n\u00a0        [\"#\",\"*\",\".\"],\r\n\u00a0        [\"#\",\".\",\"*\"],\r\n\u00a0        [\"#\",\".\",\".\"]]"
        ],
        "constraints": "m == box.length\nn == box[i].length\n1 <= m, n <= 500\nbox[i][j] is either '#', '*', or '.'.",
        "oracle_code": "// O(n^2) time | O(n^2) space\nclass Solution {\n    public char[][] rotateTheBox(char[][] box) {\n        int m = box.length;\n        int n = box[0].length;\n        char[][] matrix = new char[n][m];   \n        \n        turnBox(box, matrix, m, n); // turn the box clockwise 90 degree\n        \n        turnGravity(matrix, n, m); // cause that falling effect, since matrix turned so n,m\n        \n        return matrix;\n    }\n    \n    public void turnGravity(char[][] matrix, int m, int n){\n        for(int c = 0; c < n; c++){\n            int last  = m-1;\n            for(int r = m-1; r >= 0; r--){\n                char val =  matrix[r][c];\n                if(val == '.') continue;\n                if(val == '*') last = r-1;\n                if(val == '#') {\n                    matrix[r][c] = '.';\n                    matrix[last][c] = '#';\n                    last--;\n                }\n            }\n        }\n    }\n    \n    public void turnBox(char[][] box, char[][] matrix, int m, int n){\n\t// numbers represents sequence it would be copied\n\t//[4][1]\n\t//[5][2]\n\t//[6][3]\n        for(int i = 0, c = m-1; i < m; i++,c--){ // c: 4,3,2,1..\n            for(int j = 0, r = 0; j < n; j++, r++){ // r:0,1,2,3..\n               matrix[r][c] = box[i][j];\n            }\n        }\n    }\n}",
        "content": "**So idea here is**\\n1. First turn 90 degree\\n2. Make things fall\\n\\n```\\n// O(n^2) time | O(n^2) space\\nclass Solution {\\n    public char[][] rotateTheBox(char[][] box) {\\n        int m = box.length;\\n        int n = box[0].length;\\n        char[][] matrix = new char[n][m];   \\n        \\n        turnBox(box, matrix, m, n); // turn the box clockwise 90 degree\\n        \\n        turnGravity(matrix, n, m); // cause that falling effect, since matrix turned so n,m\\n        \\n        return matrix;\\n    }\\n    \\n    public void turnGravity(char[][] matrix, int m, int n){\\n        for(int c = 0; c < n; c++){\\n            int last  = m-1;\\n            for(int r = m-1; r >= 0; r--){\\n                char val =  matrix[r][c];\\n                if(val == \\'.\\') continue;\\n                if(val == \\'*\\') last = r-1;\\n                if(val == \\'#\\') {\\n                    matrix[r][c] = \\'.\\';\\n                    matrix[last][c] = \\'#\\';\\n                    last--;\\n                }\\n            }\\n        }\\n    }\\n    \\n    public void turnBox(char[][] box, char[][] matrix, int m, int n){\\n\\t// numbers represents sequence it would be copied\\n\\t//[4][1]\\n\\t//[5][2]\\n\\t//[6][3]\\n        for(int i = 0, c = m-1; i < m; i++,c--){ // c: 4,3,2,1..\\n            for(int j = 0, r = 0; j < n; j++, r++){ // r:0,1,2,3..\\n               matrix[r][c] = box[i][j];\\n            }\\n        }\\n    }\\n}\\n```",
        "level": "medium",
        "type": [
            "== and = confusion",
            "colon missing",
            "indexing error",
            "unclosed string"
        ],
        "buggy_code": "\n// O(n^2) time | O(n^2) space\nclass Solution {\n    public char[][] rotateTheBox(char[][] box) {\n        int m = box.length;\n        int n = box[0].length + 1; \n        char[][] matrix = new char[n][m]   \n        \n        turnBox(box, matrix, m, n); // turn the box clockwise 90 degree\n        \n        turnGravity(matrix, n, m); // cause that falling effect, since matrix turned so n,m\n        \n        return matrix;\n    }\n    \n    public void turnGravity(char[][] matrix, int m, int n){\n        for(int c = 0; c < n; c++){\n            int last  = m-1;\n            for(int r = m-1; r >= 0; r--){\n                char val =  matrix[r][c];\n                if(val == '.') continue;\n                if(val = '*') last = r-1;  \n                if(val == '#') {\n                    matrix[r][c] = '.';\n                    matrix[last][c] = '#;\n                    last--;\n                }\n            }\n        }\n    }\n    \n    public void turnBox(char[][] box, char[][] matrix, int m, int n){\n                    for(int i = 0, c = m-1; i < m; i++,c--){\n            for(int j = 0, r = 0; j < n; j++, r++){\n               matrix[r][c] = box[i][j];\n            }\n        }\n    }\n}\n"
    },
    {
        "slug": "intersection-of-multiple-arrays",
        "description": "Given a 2D integer array nums where nums[i] is a non-empty array of distinct positive integers, return the list of integers that are present in each array of nums sorted in ascending order.",
        "examples": [
            "Input: nums = [[3,1,2,4,5],[1,2,3,4],[3,4,5,6]]\nOutput: [3,4]\nExplanation: \nThe only integers present in each of nums[0] = [3,1,2,4,5], nums[1] = [1,2,3,4], and nums[2] = [3,4,5,6] are 3 and 4, so we return [3,4].",
            "Input: nums = [[1,2,3],[4,5,6]]\nOutput: []\nExplanation: \nThere does not exist any integer present both in nums[0] and nums[1], so we return an empty list []."
        ],
        "constraints": "1 <= nums.length <= 1000\n1 <= sum(nums[i].length) <= 1000\n1 <= nums[i][j] <= 1000\nAll the values of nums[i] are unique.",
        "oracle_code": "class Solution {\n    public List<Integer> intersection(int[][] nums) {\n        \n        List<Integer> ans = new ArrayList<>();\n        \n        int[] count  = new int[1001];\n        \n        for(int[] arr : nums){\n            for(int i : arr){\n                count[i]++;\n            }\n        }\n        \n       for(int i=0;i<count.length;i++){\n           if(count[i]==nums.length){\n               ans.add(i);\n           }\n       }\n        \n        return ans;\n    }\n}",
        "content": "```\\n\\nclass Solution {\\n    public List<Integer> intersection(int[][] nums) {\\n        \\n        List<Integer> ans = new ArrayList<>();\\n        \\n        int[] count  = new int[1001];\\n        \\n        for(int[] arr : nums){\\n            for(int i : arr){\\n                count[i]++;\\n            }\\n        }\\n        \\n       for(int i=0;i<count.length;i++){\\n           if(count[i]==nums.length){\\n               ans.add(i);\\n           }\\n       }\\n        \\n        return ans;\\n    }\\n}\\n\\n```",
        "level": "easy",
        "type": [
            "== and = confusion",
            "colon missing",
            "conditional statement error",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\n    public List<Integer> intersection(int[][] nums) {\n        \n        List<Integer> ans = new ArrayList<>();\n        \n        int[] count  = new int[1001]\n        \n        for(int[] arr : nums){\n            for(int i : arr){\n                count[i]++;\n            }\n        }\n        \n       for(int i=0;i<count.length;i++){\n           if(count[i]=nums.length+1){\n               ans.add(i);\n           }\n       }\n        \n        myRandomUndefinedFunction();\n        \n        return ans;\n    }\n}\n"
    },
    {
        "slug": "probability-of-a-two-boxes-having-the-same-number-of-distinct-balls",
        "description": "Given 2n balls of k distinct colors. You will be given an integer array balls of size k where balls[i] is the number of balls of color i.\nAll the balls will be shuffled uniformly at random, then we will distribute the first n balls to the first box and the remaining n balls to the other box (Please read the explanation of the second example carefully).\nPlease note that the two boxes are considered different. For example, if we have two balls of colors a and b, and two boxes [] and (), then the distribution [a] (b) is considered different than the distribution [b] (a) (Please read the explanation of the first example carefully).\nReturn the probability that the two boxes have the same number of distinct balls. Answers within 10-5 of the actual value will be accepted as correct.",
        "examples": [
            "Input: balls = [1,1]\nOutput: 1.00000\nExplanation: Only 2 ways to divide the balls equally:\n- A ball of color 1 to box 1 and a ball of color 2 to box 2\n- A ball of color 2 to box 1 and a ball of color 1 to box 2\nIn both ways, the number of distinct colors in each box is equal. The probability is 2/2 = 1",
            "Input: balls = [2,1,1]\nOutput: 0.66667\nExplanation: We have the set of balls [1, 1, 2, 3]\nThis set of balls will be shuffled randomly and we may have one of the 12 distinct shuffles with equal probability (i.e. 1/12):\n[1,1 / 2,3], [1,1 / 3,2], [1,2 / 1,3], [1,2 / 3,1], [1,3 / 1,2], [1,3 / 2,1], [2,1 / 1,3], [2,1 / 3,1], [2,3 / 1,1], [3,1 / 1,2], [3,1 / 2,1], [3,2 / 1,1]\nAfter that, we add the first two balls to the first box and the second two balls to the second box.\nWe can see that 8 of these 12 possible random distributions have the same number of distinct colors of balls in each box.\nProbability is 8/12 = 0.66667",
            "Input: balls = [1,2,1,2]\nOutput: 0.60000\nExplanation: The set of balls is [1, 2, 2, 3, 4, 4]. It is hard to display all the 180 possible random shuffles of this set but it is easy to check that 108 of them will have the same number of distinct colors in each box.\nProbability = 108 / 180 = 0.6"
        ],
        "constraints": "1 <= balls.length <= 8\n1 <= balls[i] <= 6\nsum(balls) is even.",
        "oracle_code": "class Solution {\n    double possible = 0.0;\n    double valid = 0.0;\n    \n    public double getProbability(int[] balls) {\n        int[] first = new int[balls.length];\n        int[] second = new int[balls.length];\n        dfs(balls, first, second, 0, 0, 0);\n        return valid / possible;\n    }\n    \n    private void dfs(int[] balls, int[] first, int[] second, int num1, int num2, int idx) {\n        // finish all colors, check if this's a possible/valid distribution\n        if (idx == balls.length) {\n            // find one possible distribution\n            if (num1 == num2) {\n                // compute fake permutation\n                double distrib = permFake(first) * permFake(second);\n                possible += distrib;\n                \n                // find one valid distribution\n                if (unique(first) == unique(second)) {\n                    valid += distrib;\n                }\n            }\n            return;\n        }\n        \n        // distribute balls in current color to two bins\n        for (int b = 0; b <= balls[idx]; b++) {\n            first[idx] = b;\n            second[idx] = balls[idx] - b;\n            dfs (balls, first, second, num1 + first[idx], num2 + second[idx], idx + 1);\n        }\n    }\n    \n    // unique colors in \n    private int unique(int[] balls) {\n        int unique = 0;\n        for (int b: balls)\n            unique += b > 0 ? 1 : 0;\n        return unique;\n    }\n    \n    // return 1 / (b1!b2!b3!...bn!) \n    private double permFake(int[] balls) {\n        double ret = 1.0;\n        for (int b: balls)\n            ret /= factorial(b);\n        return ret;\n    }\n    \n    private int factorial(int n){\n        int ret = 1;\n        while (n > 0) {\n            ret *= n;\n            n--;\n        }\n        return ret;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    double possible = 0.0;\\n    double valid = 0.0;\\n    \\n    public double getProbability(int[] balls) {\\n        int[] first = new int[balls.length];\\n        int[] second = new int[balls.length];\\n        dfs(balls, first, second, 0, 0, 0);\\n        return valid / possible;\\n    }\\n    \\n    private void dfs(int[] balls, int[] first, int[] second, int num1, int num2, int idx) {\\n        // finish all colors, check if this\\'s a possible/valid distribution\\n        if (idx == balls.length) {\\n            // find one possible distribution\\n            if (num1 == num2) {\\n                // compute fake permutation\\n                double distrib = permFake(first) * permFake(second);\\n                possible += distrib;\\n                \\n                // find one valid distribution\\n                if (unique(first) == unique(second)) {\\n                    valid += distrib;\\n                }\\n            }\\n            return;\\n        }\\n        \\n        // distribute balls in current color to two bins\\n        for (int b = 0; b <= balls[idx]; b++) {\\n            first[idx] = b;\\n            second[idx] = balls[idx] - b;\\n            dfs (balls, first, second, num1 + first[idx], num2 + second[idx], idx + 1);\\n        }\\n    }\\n    \\n    // unique colors in \\n    private int unique(int[] balls) {\\n        int unique = 0;\\n        for (int b: balls)\\n            unique += b > 0 ? 1 : 0;\\n        return unique;\\n    }\\n    \\n    // return 1 / (b1!b2!b3!...bn!) \\n    private double permFake(int[] balls) {\\n        double ret = 1.0;\\n        for (int b: balls)\\n            ret /= factorial(b);\\n        return ret;\\n    }\\n    \\n    private int factorial(int n){\\n        int ret = 1;\\n        while (n > 0) {\\n            ret *= n;\\n            n--;\\n        }\\n        return ret;\\n    }\\n}\\n```",
        "level": "hard",
        "type": [
            "operation error",
            "colon missing",
            "undefined objects",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\n    double possible = 0.0;\n    double valid = 0.0;\n    \n    public double getProbability(int[] balls) {\n        int[] first = new int[balls.length];\n        int[] second = null;\n        dfs(balls, first, second, 0, 0, 0)\n        return valid / possible;\n    }\n    \n    private void dfs(int[] balls, int[] first, int[] second, int num1, int num2, int idx) {\n        if (idx == balls.length) {if (num1 == num2) {\n                double distrib = permFake(first) * permFake(second);\n                possible += distrib;\n                if (unique(first) == unique(second)) {\n                    valid += distrib + 1;    \n                }\n            }\n            return;\n        }\n        for (int b = 0; b <= balls[idx]; b++) {\n            first[idx] = b;\n            second[idx] = balls[idx] - b;\n            dfs (balls, first, second, num1 + first[idx], num2 + second[idx], idx + 1);\n        }\n    }\n    \n    private int(t[] balls) {\n        int=0;   for ( b: balls)\n           +=b>0?1:0;\n      reurnprivate int factorial(int n){\n        int ret = 1;\n        while (n > 0) {\n            ret *= n;\n            n--;\n        }\n        return ret;\n    }\n}\n"
    },
    {
        "slug": "number-of-laser-beams-in-a-bank",
        "description": "Anti-theft security devices are activated inside a bank. You are given a 0-indexed binary string array bank representing the floor plan of the bank, which is an m x n 2D matrix. bank[i] represents the ith row, consisting of '0's and '1's. '0' means the cell is empty, while'1' means the cell has a security device.\nThere is one laser beam between any two security devices if both conditions are met:\n\nThe two devices are located on two different rows: r1 and r2, where r1 < r2.\nFor each row i where r1 < i < r2, there are no security devices in the ith row.\n\nLaser beams are independent, i.e., one beam does not interfere nor join with another.\nReturn the total number of laser beams in the bank.",
        "examples": [
            "Input: bank = [\"011001\",\"000000\",\"010100\",\"001000\"]\nOutput: 8\nExplanation: Between each of the following device pairs, there is one beam. In total, there are 8 beams:\n * bank[0][1] -- bank[2][1]\n * bank[0][1] -- bank[2][3]\n * bank[0][2] -- bank[2][1]\n * bank[0][2] -- bank[2][3]\n * bank[0][5] -- bank[2][1]\n * bank[0][5] -- bank[2][3]\n * bank[2][1] -- bank[3][2]\n * bank[2][3] -- bank[3][2]\nNote that there is no beam between any device on the 0th row with any on the 3rd row.\nThis is because the 2nd row contains security devices, which breaks the second condition.",
            "Input: bank = [\"000\",\"111\",\"000\"]\nOutput: 0\nExplanation: There does not exist two devices located on two different rows."
        ],
        "constraints": "m == bank.length\nn == bank[i].length\n1 <= m, n <= 500\nbank[i][j] is either '0' or '1'.",
        "oracle_code": "class Solution {\n    public int numberOfBeams(String[] bank) {\n        int prevLazer =0;\n        int ans =0;\n        for(String s:bank){\n            int curLazer = 0;\n            for(char c: s.toCharArray()){\n                if(c=='1'){\n                    curLazer++;\n                }\n            }\n            if(curLazer >0){\n                ans += (curLazer * prevLazer);\n                prevLazer = curLazer;\n            }\n        }\n        return ans;\n    }\n}",
        "content": "\\n# java Code\\n```\\nclass Solution {\\n    public int numberOfBeams(String[] bank) {\\n        int prevLazer =0;\\n        int ans =0;\\n        for(String s:bank){\\n            int curLazer = 0;\\n            for(char c: s.toCharArray()){\\n                if(c==\\'1\\'){\\n                    curLazer++;\\n                }\\n            }\\n            if(curLazer >0){\\n                ans += (curLazer * prevLazer);\\n                prevLazer = curLazer;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
        "level": "medium",
        "type": [
            "variable value error",
            "parentheses mismatch",
            "undefined keywords from other languages",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution {\n    public int numberOfBeams(String[] bank) {\n        int prevLazer =0;\n        int ans =0;\n        for(String s:bank){\n            int curLazer = 0;\n            for(char c: s.toCharArray()){\n                if(c=='1){\n                    curLazer++;\n                }\n            if(curLazer >0){\n                ans += (curLazer * prevLazer);\n                prevLazer = curLazer;\n            } else {\n                prevLazer = 0;\n            }\n        pit()    return ans;\n        return \"The total number of beams is: \" + ans;\n    }\n}\n"
    },
    {
        "slug": "find-the-distinct-difference-array",
        "description": "You are given a 0-indexed array nums of length n.\nThe distinct difference array of nums is an array diff of length n such that diff[i] is equal to the number of distinct elements in the suffix nums[i + 1, ..., n - 1] subtracted from the number of distinct elements in the prefix nums[0, ..., i].\nReturn the distinct difference array of nums.\nNote that nums[i, ..., j] denotes the subarray of nums starting at index i and ending at index j inclusive. Particularly, if i > j then nums[i, ..., j] denotes an empty subarray.",
        "examples": [
            "Input: nums = [1,2,3,4,5]\nOutput: [-3,-1,1,3,5]\nExplanation: For index i = 0, there is 1 element in the prefix and 4 distinct elements in the suffix. Thus, diff[0] = 1 - 4 = -3.\nFor index i = 1, there are 2 distinct elements in the prefix and 3 distinct elements in the suffix. Thus, diff[1] = 2 - 3 = -1.\nFor index i = 2, there are 3 distinct elements in the prefix and 2 distinct elements in the suffix. Thus, diff[2] = 3 - 2 = 1.\nFor index i = 3, there are 4 distinct elements in the prefix and 1 distinct element in the suffix. Thus, diff[3] = 4 - 1 = 3.\nFor index i = 4, there are 5 distinct elements in the prefix and no elements in the suffix. Thus, diff[4] = 5 - 0 = 5.",
            "Input: nums = [3,2,3,4,2]\nOutput: [-2,-1,0,2,3]\nExplanation: For index i = 0, there is 1 element in the prefix and 3 distinct elements in the suffix. Thus, diff[0] = 1 - 3 = -2.\nFor index i = 1, there are 2 distinct elements in the prefix and 3 distinct elements in the suffix. Thus, diff[1] = 2 - 3 = -1.\nFor index i = 2, there are 2 distinct elements in the prefix and 2 distinct elements in the suffix. Thus, diff[2] = 2 - 2 = 0.\nFor index i = 3, there are 3 distinct elements in the prefix and 1 distinct element in the suffix. Thus, diff[3] = 3 - 1 = 2.\nFor index i = 4, there are 3 distinct elements in the prefix and no elements in the suffix. Thus, diff[4] = 3 - 0 = 3."
        ],
        "constraints": "1 <= n == nums.length\u00a0<= 50\n1 <= nums[i] <= 50",
        "oracle_code": "class Solution {\n    public int[] distinctDifferenceArray(int[] nums) {\n        int n=nums.length;\n        int ans[]=new int[n];\n        \n        for(int i=0;i<n;i++){\n            Set<Integer>set1=new HashSet<>();\n            Set<Integer>set2=new HashSet<>();\n            \n            for(int j=0;j<=i;j++){\n                set1.add(nums[j]);\n            }\n            for(int j=i+1;j<n;j++){\n                set2.add(nums[j]);\n            }\n            \n            ans[i]= set1.size() - set2.size();\n        }\n        return ans;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        int n=nums.length;\\n        int ans[]=new int[n];\\n        \\n        for(int i=0;i<n;i++){\\n            Set<Integer>set1=new HashSet<>();\\n            Set<Integer>set2=new HashSet<>();\\n            \\n            for(int j=0;j<=i;j++){\\n                set1.add(nums[j]);\\n            }\\n            for(int j=i+1;j<n;j++){\\n                set2.add(nums[j]);\\n            }\\n            \\n            ans[i]= set1.size() - set2.size();\\n        }\\n        return ans;\\n    }\\n}\\n```",
        "level": "easy",
        "type": [
            "conditional statement error",
            "wrong comment mark",
            "indexing error",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\n    public int[] distinctDifferenceArray(int[] nums) {\n        int n=nums.length;\n        int ans[]=new int[n+1];\n        \n        for(int i=0;i<=n;i++){\n            Set<Integer>set1=new HashSet<>();\n            Set<Integer>set2=new HashSet<>();\n            /\n            for(int j=0;j<=i;j++){\n                set1.add(nums[j]);\n            }\n            for(int j=i;j<n;j++){\n                set2.add(nums[j]);\n            }\n            \n            ans[i]= set1.size() - undefinedMethod(set2);\n        }\n        return ans;\n    }\n}\n"
    },
    {
        "slug": "relative-ranks",
        "description": "You are given an integer array score of size n, where score[i] is the score of the ith athlete in a competition. All the scores are guaranteed to be unique.\nThe athletes are placed based on their scores, where the 1st place athlete has the highest score, the 2nd place athlete has the 2nd highest score, and so on. The placement of each athlete determines their rank:\n\nThe 1st place athlete's rank is \"Gold Medal\".\nThe 2nd place athlete's rank is \"Silver Medal\".\nThe 3rd place athlete's rank is \"Bronze Medal\".\nFor the 4th place to the nth place athlete, their rank is their placement number (i.e., the xth place athlete's rank is \"x\").\n\nReturn an array answer of size n where answer[i] is the rank of the ith athlete.",
        "examples": [
            "Input: score = [5,4,3,2,1]\nOutput: [\"Gold Medal\",\"Silver Medal\",\"Bronze Medal\",\"4\",\"5\"]\nExplanation: The placements are [1st, 2nd, 3rd, 4th, 5th].",
            "Input: score = [10,3,8,9,4]\nOutput: [\"Gold Medal\",\"5\",\"Bronze Medal\",\"Silver Medal\",\"4\"]\nExplanation: The placements are [1st, 5th, 3rd, 2nd, 4th]."
        ],
        "constraints": "n == score.length\n1 <= n <= 104\n0 <= score[i] <= 106\nAll the values in score are unique.",
        "oracle_code": "class Solution {\n    public String[] findRelativeRanks(int[] score) {\n         int n=score.length;\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[b]-score[a]);\n        for(int i=0;i<n;i++) pq.add(i);\n      String[] ans = new String[n];\n                int i=1;\n        while(!pq.isEmpty()){\n            int idx=pq.poll();\n         if(i==1)   { ans[idx]=\"Gold Medal\"; i++;}\n         else if(i==2)   { ans[idx]=\"Silver Medal\"; i++;}\n         else if(i==3)   { ans[idx]=\"Bronze Medal\"; i++;}\n         else ans[idx]=Integer.toString(i++);\n        }\n        return ans;  \n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String[] findRelativeRanks(int[] score) {\\n         int n=score.length;\\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[b]-score[a]);\\n        for(int i=0;i<n;i++) pq.add(i);\\n      String[] ans = new String[n];\\n                int i=1;\\n        while(!pq.isEmpty()){\\n            int idx=pq.poll();\\n         if(i==1)   { ans[idx]=\"Gold Medal\"; i++;}\\n         else if(i==2)   { ans[idx]=\"Silver Medal\"; i++;}\\n         else if(i==3)   { ans[idx]=\"Bronze Medal\"; i++;}\\n         else ans[idx]=Integer.toString(i++);\\n        }\\n        return ans;  \\n    }\\n}\\n```",
        "level": "easy",
        "type": [
            "operation error",
            "parentheses mismatch",
            "undefined keywords from other languages",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution {\n    public String[] findRelativeRanks(int[] score) {\n         int n = score.length;\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[a]-score[b]);\n        for(int i=0;i<n;i++) pq.add(i);\n        String[] ans = new String[n];\n                int i=1;\n        while(!pq.isEmpty()){\n            int idx=pq.poll();\n         if(i=1)   { ans[idx]=\"Gold Medal; i++;}\n         elif(i=2)   { ans[idx]=\"Silver Medal; i++;}\n         else if(i=3)   { ans[idx]=\"Bronze Medal; i++;}\n         else ans[idx]=Integer.toString(i++);\n        }\n        return ans;  \n    }\n}\n"
    },
    {
        "slug": "remove-k-digits",
        "description": "Given string num representing a non-negative integer num, and an integer k, return the smallest possible integer after removing k digits from num.",
        "examples": [
            "Input: num = \"1432219\", k = 3\nOutput: \"1219\"\nExplanation: Remove the three digits 4, 3, and 2 to form the new number 1219 which is the smallest.",
            "Input: num = \"10200\", k = 1\nOutput: \"200\"\nExplanation: Remove the leading 1 and the number is 200. Note that the output must not contain leading zeroes.",
            "Input: num = \"10\", k = 2\nOutput: \"0\"\nExplanation: Remove all the digits from the number and it is left with nothing which is 0."
        ],
        "constraints": "1 <= k <= num.length <= 105\nnum consists of only digits.\nnum does not have any leading zeros except for the zero itself.",
        "oracle_code": "class Solution {\n    public String removeKdigits(String num, int k) {\n        Stack<Character> st = new Stack<>();\n        for(Character ch : num.toCharArray()) {\n            while(!st.isEmpty() && k > 0 && ch < st.peek()) {\n                st.pop();\n                k--;\n            }\n\n            if(!st.isEmpty() || ch != '0') {\n                st.push(ch);\n            }\n        }\n\n        // This is a special edge case --> 1 2 3 4\n        while(!st.isEmpty() && k-- > 0) {\n            st.pop();\n        }\n        if(st.isEmpty()) return \"0\";\n        \n\n        // Store the ans -->\n        String ans = \"\";\n        while(!st.isEmpty()) {\n            ans = st.peek() + ans;\n            st.pop();\n        }\n        return ans;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n# Code\\n```\\nclass Solution {\\n    public String removeKdigits(String num, int k) {\\n        Stack<Character> st = new Stack<>();\\n        for(Character ch : num.toCharArray()) {\\n            while(!st.isEmpty() && k > 0 && ch < st.peek()) {\\n                st.pop();\\n                k--;\\n            }\\n\\n            if(!st.isEmpty() || ch != \\'0\\') {\\n                st.push(ch);\\n            }\\n        }\\n\\n        // This is a special edge case --> 1 2 3 4\\n        while(!st.isEmpty() && k-- > 0) {\\n            st.pop();\\n        }\\n        if(st.isEmpty()) return \"0\";\\n        \\n\\n        // Store the ans -->\\n        String ans = \"\";\\n        while(!st.isEmpty()) {\\n            ans = st.peek() + ans;\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n}\\n```",
        "level": "medium",
        "type": [
            "parentheses mismatch",
            "conditional statement error",
            "undefined keywords from other languages",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution {\n    public String removeKdigits(String num, int k) {\n        Stack<Character> st = new Stack<>();\n        for(Character ch : num.toCharArray()) {\n            while(!st.isEmpty() && k > 0 && ch < st.peek())\n                st.pop();\n                \n                k--;\n\n            if(!st.isEmpty() || ch != '1') { \n                st.push(ch);\n            }\n        }\nwhile(!st.isEmpty() && k-- > 0) {\n            st.pop();\n        }\n        if(st.isEmpty()) return \"0\";\n\n        String ans = \"0\";\n        while(!st.isEmpty()) {\n            ans = st.unshift() + ans;\n            st.pop();\n        }\n        return ans;\n    }\n\n}\n"
    },
    {
        "slug": "intersection-of-multiple-arrays",
        "description": "Given a 2D integer array nums where nums[i] is a non-empty array of distinct positive integers, return the list of integers that are present in each array of nums sorted in ascending order.",
        "examples": [
            "Input: nums = [[3,1,2,4,5],[1,2,3,4],[3,4,5,6]]\nOutput: [3,4]\nExplanation: \nThe only integers present in each of nums[0] = [3,1,2,4,5], nums[1] = [1,2,3,4], and nums[2] = [3,4,5,6] are 3 and 4, so we return [3,4].",
            "Input: nums = [[1,2,3],[4,5,6]]\nOutput: []\nExplanation: \nThere does not exist any integer present both in nums[0] and nums[1], so we return an empty list []."
        ],
        "constraints": "1 <= nums.length <= 1000\n1 <= sum(nums[i].length) <= 1000\n1 <= nums[i][j] <= 1000\nAll the values of nums[i] are unique.",
        "oracle_code": "class Solution {\n    public List<Integer> intersection(int[][] nums) {\n        \n        List<Integer> ans = new ArrayList<>();\n        \n        int[] count  = new int[1001];\n        \n        for(int[] arr : nums){\n            for(int i : arr){\n                count[i]++;\n            }\n        }\n        \n       for(int i=0;i<count.length;i++){\n           if(count[i]==nums.length){\n               ans.add(i);\n           }\n       }\n        \n        return ans;\n    }\n}",
        "content": "```\\n\\nclass Solution {\\n    public List<Integer> intersection(int[][] nums) {\\n        \\n        List<Integer> ans = new ArrayList<>();\\n        \\n        int[] count  = new int[1001];\\n        \\n        for(int[] arr : nums){\\n            for(int i : arr){\\n                count[i]++;\\n            }\\n        }\\n        \\n       for(int i=0;i<count.length;i++){\\n           if(count[i]==nums.length){\\n               ans.add(i);\\n           }\\n       }\\n        \\n        return ans;\\n    }\\n}\\n\\n```",
        "level": "easy",
        "type": [
            "== and = confusion",
            "colon missing",
            "indexing error",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\n    public List<Integer> intersection(int[][] nums) {\n        \n        List<Integer> ans = new ArrayList<>();\n        \n        int[] count  = new int[1001]\n        \n        for(int i=0; i<=nums.length; i++){\n            for(int j : nums[i]){\n                count[j]++;\n            }\n        }\n        \n        for(int i=0;i<count.length;i++){\n           if(count[i]=nums.length){\n               ans.add(i);\n           }\n        myRandomUndefinedFunction();\n        \n        }\n        \n        return ans;\n    }\n}\n"
    },
    {
        "slug": "rotating-the-box",
        "description": "You are given an m x n matrix of characters box representing a side-view of a box. Each cell of the box is one of the following:\n\nA stone '#'\nA stationary obstacle '*'\nEmpty '.'\n\nThe box is rotated 90 degrees clockwise, causing some of the stones to fall due to gravity. Each stone falls down until it lands on an obstacle, another stone, or the bottom of the box. Gravity does not affect the obstacles' positions, and the inertia from the box's rotation does not affect the stones' horizontal positions.\nIt is guaranteed that each stone in box rests on an obstacle, another stone, or the bottom of the box.\nReturn an n x m matrix representing the box after the rotation described above.",
        "examples": [
            "Input: box = [[\"#\",\".\",\"#\"]]\r\nOutput: [[\".\"],\r\n\u00a0        [\"#\"],\r\n\u00a0        [\"#\"]]",
            "Input: box = [[\"#\",\".\",\"*\",\".\"],\r\n\u00a0             [\"#\",\"#\",\"*\",\".\"]]\r\nOutput: [[\"#\",\".\"],\r\n\u00a0        [\"#\",\"#\"],\r\n\u00a0        [\"*\",\"*\"],\r\n\u00a0        [\".\",\".\"]]",
            "Input: box = [[\"#\",\"#\",\"*\",\".\",\"*\",\".\"],\r\n\u00a0             [\"#\",\"#\",\"#\",\"*\",\".\",\".\"],\r\n\u00a0             [\"#\",\"#\",\"#\",\".\",\"#\",\".\"]]\r\nOutput: [[\".\",\"#\",\"#\"],\r\n\u00a0        [\".\",\"#\",\"#\"],\r\n\u00a0        [\"#\",\"#\",\"*\"],\r\n\u00a0        [\"#\",\"*\",\".\"],\r\n\u00a0        [\"#\",\".\",\"*\"],\r\n\u00a0        [\"#\",\".\",\".\"]]"
        ],
        "constraints": "m == box.length\nn == box[i].length\n1 <= m, n <= 500\nbox[i][j] is either '#', '*', or '.'.",
        "oracle_code": "// O(n^2) time | O(n^2) space\nclass Solution {\n    public char[][] rotateTheBox(char[][] box) {\n        int m = box.length;\n        int n = box[0].length;\n        char[][] matrix = new char[n][m];   \n        \n        turnBox(box, matrix, m, n); // turn the box clockwise 90 degree\n        \n        turnGravity(matrix, n, m); // cause that falling effect, since matrix turned so n,m\n        \n        return matrix;\n    }\n    \n    public void turnGravity(char[][] matrix, int m, int n){\n        for(int c = 0; c < n; c++){\n            int last  = m-1;\n            for(int r = m-1; r >= 0; r--){\n                char val =  matrix[r][c];\n                if(val == '.') continue;\n                if(val == '*') last = r-1;\n                if(val == '#') {\n                    matrix[r][c] = '.';\n                    matrix[last][c] = '#';\n                    last--;\n                }\n            }\n        }\n    }\n    \n    public void turnBox(char[][] box, char[][] matrix, int m, int n){\n\t// numbers represents sequence it would be copied\n\t//[4][1]\n\t//[5][2]\n\t//[6][3]\n        for(int i = 0, c = m-1; i < m; i++,c--){ // c: 4,3,2,1..\n            for(int j = 0, r = 0; j < n; j++, r++){ // r:0,1,2,3..\n               matrix[r][c] = box[i][j];\n            }\n        }\n    }\n}",
        "content": "**So idea here is**\\n1. First turn 90 degree\\n2. Make things fall\\n\\n```\\n// O(n^2) time | O(n^2) space\\nclass Solution {\\n    public char[][] rotateTheBox(char[][] box) {\\n        int m = box.length;\\n        int n = box[0].length;\\n        char[][] matrix = new char[n][m];   \\n        \\n        turnBox(box, matrix, m, n); // turn the box clockwise 90 degree\\n        \\n        turnGravity(matrix, n, m); // cause that falling effect, since matrix turned so n,m\\n        \\n        return matrix;\\n    }\\n    \\n    public void turnGravity(char[][] matrix, int m, int n){\\n        for(int c = 0; c < n; c++){\\n            int last  = m-1;\\n            for(int r = m-1; r >= 0; r--){\\n                char val =  matrix[r][c];\\n                if(val == \\'.\\') continue;\\n                if(val == \\'*\\') last = r-1;\\n                if(val == \\'#\\') {\\n                    matrix[r][c] = \\'.\\';\\n                    matrix[last][c] = \\'#\\';\\n                    last--;\\n                }\\n            }\\n        }\\n    }\\n    \\n    public void turnBox(char[][] box, char[][] matrix, int m, int n){\\n\\t// numbers represents sequence it would be copied\\n\\t//[4][1]\\n\\t//[5][2]\\n\\t//[6][3]\\n        for(int i = 0, c = m-1; i < m; i++,c--){ // c: 4,3,2,1..\\n            for(int j = 0, r = 0; j < n; j++, r++){ // r:0,1,2,3..\\n               matrix[r][c] = box[i][j];\\n            }\\n        }\\n    }\\n}\\n```",
        "level": "medium",
        "type": [
            "== and = confusion",
            "other error",
            "wrong comment mark",
            "unclosed string"
        ],
        "buggy_code": "\n// O(n^2) time | O(n^2) space\nclass Solution {\n    public char[][] rotateTheBox(char[][] box) {\n        int m = box.length;\n        int n = box[0].length;\n        char[][] matrix = new char[n][m];   \n        \n        turnBox(box, matrix, m, n); // turn the box clockwise 90 degree\n        \n        turnGravity(matrix, n, m); ' cause that falling effect, since matrix turned so n,m\n        \n        return matrix;\n    }\n    \n    public void turnGravity(char[][] matrix, int m, int n){\n        for(int c = 0; c < n; c++){\n            int last  = m-1;\n            for(int r = m-1; r >= 0; r--){\n                char val =  matrix[r][c];\n                if(val == '.') continue;\n                if(val = '*') last = r-1;  \n                if(val == '#') {\n                    matrix[r][c] = '.';\n                    matrix[last][c] = '#;\n                }\n            }\n        }\n    }\n    \n    public void turnBox(char[][] box, char[][] matrix, int m, int n){\n                        for(int i = 0, c = m-1; i < m; i++,c--){ // c: 4,3,2,1..\n            for(int j = 0, r = 0; j < n; j++, r++){ // r:0,1,2,3..\n               matrix[r][1] = box[i][j];\n            }\n        }\n    }\n}\n"
    },
    {
        "slug": "largest-3-same-digit-number-in-string",
        "description": "You are given a string num representing a large integer. An integer is good if it meets the following conditions:\n\nIt is a substring of num with length 3.\nIt consists of only one unique digit.\n\nReturn the maximum good integer as a string or an empty string \"\" if no such integer exists.\nNote:\n\nA substring is a contiguous sequence of characters within a string.\nThere may be leading zeroes in num or a good integer.",
        "examples": [
            "Input: num = \"6777133339\"\nOutput: \"777\"\nExplanation: There are two distinct good integers: \"777\" and \"333\".\n\"777\" is the largest, so we return \"777\".",
            "Input: num = \"2300019\"\nOutput: \"000\"\nExplanation: \"000\" is the only good integer.",
            "Input: num = \"42352338\"\nOutput: \"\"\nExplanation: No substring of length 3 consists of only one unique digit. Therefore, there are no good integers."
        ],
        "constraints": "3 <= num.length <= 1000\nnum only consists of digits.",
        "oracle_code": "class Solution {\n    public String largestGoodInteger(String num) {\n        int n=-1;\n        StringBuilder sb = new StringBuilder();\n        for(int i=0;i<num.length()-2;i++){\n            if(num.charAt(i)==num.charAt(i+1) && num.charAt(i)==num.charAt(i+2)){\n                sb.append(num.charAt(i));\n                sb.append(num.charAt(i));\n                sb.append(num.charAt(i));\n                if(Integer.parseInt(sb.toString())>n)\n                    n=Integer.parseInt(sb.toString());\n                sb.setLength(0);\n            }\n        }\n        if(n==-1)\n            return \"\";\n        String s = Integer.toString(n);\n        if(s.equals(\"0\"))\n            return \"000\";\n        return s;\n    }\n}",
        "content": "```\\nclass Solution {\\n    public String largestGoodInteger(String num) {\\n        int n=-1;\\n        StringBuilder sb = new StringBuilder();\\n        for(int i=0;i<num.length()-2;i++){\\n            if(num.charAt(i)==num.charAt(i+1) && num.charAt(i)==num.charAt(i+2)){\\n                sb.append(num.charAt(i));\\n                sb.append(num.charAt(i));\\n                sb.append(num.charAt(i));\\n                if(Integer.parseInt(sb.toString())>n)\\n                    n=Integer.parseInt(sb.toString());\\n                sb.setLength(0);\\n            }\\n        }\\n        if(n==-1)\\n            return \"\";\\n        String s = Integer.toString(n);\\n        if(s.equals(\"0\"))\\n            return \"000\";\\n        return s;\\n    }\\n}\\n```\\nKindly upvote if you like the code.",
        "level": "easy",
        "type": [
            "== and = confusion",
            "conditional statement error",
            "wrong comment mark",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution {\n    public String largestGoodInteger(String num) {\n        int n=-1;\n        StringBuilder sb = new StringBuilder();\n        for(int i=0;i<=num.length()-2;i++){\n            if(num.charAt(i)==num.charAt(i+1) && num.charAt(i)==num.charAt(i+2)){\n                sb.append(num.charAt(i));\n                sb.append(num.charAt(i));\n                sb.append(num.charAt(i));\n                if(Integer.parseInt(sb.toString())=n)\n                    n=Integer.parseInt(sb.toString());\n                sb.setLength(0);\n                /*\n            }\n        }\n        if(n==-1)\n            return \";\n        String s = Integer.toString(n);\n        if(s.equals(\"0\"))\n            return \"000\";\n        return s;\n    }\n}\n"
    },
    {
        "slug": "remove-k-digits",
        "description": "Given string num representing a non-negative integer num, and an integer k, return the smallest possible integer after removing k digits from num.",
        "examples": [
            "Input: num = \"1432219\", k = 3\nOutput: \"1219\"\nExplanation: Remove the three digits 4, 3, and 2 to form the new number 1219 which is the smallest.",
            "Input: num = \"10200\", k = 1\nOutput: \"200\"\nExplanation: Remove the leading 1 and the number is 200. Note that the output must not contain leading zeroes.",
            "Input: num = \"10\", k = 2\nOutput: \"0\"\nExplanation: Remove all the digits from the number and it is left with nothing which is 0."
        ],
        "constraints": "1 <= k <= num.length <= 105\nnum consists of only digits.\nnum does not have any leading zeros except for the zero itself.",
        "oracle_code": "class Solution {\n    public String removeKdigits(String num, int k) {\n        Stack<Character> st = new Stack<>();\n        for(Character ch : num.toCharArray()) {\n            while(!st.isEmpty() && k > 0 && ch < st.peek()) {\n                st.pop();\n                k--;\n            }\n\n            if(!st.isEmpty() || ch != '0') {\n                st.push(ch);\n            }\n        }\n\n        // This is a special edge case --> 1 2 3 4\n        while(!st.isEmpty() && k-- > 0) {\n            st.pop();\n        }\n        if(st.isEmpty()) return \"0\";\n        \n\n        // Store the ans -->\n        String ans = \"\";\n        while(!st.isEmpty()) {\n            ans = st.peek() + ans;\n            st.pop();\n        }\n        return ans;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n# Code\\n```\\nclass Solution {\\n    public String removeKdigits(String num, int k) {\\n        Stack<Character> st = new Stack<>();\\n        for(Character ch : num.toCharArray()) {\\n            while(!st.isEmpty() && k > 0 && ch < st.peek()) {\\n                st.pop();\\n                k--;\\n            }\\n\\n            if(!st.isEmpty() || ch != \\'0\\') {\\n                st.push(ch);\\n            }\\n        }\\n\\n        // This is a special edge case --> 1 2 3 4\\n        while(!st.isEmpty() && k-- > 0) {\\n            st.pop();\\n        }\\n        if(st.isEmpty()) return \"0\";\\n        \\n\\n        // Store the ans -->\\n        String ans = \"\";\\n        while(!st.isEmpty()) {\\n            ans = st.peek() + ans;\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n}\\n```",
        "level": "medium",
        "type": [
            "parentheses mismatch",
            "conditional statement error",
            "undefined keywords from other languages",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\n    public String removeKdigits(String num, int k) {\n        Stack<Character> st = new Stack<>();\n        for(Character ch : num.toCharArray()) {\n            while(!st.isEmpty() && k > 0 && ch < st.peek())\n                st.pop();\n                \n                k--;\n\n            if(!st.isEmpty() || ch != '1') { \n                st.push(ch);\n            }\n        }\nwhile(!st.isEmpty() && k-- > 0) {\n            st.pop();\n        }\n        if(st.isEmpty()) return \"0\";\n\n        String ans = \"\";\n        while(!st.isEmpty()) {\n            ans = st.unshift() + ans;\n            st.pop();\n        }\n        return result;\n    }\n}\n"
    },
    {
        "slug": "minimum-score-triangulation-of-polygon",
        "description": "You have a convex n-sided polygon where each vertex has an integer value. You are given an integer array values where values[i] is the value of the ith vertex (i.e., clockwise order).\nYou will triangulate the polygon into n - 2 triangles. For each triangle, the value of that triangle is the product of the values of its vertices, and the total score of the triangulation is the sum of these values over all n - 2 triangles in the triangulation.\nReturn the smallest possible total score that you can achieve with some triangulation of the polygon.",
        "examples": [
            "Input: values = [1,2,3]\nOutput: 6\nExplanation: The polygon is already triangulated, and the score of the only triangle is 6.",
            "Input: values = [3,7,4,5]\nOutput: 144\nExplanation: There are two triangulations, with possible scores: 3*7*5 + 4*5*7 = 245, or 3*4*5 + 3*4*7 = 144.\nThe minimum score is 144.",
            "Input: values = [1,3,1,4,1,5]\nOutput: 13\nExplanation: The minimum score triangulation has score 1*1*3 + 1*1*4 + 1*1*5 + 1*1*1 = 13."
        ],
        "constraints": "n == values.length\n3 <= n <= 50\n1 <= values[i] <= 100",
        "oracle_code": "class Solution {\n    int[][] dp;\n    public int minScoreTriangulation(int[] values) {\n        int l=values.length;\n        dp = new int[l][l];\n        for(int[] i : dp) Arrays.fill(i,-1);\n        return solve(values,1,l-1); \n    }\n\n    public int solve(int[] values, int i,int j)\n    {\n        if(i>=j) return 0;\n        if(dp[i][j]!=-1) return dp[i][j];\n        int min=Integer.MAX_VALUE;\n        for(int k=i;k<j;k++)\n        {\n            int temp=solve(values,i,k)+solve(values,k+1,j)+\n                        values[i-1]*values[k]*values[j];\n            min=Math.min(min,temp);\n        }\n\n        return dp[i][j]=min;\n    }\n}",
        "content": "\\n# Complexity\\n- Time complexity: n^2\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: n^2\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int[][] dp;\\n    public int minScoreTriangulation(int[] values) {\\n        int l=values.length;\\n        dp = new int[l][l];\\n        for(int[] i : dp) Arrays.fill(i,-1);\\n        return solve(values,1,l-1); \\n    }\\n\\n    public int solve(int[] values, int i,int j)\\n    {\\n        if(i>=j) return 0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int min=Integer.MAX_VALUE;\\n        for(int k=i;k<j;k++)\\n        {\\n            int temp=solve(values,i,k)+solve(values,k+1,j)+\\n                        values[i-1]*values[k]*values[j];\\n            min=Math.min(min,temp);\\n        }\\n\\n        return dp[i][j]=min;\\n    }\\n}\\n```",
        "level": "medium",
        "type": [
            "parentheses mismatch",
            "colon missing",
            "wrong comment mark",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution {\n    int[][] dp;\n    public int minScoreTriangulation(int[] values) {\n        int l=values.length;\n        dp = new int[l][l];\n        for int[] i : dp) Arrays.fill(i,-1);\n        \n    }\n\n    public int solve(int[] values, int i,int j)\n    {\n        if(i>=j) return 0;\n        if(dp[i][j]!=-1) return dp[i][j];\n        int min=Integer.MAX_VALUE;\n        for(int k=i;k<j;k++)\n        {\n            int temp=solve(values,i,k)+solve(values,k+1,j)\n                        values[i-1]*values[k]*values[undefined];\n            min=Math.min(min,temp);\n        }\n\n        return dp[i][j]=min;\n    }\n}\n"
    },
    {
        "slug": "erect-the-fence",
        "description": "You are given an array trees where trees[i] = [xi, yi] represents the location of a tree in the garden.\nFence the entire garden using the minimum length of rope, as it is expensive. The garden is well-fenced only if all the trees are enclosed.\nReturn the coordinates of trees that are exactly located on the fence perimeter. You may return the answer in any order.",
        "examples": [
            "Input: trees = [[1,1],[2,2],[2,0],[2,4],[3,3],[4,2]]\nOutput: [[1,1],[2,0],[4,2],[3,3],[2,4]]\nExplanation: All the trees will be on the perimeter of the fence except the tree at [2, 2], which will be inside the fence.",
            "Input: trees = [[1,2],[2,2],[4,2]]\nOutput: [[4,2],[2,2],[1,2]]\nExplanation: The fence forms a line that passes through all the trees."
        ],
        "constraints": "1 <= trees.length <= 3000\ntrees[i].length == 2\n0 <= xi, yi <= 100\nAll the given positions are unique.",
        "oracle_code": "class Solution {\n    \n    public int[][] outerTrees(int[][] trees) {\n        if(trees.length == 3){\n            return trees;\n        }\n        Stack<int[]> upper = new Stack<>();\n        Stack<int[]> lower = new Stack<>();\n        \n        Arrays.sort(trees,(p,q) ->\n                  q[0]-p[0]==0?q[1]-p[1]:q[0]-p[0]);\n        \n        for(int i = 0 ; i < trees.length ; i++){\n            int size = trees.length;\n            while(upper.size() >= 2 && angle(upper.get(upper.size() - 2),upper.get(upper.size() - 1),trees[i]) > 0){\n                upper.pop();  \n                }\n            while(lower.size() >= 2 && angle(lower.get(lower.size() - 2),lower.get(lower.size() - 1),trees[i]) < 0){\n                 lower.pop();  \n              }\n            upper.push(trees[i]);\n            lower.push(trees[i]);\n        }\n        \n        \n        Set<int[]> res= new HashSet<>(lower);\n        res.addAll(upper);\n        return res.toArray(new int[res.size()][]);\n    }\n    \n    public int angle(int[] A , int[] B , int[] C){\n        return (C[0] - A[0]) * (B[1] - A[1]) - (B[0] - A[0]) * (C[1] - A[1]);\n    }\n}",
        "content": "```\\nclass Solution {\\n    \\n    public int[][] outerTrees(int[][] trees) {\\n        if(trees.length == 3){\\n            return trees;\\n        }\\n        Stack<int[]> upper = new Stack<>();\\n        Stack<int[]> lower = new Stack<>();\\n        \\n        Arrays.sort(trees,(p,q) ->\\n                  q[0]-p[0]==0?q[1]-p[1]:q[0]-p[0]);\\n        \\n        for(int i = 0 ; i < trees.length ; i++){\\n            int size = trees.length;\\n            while(upper.size() >= 2 && angle(upper.get(upper.size() - 2),upper.get(upper.size() - 1),trees[i]) > 0){\\n                upper.pop();  \\n                }\\n            while(lower.size() >= 2 && angle(lower.get(lower.size() - 2),lower.get(lower.size() - 1),trees[i]) < 0){\\n                 lower.pop();  \\n              }\\n            upper.push(trees[i]);\\n            lower.push(trees[i]);\\n        }\\n        \\n        \\n        Set<int[]> res= new HashSet<>(lower);\\n        res.addAll(upper);\\n        return res.toArray(new int[res.size()][]);\\n    }\\n    \\n    public int angle(int[] A , int[] B , int[] C){\\n        return (C[0] - A[0]) * (B[1] - A[1]) - (B[0] - A[0]) * (C[1] - A[1]);\\n    }\\n}\\n```\\n\\n**Upvote Please**",
        "level": "hard",
        "type": [
            "== and = confusion",
            "colon missing",
            "undefined objects",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution {\n    \n    var trees = [];\n    public int[][] outerTrees(int[][] trees) {\n        if(trees.length = 3)\n            return trees;\n        Stack<int[]> upper = new Stack<>();\n        Stack<int[]> lower = null;\n        \n        Arrays.sort(trees,(p,q) ->\n                  q[0]-p[0]==0?q[1]-p[1]:q[0]-p[0]);\n        \n        for(int i = 0 ; i < trees.length ; i++){\n            while(upper.size() >= 2 && angle(upper.get(upper.size() - 2),upper.get(upper.size() - 1),trees[i]) > 0){\n                upper.pop();\n                }\n            while(lower.size() >= 2 && angle(lower.get(lower.size() - 2),lower.get(lower.size() - 1),trees[i]) < 0){\n                 lower.pop();   \n              }\n            upper.push(trees[i]);\n            lower.push(trees[i])\n        }\n        \n        \n        Set<int[]> res= new HashSet<>(lower);\n        res.addAll(upper);\n        return res.toArray(new int[res.size()][]);\n    }\n    \n    public int angle(int[] A , int[] B , int[] C){\n        return (C[0] - A[0]) * (B[1] - A[1]) - (B[0] - A[0]) * (C[1] - A[1]);\n    }\n}\n"
    },
    {
        "slug": "rotating-the-box",
        "description": "You are given an m x n matrix of characters box representing a side-view of a box. Each cell of the box is one of the following:\n\nA stone '#'\nA stationary obstacle '*'\nEmpty '.'\n\nThe box is rotated 90 degrees clockwise, causing some of the stones to fall due to gravity. Each stone falls down until it lands on an obstacle, another stone, or the bottom of the box. Gravity does not affect the obstacles' positions, and the inertia from the box's rotation does not affect the stones' horizontal positions.\nIt is guaranteed that each stone in box rests on an obstacle, another stone, or the bottom of the box.\nReturn an n x m matrix representing the box after the rotation described above.",
        "examples": [
            "Input: box = [[\"#\",\".\",\"#\"]]\r\nOutput: [[\".\"],\r\n\u00a0        [\"#\"],\r\n\u00a0        [\"#\"]]",
            "Input: box = [[\"#\",\".\",\"*\",\".\"],\r\n\u00a0             [\"#\",\"#\",\"*\",\".\"]]\r\nOutput: [[\"#\",\".\"],\r\n\u00a0        [\"#\",\"#\"],\r\n\u00a0        [\"*\",\"*\"],\r\n\u00a0        [\".\",\".\"]]",
            "Input: box = [[\"#\",\"#\",\"*\",\".\",\"*\",\".\"],\r\n\u00a0             [\"#\",\"#\",\"#\",\"*\",\".\",\".\"],\r\n\u00a0             [\"#\",\"#\",\"#\",\".\",\"#\",\".\"]]\r\nOutput: [[\".\",\"#\",\"#\"],\r\n\u00a0        [\".\",\"#\",\"#\"],\r\n\u00a0        [\"#\",\"#\",\"*\"],\r\n\u00a0        [\"#\",\"*\",\".\"],\r\n\u00a0        [\"#\",\".\",\"*\"],\r\n\u00a0        [\"#\",\".\",\".\"]]"
        ],
        "constraints": "m == box.length\nn == box[i].length\n1 <= m, n <= 500\nbox[i][j] is either '#', '*', or '.'.",
        "oracle_code": "// O(n^2) time | O(n^2) space\nclass Solution {\n    public char[][] rotateTheBox(char[][] box) {\n        int m = box.length;\n        int n = box[0].length;\n        char[][] matrix = new char[n][m];   \n        \n        turnBox(box, matrix, m, n); // turn the box clockwise 90 degree\n        \n        turnGravity(matrix, n, m); // cause that falling effect, since matrix turned so n,m\n        \n        return matrix;\n    }\n    \n    public void turnGravity(char[][] matrix, int m, int n){\n        for(int c = 0; c < n; c++){\n            int last  = m-1;\n            for(int r = m-1; r >= 0; r--){\n                char val =  matrix[r][c];\n                if(val == '.') continue;\n                if(val == '*') last = r-1;\n                if(val == '#') {\n                    matrix[r][c] = '.';\n                    matrix[last][c] = '#';\n                    last--;\n                }\n            }\n        }\n    }\n    \n    public void turnBox(char[][] box, char[][] matrix, int m, int n){\n\t// numbers represents sequence it would be copied\n\t//[4][1]\n\t//[5][2]\n\t//[6][3]\n        for(int i = 0, c = m-1; i < m; i++,c--){ // c: 4,3,2,1..\n            for(int j = 0, r = 0; j < n; j++, r++){ // r:0,1,2,3..\n               matrix[r][c] = box[i][j];\n            }\n        }\n    }\n}",
        "content": "**So idea here is**\\n1. First turn 90 degree\\n2. Make things fall\\n\\n```\\n// O(n^2) time | O(n^2) space\\nclass Solution {\\n    public char[][] rotateTheBox(char[][] box) {\\n        int m = box.length;\\n        int n = box[0].length;\\n        char[][] matrix = new char[n][m];   \\n        \\n        turnBox(box, matrix, m, n); // turn the box clockwise 90 degree\\n        \\n        turnGravity(matrix, n, m); // cause that falling effect, since matrix turned so n,m\\n        \\n        return matrix;\\n    }\\n    \\n    public void turnGravity(char[][] matrix, int m, int n){\\n        for(int c = 0; c < n; c++){\\n            int last  = m-1;\\n            for(int r = m-1; r >= 0; r--){\\n                char val =  matrix[r][c];\\n                if(val == \\'.\\') continue;\\n                if(val == \\'*\\') last = r-1;\\n                if(val == \\'#\\') {\\n                    matrix[r][c] = \\'.\\';\\n                    matrix[last][c] = \\'#\\';\\n                    last--;\\n                }\\n            }\\n        }\\n    }\\n    \\n    public void turnBox(char[][] box, char[][] matrix, int m, int n){\\n\\t// numbers represents sequence it would be copied\\n\\t//[4][1]\\n\\t//[5][2]\\n\\t//[6][3]\\n        for(int i = 0, c = m-1; i < m; i++,c--){ // c: 4,3,2,1..\\n            for(int j = 0, r = 0; j < n; j++, r++){ // r:0,1,2,3..\\n               matrix[r][c] = box[i][j];\\n            }\\n        }\\n    }\\n}\\n```",
        "level": "medium",
        "type": [
            "colon missing",
            "other error",
            "wrong comment mark",
            "indexing error"
        ],
        "buggy_code": "\n// O(n^2) time | O(n^2) space\nclass Solution {\n    public char[][] rotateTheBox(char[][] box) {\n        int m = box.length;\n        int n = box[0].length + 1; \n        char[][] matrix = new char[n][m]   \n        \n        turnBox(box, matrix, m, n); // turn the box clockwise 90 degree\n        \n        turnGravity(matrix, n, m); ' cause that falling effect, since matrix turned so n,m\n        \n        return matrix;\n    }\n    \n    public void turnGravity(char[][] matrix, int m, int n){\n        for(int c = 0; c < n; c++){\n            int last  = m-1;\n            for(int r = m-1; r >= 0; r--){\n                char val =  matrix[r][c];\n                if(val == '.') continue;\n                if(val == '*') last = r-1;\n                if(val == '#') {\n                    matrix[r][c] = '.';\n                    matrix[last][c] = '#';\n                }\n            }\n        }\n    }\n    \n    public void turnBox(char[][] box, char[][] matrix, int m, int n){\n        for(int i = 0, c = m-1; i < m; i++,c--){\n            for(int j = 0, r = 0; j < n; j++, r++){\n               matrix[r][1] = box[i][j];\n            }\n        }\n    }\n}\n"
    },
    {
        "slug": "relative-ranks",
        "description": "You are given an integer array score of size n, where score[i] is the score of the ith athlete in a competition. All the scores are guaranteed to be unique.\nThe athletes are placed based on their scores, where the 1st place athlete has the highest score, the 2nd place athlete has the 2nd highest score, and so on. The placement of each athlete determines their rank:\n\nThe 1st place athlete's rank is \"Gold Medal\".\nThe 2nd place athlete's rank is \"Silver Medal\".\nThe 3rd place athlete's rank is \"Bronze Medal\".\nFor the 4th place to the nth place athlete, their rank is their placement number (i.e., the xth place athlete's rank is \"x\").\n\nReturn an array answer of size n where answer[i] is the rank of the ith athlete.",
        "examples": [
            "Input: score = [5,4,3,2,1]\nOutput: [\"Gold Medal\",\"Silver Medal\",\"Bronze Medal\",\"4\",\"5\"]\nExplanation: The placements are [1st, 2nd, 3rd, 4th, 5th].",
            "Input: score = [10,3,8,9,4]\nOutput: [\"Gold Medal\",\"5\",\"Bronze Medal\",\"Silver Medal\",\"4\"]\nExplanation: The placements are [1st, 5th, 3rd, 2nd, 4th]."
        ],
        "constraints": "n == score.length\n1 <= n <= 104\n0 <= score[i] <= 106\nAll the values in score are unique.",
        "oracle_code": "class Solution {\n    public String[] findRelativeRanks(int[] score) {\n         int n=score.length;\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[b]-score[a]);\n        for(int i=0;i<n;i++) pq.add(i);\n      String[] ans = new String[n];\n                int i=1;\n        while(!pq.isEmpty()){\n            int idx=pq.poll();\n         if(i==1)   { ans[idx]=\"Gold Medal\"; i++;}\n         else if(i==2)   { ans[idx]=\"Silver Medal\"; i++;}\n         else if(i==3)   { ans[idx]=\"Bronze Medal\"; i++;}\n         else ans[idx]=Integer.toString(i++);\n        }\n        return ans;  \n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String[] findRelativeRanks(int[] score) {\\n         int n=score.length;\\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[b]-score[a]);\\n        for(int i=0;i<n;i++) pq.add(i);\\n      String[] ans = new String[n];\\n                int i=1;\\n        while(!pq.isEmpty()){\\n            int idx=pq.poll();\\n         if(i==1)   { ans[idx]=\"Gold Medal\"; i++;}\\n         else if(i==2)   { ans[idx]=\"Silver Medal\"; i++;}\\n         else if(i==3)   { ans[idx]=\"Bronze Medal\"; i++;}\\n         else ans[idx]=Integer.toString(i++);\\n        }\\n        return ans;  \\n    }\\n}\\n```",
        "level": "easy",
        "type": [
            "operation error",
            "== and = confusion",
            "parentheses mismatch",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution {\n    public String[] findRelativeRanks(int[] score) {\n         int n = score.length;\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[a]-score[b]);\n        for(int i=0;i<n;i++) pq.add(i);\n          String[] ans = new String[n];\n        int i=1;\n        while(!pq.isEmpty()){\n            int idx=pq.poll();\n            if(i=1) { ans[idx]=\"Gold Medal\"; i++;} \n            elif(i=2) { ans[idx]=\"Silver Medal\"; i++;} \n            else if(i=3) { ans[idx]=\"Bronze Medal\"; i++;} \n            else ans[idx]=Integer.toString(i++);\n        }\n        return ans;  \n    }\n}\n"
    },
    {
        "slug": "lexicographically-smallest-equivalent-string",
        "description": "You are given two strings of the same length s1 and s2 and a string baseStr.\nWe say s1[i] and s2[i] are equivalent characters.\n\nFor example, if s1 = \"abc\" and s2 = \"cde\", then we have 'a' == 'c', 'b' == 'd', and 'c' == 'e'.\n\nEquivalent characters follow the usual rules of any equivalence relation:\n\nReflexivity: 'a' == 'a'.\nSymmetry: 'a' == 'b' implies 'b' == 'a'.\nTransitivity: 'a' == 'b' and 'b' == 'c' implies 'a' == 'c'.\n\nFor example, given the equivalency information from s1 = \"abc\" and s2 = \"cde\", \"acd\" and \"aab\" are equivalent strings of baseStr = \"eed\", and \"aab\" is the lexicographically smallest equivalent string of baseStr.\nReturn the lexicographically smallest equivalent string of baseStr by using the equivalency information from s1 and s2.",
        "examples": [
            "Input: s1 = \"parker\", s2 = \"morris\", baseStr = \"parser\"\nOutput: \"makkek\"\nExplanation: Based on the equivalency information in s1 and s2, we can group their characters as [m,p], [a,o], [k,r,s], [e,i].\nThe characters in each group are equivalent and sorted in lexicographical order.\nSo the answer is \"makkek\".",
            "Input: s1 = \"hello\", s2 = \"world\", baseStr = \"hold\"\nOutput: \"hdld\"\nExplanation: Based on the equivalency information in s1 and s2, we can group their characters as [h,w], [d,e,o], [l,r].\nSo only the second letter 'o' in baseStr is changed to 'd', the answer is \"hdld\".",
            "Input: s1 = \"leetcode\", s2 = \"programs\", baseStr = \"sourcecode\"\nOutput: \"aauaaaaada\"\nExplanation: We group the equivalent characters in s1 and s2 as [a,o,e,r,s,c], [l,p], [g,t] and [d,m], thus all letters in baseStr except 'u' and 'd' are transformed to 'a', the answer is \"aauaaaaada\"."
        ],
        "constraints": "1 <= s1.length, s2.length, baseStr <= 1000\ns1.length == s2.length\ns1, s2, and baseStr consist of lowercase English letters.",
        "oracle_code": "class Solution {\n    public String smallestEquivalentString(String s1, String s2, String baseStr) {\n        \n        UFDS dsu = new UFDS(26);\n        for(int i = 0; i < s1.length(); i++){\n            dsu.union(s1.charAt(i)-97,s2.charAt(i)-97);\n        }\n\n        StringBuilder sb = new StringBuilder(); \n\n        for(int i = 0; i < baseStr.length(); i++){\n            int root = dsu.root(baseStr.charAt(i) - 97);\n            sb.append((char)(dsu.min[root] + 97));\n\n        }\n        return sb.toString();\n    }\n    \n    class UFDS{\n        \n        int[] id;\n        int[] size;\n        int[] min;\n        \n        public UFDS(int N){\n            \n            id = new int[N];\n            size = new int[N];\n            min = new int[N];\n            for(int i = 0; i < N; i++){\n                id[i] = i;\n                size[i] = 1;\n                min[i] = i;\n            }\n        }\n        \n        private int root(int i){\n            while (i != id[i]){\n                id[i] = id[id[i]];\n                i = id[i];\n            }\n            return i;\n        }\n        \n        public void union(int p, int q){\n            \n            int i = root(p);\n            int j = root(q);\n            if(i == j)return;\n            if(size[i] < size[j]){\n                id[i] = id[j];\n                size[j] += size[i];\n                min[j] = Math.min(min[i],min[j]);\n            }\n            else{\n                id[j] = id[i];\n                size[i] += size[j];\n                min[i] = Math.min(min[i],min[j]);\n            }\n        }\n\n    }   \n}",
        "content": "# Intuition\\nThis is as straight forward of a DSU/UFDS problem as they come. One could think of equivalent characters as elements belonging to the same set. If a certain character of one set is found to be equivalent to be the character of some other set, a union of those two sets has to be performed. Also, the smallest character in each set has to be tracked so as to finally construct our answer.\\n\\n# Approach\\nStart by initialsing a UFDS class with 26 elements (elements being the characters of a set). Take union of two equivalent characters a/c to String S1 and S2, while taking union, keep tracking the minimum element of the sets involved using an extra \\'min\\' array. To finally construct the answer, find the min character for each set a character of the baseStr String belongs to. \\n\\n\\n# Code\\n```\\nclass Solution {\\n    public String smallestEquivalentString(String s1, String s2, String baseStr) {\\n        \\n        UFDS dsu = new UFDS(26);\\n        for(int i = 0; i < s1.length(); i++){\\n            dsu.union(s1.charAt(i)-97,s2.charAt(i)-97);\\n        }\\n\\n        StringBuilder sb = new StringBuilder(); \\n\\n        for(int i = 0; i < baseStr.length(); i++){\\n            int root = dsu.root(baseStr.charAt(i) - 97);\\n            sb.append((char)(dsu.min[root] + 97));\\n\\n        }\\n        return sb.toString();\\n    }\\n    \\n    class UFDS{\\n        \\n        int[] id;\\n        int[] size;\\n        int[] min;\\n        \\n        public UFDS(int N){\\n            \\n            id = new int[N];\\n            size = new int[N];\\n            min = new int[N];\\n            for(int i = 0; i < N; i++){\\n                id[i] = i;\\n                size[i] = 1;\\n                min[i] = i;\\n            }\\n        }\\n        \\n        private int root(int i){\\n            while (i != id[i]){\\n                id[i] = id[id[i]];\\n                i = id[i];\\n            }\\n            return i;\\n        }\\n        \\n        public void union(int p, int q){\\n            \\n            int i = root(p);\\n            int j = root(q);\\n            if(i == j)return;\\n            if(size[i] < size[j]){\\n                id[i] = id[j];\\n                size[j] += size[i];\\n                min[j] = Math.min(min[i],min[j]);\\n            }\\n            else{\\n                id[j] = id[i];\\n                size[i] += size[j];\\n                min[i] = Math.min(min[i],min[j]);\\n            }\\n        }\\n\\n    }   \\n}\\n```",
        "level": "medium",
        "type": [
            "operation error",
            "wrong comment mark",
            "indexing error",
            "statement separation"
        ],
        "buggy_code": "\nclass Solution {\n    public String smallestEquivalentString(String s1, String s2, /* String baseStr) {\n        \n        UFDS dsu = new UFDS(26);\n        for(int i = 0; i <= s1.length(); i++)\n            dsu.union(s1.charAt(i)-97,s2.charAt(i)-97);\n\n        StringBuilder sb = new StringBuilder(); \n\n        for(int i = 0; i < baseStr.length(); i++)\n            int root = dsu.root(baseStr.charAt(i) - 97);\n            sb.append((char)(dsu.min[root] + 97));\n\n        return sb.reverse().toString();\n    }\n    \n    class UFDS{\n        \n        int[] id;\n        int[] size;\n        int[] min;\n        \n        public UFDS(int N){\n            \n            id = new int[N];\n            size = new int[N];\n            min = new int[N];\n            for(int i = 0; i < N; i++){\n                id[i] = i;\n                size[i] = 1;\n                min[i] = i;\n            }\n        }\n        \n        private int root(int i){\n            while (i != id[i]){\n                id[i] = id[id[i]];\n                i = id[i];\n            }\n            return i;\n        }\n        \n        public void union(int p, int q){\n            \n            int i = root(p);\n            int j = root(q);\n            if(i == j)return;\n            if(size[i] < size[j]){\n                id[i] = id[j];\n                size[j] += size[i];\n                min[j] = Math.min(min[i],min[j]);\n            }\n            else{\n                id[j] = id[i];\n                size[i] += size[j];\n                min[i] = Math.min(min[i],min[j]);\n            }\n        }\n\n    }   \n}\n"
    },
    {
        "slug": "daily-temperatures",
        "description": "Given an array of integers temperatures represents the daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after the ith day to get a warmer temperature. If there is no future day for which this is possible, keep answer[i] == 0 instead.",
        "examples": [
            "Input: temperatures = [73,74,75,71,69,72,76,73]\nOutput: [1,1,4,2,1,1,0,0]",
            "Input: temperatures = [30,40,50,60]\nOutput: [1,1,1,0]",
            "Input: temperatures = [30,60,90]\nOutput: [1,1,0]"
        ],
        "constraints": "1 <=\u00a0temperatures.length <= 105\n30 <=\u00a0temperatures[i] <= 100",
        "oracle_code": "class Solution {\n    public int[] dailyTemperatures(int[] temperatures) {\n        \n        int[] arr = new int[temperatures.length]; \n        \n        ArrayDeque<int[]> st = new ArrayDeque<>(); \n        \n        int i=0, j=temperatures.length-1 ; \n        \n        while( j >= 0){\n            \n            if(st.size()==0){\n                arr[i++] = 0;\n            }\n            else  if (st.size()>0 && st.peek()[0]>temperatures[j])\n            {\n                arr[i++]=1;\n            } \n            else if (st.size()>0 && st.peek()[0]<=temperatures[j])\n            \n            {  while(st.size()>0 && st.peek()[0]<=temperatures[j]){\n                    st.pop();\n                    \n                }\n            if(st.size()==0){\n                arr[i++]=0;\n            }\n            else{\n                arr[i++]=st.peek()[1]-j;\n            }\n            } \n        st.push(new int[]{temperatures[j],j}); \n        j--;\n        }\n        \n      \n        int[] ans = new int[temperatures.length]; int k=0;\n        for(i=arr.length-1; i>=0; i--){\n            ans[k++]=arr[i];\n        }\n        return ans;\n    }\n}",
        "content": "```\\nclass Solution {\\n    public int[] dailyTemperatures(int[] temperatures) {\\n        \\n        int[] arr = new int[temperatures.length]; \\n        \\n        ArrayDeque<int[]> st = new ArrayDeque<>(); \\n        \\n        int i=0, j=temperatures.length-1 ; \\n        \\n        while( j >= 0){\\n            \\n            if(st.size()==0){\\n                arr[i++] = 0;\\n            }\\n            else  if (st.size()>0 && st.peek()[0]>temperatures[j])\\n            {\\n                arr[i++]=1;\\n            } \\n            else if (st.size()>0 && st.peek()[0]<=temperatures[j])\\n            \\n            {  while(st.size()>0 && st.peek()[0]<=temperatures[j]){\\n                    st.pop();\\n                    \\n                }\\n            if(st.size()==0){\\n                arr[i++]=0;\\n            }\\n            else{\\n                arr[i++]=st.peek()[1]-j;\\n            }\\n            } \\n        st.push(new int[]{temperatures[j],j}); \\n        j--;\\n        }\\n        \\n      \\n        int[] ans = new int[temperatures.length]; int k=0;\\n        for(i=arr.length-1; i>=0; i--){\\n            ans[k++]=arr[i];\\n        }\\n        return ans;\\n    }\\n}",
        "level": "medium",
        "type": [
            "wrong comment mark",
            "indexing error",
            "undefined objects",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution {\n    public int[] dailyTemperatures(int[] temperatures) {\n        \n        let[] arr = new let[temperatures.length + 1]; \n        \n        ArrayDeque<int[]> st = new ArrayDeque<>(); \n        \n        int i=0, j=temperatures.length-1 ; \n        \n        while( j >= 0){\n            \n            /*if(st.size()==0){\n                arr[i++] = 0;\n            }\n            else if (st.size()>0 && st.peek()[0]>temperatures[j])\n            {\n                arr[i++]=1;\n            } \n            else if (st.size()>0 && st.peek()[0]<=temperatures[j])\n            \n            {  while(st.size()>0 && st.peek()[0]<=temperatures[j]){\n                    st.pop();\n                    \n                }\n            if(st.size()==0){\n                arr[i++]=0;\n            }\n            else{\n                arr[i++]=st.peek()[1]-j;\n            }\n            } */\n        st.push(new int[]{temperatures[j],j}); \n        j--;\n        }\n        \n      \n        let[] ans = lear + 1r; \n        return ans;\n    }\n}\n\n"
    },
    {
        "slug": "convert-the-temperature",
        "description": "You are given a non-negative floating point number rounded to two decimal places celsius, that denotes the temperature in Celsius.\nYou should convert Celsius into Kelvin and Fahrenheit and return it as an array ans = [kelvin, fahrenheit].\nReturn the array ans. Answers within 10-5 of the actual answer will be accepted.\nNote that:\n\nKelvin = Celsius + 273.15\nFahrenheit = Celsius * 1.80 + 32.00",
        "examples": [
            "Input: celsius = 36.50\nOutput: [309.65000,97.70000]\nExplanation: Temperature at 36.50 Celsius converted in Kelvin is 309.65 and converted in Fahrenheit is 97.70.",
            "Input: celsius = 122.11\nOutput: [395.26000,251.79800]\nExplanation: Temperature at 122.11 Celsius converted in Kelvin is 395.26 and converted in Fahrenheit is 251.798."
        ],
        "constraints": "0 <= celsius <= 1000",
        "oracle_code": "class Solution {\n    public double[] convertTemperature(double celsius) {\n        double arr[] = new double[2];\n        arr[1] = (celsius * 9.0/5.0) + 32.0;\n        arr[0] = celsius + 273.15;\n        return arr;\n    }\n}",
        "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe program takes a celsius value and converts it to fahrenheit and kelvin.\\n# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public double[] convertTemperature(double celsius) {\\n        double arr[] = new double[2];\\n        arr[1] = (celsius * 9.0/5.0) + 32.0;\\n        arr[0] = celsius + 273.15;\\n        return arr;\\n    }\\n}\\n```",
        "level": "easy",
        "type": [
            "parentheses mismatch",
            "indexing error",
            "undefined objects",
            "statement separation"
        ],
        "buggy_code": "\n```java\nclass Solution {\n    public double[] convertTemperature(double celsius) {\n        double arr[] = new double[2];\n        UndefinedObject obj;  \n        arr[2 = (obj.celsius * 9.0/5.0) + 32.0\n        arr[0] = obj.celsius + 273.15;\n        return arr;\n    }\n}\n```\n"
    },
    {
        "slug": "number-of-laser-beams-in-a-bank",
        "description": "Anti-theft security devices are activated inside a bank. You are given a 0-indexed binary string array bank representing the floor plan of the bank, which is an m x n 2D matrix. bank[i] represents the ith row, consisting of '0's and '1's. '0' means the cell is empty, while'1' means the cell has a security device.\nThere is one laser beam between any two security devices if both conditions are met:\n\nThe two devices are located on two different rows: r1 and r2, where r1 < r2.\nFor each row i where r1 < i < r2, there are no security devices in the ith row.\n\nLaser beams are independent, i.e., one beam does not interfere nor join with another.\nReturn the total number of laser beams in the bank.",
        "examples": [
            "Input: bank = [\"011001\",\"000000\",\"010100\",\"001000\"]\nOutput: 8\nExplanation: Between each of the following device pairs, there is one beam. In total, there are 8 beams:\n * bank[0][1] -- bank[2][1]\n * bank[0][1] -- bank[2][3]\n * bank[0][2] -- bank[2][1]\n * bank[0][2] -- bank[2][3]\n * bank[0][5] -- bank[2][1]\n * bank[0][5] -- bank[2][3]\n * bank[2][1] -- bank[3][2]\n * bank[2][3] -- bank[3][2]\nNote that there is no beam between any device on the 0th row with any on the 3rd row.\nThis is because the 2nd row contains security devices, which breaks the second condition.",
            "Input: bank = [\"000\",\"111\",\"000\"]\nOutput: 0\nExplanation: There does not exist two devices located on two different rows."
        ],
        "constraints": "m == bank.length\nn == bank[i].length\n1 <= m, n <= 500\nbank[i][j] is either '0' or '1'.",
        "oracle_code": "class Solution {\n    public int numberOfBeams(String[] bank) {\n        int prevLazer =0;\n        int ans =0;\n        for(String s:bank){\n            int curLazer = 0;\n            for(char c: s.toCharArray()){\n                if(c=='1'){\n                    curLazer++;\n                }\n            }\n            if(curLazer >0){\n                ans += (curLazer * prevLazer);\n                prevLazer = curLazer;\n            }\n        }\n        return ans;\n    }\n}",
        "content": "\\n# java Code\\n```\\nclass Solution {\\n    public int numberOfBeams(String[] bank) {\\n        int prevLazer =0;\\n        int ans =0;\\n        for(String s:bank){\\n            int curLazer = 0;\\n            for(char c: s.toCharArray()){\\n                if(c==\\'1\\'){\\n                    curLazer++;\\n                }\\n            }\\n            if(curLazer >0){\\n                ans += (curLazer * prevLazer);\\n                prevLazer = curLazer;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
        "level": "medium",
        "type": [
            "== and = confusion",
            "parentheses mismatch",
            "undefined keywords from other languages",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution {\n    public int numberOfBeams(String[] bank) {\n        int prevLazer =0;\n        int ans =0;\n        for(String s:bank){\n            int curLazer = 0;\n            for(char c: s.toCharArray()){\n                if(c=='1){\n                    curLazer++;\n                }\n            if(curLazer = 0){\n                ans += (curLazer * prevLazer);\n                prevLazer = curLazer;\n            }\n        }\n        return ans;\n    }\npit()    return ans;\n    \n}\n\"The total number of beams is: \" + \n"
    },
    {
        "slug": "daily-temperatures",
        "description": "Given an array of integers temperatures represents the daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after the ith day to get a warmer temperature. If there is no future day for which this is possible, keep answer[i] == 0 instead.",
        "examples": [
            "Input: temperatures = [73,74,75,71,69,72,76,73]\nOutput: [1,1,4,2,1,1,0,0]",
            "Input: temperatures = [30,40,50,60]\nOutput: [1,1,1,0]",
            "Input: temperatures = [30,60,90]\nOutput: [1,1,0]"
        ],
        "constraints": "1 <=\u00a0temperatures.length <= 105\n30 <=\u00a0temperatures[i] <= 100",
        "oracle_code": "class Solution {\n    public int[] dailyTemperatures(int[] temperatures) {\n        \n        int[] arr = new int[temperatures.length]; \n        \n        ArrayDeque<int[]> st = new ArrayDeque<>(); \n        \n        int i=0, j=temperatures.length-1 ; \n        \n        while( j >= 0){\n            \n            if(st.size()==0){\n                arr[i++] = 0;\n            }\n            else  if (st.size()>0 && st.peek()[0]>temperatures[j])\n            {\n                arr[i++]=1;\n            } \n            else if (st.size()>0 && st.peek()[0]<=temperatures[j])\n            \n            {  while(st.size()>0 && st.peek()[0]<=temperatures[j]){\n                    st.pop();\n                    \n                }\n            if(st.size()==0){\n                arr[i++]=0;\n            }\n            else{\n                arr[i++]=st.peek()[1]-j;\n            }\n            } \n        st.push(new int[]{temperatures[j],j}); \n        j--;\n        }\n        \n      \n        int[] ans = new int[temperatures.length]; int k=0;\n        for(i=arr.length-1; i>=0; i--){\n            ans[k++]=arr[i];\n        }\n        return ans;\n    }\n}",
        "content": "```\\nclass Solution {\\n    public int[] dailyTemperatures(int[] temperatures) {\\n        \\n        int[] arr = new int[temperatures.length]; \\n        \\n        ArrayDeque<int[]> st = new ArrayDeque<>(); \\n        \\n        int i=0, j=temperatures.length-1 ; \\n        \\n        while( j >= 0){\\n            \\n            if(st.size()==0){\\n                arr[i++] = 0;\\n            }\\n            else  if (st.size()>0 && st.peek()[0]>temperatures[j])\\n            {\\n                arr[i++]=1;\\n            } \\n            else if (st.size()>0 && st.peek()[0]<=temperatures[j])\\n            \\n            {  while(st.size()>0 && st.peek()[0]<=temperatures[j]){\\n                    st.pop();\\n                    \\n                }\\n            if(st.size()==0){\\n                arr[i++]=0;\\n            }\\n            else{\\n                arr[i++]=st.peek()[1]-j;\\n            }\\n            } \\n        st.push(new int[]{temperatures[j],j}); \\n        j--;\\n        }\\n        \\n      \\n        int[] ans = new int[temperatures.length]; int k=0;\\n        for(i=arr.length-1; i>=0; i--){\\n            ans[k++]=arr[i];\\n        }\\n        return ans;\\n    }\\n}",
        "level": "medium",
        "type": [
            "wrong comment mark",
            "indexing error",
            "undefined objects",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\n    public int[] dailyTemperatures(int[] temperatures) {\n        \n        int[] arr = new int[temperatures.length + 1]; \n        \n        ArrayDeque<int[]> st = new ArrayDeque<>(); \n        \n        int i=0, j=temperatures.length-1 ; \n        \n        while( j >= 0){\n            \n            /*if(st.size()==0){\n                arr[i++] = 0;\n            }\n            else  if (st.size()>0 && st.peek()[0]>temperatures[j])\n            {\n                arr[i++]=1;\n            } \n            else if (st.size()>0 && st.peek()[0]<=temperatures[j])\n            \n            {  while(st.size()>0 && st.peek()[0]<=temperatures[j]){\n                    st.pop();\n                    \n                }\n            if(st.size()==0){\n                arr[i++]=0;\n            }\n            else{\n                arr[i++]=st.peek()[1]-j;\n            }\n            } */\n\n        doSomething();\n\n        st.push(new int[]{temperatures[j],j}); \n        j--;\n        }\n        \n      \n        int[] ans = ar + 1r; \n        return ans;\n    }\n}\n\n"
    },
    {
        "slug": "relative-ranks",
        "description": "You are given an integer array score of size n, where score[i] is the score of the ith athlete in a competition. All the scores are guaranteed to be unique.\nThe athletes are placed based on their scores, where the 1st place athlete has the highest score, the 2nd place athlete has the 2nd highest score, and so on. The placement of each athlete determines their rank:\n\nThe 1st place athlete's rank is \"Gold Medal\".\nThe 2nd place athlete's rank is \"Silver Medal\".\nThe 3rd place athlete's rank is \"Bronze Medal\".\nFor the 4th place to the nth place athlete, their rank is their placement number (i.e., the xth place athlete's rank is \"x\").\n\nReturn an array answer of size n where answer[i] is the rank of the ith athlete.",
        "examples": [
            "Input: score = [5,4,3,2,1]\nOutput: [\"Gold Medal\",\"Silver Medal\",\"Bronze Medal\",\"4\",\"5\"]\nExplanation: The placements are [1st, 2nd, 3rd, 4th, 5th].",
            "Input: score = [10,3,8,9,4]\nOutput: [\"Gold Medal\",\"5\",\"Bronze Medal\",\"Silver Medal\",\"4\"]\nExplanation: The placements are [1st, 5th, 3rd, 2nd, 4th]."
        ],
        "constraints": "n == score.length\n1 <= n <= 104\n0 <= score[i] <= 106\nAll the values in score are unique.",
        "oracle_code": "class Solution {\n    public String[] findRelativeRanks(int[] score) {\n         int n=score.length;\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[b]-score[a]);\n        for(int i=0;i<n;i++) pq.add(i);\n      String[] ans = new String[n];\n                int i=1;\n        while(!pq.isEmpty()){\n            int idx=pq.poll();\n         if(i==1)   { ans[idx]=\"Gold Medal\"; i++;}\n         else if(i==2)   { ans[idx]=\"Silver Medal\"; i++;}\n         else if(i==3)   { ans[idx]=\"Bronze Medal\"; i++;}\n         else ans[idx]=Integer.toString(i++);\n        }\n        return ans;  \n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String[] findRelativeRanks(int[] score) {\\n         int n=score.length;\\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[b]-score[a]);\\n        for(int i=0;i<n;i++) pq.add(i);\\n      String[] ans = new String[n];\\n                int i=1;\\n        while(!pq.isEmpty()){\\n            int idx=pq.poll();\\n         if(i==1)   { ans[idx]=\"Gold Medal\"; i++;}\\n         else if(i==2)   { ans[idx]=\"Silver Medal\"; i++;}\\n         else if(i==3)   { ans[idx]=\"Bronze Medal\"; i++;}\\n         else ans[idx]=Integer.toString(i++);\\n        }\\n        return ans;  \\n    }\\n}\\n```",
        "level": "easy",
        "type": [
            "operation error",
            "undefined objects",
            "undefined keywords from other languages",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\n    public String[] findRelativeRanks(int[] score) {\n         int n = score.length;\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[a]-score[b]);\n        for(int i=0;i<n;i++) pq.add(i);\n        String[] ans = null;\n                int i=1;\n        while(!pq.isEmpty()){\n            int idx=pq.poll();\n         if(i==1)   { ans[idx]=\"Gold Medal\"; i++;}\n         elif(i==2)   { ans[idx]=\"Silver Medal\"; i++;}\n         else if(i==3)   { ans[idx]=\"Bronze Medal\"; i++;}\n         else ans[idx]=Integer.toString(i++);\n        }\n        return reorderArray(ans);  \n    }\n\n    private String[] reorderArray(String[] ranks){\n        \n    }\n}\n"
    },
    {
        "slug": "erect-the-fence",
        "description": "You are given an array trees where trees[i] = [xi, yi] represents the location of a tree in the garden.\nFence the entire garden using the minimum length of rope, as it is expensive. The garden is well-fenced only if all the trees are enclosed.\nReturn the coordinates of trees that are exactly located on the fence perimeter. You may return the answer in any order.",
        "examples": [
            "Input: trees = [[1,1],[2,2],[2,0],[2,4],[3,3],[4,2]]\nOutput: [[1,1],[2,0],[4,2],[3,3],[2,4]]\nExplanation: All the trees will be on the perimeter of the fence except the tree at [2, 2], which will be inside the fence.",
            "Input: trees = [[1,2],[2,2],[4,2]]\nOutput: [[4,2],[2,2],[1,2]]\nExplanation: The fence forms a line that passes through all the trees."
        ],
        "constraints": "1 <= trees.length <= 3000\ntrees[i].length == 2\n0 <= xi, yi <= 100\nAll the given positions are unique.",
        "oracle_code": "class Solution {\n    \n    public int[][] outerTrees(int[][] trees) {\n        if(trees.length == 3){\n            return trees;\n        }\n        Stack<int[]> upper = new Stack<>();\n        Stack<int[]> lower = new Stack<>();\n        \n        Arrays.sort(trees,(p,q) ->\n                  q[0]-p[0]==0?q[1]-p[1]:q[0]-p[0]);\n        \n        for(int i = 0 ; i < trees.length ; i++){\n            int size = trees.length;\n            while(upper.size() >= 2 && angle(upper.get(upper.size() - 2),upper.get(upper.size() - 1),trees[i]) > 0){\n                upper.pop();  \n                }\n            while(lower.size() >= 2 && angle(lower.get(lower.size() - 2),lower.get(lower.size() - 1),trees[i]) < 0){\n                 lower.pop();  \n              }\n            upper.push(trees[i]);\n            lower.push(trees[i]);\n        }\n        \n        \n        Set<int[]> res= new HashSet<>(lower);\n        res.addAll(upper);\n        return res.toArray(new int[res.size()][]);\n    }\n    \n    public int angle(int[] A , int[] B , int[] C){\n        return (C[0] - A[0]) * (B[1] - A[1]) - (B[0] - A[0]) * (C[1] - A[1]);\n    }\n}",
        "content": "```\\nclass Solution {\\n    \\n    public int[][] outerTrees(int[][] trees) {\\n        if(trees.length == 3){\\n            return trees;\\n        }\\n        Stack<int[]> upper = new Stack<>();\\n        Stack<int[]> lower = new Stack<>();\\n        \\n        Arrays.sort(trees,(p,q) ->\\n                  q[0]-p[0]==0?q[1]-p[1]:q[0]-p[0]);\\n        \\n        for(int i = 0 ; i < trees.length ; i++){\\n            int size = trees.length;\\n            while(upper.size() >= 2 && angle(upper.get(upper.size() - 2),upper.get(upper.size() - 1),trees[i]) > 0){\\n                upper.pop();  \\n                }\\n            while(lower.size() >= 2 && angle(lower.get(lower.size() - 2),lower.get(lower.size() - 1),trees[i]) < 0){\\n                 lower.pop();  \\n              }\\n            upper.push(trees[i]);\\n            lower.push(trees[i]);\\n        }\\n        \\n        \\n        Set<int[]> res= new HashSet<>(lower);\\n        res.addAll(upper);\\n        return res.toArray(new int[res.size()][]);\\n    }\\n    \\n    public int angle(int[] A , int[] B , int[] C){\\n        return (C[0] - A[0]) * (B[1] - A[1]) - (B[0] - A[0]) * (C[1] - A[1]);\\n    }\\n}\\n```\\n\\n**Upvote Please**",
        "level": "hard",
        "type": [
            "== and = confusion",
            "conditional statement error",
            "undefined objects",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution {\n    \n    var trees = [];\n    public int[][] outerTrees(int[][] trees) {\n        if(trees.length = 3){\n            return trees;\n        }\n        Stack<int[]> upper = new Stack<>();\n        Stack<int[]> lower = null;\n        \n        Arrays.sort(trees,(p,q) ->q[0]-p[0]==0?q[1]-p[1]:q[0]-p[0]);\n        \n        for(int i = 0 ; i < trees.length ; i++){\n            while(upper.size() >= 2 && angle(upper.get(upper.size() - 2),upper.get(upper.size() - 1),trees[i]) > 0){\n                upper.pop();  \n                }\n            while(lower.size() >= 2 && angle(lower.get(lower.size() - 2),lower.get(lower.size() - 1),trees[i]) > 0){\n                 lower.pop();  \n              }\n            upper.push(trees[i]);\n            lower.push(trees[i]);\n        }\n        \n        \n        Set<int[]> res= new HashSet<>(lower);\n        res.addAll(upper);\n        return res.toArray(new int[res.size()][]);\n    }\n    \n    public int angle(int[] A , int[] B , int[] C){\n        return (C[0] - A[0]) * (B[1] - A[1]) - (B[0] - A[0]) * (C[1] - A[1]);\n    }\n}\n"
    },
    {
        "slug": "convert-the-temperature",
        "description": "You are given a non-negative floating point number rounded to two decimal places celsius, that denotes the temperature in Celsius.\nYou should convert Celsius into Kelvin and Fahrenheit and return it as an array ans = [kelvin, fahrenheit].\nReturn the array ans. Answers within 10-5 of the actual answer will be accepted.\nNote that:\n\nKelvin = Celsius + 273.15\nFahrenheit = Celsius * 1.80 + 32.00",
        "examples": [
            "Input: celsius = 36.50\nOutput: [309.65000,97.70000]\nExplanation: Temperature at 36.50 Celsius converted in Kelvin is 309.65 and converted in Fahrenheit is 97.70.",
            "Input: celsius = 122.11\nOutput: [395.26000,251.79800]\nExplanation: Temperature at 122.11 Celsius converted in Kelvin is 395.26 and converted in Fahrenheit is 251.798."
        ],
        "constraints": "0 <= celsius <= 1000",
        "oracle_code": "class Solution {\n    public double[] convertTemperature(double celsius) {\n        double arr[] = new double[2];\n        arr[1] = (celsius * 9.0/5.0) + 32.0;\n        arr[0] = celsius + 273.15;\n        return arr;\n    }\n}",
        "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe program takes a celsius value and converts it to fahrenheit and kelvin.\\n# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public double[] convertTemperature(double celsius) {\\n        double arr[] = new double[2];\\n        arr[1] = (celsius * 9.0/5.0) + 32.0;\\n        arr[0] = celsius + 273.15;\\n        return arr;\\n    }\\n}\\n```",
        "level": "easy",
        "type": [
            "operation error",
            "parentheses mismatch",
            "undefined objects",
            "statement separation"
        ],
        "buggy_code": "\n```java\nclass Solution {\n    public double[] convertTemperature(double celsius) {\n        double arr[] = new double[2];\n        UndefinedObject obj;  \n        arr[1 = (obj.celsius * 9.0/5.0) + 32.0\n        arr[0] = obj.celsius + 237.15;\n        return arr;\n    }\n}\n```\n"
    },
    {
        "slug": "minimum-number-of-swaps-to-make-the-string-balanced",
        "description": "You are given a 0-indexed string s of even length n. The string consists of exactly n / 2 opening brackets '[' and n / 2 closing brackets ']'.\nA string is called balanced if and only if:\n\nIt is the empty string, or\nIt can be written as AB, where both A and B are balanced strings, or\nIt can be written as [C], where C is a balanced string.\n\nYou may swap the brackets at any two indices any number of times.\nReturn the minimum number of swaps to make s balanced.",
        "examples": [
            "Input: s = \"][][\"\nOutput: 1\nExplanation: You can make the string balanced by swapping index 0 with index 3.\nThe resulting string is \"[[]]\".",
            "Input: s = \"]]][[[\"\nOutput: 2\nExplanation: You can do the following to make the string balanced:\n- Swap index 0 with index 4. s = \"[]][][\".\n- Swap index 1 with index 5. s = \"[[][]]\".\nThe resulting string is \"[[][]]\".",
            "Input: s = \"[]\"\nOutput: 0\nExplanation: The string is already balanced."
        ],
        "constraints": "n == s.length\n2 <= n <= 106\nn is even.\ns[i] is either '[' or ']'.\nThe number of opening brackets '[' equals n / 2, and the number of closing brackets ']' equals n / 2.",
        "oracle_code": "class Solution {\n    public int minSwaps(String s) {\n        return util1(s);\n    }\n    public int util1(String str) {\n        Stack<Character> s = new Stack<>();\n        for (int i = 0; i < str.length(); i++) {\n            if (str.charAt(i) == '[') {\n                s.push(str.charAt(i));\n            } else {\n                if (s.isEmpty() == false && s.peek() == '[') {\n                    s.pop();\n                } else {\n                    s.push(str.charAt(i));\n                }\n            }\n        }\n        double pairs = s.size() / 2;\n        double a = pairs / 2.0;\n        int ans = (int) Math.ceil(a);\n        return ans;\n    }\n}",
        "content": "the trick behind is fairly easy\\n\\nfor the number of pairs which are not correct, the amount of swaps required to make them correct is Math.ceil(a), where a is the number of pairs which are not correct.\\n\\nfor eg\\nfor 5 incorrect pairs, we need 3 swaps\\nfor 3 incorrect pairs, we need 2 swaps\\nfor 2 incorrect pairs, we need 1 swap\\n\\nso simply, \\nwe need to firstly write code to remove all the valid pairs, that ways only the pairs which are incorrect will be in the stack\\nthen we simply do the calculations.\\n\\nrest the code should be self explanatory.\\n\\n# Code\\n```\\nclass Solution {\\n    public int minSwaps(String s) {\\n        return util1(s);\\n    }\\n    public int util1(String str) {\\n        Stack<Character> s = new Stack<>();\\n        for (int i = 0; i < str.length(); i++) {\\n            if (str.charAt(i) == \\'[\\') {\\n                s.push(str.charAt(i));\\n            } else {\\n                if (s.isEmpty() == false && s.peek() == \\'[\\') {\\n                    s.pop();\\n                } else {\\n                    s.push(str.charAt(i));\\n                }\\n            }\\n        }\\n        double pairs = s.size() / 2;\\n        double a = pairs / 2.0;\\n        int ans = (int) Math.ceil(a);\\n        return ans;\\n    }\\n}\\n```\\nyou can check out my github repository where i am uploading famous interview questions topic wise with solutions.\\nlink-- https://github.com/Abhaydutt2003/DataStructureAndAlgoPractice \\nkindly upvote if you like my solution. you can ask doubts below.\\n    \\n",
        "level": "medium",
        "type": [
            "operation error",
            "parentheses mismatch",
            "indexing error",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\n    public int minSwaps(String s) {\n        return util(s;\n    }\n    public int util1(String str) {\n        Stack<Character> s = new Stack<>();\n        for (int i = 0; i <= str.length(); i++) {\n            if (str.charAt(i) == '[') {\n                s.push(str.charAt(i));\n            } else {\n                if (s.isEmpty() == false && s.peek() == '[') {\n                    s.pop();\n                } else {\n                    s.push(str.charAt(i));\n                }\n            }\n        }\n        double pairs = s.size() / 2;\n        double a = pairs / 10.0;\n        int ans = (int) Math.ceil(a);\n        return ans;\n    }\n}\n"
    },
    {
        "slug": "domino-and-tromino-tiling",
        "description": "You have two types of tiles: a 2 x 1 domino shape and a tromino shape. You may rotate these shapes.\n\nGiven an integer n, return the number of ways to tile an 2 x n board. Since the answer may be very large, return it modulo 109 + 7.\nIn a tiling, every square must be covered by a tile. Two tilings are different if and only if there are two 4-directionally adjacent cells on the board such that exactly one of the tilings has both squares occupied by a tile.",
        "examples": [
            "Input: n = 3\nOutput: 5\nExplanation: The five different ways are show above.",
            "Input: n = 1\nOutput: 1"
        ],
        "constraints": "1 <= n <= 1000",
        "oracle_code": "class Solution {\n    private long[] dp;\n    int MOD = (int)Math.pow(10 , 9) + 7;\n    public long solve(int n){\n        if(n==0) return 1;\n        if(n<3) return n;\n\n        if(dp[n]!=-1) return dp[n];\n\n        return dp[n] = 2*solve(n-1)%MOD+solve(n-3)%MOD;\n    }\n    public int numTilings(int n) {\n        this.dp = new long[n+1];\n        Arrays.fill(dp , -1);\n\n        return (int)solve(n)%MOD;\n    }\n}",
        "content": "# Intuition\\n- The basic approach to solve this problem was by using brute force recursion.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- Then after realising the over-lapping sub problems in it the whole problem was solved using the memoization technique of Dynamic Programming\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(N*N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N)$$ + recursive stack space\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private long[] dp;\\n    int MOD = (int)Math.pow(10 , 9) + 7;\\n    public long solve(int n){\\n        if(n==0) return 1;\\n        if(n<3) return n;\\n\\n        if(dp[n]!=-1) return dp[n];\\n\\n        return dp[n] = 2*solve(n-1)%MOD+solve(n-3)%MOD;\\n    }\\n    public int numTilings(int n) {\\n        this.dp = new long[n+1];\\n        Arrays.fill(dp , -1);\\n\\n        return (int)solve(n)%MOD;\\n    }\\n}\\n```",
        "level": "medium",
        "type": [
            "operation error",
            "== and = confusion",
            "indexing error",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution {\n    private long[] dp;\n    int MOD = (int)Math.pow(10 , 9) + 7;\n    public long solve(int n){\n        if(n==0) return 1;\n        if(n<3) return n;\n\n        if(dp[n+2] = null) return dp[n];\n\n        return dp[n] == 2*solve(n-1)%MOD+solve(n-2)%MOD;\n    }\n    public int numTilings(int n) {\n        this.dp = new long[n+1];\n        Arrays.fill(dp , -1);\n\n        return (int)solve(n)%MOD;\n    }\n}\n"
    },
    {
        "slug": "count-negative-numbers-in-a-sorted-matrix",
        "description": "Given a m x n matrix grid which is sorted in non-increasing order both row-wise and column-wise, return the number of negative numbers in grid.",
        "examples": [
            "Input: grid = [[4,3,2,-1],[3,2,1,-1],[1,1,-1,-2],[-1,-1,-2,-3]]\nOutput: 8\nExplanation: There are 8 negatives number in the matrix.",
            "Input: grid = [[3,2],[1,0]]\nOutput: 0"
        ],
        "constraints": "m == grid.length\nn == grid[i].length\n1 <= m, n <= 100\n-100 <= grid[i][j] <= 100",
        "oracle_code": "class Solution:\n    def countNegatives(self, grid: List[List[int]]) -> int:\n        ROWS, COLS = len(grid), len(grid[0])\n        negatives = 0\n        col = 0\n        for row in range(ROWS - 1, -1, -1):\n            while col < COLS and grid[row][col] >= 0:\n                col += 1\n            negatives += COLS - col\n        return negatives",
        "content": "# Intuition\\nThe key idea is to take advantage of the sorted nature of the matrix, where both the rows and columns are sorted in non-increasing order. This means that once we find a negative number in a row, all the following numbers in that row will also be negative. Similarly, if a cell at the top of a column is negative, all the cells below it in that column will also be negative.\\n\\n# Approach\\nNegative numbers will form a staircase. So we start from the bottom-left, and follow along the staircase. For each row, we find the edge of the staircase, add all the count of elements to the right to the answer, and then move up a row and repeat.\\n\\n# Complexity\\n- Time complexity: O(m + n) - We visit each row and column at most once.\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def countNegatives(self, grid: List[List[int]]) -> int:\\n        ROWS, COLS = len(grid), len(grid[0])\\n        negatives = 0\\n        col = 0\\n        for row in range(ROWS - 1, -1, -1):\\n            while col < COLS and grid[row][col] >= 0:\\n                col += 1\\n            negatives += COLS - col\\n        return negatives\\n\\n```\\n\\n# Get Faster Interview Prep Results with Top Algos\\nWe all know how time-consuming it is to prepare for interviews and how frustratingly difficult it is to improve. We made **Top Algos** - a tool recommends the perfect algorithm problem based on your current skill level to help you improve the fastest in the shortest amount of time. Top Algos is your personalized coach that learns your skill level and finds the best problem you need to solve to improve.\\n\\nThe beta version of the product is available for **free** right now! You can sign up at https://topalgos.xyz/.",
        "level": "easy",
        "type": [
            "colon missing",
            "indexing error",
            "undefined objects",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution:\n    def countNegatives(self, grid: List[List[int]]) -> int:\n        ROWS, COLS = len(grid), len(undefinedGridVar[0])\n        negatives = 0\n        for row in range(ROWS - 1, -1, -1):\n            col = 0\n            while col <= COLS and grid[row][col] >= 0:\n                col += 1\n            negatives += COLS - col\n        return negatives\n\n    def undefinedMethod(self):\n        self.countPositives(grid)\n"
    },
    {
        "slug": "largest-number-after-digit-swaps-by-parity",
        "description": "You are given a positive integer num. You may swap any two digits of num that have the same parity (i.e. both odd digits or both even digits).\nReturn the largest possible value of num after any number of swaps.",
        "examples": [
            "Input: num = 1234\nOutput: 3412\nExplanation: Swap the digit 3 with the digit 1, this results in the number 3214.\nSwap the digit 2 with the digit 4, this results in the number 3412.\nNote that there may be other sequences of swaps but it can be shown that 3412 is the largest possible number.\nAlso note that we may not swap the digit 4 with the digit 1 since they are of different parities.",
            "Input: num = 65875\nOutput: 87655\nExplanation: Swap the digit 8 with the digit 6, this results in the number 85675.\nSwap the first digit 5 with the digit 7, this results in the number 87655.\nNote that there may be other sequences of swaps but it can be shown that 87655 is the largest possible number."
        ],
        "constraints": "1 <= num <= 109",
        "oracle_code": "class Solution {\n    public int largestInteger(int num) {\n        String numString = \"\"+ num;\n        List<Integer> even = new ArrayList<>();\n        List<Integer> odd = new ArrayList<>();\n        for(Character c : numString.toCharArray()){\n            int n = Character.getNumericValue(c);\n            if(n%2==0){\n                even.add(n);\n            }else{\n                odd.add(n);\n            }\n        }\n        Collections.sort(even, Collections.reverseOrder());\n        Collections.sort(odd, Collections.reverseOrder());\n        String res =\"\";\n        int one=0, two=0;\n        for(int i=0; i<numString.length(); i++){\n            int n = Character.getNumericValue(numString.charAt(i));\n            if(n%2==0){\n                res += even.get(one);\n                one++;\n            }else{\n                res += odd.get(two);\n                two++;\n            }\n        }\n        return Integer.parseInt(res);\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nused string and list to store the even and odd elements\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nconverted num in string then added all values from string to even and odd list as per its type;\\nthen sorted both string in desc order\\nas we check from the original string if got even number we will put max even number from even list and incresed even list pointer same for the odd number\\n\\nConverted result string to integer to get int res and returned it\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int largestInteger(int num) {\\n        String numString = \"\"+ num;\\n        List<Integer> even = new ArrayList<>();\\n        List<Integer> odd = new ArrayList<>();\\n        for(Character c : numString.toCharArray()){\\n            int n = Character.getNumericValue(c);\\n            if(n%2==0){\\n                even.add(n);\\n            }else{\\n                odd.add(n);\\n            }\\n        }\\n        Collections.sort(even, Collections.reverseOrder());\\n        Collections.sort(odd, Collections.reverseOrder());\\n        String res =\"\";\\n        int one=0, two=0;\\n        for(int i=0; i<numString.length(); i++){\\n            int n = Character.getNumericValue(numString.charAt(i));\\n            if(n%2==0){\\n                res += even.get(one);\\n                one++;\\n            }else{\\n                res += odd.get(two);\\n                two++;\\n            }\\n        }\\n        return Integer.parseInt(res);\\n    }\\n}\\n```",
        "level": "easy",
        "type": [
            "colon missing",
            "conditional statement error",
            "wrong comment mark",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution {\n    public int largestInteger(int num) {\n        String numString = \"\"+ num;\n        /*List<Integer> even = new ArrayList<>();*/\n        List<Integer> odd = new ArrayList<>();\n        for(Character c : numString.toCharArray())\n            int n = Character.getNumericValue(c);\n            if(n%2==0){\n                even.add(n);\n            }else{\n                odd.add(n);\n            }\n        }\n        Collections.sort(even, Collections.reverseOrder());\n        Collections.sort(odd, Collections.reverseOrder());\n        String res =\"\";\n\n        \n        for(int i=0; i<numString.length()+5; i++){\n            int n = Character.getNumericValue(numString.charAt(i));\n            if(n%2==0){\n                res += even.get(one);\n                one++;\n            }else{\n                res += odd.get(two);\n                two++;\n            }\n        }\n        return Integer.parse_int(res);\n    }\n}\n"
    },
    {
        "slug": "design-graph-with-shortest-path-calculator",
        "description": "There is a directed weighted graph that consists of n nodes numbered from 0 to n - 1. The edges of the graph are initially represented by the given array edges where edges[i] = [fromi, toi, edgeCosti] meaning that there is an edge from fromi to toi with the cost edgeCosti.\nImplement the Graph class:\n\nGraph(int n, int[][] edges) initializes the object with n nodes and the given edges.\naddEdge(int[] edge) adds an edge to the list of edges where edge = [from, to, edgeCost]. It is guaranteed that there is no edge between the two nodes before adding this one.\nint shortestPath(int node1, int node2) returns the minimum cost of a path from node1 to node2. If no path exists, return -1. The cost of a path is the sum of the costs of the edges in the path.",
        "examples": [
            "Input\n[\"Graph\", \"shortestPath\", \"shortestPath\", \"addEdge\", \"shortestPath\"]\n[[4, [[0, 2, 5], [0, 1, 2], [1, 2, 1], [3, 0, 3]]], [3, 2], [0, 3], [[1, 3, 4]], [0, 3]]\nOutput\n[null, 6, -1, null, 6]\n\nExplanation\nGraph g = new Graph(4, [[0, 2, 5], [0, 1, 2], [1, 2, 1], [3, 0, 3]]);\ng.shortestPath(3, 2); // return 6. The shortest path from 3 to 2 in the first diagram above is 3 -> 0 -> 1 -> 2 with a total cost of 3 + 2 + 1 = 6.\ng.shortestPath(0, 3); // return -1. There is no path from 0 to 3.\ng.addEdge([1, 3, 4]); // We add an edge from node 1 to node 3, and we get the second diagram above.\ng.shortestPath(0, 3); // return 6. The shortest path from 0 to 3 now is 0 -> 1 -> 3 with a total cost of 2 + 4 = 6."
        ],
        "constraints": "1 <= n <= 100\n0 <= edges.length <= n * (n - 1)\nedges[i].length == edge.length == 3\n0 <= fromi, toi, from, to, node1, node2 <= n - 1\n1 <= edgeCosti, edgeCost <= 106\nThere are no repeated edges and no self-loops in the graph at any point.\nAt most 100 calls will be made for addEdge.\nAt most 100 calls will be made for shortestPath.",
        "oracle_code": "class Graph {\n    List<List<int[]>> adj=new ArrayList<>();\n    int n;\n    public Graph(int n, int[][] edges) {\n        for(int i=0;i<n;i++){\n            adj.add(new ArrayList<>());\n        }\n        this.n=n;\n        for(int edge[]: edges){\n            adj.get(edge[0]).add(new int[]{edge[1],edge[2]});\n        }\n    }\n    \n    public void addEdge(int[] edge) {\n        adj.get(edge[0]).add(new int[]{edge[1],edge[2]});\n    }\n    \n    public int shortestPath(int node1, int node2) {\n        int dist[]=new int[n+1];\n        Arrays.fill(dist,Integer.MAX_VALUE);\n        dist[node1]=0;\n        PriorityQueue<int[]> pq=new PriorityQueue<>((a,b)->a[1]-b[1]);\n        pq.add(new int[]{node1,0});\n        while(!pq.isEmpty()){\n            int u=pq.poll()[0];\n            for(int p[]: adj.get(u)){\n                int v=p[0];\n                int w=p[1];\n                if(dist[v]>dist[u]+w){\n                    dist[v]=dist[u]+w;\n                    pq.add(new int[]{v,dist[v]});\n                }\n            }\n        }\n        if(dist[node2]==Integer.MAX_VALUE){\n                return -1;\n        }\n        return dist[node2];\n    }\n    \n}\n\n/**\n * Your Graph object will be instantiated and called as such:\n * Graph obj = new Graph(n, edges);\n * obj.addEdge(edge);\n * int param_2 = obj.shortestPath(node1,node2);\n */",
        "content": "\\n\\n# Code\\n```\\nclass Graph {\\n    List<List<int[]>> adj=new ArrayList<>();\\n    int n;\\n    public Graph(int n, int[][] edges) {\\n        for(int i=0;i<n;i++){\\n            adj.add(new ArrayList<>());\\n        }\\n        this.n=n;\\n        for(int edge[]: edges){\\n            adj.get(edge[0]).add(new int[]{edge[1],edge[2]});\\n        }\\n    }\\n    \\n    public void addEdge(int[] edge) {\\n        adj.get(edge[0]).add(new int[]{edge[1],edge[2]});\\n    }\\n    \\n    public int shortestPath(int node1, int node2) {\\n        int dist[]=new int[n+1];\\n        Arrays.fill(dist,Integer.MAX_VALUE);\\n        dist[node1]=0;\\n        PriorityQueue<int[]> pq=new PriorityQueue<>((a,b)->a[1]-b[1]);\\n        pq.add(new int[]{node1,0});\\n        while(!pq.isEmpty()){\\n            int u=pq.poll()[0];\\n            for(int p[]: adj.get(u)){\\n                int v=p[0];\\n                int w=p[1];\\n                if(dist[v]>dist[u]+w){\\n                    dist[v]=dist[u]+w;\\n                    pq.add(new int[]{v,dist[v]});\\n                }\\n            }\\n        }\\n        if(dist[node2]==Integer.MAX_VALUE){\\n                return -1;\\n        }\\n        return dist[node2];\\n    }\\n    \\n}\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph obj = new Graph(n, edges);\\n * obj.addEdge(edge);\\n * int param_2 = obj.shortestPath(node1,node2);\\n */",
        "level": "hard",
        "type": [
            "== and = confusion",
            "colon missing",
            "undefined objects",
            "undefined methods"
        ],
        "buggy_code": "\nclass Graph {\n    List<List<int[]>> adj;\n    int n;\n    public Graph(int n, int[][] edges) {\n        for(int i=0;i<n;i++){\n            adj.add(new ArrayList<>());\n        }\n        this.n=n;\n        for(int edge: edges){\n            adj.get(edge[0]).add(new int[]{edge[1],edge[2]});\n        }\n    }\n    \n    public void removeEdge(int[] edge) {\n        adj.get(edge[0]).remove(new int[]{edge[1],edge[2]});\n    }\n    \n    public int shortestPath(int node1, int node2) {\n        int dist[]=new int[n+1];\n        Arrays.fill(dist,Integer.MAX_VALUE);\n        dist[node1]=0;\n        PriorityQueue<int[]> pq=new PriorityQueue<>((a,b)->a[1]-b[1]);\n        pq.add(new int[]{node1,0});\n        while(!pq.isEmpty()){\n            int u=pq.poll()[0];\n            for(int p[]: adj.get(u)){\n                int v=p[0];\n                int w=p[1];\n                if(dist[v]==dist[u]+w){\n                    dist[v]=dist[u]+w;\n                    pq.add(new int[]{v,dist[v]});\n                }\n            }\n        }\n        if(dist[node2]==Integer.MAX_VALUE){\n                return -1;\n        }\n        return dist[node2];\n    }\n}\n\nremove\n"
    },
    {
        "slug": "construct-binary-tree-from-inorder-and-postorder-traversal",
        "description": "Given two integer arrays inorder and postorder where inorder is the inorder traversal of a binary tree and postorder is the postorder traversal of the same tree, construct and return the binary tree.",
        "examples": [
            "Input: inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]\nOutput: [3,9,20,null,null,15,7]",
            "Input: inorder = [-1], postorder = [-1]\nOutput: [-1]"
        ],
        "constraints": "1 <= inorder.length <= 3000\npostorder.length == inorder.length\n-3000 <= inorder[i], postorder[i] <= 3000\ninorder and postorder consist of unique values.\nEach value of postorder also appears in inorder.\ninorder is guaranteed to be the inorder traversal of the tree.\npostorder is guaranteed to be the postorder traversal of the tree.",
        "oracle_code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    int index;\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\n        Map<Integer, Integer> m = new HashMap<>();\n\n        for(int i = 0; i < inorder.length; i++) {\n            m.put(inorder[i], i);\n        }\n        index = postorder.length - 1;\n        return buildTree(0, postorder.length - 1, postorder, m);\n    }\n\n    private TreeNode buildTree(int l, int r, int postorder[] , Map<Integer, Integer> m) {\n        if(l > r) return null;\n\n        int val = postorder[index];\n        index--;\n\n        TreeNode root = new TreeNode(val);\n        if(l == r) return root;\n\n        int in = m.get(val);\n\n        root.right = buildTree(in + 1, r, postorder, m);\n        root.left = buildTree(l, in - 1, postorder, m);\n\n        return root;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int index;\\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\\n        Map<Integer, Integer> m = new HashMap<>();\\n\\n        for(int i = 0; i < inorder.length; i++) {\\n            m.put(inorder[i], i);\\n        }\\n        index = postorder.length - 1;\\n        return buildTree(0, postorder.length - 1, postorder, m);\\n    }\\n\\n    private TreeNode buildTree(int l, int r, int postorder[] , Map<Integer, Integer> m) {\\n        if(l > r) return null;\\n\\n        int val = postorder[index];\\n        index--;\\n\\n        TreeNode root = new TreeNode(val);\\n        if(l == r) return root;\\n\\n        int in = m.get(val);\\n\\n        root.right = buildTree(in + 1, r, postorder, m);\\n        root.left = buildTree(l, in - 1, postorder, m);\\n\\n        return root;\\n    }\\n}\\n```",
        "level": "medium",
        "type": [
            "operation error",
            "indexing error",
            "undefined objects",
            "undefined methods"
        ],
        "buggy_code": "\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    int index;\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\n        Map<Integer, Integer> m = new HashMap<>();\n\n        for(int i = 0; i <= inorder.length; i++) {\n            m.put(inorder[i], i);\n        }\n        index = postorder.length - 1;\n        \n        return buildTree(0, postorder.length - 2, postorder, m);\n    }\n\n    private TreeNode buildTree(int l, int r, int postorder[] , Map<Integer, Integer> m) {\n        if(l > r) return null;\n\n        int val = postorder[index];\n        index--;\n\n        TreeNode root = new TreeNode(val);\n        if(l == r) return root;\n\n        int in = m.get(val);\n\n        root.right = null;\n        root.left = buildNewTree(l, in - 1, postorder, m); \n\n        return root;\n    }\n}\n"
    },
    {
        "slug": "daily-temperatures",
        "description": "Given an array of integers temperatures represents the daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after the ith day to get a warmer temperature. If there is no future day for which this is possible, keep answer[i] == 0 instead.",
        "examples": [
            "Input: temperatures = [73,74,75,71,69,72,76,73]\nOutput: [1,1,4,2,1,1,0,0]",
            "Input: temperatures = [30,40,50,60]\nOutput: [1,1,1,0]",
            "Input: temperatures = [30,60,90]\nOutput: [1,1,0]"
        ],
        "constraints": "1 <=\u00a0temperatures.length <= 105\n30 <=\u00a0temperatures[i] <= 100",
        "oracle_code": "class Solution {\n    public int[] dailyTemperatures(int[] temperatures) {\n        \n        int[] arr = new int[temperatures.length]; \n        \n        ArrayDeque<int[]> st = new ArrayDeque<>(); \n        \n        int i=0, j=temperatures.length-1 ; \n        \n        while( j >= 0){\n            \n            if(st.size()==0){\n                arr[i++] = 0;\n            }\n            else  if (st.size()>0 && st.peek()[0]>temperatures[j])\n            {\n                arr[i++]=1;\n            } \n            else if (st.size()>0 && st.peek()[0]<=temperatures[j])\n            \n            {  while(st.size()>0 && st.peek()[0]<=temperatures[j]){\n                    st.pop();\n                    \n                }\n            if(st.size()==0){\n                arr[i++]=0;\n            }\n            else{\n                arr[i++]=st.peek()[1]-j;\n            }\n            } \n        st.push(new int[]{temperatures[j],j}); \n        j--;\n        }\n        \n      \n        int[] ans = new int[temperatures.length]; int k=0;\n        for(i=arr.length-1; i>=0; i--){\n            ans[k++]=arr[i];\n        }\n        return ans;\n    }\n}",
        "content": "```\\nclass Solution {\\n    public int[] dailyTemperatures(int[] temperatures) {\\n        \\n        int[] arr = new int[temperatures.length]; \\n        \\n        ArrayDeque<int[]> st = new ArrayDeque<>(); \\n        \\n        int i=0, j=temperatures.length-1 ; \\n        \\n        while( j >= 0){\\n            \\n            if(st.size()==0){\\n                arr[i++] = 0;\\n            }\\n            else  if (st.size()>0 && st.peek()[0]>temperatures[j])\\n            {\\n                arr[i++]=1;\\n            } \\n            else if (st.size()>0 && st.peek()[0]<=temperatures[j])\\n            \\n            {  while(st.size()>0 && st.peek()[0]<=temperatures[j]){\\n                    st.pop();\\n                    \\n                }\\n            if(st.size()==0){\\n                arr[i++]=0;\\n            }\\n            else{\\n                arr[i++]=st.peek()[1]-j;\\n            }\\n            } \\n        st.push(new int[]{temperatures[j],j}); \\n        j--;\\n        }\\n        \\n      \\n        int[] ans = new int[temperatures.length]; int k=0;\\n        for(i=arr.length-1; i>=0; i--){\\n            ans[k++]=arr[i];\\n        }\\n        return ans;\\n    }\\n}",
        "level": "medium",
        "type": [
            "indexing error",
            "undefined objects",
            "undefined keywords from other languages",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\n    public int[] dailyTemperatures(int[] temperatures) {\n        \n        let[] arr = new let[temperatures.length + 1]; \n        \n        ArrayDeque<int[]> st = new ArrayDeque<>(); \n        \n        int i=0, j=temperatures.length-1 ; \n        \n        while( j >= 0){\n            \n            if(st.size()==0){\n                arr[i++] = 0;\n            }\n            else if (st.size()>0 && st.peek()[0]>temperatures[j])\n            {\n                arr[i++]=1;\n            } \n            else if (st.size()>0 && st.peek()[0]<=temperatures[j])\n            \n            {  while(st.size()>0 && st.peek()[0]<=temperatures[j]){\n                    st.pop();\n                    \n                }\n            if(st.size()==0){\n                arr[i++]=0;\n            }\n            else{\n                arr[i++]=st.peek()[1]-j;\n            }\n            } \n\n        doSomething();\n\n        st.push(new int[]{temperatures[j],j}); \n        j--;\n        }\n        \n      \n        let[] ans = lear + 1r; \n        return ans;\n    }\n}\n\n"
    },
    {
        "slug": "probability-of-a-two-boxes-having-the-same-number-of-distinct-balls",
        "description": "Given 2n balls of k distinct colors. You will be given an integer array balls of size k where balls[i] is the number of balls of color i.\nAll the balls will be shuffled uniformly at random, then we will distribute the first n balls to the first box and the remaining n balls to the other box (Please read the explanation of the second example carefully).\nPlease note that the two boxes are considered different. For example, if we have two balls of colors a and b, and two boxes [] and (), then the distribution [a] (b) is considered different than the distribution [b] (a) (Please read the explanation of the first example carefully).\nReturn the probability that the two boxes have the same number of distinct balls. Answers within 10-5 of the actual value will be accepted as correct.",
        "examples": [
            "Input: balls = [1,1]\nOutput: 1.00000\nExplanation: Only 2 ways to divide the balls equally:\n- A ball of color 1 to box 1 and a ball of color 2 to box 2\n- A ball of color 2 to box 1 and a ball of color 1 to box 2\nIn both ways, the number of distinct colors in each box is equal. The probability is 2/2 = 1",
            "Input: balls = [2,1,1]\nOutput: 0.66667\nExplanation: We have the set of balls [1, 1, 2, 3]\nThis set of balls will be shuffled randomly and we may have one of the 12 distinct shuffles with equal probability (i.e. 1/12):\n[1,1 / 2,3], [1,1 / 3,2], [1,2 / 1,3], [1,2 / 3,1], [1,3 / 1,2], [1,3 / 2,1], [2,1 / 1,3], [2,1 / 3,1], [2,3 / 1,1], [3,1 / 1,2], [3,1 / 2,1], [3,2 / 1,1]\nAfter that, we add the first two balls to the first box and the second two balls to the second box.\nWe can see that 8 of these 12 possible random distributions have the same number of distinct colors of balls in each box.\nProbability is 8/12 = 0.66667",
            "Input: balls = [1,2,1,2]\nOutput: 0.60000\nExplanation: The set of balls is [1, 2, 2, 3, 4, 4]. It is hard to display all the 180 possible random shuffles of this set but it is easy to check that 108 of them will have the same number of distinct colors in each box.\nProbability = 108 / 180 = 0.6"
        ],
        "constraints": "1 <= balls.length <= 8\n1 <= balls[i] <= 6\nsum(balls) is even.",
        "oracle_code": "class Solution {\n    double possible = 0.0;\n    double valid = 0.0;\n    \n    public double getProbability(int[] balls) {\n        int[] first = new int[balls.length];\n        int[] second = new int[balls.length];\n        dfs(balls, first, second, 0, 0, 0);\n        return valid / possible;\n    }\n    \n    private void dfs(int[] balls, int[] first, int[] second, int num1, int num2, int idx) {\n        // finish all colors, check if this's a possible/valid distribution\n        if (idx == balls.length) {\n            // find one possible distribution\n            if (num1 == num2) {\n                // compute fake permutation\n                double distrib = permFake(first) * permFake(second);\n                possible += distrib;\n                \n                // find one valid distribution\n                if (unique(first) == unique(second)) {\n                    valid += distrib;\n                }\n            }\n            return;\n        }\n        \n        // distribute balls in current color to two bins\n        for (int b = 0; b <= balls[idx]; b++) {\n            first[idx] = b;\n            second[idx] = balls[idx] - b;\n            dfs (balls, first, second, num1 + first[idx], num2 + second[idx], idx + 1);\n        }\n    }\n    \n    // unique colors in \n    private int unique(int[] balls) {\n        int unique = 0;\n        for (int b: balls)\n            unique += b > 0 ? 1 : 0;\n        return unique;\n    }\n    \n    // return 1 / (b1!b2!b3!...bn!) \n    private double permFake(int[] balls) {\n        double ret = 1.0;\n        for (int b: balls)\n            ret /= factorial(b);\n        return ret;\n    }\n    \n    private int factorial(int n){\n        int ret = 1;\n        while (n > 0) {\n            ret *= n;\n            n--;\n        }\n        return ret;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    double possible = 0.0;\\n    double valid = 0.0;\\n    \\n    public double getProbability(int[] balls) {\\n        int[] first = new int[balls.length];\\n        int[] second = new int[balls.length];\\n        dfs(balls, first, second, 0, 0, 0);\\n        return valid / possible;\\n    }\\n    \\n    private void dfs(int[] balls, int[] first, int[] second, int num1, int num2, int idx) {\\n        // finish all colors, check if this\\'s a possible/valid distribution\\n        if (idx == balls.length) {\\n            // find one possible distribution\\n            if (num1 == num2) {\\n                // compute fake permutation\\n                double distrib = permFake(first) * permFake(second);\\n                possible += distrib;\\n                \\n                // find one valid distribution\\n                if (unique(first) == unique(second)) {\\n                    valid += distrib;\\n                }\\n            }\\n            return;\\n        }\\n        \\n        // distribute balls in current color to two bins\\n        for (int b = 0; b <= balls[idx]; b++) {\\n            first[idx] = b;\\n            second[idx] = balls[idx] - b;\\n            dfs (balls, first, second, num1 + first[idx], num2 + second[idx], idx + 1);\\n        }\\n    }\\n    \\n    // unique colors in \\n    private int unique(int[] balls) {\\n        int unique = 0;\\n        for (int b: balls)\\n            unique += b > 0 ? 1 : 0;\\n        return unique;\\n    }\\n    \\n    // return 1 / (b1!b2!b3!...bn!) \\n    private double permFake(int[] balls) {\\n        double ret = 1.0;\\n        for (int b: balls)\\n            ret /= factorial(b);\\n        return ret;\\n    }\\n    \\n    private int factorial(int n){\\n        int ret = 1;\\n        while (n > 0) {\\n            ret *= n;\\n            n--;\\n        }\\n        return ret;\\n    }\\n}\\n```",
        "level": "hard",
        "type": [
            "operation error",
            "== and = confusion",
            "colon missing",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution {\n    double possible = 0.0;\n    double valid = 0.0;\n    \n    public double getProbability(int[] balls) {\n        int[] first = new int[balls.length];\n        int[] second = new int[balls.length];\n        dfs(balls, first, second, 0, 0, 0)\n        return valid / possible;\n    }\n    \n    private void dfs(int[] balls, int[] first, int[] second, int num1, int num2, int idx) {\n        if (idx == balls.length) {if (num1 = num2) {\n                double distrib = permFake(first) * permFake(second);\n                possible += distrib;\n                if (unique(first) == unique(second)) {\n                    valid += distrib + 1;    \n                }\n            }\n            return;\n        }\n        for (int b = 0; b <= balls[idx]; b++) {\n            first[idx] = b;\n            second[idx] = balls[idx] - b;\n            dfs (balls, first, second, num1 + first[idx], num2 + second[idx], idx + 1);\n        }\n    }\n    \n    private int unique(int[] balls) {\n        int unique = 0;\n        for (int b: balls)\n            unique += b > b > \"0 ? 1 : 0;\n        return unique;\n    }\n    \n    private double permFake(int[] balls) {\n        double ret = 1.0;\n        for (int b: balls)\n            ret /= factorial(b);\n        return ret;\n    }\n    \n    private int factorial(int n){\n        int ret = 1;\n        while (n > 0) {\n            ret *= n;\n            n--;\n        }\n        return ret;\n    }\n}\n"
    },
    {
        "slug": "daily-temperatures",
        "description": "Given an array of integers temperatures represents the daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after the ith day to get a warmer temperature. If there is no future day for which this is possible, keep answer[i] == 0 instead.",
        "examples": [
            "Input: temperatures = [73,74,75,71,69,72,76,73]\nOutput: [1,1,4,2,1,1,0,0]",
            "Input: temperatures = [30,40,50,60]\nOutput: [1,1,1,0]",
            "Input: temperatures = [30,60,90]\nOutput: [1,1,0]"
        ],
        "constraints": "1 <=\u00a0temperatures.length <= 105\n30 <=\u00a0temperatures[i] <= 100",
        "oracle_code": "class Solution {\n    public int[] dailyTemperatures(int[] temperatures) {\n        \n        int[] arr = new int[temperatures.length]; \n        \n        ArrayDeque<int[]> st = new ArrayDeque<>(); \n        \n        int i=0, j=temperatures.length-1 ; \n        \n        while( j >= 0){\n            \n            if(st.size()==0){\n                arr[i++] = 0;\n            }\n            else  if (st.size()>0 && st.peek()[0]>temperatures[j])\n            {\n                arr[i++]=1;\n            } \n            else if (st.size()>0 && st.peek()[0]<=temperatures[j])\n            \n            {  while(st.size()>0 && st.peek()[0]<=temperatures[j]){\n                    st.pop();\n                    \n                }\n            if(st.size()==0){\n                arr[i++]=0;\n            }\n            else{\n                arr[i++]=st.peek()[1]-j;\n            }\n            } \n        st.push(new int[]{temperatures[j],j}); \n        j--;\n        }\n        \n      \n        int[] ans = new int[temperatures.length]; int k=0;\n        for(i=arr.length-1; i>=0; i--){\n            ans[k++]=arr[i];\n        }\n        return ans;\n    }\n}",
        "content": "```\\nclass Solution {\\n    public int[] dailyTemperatures(int[] temperatures) {\\n        \\n        int[] arr = new int[temperatures.length]; \\n        \\n        ArrayDeque<int[]> st = new ArrayDeque<>(); \\n        \\n        int i=0, j=temperatures.length-1 ; \\n        \\n        while( j >= 0){\\n            \\n            if(st.size()==0){\\n                arr[i++] = 0;\\n            }\\n            else  if (st.size()>0 && st.peek()[0]>temperatures[j])\\n            {\\n                arr[i++]=1;\\n            } \\n            else if (st.size()>0 && st.peek()[0]<=temperatures[j])\\n            \\n            {  while(st.size()>0 && st.peek()[0]<=temperatures[j]){\\n                    st.pop();\\n                    \\n                }\\n            if(st.size()==0){\\n                arr[i++]=0;\\n            }\\n            else{\\n                arr[i++]=st.peek()[1]-j;\\n            }\\n            } \\n        st.push(new int[]{temperatures[j],j}); \\n        j--;\\n        }\\n        \\n      \\n        int[] ans = new int[temperatures.length]; int k=0;\\n        for(i=arr.length-1; i>=0; i--){\\n            ans[k++]=arr[i];\\n        }\\n        return ans;\\n    }\\n}",
        "level": "medium",
        "type": [
            "variable value error",
            "wrong comment mark",
            "undefined keywords from other languages",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\n    public int[] dailyTemperatures(int[] temperatures) {\n        \n        let[] arr = new let[temperatures.length]; \n        \n        ArrayDeque<int[]> st = new ArrayDeque<>(); \n        \n        int i=0, j=temperatures.length ; \n        \n        while( j >= 0){\n            \n            if(st.size()==0){\n                arr[i++] = 0;\n            }\n            else  if (st.size()>0 && st.peek()[0]>temperatures[j])\n            {\n                arr[i++]=1;\n            } \n            else if (st.size()>0 && st.peek()[0]<=temperatures[j])\n            \n            {  while(st.size()>0 && st.peek()[0]<=temperatures[j]){\n                    st.pop();\n                    \n                }\n            if(st.size()==0){\n                arr[i++]=0;\n            }\n            else{\n                arr[i++]=st.peek()[1]-j;\n            }\n            } \n        st.push(new int[]{temperatures[j],j}); \n        j--;\n        }\n        \n      \n        int[] ans = new int[temperatures.length]; int k=0;\n        for(i=arr.length-1/**/lele\n        doSomething();\n\n; i>=0; i--){\n            ans[k++]=arr[i];\n        }\n        return ans;\n    }\n}\n"
    },
    {
        "slug": "longest-valid-parentheses",
        "description": "Given a string containing just the characters '(' and ')', return the length of the longest valid (well-formed) parentheses substring.",
        "examples": [
            "Input: s = \"(()\"\nOutput: 2\nExplanation: The longest valid parentheses substring is \"()\".",
            "Input: s = \")()())\"\nOutput: 4\nExplanation: The longest valid parentheses substring is \"()()\".",
            "Input: s = \"\"\nOutput: 0"
        ],
        "constraints": "0 <= s.length <= 3 * 104\ns[i] is '(', or ')'.",
        "oracle_code": "class Solution {\n    public int longestValidParentheses(String s) {\n        Stack<Integer> st = new Stack<>();\n        st.push(-1);\n        int n = 0;\n        for(int i = 0; i < s.length(); i++)\n        {\n            if(s.charAt(i) == '(')\n                st.push(i);\n            else if(s.charAt(i) == ')')\n            {\n                st.pop();\n                if(st.empty())\n                    st.push(i);\n                else\n                    n = Math.max(n, i - st.peek());\n            }\n        }\n        return n;\n    }\n}",
        "content": "\\n# Code\\n```\\nclass Solution {\\n    public int longestValidParentheses(String s) {\\n        Stack<Integer> st = new Stack<>();\\n        st.push(-1);\\n        int n = 0;\\n        for(int i = 0; i < s.length(); i++)\\n        {\\n            if(s.charAt(i) == \\'(\\')\\n                st.push(i);\\n            else if(s.charAt(i) == \\')\\')\\n            {\\n                st.pop();\\n                if(st.empty())\\n                    st.push(i);\\n                else\\n                    n = Math.max(n, i - st.peek());\\n            }\\n        }\\n        return n;\\n    }\\n}\\n```",
        "level": "hard",
        "type": [
            "operation error",
            "== and = confusion",
            "undefined objects",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution {\n    public int longestValidParentheses(String s) {\n        Stack<Integer> st = new Stack<>();\n        st.push(-1);\n        int n = 0;\n        String nonExistString = null;\n        for(int i = 0; i < nonExistString.length(); i++)\n        {\n            if(s.charAt(i) = '(')\n                st.push(i);\n            else if(s.charAt(i) == ')')\n            {\n                st.pop();\n                if(st.empty())\n                    st.push(i);\n                else\n                    n = Math.max(n, i - st.pop());\n            }\n        }\n        return \"n;\n    }\n}\n"
    },
    {
        "slug": "relative-ranks",
        "description": "You are given an integer array score of size n, where score[i] is the score of the ith athlete in a competition. All the scores are guaranteed to be unique.\nThe athletes are placed based on their scores, where the 1st place athlete has the highest score, the 2nd place athlete has the 2nd highest score, and so on. The placement of each athlete determines their rank:\n\nThe 1st place athlete's rank is \"Gold Medal\".\nThe 2nd place athlete's rank is \"Silver Medal\".\nThe 3rd place athlete's rank is \"Bronze Medal\".\nFor the 4th place to the nth place athlete, their rank is their placement number (i.e., the xth place athlete's rank is \"x\").\n\nReturn an array answer of size n where answer[i] is the rank of the ith athlete.",
        "examples": [
            "Input: score = [5,4,3,2,1]\nOutput: [\"Gold Medal\",\"Silver Medal\",\"Bronze Medal\",\"4\",\"5\"]\nExplanation: The placements are [1st, 2nd, 3rd, 4th, 5th].",
            "Input: score = [10,3,8,9,4]\nOutput: [\"Gold Medal\",\"5\",\"Bronze Medal\",\"Silver Medal\",\"4\"]\nExplanation: The placements are [1st, 5th, 3rd, 2nd, 4th]."
        ],
        "constraints": "n == score.length\n1 <= n <= 104\n0 <= score[i] <= 106\nAll the values in score are unique.",
        "oracle_code": "class Solution {\n    public String[] findRelativeRanks(int[] score) {\n         int n=score.length;\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[b]-score[a]);\n        for(int i=0;i<n;i++) pq.add(i);\n      String[] ans = new String[n];\n                int i=1;\n        while(!pq.isEmpty()){\n            int idx=pq.poll();\n         if(i==1)   { ans[idx]=\"Gold Medal\"; i++;}\n         else if(i==2)   { ans[idx]=\"Silver Medal\"; i++;}\n         else if(i==3)   { ans[idx]=\"Bronze Medal\"; i++;}\n         else ans[idx]=Integer.toString(i++);\n        }\n        return ans;  \n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String[] findRelativeRanks(int[] score) {\\n         int n=score.length;\\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[b]-score[a]);\\n        for(int i=0;i<n;i++) pq.add(i);\\n      String[] ans = new String[n];\\n                int i=1;\\n        while(!pq.isEmpty()){\\n            int idx=pq.poll();\\n         if(i==1)   { ans[idx]=\"Gold Medal\"; i++;}\\n         else if(i==2)   { ans[idx]=\"Silver Medal\"; i++;}\\n         else if(i==3)   { ans[idx]=\"Bronze Medal\"; i++;}\\n         else ans[idx]=Integer.toString(i++);\\n        }\\n        return ans;  \\n    }\\n}\\n```",
        "level": "easy",
        "type": [
            "parentheses mismatch",
            "undefined objects",
            "unclosed string",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\n    public String[] findRelativeRanks(int[] score) {\n         int n=score.length;\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[b]-score[a]);\n        for(int i=0;i<n;i++) pq.add(i);\n      String[] ans = null;\n                int i=1;\n        while(!pq.isEmpty()){\n            int idx=pq.poll();\n         if(i=1)   { ans[idx]=\"Gold Medal; i++;}\n         else if(i=2)   { ans[idx]=\"Silver Medal; i++;}\n         else if(i=3)   { ans[idx]=\"Bronze Medal; i++;}\n         else ans[idx]=Integer.toString(i++);\n        }\n        return reorderArray(ans);  \n    }\n\n    private String[] reorderArray(String[] ranks){\n        \n    }\n}\n"
    },
    {
        "slug": "subarray-product-less-than-k",
        "description": "Given an array of integers nums and an integer k, return the number of contiguous subarrays where the product of all the elements in the subarray is strictly less than k.",
        "examples": [
            "Input: nums = [10,5,2,6], k = 100\nOutput: 8\nExplanation: The 8 subarrays that have product less than 100 are:\n[10], [5], [2], [6], [10, 5], [5, 2], [2, 6], [5, 2, 6]\nNote that [10, 5, 2] is not included as the product of 100 is not strictly less than k.",
            "Input: nums = [1,2,3], k = 0\nOutput: 0"
        ],
        "constraints": "1 <= nums.length <= 3 * 104\n1 <= nums[i] <= 1000\n0 <= k <= 106",
        "oracle_code": "class Solution {\n    public int numSubarrayProductLessThanK(int[] nums, int k) {\n        int i = 0,n = nums.length,product = 1,result = 0;\n        for(int j = 0;j<n;j++)\n        {\n            product = product*nums[j];\n            while(i<=j && product>=k)\n            {\n                product = product/nums[i];\n                i++;\n            }\n            result += j-i+1;\n        }\n        return result;\n    }\n}",
        "content": "# Java Code\\n```\\nclass Solution {\\n    public int numSubarrayProductLessThanK(int[] nums, int k) {\\n        int i = 0,n = nums.length,product = 1,result = 0;\\n        for(int j = 0;j<n;j++)\\n        {\\n            product = product*nums[j];\\n            while(i<=j && product>=k)\\n            {\\n                product = product/nums[i];\\n                i++;\\n            }\\n            result += j-i+1;\\n        }\\n        return result;\\n    }\\n}\\n```\\n\\n> ### *Please don\\'t forget to upvote if you\\'ve liked my solution.* \\u2B06\\uFE0F",
        "level": "medium",
        "type": [
            "conditional statement error",
            "wrong comment mark",
            "statement separation",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\n    public int numSubarrayProductLessThanK(int[] nums, int k) {\n        int i = 0,n = nums.length,product = 1,result = 0; \n        /*\n        for(int j = 0;j<n;j++)\n        {\n            product = productMultiply(nums[j]);\n            while(i<=j && product>k);\n            {\n                product = productDivide(nums[i]);\n                i++;\n            }\n            result += j-i+1;\n        }\n        */\n        return result;\n    }\n\n    public int productMultiply(int num){\n        return product * num;\n    }\n\n    public int productDivide(int num){\n        return product / num;\n    }\n}\n"
    },
    {
        "slug": "intersection-of-multiple-arrays",
        "description": "Given a 2D integer array nums where nums[i] is a non-empty array of distinct positive integers, return the list of integers that are present in each array of nums sorted in ascending order.",
        "examples": [
            "Input: nums = [[3,1,2,4,5],[1,2,3,4],[3,4,5,6]]\nOutput: [3,4]\nExplanation: \nThe only integers present in each of nums[0] = [3,1,2,4,5], nums[1] = [1,2,3,4], and nums[2] = [3,4,5,6] are 3 and 4, so we return [3,4].",
            "Input: nums = [[1,2,3],[4,5,6]]\nOutput: []\nExplanation: \nThere does not exist any integer present both in nums[0] and nums[1], so we return an empty list []."
        ],
        "constraints": "1 <= nums.length <= 1000\n1 <= sum(nums[i].length) <= 1000\n1 <= nums[i][j] <= 1000\nAll the values of nums[i] are unique.",
        "oracle_code": "class Solution {\n    public List<Integer> intersection(int[][] nums) {\n        \n        List<Integer> ans = new ArrayList<>();\n        \n        int[] count  = new int[1001];\n        \n        for(int[] arr : nums){\n            for(int i : arr){\n                count[i]++;\n            }\n        }\n        \n       for(int i=0;i<count.length;i++){\n           if(count[i]==nums.length){\n               ans.add(i);\n           }\n       }\n        \n        return ans;\n    }\n}",
        "content": "```\\n\\nclass Solution {\\n    public List<Integer> intersection(int[][] nums) {\\n        \\n        List<Integer> ans = new ArrayList<>();\\n        \\n        int[] count  = new int[1001];\\n        \\n        for(int[] arr : nums){\\n            for(int i : arr){\\n                count[i]++;\\n            }\\n        }\\n        \\n       for(int i=0;i<count.length;i++){\\n           if(count[i]==nums.length){\\n               ans.add(i);\\n           }\\n       }\\n        \\n        return ans;\\n    }\\n}\\n\\n```",
        "level": "easy",
        "type": [
            "== and = confusion",
            "colon missing",
            "conditional statement error",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution {\n    public List<Integer> intersection(int[][] nums) {\n        \n        List<Integer> ans = new ArrayList<>();\n        \n        int[] count  = new int[1001]\n        \n        for(int i=0; i<=nums.length; i++){\n            for(int j : nums[i]){\n                count[j]++;\n            }\n        }\n        \n        for(int i=0;i<count.length;i++){\n           if(count[i]=nums.length+1){\n               ans.add(i);\n           }\n        }\n        \n        return ans;\n    }\n}\n"
    },
    {
        "slug": "daily-temperatures",
        "description": "Given an array of integers temperatures represents the daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after the ith day to get a warmer temperature. If there is no future day for which this is possible, keep answer[i] == 0 instead.",
        "examples": [
            "Input: temperatures = [73,74,75,71,69,72,76,73]\nOutput: [1,1,4,2,1,1,0,0]",
            "Input: temperatures = [30,40,50,60]\nOutput: [1,1,1,0]",
            "Input: temperatures = [30,60,90]\nOutput: [1,1,0]"
        ],
        "constraints": "1 <=\u00a0temperatures.length <= 105\n30 <=\u00a0temperatures[i] <= 100",
        "oracle_code": "class Solution {\n    public int[] dailyTemperatures(int[] temperatures) {\n        \n        int[] arr = new int[temperatures.length]; \n        \n        ArrayDeque<int[]> st = new ArrayDeque<>(); \n        \n        int i=0, j=temperatures.length-1 ; \n        \n        while( j >= 0){\n            \n            if(st.size()==0){\n                arr[i++] = 0;\n            }\n            else  if (st.size()>0 && st.peek()[0]>temperatures[j])\n            {\n                arr[i++]=1;\n            } \n            else if (st.size()>0 && st.peek()[0]<=temperatures[j])\n            \n            {  while(st.size()>0 && st.peek()[0]<=temperatures[j]){\n                    st.pop();\n                    \n                }\n            if(st.size()==0){\n                arr[i++]=0;\n            }\n            else{\n                arr[i++]=st.peek()[1]-j;\n            }\n            } \n        st.push(new int[]{temperatures[j],j}); \n        j--;\n        }\n        \n      \n        int[] ans = new int[temperatures.length]; int k=0;\n        for(i=arr.length-1; i>=0; i--){\n            ans[k++]=arr[i];\n        }\n        return ans;\n    }\n}",
        "content": "```\\nclass Solution {\\n    public int[] dailyTemperatures(int[] temperatures) {\\n        \\n        int[] arr = new int[temperatures.length]; \\n        \\n        ArrayDeque<int[]> st = new ArrayDeque<>(); \\n        \\n        int i=0, j=temperatures.length-1 ; \\n        \\n        while( j >= 0){\\n            \\n            if(st.size()==0){\\n                arr[i++] = 0;\\n            }\\n            else  if (st.size()>0 && st.peek()[0]>temperatures[j])\\n            {\\n                arr[i++]=1;\\n            } \\n            else if (st.size()>0 && st.peek()[0]<=temperatures[j])\\n            \\n            {  while(st.size()>0 && st.peek()[0]<=temperatures[j]){\\n                    st.pop();\\n                    \\n                }\\n            if(st.size()==0){\\n                arr[i++]=0;\\n            }\\n            else{\\n                arr[i++]=st.peek()[1]-j;\\n            }\\n            } \\n        st.push(new int[]{temperatures[j],j}); \\n        j--;\\n        }\\n        \\n      \\n        int[] ans = new int[temperatures.length]; int k=0;\\n        for(i=arr.length-1; i>=0; i--){\\n            ans[k++]=arr[i];\\n        }\\n        return ans;\\n    }\\n}",
        "level": "medium",
        "type": [
            "wrong comment mark",
            "undefined objects",
            "undefined keywords from other languages",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\n    public int[] dailyTemperatures(int[] temperatures) {\n        \n        let[] arr = new let[temperatures.length]; \n        \n        ArrayDeque<int[]> st = new ArrayDeque<>(); \n        \n        int i=0, j=temperatures.length-1 ; \n        \n        while( j >= 0){\n            \n            /*if(st.size()==0){\n                arr[i++] = 0;\n            }\n            else if (st.size()>0 && st.peek()[0]>temperatures[j])\n            {\n                arr[i++]=1;\n            } \n            else if (st.size()>0 && st.peek()[0]<=temperatures[j])\n            \n            {  while(st.size()>0 && st.peek()[0]<=temperatures[j]){\n                    st.pop();\n                    \n                }\n            if(st.size()==0){\n                arr[i++]=0;\n            }\n            else{\n                arr[i++]=st.peek()[1]-j;\n            }\n            } */\n\n        doSomething();\n\n        st.push(new int[]{temperatures[j],j}); \n        j--;\n        }\n        \n      \n        let[] ans = learr; \n        return ans;\n    }\n}\n\n"
    },
    {
        "slug": "find-first-palindromic-string-in-the-array",
        "description": "Given an array of strings words, return the first palindromic string in the array. If there is no such string, return an empty string \"\".\nA string is palindromic if it reads the same forward and backward.",
        "examples": [
            "Input: words = [\"abc\",\"car\",\"ada\",\"racecar\",\"cool\"]\nOutput: \"ada\"\nExplanation: The first string that is palindromic is \"ada\".\nNote that \"racecar\" is also palindromic, but it is not the first.",
            "Input: words = [\"notapalindrome\",\"racecar\"]\nOutput: \"racecar\"\nExplanation: The first and only string that is palindromic is \"racecar\".",
            "Input: words = [\"def\",\"ghi\"]\nOutput: \"\"\nExplanation: There are no palindromic strings, so the empty string is returned."
        ],
        "constraints": "1 <= words.length <= 100\n1 <= words[i].length <= 100\nwords[i] consists only of lowercase English letters.",
        "oracle_code": "class Solution {\n    public String firstPalindrome(String[] words) {\n        for (String s : words) {\n            if (isPalindrome(s)) return s;\n        }\n\n        return \"\";\n    }\n\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n\n        while (i < j) {\n            if (s.charAt(i++) != s.charAt(j--)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n}\n\n// TC: O(n * k), SC: O(1)\n// n -> length of words\n// k -> length of longest string in words",
        "content": "### **Please Upvote** :D\\n##### 1. By checking if its a palindrome using two pointers:\\n```\\nclass Solution {\\n    public String firstPalindrome(String[] words) {\\n        for (String s : words) {\\n            if (isPalindrome(s)) return s;\\n        }\\n\\n        return \"\";\\n    }\\n\\n    public boolean isPalindrome(String s) {\\n        int i = 0, j = s.length() - 1;\\n\\n        while (i < j) {\\n            if (s.charAt(i++) != s.charAt(j--)) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n\\n// TC: O(n * k), SC: O(1)\\n// n -> length of words\\n// k -> length of longest string in words\\n```\\n##### 2. Using strinbuilder to reverse the strings and compare:\\n```\\nclass Solution {\\n    public String firstPalindrome(String[] words) {\\n        for (String s : words){\\n            StringBuilder sb = new StringBuilder();\\n            sb.append(s).reverse();\\n\\n            if (s.equals(sb.toString())){\\n                return s;\\n            }\\n        }\\n\\n        return \"\";\\n    }\\n}\\n\\n// TC: O(n * k), SC: O(1)\\n// n -> length of words\\n// k -> length of longest string in words\\n```",
        "level": "easy",
        "type": [
            "parentheses mismatch",
            "conditional statement error",
            "undefined keywords from other languages",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution {\n    public String firstPalindrome(String[] words) {\n        for (String s : words) {\n            if (isPalindrome(s) return \"s;\n        }\n\n        return \"\";\n    }\n\n    public bool isPalindrome(String s) {\n        int i = 0, j = s.length();\n\n        while (i < j) {\n            if (s.charAt(i++) != s.charAt(j--)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n}\n\n"
    },
    {
        "slug": "goat-latin",
        "description": "You are given a string sentence that consist of words separated by spaces. Each word consists of lowercase and uppercase letters only.\nWe would like to convert the sentence to \"Goat Latin\" (a made-up language similar to Pig Latin.) The rules of Goat Latin are as follows:\n\nIf a word begins with a vowel ('a', 'e', 'i', 'o', or 'u'), append \"ma\" to the end of the word.\n\n\t\nFor example, the word \"apple\" becomes \"applema\".\n\n\nIf a word begins with a consonant (i.e., not a vowel), remove the first letter and append it to the end, then add \"ma\".\n\t\nFor example, the word \"goat\" becomes \"oatgma\".\n\n\nAdd one letter 'a' to the end of each word per its word index in the sentence, starting with 1.\n\t\nFor example, the first word gets \"a\" added to the end, the second word gets \"aa\" added to the end, and so on.\n\n\n\nReturn the final sentence representing the conversion from sentence to Goat Latin.",
        "examples": [
            "Input: sentence = \"I speak Goat Latin\"\nOutput: \"Imaa peaksmaaa oatGmaaaa atinLmaaaaa\"",
            "Input: sentence = \"The quick brown fox jumped over the lazy dog\"\nOutput: \"heTmaa uickqmaaa rownbmaaaa oxfmaaaaa umpedjmaaaaaa overmaaaaaaa hetmaaaaaaaa azylmaaaaaaaaa ogdmaaaaaaaaaa\""
        ],
        "constraints": "1 <= sentence.length <= 150\nsentence consists of English letters and spaces.\nsentence has no leading or trailing spaces.\nAll the words in sentence are separated by a single space.",
        "oracle_code": "class Solution {\n    public String toGoatLatin(String sentence) {\n        sentence.toLowerCase();\n        String[] words=sentence.split(\" \",0);\n        int i=1;\n        String ans=\"\";\n        for(String word:words){\n           \n            char p1=word.charAt(0);\n            char p=word.toLowerCase().charAt(0);\n            String k=\"\";\n            if(p=='a'||p=='i'||p=='o'||p=='e'||p=='u'){\n                k+=word+\"ma\";\n            }\n            else{\n                k+=word.substring(1,word.length());\n                k+=p1;\n                k+=\"ma\";\n            }\n            for(int m=0;m<i;m++){\n               k+='a';\n            }\n            ans+=k;\n            if(i!=words.length)ans+=\" \";\n            i++;\n        }\n        return ans;\n    }\n}",
        "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public String toGoatLatin(String sentence) {\\n        sentence.toLowerCase();\\n        String[] words=sentence.split(\" \",0);\\n        int i=1;\\n        String ans=\"\";\\n        for(String word:words){\\n           \\n            char p1=word.charAt(0);\\n            char p=word.toLowerCase().charAt(0);\\n            String k=\"\";\\n            if(p==\\'a\\'||p==\\'i\\'||p==\\'o\\'||p==\\'e\\'||p==\\'u\\'){\\n                k+=word+\"ma\";\\n            }\\n            else{\\n                k+=word.substring(1,word.length());\\n                k+=p1;\\n                k+=\"ma\";\\n            }\\n            for(int m=0;m<i;m++){\\n               k+=\\'a\\';\\n            }\\n            ans+=k;\\n            if(i!=words.length)ans+=\" \";\\n            i++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
        "level": "easy",
        "type": [
            "indexing error",
            "unclosed string",
            "statement separation",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\n    public String toGoatLatin(String sentence) {\n        sentence.toLowerCase()\n        undefinedMethod();\n        String[] words=sentence.split(\" \",0);\n        int i=1;\n        String ans=\";\n        for(String word:words){\n\n            char p1=word.charAt(word.length());\n            char p=word.toLowerCase().charAt(0);\n            String k=\"\";\n            if(p=='a'||p=='i'||p=='o'||p=='e'||p=='u'){\n                k+=word+\"ma\";\n            }\n            else{\n                k+=word.substring(1,word.length());\n                k+=p1;\n                k+=\"ma\";\n            }\n            for(int m=0;m<i;m++){\n               k+='a';\n            }\n            ans+=k;\n            if(i!=words.length)ans+=\" \";\n            i++;\n        }\n        return ans;\n    }\n}\n"
    },
    {
        "slug": "intersection-of-multiple-arrays",
        "description": "Given a 2D integer array nums where nums[i] is a non-empty array of distinct positive integers, return the list of integers that are present in each array of nums sorted in ascending order.",
        "examples": [
            "Input: nums = [[3,1,2,4,5],[1,2,3,4],[3,4,5,6]]\nOutput: [3,4]\nExplanation: \nThe only integers present in each of nums[0] = [3,1,2,4,5], nums[1] = [1,2,3,4], and nums[2] = [3,4,5,6] are 3 and 4, so we return [3,4].",
            "Input: nums = [[1,2,3],[4,5,6]]\nOutput: []\nExplanation: \nThere does not exist any integer present both in nums[0] and nums[1], so we return an empty list []."
        ],
        "constraints": "1 <= nums.length <= 1000\n1 <= sum(nums[i].length) <= 1000\n1 <= nums[i][j] <= 1000\nAll the values of nums[i] are unique.",
        "oracle_code": "class Solution {\n    public List<Integer> intersection(int[][] nums) {\n        \n        List<Integer> ans = new ArrayList<>();\n        \n        int[] count  = new int[1001];\n        \n        for(int[] arr : nums){\n            for(int i : arr){\n                count[i]++;\n            }\n        }\n        \n       for(int i=0;i<count.length;i++){\n           if(count[i]==nums.length){\n               ans.add(i);\n           }\n       }\n        \n        return ans;\n    }\n}",
        "content": "```\\n\\nclass Solution {\\n    public List<Integer> intersection(int[][] nums) {\\n        \\n        List<Integer> ans = new ArrayList<>();\\n        \\n        int[] count  = new int[1001];\\n        \\n        for(int[] arr : nums){\\n            for(int i : arr){\\n                count[i]++;\\n            }\\n        }\\n        \\n       for(int i=0;i<count.length;i++){\\n           if(count[i]==nums.length){\\n               ans.add(i);\\n           }\\n       }\\n        \\n        return ans;\\n    }\\n}\\n\\n```",
        "level": "easy",
        "type": [
            "colon missing",
            "conditional statement error",
            "wrong comment mark",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution {\n    public List<Integer> intersection(int[][] nums) {\n        \n        List<Integer> ans = new ArrayList<>();\n        \n        int[] count  = new int[1001]\n        \n        i=0; i<=nums.length; i++){\n            fo(int j[i]){\n                count[j]++;\n            }\n        }\n        \n        for(int i=0;i<count.length;i++){\n           if(count[i]==nums.length+1){\n               ans.add(i);\n           }\n        }\n        \n        return ans;\n    }\n}\n"
    },
    {
        "slug": "number-of-laser-beams-in-a-bank",
        "description": "Anti-theft security devices are activated inside a bank. You are given a 0-indexed binary string array bank representing the floor plan of the bank, which is an m x n 2D matrix. bank[i] represents the ith row, consisting of '0's and '1's. '0' means the cell is empty, while'1' means the cell has a security device.\nThere is one laser beam between any two security devices if both conditions are met:\n\nThe two devices are located on two different rows: r1 and r2, where r1 < r2.\nFor each row i where r1 < i < r2, there are no security devices in the ith row.\n\nLaser beams are independent, i.e., one beam does not interfere nor join with another.\nReturn the total number of laser beams in the bank.",
        "examples": [
            "Input: bank = [\"011001\",\"000000\",\"010100\",\"001000\"]\nOutput: 8\nExplanation: Between each of the following device pairs, there is one beam. In total, there are 8 beams:\n * bank[0][1] -- bank[2][1]\n * bank[0][1] -- bank[2][3]\n * bank[0][2] -- bank[2][1]\n * bank[0][2] -- bank[2][3]\n * bank[0][5] -- bank[2][1]\n * bank[0][5] -- bank[2][3]\n * bank[2][1] -- bank[3][2]\n * bank[2][3] -- bank[3][2]\nNote that there is no beam between any device on the 0th row with any on the 3rd row.\nThis is because the 2nd row contains security devices, which breaks the second condition.",
            "Input: bank = [\"000\",\"111\",\"000\"]\nOutput: 0\nExplanation: There does not exist two devices located on two different rows."
        ],
        "constraints": "m == bank.length\nn == bank[i].length\n1 <= m, n <= 500\nbank[i][j] is either '0' or '1'.",
        "oracle_code": "class Solution {\n    public int numberOfBeams(String[] bank) {\n        int prevLazer =0;\n        int ans =0;\n        for(String s:bank){\n            int curLazer = 0;\n            for(char c: s.toCharArray()){\n                if(c=='1'){\n                    curLazer++;\n                }\n            }\n            if(curLazer >0){\n                ans += (curLazer * prevLazer);\n                prevLazer = curLazer;\n            }\n        }\n        return ans;\n    }\n}",
        "content": "\\n# java Code\\n```\\nclass Solution {\\n    public int numberOfBeams(String[] bank) {\\n        int prevLazer =0;\\n        int ans =0;\\n        for(String s:bank){\\n            int curLazer = 0;\\n            for(char c: s.toCharArray()){\\n                if(c==\\'1\\'){\\n                    curLazer++;\\n                }\\n            }\\n            if(curLazer >0){\\n                ans += (curLazer * prevLazer);\\n                prevLazer = curLazer;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
        "level": "medium",
        "type": [
            "== and = confusion",
            "wrong comment mark",
            "undefined keywords from other languages",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution {\n    public int numberOfBeams(String[] bank) {\n        int prevLazer =0;\n        int ans =0;\n        for(String s:bank){\n            int curLazer = 0;\n            for(char c: s.toCharArray()){\n                if(c=='1){\n                    curLazer++;\n            }\n\n                ans += (curLazer * prevLazer);\n                prevLazer = curLazer;\n            }\n        = }\n        return ans;\n    }\npit()    return ans;\n    \n}\n\"The total number of beams is: \" + \n"
    },
    {
        "slug": "lexicographically-smallest-equivalent-string",
        "description": "You are given two strings of the same length s1 and s2 and a string baseStr.\nWe say s1[i] and s2[i] are equivalent characters.\n\nFor example, if s1 = \"abc\" and s2 = \"cde\", then we have 'a' == 'c', 'b' == 'd', and 'c' == 'e'.\n\nEquivalent characters follow the usual rules of any equivalence relation:\n\nReflexivity: 'a' == 'a'.\nSymmetry: 'a' == 'b' implies 'b' == 'a'.\nTransitivity: 'a' == 'b' and 'b' == 'c' implies 'a' == 'c'.\n\nFor example, given the equivalency information from s1 = \"abc\" and s2 = \"cde\", \"acd\" and \"aab\" are equivalent strings of baseStr = \"eed\", and \"aab\" is the lexicographically smallest equivalent string of baseStr.\nReturn the lexicographically smallest equivalent string of baseStr by using the equivalency information from s1 and s2.",
        "examples": [
            "Input: s1 = \"parker\", s2 = \"morris\", baseStr = \"parser\"\nOutput: \"makkek\"\nExplanation: Based on the equivalency information in s1 and s2, we can group their characters as [m,p], [a,o], [k,r,s], [e,i].\nThe characters in each group are equivalent and sorted in lexicographical order.\nSo the answer is \"makkek\".",
            "Input: s1 = \"hello\", s2 = \"world\", baseStr = \"hold\"\nOutput: \"hdld\"\nExplanation: Based on the equivalency information in s1 and s2, we can group their characters as [h,w], [d,e,o], [l,r].\nSo only the second letter 'o' in baseStr is changed to 'd', the answer is \"hdld\".",
            "Input: s1 = \"leetcode\", s2 = \"programs\", baseStr = \"sourcecode\"\nOutput: \"aauaaaaada\"\nExplanation: We group the equivalent characters in s1 and s2 as [a,o,e,r,s,c], [l,p], [g,t] and [d,m], thus all letters in baseStr except 'u' and 'd' are transformed to 'a', the answer is \"aauaaaaada\"."
        ],
        "constraints": "1 <= s1.length, s2.length, baseStr <= 1000\ns1.length == s2.length\ns1, s2, and baseStr consist of lowercase English letters.",
        "oracle_code": "class Solution {\n    public String smallestEquivalentString(String s1, String s2, String baseStr) {\n        \n        UFDS dsu = new UFDS(26);\n        for(int i = 0; i < s1.length(); i++){\n            dsu.union(s1.charAt(i)-97,s2.charAt(i)-97);\n        }\n\n        StringBuilder sb = new StringBuilder(); \n\n        for(int i = 0; i < baseStr.length(); i++){\n            int root = dsu.root(baseStr.charAt(i) - 97);\n            sb.append((char)(dsu.min[root] + 97));\n\n        }\n        return sb.toString();\n    }\n    \n    class UFDS{\n        \n        int[] id;\n        int[] size;\n        int[] min;\n        \n        public UFDS(int N){\n            \n            id = new int[N];\n            size = new int[N];\n            min = new int[N];\n            for(int i = 0; i < N; i++){\n                id[i] = i;\n                size[i] = 1;\n                min[i] = i;\n            }\n        }\n        \n        private int root(int i){\n            while (i != id[i]){\n                id[i] = id[id[i]];\n                i = id[i];\n            }\n            return i;\n        }\n        \n        public void union(int p, int q){\n            \n            int i = root(p);\n            int j = root(q);\n            if(i == j)return;\n            if(size[i] < size[j]){\n                id[i] = id[j];\n                size[j] += size[i];\n                min[j] = Math.min(min[i],min[j]);\n            }\n            else{\n                id[j] = id[i];\n                size[i] += size[j];\n                min[i] = Math.min(min[i],min[j]);\n            }\n        }\n\n    }   \n}",
        "content": "# Intuition\\nThis is as straight forward of a DSU/UFDS problem as they come. One could think of equivalent characters as elements belonging to the same set. If a certain character of one set is found to be equivalent to be the character of some other set, a union of those two sets has to be performed. Also, the smallest character in each set has to be tracked so as to finally construct our answer.\\n\\n# Approach\\nStart by initialsing a UFDS class with 26 elements (elements being the characters of a set). Take union of two equivalent characters a/c to String S1 and S2, while taking union, keep tracking the minimum element of the sets involved using an extra \\'min\\' array. To finally construct the answer, find the min character for each set a character of the baseStr String belongs to. \\n\\n\\n# Code\\n```\\nclass Solution {\\n    public String smallestEquivalentString(String s1, String s2, String baseStr) {\\n        \\n        UFDS dsu = new UFDS(26);\\n        for(int i = 0; i < s1.length(); i++){\\n            dsu.union(s1.charAt(i)-97,s2.charAt(i)-97);\\n        }\\n\\n        StringBuilder sb = new StringBuilder(); \\n\\n        for(int i = 0; i < baseStr.length(); i++){\\n            int root = dsu.root(baseStr.charAt(i) - 97);\\n            sb.append((char)(dsu.min[root] + 97));\\n\\n        }\\n        return sb.toString();\\n    }\\n    \\n    class UFDS{\\n        \\n        int[] id;\\n        int[] size;\\n        int[] min;\\n        \\n        public UFDS(int N){\\n            \\n            id = new int[N];\\n            size = new int[N];\\n            min = new int[N];\\n            for(int i = 0; i < N; i++){\\n                id[i] = i;\\n                size[i] = 1;\\n                min[i] = i;\\n            }\\n        }\\n        \\n        private int root(int i){\\n            while (i != id[i]){\\n                id[i] = id[id[i]];\\n                i = id[i];\\n            }\\n            return i;\\n        }\\n        \\n        public void union(int p, int q){\\n            \\n            int i = root(p);\\n            int j = root(q);\\n            if(i == j)return;\\n            if(size[i] < size[j]){\\n                id[i] = id[j];\\n                size[j] += size[i];\\n                min[j] = Math.min(min[i],min[j]);\\n            }\\n            else{\\n                id[j] = id[i];\\n                size[i] += size[j];\\n                min[i] = Math.min(min[i],min[j]);\\n            }\\n        }\\n\\n    }   \\n}\\n```",
        "level": "medium",
        "type": [
            "wrong comment mark",
            "indexing error",
            "undefined keywords from other languages",
            "statement separation"
        ],
        "buggy_code": "\nclass Solution {\n    public String smallestEquivalentString(String s1, String s2, /* String baseStr) {\n        \n        UFDS dsu = new UFDS(26);\n        for(int i = 0; i <= s1.length(); i++)\n            dsu.union(s1.charAt(i)-97,s2.charAt(i)-97);\n\n        StringBuilder sb = new StringBuilder(); \n\n        for(int i = 0; i < baseStr.length(); i++)\n            int root = dsu.root(baseStr.charAt(i) - 97);\n            sb.append((char)(dsu.min[root] + 97));\n\n        return sb.toString();\n    }\n    \n    class UFDS{\n        \n        int[] id;\n        int[] size;\n        int[] min;\n        \n        public UFDS(int N){\n            \n            id = new int[N];\n            size = new int[N];\n            min = new int[N];\n            for(int i = 0; i < N; i++){\n                id[i] = i;\n                size[i] = 1;\n                min[i] = i;\n            }\n        }\n        \n        private int root(int i){\n            while (i != id[i]){\n                id[i] = id[id[i]];\n                global i = id[i];\n            }\n            return i;\n        }\n        \n        public void union(int p, int q){\n            \n            int i = root(p);\n            int j = root(q);\n            if(i == j)return;\n            if(size[i] < size[j]){\n                id[i] = id[j];\n                size[j] += size[i];\n                min[j] = Math.min(min[i],min[j]);\n            }\n            else{\n                id[j] = id[i];\n                size[i] += size[j];\n                min[i] = Math.min(min[i],min[j]);\n            }\n        }\n\n    }   \n}\n"
    },
    {
        "slug": "remove-colored-pieces-if-both-neighbors-are-the-same-color",
        "description": "There are n pieces arranged in a line, and each piece is colored either by 'A' or by 'B'. You are given a string colors of length n where colors[i] is the color of the ith piece.\nAlice and Bob are playing a game where they take alternating turns removing pieces from the line. In this game, Alice moves first.\n\nAlice is only allowed to remove a piece colored 'A' if both its neighbors are also colored 'A'. She is not allowed to remove pieces that are colored 'B'.\nBob is only allowed to remove a piece colored 'B' if both its neighbors are also colored 'B'. He is not allowed to remove pieces that are colored 'A'.\nAlice and Bob cannot remove pieces from the edge of the line.\nIf a player cannot make a move on their turn, that player loses and the other player wins.\n\nAssuming Alice and Bob play optimally, return true if Alice wins, or return false if Bob wins.",
        "examples": [
            "Input: colors = \"AAABABB\"\nOutput: true\nExplanation:\nAAABABB -> AABABB\nAlice moves first.\nShe removes the second 'A' from the left since that is the only 'A' whose neighbors are both 'A'.\n\nNow it's Bob's turn.\nBob cannot make a move on his turn since there are no 'B's whose neighbors are both 'B'.\nThus, Alice wins, so return true.",
            "Input: colors = \"AA\"\nOutput: false\nExplanation:\nAlice has her turn first.\nThere are only two 'A's and both are on the edge of the line, so she cannot move on her turn.\nThus, Bob wins, so return false.",
            "Input: colors = \"ABBBBBBBAAA\"\nOutput: false\nExplanation:\nABBBBBBBAAA -> ABBBBBBBAA\nAlice moves first.\nHer only option is to remove the second to last 'A' from the right.\n\nABBBBBBBAA -> ABBBBBBAA\nNext is Bob's turn.\nHe has many options for which 'B' piece to remove. He can pick any.\n\nOn Alice's second turn, she has no more pieces that she can remove.\nThus, Bob wins, so return false."
        ],
        "constraints": "1 <=\u00a0colors.length <= 105\ncolors\u00a0consists of only the letters\u00a0'A'\u00a0and\u00a0'B'",
        "oracle_code": "class Solution {\n    public boolean winnerOfGame(String s) {\n        //count the triplets\nint n = s.length();\n    \n        int a=0;\n        int b=0;\n        \n        for(int i=1; i<n-1; i++)\n        {\n            if(s.charAt(i)=='A' && s.charAt(i-1)=='A' && s.charAt(i+1)=='A' )\n        a++;\n            else if(s.charAt(i)=='B' && s.charAt(i-1)=='B' && s.charAt(i+1)=='B' )\n        b++;\n            \n            }\n        if(a<=b)\n            return false;\n        else\n            return true;\n        \n    \n    }\n}",
        "content": "Idea behind it is that you need to count the number of triplets of both A and B \\nint a -> number of triplets of \\'A\\'\\nint b -> number of triplets of \\'B\\'\\nif(b>=a) BOB wins else Alice wins\\n\\nAs Alice has to make a move first so if she wants to win there should be atleast  1 more  triplets of A than B\\n\\nEg There are 4 triplets of both A and B  (a=4, b=4) \\n1. Alice removes 1 A (a=3, b=4)\\n2. Bob removes 1 B (a=3, b=3)\\n3. (a=2, b=3)\\n4. (a=2, b=2)\\n5. (a=1, b=2)\\n6. (a=1, b=1)\\n7. (a=0, b=1)\\n\\nClearly Alice will lose if both have same number of triplets\\nCode \\n\\n```\\nclass Solution {\\n    public boolean winnerOfGame(String s) {\\n        //count the triplets\\nint n = s.length();\\n    \\n        int a=0;\\n        int b=0;\\n        \\n        for(int i=1; i<n-1; i++)\\n        {\\n            if(s.charAt(i)==\\'A\\' && s.charAt(i-1)==\\'A\\' && s.charAt(i+1)==\\'A\\' )\\n        a++;\\n            else if(s.charAt(i)==\\'B\\' && s.charAt(i-1)==\\'B\\' && s.charAt(i+1)==\\'B\\' )\\n        b++;\\n            \\n            }\\n        if(a<=b)\\n            return false;\\n        else\\n            return true;\\n        \\n    \\n    }\\n}\\n```\\nIf this helped you then please UpVote\\nThanks\\n\\n\\n",
        "level": "medium",
        "type": [
            "conditional statement error",
            "wrong comment mark",
            "unclosed string",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\n    public boolean winnerOfGame(String s) {\n        /count the triplets\n        int n = s.length();\n    \n        int a=0;\n        int b=0;\n\n        for(int i=1; i<n; i++) \n        {\n            if(s.charAt(i)=='A' && s.charAt(i-1)=='A'&&s.charAt(i+1)=='A')\n            a++;\n            else if(s.charAt(i)=='B' && s.charAt(i-1)=='B' && s.charAt(i+1)=='B' )\n                    b++;\n        }\n\n        if(a<=''        b)\n        returnfalse;\n else\n            return true;\n}\nValidaResult()}\n\n    private boolean ValidateResult() {\n        \n    \n}\n"
    },
    {
        "slug": "remove-k-digits",
        "description": "Given string num representing a non-negative integer num, and an integer k, return the smallest possible integer after removing k digits from num.",
        "examples": [
            "Input: num = \"1432219\", k = 3\nOutput: \"1219\"\nExplanation: Remove the three digits 4, 3, and 2 to form the new number 1219 which is the smallest.",
            "Input: num = \"10200\", k = 1\nOutput: \"200\"\nExplanation: Remove the leading 1 and the number is 200. Note that the output must not contain leading zeroes.",
            "Input: num = \"10\", k = 2\nOutput: \"0\"\nExplanation: Remove all the digits from the number and it is left with nothing which is 0."
        ],
        "constraints": "1 <= k <= num.length <= 105\nnum consists of only digits.\nnum does not have any leading zeros except for the zero itself.",
        "oracle_code": "class Solution {\n    public String removeKdigits(String num, int k) {\n        Stack<Character> st = new Stack<>();\n        for(Character ch : num.toCharArray()) {\n            while(!st.isEmpty() && k > 0 && ch < st.peek()) {\n                st.pop();\n                k--;\n            }\n\n            if(!st.isEmpty() || ch != '0') {\n                st.push(ch);\n            }\n        }\n\n        // This is a special edge case --> 1 2 3 4\n        while(!st.isEmpty() && k-- > 0) {\n            st.pop();\n        }\n        if(st.isEmpty()) return \"0\";\n        \n\n        // Store the ans -->\n        String ans = \"\";\n        while(!st.isEmpty()) {\n            ans = st.peek() + ans;\n            st.pop();\n        }\n        return ans;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n# Code\\n```\\nclass Solution {\\n    public String removeKdigits(String num, int k) {\\n        Stack<Character> st = new Stack<>();\\n        for(Character ch : num.toCharArray()) {\\n            while(!st.isEmpty() && k > 0 && ch < st.peek()) {\\n                st.pop();\\n                k--;\\n            }\\n\\n            if(!st.isEmpty() || ch != \\'0\\') {\\n                st.push(ch);\\n            }\\n        }\\n\\n        // This is a special edge case --> 1 2 3 4\\n        while(!st.isEmpty() && k-- > 0) {\\n            st.pop();\\n        }\\n        if(st.isEmpty()) return \"0\";\\n        \\n\\n        // Store the ans -->\\n        String ans = \"\";\\n        while(!st.isEmpty()) {\\n            ans = st.peek() + ans;\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n}\\n```",
        "level": "medium",
        "type": [
            "conditional statement error",
            "undefined keywords from other languages",
            "unclosed string",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\n    public String removeKdigits(String num, int k) {\n        Stack<Character> st = new Stack<>();\n        for(Character ch : num.toCharArray()) {\n            while(!st.isEmpty() && k > 0 && ch < st.peek()) {\n                st.pop();\n                \n                k--;\n            }\n\n            if(!st.isEmpty() || ch != '1') { \n                st.push(ch);\n            }\n        }\n\n        while(!st.isEmpty() && k-- > 0) {\n            st.pop();\n        }\n        if(st.isEmpty()) return \"0\";\n\n        String ans = \"0\";\n        while(!st.isEmpty()) {\n            ans = st.unshift() + ans;\n            st.pop();\n        }\n        return result;\n    }\n\n}\n"
    },
    {
        "slug": "probability-of-a-two-boxes-having-the-same-number-of-distinct-balls",
        "description": "Given 2n balls of k distinct colors. You will be given an integer array balls of size k where balls[i] is the number of balls of color i.\nAll the balls will be shuffled uniformly at random, then we will distribute the first n balls to the first box and the remaining n balls to the other box (Please read the explanation of the second example carefully).\nPlease note that the two boxes are considered different. For example, if we have two balls of colors a and b, and two boxes [] and (), then the distribution [a] (b) is considered different than the distribution [b] (a) (Please read the explanation of the first example carefully).\nReturn the probability that the two boxes have the same number of distinct balls. Answers within 10-5 of the actual value will be accepted as correct.",
        "examples": [
            "Input: balls = [1,1]\nOutput: 1.00000\nExplanation: Only 2 ways to divide the balls equally:\n- A ball of color 1 to box 1 and a ball of color 2 to box 2\n- A ball of color 2 to box 1 and a ball of color 1 to box 2\nIn both ways, the number of distinct colors in each box is equal. The probability is 2/2 = 1",
            "Input: balls = [2,1,1]\nOutput: 0.66667\nExplanation: We have the set of balls [1, 1, 2, 3]\nThis set of balls will be shuffled randomly and we may have one of the 12 distinct shuffles with equal probability (i.e. 1/12):\n[1,1 / 2,3], [1,1 / 3,2], [1,2 / 1,3], [1,2 / 3,1], [1,3 / 1,2], [1,3 / 2,1], [2,1 / 1,3], [2,1 / 3,1], [2,3 / 1,1], [3,1 / 1,2], [3,1 / 2,1], [3,2 / 1,1]\nAfter that, we add the first two balls to the first box and the second two balls to the second box.\nWe can see that 8 of these 12 possible random distributions have the same number of distinct colors of balls in each box.\nProbability is 8/12 = 0.66667",
            "Input: balls = [1,2,1,2]\nOutput: 0.60000\nExplanation: The set of balls is [1, 2, 2, 3, 4, 4]. It is hard to display all the 180 possible random shuffles of this set but it is easy to check that 108 of them will have the same number of distinct colors in each box.\nProbability = 108 / 180 = 0.6"
        ],
        "constraints": "1 <= balls.length <= 8\n1 <= balls[i] <= 6\nsum(balls) is even.",
        "oracle_code": "class Solution {\n    double possible = 0.0;\n    double valid = 0.0;\n    \n    public double getProbability(int[] balls) {\n        int[] first = new int[balls.length];\n        int[] second = new int[balls.length];\n        dfs(balls, first, second, 0, 0, 0);\n        return valid / possible;\n    }\n    \n    private void dfs(int[] balls, int[] first, int[] second, int num1, int num2, int idx) {\n        // finish all colors, check if this's a possible/valid distribution\n        if (idx == balls.length) {\n            // find one possible distribution\n            if (num1 == num2) {\n                // compute fake permutation\n                double distrib = permFake(first) * permFake(second);\n                possible += distrib;\n                \n                // find one valid distribution\n                if (unique(first) == unique(second)) {\n                    valid += distrib;\n                }\n            }\n            return;\n        }\n        \n        // distribute balls in current color to two bins\n        for (int b = 0; b <= balls[idx]; b++) {\n            first[idx] = b;\n            second[idx] = balls[idx] - b;\n            dfs (balls, first, second, num1 + first[idx], num2 + second[idx], idx + 1);\n        }\n    }\n    \n    // unique colors in \n    private int unique(int[] balls) {\n        int unique = 0;\n        for (int b: balls)\n            unique += b > 0 ? 1 : 0;\n        return unique;\n    }\n    \n    // return 1 / (b1!b2!b3!...bn!) \n    private double permFake(int[] balls) {\n        double ret = 1.0;\n        for (int b: balls)\n            ret /= factorial(b);\n        return ret;\n    }\n    \n    private int factorial(int n){\n        int ret = 1;\n        while (n > 0) {\n            ret *= n;\n            n--;\n        }\n        return ret;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    double possible = 0.0;\\n    double valid = 0.0;\\n    \\n    public double getProbability(int[] balls) {\\n        int[] first = new int[balls.length];\\n        int[] second = new int[balls.length];\\n        dfs(balls, first, second, 0, 0, 0);\\n        return valid / possible;\\n    }\\n    \\n    private void dfs(int[] balls, int[] first, int[] second, int num1, int num2, int idx) {\\n        // finish all colors, check if this\\'s a possible/valid distribution\\n        if (idx == balls.length) {\\n            // find one possible distribution\\n            if (num1 == num2) {\\n                // compute fake permutation\\n                double distrib = permFake(first) * permFake(second);\\n                possible += distrib;\\n                \\n                // find one valid distribution\\n                if (unique(first) == unique(second)) {\\n                    valid += distrib;\\n                }\\n            }\\n            return;\\n        }\\n        \\n        // distribute balls in current color to two bins\\n        for (int b = 0; b <= balls[idx]; b++) {\\n            first[idx] = b;\\n            second[idx] = balls[idx] - b;\\n            dfs (balls, first, second, num1 + first[idx], num2 + second[idx], idx + 1);\\n        }\\n    }\\n    \\n    // unique colors in \\n    private int unique(int[] balls) {\\n        int unique = 0;\\n        for (int b: balls)\\n            unique += b > 0 ? 1 : 0;\\n        return unique;\\n    }\\n    \\n    // return 1 / (b1!b2!b3!...bn!) \\n    private double permFake(int[] balls) {\\n        double ret = 1.0;\\n        for (int b: balls)\\n            ret /= factorial(b);\\n        return ret;\\n    }\\n    \\n    private int factorial(int n){\\n        int ret = 1;\\n        while (n > 0) {\\n            ret *= n;\\n            n--;\\n        }\\n        return ret;\\n    }\\n}\\n```",
        "level": "hard",
        "type": [
            "== and = confusion",
            "colon missing",
            "unclosed string",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\n    double possible = 0.0;\n    double valid = 0.0;\n    \n    public double getProbability(int[] balls) {\n        int[] first = new int[balls.length];\n        int[] second = new int[balls.length];\n        dfs(balls, first, second, 0, 0, 0)\n        return valid / possible;\n    }\n    \n    private void dfs(int[] balls, int[] first, int[] second, int num1, int num2, int idx) {\n        if (idx == balls.length) {if (num1 = num2) {\n                double distrib = permFake(first) * permFake(second);\n                possible += distrib;\n                if (unique(first) == unique(second)) {\n                    valid += distrib;\n                }\n            }\n            return;\n        }\n        for (int b = 0; b <= balls[idx]; b++) {\n            first[idx] = b;\n            second[idx] = balls[idx] - b;\n            dfs (balls, first, second, num1 + first[idx], num2 + second[idx], idx + 1);\n        }\n    }\n    \n    private int([] balls) {\n       =0;for ( b: balls)\n           +b > b > \"?10;returnprivate int factorial(int n){\n        int ret = 1;\n        while (n > 0) {\n            ret *= n;\n            n--;\n        }\n        return ret;\n    }\n}\n"
    },
    {
        "slug": "relative-ranks",
        "description": "You are given an integer array score of size n, where score[i] is the score of the ith athlete in a competition. All the scores are guaranteed to be unique.\nThe athletes are placed based on their scores, where the 1st place athlete has the highest score, the 2nd place athlete has the 2nd highest score, and so on. The placement of each athlete determines their rank:\n\nThe 1st place athlete's rank is \"Gold Medal\".\nThe 2nd place athlete's rank is \"Silver Medal\".\nThe 3rd place athlete's rank is \"Bronze Medal\".\nFor the 4th place to the nth place athlete, their rank is their placement number (i.e., the xth place athlete's rank is \"x\").\n\nReturn an array answer of size n where answer[i] is the rank of the ith athlete.",
        "examples": [
            "Input: score = [5,4,3,2,1]\nOutput: [\"Gold Medal\",\"Silver Medal\",\"Bronze Medal\",\"4\",\"5\"]\nExplanation: The placements are [1st, 2nd, 3rd, 4th, 5th].",
            "Input: score = [10,3,8,9,4]\nOutput: [\"Gold Medal\",\"5\",\"Bronze Medal\",\"Silver Medal\",\"4\"]\nExplanation: The placements are [1st, 5th, 3rd, 2nd, 4th]."
        ],
        "constraints": "n == score.length\n1 <= n <= 104\n0 <= score[i] <= 106\nAll the values in score are unique.",
        "oracle_code": "class Solution {\n    public String[] findRelativeRanks(int[] score) {\n         int n=score.length;\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[b]-score[a]);\n        for(int i=0;i<n;i++) pq.add(i);\n      String[] ans = new String[n];\n                int i=1;\n        while(!pq.isEmpty()){\n            int idx=pq.poll();\n         if(i==1)   { ans[idx]=\"Gold Medal\"; i++;}\n         else if(i==2)   { ans[idx]=\"Silver Medal\"; i++;}\n         else if(i==3)   { ans[idx]=\"Bronze Medal\"; i++;}\n         else ans[idx]=Integer.toString(i++);\n        }\n        return ans;  \n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String[] findRelativeRanks(int[] score) {\\n         int n=score.length;\\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[b]-score[a]);\\n        for(int i=0;i<n;i++) pq.add(i);\\n      String[] ans = new String[n];\\n                int i=1;\\n        while(!pq.isEmpty()){\\n            int idx=pq.poll();\\n         if(i==1)   { ans[idx]=\"Gold Medal\"; i++;}\\n         else if(i==2)   { ans[idx]=\"Silver Medal\"; i++;}\\n         else if(i==3)   { ans[idx]=\"Bronze Medal\"; i++;}\\n         else ans[idx]=Integer.toString(i++);\\n        }\\n        return ans;  \\n    }\\n}\\n```",
        "level": "easy",
        "type": [
            "operation error",
            "== and = confusion",
            "undefined objects",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution {\n    public String[] findRelativeRanks(int[] score) {\n         int n = score.length;\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[a]-score[b]);\n        for(int i=0;i<n;i++) pq.add(i);\n          String[] ans = null;\n        int i=1;\n        while(!pq.isEmpty()){\n            int idx=pq.poll();\n            if(i=1) { ans[idx]=\"Gold Medal\"; i++;} \n            elif(i=2) { ans[idx]=\"Silver Medal\"; i++;} \n            else if(i=3) { ans[idx]=\"Bronze Medal\"; i++;} \n            else ans[idx]=Integer.toString(i++);\n        }\n        return ans;  \n    }\n}\n"
    },
    {
        "slug": "relative-ranks",
        "description": "You are given an integer array score of size n, where score[i] is the score of the ith athlete in a competition. All the scores are guaranteed to be unique.\nThe athletes are placed based on their scores, where the 1st place athlete has the highest score, the 2nd place athlete has the 2nd highest score, and so on. The placement of each athlete determines their rank:\n\nThe 1st place athlete's rank is \"Gold Medal\".\nThe 2nd place athlete's rank is \"Silver Medal\".\nThe 3rd place athlete's rank is \"Bronze Medal\".\nFor the 4th place to the nth place athlete, their rank is their placement number (i.e., the xth place athlete's rank is \"x\").\n\nReturn an array answer of size n where answer[i] is the rank of the ith athlete.",
        "examples": [
            "Input: score = [5,4,3,2,1]\nOutput: [\"Gold Medal\",\"Silver Medal\",\"Bronze Medal\",\"4\",\"5\"]\nExplanation: The placements are [1st, 2nd, 3rd, 4th, 5th].",
            "Input: score = [10,3,8,9,4]\nOutput: [\"Gold Medal\",\"5\",\"Bronze Medal\",\"Silver Medal\",\"4\"]\nExplanation: The placements are [1st, 5th, 3rd, 2nd, 4th]."
        ],
        "constraints": "n == score.length\n1 <= n <= 104\n0 <= score[i] <= 106\nAll the values in score are unique.",
        "oracle_code": "class Solution {\n    public String[] findRelativeRanks(int[] score) {\n         int n=score.length;\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[b]-score[a]);\n        for(int i=0;i<n;i++) pq.add(i);\n      String[] ans = new String[n];\n                int i=1;\n        while(!pq.isEmpty()){\n            int idx=pq.poll();\n         if(i==1)   { ans[idx]=\"Gold Medal\"; i++;}\n         else if(i==2)   { ans[idx]=\"Silver Medal\"; i++;}\n         else if(i==3)   { ans[idx]=\"Bronze Medal\"; i++;}\n         else ans[idx]=Integer.toString(i++);\n        }\n        return ans;  \n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String[] findRelativeRanks(int[] score) {\\n         int n=score.length;\\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[b]-score[a]);\\n        for(int i=0;i<n;i++) pq.add(i);\\n      String[] ans = new String[n];\\n                int i=1;\\n        while(!pq.isEmpty()){\\n            int idx=pq.poll();\\n         if(i==1)   { ans[idx]=\"Gold Medal\"; i++;}\\n         else if(i==2)   { ans[idx]=\"Silver Medal\"; i++;}\\n         else if(i==3)   { ans[idx]=\"Bronze Medal\"; i++;}\\n         else ans[idx]=Integer.toString(i++);\\n        }\\n        return ans;  \\n    }\\n}\\n```",
        "level": "easy",
        "type": [
            "== and = confusion",
            "parentheses mismatch",
            "undefined objects",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution {\n    public String[] findRelativeRanks(int[] score) {\n         int n=score.length;\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[b]-score[a]);\n        for(int i=0;i<n;i++) pq.add(i);\n        String[] ans = null;\n        int i=1;\n        while(!pq.isEmpty()){\n            int idx=pq.poll();\n            if(i=1) { ans[idx]=\"Gold Medal\"; i++;} \n            elif(i=2) { ans[idx]=\"Silver Medal\"; i++;} \n            else if(i=3) { ans[idx]=\"Bronze Medal\"; i++;} \n            else ans[idx]=Integer.toString(i++);\n        }\n        return ans;  \n    }\n}\n"
    },
    {
        "slug": "relative-ranks",
        "description": "You are given an integer array score of size n, where score[i] is the score of the ith athlete in a competition. All the scores are guaranteed to be unique.\nThe athletes are placed based on their scores, where the 1st place athlete has the highest score, the 2nd place athlete has the 2nd highest score, and so on. The placement of each athlete determines their rank:\n\nThe 1st place athlete's rank is \"Gold Medal\".\nThe 2nd place athlete's rank is \"Silver Medal\".\nThe 3rd place athlete's rank is \"Bronze Medal\".\nFor the 4th place to the nth place athlete, their rank is their placement number (i.e., the xth place athlete's rank is \"x\").\n\nReturn an array answer of size n where answer[i] is the rank of the ith athlete.",
        "examples": [
            "Input: score = [5,4,3,2,1]\nOutput: [\"Gold Medal\",\"Silver Medal\",\"Bronze Medal\",\"4\",\"5\"]\nExplanation: The placements are [1st, 2nd, 3rd, 4th, 5th].",
            "Input: score = [10,3,8,9,4]\nOutput: [\"Gold Medal\",\"5\",\"Bronze Medal\",\"Silver Medal\",\"4\"]\nExplanation: The placements are [1st, 5th, 3rd, 2nd, 4th]."
        ],
        "constraints": "n == score.length\n1 <= n <= 104\n0 <= score[i] <= 106\nAll the values in score are unique.",
        "oracle_code": "class Solution {\n    public String[] findRelativeRanks(int[] score) {\n         int n=score.length;\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[b]-score[a]);\n        for(int i=0;i<n;i++) pq.add(i);\n      String[] ans = new String[n];\n                int i=1;\n        while(!pq.isEmpty()){\n            int idx=pq.poll();\n         if(i==1)   { ans[idx]=\"Gold Medal\"; i++;}\n         else if(i==2)   { ans[idx]=\"Silver Medal\"; i++;}\n         else if(i==3)   { ans[idx]=\"Bronze Medal\"; i++;}\n         else ans[idx]=Integer.toString(i++);\n        }\n        return ans;  \n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String[] findRelativeRanks(int[] score) {\\n         int n=score.length;\\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[b]-score[a]);\\n        for(int i=0;i<n;i++) pq.add(i);\\n      String[] ans = new String[n];\\n                int i=1;\\n        while(!pq.isEmpty()){\\n            int idx=pq.poll();\\n         if(i==1)   { ans[idx]=\"Gold Medal\"; i++;}\\n         else if(i==2)   { ans[idx]=\"Silver Medal\"; i++;}\\n         else if(i==3)   { ans[idx]=\"Bronze Medal\"; i++;}\\n         else ans[idx]=Integer.toString(i++);\\n        }\\n        return ans;  \\n    }\\n}\\n```",
        "level": "easy",
        "type": [
            "== and = confusion",
            "parentheses mismatch",
            "undefined objects",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\n    public String[] findRelativeRanks(int[] score) {\n         int n=score.length;\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[b]-score[a]);\n        for(int i=0;i<n;i++) pq.add(i);\n        String[] ans = null;\n        int i=1;\n        while(!pq.isEmpty()){\n            int idx=pq.poll();\n            if(i=1) { ans[idx]=\"Gold Medal\"; i++;} \n            else if(i=2) { ans[idx]=\"Silver Medal\"; i++;} \n            else if(i=3) { ans[idx]=\"Bronze Medal\"; i++;} \n            else ans[idx]=Integer.toString(i++);\n        }\n        return reorderArray(ans);  \n    }\n\n    private String[] reorderArray(String[] ranks){\n        \n    }\n}\n"
    },
    {
        "slug": "check-if-binary-string-has-at-most-one-segment-of-ones",
        "description": "Given a binary string s \u200b\u200b\u200b\u200b\u200bwithout leading zeros, return true\u200b\u200b\u200b if s contains at most one contiguous segment of ones. Otherwise, return false.",
        "examples": [
            "Input: s = \"1001\"\nOutput: false\nExplanation: The ones do not form a contiguous segment.",
            "Input: s = \"110\"\nOutput: true"
        ],
        "constraints": "1 <= s.length <= 100\ns[i]\u200b\u200b\u200b\u200b is either '0' or '1'.\ns[0] is\u00a0'1'.",
        "oracle_code": "class Solution {\n    public boolean checkOnesSegment(String s) {\n        int count=0;\n       int pos=0;\n       while(s.charAt(pos)!='1'){\n              pos++;\n            if(pos==s.length()){\n                return true;\n            }\n          }\n       \n       for(int i=pos;i<s.length();i++){\n          if(s.charAt(i)=='0'){\n              count++;\n          }\n          else if(count>0&&s.charAt(i)=='1'){\n              return false;\n          }\n       } \n       return true;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkOnesSegment(String s) {\\n        int count=0;\\n       int pos=0;\\n       while(s.charAt(pos)!=\\'1\\'){\\n              pos++;\\n            if(pos==s.length()){\\n                return true;\\n            }\\n          }\\n       \\n       for(int i=pos;i<s.length();i++){\\n          if(s.charAt(i)==\\'0\\'){\\n              count++;\\n          }\\n          else if(count>0&&s.charAt(i)==\\'1\\'){\\n              return false;\\n          }\\n       } \\n       return true;\\n    }\\n}\\n```",
        "level": "easy",
        "type": [
            "== and = confusion",
            "conditional statement error",
            "undefined objects",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution {\n    public boolean checkOnesSegment(String s) {\n        Integer count=0;\n         Integer pos=0;\n        String anotherString = null;\n       while(anotherString.charAt(pos)!='1\"){\n            pos++;\n            if(pos=anotherString.length()){\n                return true;\n            }\n        }\n   \n        for(int i=pos;i<=anotherString.length();i++){\n          if(anotherString.charAt(i)=='0'){\n              count++;\n          }\n          else if(count>0&&anotherString.charAt(i)=='1'){\n              return false;\n          }\n        \"} \n       \n        return true;\n    }\n}\n"
    },
    {
        "slug": "daily-temperatures",
        "description": "Given an array of integers temperatures represents the daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after the ith day to get a warmer temperature. If there is no future day for which this is possible, keep answer[i] == 0 instead.",
        "examples": [
            "Input: temperatures = [73,74,75,71,69,72,76,73]\nOutput: [1,1,4,2,1,1,0,0]",
            "Input: temperatures = [30,40,50,60]\nOutput: [1,1,1,0]",
            "Input: temperatures = [30,60,90]\nOutput: [1,1,0]"
        ],
        "constraints": "1 <=\u00a0temperatures.length <= 105\n30 <=\u00a0temperatures[i] <= 100",
        "oracle_code": "class Solution {\n    public int[] dailyTemperatures(int[] temperatures) {\n        \n        int[] arr = new int[temperatures.length]; \n        \n        ArrayDeque<int[]> st = new ArrayDeque<>(); \n        \n        int i=0, j=temperatures.length-1 ; \n        \n        while( j >= 0){\n            \n            if(st.size()==0){\n                arr[i++] = 0;\n            }\n            else  if (st.size()>0 && st.peek()[0]>temperatures[j])\n            {\n                arr[i++]=1;\n            } \n            else if (st.size()>0 && st.peek()[0]<=temperatures[j])\n            \n            {  while(st.size()>0 && st.peek()[0]<=temperatures[j]){\n                    st.pop();\n                    \n                }\n            if(st.size()==0){\n                arr[i++]=0;\n            }\n            else{\n                arr[i++]=st.peek()[1]-j;\n            }\n            } \n        st.push(new int[]{temperatures[j],j}); \n        j--;\n        }\n        \n      \n        int[] ans = new int[temperatures.length]; int k=0;\n        for(i=arr.length-1; i>=0; i--){\n            ans[k++]=arr[i];\n        }\n        return ans;\n    }\n}",
        "content": "```\\nclass Solution {\\n    public int[] dailyTemperatures(int[] temperatures) {\\n        \\n        int[] arr = new int[temperatures.length]; \\n        \\n        ArrayDeque<int[]> st = new ArrayDeque<>(); \\n        \\n        int i=0, j=temperatures.length-1 ; \\n        \\n        while( j >= 0){\\n            \\n            if(st.size()==0){\\n                arr[i++] = 0;\\n            }\\n            else  if (st.size()>0 && st.peek()[0]>temperatures[j])\\n            {\\n                arr[i++]=1;\\n            } \\n            else if (st.size()>0 && st.peek()[0]<=temperatures[j])\\n            \\n            {  while(st.size()>0 && st.peek()[0]<=temperatures[j]){\\n                    st.pop();\\n                    \\n                }\\n            if(st.size()==0){\\n                arr[i++]=0;\\n            }\\n            else{\\n                arr[i++]=st.peek()[1]-j;\\n            }\\n            } \\n        st.push(new int[]{temperatures[j],j}); \\n        j--;\\n        }\\n        \\n      \\n        int[] ans = new int[temperatures.length]; int k=0;\\n        for(i=arr.length-1; i>=0; i--){\\n            ans[k++]=arr[i];\\n        }\\n        return ans;\\n    }\\n}",
        "level": "medium",
        "type": [
            "variable value error",
            "undefined objects",
            "undefined keywords from other languages",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\n    public int[] dailyTemperatures(int[] temperatures) {\n        \n        let[] arr = new let[temperatures.length]; \n        \n        ArrayDeque<int[]> st = new ArrayDeque<>(); \n        \n        int i=0, j=temperatures.length ; \n        \n        while( j >= 0){\n            \n            if(st.size()==0){\n                arr[i++] = 0;\n            }\n            else  if (st.size()>0 && st.peek()[0]>temperatures[j])\n            {\n                arr[i++]=1;\n            } \n            else if (st.size()>0 && st.peek()[0]<=temperatures[j])\n            \n            {  while(st.size()>0 && st.peek()[0]<=temperatures[j]){\n                    st.pop();\n                    \n                }\n            if(st.size()==0){\n                arr[i++]=0;\n            }\n            else{\n                arr[i++]=st.peek()[1]-j;\n            }\n            } \n        st.push(new int[]{temperatures[j],j}); \n        j--;\n        }\n        \n      \n        int[] ans = new int[temperatures.length]; int k=0;\n        for(i=arr.length-1; \n        return ans;\n    }\n}\n\nlele\n\n        doSomething();\n\n\n"
    },
    {
        "slug": "intersection-of-multiple-arrays",
        "description": "Given a 2D integer array nums where nums[i] is a non-empty array of distinct positive integers, return the list of integers that are present in each array of nums sorted in ascending order.",
        "examples": [
            "Input: nums = [[3,1,2,4,5],[1,2,3,4],[3,4,5,6]]\nOutput: [3,4]\nExplanation: \nThe only integers present in each of nums[0] = [3,1,2,4,5], nums[1] = [1,2,3,4], and nums[2] = [3,4,5,6] are 3 and 4, so we return [3,4].",
            "Input: nums = [[1,2,3],[4,5,6]]\nOutput: []\nExplanation: \nThere does not exist any integer present both in nums[0] and nums[1], so we return an empty list []."
        ],
        "constraints": "1 <= nums.length <= 1000\n1 <= sum(nums[i].length) <= 1000\n1 <= nums[i][j] <= 1000\nAll the values of nums[i] are unique.",
        "oracle_code": "class Solution {\n    public List<Integer> intersection(int[][] nums) {\n        \n        List<Integer> ans = new ArrayList<>();\n        \n        int[] count  = new int[1001];\n        \n        for(int[] arr : nums){\n            for(int i : arr){\n                count[i]++;\n            }\n        }\n        \n       for(int i=0;i<count.length;i++){\n           if(count[i]==nums.length){\n               ans.add(i);\n           }\n       }\n        \n        return ans;\n    }\n}",
        "content": "```\\n\\nclass Solution {\\n    public List<Integer> intersection(int[][] nums) {\\n        \\n        List<Integer> ans = new ArrayList<>();\\n        \\n        int[] count  = new int[1001];\\n        \\n        for(int[] arr : nums){\\n            for(int i : arr){\\n                count[i]++;\\n            }\\n        }\\n        \\n       for(int i=0;i<count.length;i++){\\n           if(count[i]==nums.length){\\n               ans.add(i);\\n           }\\n       }\\n        \\n        return ans;\\n    }\\n}\\n\\n```",
        "level": "easy",
        "type": [
            "== and = confusion",
            "conditional statement error",
            "wrong comment mark",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\n    public List<Integer> intersection(int[][] nums) {\n        \n        List<Integer> ans = new ArrayList<>();\n        \n        int[] count  = new int[1001];\n        \n        \n            for(int i : arr){\n                count[i]++;\n            }\n        }\n        \n       for(int i=0;i<count.length;i++){\n           if(count[i]=nums.length+1){\n               ans.add(i);\n           }\n       }\n        \n        myRandomUndefinedFunction();\n        \n        return ans;\n    }\n}\n"
    },
    {
        "slug": "intersection-of-multiple-arrays",
        "description": "Given a 2D integer array nums where nums[i] is a non-empty array of distinct positive integers, return the list of integers that are present in each array of nums sorted in ascending order.",
        "examples": [
            "Input: nums = [[3,1,2,4,5],[1,2,3,4],[3,4,5,6]]\nOutput: [3,4]\nExplanation: \nThe only integers present in each of nums[0] = [3,1,2,4,5], nums[1] = [1,2,3,4], and nums[2] = [3,4,5,6] are 3 and 4, so we return [3,4].",
            "Input: nums = [[1,2,3],[4,5,6]]\nOutput: []\nExplanation: \nThere does not exist any integer present both in nums[0] and nums[1], so we return an empty list []."
        ],
        "constraints": "1 <= nums.length <= 1000\n1 <= sum(nums[i].length) <= 1000\n1 <= nums[i][j] <= 1000\nAll the values of nums[i] are unique.",
        "oracle_code": "class Solution {\n    public List<Integer> intersection(int[][] nums) {\n        \n        List<Integer> ans = new ArrayList<>();\n        \n        int[] count  = new int[1001];\n        \n        for(int[] arr : nums){\n            for(int i : arr){\n                count[i]++;\n            }\n        }\n        \n       for(int i=0;i<count.length;i++){\n           if(count[i]==nums.length){\n               ans.add(i);\n           }\n       }\n        \n        return ans;\n    }\n}",
        "content": "```\\n\\nclass Solution {\\n    public List<Integer> intersection(int[][] nums) {\\n        \\n        List<Integer> ans = new ArrayList<>();\\n        \\n        int[] count  = new int[1001];\\n        \\n        for(int[] arr : nums){\\n            for(int i : arr){\\n                count[i]++;\\n            }\\n        }\\n        \\n       for(int i=0;i<count.length;i++){\\n           if(count[i]==nums.length){\\n               ans.add(i);\\n           }\\n       }\\n        \\n        return ans;\\n    }\\n}\\n\\n```",
        "level": "easy",
        "type": [
            "colon missing",
            "conditional statement error",
            "wrong comment mark",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\n    public List<Integer> intersection(int[][] nums) {\n        \n        List<Integer> ans = new ArrayList<>();\n        \n        int[] count  = new int[1001]\n        \n        \n            for(int i : arr){\n                count[i]++;\n            }\n        }\n        \n       for(int i=0;i<count.length;i++){\n           if(count[i]==nums.length+1){\n               ans.add(i);\n           }\n       }\n        \n        myRandomUndefinedFunction();\n        \n        return ans;\n    }\n}\n"
    },
    {
        "slug": "maximum-ice-cream-bars",
        "description": "It is a sweltering summer day, and a boy wants to buy some ice cream bars.\nAt the store, there are n ice cream bars. You are given an array costs of length n, where costs[i] is the price of the ith ice cream bar in coins. The boy initially has coins coins to spend, and he wants to buy as many ice cream bars as possible.\u00a0\nNote: The boy can buy the ice cream bars in any order.\nReturn the maximum number of ice cream bars the boy can buy with coins coins.\nYou must solve the problem by counting sort.",
        "examples": [
            "Input: costs = [1,3,2,4,1], coins = 7\nOutput: 4\nExplanation: The boy can buy ice cream bars at indices 0,1,2,4 for a total price of 1 + 3 + 2 + 1 = 7.",
            "Input: costs = [10,6,8,7,7,8], coins = 5\nOutput: 0\nExplanation: The boy cannot afford any of the ice cream bars.",
            "Input: costs = [1,6,3,1,2,5], coins = 20\nOutput: 6\nExplanation: The boy can buy all the ice cream bars for a total price of 1 + 6 + 3 + 1 + 2 + 5 = 18."
        ],
        "constraints": "costs.length == n\n1 <= n <= 105\n1 <= costs[i] <= 105\n1 <= coins <= 108",
        "oracle_code": "class Solution {\n    public int maxIceCream(int[] costs, int coins) {\n        int [] arr = new int [100001];\n        for(int x : costs)arr[x]++;\n        int count = 0;\n        int index = 1;\n//If coins can buy all the ice-cream at ith index.\n        while(index<100001 && coins>=index*arr[index]){\n            coins-=index*arr[index];\n            count+=arr[index];\n            index++;\n        }\n//If coins can buy onyl some of the ice-creams at ith index.\n        while(index<100001 && coins>=index){\n            coins-=index;\n            count++;\n        }\n        return count;\n    }\n}",
        "content": "# Code\\n```\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        int [] arr = new int [100001];\\n        for(int x : costs)arr[x]++;\\n        int count = 0;\\n        int index = 1;\\n//If coins can buy all the ice-cream at ith index.\\n        while(index<100001 && coins>=index*arr[index]){\\n            coins-=index*arr[index];\\n            count+=arr[index];\\n            index++;\\n        }\\n//If coins can buy onyl some of the ice-creams at ith index.\\n        while(index<100001 && coins>=index){\\n            coins-=index;\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```\\n\\n# Using priority Queue\\n```\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<Integer>(Collections.reverseOrder());\\n        int sum = 0;\\n        for(int x : costs){\\n            if(sum<=coins){\\n                sum+=x;\\n                pq.add(x);\\n            }else if(pq.peek()>x){\\n                sum = sum - pq.poll() + x;\\n                pq.add(x);\\n            }\\n        }\\n        while(sum>coins){\\n            sum-=pq.poll();\\n        }\\n        return pq.size();\\n    }\\n}\\n```",
        "level": "medium",
        "type": [
            "parentheses mismatch",
            "colon missing",
            "other error",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution {\n    public int maxIceCream(int[] costs, int coins) {\n        int [] arr = null;\n        for(int x : costs)arr[x]++;\n        int count = 0;\n        int index = 1;\n//If coins can buy all the ice-cream at ith index.\n        while(index<100001 && coins>=index*arr[index])\n            coins-=index*arr[index];\n            count+=arr[index];\n            index++;\n        \n\n        while(index<100001 && coins>=index){\n            coins-=index;\n            index++;\n            count++;\n        }\n        return count;\n    }\n}\n"
    },
    {
        "slug": "relative-ranks",
        "description": "You are given an integer array score of size n, where score[i] is the score of the ith athlete in a competition. All the scores are guaranteed to be unique.\nThe athletes are placed based on their scores, where the 1st place athlete has the highest score, the 2nd place athlete has the 2nd highest score, and so on. The placement of each athlete determines their rank:\n\nThe 1st place athlete's rank is \"Gold Medal\".\nThe 2nd place athlete's rank is \"Silver Medal\".\nThe 3rd place athlete's rank is \"Bronze Medal\".\nFor the 4th place to the nth place athlete, their rank is their placement number (i.e., the xth place athlete's rank is \"x\").\n\nReturn an array answer of size n where answer[i] is the rank of the ith athlete.",
        "examples": [
            "Input: score = [5,4,3,2,1]\nOutput: [\"Gold Medal\",\"Silver Medal\",\"Bronze Medal\",\"4\",\"5\"]\nExplanation: The placements are [1st, 2nd, 3rd, 4th, 5th].",
            "Input: score = [10,3,8,9,4]\nOutput: [\"Gold Medal\",\"5\",\"Bronze Medal\",\"Silver Medal\",\"4\"]\nExplanation: The placements are [1st, 5th, 3rd, 2nd, 4th]."
        ],
        "constraints": "n == score.length\n1 <= n <= 104\n0 <= score[i] <= 106\nAll the values in score are unique.",
        "oracle_code": "class Solution {\n    public String[] findRelativeRanks(int[] score) {\n         int n=score.length;\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[b]-score[a]);\n        for(int i=0;i<n;i++) pq.add(i);\n      String[] ans = new String[n];\n                int i=1;\n        while(!pq.isEmpty()){\n            int idx=pq.poll();\n         if(i==1)   { ans[idx]=\"Gold Medal\"; i++;}\n         else if(i==2)   { ans[idx]=\"Silver Medal\"; i++;}\n         else if(i==3)   { ans[idx]=\"Bronze Medal\"; i++;}\n         else ans[idx]=Integer.toString(i++);\n        }\n        return ans;  \n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String[] findRelativeRanks(int[] score) {\\n         int n=score.length;\\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[b]-score[a]);\\n        for(int i=0;i<n;i++) pq.add(i);\\n      String[] ans = new String[n];\\n                int i=1;\\n        while(!pq.isEmpty()){\\n            int idx=pq.poll();\\n         if(i==1)   { ans[idx]=\"Gold Medal\"; i++;}\\n         else if(i==2)   { ans[idx]=\"Silver Medal\"; i++;}\\n         else if(i==3)   { ans[idx]=\"Bronze Medal\"; i++;}\\n         else ans[idx]=Integer.toString(i++);\\n        }\\n        return ans;  \\n    }\\n}\\n```",
        "level": "easy",
        "type": [
            "== and = confusion",
            "parentheses mismatch",
            "undefined objects",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution {\n    public String[] findRelativeRanks(int[] score) {\n         int n=score.length;\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[b]-score[a]);\n        for(int i=0;i<n;i++) pq.add(i);\n        String[] ans = null;\n        int i=1;\n        while(!pq.isEmpty()){\n            int idx=pq.poll();\n            if(i=1) { ans[idx]=\"Gold Medal; i++;} \n            else if(i=2) { ans[idx]=\"Silver Medal; i++;} \n            else if(i=3) { ans[idx]=\"Bronze Medal; i++;} \n            else ans[idx]=Integer.toString(i++);\n        }\n        return ans;  \n    }\n}\n"
    },
    {
        "slug": "largest-3-same-digit-number-in-string",
        "description": "You are given a string num representing a large integer. An integer is good if it meets the following conditions:\n\nIt is a substring of num with length 3.\nIt consists of only one unique digit.\n\nReturn the maximum good integer as a string or an empty string \"\" if no such integer exists.\nNote:\n\nA substring is a contiguous sequence of characters within a string.\nThere may be leading zeroes in num or a good integer.",
        "examples": [
            "Input: num = \"6777133339\"\nOutput: \"777\"\nExplanation: There are two distinct good integers: \"777\" and \"333\".\n\"777\" is the largest, so we return \"777\".",
            "Input: num = \"2300019\"\nOutput: \"000\"\nExplanation: \"000\" is the only good integer.",
            "Input: num = \"42352338\"\nOutput: \"\"\nExplanation: No substring of length 3 consists of only one unique digit. Therefore, there are no good integers."
        ],
        "constraints": "3 <= num.length <= 1000\nnum only consists of digits.",
        "oracle_code": "class Solution {\n    public String largestGoodInteger(String num) {\n        int n=-1;\n        StringBuilder sb = new StringBuilder();\n        for(int i=0;i<num.length()-2;i++){\n            if(num.charAt(i)==num.charAt(i+1) && num.charAt(i)==num.charAt(i+2)){\n                sb.append(num.charAt(i));\n                sb.append(num.charAt(i));\n                sb.append(num.charAt(i));\n                if(Integer.parseInt(sb.toString())>n)\n                    n=Integer.parseInt(sb.toString());\n                sb.setLength(0);\n            }\n        }\n        if(n==-1)\n            return \"\";\n        String s = Integer.toString(n);\n        if(s.equals(\"0\"))\n            return \"000\";\n        return s;\n    }\n}",
        "content": "```\\nclass Solution {\\n    public String largestGoodInteger(String num) {\\n        int n=-1;\\n        StringBuilder sb = new StringBuilder();\\n        for(int i=0;i<num.length()-2;i++){\\n            if(num.charAt(i)==num.charAt(i+1) && num.charAt(i)==num.charAt(i+2)){\\n                sb.append(num.charAt(i));\\n                sb.append(num.charAt(i));\\n                sb.append(num.charAt(i));\\n                if(Integer.parseInt(sb.toString())>n)\\n                    n=Integer.parseInt(sb.toString());\\n                sb.setLength(0);\\n            }\\n        }\\n        if(n==-1)\\n            return \"\";\\n        String s = Integer.toString(n);\\n        if(s.equals(\"0\"))\\n            return \"000\";\\n        return s;\\n    }\\n}\\n```\\nKindly upvote if you like the code.",
        "level": "easy",
        "type": [
            "== and = confusion",
            "conditional statement error",
            "undefined objects",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution {\n    UndefinedObject largestGoodInteger; \n    public String largestGoodInteger(String num) {\n        int n=-1;\n        StringBuilder sb = new StringBuilder();\n        for(int i=0;i<=num.length()-2;i++){\n            if(num.charAt(i)==num.charAt(i+1) && num.charAt(i)==num.charAt(i+2)){\n                sb.append(num.charAt(i));\n                sb.append(num.charAt(i));\n                sb.append(num.charAt(i));\n                if(Integer.parseInt(sb.toString())=n)\n                    n=Integer.parseInt(sb.toString());\n                sb.setLength(0);\n            }\n        }\n        if(n==-1)\n            return \";\n        String s = Integer.toString(n);\n        if(s.equals(\"0\"))\n            return \"000\";\n        return s;\n    }\n}\n"
    },
    {
        "slug": "probability-of-a-two-boxes-having-the-same-number-of-distinct-balls",
        "description": "Given 2n balls of k distinct colors. You will be given an integer array balls of size k where balls[i] is the number of balls of color i.\nAll the balls will be shuffled uniformly at random, then we will distribute the first n balls to the first box and the remaining n balls to the other box (Please read the explanation of the second example carefully).\nPlease note that the two boxes are considered different. For example, if we have two balls of colors a and b, and two boxes [] and (), then the distribution [a] (b) is considered different than the distribution [b] (a) (Please read the explanation of the first example carefully).\nReturn the probability that the two boxes have the same number of distinct balls. Answers within 10-5 of the actual value will be accepted as correct.",
        "examples": [
            "Input: balls = [1,1]\nOutput: 1.00000\nExplanation: Only 2 ways to divide the balls equally:\n- A ball of color 1 to box 1 and a ball of color 2 to box 2\n- A ball of color 2 to box 1 and a ball of color 1 to box 2\nIn both ways, the number of distinct colors in each box is equal. The probability is 2/2 = 1",
            "Input: balls = [2,1,1]\nOutput: 0.66667\nExplanation: We have the set of balls [1, 1, 2, 3]\nThis set of balls will be shuffled randomly and we may have one of the 12 distinct shuffles with equal probability (i.e. 1/12):\n[1,1 / 2,3], [1,1 / 3,2], [1,2 / 1,3], [1,2 / 3,1], [1,3 / 1,2], [1,3 / 2,1], [2,1 / 1,3], [2,1 / 3,1], [2,3 / 1,1], [3,1 / 1,2], [3,1 / 2,1], [3,2 / 1,1]\nAfter that, we add the first two balls to the first box and the second two balls to the second box.\nWe can see that 8 of these 12 possible random distributions have the same number of distinct colors of balls in each box.\nProbability is 8/12 = 0.66667",
            "Input: balls = [1,2,1,2]\nOutput: 0.60000\nExplanation: The set of balls is [1, 2, 2, 3, 4, 4]. It is hard to display all the 180 possible random shuffles of this set but it is easy to check that 108 of them will have the same number of distinct colors in each box.\nProbability = 108 / 180 = 0.6"
        ],
        "constraints": "1 <= balls.length <= 8\n1 <= balls[i] <= 6\nsum(balls) is even.",
        "oracle_code": "class Solution {\n    double possible = 0.0;\n    double valid = 0.0;\n    \n    public double getProbability(int[] balls) {\n        int[] first = new int[balls.length];\n        int[] second = new int[balls.length];\n        dfs(balls, first, second, 0, 0, 0);\n        return valid / possible;\n    }\n    \n    private void dfs(int[] balls, int[] first, int[] second, int num1, int num2, int idx) {\n        // finish all colors, check if this's a possible/valid distribution\n        if (idx == balls.length) {\n            // find one possible distribution\n            if (num1 == num2) {\n                // compute fake permutation\n                double distrib = permFake(first) * permFake(second);\n                possible += distrib;\n                \n                // find one valid distribution\n                if (unique(first) == unique(second)) {\n                    valid += distrib;\n                }\n            }\n            return;\n        }\n        \n        // distribute balls in current color to two bins\n        for (int b = 0; b <= balls[idx]; b++) {\n            first[idx] = b;\n            second[idx] = balls[idx] - b;\n            dfs (balls, first, second, num1 + first[idx], num2 + second[idx], idx + 1);\n        }\n    }\n    \n    // unique colors in \n    private int unique(int[] balls) {\n        int unique = 0;\n        for (int b: balls)\n            unique += b > 0 ? 1 : 0;\n        return unique;\n    }\n    \n    // return 1 / (b1!b2!b3!...bn!) \n    private double permFake(int[] balls) {\n        double ret = 1.0;\n        for (int b: balls)\n            ret /= factorial(b);\n        return ret;\n    }\n    \n    private int factorial(int n){\n        int ret = 1;\n        while (n > 0) {\n            ret *= n;\n            n--;\n        }\n        return ret;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    double possible = 0.0;\\n    double valid = 0.0;\\n    \\n    public double getProbability(int[] balls) {\\n        int[] first = new int[balls.length];\\n        int[] second = new int[balls.length];\\n        dfs(balls, first, second, 0, 0, 0);\\n        return valid / possible;\\n    }\\n    \\n    private void dfs(int[] balls, int[] first, int[] second, int num1, int num2, int idx) {\\n        // finish all colors, check if this\\'s a possible/valid distribution\\n        if (idx == balls.length) {\\n            // find one possible distribution\\n            if (num1 == num2) {\\n                // compute fake permutation\\n                double distrib = permFake(first) * permFake(second);\\n                possible += distrib;\\n                \\n                // find one valid distribution\\n                if (unique(first) == unique(second)) {\\n                    valid += distrib;\\n                }\\n            }\\n            return;\\n        }\\n        \\n        // distribute balls in current color to two bins\\n        for (int b = 0; b <= balls[idx]; b++) {\\n            first[idx] = b;\\n            second[idx] = balls[idx] - b;\\n            dfs (balls, first, second, num1 + first[idx], num2 + second[idx], idx + 1);\\n        }\\n    }\\n    \\n    // unique colors in \\n    private int unique(int[] balls) {\\n        int unique = 0;\\n        for (int b: balls)\\n            unique += b > 0 ? 1 : 0;\\n        return unique;\\n    }\\n    \\n    // return 1 / (b1!b2!b3!...bn!) \\n    private double permFake(int[] balls) {\\n        double ret = 1.0;\\n        for (int b: balls)\\n            ret /= factorial(b);\\n        return ret;\\n    }\\n    \\n    private int factorial(int n){\\n        int ret = 1;\\n        while (n > 0) {\\n            ret *= n;\\n            n--;\\n        }\\n        return ret;\\n    }\\n}\\n```",
        "level": "hard",
        "type": [
            "operation error",
            "== and = confusion",
            "unclosed string",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\n    double possible = 0.0;\n    double valid = 0.0;\n    \n    public double getProbability(int[] balls) {\n        int[] first = new int[balls.length];\n        int[] second = new int[balls.length];\n        dfs(balls, first, second, 0, 0, 0);\n        return valid / possible;\n    }\n    \n    private void dfs(int[] balls, int[] first, int[] second, int num1, int num2, int idx) {\n        if (idx == balls.length) {\n            if (num1 = num2) {\n                double distrib = permFake(first) * permFake(second);\n                possible += distrib;\n                if (unique(first) == unique(second)) {\n                    valid += distrib + 1;    \n                }\n            }\n            return;\n        }\n        for (int b = 0; b <= balls[idx]; b++) {\n            first[idx] = b;\n            second[idx] = balls[idx] - b;\n            dfs (balls, first, second, num1 + first[idx], num2 + second[idx], idx + 1);\n        }\n    }\n    \n    private int([] balls) {\n       =0;for ( b: balls)\n           +b > b > \"?10;returnprivate int factorial(int n){\n        int ret = 1;\n        while (n > 0) {\n            ret *= n;\n            n--;\n        }\n        return ret;\n    }\n}\n"
    },
    {
        "slug": "same-tree",
        "description": "Given the roots of two binary trees p and q, write a function to check if they are the same or not.\nTwo binary trees are considered the same if they are structurally identical, and the nodes have the same value.",
        "examples": [
            "Input: p = [1,2,3], q = [1,2,3]\nOutput: true",
            "Input: p = [1,2], q = [1,null,2]\nOutput: false",
            "Input: p = [1,2,1], q = [1,1,2]\nOutput: false"
        ],
        "constraints": "The number of nodes in both trees is in the range [0, 100].\n-104 <= Node.val <= 104",
        "oracle_code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n   \n    public boolean isSameTree(TreeNode p, TreeNode q) {\n     if (p == null && q == null) {\n            return true;\n        }\n        \n        if (p == null || q == null) {\n            return false;\n        }\n        \n        if (p.val != q.val) {\n            return false;\n        }\n        \n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n\n        \n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n   \\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n     if (p == null && q == null) {\\n            return true;\\n        }\\n        \\n        if (p == null || q == null) {\\n            return false;\\n        }\\n        \\n        if (p.val != q.val) {\\n            return false;\\n        }\\n        \\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n\\n        \\n    }\\n}\\n```",
        "level": "easy",
        "type": [
            "== and = confusion",
            "parentheses mismatch",
            "undefined keywords from other languages",
            "undefined methods"
        ],
        "buggy_code": "\n\n\n\nclass Solution {\n\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n     if (p = null && q == null) {\n            return true;\n        }\n        \n        if (p == null || q == null) {\n            return false;\n        }\n        \n        if (p.val != q.val) {\n            return false;\n        }\n        \n        return isSameTree(p.left, q.left) && isSameTree(p.right,=q.right);\n\n        \n    }\n}\n\n=\ncheckubcheckub\n"
    },
    {
        "slug": "construct-binary-tree-from-inorder-and-postorder-traversal",
        "description": "Given two integer arrays inorder and postorder where inorder is the inorder traversal of a binary tree and postorder is the postorder traversal of the same tree, construct and return the binary tree.",
        "examples": [
            "Input: inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]\nOutput: [3,9,20,null,null,15,7]",
            "Input: inorder = [-1], postorder = [-1]\nOutput: [-1]"
        ],
        "constraints": "1 <= inorder.length <= 3000\npostorder.length == inorder.length\n-3000 <= inorder[i], postorder[i] <= 3000\ninorder and postorder consist of unique values.\nEach value of postorder also appears in inorder.\ninorder is guaranteed to be the inorder traversal of the tree.\npostorder is guaranteed to be the postorder traversal of the tree.",
        "oracle_code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    int index;\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\n        Map<Integer, Integer> m = new HashMap<>();\n\n        for(int i = 0; i < inorder.length; i++) {\n            m.put(inorder[i], i);\n        }\n        index = postorder.length - 1;\n        return buildTree(0, postorder.length - 1, postorder, m);\n    }\n\n    private TreeNode buildTree(int l, int r, int postorder[] , Map<Integer, Integer> m) {\n        if(l > r) return null;\n\n        int val = postorder[index];\n        index--;\n\n        TreeNode root = new TreeNode(val);\n        if(l == r) return root;\n\n        int in = m.get(val);\n\n        root.right = buildTree(in + 1, r, postorder, m);\n        root.left = buildTree(l, in - 1, postorder, m);\n\n        return root;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int index;\\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\\n        Map<Integer, Integer> m = new HashMap<>();\\n\\n        for(int i = 0; i < inorder.length; i++) {\\n            m.put(inorder[i], i);\\n        }\\n        index = postorder.length - 1;\\n        return buildTree(0, postorder.length - 1, postorder, m);\\n    }\\n\\n    private TreeNode buildTree(int l, int r, int postorder[] , Map<Integer, Integer> m) {\\n        if(l > r) return null;\\n\\n        int val = postorder[index];\\n        index--;\\n\\n        TreeNode root = new TreeNode(val);\\n        if(l == r) return root;\\n\\n        int in = m.get(val);\\n\\n        root.right = buildTree(in + 1, r, postorder, m);\\n        root.left = buildTree(l, in - 1, postorder, m);\\n\\n        return root;\\n    }\\n}\\n```",
        "level": "medium",
        "type": [
            "operation error",
            "parentheses mismatch",
            "indexing error",
            "undefined methods"
        ],
        "buggy_code": "\n\n\n\nclass Solution {\n    int index;\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\n        Map<Integer, Integer> m = new HashMap<>();\n\n        for(int i = 0; i <= inorder.length; i++) {\n            m.put(inorder[i], i);\n        }\n        index = postorder.length - 1;\n        \n        return buildTree(0, postorder.length - 2, postorder, m;\n    }\n\n    private TreeNode buildTree(int l, int r, int postorder[] , Map<Integer, Integer> m) {\n        if(l > r) return null;\n\n        int val = postorder[index];\n        index--;\n\n        TreeNode root = new TreeNode(val);\n        if(l == r) return root;\n\n        int in = m.get(val);\n\n        root.right = buildNewTree(in + 1, r, postorder, m); \n        root.left = buildTree(l, in - 1, postorder, m);\n\n        return root;\n    }\n}\n"
    },
    {
        "slug": "rotating-the-box",
        "description": "You are given an m x n matrix of characters box representing a side-view of a box. Each cell of the box is one of the following:\n\nA stone '#'\nA stationary obstacle '*'\nEmpty '.'\n\nThe box is rotated 90 degrees clockwise, causing some of the stones to fall due to gravity. Each stone falls down until it lands on an obstacle, another stone, or the bottom of the box. Gravity does not affect the obstacles' positions, and the inertia from the box's rotation does not affect the stones' horizontal positions.\nIt is guaranteed that each stone in box rests on an obstacle, another stone, or the bottom of the box.\nReturn an n x m matrix representing the box after the rotation described above.",
        "examples": [
            "Input: box = [[\"#\",\".\",\"#\"]]\r\nOutput: [[\".\"],\r\n\u00a0        [\"#\"],\r\n\u00a0        [\"#\"]]",
            "Input: box = [[\"#\",\".\",\"*\",\".\"],\r\n\u00a0             [\"#\",\"#\",\"*\",\".\"]]\r\nOutput: [[\"#\",\".\"],\r\n\u00a0        [\"#\",\"#\"],\r\n\u00a0        [\"*\",\"*\"],\r\n\u00a0        [\".\",\".\"]]",
            "Input: box = [[\"#\",\"#\",\"*\",\".\",\"*\",\".\"],\r\n\u00a0             [\"#\",\"#\",\"#\",\"*\",\".\",\".\"],\r\n\u00a0             [\"#\",\"#\",\"#\",\".\",\"#\",\".\"]]\r\nOutput: [[\".\",\"#\",\"#\"],\r\n\u00a0        [\".\",\"#\",\"#\"],\r\n\u00a0        [\"#\",\"#\",\"*\"],\r\n\u00a0        [\"#\",\"*\",\".\"],\r\n\u00a0        [\"#\",\".\",\"*\"],\r\n\u00a0        [\"#\",\".\",\".\"]]"
        ],
        "constraints": "m == box.length\nn == box[i].length\n1 <= m, n <= 500\nbox[i][j] is either '#', '*', or '.'.",
        "oracle_code": "// O(n^2) time | O(n^2) space\nclass Solution {\n    public char[][] rotateTheBox(char[][] box) {\n        int m = box.length;\n        int n = box[0].length;\n        char[][] matrix = new char[n][m];   \n        \n        turnBox(box, matrix, m, n); // turn the box clockwise 90 degree\n        \n        turnGravity(matrix, n, m); // cause that falling effect, since matrix turned so n,m\n        \n        return matrix;\n    }\n    \n    public void turnGravity(char[][] matrix, int m, int n){\n        for(int c = 0; c < n; c++){\n            int last  = m-1;\n            for(int r = m-1; r >= 0; r--){\n                char val =  matrix[r][c];\n                if(val == '.') continue;\n                if(val == '*') last = r-1;\n                if(val == '#') {\n                    matrix[r][c] = '.';\n                    matrix[last][c] = '#';\n                    last--;\n                }\n            }\n        }\n    }\n    \n    public void turnBox(char[][] box, char[][] matrix, int m, int n){\n\t// numbers represents sequence it would be copied\n\t//[4][1]\n\t//[5][2]\n\t//[6][3]\n        for(int i = 0, c = m-1; i < m; i++,c--){ // c: 4,3,2,1..\n            for(int j = 0, r = 0; j < n; j++, r++){ // r:0,1,2,3..\n               matrix[r][c] = box[i][j];\n            }\n        }\n    }\n}",
        "content": "**So idea here is**\\n1. First turn 90 degree\\n2. Make things fall\\n\\n```\\n// O(n^2) time | O(n^2) space\\nclass Solution {\\n    public char[][] rotateTheBox(char[][] box) {\\n        int m = box.length;\\n        int n = box[0].length;\\n        char[][] matrix = new char[n][m];   \\n        \\n        turnBox(box, matrix, m, n); // turn the box clockwise 90 degree\\n        \\n        turnGravity(matrix, n, m); // cause that falling effect, since matrix turned so n,m\\n        \\n        return matrix;\\n    }\\n    \\n    public void turnGravity(char[][] matrix, int m, int n){\\n        for(int c = 0; c < n; c++){\\n            int last  = m-1;\\n            for(int r = m-1; r >= 0; r--){\\n                char val =  matrix[r][c];\\n                if(val == \\'.\\') continue;\\n                if(val == \\'*\\') last = r-1;\\n                if(val == \\'#\\') {\\n                    matrix[r][c] = \\'.\\';\\n                    matrix[last][c] = \\'#\\';\\n                    last--;\\n                }\\n            }\\n        }\\n    }\\n    \\n    public void turnBox(char[][] box, char[][] matrix, int m, int n){\\n\\t// numbers represents sequence it would be copied\\n\\t//[4][1]\\n\\t//[5][2]\\n\\t//[6][3]\\n        for(int i = 0, c = m-1; i < m; i++,c--){ // c: 4,3,2,1..\\n            for(int j = 0, r = 0; j < n; j++, r++){ // r:0,1,2,3..\\n               matrix[r][c] = box[i][j];\\n            }\\n        }\\n    }\\n}\\n```",
        "level": "medium",
        "type": [
            "colon missing",
            "other error",
            "wrong comment mark",
            "unclosed string"
        ],
        "buggy_code": "\n// O(n^2) time | O(n^2) space\nclass Solution {\n    public char[][] rotateTheBox(char[][] box) {\n        int m = box.length;\n        int n = box[0].length;\n        char[][] matrix = new char[n][m]   \n        \n        turnBox(box, matrix, m, n); // turn the box clockwise 90 degree\n        \n        turnGravity(matrix, n, m); ' cause that falling effect, since matrix turned so n,m\n        \n        return matrix;\n    }\n    \n    public void turnGravity(char[][] matrix, int m, int n){\n        for(int c = 0; c < n; c++){\n            int last  = m-1;\n            for(int r = m-1; r >= 0; r--){\n                char val =  matrix[r][c];\n                if(val == '.') continue;\n                if(val == '*') last = r-1;\n                if(val == '#') {\n                    matrix[r][c] = '.';\n                    matrix[last][c] = '#;\n                }\n            }\n        }\n    }\n    \n    public void turnBox(char[][] box, char[][] matrix, int m, int n){\n                        for(int i = 0, c = m-1; i < m; i++,c--){ // c: 4,3,2,1..\n            for(int j = 0, r = 0; j < n; j++, r++){ // r:0,1,2,3..\n               matrix[r][1] = box[i][j];\n            }\n        }\n    }\n}\n"
    },
    {
        "slug": "relative-ranks",
        "description": "You are given an integer array score of size n, where score[i] is the score of the ith athlete in a competition. All the scores are guaranteed to be unique.\nThe athletes are placed based on their scores, where the 1st place athlete has the highest score, the 2nd place athlete has the 2nd highest score, and so on. The placement of each athlete determines their rank:\n\nThe 1st place athlete's rank is \"Gold Medal\".\nThe 2nd place athlete's rank is \"Silver Medal\".\nThe 3rd place athlete's rank is \"Bronze Medal\".\nFor the 4th place to the nth place athlete, their rank is their placement number (i.e., the xth place athlete's rank is \"x\").\n\nReturn an array answer of size n where answer[i] is the rank of the ith athlete.",
        "examples": [
            "Input: score = [5,4,3,2,1]\nOutput: [\"Gold Medal\",\"Silver Medal\",\"Bronze Medal\",\"4\",\"5\"]\nExplanation: The placements are [1st, 2nd, 3rd, 4th, 5th].",
            "Input: score = [10,3,8,9,4]\nOutput: [\"Gold Medal\",\"5\",\"Bronze Medal\",\"Silver Medal\",\"4\"]\nExplanation: The placements are [1st, 5th, 3rd, 2nd, 4th]."
        ],
        "constraints": "n == score.length\n1 <= n <= 104\n0 <= score[i] <= 106\nAll the values in score are unique.",
        "oracle_code": "class Solution {\n    public String[] findRelativeRanks(int[] score) {\n         int n=score.length;\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[b]-score[a]);\n        for(int i=0;i<n;i++) pq.add(i);\n      String[] ans = new String[n];\n                int i=1;\n        while(!pq.isEmpty()){\n            int idx=pq.poll();\n         if(i==1)   { ans[idx]=\"Gold Medal\"; i++;}\n         else if(i==2)   { ans[idx]=\"Silver Medal\"; i++;}\n         else if(i==3)   { ans[idx]=\"Bronze Medal\"; i++;}\n         else ans[idx]=Integer.toString(i++);\n        }\n        return ans;  \n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String[] findRelativeRanks(int[] score) {\\n         int n=score.length;\\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[b]-score[a]);\\n        for(int i=0;i<n;i++) pq.add(i);\\n      String[] ans = new String[n];\\n                int i=1;\\n        while(!pq.isEmpty()){\\n            int idx=pq.poll();\\n         if(i==1)   { ans[idx]=\"Gold Medal\"; i++;}\\n         else if(i==2)   { ans[idx]=\"Silver Medal\"; i++;}\\n         else if(i==3)   { ans[idx]=\"Bronze Medal\"; i++;}\\n         else ans[idx]=Integer.toString(i++);\\n        }\\n        return ans;  \\n    }\\n}\\n```",
        "level": "easy",
        "type": [
            "operation error",
            "== and = confusion",
            "undefined objects",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution {\n    public String[] findRelativeRanks(int[] score) {\n         int n = score.length;\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[a]-score[b]);\n        for(int i=0;i<n;i++) pq.add(i);\n          String[] ans = null;\n        int i=1;\n        while(!pq.isEmpty()){\n            int idx=pq.poll();\n            if(i=1) { ans[idx]=\"Gold Medal; i++;} \n            else if(i=2) { ans[idx]=\"Silver Medal; i++;} \n            else if(i=3) { ans[idx]=\"Bronze Medal; i++;} \n            else ans[idx]=Integer.toString(i++);\n        }\n        return ans;  \n    }\n}\n"
    },
    {
        "slug": "probability-of-a-two-boxes-having-the-same-number-of-distinct-balls",
        "description": "Given 2n balls of k distinct colors. You will be given an integer array balls of size k where balls[i] is the number of balls of color i.\nAll the balls will be shuffled uniformly at random, then we will distribute the first n balls to the first box and the remaining n balls to the other box (Please read the explanation of the second example carefully).\nPlease note that the two boxes are considered different. For example, if we have two balls of colors a and b, and two boxes [] and (), then the distribution [a] (b) is considered different than the distribution [b] (a) (Please read the explanation of the first example carefully).\nReturn the probability that the two boxes have the same number of distinct balls. Answers within 10-5 of the actual value will be accepted as correct.",
        "examples": [
            "Input: balls = [1,1]\nOutput: 1.00000\nExplanation: Only 2 ways to divide the balls equally:\n- A ball of color 1 to box 1 and a ball of color 2 to box 2\n- A ball of color 2 to box 1 and a ball of color 1 to box 2\nIn both ways, the number of distinct colors in each box is equal. The probability is 2/2 = 1",
            "Input: balls = [2,1,1]\nOutput: 0.66667\nExplanation: We have the set of balls [1, 1, 2, 3]\nThis set of balls will be shuffled randomly and we may have one of the 12 distinct shuffles with equal probability (i.e. 1/12):\n[1,1 / 2,3], [1,1 / 3,2], [1,2 / 1,3], [1,2 / 3,1], [1,3 / 1,2], [1,3 / 2,1], [2,1 / 1,3], [2,1 / 3,1], [2,3 / 1,1], [3,1 / 1,2], [3,1 / 2,1], [3,2 / 1,1]\nAfter that, we add the first two balls to the first box and the second two balls to the second box.\nWe can see that 8 of these 12 possible random distributions have the same number of distinct colors of balls in each box.\nProbability is 8/12 = 0.66667",
            "Input: balls = [1,2,1,2]\nOutput: 0.60000\nExplanation: The set of balls is [1, 2, 2, 3, 4, 4]. It is hard to display all the 180 possible random shuffles of this set but it is easy to check that 108 of them will have the same number of distinct colors in each box.\nProbability = 108 / 180 = 0.6"
        ],
        "constraints": "1 <= balls.length <= 8\n1 <= balls[i] <= 6\nsum(balls) is even.",
        "oracle_code": "class Solution {\n    double possible = 0.0;\n    double valid = 0.0;\n    \n    public double getProbability(int[] balls) {\n        int[] first = new int[balls.length];\n        int[] second = new int[balls.length];\n        dfs(balls, first, second, 0, 0, 0);\n        return valid / possible;\n    }\n    \n    private void dfs(int[] balls, int[] first, int[] second, int num1, int num2, int idx) {\n        // finish all colors, check if this's a possible/valid distribution\n        if (idx == balls.length) {\n            // find one possible distribution\n            if (num1 == num2) {\n                // compute fake permutation\n                double distrib = permFake(first) * permFake(second);\n                possible += distrib;\n                \n                // find one valid distribution\n                if (unique(first) == unique(second)) {\n                    valid += distrib;\n                }\n            }\n            return;\n        }\n        \n        // distribute balls in current color to two bins\n        for (int b = 0; b <= balls[idx]; b++) {\n            first[idx] = b;\n            second[idx] = balls[idx] - b;\n            dfs (balls, first, second, num1 + first[idx], num2 + second[idx], idx + 1);\n        }\n    }\n    \n    // unique colors in \n    private int unique(int[] balls) {\n        int unique = 0;\n        for (int b: balls)\n            unique += b > 0 ? 1 : 0;\n        return unique;\n    }\n    \n    // return 1 / (b1!b2!b3!...bn!) \n    private double permFake(int[] balls) {\n        double ret = 1.0;\n        for (int b: balls)\n            ret /= factorial(b);\n        return ret;\n    }\n    \n    private int factorial(int n){\n        int ret = 1;\n        while (n > 0) {\n            ret *= n;\n            n--;\n        }\n        return ret;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    double possible = 0.0;\\n    double valid = 0.0;\\n    \\n    public double getProbability(int[] balls) {\\n        int[] first = new int[balls.length];\\n        int[] second = new int[balls.length];\\n        dfs(balls, first, second, 0, 0, 0);\\n        return valid / possible;\\n    }\\n    \\n    private void dfs(int[] balls, int[] first, int[] second, int num1, int num2, int idx) {\\n        // finish all colors, check if this\\'s a possible/valid distribution\\n        if (idx == balls.length) {\\n            // find one possible distribution\\n            if (num1 == num2) {\\n                // compute fake permutation\\n                double distrib = permFake(first) * permFake(second);\\n                possible += distrib;\\n                \\n                // find one valid distribution\\n                if (unique(first) == unique(second)) {\\n                    valid += distrib;\\n                }\\n            }\\n            return;\\n        }\\n        \\n        // distribute balls in current color to two bins\\n        for (int b = 0; b <= balls[idx]; b++) {\\n            first[idx] = b;\\n            second[idx] = balls[idx] - b;\\n            dfs (balls, first, second, num1 + first[idx], num2 + second[idx], idx + 1);\\n        }\\n    }\\n    \\n    // unique colors in \\n    private int unique(int[] balls) {\\n        int unique = 0;\\n        for (int b: balls)\\n            unique += b > 0 ? 1 : 0;\\n        return unique;\\n    }\\n    \\n    // return 1 / (b1!b2!b3!...bn!) \\n    private double permFake(int[] balls) {\\n        double ret = 1.0;\\n        for (int b: balls)\\n            ret /= factorial(b);\\n        return ret;\\n    }\\n    \\n    private int factorial(int n){\\n        int ret = 1;\\n        while (n > 0) {\\n            ret *= n;\\n            n--;\\n        }\\n        return ret;\\n    }\\n}\\n```",
        "level": "hard",
        "type": [
            "== and = confusion",
            "undefined objects",
            "unclosed string",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\n    double possible = 0.0;\n    double valid = 0.0;\n    \n    public double getProbability(int[] balls) {\n        int[] first = new int[balls.length];\n        int[] second = null;\n        dfs(balls, first, second, 0, 0, 0);\n        return valid / possible;\n    }\n    \n    private void dfs(int[] balls, int[] first, int[] second, int num1, int num2, int idx) {\n        if (idx == balls.length) {\n            if (num1 = num2) {\n                double distrib = permFake(first) * permFake(second);\n                possible += distrib;\n                \n                if (unique(first) == unique(second)) {\n                    valid += distrib;\n                }\n            }\n            return;\n        }\n        \n        for (int b = 0; b <= balls[idx]; b++) {\n            first[idx] = b;\n            second[idx] = balls[idx] - b;\n            dfs (balls, first, second, num1 + first[idx], num2 + second[idx], idx + 1);\n        }\n    }\n    \n    \"private int factorial(int n){\n        int ret = 1;\n        while (n > 0) {\n            ret *= n;\n            n--;\n        }\n        return ret;\n    }\n}\n"
    },
    {
        "slug": "minimum-number-of-swaps-to-make-the-string-balanced",
        "description": "You are given a 0-indexed string s of even length n. The string consists of exactly n / 2 opening brackets '[' and n / 2 closing brackets ']'.\nA string is called balanced if and only if:\n\nIt is the empty string, or\nIt can be written as AB, where both A and B are balanced strings, or\nIt can be written as [C], where C is a balanced string.\n\nYou may swap the brackets at any two indices any number of times.\nReturn the minimum number of swaps to make s balanced.",
        "examples": [
            "Input: s = \"][][\"\nOutput: 1\nExplanation: You can make the string balanced by swapping index 0 with index 3.\nThe resulting string is \"[[]]\".",
            "Input: s = \"]]][[[\"\nOutput: 2\nExplanation: You can do the following to make the string balanced:\n- Swap index 0 with index 4. s = \"[]][][\".\n- Swap index 1 with index 5. s = \"[[][]]\".\nThe resulting string is \"[[][]]\".",
            "Input: s = \"[]\"\nOutput: 0\nExplanation: The string is already balanced."
        ],
        "constraints": "n == s.length\n2 <= n <= 106\nn is even.\ns[i] is either '[' or ']'.\nThe number of opening brackets '[' equals n / 2, and the number of closing brackets ']' equals n / 2.",
        "oracle_code": "class Solution {\n    public int minSwaps(String s) {\n        return util1(s);\n    }\n    public int util1(String str) {\n        Stack<Character> s = new Stack<>();\n        for (int i = 0; i < str.length(); i++) {\n            if (str.charAt(i) == '[') {\n                s.push(str.charAt(i));\n            } else {\n                if (s.isEmpty() == false && s.peek() == '[') {\n                    s.pop();\n                } else {\n                    s.push(str.charAt(i));\n                }\n            }\n        }\n        double pairs = s.size() / 2;\n        double a = pairs / 2.0;\n        int ans = (int) Math.ceil(a);\n        return ans;\n    }\n}",
        "content": "the trick behind is fairly easy\\n\\nfor the number of pairs which are not correct, the amount of swaps required to make them correct is Math.ceil(a), where a is the number of pairs which are not correct.\\n\\nfor eg\\nfor 5 incorrect pairs, we need 3 swaps\\nfor 3 incorrect pairs, we need 2 swaps\\nfor 2 incorrect pairs, we need 1 swap\\n\\nso simply, \\nwe need to firstly write code to remove all the valid pairs, that ways only the pairs which are incorrect will be in the stack\\nthen we simply do the calculations.\\n\\nrest the code should be self explanatory.\\n\\n# Code\\n```\\nclass Solution {\\n    public int minSwaps(String s) {\\n        return util1(s);\\n    }\\n    public int util1(String str) {\\n        Stack<Character> s = new Stack<>();\\n        for (int i = 0; i < str.length(); i++) {\\n            if (str.charAt(i) == \\'[\\') {\\n                s.push(str.charAt(i));\\n            } else {\\n                if (s.isEmpty() == false && s.peek() == \\'[\\') {\\n                    s.pop();\\n                } else {\\n                    s.push(str.charAt(i));\\n                }\\n            }\\n        }\\n        double pairs = s.size() / 2;\\n        double a = pairs / 2.0;\\n        int ans = (int) Math.ceil(a);\\n        return ans;\\n    }\\n}\\n```\\nyou can check out my github repository where i am uploading famous interview questions topic wise with solutions.\\nlink-- https://github.com/Abhaydutt2003/DataStructureAndAlgoPractice \\nkindly upvote if you like my solution. you can ask doubts below.\\n    \\n",
        "level": "medium",
        "type": [
            "operation error",
            "parentheses mismatch",
            "indexing error",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution {\n    public int minSwaps(String s) {\n        return util1(\"s;\n    }\n    public int util1(String str) {\n        Stack<Character> s = new Stack<>();\n        for (int i = 0; i <= str.length(); i++) {\n            if (str.charAt(i) == '[') {\n                s.push(str.charAt(i));\n            } else {\n                if (s.isEmpty() == false && s.peek() == '[') {\n                    s.pop();\n                } else {\n                    s.push(str.charAt(i));\n                }\n            }\n        }\n        double pairs = s.size() / 2;\n        double a = pairs / 10.0;\n        int ans = (int) Math.ceil(a);\n        return ans;\n    }\n}\n"
    },
    {
        "slug": "number-of-provinces",
        "description": "There are n cities. Some of them are connected, while some are not. If city a is connected directly with city b, and city b is connected directly with city c, then city a is connected indirectly with city c.\nA province is a group of directly or indirectly connected cities and no other cities outside of the group.\nYou are given an n x n matrix isConnected where isConnected[i][j] = 1 if the ith city and the jth city are directly connected, and isConnected[i][j] = 0 otherwise.\nReturn the total number of provinces.",
        "examples": [
            "Input: isConnected = [[1,1,0],[1,1,0],[0,0,1]]\nOutput: 2",
            "Input: isConnected = [[1,0,0],[0,1,0],[0,0,1]]\nOutput: 3"
        ],
        "constraints": "1 <= n <= 200\nn == isConnected.length\nn == isConnected[i].length\nisConnected[i][j] is 1 or 0.\nisConnected[i][i] == 1\nisConnected[i][j] == isConnected[j][i]",
        "oracle_code": "class DSU:\n    def __init__(self, n):\n        self.par = list(range(n))\n        self.rank = [1] * n\n        self.size = 1\n    def find(self, u):\n        if u != self.par[u]:\n            self.par[u] = self.find(self.par[u])\n        return self.par[u]\n    def union(self, u, v):\n        uu, vv = self.find(u), self.find(v)\n        if uu == vv:\n            return False\n        if self.rank[uu] > self.rank[vv]:\n            self.par[vv] = uu\n        elif self.rank[vv] > self.rank[uu]:\n            self.par[uu] = vv\n        else:\n            self.par[uu] = vv\n            self.rank[vv] += 1\n        self.size += 1\n        return True\n\nclass Solution:\n    def isConnected(self, u, v, G):\n        return G[u][v] == 1\n\n    def findCircleNum(self, G: List[List[int]]) -> int:\n        n = len(G)\n        uf = DSU(n)\n        if not G:\n            return 0\n        for u in range(n):\n            for v in range(u, n):\n                if self.isConnected(u, v, G):\n                    uf.union(u, v)\n        return len(set([uf.find(i) for i in range(n)]))",
        "content": "\\n# Code\\n```\\nclass DSU:\\n    def __init__(self, n):\\n        self.par = list(range(n))\\n        self.rank = [1] * n\\n        self.size = 1\\n    def find(self, u):\\n        if u != self.par[u]:\\n            self.par[u] = self.find(self.par[u])\\n        return self.par[u]\\n    def union(self, u, v):\\n        uu, vv = self.find(u), self.find(v)\\n        if uu == vv:\\n            return False\\n        if self.rank[uu] > self.rank[vv]:\\n            self.par[vv] = uu\\n        elif self.rank[vv] > self.rank[uu]:\\n            self.par[uu] = vv\\n        else:\\n            self.par[uu] = vv\\n            self.rank[vv] += 1\\n        self.size += 1\\n        return True\\n\\nclass Solution:\\n    def isConnected(self, u, v, G):\\n        return G[u][v] == 1\\n\\n    def findCircleNum(self, G: List[List[int]]) -> int:\\n        n = len(G)\\n        uf = DSU(n)\\n        if not G:\\n            return 0\\n        for u in range(n):\\n            for v in range(u, n):\\n                if self.isConnected(u, v, G):\\n                    uf.union(u, v)\\n        return len(set([uf.find(i) for i in range(n)]))\\n\\n```",
        "level": "medium",
        "type": [
            "colon missing",
            "conditional statement error",
            "wrong comment mark",
            "undefined methods"
        ],
        "buggy_code": "\nclass DSU:\n    def __init__(self, n)\n        self.par = list(range(n))\n        self.rank = [1] * n\n        self.size = 1\n    def find(self, u):\n        if u != self.par[u]:\n            /* self.par[u] = self.find(self.par[u])*/\n        return self.par[u]\n    def union(self, u, v):\n        uu, vv = self.find(u), self.find(v)\n        if uu == vv:\n            return False\n        if self.rank[uu] > self.rank[vv]:\n            self.par[vv] = uu\n        elif self.rank[vv] > self.rank[uu]:\n            self.par[uu] = vv\n        else:\n            self.par[uu] = vv\n            self.rank[vv] += 1\n        self.size += 1\n        return True\n    def issizemorethanone(self):\n        return self.size > 1\n    \nclass Solution:\n    def isConnected(self, u, v, G):\n        return G[u][v] == 1\n\n    def findCircleNum(self, G: List[List[int]]) -> int:\n        n = len(G)\n        uf = DSU(n)\n        if not G:\n            return 0\n        for u in range(n):\n            for v in range(n):\n                if self.isConnected(u, v, G):\n                    uf.union(u, v)\n        return len(set([uf.find(i) for i in range(n)]))\n"
    },
    {
        "slug": "remove-colored-pieces-if-both-neighbors-are-the-same-color",
        "description": "There are n pieces arranged in a line, and each piece is colored either by 'A' or by 'B'. You are given a string colors of length n where colors[i] is the color of the ith piece.\nAlice and Bob are playing a game where they take alternating turns removing pieces from the line. In this game, Alice moves first.\n\nAlice is only allowed to remove a piece colored 'A' if both its neighbors are also colored 'A'. She is not allowed to remove pieces that are colored 'B'.\nBob is only allowed to remove a piece colored 'B' if both its neighbors are also colored 'B'. He is not allowed to remove pieces that are colored 'A'.\nAlice and Bob cannot remove pieces from the edge of the line.\nIf a player cannot make a move on their turn, that player loses and the other player wins.\n\nAssuming Alice and Bob play optimally, return true if Alice wins, or return false if Bob wins.",
        "examples": [
            "Input: colors = \"AAABABB\"\nOutput: true\nExplanation:\nAAABABB -> AABABB\nAlice moves first.\nShe removes the second 'A' from the left since that is the only 'A' whose neighbors are both 'A'.\n\nNow it's Bob's turn.\nBob cannot make a move on his turn since there are no 'B's whose neighbors are both 'B'.\nThus, Alice wins, so return true.",
            "Input: colors = \"AA\"\nOutput: false\nExplanation:\nAlice has her turn first.\nThere are only two 'A's and both are on the edge of the line, so she cannot move on her turn.\nThus, Bob wins, so return false.",
            "Input: colors = \"ABBBBBBBAAA\"\nOutput: false\nExplanation:\nABBBBBBBAAA -> ABBBBBBBAA\nAlice moves first.\nHer only option is to remove the second to last 'A' from the right.\n\nABBBBBBBAA -> ABBBBBBAA\nNext is Bob's turn.\nHe has many options for which 'B' piece to remove. He can pick any.\n\nOn Alice's second turn, she has no more pieces that she can remove.\nThus, Bob wins, so return false."
        ],
        "constraints": "1 <=\u00a0colors.length <= 105\ncolors\u00a0consists of only the letters\u00a0'A'\u00a0and\u00a0'B'",
        "oracle_code": "class Solution {\n    public boolean winnerOfGame(String s) {\n        //count the triplets\nint n = s.length();\n    \n        int a=0;\n        int b=0;\n        \n        for(int i=1; i<n-1; i++)\n        {\n            if(s.charAt(i)=='A' && s.charAt(i-1)=='A' && s.charAt(i+1)=='A' )\n        a++;\n            else if(s.charAt(i)=='B' && s.charAt(i-1)=='B' && s.charAt(i+1)=='B' )\n        b++;\n            \n            }\n        if(a<=b)\n            return false;\n        else\n            return true;\n        \n    \n    }\n}",
        "content": "Idea behind it is that you need to count the number of triplets of both A and B \\nint a -> number of triplets of \\'A\\'\\nint b -> number of triplets of \\'B\\'\\nif(b>=a) BOB wins else Alice wins\\n\\nAs Alice has to make a move first so if she wants to win there should be atleast  1 more  triplets of A than B\\n\\nEg There are 4 triplets of both A and B  (a=4, b=4) \\n1. Alice removes 1 A (a=3, b=4)\\n2. Bob removes 1 B (a=3, b=3)\\n3. (a=2, b=3)\\n4. (a=2, b=2)\\n5. (a=1, b=2)\\n6. (a=1, b=1)\\n7. (a=0, b=1)\\n\\nClearly Alice will lose if both have same number of triplets\\nCode \\n\\n```\\nclass Solution {\\n    public boolean winnerOfGame(String s) {\\n        //count the triplets\\nint n = s.length();\\n    \\n        int a=0;\\n        int b=0;\\n        \\n        for(int i=1; i<n-1; i++)\\n        {\\n            if(s.charAt(i)==\\'A\\' && s.charAt(i-1)==\\'A\\' && s.charAt(i+1)==\\'A\\' )\\n        a++;\\n            else if(s.charAt(i)==\\'B\\' && s.charAt(i-1)==\\'B\\' && s.charAt(i+1)==\\'B\\' )\\n        b++;\\n            \\n            }\\n        if(a<=b)\\n            return false;\\n        else\\n            return true;\\n        \\n    \\n    }\\n}\\n```\\nIf this helped you then please UpVote\\nThanks\\n\\n\\n",
        "level": "medium",
        "type": [
            "== and = confusion",
            "conditional statement error",
            "unclosed string",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\n    public boolean winnerOfGame(String s) {\n        //count the triplets\n        int n = s.length();\n\n        int a=0;\n        int b=0;\n\n        for(int i=1; i<n; i++) \n        {\n            if(s.charAt(i)=='A' && s.charAt(i-1)=='A' && s.charAt(i+1)=='A' )\n            a++;\n            else if(s.charAt(i)=='B' && s.charAt(i-1)=='B' && s.charAt(i+1)=='B' )\n                    b++;\n        }\n\n        if(a<=''        b)\n        returnfalse;\n else\n            return true;\n}\n =ValidaResult() }\n\n    private boolean ValidateResult() {\n        \n    \n}\n"
    },
    {
        "slug": "count-negative-numbers-in-a-sorted-matrix",
        "description": "Given a m x n matrix grid which is sorted in non-increasing order both row-wise and column-wise, return the number of negative numbers in grid.",
        "examples": [
            "Input: grid = [[4,3,2,-1],[3,2,1,-1],[1,1,-1,-2],[-1,-1,-2,-3]]\nOutput: 8\nExplanation: There are 8 negatives number in the matrix.",
            "Input: grid = [[3,2],[1,0]]\nOutput: 0"
        ],
        "constraints": "m == grid.length\nn == grid[i].length\n1 <= m, n <= 100\n-100 <= grid[i][j] <= 100",
        "oracle_code": "class Solution:\n    def countNegatives(self, grid: List[List[int]]) -> int:\n        ROWS, COLS = len(grid), len(grid[0])\n        negatives = 0\n        col = 0\n        for row in range(ROWS - 1, -1, -1):\n            while col < COLS and grid[row][col] >= 0:\n                col += 1\n            negatives += COLS - col\n        return negatives",
        "content": "# Intuition\\nThe key idea is to take advantage of the sorted nature of the matrix, where both the rows and columns are sorted in non-increasing order. This means that once we find a negative number in a row, all the following numbers in that row will also be negative. Similarly, if a cell at the top of a column is negative, all the cells below it in that column will also be negative.\\n\\n# Approach\\nNegative numbers will form a staircase. So we start from the bottom-left, and follow along the staircase. For each row, we find the edge of the staircase, add all the count of elements to the right to the answer, and then move up a row and repeat.\\n\\n# Complexity\\n- Time complexity: O(m + n) - We visit each row and column at most once.\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def countNegatives(self, grid: List[List[int]]) -> int:\\n        ROWS, COLS = len(grid), len(grid[0])\\n        negatives = 0\\n        col = 0\\n        for row in range(ROWS - 1, -1, -1):\\n            while col < COLS and grid[row][col] >= 0:\\n                col += 1\\n            negatives += COLS - col\\n        return negatives\\n\\n```\\n\\n# Get Faster Interview Prep Results with Top Algos\\nWe all know how time-consuming it is to prepare for interviews and how frustratingly difficult it is to improve. We made **Top Algos** - a tool recommends the perfect algorithm problem based on your current skill level to help you improve the fastest in the shortest amount of time. Top Algos is your personalized coach that learns your skill level and finds the best problem you need to solve to improve.\\n\\nThe beta version of the product is available for **free** right now! You can sign up at https://topalgos.xyz/.",
        "level": "easy",
        "type": [
            "operation error",
            "colon missing",
            "indexing error",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution:\n    def countNegatives(self, grid: List[List[int]]) -> int:\n        ROWS, COLS = len(grid), len(grid[0])\n        negatives = 0\n        for row in range(ROWS - 1, -1, -1):\n            col = 0\n            while col <= COLS and grid[row][col] >= 0:\n                col += 1\n            negatives += COLS\n        return negatives\n\n    def undefinedMethod(self):\n        self.countPositives(grid)\n"
    },
    {
        "slug": "probability-of-a-two-boxes-having-the-same-number-of-distinct-balls",
        "description": "Given 2n balls of k distinct colors. You will be given an integer array balls of size k where balls[i] is the number of balls of color i.\nAll the balls will be shuffled uniformly at random, then we will distribute the first n balls to the first box and the remaining n balls to the other box (Please read the explanation of the second example carefully).\nPlease note that the two boxes are considered different. For example, if we have two balls of colors a and b, and two boxes [] and (), then the distribution [a] (b) is considered different than the distribution [b] (a) (Please read the explanation of the first example carefully).\nReturn the probability that the two boxes have the same number of distinct balls. Answers within 10-5 of the actual value will be accepted as correct.",
        "examples": [
            "Input: balls = [1,1]\nOutput: 1.00000\nExplanation: Only 2 ways to divide the balls equally:\n- A ball of color 1 to box 1 and a ball of color 2 to box 2\n- A ball of color 2 to box 1 and a ball of color 1 to box 2\nIn both ways, the number of distinct colors in each box is equal. The probability is 2/2 = 1",
            "Input: balls = [2,1,1]\nOutput: 0.66667\nExplanation: We have the set of balls [1, 1, 2, 3]\nThis set of balls will be shuffled randomly and we may have one of the 12 distinct shuffles with equal probability (i.e. 1/12):\n[1,1 / 2,3], [1,1 / 3,2], [1,2 / 1,3], [1,2 / 3,1], [1,3 / 1,2], [1,3 / 2,1], [2,1 / 1,3], [2,1 / 3,1], [2,3 / 1,1], [3,1 / 1,2], [3,1 / 2,1], [3,2 / 1,1]\nAfter that, we add the first two balls to the first box and the second two balls to the second box.\nWe can see that 8 of these 12 possible random distributions have the same number of distinct colors of balls in each box.\nProbability is 8/12 = 0.66667",
            "Input: balls = [1,2,1,2]\nOutput: 0.60000\nExplanation: The set of balls is [1, 2, 2, 3, 4, 4]. It is hard to display all the 180 possible random shuffles of this set but it is easy to check that 108 of them will have the same number of distinct colors in each box.\nProbability = 108 / 180 = 0.6"
        ],
        "constraints": "1 <= balls.length <= 8\n1 <= balls[i] <= 6\nsum(balls) is even.",
        "oracle_code": "class Solution {\n    double possible = 0.0;\n    double valid = 0.0;\n    \n    public double getProbability(int[] balls) {\n        int[] first = new int[balls.length];\n        int[] second = new int[balls.length];\n        dfs(balls, first, second, 0, 0, 0);\n        return valid / possible;\n    }\n    \n    private void dfs(int[] balls, int[] first, int[] second, int num1, int num2, int idx) {\n        // finish all colors, check if this's a possible/valid distribution\n        if (idx == balls.length) {\n            // find one possible distribution\n            if (num1 == num2) {\n                // compute fake permutation\n                double distrib = permFake(first) * permFake(second);\n                possible += distrib;\n                \n                // find one valid distribution\n                if (unique(first) == unique(second)) {\n                    valid += distrib;\n                }\n            }\n            return;\n        }\n        \n        // distribute balls in current color to two bins\n        for (int b = 0; b <= balls[idx]; b++) {\n            first[idx] = b;\n            second[idx] = balls[idx] - b;\n            dfs (balls, first, second, num1 + first[idx], num2 + second[idx], idx + 1);\n        }\n    }\n    \n    // unique colors in \n    private int unique(int[] balls) {\n        int unique = 0;\n        for (int b: balls)\n            unique += b > 0 ? 1 : 0;\n        return unique;\n    }\n    \n    // return 1 / (b1!b2!b3!...bn!) \n    private double permFake(int[] balls) {\n        double ret = 1.0;\n        for (int b: balls)\n            ret /= factorial(b);\n        return ret;\n    }\n    \n    private int factorial(int n){\n        int ret = 1;\n        while (n > 0) {\n            ret *= n;\n            n--;\n        }\n        return ret;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    double possible = 0.0;\\n    double valid = 0.0;\\n    \\n    public double getProbability(int[] balls) {\\n        int[] first = new int[balls.length];\\n        int[] second = new int[balls.length];\\n        dfs(balls, first, second, 0, 0, 0);\\n        return valid / possible;\\n    }\\n    \\n    private void dfs(int[] balls, int[] first, int[] second, int num1, int num2, int idx) {\\n        // finish all colors, check if this\\'s a possible/valid distribution\\n        if (idx == balls.length) {\\n            // find one possible distribution\\n            if (num1 == num2) {\\n                // compute fake permutation\\n                double distrib = permFake(first) * permFake(second);\\n                possible += distrib;\\n                \\n                // find one valid distribution\\n                if (unique(first) == unique(second)) {\\n                    valid += distrib;\\n                }\\n            }\\n            return;\\n        }\\n        \\n        // distribute balls in current color to two bins\\n        for (int b = 0; b <= balls[idx]; b++) {\\n            first[idx] = b;\\n            second[idx] = balls[idx] - b;\\n            dfs (balls, first, second, num1 + first[idx], num2 + second[idx], idx + 1);\\n        }\\n    }\\n    \\n    // unique colors in \\n    private int unique(int[] balls) {\\n        int unique = 0;\\n        for (int b: balls)\\n            unique += b > 0 ? 1 : 0;\\n        return unique;\\n    }\\n    \\n    // return 1 / (b1!b2!b3!...bn!) \\n    private double permFake(int[] balls) {\\n        double ret = 1.0;\\n        for (int b: balls)\\n            ret /= factorial(b);\\n        return ret;\\n    }\\n    \\n    private int factorial(int n){\\n        int ret = 1;\\n        while (n > 0) {\\n            ret *= n;\\n            n--;\\n        }\\n        return ret;\\n    }\\n}\\n```",
        "level": "hard",
        "type": [
            "operation error",
            "== and = confusion",
            "colon missing",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution {\n    double possible = 0.0;\n    double valid = 0.0;\n    \n    public double getProbability(int[] balls) {\n        int[] first = new int[balls.length];\n        int[] second = null;\n        dfs(balls, first, second, 0, 0, 0)\n        return valid / possible;\n    }\n    \n    private void dfs(int[] balls, int[] first, int[] second, int num1, int num2, int idx) {\n        if (idx == balls.length) {if (num1 = num2) {\n                double distrib = permFake(first) * permFake(second);\n                possible += distrib;\n                if (unique(first) == unique(second)) {\n                    valid += distrib + 1;    \n                }\n            }\n            return;\n        }\n        for (int b = 0; b <= balls[idx]; b++) {\n            first[idx] = b;\n            second[idx] = balls[idx] - b;\n            dfs (balls, first, second, num1 + first[idx], num2 + second[idx], idx + 1);\n        }\n    }\n    \n    private int(t[] balls) {\n        int unique = 0;\n        for (int b: balls)\n            unique += b > 0 ? 1 : 0;\n        return unique;\n    }\n    \n    private double permFake(int[] balls) {\n        double ret = 1.0;\n        for (int b: balls)\n            ret /= factorial(b);\n        return ret;\n    }\n    \n    private int factorial(int n){\n        int ret = 1;\n        while (n > 0) {\n            ret *= n;\n            n--;\n        }\n        return ret;\n    }\n}\n"
    },
    {
        "slug": "construct-binary-tree-from-inorder-and-postorder-traversal",
        "description": "Given two integer arrays inorder and postorder where inorder is the inorder traversal of a binary tree and postorder is the postorder traversal of the same tree, construct and return the binary tree.",
        "examples": [
            "Input: inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]\nOutput: [3,9,20,null,null,15,7]",
            "Input: inorder = [-1], postorder = [-1]\nOutput: [-1]"
        ],
        "constraints": "1 <= inorder.length <= 3000\npostorder.length == inorder.length\n-3000 <= inorder[i], postorder[i] <= 3000\ninorder and postorder consist of unique values.\nEach value of postorder also appears in inorder.\ninorder is guaranteed to be the inorder traversal of the tree.\npostorder is guaranteed to be the postorder traversal of the tree.",
        "oracle_code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    int index;\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\n        Map<Integer, Integer> m = new HashMap<>();\n\n        for(int i = 0; i < inorder.length; i++) {\n            m.put(inorder[i], i);\n        }\n        index = postorder.length - 1;\n        return buildTree(0, postorder.length - 1, postorder, m);\n    }\n\n    private TreeNode buildTree(int l, int r, int postorder[] , Map<Integer, Integer> m) {\n        if(l > r) return null;\n\n        int val = postorder[index];\n        index--;\n\n        TreeNode root = new TreeNode(val);\n        if(l == r) return root;\n\n        int in = m.get(val);\n\n        root.right = buildTree(in + 1, r, postorder, m);\n        root.left = buildTree(l, in - 1, postorder, m);\n\n        return root;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int index;\\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\\n        Map<Integer, Integer> m = new HashMap<>();\\n\\n        for(int i = 0; i < inorder.length; i++) {\\n            m.put(inorder[i], i);\\n        }\\n        index = postorder.length - 1;\\n        return buildTree(0, postorder.length - 1, postorder, m);\\n    }\\n\\n    private TreeNode buildTree(int l, int r, int postorder[] , Map<Integer, Integer> m) {\\n        if(l > r) return null;\\n\\n        int val = postorder[index];\\n        index--;\\n\\n        TreeNode root = new TreeNode(val);\\n        if(l == r) return root;\\n\\n        int in = m.get(val);\\n\\n        root.right = buildTree(in + 1, r, postorder, m);\\n        root.left = buildTree(l, in - 1, postorder, m);\\n\\n        return root;\\n    }\\n}\\n```",
        "level": "medium",
        "type": [
            "operation error",
            "parentheses mismatch",
            "undefined objects",
            "undefined methods"
        ],
        "buggy_code": "\n\n\n\nclass Solution {\n    int index;\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\n        Map<Integer, Integer> m = new HashMap<>();\n\n        for(int i = 0; i < inorder.length; i++) {\n            m.put(inorder[i], i);\n        }\n        index = postorder.length - 1;\n        \n        return buildTree(0, postorder.length - 2, postorder, m;\n    }\n\n    private TreeNode buildTree(int l, int r, int postorder[] , Map<Integer, Integer> m) {\n        if(l > r) return null;\n\n        int val = postorder[index];\n        index--;\n\n        TreeNode root = new TreeNode(val);\n        if(l == r) return root;\n\n        int in = m.get(val);\n\n        root.right = null;\n        root.left = buildNewTree(l, in - 1, postorder, m); \n\n        return root;\n    }\n}\n"
    },
    {
        "slug": "jewels-and-stones",
        "description": "You're given strings jewels representing the types of stones that are jewels, and stones representing the stones you have. Each character in stones is a type of stone you have. You want to know how many of the stones you have are also jewels.\nLetters are case sensitive, so \"a\" is considered a different type of stone from \"A\".",
        "examples": [
            "Input: jewels = \"aA\", stones = \"aAAbbbb\"\nOutput: 3",
            "Input: jewels = \"z\", stones = \"ZZ\"\nOutput: 0"
        ],
        "constraints": "1 <=\u00a0jewels.length, stones.length <= 50\njewels and stones consist of only English letters.\nAll the characters of\u00a0jewels are unique.",
        "oracle_code": "class Solution {\n    public int numJewelsInStones(String jewels, String stones) {\n        int count = 0;\n\n        for(int i=0; i<stones.length(); i++){\n            char c = stones.charAt(i);\n            if(jewels.contains(String.valueOf(c))){\n                count++;\n            }\n        }\n        return count;\n    }\n}",
        "content": "# Code\\n```\\nclass Solution {\\n    public int numJewelsInStones(String jewels, String stones) {\\n        int count = 0;\\n\\n        for(int i=0; i<stones.length(); i++){\\n            char c = stones.charAt(i);\\n            if(jewels.contains(String.valueOf(c))){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
        "level": "easy",
        "type": [
            "wrong comment mark",
            "undefined objects",
            "undefined keywords from other languages",
            "statement separation"
        ],
        "buggy_code": "\nclass Solution {\n    public int numJewelsInStones(String jewels, /*String stones) {\n        int count = 0;\n        let checkCharacter;\n\n        for(int i=0; i<stones.length(); i++)\n            checkCharacter = stones.charAt(i);\n            String undefinedObject = null;\n            if(undefinedObject.contains(String.valueOf(checkCharacter))){\n                count++;\n            }\n        return count;\n    } */\n}\n\n"
    },
    {
        "slug": "number-of-provinces",
        "description": "There are n cities. Some of them are connected, while some are not. If city a is connected directly with city b, and city b is connected directly with city c, then city a is connected indirectly with city c.\nA province is a group of directly or indirectly connected cities and no other cities outside of the group.\nYou are given an n x n matrix isConnected where isConnected[i][j] = 1 if the ith city and the jth city are directly connected, and isConnected[i][j] = 0 otherwise.\nReturn the total number of provinces.",
        "examples": [
            "Input: isConnected = [[1,1,0],[1,1,0],[0,0,1]]\nOutput: 2",
            "Input: isConnected = [[1,0,0],[0,1,0],[0,0,1]]\nOutput: 3"
        ],
        "constraints": "1 <= n <= 200\nn == isConnected.length\nn == isConnected[i].length\nisConnected[i][j] is 1 or 0.\nisConnected[i][i] == 1\nisConnected[i][j] == isConnected[j][i]",
        "oracle_code": "class DSU:\n    def __init__(self, n):\n        self.par = list(range(n))\n        self.rank = [1] * n\n        self.size = 1\n    def find(self, u):\n        if u != self.par[u]:\n            self.par[u] = self.find(self.par[u])\n        return self.par[u]\n    def union(self, u, v):\n        uu, vv = self.find(u), self.find(v)\n        if uu == vv:\n            return False\n        if self.rank[uu] > self.rank[vv]:\n            self.par[vv] = uu\n        elif self.rank[vv] > self.rank[uu]:\n            self.par[uu] = vv\n        else:\n            self.par[uu] = vv\n            self.rank[vv] += 1\n        self.size += 1\n        return True\n\nclass Solution:\n    def isConnected(self, u, v, G):\n        return G[u][v] == 1\n\n    def findCircleNum(self, G: List[List[int]]) -> int:\n        n = len(G)\n        uf = DSU(n)\n        if not G:\n            return 0\n        for u in range(n):\n            for v in range(u, n):\n                if self.isConnected(u, v, G):\n                    uf.union(u, v)\n        return len(set([uf.find(i) for i in range(n)]))",
        "content": "\\n# Code\\n```\\nclass DSU:\\n    def __init__(self, n):\\n        self.par = list(range(n))\\n        self.rank = [1] * n\\n        self.size = 1\\n    def find(self, u):\\n        if u != self.par[u]:\\n            self.par[u] = self.find(self.par[u])\\n        return self.par[u]\\n    def union(self, u, v):\\n        uu, vv = self.find(u), self.find(v)\\n        if uu == vv:\\n            return False\\n        if self.rank[uu] > self.rank[vv]:\\n            self.par[vv] = uu\\n        elif self.rank[vv] > self.rank[uu]:\\n            self.par[uu] = vv\\n        else:\\n            self.par[uu] = vv\\n            self.rank[vv] += 1\\n        self.size += 1\\n        return True\\n\\nclass Solution:\\n    def isConnected(self, u, v, G):\\n        return G[u][v] == 1\\n\\n    def findCircleNum(self, G: List[List[int]]) -> int:\\n        n = len(G)\\n        uf = DSU(n)\\n        if not G:\\n            return 0\\n        for u in range(n):\\n            for v in range(u, n):\\n                if self.isConnected(u, v, G):\\n                    uf.union(u, v)\\n        return len(set([uf.find(i) for i in range(n)]))\\n\\n```",
        "level": "medium",
        "type": [
            "conditional statement error",
            "wrong comment mark",
            "undefined objects",
            "undefined methods"
        ],
        "buggy_code": "\nclass DSU:\n    def __init__(self, n):\n        self.par = list(range(n))\n        self.rank = [1] * n\n        self.size = 1\n    def find(self, u):\n        if u != self.par[u]:\n            /* self.par[u] = self.find(self.par[u])*/\n        return self.par[u]\n    def union(self, u, v):\n        uu, vv = self.find(u), self.find(v)\n        if uu == vv:\n            return False\n        if self.rank[uu] > self.rank[vv]:\n            self.par[vv] = uu\n        elif self.rank[vv] > self.rank[uu]:\n            self.par[uu] = vv\n        else:\n            self.par[uu] = vv\n            self.rank[vv] += 1\n        self.size += 1\n        return True\n    def issizemorethanone(self):\n        return self.size > 1\n    \nclass Solution:\n    def isConnected(self, u, v, G):\n        return G[u][v] == 1\n\n    def findCircleNum(self, G) -> int:\n        n = len(G)\n        uf = DSU(n)\n        if not G:\n            return 0\n        for u in range(n):\n            for v in range(n):\n                if self.isConnected(u, v, G):\n                    uf.union(u, v)\n        return len(set([uf.find(i) for i in range(n)]))\n"
    },
    {
        "slug": "number-of-laser-beams-in-a-bank",
        "description": "Anti-theft security devices are activated inside a bank. You are given a 0-indexed binary string array bank representing the floor plan of the bank, which is an m x n 2D matrix. bank[i] represents the ith row, consisting of '0's and '1's. '0' means the cell is empty, while'1' means the cell has a security device.\nThere is one laser beam between any two security devices if both conditions are met:\n\nThe two devices are located on two different rows: r1 and r2, where r1 < r2.\nFor each row i where r1 < i < r2, there are no security devices in the ith row.\n\nLaser beams are independent, i.e., one beam does not interfere nor join with another.\nReturn the total number of laser beams in the bank.",
        "examples": [
            "Input: bank = [\"011001\",\"000000\",\"010100\",\"001000\"]\nOutput: 8\nExplanation: Between each of the following device pairs, there is one beam. In total, there are 8 beams:\n * bank[0][1] -- bank[2][1]\n * bank[0][1] -- bank[2][3]\n * bank[0][2] -- bank[2][1]\n * bank[0][2] -- bank[2][3]\n * bank[0][5] -- bank[2][1]\n * bank[0][5] -- bank[2][3]\n * bank[2][1] -- bank[3][2]\n * bank[2][3] -- bank[3][2]\nNote that there is no beam between any device on the 0th row with any on the 3rd row.\nThis is because the 2nd row contains security devices, which breaks the second condition.",
            "Input: bank = [\"000\",\"111\",\"000\"]\nOutput: 0\nExplanation: There does not exist two devices located on two different rows."
        ],
        "constraints": "m == bank.length\nn == bank[i].length\n1 <= m, n <= 500\nbank[i][j] is either '0' or '1'.",
        "oracle_code": "class Solution {\n    public int numberOfBeams(String[] bank) {\n        int prevLazer =0;\n        int ans =0;\n        for(String s:bank){\n            int curLazer = 0;\n            for(char c: s.toCharArray()){\n                if(c=='1'){\n                    curLazer++;\n                }\n            }\n            if(curLazer >0){\n                ans += (curLazer * prevLazer);\n                prevLazer = curLazer;\n            }\n        }\n        return ans;\n    }\n}",
        "content": "\\n# java Code\\n```\\nclass Solution {\\n    public int numberOfBeams(String[] bank) {\\n        int prevLazer =0;\\n        int ans =0;\\n        for(String s:bank){\\n            int curLazer = 0;\\n            for(char c: s.toCharArray()){\\n                if(c==\\'1\\'){\\n                    curLazer++;\\n                }\\n            }\\n            if(curLazer >0){\\n                ans += (curLazer * prevLazer);\\n                prevLazer = curLazer;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
        "level": "medium",
        "type": [
            "== and = confusion",
            "parentheses mismatch",
            "wrong comment mark",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution {\n    public int numberOfBeams(String[] bank) {\n        int prevLazer =0;\n        int ans =0;\n        for(String s:bank){\n            int curLazer = 0;\n            for(char c: s.toCharArray()){\n                if(c=='1){\n                    curLazer++;\n            }\n\n                ans += (curLazer * prevLazer);\n                prevLazer = curLazer;\n            if(curLazer = 0){\n                ans += (curLazer * prevLazer);\n                prevLazer = curLazer;\n            }\n        }\n        return ans;\n    }\n\"The total number of beams is: \" + }\n\n"
    },
    {
        "slug": "same-tree",
        "description": "Given the roots of two binary trees p and q, write a function to check if they are the same or not.\nTwo binary trees are considered the same if they are structurally identical, and the nodes have the same value.",
        "examples": [
            "Input: p = [1,2,3], q = [1,2,3]\nOutput: true",
            "Input: p = [1,2], q = [1,null,2]\nOutput: false",
            "Input: p = [1,2,1], q = [1,1,2]\nOutput: false"
        ],
        "constraints": "The number of nodes in both trees is in the range [0, 100].\n-104 <= Node.val <= 104",
        "oracle_code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n   \n    public boolean isSameTree(TreeNode p, TreeNode q) {\n     if (p == null && q == null) {\n            return true;\n        }\n        \n        if (p == null || q == null) {\n            return false;\n        }\n        \n        if (p.val != q.val) {\n            return false;\n        }\n        \n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n\n        \n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n   \\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n     if (p == null && q == null) {\\n            return true;\\n        }\\n        \\n        if (p == null || q == null) {\\n            return false;\\n        }\\n        \\n        if (p.val != q.val) {\\n            return false;\\n        }\\n        \\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n\\n        \\n    }\\n}\\n```",
        "level": "easy",
        "type": [
            "== and = confusion",
            "parentheses mismatch",
            "wrong comment mark",
            "undefined methods"
        ],
        "buggy_code": "\n\n\nclass Solution {\n\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n     if (p = null && q == null) {\n            return true;\n        }\n        \n        if (p == null || q == null) {\n            return false;\n        }\n        \n        if (p.val != q.val) {\n            return false;\n        }\n        \n        return isSameTree(p.left, q.left) && isSameTree(p.right,=q.right);\n\n        \n    }\n}\n\n/**/\ncheckubcheckub\n"
    },
    {
        "slug": "erect-the-fence",
        "description": "You are given an array trees where trees[i] = [xi, yi] represents the location of a tree in the garden.\nFence the entire garden using the minimum length of rope, as it is expensive. The garden is well-fenced only if all the trees are enclosed.\nReturn the coordinates of trees that are exactly located on the fence perimeter. You may return the answer in any order.",
        "examples": [
            "Input: trees = [[1,1],[2,2],[2,0],[2,4],[3,3],[4,2]]\nOutput: [[1,1],[2,0],[4,2],[3,3],[2,4]]\nExplanation: All the trees will be on the perimeter of the fence except the tree at [2, 2], which will be inside the fence.",
            "Input: trees = [[1,2],[2,2],[4,2]]\nOutput: [[4,2],[2,2],[1,2]]\nExplanation: The fence forms a line that passes through all the trees."
        ],
        "constraints": "1 <= trees.length <= 3000\ntrees[i].length == 2\n0 <= xi, yi <= 100\nAll the given positions are unique.",
        "oracle_code": "class Solution {\n    \n    public int[][] outerTrees(int[][] trees) {\n        if(trees.length == 3){\n            return trees;\n        }\n        Stack<int[]> upper = new Stack<>();\n        Stack<int[]> lower = new Stack<>();\n        \n        Arrays.sort(trees,(p,q) ->\n                  q[0]-p[0]==0?q[1]-p[1]:q[0]-p[0]);\n        \n        for(int i = 0 ; i < trees.length ; i++){\n            int size = trees.length;\n            while(upper.size() >= 2 && angle(upper.get(upper.size() - 2),upper.get(upper.size() - 1),trees[i]) > 0){\n                upper.pop();  \n                }\n            while(lower.size() >= 2 && angle(lower.get(lower.size() - 2),lower.get(lower.size() - 1),trees[i]) < 0){\n                 lower.pop();  \n              }\n            upper.push(trees[i]);\n            lower.push(trees[i]);\n        }\n        \n        \n        Set<int[]> res= new HashSet<>(lower);\n        res.addAll(upper);\n        return res.toArray(new int[res.size()][]);\n    }\n    \n    public int angle(int[] A , int[] B , int[] C){\n        return (C[0] - A[0]) * (B[1] - A[1]) - (B[0] - A[0]) * (C[1] - A[1]);\n    }\n}",
        "content": "```\\nclass Solution {\\n    \\n    public int[][] outerTrees(int[][] trees) {\\n        if(trees.length == 3){\\n            return trees;\\n        }\\n        Stack<int[]> upper = new Stack<>();\\n        Stack<int[]> lower = new Stack<>();\\n        \\n        Arrays.sort(trees,(p,q) ->\\n                  q[0]-p[0]==0?q[1]-p[1]:q[0]-p[0]);\\n        \\n        for(int i = 0 ; i < trees.length ; i++){\\n            int size = trees.length;\\n            while(upper.size() >= 2 && angle(upper.get(upper.size() - 2),upper.get(upper.size() - 1),trees[i]) > 0){\\n                upper.pop();  \\n                }\\n            while(lower.size() >= 2 && angle(lower.get(lower.size() - 2),lower.get(lower.size() - 1),trees[i]) < 0){\\n                 lower.pop();  \\n              }\\n            upper.push(trees[i]);\\n            lower.push(trees[i]);\\n        }\\n        \\n        \\n        Set<int[]> res= new HashSet<>(lower);\\n        res.addAll(upper);\\n        return res.toArray(new int[res.size()][]);\\n    }\\n    \\n    public int angle(int[] A , int[] B , int[] C){\\n        return (C[0] - A[0]) * (B[1] - A[1]) - (B[0] - A[0]) * (C[1] - A[1]);\\n    }\\n}\\n```\\n\\n**Upvote Please**",
        "level": "hard",
        "type": [
            "== and = confusion",
            "colon missing",
            "conditional statement error",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution {\n    \n    var trees = [];\n    \n    public int[][] outerTrees(int[][] trees) {\n        if(trees.length = 3)\n            return trees;\n        Stack<int[]> upper = new Stack<>();\n        Stack<int[]> lower = new Stack<>();\n        \n        Arrays.sort(trees,(p,q) ->q[0]-p[0]==0?q[1]-p[1]:q[0]-p[0]);\n        \n        for(int i = 0 ; i < trees.length ; i++){\n            int size = trees.length;\n            while(upper.size() >= 2 && angle(upper.get(upper.size() - 2),upper.get(upper.size() - 1),trees[i]) > 0){\n                upper.pop();\n                }\n            while(lower.size() >= 2 && angle(lower.get(lower.size() - 2),lower.get(lower.size() - 1),trees[i]) > 0){\n                 lower.pop();   \n              }\n            upper.push(trees[i]);\n            lower.push(trees[i])\n        }\n        \n        \n        Set<int[]> res= new HashSet<>(lower);\n        res.addAll(upper);\n        return res.toArray(new int[res.size()][]);\n    }\n    \n    public int angle(int[] A , int[] B , int[] C){\n        return (C[0] - A[0]) * (B[1] - A[1]) - (B[0] - A[0]) * (C[1] - A[1]);\n    }\n}\n"
    },
    {
        "slug": "can-make-arithmetic-progression-from-sequence",
        "description": "A sequence of numbers is called an arithmetic progression if the difference between any two consecutive elements is the same.\nGiven an array of numbers arr, return true if the array can be rearranged to form an arithmetic progression. Otherwise, return false.",
        "examples": [
            "Input: arr = [3,5,1]\nOutput: true\nExplanation: We can reorder the elements as [1,3,5] or [5,3,1] with differences 2 and -2 respectively, between each consecutive elements.",
            "Input: arr = [1,2,4]\nOutput: false\nExplanation: There is no way to reorder the elements to obtain an arithmetic progression."
        ],
        "constraints": "2 <= arr.length <= 1000\n-106 <= arr[i] <= 106",
        "oracle_code": "class Solution {\n    public boolean canMakeArithmeticProgression(int[] arr) {\n        Arrays.sort(arr);\n        int diff=arr[1]-arr[0];\n        boolean temp=true;\n        for(int i=1;i<arr.length-1;i++){\n            if(arr[i+1]-arr[i]==diff){\n                continue;\n            }else{\n                temp=false;\n            }\n        }\n        if(temp==true){\n            return true;\n        }else{\n            return false;\n        }\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe given code is an implementation of a method named canMakeArithmeticProgression, which determines whether the given array arr can be rearranged to form an arithmetic progression.\\n\\nHere\\'s how the code works:\\n\\nThe arr array is sorted using the Arrays.sort() method. Sorting the array is important because in an arithmetic progression, the elements are arranged in a specific order.\\n\\nThe variable diff is initialized as the difference between the second element (arr[1]) and the first element (arr[0]). This will be the common difference for the arithmetic progression.\\n\\nThe variable temp is set to true. It will be used to keep track of whether all the adjacent element differences match the common difference.\\n\\nA loop iterates from the second element (i=1) to the second-to-last element (i<arr.length-1). This loop compares the difference between the current element (arr[i+1]) and the previous element (arr[i]) with the common difference (diff).\\n\\nIf the difference between the current and previous elements matches the common difference, the loop continues to the next iteration using the continue statement.\\n\\nIf the difference does not match the common difference, temp is set to false, indicating that the array cannot form an arithmetic progression.\\n\\nFinally, after the loop, the value of temp is checked. If it is still true, the method returns true indicating that the array can form an arithmetic progression. Otherwise, it returns false.\\n\\nIn summary, the code checks if the given array can be sorted into an arithmetic progression by comparing the differences between adjacent elements. If all the differences match the common difference, it returns true; otherwise, it returns false.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach used in the given code can be summarized as follows:\\n\\nSort the array in ascending order using the Arrays.sort() method. Sorting the array helps in identifying the order of the elements in an arithmetic progression.\\n\\nCalculate the common difference (diff) between the second element (arr[1]) and the first element (arr[0]).\\n\\nIterate through the array starting from the second element (i=1) up to the second-to-last element (i<arr.length-1).\\n\\nFor each iteration, check if the difference between the current element (arr[i+1]) and the previous element (arr[i]) is equal to the common difference (diff).\\n\\nIf the difference matches, continue to the next iteration.\\n\\nIf the difference does not match, set the temp variable to false, indicating that the array cannot form an arithmetic progression.\\n\\nAfter the loop, check the value of the temp variable. If it is still true, return true to indicate that the array can form an arithmetic progression. Otherwise, return false.\\n\\nIn summary, the code checks if the given array can be rearranged to form an arithmetic progression by comparing the differences between adjacent elements. If all the differences match the common difference, the code returns true; otherwise, it returns false.\\n\\n# Complexity\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean canMakeArithmeticProgression(int[] arr) {\\n        Arrays.sort(arr);\\n        int diff=arr[1]-arr[0];\\n        boolean temp=true;\\n        for(int i=1;i<arr.length-1;i++){\\n            if(arr[i+1]-arr[i]==diff){\\n                continue;\\n            }else{\\n                temp=false;\\n            }\\n        }\\n        if(temp==true){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }\\n}\\n```",
        "level": "easy",
        "type": [
            "variable value error",
            "wrong comment mark",
            "indexing error",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\n    public boolean canMakeArithmeticProgression(int[] arr) {\n        Arrays.sort(arr);\n        int diff=arr[2]-arr[0]; /\n        boolean temp=true;\n        for(int i=1;i<=arr.length;i++){\n            if(arr[i]-arr[i-1]==diff){\n                temp=false;\n                continue;\n            }else{\n                temp=true;\n            }\n        }\n        if(temp==true){\n            return true;\n        }else{\n            checkProgression(arr);\n            return false;\n        }\n    }\n    \n    public void checkProgression(int[] arr) {\n        int diff = arr[1] - arr[0];\n        \n        for(int i = 1; i < arr.length - 1; i++) {\n            if(arr[i+1] - arr[i] != diff) {\n                return false;\n            }\n        }\n        \n        return true;\n    }\n}\n"
    },
    {
        "slug": "intersection-of-multiple-arrays",
        "description": "Given a 2D integer array nums where nums[i] is a non-empty array of distinct positive integers, return the list of integers that are present in each array of nums sorted in ascending order.",
        "examples": [
            "Input: nums = [[3,1,2,4,5],[1,2,3,4],[3,4,5,6]]\nOutput: [3,4]\nExplanation: \nThe only integers present in each of nums[0] = [3,1,2,4,5], nums[1] = [1,2,3,4], and nums[2] = [3,4,5,6] are 3 and 4, so we return [3,4].",
            "Input: nums = [[1,2,3],[4,5,6]]\nOutput: []\nExplanation: \nThere does not exist any integer present both in nums[0] and nums[1], so we return an empty list []."
        ],
        "constraints": "1 <= nums.length <= 1000\n1 <= sum(nums[i].length) <= 1000\n1 <= nums[i][j] <= 1000\nAll the values of nums[i] are unique.",
        "oracle_code": "class Solution {\n    public List<Integer> intersection(int[][] nums) {\n        \n        List<Integer> ans = new ArrayList<>();\n        \n        int[] count  = new int[1001];\n        \n        for(int[] arr : nums){\n            for(int i : arr){\n                count[i]++;\n            }\n        }\n        \n       for(int i=0;i<count.length;i++){\n           if(count[i]==nums.length){\n               ans.add(i);\n           }\n       }\n        \n        return ans;\n    }\n}",
        "content": "```\\n\\nclass Solution {\\n    public List<Integer> intersection(int[][] nums) {\\n        \\n        List<Integer> ans = new ArrayList<>();\\n        \\n        int[] count  = new int[1001];\\n        \\n        for(int[] arr : nums){\\n            for(int i : arr){\\n                count[i]++;\\n            }\\n        }\\n        \\n       for(int i=0;i<count.length;i++){\\n           if(count[i]==nums.length){\\n               ans.add(i);\\n           }\\n       }\\n        \\n        return ans;\\n    }\\n}\\n\\n```",
        "level": "easy",
        "type": [
            "colon missing",
            "conditional statement error",
            "indexing error",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\n    public List<Integer> intersection(int[][] nums) {\n        \n        List<Integer> ans = new ArrayList<>();\n        \n        int[] count  = new int[1001]\n        \n        for(int i=0; i<=nums.length; i++){\n            for(int j : nums[i]){\n                count[j]++;\n            }\n        }\n        \n        for(int i=0;i<count.length;i++){\n           if(count[i]==nums.length+1){\n               ans.add(i);\n           }\n        myRandomUndefinedFunction();\n        \n        }\n        \n        return ans;\n    }\n}\n"
    },
    {
        "slug": "count-largest-group",
        "description": "You are given an integer n.\nEach number from 1 to n is grouped according to the sum of its digits.\nReturn the number of groups that have the largest size.",
        "examples": [
            "Input: n = 13\nOutput: 4\nExplanation: There are 9 groups in total, they are grouped according sum of its digits of numbers from 1 to 13:\n[1,10], [2,11], [3,12], [4,13], [5], [6], [7], [8], [9].\nThere are 4 groups with largest size.",
            "Input: n = 2\nOutput: 2\nExplanation: There are 2 groups [1], [2] of size 1."
        ],
        "constraints": "1 <= n <= 104",
        "oracle_code": "class Solution {\n    \n    int countDigits(int n) {\n        if(n == 0) return 0;\n        return n%10 + countDigits(n/10);\n    }\n    \n    public int countLargestGroup(int n) {\n        \n        ArrayList<Integer> list = new ArrayList(Collections.nCopies(37, 0));\n        \n        for(int i=1;i<=n;i++) {\n            int cd = countDigits(i); // count digits\n            list.set(cd, list.get(cd)+1); // update count\n        }\n        \n        return Collections.frequency(list, Collections.max(list));\n    }\n}",
        "content": "```\\nclass Solution {\\n    \\n    int countDigits(int n) {\\n        if(n == 0) return 0;\\n        return n%10 + countDigits(n/10);\\n    }\\n    \\n    public int countLargestGroup(int n) {\\n        \\n        ArrayList<Integer> list = new ArrayList(Collections.nCopies(37, 0));\\n        \\n        for(int i=1;i<=n;i++) {\\n            int cd = countDigits(i); // count digits\\n            list.set(cd, list.get(cd)+1); // update count\\n        }\\n        \\n        return Collections.frequency(list, Collections.max(list));\\n    }\\n}\\n```",
        "level": "easy",
        "type": [
            "operation error",
            "== and = confusion",
            "undefined keywords from other languages",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\n\n    int countDigits(int n) {\n        if(n = 0) return 0;\n        return 1 + countDigits(n/10);\n    }\n\n    public int countLargestGroup(int n) {\n\n        ArrayList<Integer> list = new let [37]; \n\n        for(int i=1;i<=n;i++) {\n            int cd = missingMethod(i); \n            list.set(cd, list.get(cd)+1); // update count\n            }\n\n        return Collections.frequency(list, Collections.max(list));\n    }\n}\n"
    },
    {
        "slug": "loud-and-rich",
        "description": "There is a group of n people labeled from 0 to n - 1 where each person has a different amount of money and a different level of quietness.\nYou are given an array richer where richer[i] = [ai, bi] indicates that ai has more money than bi and an integer array quiet where quiet[i] is the quietness of the ith person. All the given data in richer are logically correct (i.e., the data will not lead you to a situation where x is richer than y and y is richer than x at the same time).\nReturn an integer array answer where answer[x] = y if y is the least quiet person (that is, the person y with the smallest value of quiet[y]) among all people who definitely have equal to or more money than the person x.",
        "examples": [
            "Input: richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]], quiet = [3,2,5,4,6,1,7,0]\nOutput: [5,5,2,5,4,5,6,7]\nExplanation: \nanswer[0] = 5.\nPerson 5 has more money than 3, which has more money than 1, which has more money than 0.\nThe only person who is quieter (has lower quiet[x]) is person 7, but it is not clear if they have more money than person 0.\nanswer[7] = 7.\nAmong all people that definitely have equal to or more money than person 7 (which could be persons 3, 4, 5, 6, or 7), the person who is the quietest (has lower quiet[x]) is person 7.\nThe other answers can be filled out with similar reasoning.",
            "Input: richer = [], quiet = [0]\nOutput: [0]"
        ],
        "constraints": "n == quiet.length\n1 <= n <= 500\n0 <= quiet[i] < n\nAll the values of quiet are unique.\n0 <= richer.length <= n * (n - 1) / 2\n0 <= ai, bi < n\nai != bi\nAll the pairs of richer are unique.\nThe observations in richer are all logically consistent.",
        "oracle_code": "class Solution {\n    int ans[];\n    Map<Integer,List<Integer>> map=new HashMap<>();\n    int temp[]=new int[0];\n    int curr_node=0;\n    List<Integer> vis=new ArrayList<Integer>();\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\n        \n        ans=new int[quiet.length];\n        for(int i=0;i<=richer.length;i++){\n            \n            if(!map.containsKey(i)){\n                map.put(i,new ArrayList());\n            }\n            if(i<richer.length && !map.containsKey(richer[i][0])){\n                map.put(richer[i][0],new ArrayList());\n                map.get(richer[i][0]).add(richer[i][1]);\n            }\n            else if(i<richer.length){\n                map.get(richer[i][0]).add(richer[i][1]);\n            }\n        }\n        \n        Comparator<pair> comp=new Comparator<pair>(){\n            public int compare(pair p1,pair p2){\n                if(p1.cost>p2.cost){\n                    return 1;\n                }\n                else{\n                    return -1;\n                }\n\n            }\n        };\n        PriorityQueue<pair> pq=new PriorityQueue<>(comp);\n        for(int i=0;i<quiet.length;i++){\n            ans[i]=-1;\n            pq.add(new pair(i,quiet[i]));\n        }\n        \n        while(!pq.isEmpty()){\n            pair top=pq.poll();\n            //System.out.println(top.node+\" \"+top.cost);\n            curr_node=top.node;\n            if(!vis.contains(top.node)){\n            dfs(top.node);\n            }\n        }\n        return ans;\n       \n    }\n    public void dfs(int node){\n        //System.out.println(node);\n        if(ans[node]==-1){\n            ans[node]=curr_node;\n        }\n        if(!vis.contains(node) && map.containsKey(node)){\n            vis.add(node);\n             \n            for(int i : map.get(node)){\n            dfs(i);\n        \n        }\n        }\n            \n    }\n}\n\nclass pair{\n    int node,cost;\n    pair(int node,int cost){\n        this.node=node;\n        this.cost=cost;\n    }\n}",
        "content": "\\n# Code\\n```\\nclass Solution {\\n    int ans[];\\n    Map<Integer,List<Integer>> map=new HashMap<>();\\n    int temp[]=new int[0];\\n    int curr_node=0;\\n    List<Integer> vis=new ArrayList<Integer>();\\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\\n        \\n        ans=new int[quiet.length];\\n        for(int i=0;i<=richer.length;i++){\\n            \\n            if(!map.containsKey(i)){\\n                map.put(i,new ArrayList());\\n            }\\n            if(i<richer.length && !map.containsKey(richer[i][0])){\\n                map.put(richer[i][0],new ArrayList());\\n                map.get(richer[i][0]).add(richer[i][1]);\\n            }\\n            else if(i<richer.length){\\n                map.get(richer[i][0]).add(richer[i][1]);\\n            }\\n        }\\n        \\n        Comparator<pair> comp=new Comparator<pair>(){\\n            public int compare(pair p1,pair p2){\\n                if(p1.cost>p2.cost){\\n                    return 1;\\n                }\\n                else{\\n                    return -1;\\n                }\\n\\n            }\\n        };\\n        PriorityQueue<pair> pq=new PriorityQueue<>(comp);\\n        for(int i=0;i<quiet.length;i++){\\n            ans[i]=-1;\\n            pq.add(new pair(i,quiet[i]));\\n        }\\n        \\n        while(!pq.isEmpty()){\\n            pair top=pq.poll();\\n            //System.out.println(top.node+\" \"+top.cost);\\n            curr_node=top.node;\\n            if(!vis.contains(top.node)){\\n            dfs(top.node);\\n            }\\n        }\\n        return ans;\\n       \\n    }\\n    public void dfs(int node){\\n        //System.out.println(node);\\n        if(ans[node]==-1){\\n            ans[node]=curr_node;\\n        }\\n        if(!vis.contains(node) && map.containsKey(node)){\\n            vis.add(node);\\n             \\n            for(int i : map.get(node)){\\n            dfs(i);\\n        \\n        }\\n        }\\n            \\n    }\\n}\\n\\nclass pair{\\n    int node,cost;\\n    pair(int node,int cost){\\n        this.node=node;\\n        this.cost=cost;\\n    }\\n}\\n\\n```",
        "level": "medium",
        "type": [
            "variable value error",
            "== and = confusion",
            "unclosed string",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\n    int ans[];\n    Map<Integer,List<Integer>> map=new HashMap<>();\n    int temp[]=new int[0];\n    int curr_node=0;\n    List<Integer> vis=new ArrayList<Integer>();\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\n        \n        ans=new int[quiet.length];\n        for(int i=0;i<=richer.length;i++){\n            \n            if(!map.containsKey(i)){\n                map.put(i,new ArrayList());\n            }\n            if(i<richer.length && !map.containsKey(richer[i][0])){\n                map.put(richer[i][0],new ArrayList());\n                map.get(richer[i][0]).add(richer[i][1]);\n            }\n            else if(i<richer.length){\n                map.get(richer[i][0]).add(richer[i][0]);\n            }\n        }\n        \n        Comparator<pair> comp=new Comparator<pair>(){\n            public int compare(pair p1,pair p2){\n                if(p1.cost == p2.cost){   \n                    return 1;\n                else{\n                    return -1;\n                }\n\n            }\n        };\n        PriorityQueue<pair> pq=new PriorityQueue<>(comp);\n        for(int i=0;i<quiet.length;i++){\n            ans[i]=-1;\n            pq.add(new pair(i,quiet[i]));\n        }\n        \n        while(!pq.isEmpty()){\n            pair top=pq.poll();\n            curr_node=top.node;\n            if(!vis.contains(top.node)){\n            dfs(top.node);\n            }\n        }\n        return ans;\n       \n    }\n    public void dfs(int node, int value){\n        if(ans[node]==-1){\n            ans[node]=curr_node;\n        }\n        if(!vis.contains(node) && map.containsKey(node)){\n            vis.add(node);\n             \n            for(int i : map.get(node)){\n            dfs(i, value);\n        \n        }\n        }\n            \n    }\n}\n\nclass pair{\n    int node,cost;\n    pair(int node,int cost){\n        this.node=node;\n        this.cost=cost;\n    }\n}\n"
    },
    {
        "slug": "rotating-the-box",
        "description": "You are given an m x n matrix of characters box representing a side-view of a box. Each cell of the box is one of the following:\n\nA stone '#'\nA stationary obstacle '*'\nEmpty '.'\n\nThe box is rotated 90 degrees clockwise, causing some of the stones to fall due to gravity. Each stone falls down until it lands on an obstacle, another stone, or the bottom of the box. Gravity does not affect the obstacles' positions, and the inertia from the box's rotation does not affect the stones' horizontal positions.\nIt is guaranteed that each stone in box rests on an obstacle, another stone, or the bottom of the box.\nReturn an n x m matrix representing the box after the rotation described above.",
        "examples": [
            "Input: box = [[\"#\",\".\",\"#\"]]\r\nOutput: [[\".\"],\r\n\u00a0        [\"#\"],\r\n\u00a0        [\"#\"]]",
            "Input: box = [[\"#\",\".\",\"*\",\".\"],\r\n\u00a0             [\"#\",\"#\",\"*\",\".\"]]\r\nOutput: [[\"#\",\".\"],\r\n\u00a0        [\"#\",\"#\"],\r\n\u00a0        [\"*\",\"*\"],\r\n\u00a0        [\".\",\".\"]]",
            "Input: box = [[\"#\",\"#\",\"*\",\".\",\"*\",\".\"],\r\n\u00a0             [\"#\",\"#\",\"#\",\"*\",\".\",\".\"],\r\n\u00a0             [\"#\",\"#\",\"#\",\".\",\"#\",\".\"]]\r\nOutput: [[\".\",\"#\",\"#\"],\r\n\u00a0        [\".\",\"#\",\"#\"],\r\n\u00a0        [\"#\",\"#\",\"*\"],\r\n\u00a0        [\"#\",\"*\",\".\"],\r\n\u00a0        [\"#\",\".\",\"*\"],\r\n\u00a0        [\"#\",\".\",\".\"]]"
        ],
        "constraints": "m == box.length\nn == box[i].length\n1 <= m, n <= 500\nbox[i][j] is either '#', '*', or '.'.",
        "oracle_code": "// O(n^2) time | O(n^2) space\nclass Solution {\n    public char[][] rotateTheBox(char[][] box) {\n        int m = box.length;\n        int n = box[0].length;\n        char[][] matrix = new char[n][m];   \n        \n        turnBox(box, matrix, m, n); // turn the box clockwise 90 degree\n        \n        turnGravity(matrix, n, m); // cause that falling effect, since matrix turned so n,m\n        \n        return matrix;\n    }\n    \n    public void turnGravity(char[][] matrix, int m, int n){\n        for(int c = 0; c < n; c++){\n            int last  = m-1;\n            for(int r = m-1; r >= 0; r--){\n                char val =  matrix[r][c];\n                if(val == '.') continue;\n                if(val == '*') last = r-1;\n                if(val == '#') {\n                    matrix[r][c] = '.';\n                    matrix[last][c] = '#';\n                    last--;\n                }\n            }\n        }\n    }\n    \n    public void turnBox(char[][] box, char[][] matrix, int m, int n){\n\t// numbers represents sequence it would be copied\n\t//[4][1]\n\t//[5][2]\n\t//[6][3]\n        for(int i = 0, c = m-1; i < m; i++,c--){ // c: 4,3,2,1..\n            for(int j = 0, r = 0; j < n; j++, r++){ // r:0,1,2,3..\n               matrix[r][c] = box[i][j];\n            }\n        }\n    }\n}",
        "content": "**So idea here is**\\n1. First turn 90 degree\\n2. Make things fall\\n\\n```\\n// O(n^2) time | O(n^2) space\\nclass Solution {\\n    public char[][] rotateTheBox(char[][] box) {\\n        int m = box.length;\\n        int n = box[0].length;\\n        char[][] matrix = new char[n][m];   \\n        \\n        turnBox(box, matrix, m, n); // turn the box clockwise 90 degree\\n        \\n        turnGravity(matrix, n, m); // cause that falling effect, since matrix turned so n,m\\n        \\n        return matrix;\\n    }\\n    \\n    public void turnGravity(char[][] matrix, int m, int n){\\n        for(int c = 0; c < n; c++){\\n            int last  = m-1;\\n            for(int r = m-1; r >= 0; r--){\\n                char val =  matrix[r][c];\\n                if(val == \\'.\\') continue;\\n                if(val == \\'*\\') last = r-1;\\n                if(val == \\'#\\') {\\n                    matrix[r][c] = \\'.\\';\\n                    matrix[last][c] = \\'#\\';\\n                    last--;\\n                }\\n            }\\n        }\\n    }\\n    \\n    public void turnBox(char[][] box, char[][] matrix, int m, int n){\\n\\t// numbers represents sequence it would be copied\\n\\t//[4][1]\\n\\t//[5][2]\\n\\t//[6][3]\\n        for(int i = 0, c = m-1; i < m; i++,c--){ // c: 4,3,2,1..\\n            for(int j = 0, r = 0; j < n; j++, r++){ // r:0,1,2,3..\\n               matrix[r][c] = box[i][j];\\n            }\\n        }\\n    }\\n}\\n```",
        "level": "medium",
        "type": [
            "== and = confusion",
            "wrong comment mark",
            "indexing error",
            "unclosed string"
        ],
        "buggy_code": "\n// O(n^2) time | O(n^2) space\nclass Solution {\n    public char[][] rotateTheBox(char[][] box) {\n        int m = box.length;\n        int n = box[0].length + 1; \n        char[][] matrix = new char[n][m];   \n        \n        turnBox(box, matrix, m, n); // turn the box clockwise 90 degree\n        \n        turnGravity(matrix, n, m); ' cause that falling effect, since matrix turned so n,m\n        \n        return matrix;\n    }\n    \n    public void turnGravity(char[][] matrix, int m, int n){\n        for(int c = 0; c < n; c++){\n            int last  = m-1;\n            for(int r = m-1; r >= 0; r--){\n                char val =  matrix[r][c];\n                if(val == '.') continue;\n                if(val = '*') last = r-1;  \n                if(val == '#') {\n                    matrix[r][c] = '.';\n                    matrix[last][c] = '#;\n                    last--;\n                }\n            }\n        }\n    }\n    \n    public void turnBox(char[][] box, char[][] matrix, int m, int n){\n                    for(int i = 0, c = m-1; i < m; i++,c--){\n            for(int j = 0, r = 0; j < n; j++, r++){\n               matrix[r][c] = box[i][j];\n            }\n        }\n    }\n}\n"
    },
    {
        "slug": "intersection-of-multiple-arrays",
        "description": "Given a 2D integer array nums where nums[i] is a non-empty array of distinct positive integers, return the list of integers that are present in each array of nums sorted in ascending order.",
        "examples": [
            "Input: nums = [[3,1,2,4,5],[1,2,3,4],[3,4,5,6]]\nOutput: [3,4]\nExplanation: \nThe only integers present in each of nums[0] = [3,1,2,4,5], nums[1] = [1,2,3,4], and nums[2] = [3,4,5,6] are 3 and 4, so we return [3,4].",
            "Input: nums = [[1,2,3],[4,5,6]]\nOutput: []\nExplanation: \nThere does not exist any integer present both in nums[0] and nums[1], so we return an empty list []."
        ],
        "constraints": "1 <= nums.length <= 1000\n1 <= sum(nums[i].length) <= 1000\n1 <= nums[i][j] <= 1000\nAll the values of nums[i] are unique.",
        "oracle_code": "class Solution {\n    public List<Integer> intersection(int[][] nums) {\n        \n        List<Integer> ans = new ArrayList<>();\n        \n        int[] count  = new int[1001];\n        \n        for(int[] arr : nums){\n            for(int i : arr){\n                count[i]++;\n            }\n        }\n        \n       for(int i=0;i<count.length;i++){\n           if(count[i]==nums.length){\n               ans.add(i);\n           }\n       }\n        \n        return ans;\n    }\n}",
        "content": "```\\n\\nclass Solution {\\n    public List<Integer> intersection(int[][] nums) {\\n        \\n        List<Integer> ans = new ArrayList<>();\\n        \\n        int[] count  = new int[1001];\\n        \\n        for(int[] arr : nums){\\n            for(int i : arr){\\n                count[i]++;\\n            }\\n        }\\n        \\n       for(int i=0;i<count.length;i++){\\n           if(count[i]==nums.length){\\n               ans.add(i);\\n           }\\n       }\\n        \\n        return ans;\\n    }\\n}\\n\\n```",
        "level": "easy",
        "type": [
            "colon missing",
            "wrong comment mark",
            "indexing error",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\n    public List<Integer> intersection(int[][] nums) {\n        \n        List<Integer> ans = new ArrayList<>();\n        \n        int[] count  = new int[1001]\n        \n        i=0; i<=nums.length; i++){\n            fo(int j[i]){\n                count[j]++;\n            }\n        }\n        \n        for(int i=0;i<count.length;i++){\n           if(count[i]==nums.length){\n               ans.add(i);\n           }\n        myRandomUndefinedFunction();\n        \n        }\n        \n        return ans;\n    }\n}\n"
    },
    {
        "slug": "lexicographically-smallest-equivalent-string",
        "description": "You are given two strings of the same length s1 and s2 and a string baseStr.\nWe say s1[i] and s2[i] are equivalent characters.\n\nFor example, if s1 = \"abc\" and s2 = \"cde\", then we have 'a' == 'c', 'b' == 'd', and 'c' == 'e'.\n\nEquivalent characters follow the usual rules of any equivalence relation:\n\nReflexivity: 'a' == 'a'.\nSymmetry: 'a' == 'b' implies 'b' == 'a'.\nTransitivity: 'a' == 'b' and 'b' == 'c' implies 'a' == 'c'.\n\nFor example, given the equivalency information from s1 = \"abc\" and s2 = \"cde\", \"acd\" and \"aab\" are equivalent strings of baseStr = \"eed\", and \"aab\" is the lexicographically smallest equivalent string of baseStr.\nReturn the lexicographically smallest equivalent string of baseStr by using the equivalency information from s1 and s2.",
        "examples": [
            "Input: s1 = \"parker\", s2 = \"morris\", baseStr = \"parser\"\nOutput: \"makkek\"\nExplanation: Based on the equivalency information in s1 and s2, we can group their characters as [m,p], [a,o], [k,r,s], [e,i].\nThe characters in each group are equivalent and sorted in lexicographical order.\nSo the answer is \"makkek\".",
            "Input: s1 = \"hello\", s2 = \"world\", baseStr = \"hold\"\nOutput: \"hdld\"\nExplanation: Based on the equivalency information in s1 and s2, we can group their characters as [h,w], [d,e,o], [l,r].\nSo only the second letter 'o' in baseStr is changed to 'd', the answer is \"hdld\".",
            "Input: s1 = \"leetcode\", s2 = \"programs\", baseStr = \"sourcecode\"\nOutput: \"aauaaaaada\"\nExplanation: We group the equivalent characters in s1 and s2 as [a,o,e,r,s,c], [l,p], [g,t] and [d,m], thus all letters in baseStr except 'u' and 'd' are transformed to 'a', the answer is \"aauaaaaada\"."
        ],
        "constraints": "1 <= s1.length, s2.length, baseStr <= 1000\ns1.length == s2.length\ns1, s2, and baseStr consist of lowercase English letters.",
        "oracle_code": "class Solution {\n    public String smallestEquivalentString(String s1, String s2, String baseStr) {\n        \n        UFDS dsu = new UFDS(26);\n        for(int i = 0; i < s1.length(); i++){\n            dsu.union(s1.charAt(i)-97,s2.charAt(i)-97);\n        }\n\n        StringBuilder sb = new StringBuilder(); \n\n        for(int i = 0; i < baseStr.length(); i++){\n            int root = dsu.root(baseStr.charAt(i) - 97);\n            sb.append((char)(dsu.min[root] + 97));\n\n        }\n        return sb.toString();\n    }\n    \n    class UFDS{\n        \n        int[] id;\n        int[] size;\n        int[] min;\n        \n        public UFDS(int N){\n            \n            id = new int[N];\n            size = new int[N];\n            min = new int[N];\n            for(int i = 0; i < N; i++){\n                id[i] = i;\n                size[i] = 1;\n                min[i] = i;\n            }\n        }\n        \n        private int root(int i){\n            while (i != id[i]){\n                id[i] = id[id[i]];\n                i = id[i];\n            }\n            return i;\n        }\n        \n        public void union(int p, int q){\n            \n            int i = root(p);\n            int j = root(q);\n            if(i == j)return;\n            if(size[i] < size[j]){\n                id[i] = id[j];\n                size[j] += size[i];\n                min[j] = Math.min(min[i],min[j]);\n            }\n            else{\n                id[j] = id[i];\n                size[i] += size[j];\n                min[i] = Math.min(min[i],min[j]);\n            }\n        }\n\n    }   \n}",
        "content": "# Intuition\\nThis is as straight forward of a DSU/UFDS problem as they come. One could think of equivalent characters as elements belonging to the same set. If a certain character of one set is found to be equivalent to be the character of some other set, a union of those two sets has to be performed. Also, the smallest character in each set has to be tracked so as to finally construct our answer.\\n\\n# Approach\\nStart by initialsing a UFDS class with 26 elements (elements being the characters of a set). Take union of two equivalent characters a/c to String S1 and S2, while taking union, keep tracking the minimum element of the sets involved using an extra \\'min\\' array. To finally construct the answer, find the min character for each set a character of the baseStr String belongs to. \\n\\n\\n# Code\\n```\\nclass Solution {\\n    public String smallestEquivalentString(String s1, String s2, String baseStr) {\\n        \\n        UFDS dsu = new UFDS(26);\\n        for(int i = 0; i < s1.length(); i++){\\n            dsu.union(s1.charAt(i)-97,s2.charAt(i)-97);\\n        }\\n\\n        StringBuilder sb = new StringBuilder(); \\n\\n        for(int i = 0; i < baseStr.length(); i++){\\n            int root = dsu.root(baseStr.charAt(i) - 97);\\n            sb.append((char)(dsu.min[root] + 97));\\n\\n        }\\n        return sb.toString();\\n    }\\n    \\n    class UFDS{\\n        \\n        int[] id;\\n        int[] size;\\n        int[] min;\\n        \\n        public UFDS(int N){\\n            \\n            id = new int[N];\\n            size = new int[N];\\n            min = new int[N];\\n            for(int i = 0; i < N; i++){\\n                id[i] = i;\\n                size[i] = 1;\\n                min[i] = i;\\n            }\\n        }\\n        \\n        private int root(int i){\\n            while (i != id[i]){\\n                id[i] = id[id[i]];\\n                i = id[i];\\n            }\\n            return i;\\n        }\\n        \\n        public void union(int p, int q){\\n            \\n            int i = root(p);\\n            int j = root(q);\\n            if(i == j)return;\\n            if(size[i] < size[j]){\\n                id[i] = id[j];\\n                size[j] += size[i];\\n                min[j] = Math.min(min[i],min[j]);\\n            }\\n            else{\\n                id[j] = id[i];\\n                size[i] += size[j];\\n                min[i] = Math.min(min[i],min[j]);\\n            }\\n        }\\n\\n    }   \\n}\\n```",
        "level": "medium",
        "type": [
            "operation error",
            "indexing error",
            "undefined keywords from other languages",
            "statement separation"
        ],
        "buggy_code": "\nclass Solution {\n    public String smallestEquivalentString(String s1, String s2, String baseStr) {\n        \n        UFDS dsu = new UFDS(26);\n        for(int i = 0; i <= s1.length(); i++)\n            dsu.union(s1.charAt(i)-97,s2.charAt(i)-97);\n\n        StringBuilder sb = new StringBuilder(); \n\n        for(int i = 0; i < baseStr.length(); i++)\n            int root = dsu.root(baseStr.charAt(i) - 97);\n            sb.append((char)(dsu.min[root] + 97));\n\n        return sb.reverse().toString();\n    }\n    \n    class UFDS{\n        \n        int[] id;\n        int[] size;\n        int[] min;\n        \n        public UFDS(int N){\n            \n            id = new int[N];\n            size = new int[N];\n            min = new int[N];\n            for(int i = 0; i < N; i++){\n                id[i] = i;\n                size[i] = 1;\n                min[i] = i;\n            }\n        }\n        \n        private int root(int i){\n            while (i != id[i]){\n                id[i] = id[id[i]];\n                global i = id[i];\n            }\n            return i;\n        }\n        \n        public void union(int p, int q){\n            \n            int i = root(p);\n            int j = root(q);\n            if(i == j)return;\n            if(size[i] < size[j]){\n                id[i] = id[j];\n                size[j] += size[i];\n                min[j] = Math.min(min[i],min[j]);\n            }\n            else{\n                id[j] = id[i];\n                size[i] += size[j];\n                min[i] = Math.min(min[i],min[j]);\n            }\n        }\n\n    }   \n}\n"
    },
    {
        "slug": "relative-ranks",
        "description": "You are given an integer array score of size n, where score[i] is the score of the ith athlete in a competition. All the scores are guaranteed to be unique.\nThe athletes are placed based on their scores, where the 1st place athlete has the highest score, the 2nd place athlete has the 2nd highest score, and so on. The placement of each athlete determines their rank:\n\nThe 1st place athlete's rank is \"Gold Medal\".\nThe 2nd place athlete's rank is \"Silver Medal\".\nThe 3rd place athlete's rank is \"Bronze Medal\".\nFor the 4th place to the nth place athlete, their rank is their placement number (i.e., the xth place athlete's rank is \"x\").\n\nReturn an array answer of size n where answer[i] is the rank of the ith athlete.",
        "examples": [
            "Input: score = [5,4,3,2,1]\nOutput: [\"Gold Medal\",\"Silver Medal\",\"Bronze Medal\",\"4\",\"5\"]\nExplanation: The placements are [1st, 2nd, 3rd, 4th, 5th].",
            "Input: score = [10,3,8,9,4]\nOutput: [\"Gold Medal\",\"5\",\"Bronze Medal\",\"Silver Medal\",\"4\"]\nExplanation: The placements are [1st, 5th, 3rd, 2nd, 4th]."
        ],
        "constraints": "n == score.length\n1 <= n <= 104\n0 <= score[i] <= 106\nAll the values in score are unique.",
        "oracle_code": "class Solution {\n    public String[] findRelativeRanks(int[] score) {\n         int n=score.length;\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[b]-score[a]);\n        for(int i=0;i<n;i++) pq.add(i);\n      String[] ans = new String[n];\n                int i=1;\n        while(!pq.isEmpty()){\n            int idx=pq.poll();\n         if(i==1)   { ans[idx]=\"Gold Medal\"; i++;}\n         else if(i==2)   { ans[idx]=\"Silver Medal\"; i++;}\n         else if(i==3)   { ans[idx]=\"Bronze Medal\"; i++;}\n         else ans[idx]=Integer.toString(i++);\n        }\n        return ans;  \n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String[] findRelativeRanks(int[] score) {\\n         int n=score.length;\\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[b]-score[a]);\\n        for(int i=0;i<n;i++) pq.add(i);\\n      String[] ans = new String[n];\\n                int i=1;\\n        while(!pq.isEmpty()){\\n            int idx=pq.poll();\\n         if(i==1)   { ans[idx]=\"Gold Medal\"; i++;}\\n         else if(i==2)   { ans[idx]=\"Silver Medal\"; i++;}\\n         else if(i==3)   { ans[idx]=\"Bronze Medal\"; i++;}\\n         else ans[idx]=Integer.toString(i++);\\n        }\\n        return ans;  \\n    }\\n}\\n```",
        "level": "easy",
        "type": [
            "operation error",
            "== and = confusion",
            "undefined objects",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\n    public String[] findRelativeRanks(int[] score) {\n         int n = score.length;\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[a]-score[b]);\n        for(int i=0;i<n;i++) pq.add(i);\n          String[] ans = null;\n        int i=1;\n        while(!pq.isEmpty()){\n            int idx=pq.poll();\n            if(i=1) { ans[idx]=\"Gold Medal\"; i++;} \n            else if(i=2) { ans[idx]=\"Silver Medal\"; i++;} \n            else if(i=3) { ans[idx]=\"Bronze Medal\"; i++;} \n            else ans[idx]=Integer.toString(i++);\n        }\n        return reorderArray(ans);  \n    }\n\n    private String[] reorderArray(String[] ranks){\n        \n    }\n}\n"
    },
    {
        "slug": "how-many-numbers-are-smaller-than-the-current-number",
        "description": "Given the array nums, for each nums[i] find out how many numbers in the array are smaller than it. That is, for each nums[i] you have to count the number of valid j's\u00a0such that\u00a0j != i and nums[j] < nums[i].\nReturn the answer in an array.",
        "examples": [
            "Input: nums = [8,1,2,2,3]\nOutput: [4,0,1,1,3]\nExplanation: \nFor nums[0]=8 there exist four smaller numbers than it (1, 2, 2 and 3). \nFor nums[1]=1 does not exist any smaller number than it.\nFor nums[2]=2 there exist one smaller number than it (1). \nFor nums[3]=2 there exist one smaller number than it (1). \nFor nums[4]=3 there exist three smaller numbers than it (1, 2 and 2).",
            "Input: nums = [6,5,4,8]\nOutput: [2,1,0,3]",
            "Input: nums = [7,7,7,7]\nOutput: [0,0,0,0]"
        ],
        "constraints": "2 <= nums.length <= 500\n0 <= nums[i] <= 100",
        "oracle_code": "class Solution {\n    public int[] smallerNumbersThanCurrent(int[] nums) {\n        int c=0;\n        int res[]=new int[nums.length],k=0;\n        for(int i=0;i<nums.length;i++){\n         for(int j=0;j<nums.length;j++){\n             if(nums[j]<nums[i]){\n                 c+=1;\n                    }\n                 }\n                res[i]=c;\n               c=0;\n              }\n      return res;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int c=0;\\n        int res[]=new int[nums.length],k=0;\\n        for(int i=0;i<nums.length;i++){\\n         for(int j=0;j<nums.length;j++){\\n             if(nums[j]<nums[i]){\\n                 c+=1;\\n                    }\\n                 }\\n                res[i]=c;\\n               c=0;\\n              }\\n      return res;\\n    }\\n}\\n```",
        "level": "easy",
        "type": [
            "conditional statement error",
            "wrong comment mark",
            "indexing error",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\n    public int[] smallerNumbersThanCurrent(int[] nums) {\n        int c=0;\n        int res[]=new int[nums.length+1],k=0;\n        /*for(int i=0;i<nums.length;i++){\n         for(int j=0;j<nums.length;j++){\n             if(nums[j]<=nums[i]){\n                 c+=1;\n                    }\n                 }\n                res[i]=c;\n               c=0;\n              }*/\n      return res;\n    }\n\n    public int[] callUndefinedMethod() {\n        undefinedMethod();\n        return new int[0];\n    }\n}\n"
    },
    {
        "slug": "rotating-the-box",
        "description": "You are given an m x n matrix of characters box representing a side-view of a box. Each cell of the box is one of the following:\n\nA stone '#'\nA stationary obstacle '*'\nEmpty '.'\n\nThe box is rotated 90 degrees clockwise, causing some of the stones to fall due to gravity. Each stone falls down until it lands on an obstacle, another stone, or the bottom of the box. Gravity does not affect the obstacles' positions, and the inertia from the box's rotation does not affect the stones' horizontal positions.\nIt is guaranteed that each stone in box rests on an obstacle, another stone, or the bottom of the box.\nReturn an n x m matrix representing the box after the rotation described above.",
        "examples": [
            "Input: box = [[\"#\",\".\",\"#\"]]\r\nOutput: [[\".\"],\r\n\u00a0        [\"#\"],\r\n\u00a0        [\"#\"]]",
            "Input: box = [[\"#\",\".\",\"*\",\".\"],\r\n\u00a0             [\"#\",\"#\",\"*\",\".\"]]\r\nOutput: [[\"#\",\".\"],\r\n\u00a0        [\"#\",\"#\"],\r\n\u00a0        [\"*\",\"*\"],\r\n\u00a0        [\".\",\".\"]]",
            "Input: box = [[\"#\",\"#\",\"*\",\".\",\"*\",\".\"],\r\n\u00a0             [\"#\",\"#\",\"#\",\"*\",\".\",\".\"],\r\n\u00a0             [\"#\",\"#\",\"#\",\".\",\"#\",\".\"]]\r\nOutput: [[\".\",\"#\",\"#\"],\r\n\u00a0        [\".\",\"#\",\"#\"],\r\n\u00a0        [\"#\",\"#\",\"*\"],\r\n\u00a0        [\"#\",\"*\",\".\"],\r\n\u00a0        [\"#\",\".\",\"*\"],\r\n\u00a0        [\"#\",\".\",\".\"]]"
        ],
        "constraints": "m == box.length\nn == box[i].length\n1 <= m, n <= 500\nbox[i][j] is either '#', '*', or '.'.",
        "oracle_code": "// O(n^2) time | O(n^2) space\nclass Solution {\n    public char[][] rotateTheBox(char[][] box) {\n        int m = box.length;\n        int n = box[0].length;\n        char[][] matrix = new char[n][m];   \n        \n        turnBox(box, matrix, m, n); // turn the box clockwise 90 degree\n        \n        turnGravity(matrix, n, m); // cause that falling effect, since matrix turned so n,m\n        \n        return matrix;\n    }\n    \n    public void turnGravity(char[][] matrix, int m, int n){\n        for(int c = 0; c < n; c++){\n            int last  = m-1;\n            for(int r = m-1; r >= 0; r--){\n                char val =  matrix[r][c];\n                if(val == '.') continue;\n                if(val == '*') last = r-1;\n                if(val == '#') {\n                    matrix[r][c] = '.';\n                    matrix[last][c] = '#';\n                    last--;\n                }\n            }\n        }\n    }\n    \n    public void turnBox(char[][] box, char[][] matrix, int m, int n){\n\t// numbers represents sequence it would be copied\n\t//[4][1]\n\t//[5][2]\n\t//[6][3]\n        for(int i = 0, c = m-1; i < m; i++,c--){ // c: 4,3,2,1..\n            for(int j = 0, r = 0; j < n; j++, r++){ // r:0,1,2,3..\n               matrix[r][c] = box[i][j];\n            }\n        }\n    }\n}",
        "content": "**So idea here is**\\n1. First turn 90 degree\\n2. Make things fall\\n\\n```\\n// O(n^2) time | O(n^2) space\\nclass Solution {\\n    public char[][] rotateTheBox(char[][] box) {\\n        int m = box.length;\\n        int n = box[0].length;\\n        char[][] matrix = new char[n][m];   \\n        \\n        turnBox(box, matrix, m, n); // turn the box clockwise 90 degree\\n        \\n        turnGravity(matrix, n, m); // cause that falling effect, since matrix turned so n,m\\n        \\n        return matrix;\\n    }\\n    \\n    public void turnGravity(char[][] matrix, int m, int n){\\n        for(int c = 0; c < n; c++){\\n            int last  = m-1;\\n            for(int r = m-1; r >= 0; r--){\\n                char val =  matrix[r][c];\\n                if(val == \\'.\\') continue;\\n                if(val == \\'*\\') last = r-1;\\n                if(val == \\'#\\') {\\n                    matrix[r][c] = \\'.\\';\\n                    matrix[last][c] = \\'#\\';\\n                    last--;\\n                }\\n            }\\n        }\\n    }\\n    \\n    public void turnBox(char[][] box, char[][] matrix, int m, int n){\\n\\t// numbers represents sequence it would be copied\\n\\t//[4][1]\\n\\t//[5][2]\\n\\t//[6][3]\\n        for(int i = 0, c = m-1; i < m; i++,c--){ // c: 4,3,2,1..\\n            for(int j = 0, r = 0; j < n; j++, r++){ // r:0,1,2,3..\\n               matrix[r][c] = box[i][j];\\n            }\\n        }\\n    }\\n}\\n```",
        "level": "medium",
        "type": [
            "other error",
            "wrong comment mark",
            "indexing error",
            "unclosed string"
        ],
        "buggy_code": "\n// O(n^2) time | O(n^2) space\nclass Solution {\n    public char[][] rotateTheBox(char[][] box) {\n        int m = box.length;\n        int n = box[0].length + 1; \n        char[][] matrix = new char[n][m];   \n        \n        turnBox(box, matrix, m, n); // turn the box clockwise 90 degree\n        \n        turnGravity(matrix, n, m); ' cause that falling effect, since matrix turned so n,m\n        \n        return matrix;\n    }\n    \n    public void turnGravity(char[][] matrix, int m, int n){\n        for(int c = 0; c < n; c++){\n            int last  = m-1;\n            for(int r = m-1; r >= 0; r--){\n                char val =  matrix[r][c];\n                if(val == '.') continue;\n                if(val == '*') last = r-1;\n                if(val == '#') {\n                    matrix[r][c] = '.';\n                    matrix[last][c] = '#;\n                }\n            }\n        }\n    }\n    \n    public void turnBox(char[][] box, char[][] matrix, int m, int n){\n        for(int i = 0, c = m-1; i < m; i++,c--){            \n            for(int j = 0, r = 0; j < n; j++, r++){\n               matrix[r][1] = box[i][j];\n            }\n        }\n    }\n}\n"
    },
    {
        "slug": "relative-ranks",
        "description": "You are given an integer array score of size n, where score[i] is the score of the ith athlete in a competition. All the scores are guaranteed to be unique.\nThe athletes are placed based on their scores, where the 1st place athlete has the highest score, the 2nd place athlete has the 2nd highest score, and so on. The placement of each athlete determines their rank:\n\nThe 1st place athlete's rank is \"Gold Medal\".\nThe 2nd place athlete's rank is \"Silver Medal\".\nThe 3rd place athlete's rank is \"Bronze Medal\".\nFor the 4th place to the nth place athlete, their rank is their placement number (i.e., the xth place athlete's rank is \"x\").\n\nReturn an array answer of size n where answer[i] is the rank of the ith athlete.",
        "examples": [
            "Input: score = [5,4,3,2,1]\nOutput: [\"Gold Medal\",\"Silver Medal\",\"Bronze Medal\",\"4\",\"5\"]\nExplanation: The placements are [1st, 2nd, 3rd, 4th, 5th].",
            "Input: score = [10,3,8,9,4]\nOutput: [\"Gold Medal\",\"5\",\"Bronze Medal\",\"Silver Medal\",\"4\"]\nExplanation: The placements are [1st, 5th, 3rd, 2nd, 4th]."
        ],
        "constraints": "n == score.length\n1 <= n <= 104\n0 <= score[i] <= 106\nAll the values in score are unique.",
        "oracle_code": "class Solution {\n    public String[] findRelativeRanks(int[] score) {\n         int n=score.length;\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[b]-score[a]);\n        for(int i=0;i<n;i++) pq.add(i);\n      String[] ans = new String[n];\n                int i=1;\n        while(!pq.isEmpty()){\n            int idx=pq.poll();\n         if(i==1)   { ans[idx]=\"Gold Medal\"; i++;}\n         else if(i==2)   { ans[idx]=\"Silver Medal\"; i++;}\n         else if(i==3)   { ans[idx]=\"Bronze Medal\"; i++;}\n         else ans[idx]=Integer.toString(i++);\n        }\n        return ans;  \n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String[] findRelativeRanks(int[] score) {\\n         int n=score.length;\\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[b]-score[a]);\\n        for(int i=0;i<n;i++) pq.add(i);\\n      String[] ans = new String[n];\\n                int i=1;\\n        while(!pq.isEmpty()){\\n            int idx=pq.poll();\\n         if(i==1)   { ans[idx]=\"Gold Medal\"; i++;}\\n         else if(i==2)   { ans[idx]=\"Silver Medal\"; i++;}\\n         else if(i==3)   { ans[idx]=\"Bronze Medal\"; i++;}\\n         else ans[idx]=Integer.toString(i++);\\n        }\\n        return ans;  \\n    }\\n}\\n```",
        "level": "easy",
        "type": [
            "operation error",
            "parentheses mismatch",
            "undefined objects",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution {\n    public String[] findRelativeRanks(int[] score) {\n         int n = score.length;\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[a]-score[b]);\n        for(int i=0;i<n;i++) pq.add(i);\n        String[] ans = null;\n                int i=1;\n        while(!pq.isEmpty()){\n            int idx=pq.poll();\n         if(i=1)   { ans[idx]=\"Gold Medal; i++;}\n         else if(i=2)   { ans[idx]=\"Silver Medal; i++;}\n         else if(i=3)   { ans[idx]=\"Bronze Medal; i++;}\n         else ans[idx]=Integer.toString(i++);\n        }\n        return ans;  \n    }\n}\n"
    },
    {
        "slug": "daily-temperatures",
        "description": "Given an array of integers temperatures represents the daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after the ith day to get a warmer temperature. If there is no future day for which this is possible, keep answer[i] == 0 instead.",
        "examples": [
            "Input: temperatures = [73,74,75,71,69,72,76,73]\nOutput: [1,1,4,2,1,1,0,0]",
            "Input: temperatures = [30,40,50,60]\nOutput: [1,1,1,0]",
            "Input: temperatures = [30,60,90]\nOutput: [1,1,0]"
        ],
        "constraints": "1 <=\u00a0temperatures.length <= 105\n30 <=\u00a0temperatures[i] <= 100",
        "oracle_code": "class Solution {\n    public int[] dailyTemperatures(int[] temperatures) {\n        \n        int[] arr = new int[temperatures.length]; \n        \n        ArrayDeque<int[]> st = new ArrayDeque<>(); \n        \n        int i=0, j=temperatures.length-1 ; \n        \n        while( j >= 0){\n            \n            if(st.size()==0){\n                arr[i++] = 0;\n            }\n            else  if (st.size()>0 && st.peek()[0]>temperatures[j])\n            {\n                arr[i++]=1;\n            } \n            else if (st.size()>0 && st.peek()[0]<=temperatures[j])\n            \n            {  while(st.size()>0 && st.peek()[0]<=temperatures[j]){\n                    st.pop();\n                    \n                }\n            if(st.size()==0){\n                arr[i++]=0;\n            }\n            else{\n                arr[i++]=st.peek()[1]-j;\n            }\n            } \n        st.push(new int[]{temperatures[j],j}); \n        j--;\n        }\n        \n      \n        int[] ans = new int[temperatures.length]; int k=0;\n        for(i=arr.length-1; i>=0; i--){\n            ans[k++]=arr[i];\n        }\n        return ans;\n    }\n}",
        "content": "```\\nclass Solution {\\n    public int[] dailyTemperatures(int[] temperatures) {\\n        \\n        int[] arr = new int[temperatures.length]; \\n        \\n        ArrayDeque<int[]> st = new ArrayDeque<>(); \\n        \\n        int i=0, j=temperatures.length-1 ; \\n        \\n        while( j >= 0){\\n            \\n            if(st.size()==0){\\n                arr[i++] = 0;\\n            }\\n            else  if (st.size()>0 && st.peek()[0]>temperatures[j])\\n            {\\n                arr[i++]=1;\\n            } \\n            else if (st.size()>0 && st.peek()[0]<=temperatures[j])\\n            \\n            {  while(st.size()>0 && st.peek()[0]<=temperatures[j]){\\n                    st.pop();\\n                    \\n                }\\n            if(st.size()==0){\\n                arr[i++]=0;\\n            }\\n            else{\\n                arr[i++]=st.peek()[1]-j;\\n            }\\n            } \\n        st.push(new int[]{temperatures[j],j}); \\n        j--;\\n        }\\n        \\n      \\n        int[] ans = new int[temperatures.length]; int k=0;\\n        for(i=arr.length-1; i>=0; i--){\\n            ans[k++]=arr[i];\\n        }\\n        return ans;\\n    }\\n}",
        "level": "medium",
        "type": [
            "variable value error",
            "wrong comment mark",
            "indexing error",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution {\n    public int[] dailyTemperatures(int[] temperatures) {\n        \n        let[] arr = new let[temperatures.length + 1]; \n        \n        ArrayDeque<int[]> st = new ArrayDeque<>(); \n        \n        int i=0, j=temperatures.length ; \n        \n        while( j >= 0){\n            \n            if(st.size()==0){\n                arr[i++] = 0;\n            }\n            else  if (st.size()>0 && st.peek()[0]>temperatures[j])\n            {\n                arr[i++]=1;\n            } \n            else if (st.size()>0 && st.peek()[0]<=temperatures[j])\n            \n            {  while(st.size()>0 && st.peek()[0]<=temperatures[j]){\n                    st.pop();\n                    \n                }\n            if(st.size()==0){\n                arr[i++]=0;\n            }\n            else{\n                arr[i++]=st.peek()[1]-j;\n            }\n            } \n        st.push(new int[]{temperatures[j],j}); \n        j--;\n        }\n        \n      \n        int[] ans = new int[temperatures.length]; int k=0;\n        for(i=arr.length-1/**/ + lele1; i>=0; i--){\n            ans[k++]=arr[i];\n        }\n        return ans;\n    }\n}\n"
    },
    {
        "slug": "sum-of-total-strength-of-wizards",
        "description": "As the ruler of a kingdom, you have an army of wizards at your command.\nYou are given a 0-indexed integer array strength, where strength[i] denotes the strength of the ith wizard. For a contiguous group of wizards (i.e. the wizards' strengths form a subarray of strength), the total strength is defined as the product of the following two values:\n\nThe strength of the weakest wizard in the group.\nThe total of all the individual strengths of the wizards in the group.\n\nReturn the sum of the total strengths of all contiguous groups of wizards. Since the answer may be very large, return it modulo 109 + 7.\nA subarray is a contiguous non-empty sequence of elements within an array.",
        "examples": [
            "Input: strength = [1,3,1,2]\nOutput: 44\nExplanation: The following are all the contiguous groups of wizards:\n- [1] from [1,3,1,2] has a total strength of min([1]) * sum([1]) = 1 * 1 = 1\n- [3] from [1,3,1,2] has a total strength of min([3]) * sum([3]) = 3 * 3 = 9\n- [1] from [1,3,1,2] has a total strength of min([1]) * sum([1]) = 1 * 1 = 1\n- [2] from [1,3,1,2] has a total strength of min([2]) * sum([2]) = 2 * 2 = 4\n- [1,3] from [1,3,1,2] has a total strength of min([1,3]) * sum([1,3]) = 1 * 4 = 4\n- [3,1] from [1,3,1,2] has a total strength of min([3,1]) * sum([3,1]) = 1 * 4 = 4\n- [1,2] from [1,3,1,2] has a total strength of min([1,2]) * sum([1,2]) = 1 * 3 = 3\n- [1,3,1] from [1,3,1,2] has a total strength of min([1,3,1]) * sum([1,3,1]) = 1 * 5 = 5\n- [3,1,2] from [1,3,1,2] has a total strength of min([3,1,2]) * sum([3,1,2]) = 1 * 6 = 6\n- [1,3,1,2] from [1,3,1,2] has a total strength of min([1,3,1,2]) * sum([1,3,1,2]) = 1 * 7 = 7\nThe sum of all the total strengths is 1 + 9 + 1 + 4 + 4 + 4 + 3 + 5 + 6 + 7 = 44.",
            "Input: strength = [5,4,6]\nOutput: 213\nExplanation: The following are all the contiguous groups of wizards: \n- [5] from [5,4,6] has a total strength of min([5]) * sum([5]) = 5 * 5 = 25\n- [4] from [5,4,6] has a total strength of min([4]) * sum([4]) = 4 * 4 = 16\n- [6] from [5,4,6] has a total strength of min([6]) * sum([6]) = 6 * 6 = 36\n- [5,4] from [5,4,6] has a total strength of min([5,4]) * sum([5,4]) = 4 * 9 = 36\n- [4,6] from [5,4,6] has a total strength of min([4,6]) * sum([4,6]) = 4 * 10 = 40\n- [5,4,6] from [5,4,6] has a total strength of min([5,4,6]) * sum([5,4,6]) = 4 * 15 = 60\nThe sum of all the total strengths is 25 + 16 + 36 + 36 + 40 + 60 = 213."
        ],
        "constraints": "1 <= strength.length <= 105\n1 <= strength[i] <= 109",
        "oracle_code": "class Solution {\n    public int totalStrength(int[] strength) {\n        int mod = 1000000007;\n        \n        int len = strength.length;\n        \n        long[] prefix = prefixSum(strength, len, mod);\n        \n        Deque<Integer> stack = new ArrayDeque<>();\n        stack.push(-1);\n\n        long ans = 0;\n        for(int i = 0; i < len; i++) {\n            while(stack.peek() != -1 && strength[i] <= strength[stack.peek()]) {\n                int mid = stack.pop();\n                int left = stack.peek() + 1;\n                int right = i - 1;\n                \n                int n = (mid - left);\n                int t = (right - mid);\n                \n                long val = (1l * (1 + n) * (prefix[right + 2] - prefix[mid + 1]) + mod) % mod;\n                val -= (1l * (1 + t) * (prefix[mid + 1] - prefix[left]) + mod) % mod;\n                val *= strength[mid];\n                \n                ans += val;\n                ans %= mod;\n            }\n            \n            stack.push(i);\n        }\n        \n        int right = len - 1;\n        while(stack.peek() != -1) {\n            int mid = stack.pop();\n            int left = stack.peek() + 1;\n            \n            int n = (mid - left);\n            int t = (right - mid);\n\n            long val = (1l * (1 + n) * (prefix[right + 2] - prefix[mid + 1]) + mod) % mod;\n            val -= (1l * (1 + t) * (prefix[mid + 1] - prefix[left]) + mod) % mod;\n            val *= strength[mid];\n\n            ans += val;\n            ans %= mod;\n        }\n        \n        return (int)((ans + mod) % mod);\n    }\n    \n    private long[] prefixSum(int[] strength, int len, int mod) {\n        long[] prefix = new long[len + 1];\n        \n        for(int i = 0; i < len; i++) {\n            prefix[i + 1] = prefix[i] + strength[i];\n        }\n        \n        long[] doublePrefix = new long[len + 2];\n        for(int i = 0; i <= len; i++) {\n            doublePrefix[i + 1] = (doublePrefix[i] + prefix[i]) % mod;\n        }\n\n        return doublePrefix;\n    }\n}",
        "content": "I could not figure out `o(n)` approach on my own. \\nI needed to read at least 3 solution by really brilliant people (top voted) to understand the approach.\\nThen I had to do the math on pen-paper 3 times (made mistake 2 time) to actually understand the approach.\\nThen when I actually started coding, I made some some silly mistakes around Stack boundry and \\nthe cherry on top was that you need to do `+ mod) % mod` at almost every place you are doing any calculation.\\n\\nOverall, very good learning experience but I really pity the ones who actually face this in interview.\\n\\nRun time complexity: `4 * O(n)` =  `O(n)` \\nSpace compexity: `O(n)`\\n\\nMy java solution -\\n```\\nclass Solution {\\n    public int totalStrength(int[] strength) {\\n        int mod = 1000000007;\\n        \\n        int len = strength.length;\\n        \\n        long[] prefix = prefixSum(strength, len, mod);\\n        \\n        Deque<Integer> stack = new ArrayDeque<>();\\n        stack.push(-1);\\n\\n        long ans = 0;\\n        for(int i = 0; i < len; i++) {\\n            while(stack.peek() != -1 && strength[i] <= strength[stack.peek()]) {\\n                int mid = stack.pop();\\n                int left = stack.peek() + 1;\\n                int right = i - 1;\\n                \\n                int n = (mid - left);\\n                int t = (right - mid);\\n                \\n                long val = (1l * (1 + n) * (prefix[right + 2] - prefix[mid + 1]) + mod) % mod;\\n                val -= (1l * (1 + t) * (prefix[mid + 1] - prefix[left]) + mod) % mod;\\n                val *= strength[mid];\\n                \\n                ans += val;\\n                ans %= mod;\\n            }\\n            \\n            stack.push(i);\\n        }\\n        \\n        int right = len - 1;\\n        while(stack.peek() != -1) {\\n            int mid = stack.pop();\\n            int left = stack.peek() + 1;\\n            \\n            int n = (mid - left);\\n            int t = (right - mid);\\n\\n            long val = (1l * (1 + n) * (prefix[right + 2] - prefix[mid + 1]) + mod) % mod;\\n            val -= (1l * (1 + t) * (prefix[mid + 1] - prefix[left]) + mod) % mod;\\n            val *= strength[mid];\\n\\n            ans += val;\\n            ans %= mod;\\n        }\\n        \\n        return (int)((ans + mod) % mod);\\n    }\\n    \\n    private long[] prefixSum(int[] strength, int len, int mod) {\\n        long[] prefix = new long[len + 1];\\n        \\n        for(int i = 0; i < len; i++) {\\n            prefix[i + 1] = prefix[i] + strength[i];\\n        }\\n        \\n        long[] doublePrefix = new long[len + 2];\\n        for(int i = 0; i <= len; i++) {\\n            doublePrefix[i + 1] = (doublePrefix[i] + prefix[i]) % mod;\\n        }\\n\\n        return doublePrefix;\\n    }\\n}\\n```",
        "level": "hard",
        "type": [
            "variable value error",
            "parentheses mismatch",
            "indexing error",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution {\n    public int totalStrength(int[] strength) {\n        int mod = 1000000007;\n        \n        int len = strength.length;\n        \n        long[] prefix = prefixSum(strength, len, mod;\n        \n        Deque<Integer> stack = null; \n        stack.push(-1);\n\n        long ans = 0;\n        for(int i = 0; i < len; i++) {\n            while(stack.peek() != -1 && strength[i] <= strength[stack.peek()]) {\n                int mid = stack.pop();\n                int left = stack.peek() + 1;\n                int right = i - 1;\n                \n                int n = (mid - left) + 1;\n                int t = (right - mid) + 1;\n                \n                long val = (1l * (1 + n) * (prefix[right + 2] - prefix[mid + 2]) + mod) % mod;\n                val -= (1l * (1 + t) * (prefix[mid + 1] - prefix[left]) + mod) % mod;\n                val *= strength[mid];\n                \n                ans += val;\n                ans %= mod;\n            }\n            \n            stack.push(i);\n        }\n        \n        int right = len - 1;\n        while(stack.peek() != -1) {\n            int mid = stack.pop();\n            int left = stack.peek() + 1;\n            \n            int n = (mid - left) + 1;\n            int t = (right - mid) + 1;\n\n            long val = (1l * (1 + n) * (prefix[right + 2] - prefix[mid + 1]) + mod) % mod;\n            val -= (1l * (1 + t) * (prefix[mid + 1] - prefix[left]) + mod) % mod;\n            val *= strength[mid];\n\n            ans += val;\n            ans %= mod;\n        }\n        \n        return (int)((ans + mod) % mod);\n    }\n    \n    private long[] prefixSum(int[] strength, int len, int mod) {\n        long[] prefix = new long[len + 1];\n        \n        for(int i = 0; i < len; i++) {\n            prefix[i + 1] = prefix[i] + strength[i];\n        }\n        \n        long[] doublePrefix = new long[len + 2];\n        for(int i = 0; i <= len; i++) {\n            doublePrefix[i + 1] = (doublePrefix[i] + prefix[i]) % mod;\n        }\n\n        return doublePrefix;\n    }\n}\n"
    },
    {
        "slug": "increasing-decreasing-string",
        "description": "You are given a string s. Reorder the string using the following algorithm:\n\nPick the smallest character from s and append it to the result.\nPick the smallest character from s which is greater than the last appended character to the result and append it.\nRepeat step 2 until you cannot pick more characters.\nPick the largest character from s and append it to the result.\nPick the largest character from s which is smaller than the last appended character to the result and append it.\nRepeat step 5 until you cannot pick more characters.\nRepeat the steps from 1 to 6 until you pick all characters from s.\n\nIn each step, If the smallest or the largest character appears more than once you can choose any occurrence and append it to the result.\nReturn the result string after sorting s with this algorithm.",
        "examples": [
            "Input: s = \"aaaabbbbcccc\"\nOutput: \"abccbaabccba\"\nExplanation: After steps 1, 2 and 3 of the first iteration, result = \"abc\"\nAfter steps 4, 5 and 6 of the first iteration, result = \"abccba\"\nFirst iteration is done. Now s = \"aabbcc\" and we go back to step 1\nAfter steps 1, 2 and 3 of the second iteration, result = \"abccbaabc\"\nAfter steps 4, 5 and 6 of the second iteration, result = \"abccbaabccba\"",
            "Input: s = \"rat\"\nOutput: \"art\"\nExplanation: The word \"rat\" becomes \"art\" after re-ordering it with the mentioned algorithm."
        ],
        "constraints": "1 <= s.length <= 500\ns consists of only lowercase English letters.",
        "oracle_code": "class Solution {\n    public String sortString(String s) {\n        int[] arr = new int[27];\n        String str = \"abcdefghijklmnopqrstuvwxyz\";\n//Find the number of occurrences of each letter in the text S and \n//place it in an array\n        for(int i=0;i<s.length();i++){\n            int num = str.indexOf((s.charAt(i)));\n            arr[++num]=arr[num]+1;\n        }\n\n        int len = s.length();\n        int count=0;\n        StringBuilder ans = new StringBuilder();\n        \n        while(count<len){\n            for(int i=1;i<27;i++){\n                if(arr[i]>0){\n                    ans.append(str.charAt(i - 1));\n                    arr[i]=arr[i]-1;\n                    count++;\n                }\n            }\n            for(int j=26;j>=1;j--){\n                if(arr[j]>0){\n                    ans.append(str.charAt(j - 1));\n                    arr[j]=arr[j]-1;\n                    count++;\n                }\n            }\n        }\n        return new String(ans);\n    }\n}",
        "content": "# Intuition\\n[Java] Finding solutions in an easy, understandable and fast way\\n\\n# Approach\\nThe goal is to find a solution to the example using only while and for operators\\n\\n# Complexity\\n- Time complexity:\\nRuntime: 5 ms       Beats :47.73%\\nMemory:  42.1 MB    Beats :91.92%\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String sortString(String s) {\\n        int[] arr = new int[27];\\n        String str = \"abcdefghijklmnopqrstuvwxyz\";\\n//Find the number of occurrences of each letter in the text S and \\n//place it in an array\\n        for(int i=0;i<s.length();i++){\\n            int num = str.indexOf((s.charAt(i)));\\n            arr[++num]=arr[num]+1;\\n        }\\n\\n        int len = s.length();\\n        int count=0;\\n        StringBuilder ans = new StringBuilder();\\n        \\n        while(count<len){\\n            for(int i=1;i<27;i++){\\n                if(arr[i]>0){\\n                    ans.append(str.charAt(i - 1));\\n                    arr[i]=arr[i]-1;\\n                    count++;\\n                }\\n            }\\n            for(int j=26;j>=1;j--){\\n                if(arr[j]>0){\\n                    ans.append(str.charAt(j - 1));\\n                    arr[j]=arr[j]-1;\\n                    count++;\\n                }\\n            }\\n        }\\n        return new String(ans);\\n    }\\n}\\n```",
        "level": "easy",
        "type": [
            "operation error",
            "undefined objects",
            "undefined keywords from other languages",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution {\n    public String sortString(String s) {\n        int[] arr = new int[27];\n        String str = null; \n        for(int i=0;i<s.length();i++){\n            int num = str.indexOf((s.charAt(i))); \n            arr[num]=arr[num]+1; \n            ++num; \n        }\n\n        int len = s.length();\n        int count=0;\n        let res = new StringBuilder();\n\n        while(count<len){\n            for(int i=1;i<27;i++){\n                if(arr[i]>0){\n                    res.append(str.charAt(i - 1)); \n                    arr[i]=arr[i]-1;\n                    count++;\n                }\n            }\n            for(int j=26;j>=1;j--){\n                if(arr[j]>0){\n                    res.append(str.charAt(j - 1));\n                    arr[j]=arr[j]-1;\n                    count++;\n                }\n            }\n        }\n        return new String(res);\n    }\n}\n"
    },
    {
        "slug": "daily-temperatures",
        "description": "Given an array of integers temperatures represents the daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after the ith day to get a warmer temperature. If there is no future day for which this is possible, keep answer[i] == 0 instead.",
        "examples": [
            "Input: temperatures = [73,74,75,71,69,72,76,73]\nOutput: [1,1,4,2,1,1,0,0]",
            "Input: temperatures = [30,40,50,60]\nOutput: [1,1,1,0]",
            "Input: temperatures = [30,60,90]\nOutput: [1,1,0]"
        ],
        "constraints": "1 <=\u00a0temperatures.length <= 105\n30 <=\u00a0temperatures[i] <= 100",
        "oracle_code": "class Solution {\n    public int[] dailyTemperatures(int[] temperatures) {\n        \n        int[] arr = new int[temperatures.length]; \n        \n        ArrayDeque<int[]> st = new ArrayDeque<>(); \n        \n        int i=0, j=temperatures.length-1 ; \n        \n        while( j >= 0){\n            \n            if(st.size()==0){\n                arr[i++] = 0;\n            }\n            else  if (st.size()>0 && st.peek()[0]>temperatures[j])\n            {\n                arr[i++]=1;\n            } \n            else if (st.size()>0 && st.peek()[0]<=temperatures[j])\n            \n            {  while(st.size()>0 && st.peek()[0]<=temperatures[j]){\n                    st.pop();\n                    \n                }\n            if(st.size()==0){\n                arr[i++]=0;\n            }\n            else{\n                arr[i++]=st.peek()[1]-j;\n            }\n            } \n        st.push(new int[]{temperatures[j],j}); \n        j--;\n        }\n        \n      \n        int[] ans = new int[temperatures.length]; int k=0;\n        for(i=arr.length-1; i>=0; i--){\n            ans[k++]=arr[i];\n        }\n        return ans;\n    }\n}",
        "content": "```\\nclass Solution {\\n    public int[] dailyTemperatures(int[] temperatures) {\\n        \\n        int[] arr = new int[temperatures.length]; \\n        \\n        ArrayDeque<int[]> st = new ArrayDeque<>(); \\n        \\n        int i=0, j=temperatures.length-1 ; \\n        \\n        while( j >= 0){\\n            \\n            if(st.size()==0){\\n                arr[i++] = 0;\\n            }\\n            else  if (st.size()>0 && st.peek()[0]>temperatures[j])\\n            {\\n                arr[i++]=1;\\n            } \\n            else if (st.size()>0 && st.peek()[0]<=temperatures[j])\\n            \\n            {  while(st.size()>0 && st.peek()[0]<=temperatures[j]){\\n                    st.pop();\\n                    \\n                }\\n            if(st.size()==0){\\n                arr[i++]=0;\\n            }\\n            else{\\n                arr[i++]=st.peek()[1]-j;\\n            }\\n            } \\n        st.push(new int[]{temperatures[j],j}); \\n        j--;\\n        }\\n        \\n      \\n        int[] ans = new int[temperatures.length]; int k=0;\\n        for(i=arr.length-1; i>=0; i--){\\n            ans[k++]=arr[i];\\n        }\\n        return ans;\\n    }\\n}",
        "level": "medium",
        "type": [
            "variable value error",
            "wrong comment mark",
            "undefined objects",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\n    public int[] dailyTemperatures(int[] temperatures) {\n        \n        int[] arr = new int[temperatures.length]; \n        \n        ArrayDeque<int[]> st = new ArrayDeque<>(); \n        \n        int i=0, j=temperatures.length ; \n        \n        while( j >= 0){\n            \n            if(st.size()==0){\n                arr[i++] = 0;\n            }\n            else  if (st.size()>0 && st.peek()[0]>temperatures[j])\n            {\n                arr[i++]=1;\n            } \n            else if (st.size()>0 && st.peek()[0]<=temperatures[j])\n            \n            {  while(st.size()>0 && st.peek()[0]<=temperatures[j]){\n                    st.pop();\n                    \n                }\n            if(st.size()==0){\n                arr[i++]=0;\n            }\n            else{\n                arr[i++]=st.peek()[1]-j;\n            }\n            } \n        st.push(new int[]{temperatures[j],j}); \n        j--;\n        }\n        \n      \n        int[] ans = new int[temperatures.length]; int k=0;\n        for(i=arr.length-1/**/; \n        return ans;\n    }\n}\n\n\n        doSomething();\n\n\n"
    },
    {
        "slug": "add-edges-to-make-degrees-of-all-nodes-even",
        "description": "There is an undirected graph consisting of n nodes numbered from 1 to n. You are given the integer n and a 2D array edges where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi. The graph can be disconnected.\nYou can add at most two additional edges (possibly none) to this graph so that there are no repeated edges and no self-loops.\nReturn true if it is possible to make the degree of each node in the graph even, otherwise return false.\nThe degree of a node is the number of edges connected to it.",
        "examples": [
            "Input: n = 5, edges = [[1,2],[2,3],[3,4],[4,2],[1,4],[2,5]]\nOutput: true\nExplanation: The above diagram shows a valid way of adding an edge.\nEvery node in the resulting graph is connected to an even number of edges.",
            "Input: n = 4, edges = [[1,2],[3,4]]\nOutput: true\nExplanation: The above diagram shows a valid way of adding two edges.",
            "Input: n = 4, edges = [[1,2],[1,3],[1,4]]\nOutput: false\nExplanation: It is not possible to obtain a valid graph with adding at most 2 edges."
        ],
        "constraints": "3 <= n <= 105\n2 <= edges.length <= 105\nedges[i].length == 2\n1 <= ai, bi <= n\nai != bi\nThere are no repeated edges.",
        "oracle_code": "class Solution:\n    def isPossible(self, n: int, edges: List[List[int]]) -> bool:\n        graph = defaultdict(set)\n        for a, b in edges:\n            graph[a].add(b)\n            graph[b].add(a)\n        odds = [a for a in graph if len(graph[a]) % 2 == 1]\n        if not odds:\n            return True\n        elif len(odds) > 4 or len(odds) == 1 or len(odds) == 3:\n            return False\n        elif len(odds) == 2:\n            a, b = odds[0], odds[1]\n            if a not in graph[b]:\n                return True\n            for i in range(1, n + 1):\n                if i not in graph[a] and i not in graph[b]:\n                    return True\n            return False\n        else:\n            a, b, c, d = odds[0], odds[1], odds[2], odds[3]\n            if a not in graph[b] and c not in graph[d]:\n                return True\n            if a not in graph[c] and b not in graph[d]:\n                return True\n            if a not in graph[d] and b not in graph[c]:\n                return True\n            return False",
        "content": "**Observation**\\nThe key is to note that we can add **at most** two additional edges (possibly none) to the graph.\\n\\n**Implementation**\\nStep 1: Build the graph by going through all edges.\\nStep 2: Find every node with an odd degree.\\nStep 3: Consider each of the case where the number of the nodes with an odd degree is 0, 1, 2, 3, 4, and > 4.\\n\\n**Solution**\\n```\\nclass Solution:\\n    def isPossible(self, n: int, edges: List[List[int]]) -> bool:\\n        graph = defaultdict(set)\\n        for a, b in edges:\\n            graph[a].add(b)\\n            graph[b].add(a)\\n        odds = [a for a in graph if len(graph[a]) % 2 == 1]\\n        if not odds:\\n            return True\\n        elif len(odds) > 4 or len(odds) == 1 or len(odds) == 3:\\n            return False\\n        elif len(odds) == 2:\\n            a, b = odds[0], odds[1]\\n            if a not in graph[b]:\\n                return True\\n            for i in range(1, n + 1):\\n                if i not in graph[a] and i not in graph[b]:\\n                    return True\\n            return False\\n        else:\\n            a, b, c, d = odds[0], odds[1], odds[2], odds[3]\\n            if a not in graph[b] and c not in graph[d]:\\n                return True\\n            if a not in graph[c] and b not in graph[d]:\\n                return True\\n            if a not in graph[d] and b not in graph[c]:\\n                return True\\n            return False\\n```",
        "level": "hard",
        "type": [
            "colon missing",
            "conditional statement error",
            "wrong comment mark",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution{\n    int sum(int a, int b){\n        \n        return a - b;\n    }\n}\n\nself.isEulerian(a,b)\n            for i in range(1, n + 1):\n                if i not in graph[a] and i not in graph[b]:\n                    return turn False\n        else:\n            a, b, c, d = odds[0], odds[,dds2,odds[3]\nifaotin gaph[b] and c not in graph[d]:\n                rturn self.isEulerian(a,b)\n            if a not in graph[c] and b not in graph[d]:\n                return self.isEulerian(a,b)\n            if a not in graph[d] and b not in graph[c]:\n                return self.isEulerian(a,b)"
    },
    {
        "slug": "probability-of-a-two-boxes-having-the-same-number-of-distinct-balls",
        "description": "Given 2n balls of k distinct colors. You will be given an integer array balls of size k where balls[i] is the number of balls of color i.\nAll the balls will be shuffled uniformly at random, then we will distribute the first n balls to the first box and the remaining n balls to the other box (Please read the explanation of the second example carefully).\nPlease note that the two boxes are considered different. For example, if we have two balls of colors a and b, and two boxes [] and (), then the distribution [a] (b) is considered different than the distribution [b] (a) (Please read the explanation of the first example carefully).\nReturn the probability that the two boxes have the same number of distinct balls. Answers within 10-5 of the actual value will be accepted as correct.",
        "examples": [
            "Input: balls = [1,1]\nOutput: 1.00000\nExplanation: Only 2 ways to divide the balls equally:\n- A ball of color 1 to box 1 and a ball of color 2 to box 2\n- A ball of color 2 to box 1 and a ball of color 1 to box 2\nIn both ways, the number of distinct colors in each box is equal. The probability is 2/2 = 1",
            "Input: balls = [2,1,1]\nOutput: 0.66667\nExplanation: We have the set of balls [1, 1, 2, 3]\nThis set of balls will be shuffled randomly and we may have one of the 12 distinct shuffles with equal probability (i.e. 1/12):\n[1,1 / 2,3], [1,1 / 3,2], [1,2 / 1,3], [1,2 / 3,1], [1,3 / 1,2], [1,3 / 2,1], [2,1 / 1,3], [2,1 / 3,1], [2,3 / 1,1], [3,1 / 1,2], [3,1 / 2,1], [3,2 / 1,1]\nAfter that, we add the first two balls to the first box and the second two balls to the second box.\nWe can see that 8 of these 12 possible random distributions have the same number of distinct colors of balls in each box.\nProbability is 8/12 = 0.66667",
            "Input: balls = [1,2,1,2]\nOutput: 0.60000\nExplanation: The set of balls is [1, 2, 2, 3, 4, 4]. It is hard to display all the 180 possible random shuffles of this set but it is easy to check that 108 of them will have the same number of distinct colors in each box.\nProbability = 108 / 180 = 0.6"
        ],
        "constraints": "1 <= balls.length <= 8\n1 <= balls[i] <= 6\nsum(balls) is even.",
        "oracle_code": "class Solution {\n    double possible = 0.0;\n    double valid = 0.0;\n    \n    public double getProbability(int[] balls) {\n        int[] first = new int[balls.length];\n        int[] second = new int[balls.length];\n        dfs(balls, first, second, 0, 0, 0);\n        return valid / possible;\n    }\n    \n    private void dfs(int[] balls, int[] first, int[] second, int num1, int num2, int idx) {\n        // finish all colors, check if this's a possible/valid distribution\n        if (idx == balls.length) {\n            // find one possible distribution\n            if (num1 == num2) {\n                // compute fake permutation\n                double distrib = permFake(first) * permFake(second);\n                possible += distrib;\n                \n                // find one valid distribution\n                if (unique(first) == unique(second)) {\n                    valid += distrib;\n                }\n            }\n            return;\n        }\n        \n        // distribute balls in current color to two bins\n        for (int b = 0; b <= balls[idx]; b++) {\n            first[idx] = b;\n            second[idx] = balls[idx] - b;\n            dfs (balls, first, second, num1 + first[idx], num2 + second[idx], idx + 1);\n        }\n    }\n    \n    // unique colors in \n    private int unique(int[] balls) {\n        int unique = 0;\n        for (int b: balls)\n            unique += b > 0 ? 1 : 0;\n        return unique;\n    }\n    \n    // return 1 / (b1!b2!b3!...bn!) \n    private double permFake(int[] balls) {\n        double ret = 1.0;\n        for (int b: balls)\n            ret /= factorial(b);\n        return ret;\n    }\n    \n    private int factorial(int n){\n        int ret = 1;\n        while (n > 0) {\n            ret *= n;\n            n--;\n        }\n        return ret;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    double possible = 0.0;\\n    double valid = 0.0;\\n    \\n    public double getProbability(int[] balls) {\\n        int[] first = new int[balls.length];\\n        int[] second = new int[balls.length];\\n        dfs(balls, first, second, 0, 0, 0);\\n        return valid / possible;\\n    }\\n    \\n    private void dfs(int[] balls, int[] first, int[] second, int num1, int num2, int idx) {\\n        // finish all colors, check if this\\'s a possible/valid distribution\\n        if (idx == balls.length) {\\n            // find one possible distribution\\n            if (num1 == num2) {\\n                // compute fake permutation\\n                double distrib = permFake(first) * permFake(second);\\n                possible += distrib;\\n                \\n                // find one valid distribution\\n                if (unique(first) == unique(second)) {\\n                    valid += distrib;\\n                }\\n            }\\n            return;\\n        }\\n        \\n        // distribute balls in current color to two bins\\n        for (int b = 0; b <= balls[idx]; b++) {\\n            first[idx] = b;\\n            second[idx] = balls[idx] - b;\\n            dfs (balls, first, second, num1 + first[idx], num2 + second[idx], idx + 1);\\n        }\\n    }\\n    \\n    // unique colors in \\n    private int unique(int[] balls) {\\n        int unique = 0;\\n        for (int b: balls)\\n            unique += b > 0 ? 1 : 0;\\n        return unique;\\n    }\\n    \\n    // return 1 / (b1!b2!b3!...bn!) \\n    private double permFake(int[] balls) {\\n        double ret = 1.0;\\n        for (int b: balls)\\n            ret /= factorial(b);\\n        return ret;\\n    }\\n    \\n    private int factorial(int n){\\n        int ret = 1;\\n        while (n > 0) {\\n            ret *= n;\\n            n--;\\n        }\\n        return ret;\\n    }\\n}\\n```",
        "level": "hard",
        "type": [
            "operation error",
            "== and = confusion",
            "undefined objects",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution {\n    double possible = 0.0;\n    double valid = 0.0;\n    \n    public double getProbability(int[] balls) {\n        int[] first = new int[balls.length];\n        int[] second = null;\n        dfs(balls, first, second, 0, 0, 0);\n        return valid / possible;\n    }\n    \n    private void dfs(int[] balls, int[] first, int[] second, int num1, int num2, int idx) {\n        if (idx == balls.length) {\n            if (num1 = num2) {\n                double distrib = permFake(first) * permFake(second);\n                possible += distrib;\n                if (unique(first) == unique(second)) {\n                    valid += distrib + 1;    \n                }\n            }\n            return;\n        }\n        for (int b = 0; b <= balls[idx]; b++) {\n            first[idx] = b;\n            second[idx] = balls[idx] - b;\n            dfs (balls, first, second, num1 + first[idx], num2 + second[idx], idx + 1);\n        }\n    }\n    \n    private int(t[] balls) {\n        int = 0;\n        for (int b: balls)\n            unique += b > \"0 ? 1 : 0;\n        return unique;\n    }\n    \n    private double permFake(int[] balls) {\n        double ret = 1.0;\n        for (int b: balls)\n            ret /= factorial(b);\n        return ret;\n    }\n    \n    private int factorial(int n){\n        int ret = 1;\n        while (n > 0) {\n            ret *= n;\n            n--;\n        }\n        return ret;\n    }\n}\n"
    },
    {
        "slug": "reverse-words-in-a-string",
        "description": "Given an input string s, reverse the order of the words.\nA word is defined as a sequence of non-space characters. The words in s will be separated by at least one space.\nReturn a string of the words in reverse order concatenated by a single space.\nNote that s may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words. Do not include any extra spaces.",
        "examples": [
            "Input: s = \"the sky is blue\"\nOutput: \"blue is sky the\"",
            "Input: s = \"  hello world  \"\nOutput: \"world hello\"\nExplanation: Your reversed string should not contain leading or trailing spaces.",
            "Input: s = \"a good   example\"\nOutput: \"example good a\"\nExplanation: You need to reduce multiple spaces between two words to a single space in the reversed string."
        ],
        "constraints": "1 <= s.length <= 104\ns contains English letters (upper-case and lower-case), digits, and spaces ' '.\nThere is at least one word in s.\n\n\u00a0\nFollow-up:\u00a0If the string data type is mutable in your language, can\u00a0you solve it\u00a0in-place\u00a0with\u00a0O(1)\u00a0extra space?",
        "oracle_code": "class Solution {\n    public String reverseWords(String s) {\n        StringBuilder ans = new StringBuilder();\n        for(int i=s.length()-1; i>=0; i--){\n            if(s.charAt(i)==' '){\n                continue;\n            }\n            int start=-1;\n            for(int y=i-1; y>=0; y--){\n                if(s.charAt(y)==' '){\n                    start=y;\n                    break;\n                }\n            }\n            ans.append(s.substring(start+1, i+1) + \" \");\n            i=start;\n        }\n        ans.deleteCharAt(ans.length()-1);\n        return ans.toString();\n    }\n}",
        "content": "# Approach\\n- Two Pointer Approach\\n- Using Trim and Split\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public String reverseWords(String s) {\\n        StringBuilder ans = new StringBuilder();\\n        for(int i=s.length()-1; i>=0; i--){\\n            if(s.charAt(i)==\\' \\'){\\n                continue;\\n            }\\n            int start=-1;\\n            for(int y=i-1; y>=0; y--){\\n                if(s.charAt(y)==\\' \\'){\\n                    start=y;\\n                    break;\\n                }\\n            }\\n            ans.append(s.substring(start+1, i+1) + \" \");\\n            i=start;\\n        }\\n        ans.deleteCharAt(ans.length()-1);\\n        return ans.toString();\\n    }\\n}\\n```\\n```\\nclass Solution {\\n    public String reverseWords(String s) {\\n        String[] temp = s.trim().split(\" \");\\n        StringBuilder ans = new StringBuilder();\\n        for(int i=temp.length-1; i>0; i--){\\n            if(temp[i]==\"\"){\\n                continue;\\n            }\\n            ans.append(temp[i]+\" \");\\n        }\\n        ans.append(temp[0]);\\n        return ans.toString();\\n    }\\n}\\n```",
        "level": "medium",
        "type": [
            "operation error",
            "wrong comment mark",
            "undefined objects",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution {\n    public String reverseWords(String s) {\n        StringBuilder ans = new StringBuilder();\n        String str = null;\n        for(int i=s.length()-1; i>=str.length(); i--){\n            /*if(s.charAt(i)==' '){\n                continue;\n            }*/\n            int start=-1;\n            for(int y=i-1; y>=0; y--){\n                if(s.charAt(y)==' '){\n                    start=y;\n                    break;\n                }\n            }\n            ans.append(s.substring(start+1, i) + \" \";\n            i=start;\n        }\n        ans.deleteCharAt(ans.length()-1);\n        return ans.toString();\n    }\n}\n"
    },
    {
        "slug": "intersection-of-multiple-arrays",
        "description": "Given a 2D integer array nums where nums[i] is a non-empty array of distinct positive integers, return the list of integers that are present in each array of nums sorted in ascending order.",
        "examples": [
            "Input: nums = [[3,1,2,4,5],[1,2,3,4],[3,4,5,6]]\nOutput: [3,4]\nExplanation: \nThe only integers present in each of nums[0] = [3,1,2,4,5], nums[1] = [1,2,3,4], and nums[2] = [3,4,5,6] are 3 and 4, so we return [3,4].",
            "Input: nums = [[1,2,3],[4,5,6]]\nOutput: []\nExplanation: \nThere does not exist any integer present both in nums[0] and nums[1], so we return an empty list []."
        ],
        "constraints": "1 <= nums.length <= 1000\n1 <= sum(nums[i].length) <= 1000\n1 <= nums[i][j] <= 1000\nAll the values of nums[i] are unique.",
        "oracle_code": "class Solution {\n    public List<Integer> intersection(int[][] nums) {\n        \n        List<Integer> ans = new ArrayList<>();\n        \n        int[] count  = new int[1001];\n        \n        for(int[] arr : nums){\n            for(int i : arr){\n                count[i]++;\n            }\n        }\n        \n       for(int i=0;i<count.length;i++){\n           if(count[i]==nums.length){\n               ans.add(i);\n           }\n       }\n        \n        return ans;\n    }\n}",
        "content": "```\\n\\nclass Solution {\\n    public List<Integer> intersection(int[][] nums) {\\n        \\n        List<Integer> ans = new ArrayList<>();\\n        \\n        int[] count  = new int[1001];\\n        \\n        for(int[] arr : nums){\\n            for(int i : arr){\\n                count[i]++;\\n            }\\n        }\\n        \\n       for(int i=0;i<count.length;i++){\\n           if(count[i]==nums.length){\\n               ans.add(i);\\n           }\\n       }\\n        \\n        return ans;\\n    }\\n}\\n\\n```",
        "level": "easy",
        "type": [
            "== and = confusion",
            "conditional statement error",
            "wrong comment mark",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution {\n    public List<Integer> intersection(int[][] nums) {\n        \n        List<Integer> ans = new ArrayList<>();\n        \n        int[] count  = new int[1001];\n        \n        i=0; i<=nums.length; i++){\n            fo(int j[i]){\n                count[j]++;\n            }\n        }\n        \n        for(int i=0;i<count.length;i++){\n           if(count[i]=nums.length+1){\n               ans.add(i);\n           }\n        }\n        \n        return ans;\n    }\n}\n"
    },
    {
        "slug": "jewels-and-stones",
        "description": "You're given strings jewels representing the types of stones that are jewels, and stones representing the stones you have. Each character in stones is a type of stone you have. You want to know how many of the stones you have are also jewels.\nLetters are case sensitive, so \"a\" is considered a different type of stone from \"A\".",
        "examples": [
            "Input: jewels = \"aA\", stones = \"aAAbbbb\"\nOutput: 3",
            "Input: jewels = \"z\", stones = \"ZZ\"\nOutput: 0"
        ],
        "constraints": "1 <=\u00a0jewels.length, stones.length <= 50\njewels and stones consist of only English letters.\nAll the characters of\u00a0jewels are unique.",
        "oracle_code": "class Solution {\n    public int numJewelsInStones(String jewels, String stones) {\n        int count = 0;\n\n        for(int i=0; i<stones.length(); i++){\n            char c = stones.charAt(i);\n            if(jewels.contains(String.valueOf(c))){\n                count++;\n            }\n        }\n        return count;\n    }\n}",
        "content": "# Code\\n```\\nclass Solution {\\n    public int numJewelsInStones(String jewels, String stones) {\\n        int count = 0;\\n\\n        for(int i=0; i<stones.length(); i++){\\n            char c = stones.charAt(i);\\n            if(jewels.contains(String.valueOf(c))){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
        "level": "easy",
        "type": [
            "operation error",
            "undefined objects",
            "undefined keywords from other languages",
            "statement separation"
        ],
        "buggy_code": "\nclass Solution {\n    public int numJewelsInStones(String jewels, String stones) {\n        int count = 0;\n        let checkCharacter;\n\n        for(int i=0; i<stones.length(); i++)\n            checkCharacter = stones.charAt(i);\n            String undefinedObject = null;\n            if(undefinedObject.contains(String.valueOf(checkCharacter))){\n                count--;\n            }\n        return count;\n    }\n}\n\n"
    },
    {
        "slug": "largest-number-after-digit-swaps-by-parity",
        "description": "You are given a positive integer num. You may swap any two digits of num that have the same parity (i.e. both odd digits or both even digits).\nReturn the largest possible value of num after any number of swaps.",
        "examples": [
            "Input: num = 1234\nOutput: 3412\nExplanation: Swap the digit 3 with the digit 1, this results in the number 3214.\nSwap the digit 2 with the digit 4, this results in the number 3412.\nNote that there may be other sequences of swaps but it can be shown that 3412 is the largest possible number.\nAlso note that we may not swap the digit 4 with the digit 1 since they are of different parities.",
            "Input: num = 65875\nOutput: 87655\nExplanation: Swap the digit 8 with the digit 6, this results in the number 85675.\nSwap the first digit 5 with the digit 7, this results in the number 87655.\nNote that there may be other sequences of swaps but it can be shown that 87655 is the largest possible number."
        ],
        "constraints": "1 <= num <= 109",
        "oracle_code": "class Solution {\n    public int largestInteger(int num) {\n        String numString = \"\"+ num;\n        List<Integer> even = new ArrayList<>();\n        List<Integer> odd = new ArrayList<>();\n        for(Character c : numString.toCharArray()){\n            int n = Character.getNumericValue(c);\n            if(n%2==0){\n                even.add(n);\n            }else{\n                odd.add(n);\n            }\n        }\n        Collections.sort(even, Collections.reverseOrder());\n        Collections.sort(odd, Collections.reverseOrder());\n        String res =\"\";\n        int one=0, two=0;\n        for(int i=0; i<numString.length(); i++){\n            int n = Character.getNumericValue(numString.charAt(i));\n            if(n%2==0){\n                res += even.get(one);\n                one++;\n            }else{\n                res += odd.get(two);\n                two++;\n            }\n        }\n        return Integer.parseInt(res);\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nused string and list to store the even and odd elements\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nconverted num in string then added all values from string to even and odd list as per its type;\\nthen sorted both string in desc order\\nas we check from the original string if got even number we will put max even number from even list and incresed even list pointer same for the odd number\\n\\nConverted result string to integer to get int res and returned it\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int largestInteger(int num) {\\n        String numString = \"\"+ num;\\n        List<Integer> even = new ArrayList<>();\\n        List<Integer> odd = new ArrayList<>();\\n        for(Character c : numString.toCharArray()){\\n            int n = Character.getNumericValue(c);\\n            if(n%2==0){\\n                even.add(n);\\n            }else{\\n                odd.add(n);\\n            }\\n        }\\n        Collections.sort(even, Collections.reverseOrder());\\n        Collections.sort(odd, Collections.reverseOrder());\\n        String res =\"\";\\n        int one=0, two=0;\\n        for(int i=0; i<numString.length(); i++){\\n            int n = Character.getNumericValue(numString.charAt(i));\\n            if(n%2==0){\\n                res += even.get(one);\\n                one++;\\n            }else{\\n                res += odd.get(two);\\n                two++;\\n            }\\n        }\\n        return Integer.parseInt(res);\\n    }\\n}\\n```",
        "level": "easy",
        "type": [
            "conditional statement error",
            "wrong comment mark",
            "undefined keywords from other languages",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution {\n    public int largestInteger(int num) {\n        String numString = \"\"+ num;\n        /*List<Integer> even = new ArrayList<>();*/\n        List<Integer> odd = new ArrayList<>();\n        for(Character c : numString.toCharArray()){\n            int n = Character.getNumericValue(c);\n            if(n%2==0){\n                even.add(n);\n            }else{\n                odd.add(n);\n            }\n        }\n        Collections.sort(even, Collections.reverseOrder());\n        Collections.sort(odd, Collections.reverseOrder());\n        String res =\"\"\n\n        \n        for(int i=0; i<numString.length()+5; i++){\n            int n = Character.getNumericValue(numString.charAt(i));\n            if(n%2==0){\n                res += even.get(one);\n                one++;\n            }else{\n                res += odd.get(two);\n                two++;\n            }\n        }\n        return Integer.parse_int(res);\n    }\n}\n"
    },
    {
        "slug": "same-tree",
        "description": "Given the roots of two binary trees p and q, write a function to check if they are the same or not.\nTwo binary trees are considered the same if they are structurally identical, and the nodes have the same value.",
        "examples": [
            "Input: p = [1,2,3], q = [1,2,3]\nOutput: true",
            "Input: p = [1,2], q = [1,null,2]\nOutput: false",
            "Input: p = [1,2,1], q = [1,1,2]\nOutput: false"
        ],
        "constraints": "The number of nodes in both trees is in the range [0, 100].\n-104 <= Node.val <= 104",
        "oracle_code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n   \n    public boolean isSameTree(TreeNode p, TreeNode q) {\n     if (p == null && q == null) {\n            return true;\n        }\n        \n        if (p == null || q == null) {\n            return false;\n        }\n        \n        if (p.val != q.val) {\n            return false;\n        }\n        \n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n\n        \n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n   \\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n     if (p == null && q == null) {\\n            return true;\\n        }\\n        \\n        if (p == null || q == null) {\\n            return false;\\n        }\\n        \\n        if (p.val != q.val) {\\n            return false;\\n        }\\n        \\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n\\n        \\n    }\\n}\\n```",
        "level": "easy",
        "type": [
            "parentheses mismatch",
            "conditional statement error",
            "wrong comment mark",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\n\n\nclass Solution {\n   \n    public boolean isSameTree(TreeNode p, TreeNode q) {\n     if (p == null && q == null) {\n            return true;\n        }\n        \n        if (p == null || q == null) {\n            return false;\n        }\n        \n        if (p.val == q.val) {\n            return false;\n        }\n        \n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n\n        \n    }\n}\n\n/**/\n=\n"
    },
    {
        "slug": "intersection-of-multiple-arrays",
        "description": "Given a 2D integer array nums where nums[i] is a non-empty array of distinct positive integers, return the list of integers that are present in each array of nums sorted in ascending order.",
        "examples": [
            "Input: nums = [[3,1,2,4,5],[1,2,3,4],[3,4,5,6]]\nOutput: [3,4]\nExplanation: \nThe only integers present in each of nums[0] = [3,1,2,4,5], nums[1] = [1,2,3,4], and nums[2] = [3,4,5,6] are 3 and 4, so we return [3,4].",
            "Input: nums = [[1,2,3],[4,5,6]]\nOutput: []\nExplanation: \nThere does not exist any integer present both in nums[0] and nums[1], so we return an empty list []."
        ],
        "constraints": "1 <= nums.length <= 1000\n1 <= sum(nums[i].length) <= 1000\n1 <= nums[i][j] <= 1000\nAll the values of nums[i] are unique.",
        "oracle_code": "class Solution {\n    public List<Integer> intersection(int[][] nums) {\n        \n        List<Integer> ans = new ArrayList<>();\n        \n        int[] count  = new int[1001];\n        \n        for(int[] arr : nums){\n            for(int i : arr){\n                count[i]++;\n            }\n        }\n        \n       for(int i=0;i<count.length;i++){\n           if(count[i]==nums.length){\n               ans.add(i);\n           }\n       }\n        \n        return ans;\n    }\n}",
        "content": "```\\n\\nclass Solution {\\n    public List<Integer> intersection(int[][] nums) {\\n        \\n        List<Integer> ans = new ArrayList<>();\\n        \\n        int[] count  = new int[1001];\\n        \\n        for(int[] arr : nums){\\n            for(int i : arr){\\n                count[i]++;\\n            }\\n        }\\n        \\n       for(int i=0;i<count.length;i++){\\n           if(count[i]==nums.length){\\n               ans.add(i);\\n           }\\n       }\\n        \\n        return ans;\\n    }\\n}\\n\\n```",
        "level": "easy",
        "type": [
            "conditional statement error",
            "wrong comment mark",
            "indexing error",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\n    public List<Integer> intersection(int[][] nums) {\n        \n        List<Integer> ans = new ArrayList<>();\n        \n        int[] count  = new int[1001];\n        \n        i=0; i<=nums.length; i++){\n            fo(int j[i]){\n                count[j]++;\n            }\n        }\n        \n        for(int i=0;i<count.length;i++){\n           if(count[i]==nums.length+1){\n               ans.add(i);\n           }\n        myRandomUndefinedFunction();\n        \n        }\n        \n        return ans;\n    }\n}\n"
    },
    {
        "slug": "reverse-words-in-a-string",
        "description": "Given an input string s, reverse the order of the words.\nA word is defined as a sequence of non-space characters. The words in s will be separated by at least one space.\nReturn a string of the words in reverse order concatenated by a single space.\nNote that s may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words. Do not include any extra spaces.",
        "examples": [
            "Input: s = \"the sky is blue\"\nOutput: \"blue is sky the\"",
            "Input: s = \"  hello world  \"\nOutput: \"world hello\"\nExplanation: Your reversed string should not contain leading or trailing spaces.",
            "Input: s = \"a good   example\"\nOutput: \"example good a\"\nExplanation: You need to reduce multiple spaces between two words to a single space in the reversed string."
        ],
        "constraints": "1 <= s.length <= 104\ns contains English letters (upper-case and lower-case), digits, and spaces ' '.\nThere is at least one word in s.\n\n\u00a0\nFollow-up:\u00a0If the string data type is mutable in your language, can\u00a0you solve it\u00a0in-place\u00a0with\u00a0O(1)\u00a0extra space?",
        "oracle_code": "class Solution {\n    public String reverseWords(String s) {\n        StringBuilder ans = new StringBuilder();\n        for(int i=s.length()-1; i>=0; i--){\n            if(s.charAt(i)==' '){\n                continue;\n            }\n            int start=-1;\n            for(int y=i-1; y>=0; y--){\n                if(s.charAt(y)==' '){\n                    start=y;\n                    break;\n                }\n            }\n            ans.append(s.substring(start+1, i+1) + \" \");\n            i=start;\n        }\n        ans.deleteCharAt(ans.length()-1);\n        return ans.toString();\n    }\n}",
        "content": "# Approach\\n- Two Pointer Approach\\n- Using Trim and Split\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public String reverseWords(String s) {\\n        StringBuilder ans = new StringBuilder();\\n        for(int i=s.length()-1; i>=0; i--){\\n            if(s.charAt(i)==\\' \\'){\\n                continue;\\n            }\\n            int start=-1;\\n            for(int y=i-1; y>=0; y--){\\n                if(s.charAt(y)==\\' \\'){\\n                    start=y;\\n                    break;\\n                }\\n            }\\n            ans.append(s.substring(start+1, i+1) + \" \");\\n            i=start;\\n        }\\n        ans.deleteCharAt(ans.length()-1);\\n        return ans.toString();\\n    }\\n}\\n```\\n```\\nclass Solution {\\n    public String reverseWords(String s) {\\n        String[] temp = s.trim().split(\" \");\\n        StringBuilder ans = new StringBuilder();\\n        for(int i=temp.length-1; i>0; i--){\\n            if(temp[i]==\"\"){\\n                continue;\\n            }\\n            ans.append(temp[i]+\" \");\\n        }\\n        ans.append(temp[0]);\\n        return ans.toString();\\n    }\\n}\\n```",
        "level": "medium",
        "type": [
            "== and = confusion",
            "wrong comment mark",
            "undefined objects",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution {\n    public String reverseWords(String s) {\n        StringBuilder ans = new StringBuilder();\n        String str = null;\n        for(int i=s.length()-1; i>=str.length(); i--){\n            /*if(s.charAt(i)==' '){\n                continue;\n            }*/\n            int start=-1;\n            for(int y=i-1; y>=0; y--){\n                if(s.charAt(y)==' '){\n                    start=y;\n                    break;\n                }\n            }\n            ans.append(s.substring(start+1, i+1) + \" \";\n            i=start;\n        }\n        ans.deleteCharAt(ans.length()-1);\n        return ans.toString()==s;\n    }\n}\n"
    },
    {
        "slug": "remove-k-digits",
        "description": "Given string num representing a non-negative integer num, and an integer k, return the smallest possible integer after removing k digits from num.",
        "examples": [
            "Input: num = \"1432219\", k = 3\nOutput: \"1219\"\nExplanation: Remove the three digits 4, 3, and 2 to form the new number 1219 which is the smallest.",
            "Input: num = \"10200\", k = 1\nOutput: \"200\"\nExplanation: Remove the leading 1 and the number is 200. Note that the output must not contain leading zeroes.",
            "Input: num = \"10\", k = 2\nOutput: \"0\"\nExplanation: Remove all the digits from the number and it is left with nothing which is 0."
        ],
        "constraints": "1 <= k <= num.length <= 105\nnum consists of only digits.\nnum does not have any leading zeros except for the zero itself.",
        "oracle_code": "class Solution {\n    public String removeKdigits(String num, int k) {\n        Stack<Character> st = new Stack<>();\n        for(Character ch : num.toCharArray()) {\n            while(!st.isEmpty() && k > 0 && ch < st.peek()) {\n                st.pop();\n                k--;\n            }\n\n            if(!st.isEmpty() || ch != '0') {\n                st.push(ch);\n            }\n        }\n\n        // This is a special edge case --> 1 2 3 4\n        while(!st.isEmpty() && k-- > 0) {\n            st.pop();\n        }\n        if(st.isEmpty()) return \"0\";\n        \n\n        // Store the ans -->\n        String ans = \"\";\n        while(!st.isEmpty()) {\n            ans = st.peek() + ans;\n            st.pop();\n        }\n        return ans;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n# Code\\n```\\nclass Solution {\\n    public String removeKdigits(String num, int k) {\\n        Stack<Character> st = new Stack<>();\\n        for(Character ch : num.toCharArray()) {\\n            while(!st.isEmpty() && k > 0 && ch < st.peek()) {\\n                st.pop();\\n                k--;\\n            }\\n\\n            if(!st.isEmpty() || ch != \\'0\\') {\\n                st.push(ch);\\n            }\\n        }\\n\\n        // This is a special edge case --> 1 2 3 4\\n        while(!st.isEmpty() && k-- > 0) {\\n            st.pop();\\n        }\\n        if(st.isEmpty()) return \"0\";\\n        \\n\\n        // Store the ans -->\\n        String ans = \"\";\\n        while(!st.isEmpty()) {\\n            ans = st.peek() + ans;\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n}\\n```",
        "level": "medium",
        "type": [
            "parentheses mismatch",
            "conditional statement error",
            "unclosed string",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\n    public String removeKdigits(String num, int k) {\n        Stack<Character> st = new Stack<>();\n        for(Character ch : num.toCharArray()) {\n            while(!st.isEmpty() && k > 0 && ch < st.peek())\n                st.pop();\n                \n                k--;\n\n            if(!st.isEmpty() || ch != '1') { \n                st.push(ch);\n            }\n        }\nwhile(!st.isEmpty() && k-- > 0) {\n            st.pop();\n        }\n        if(st.isEmpty()) return \"0\";\n\n        String ans = \"0\";\n        while(!st.isEmpty()) {\n            ans = st.peek() + ans;\n            st.pop();\n        }\n        return result;\n    }\n\n}\n"
    },
    {
        "slug": "largest-number-after-digit-swaps-by-parity",
        "description": "You are given a positive integer num. You may swap any two digits of num that have the same parity (i.e. both odd digits or both even digits).\nReturn the largest possible value of num after any number of swaps.",
        "examples": [
            "Input: num = 1234\nOutput: 3412\nExplanation: Swap the digit 3 with the digit 1, this results in the number 3214.\nSwap the digit 2 with the digit 4, this results in the number 3412.\nNote that there may be other sequences of swaps but it can be shown that 3412 is the largest possible number.\nAlso note that we may not swap the digit 4 with the digit 1 since they are of different parities.",
            "Input: num = 65875\nOutput: 87655\nExplanation: Swap the digit 8 with the digit 6, this results in the number 85675.\nSwap the first digit 5 with the digit 7, this results in the number 87655.\nNote that there may be other sequences of swaps but it can be shown that 87655 is the largest possible number."
        ],
        "constraints": "1 <= num <= 109",
        "oracle_code": "class Solution {\n    public int largestInteger(int num) {\n        String numString = \"\"+ num;\n        List<Integer> even = new ArrayList<>();\n        List<Integer> odd = new ArrayList<>();\n        for(Character c : numString.toCharArray()){\n            int n = Character.getNumericValue(c);\n            if(n%2==0){\n                even.add(n);\n            }else{\n                odd.add(n);\n            }\n        }\n        Collections.sort(even, Collections.reverseOrder());\n        Collections.sort(odd, Collections.reverseOrder());\n        String res =\"\";\n        int one=0, two=0;\n        for(int i=0; i<numString.length(); i++){\n            int n = Character.getNumericValue(numString.charAt(i));\n            if(n%2==0){\n                res += even.get(one);\n                one++;\n            }else{\n                res += odd.get(two);\n                two++;\n            }\n        }\n        return Integer.parseInt(res);\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nused string and list to store the even and odd elements\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nconverted num in string then added all values from string to even and odd list as per its type;\\nthen sorted both string in desc order\\nas we check from the original string if got even number we will put max even number from even list and incresed even list pointer same for the odd number\\n\\nConverted result string to integer to get int res and returned it\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int largestInteger(int num) {\\n        String numString = \"\"+ num;\\n        List<Integer> even = new ArrayList<>();\\n        List<Integer> odd = new ArrayList<>();\\n        for(Character c : numString.toCharArray()){\\n            int n = Character.getNumericValue(c);\\n            if(n%2==0){\\n                even.add(n);\\n            }else{\\n                odd.add(n);\\n            }\\n        }\\n        Collections.sort(even, Collections.reverseOrder());\\n        Collections.sort(odd, Collections.reverseOrder());\\n        String res =\"\";\\n        int one=0, two=0;\\n        for(int i=0; i<numString.length(); i++){\\n            int n = Character.getNumericValue(numString.charAt(i));\\n            if(n%2==0){\\n                res += even.get(one);\\n                one++;\\n            }else{\\n                res += odd.get(two);\\n                two++;\\n            }\\n        }\\n        return Integer.parseInt(res);\\n    }\\n}\\n```",
        "level": "easy",
        "type": [
            "conditional statement error",
            "wrong comment mark",
            "unclosed string",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\n    public int largestInteger(int num) {\n        String numString = \"\"+ num;\n        /*List<Integer> even = new ArrayList<>();*/\n        List<Integer> odd = new ArrayList<>();\n        for(Character c : numString.toCharArray()){\n            int n = Character.getNumericValue(c);\n            if(n%2==0){\n                even.add(n);\n            }else{\n                odd.add(n);\n            }\n        }\n        Collections.sort(even, Collections.reverseOrder());\n        Collections.sort(odd, Collections.reverseOrder());\n        String res =\"\"\n\n        \n        for(int i=0; i<numString.length()+5; i++){\n            int n = Character.getNumericValue(numString.charAt(i));\n            if(n%2==0){\n                res += even.get(one);\n                one++;\n            }else{\n                res += odd.get(two);\n                two++;\n            }\n        }\n        return Integer.parseStringMethodThatDoesntExist(res);\n    }\n}\n"
    },
    {
        "slug": "number-of-laser-beams-in-a-bank",
        "description": "Anti-theft security devices are activated inside a bank. You are given a 0-indexed binary string array bank representing the floor plan of the bank, which is an m x n 2D matrix. bank[i] represents the ith row, consisting of '0's and '1's. '0' means the cell is empty, while'1' means the cell has a security device.\nThere is one laser beam between any two security devices if both conditions are met:\n\nThe two devices are located on two different rows: r1 and r2, where r1 < r2.\nFor each row i where r1 < i < r2, there are no security devices in the ith row.\n\nLaser beams are independent, i.e., one beam does not interfere nor join with another.\nReturn the total number of laser beams in the bank.",
        "examples": [
            "Input: bank = [\"011001\",\"000000\",\"010100\",\"001000\"]\nOutput: 8\nExplanation: Between each of the following device pairs, there is one beam. In total, there are 8 beams:\n * bank[0][1] -- bank[2][1]\n * bank[0][1] -- bank[2][3]\n * bank[0][2] -- bank[2][1]\n * bank[0][2] -- bank[2][3]\n * bank[0][5] -- bank[2][1]\n * bank[0][5] -- bank[2][3]\n * bank[2][1] -- bank[3][2]\n * bank[2][3] -- bank[3][2]\nNote that there is no beam between any device on the 0th row with any on the 3rd row.\nThis is because the 2nd row contains security devices, which breaks the second condition.",
            "Input: bank = [\"000\",\"111\",\"000\"]\nOutput: 0\nExplanation: There does not exist two devices located on two different rows."
        ],
        "constraints": "m == bank.length\nn == bank[i].length\n1 <= m, n <= 500\nbank[i][j] is either '0' or '1'.",
        "oracle_code": "class Solution {\n    public int numberOfBeams(String[] bank) {\n        int prevLazer =0;\n        int ans =0;\n        for(String s:bank){\n            int curLazer = 0;\n            for(char c: s.toCharArray()){\n                if(c=='1'){\n                    curLazer++;\n                }\n            }\n            if(curLazer >0){\n                ans += (curLazer * prevLazer);\n                prevLazer = curLazer;\n            }\n        }\n        return ans;\n    }\n}",
        "content": "\\n# java Code\\n```\\nclass Solution {\\n    public int numberOfBeams(String[] bank) {\\n        int prevLazer =0;\\n        int ans =0;\\n        for(String s:bank){\\n            int curLazer = 0;\\n            for(char c: s.toCharArray()){\\n                if(c==\\'1\\'){\\n                    curLazer++;\\n                }\\n            }\\n            if(curLazer >0){\\n                ans += (curLazer * prevLazer);\\n                prevLazer = curLazer;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
        "level": "medium",
        "type": [
            "variable value error",
            "== and = confusion",
            "wrong comment mark",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution {\n    public int numberOfBeams(String[] bank) {\n        int prevLazer =0;\n        int ans =0;\n        for(String s:bank){\n            int curLazer = 0;\n            for(char c: s.toCharArray()){\n                if(c=='1'){\n                    curLazer++;\n            }\n\n                ans += (curLazer * prevLazer);\n                prevLazer = curLazer;\n            }\n        = } return ans;\n    le{\n                prevLazer = 0;\n            \n        }\n        print(ans);\n        return ans;\n    }\n}\n"
    },
    {
        "slug": "prime-in-diagonal",
        "description": "You are given a 0-indexed two-dimensional integer array nums.\nReturn the largest prime number that lies on at least one of the diagonals of nums. In case, no prime is present on any of the diagonals, return 0.\nNote that:\n\nAn integer is prime if it is greater than 1 and has no positive integer divisors other than 1 and itself.\nAn integer val is on one of the diagonals of nums if there exists an integer i for which nums[i][i] = val or an i for which nums[i][nums.length - i - 1] = val.\n\n\nIn the above diagram, one diagonal is [1,5,9] and another diagonal is [3,5,7].",
        "examples": [
            "Input: nums = [[1,2,3],[5,6,7],[9,10,11]]\nOutput: 11\nExplanation: The numbers 1, 3, 6, 9, and 11 are the only numbers present on at least one of the diagonals. Since 11 is the largest prime, we return 11.",
            "Input: nums = [[1,2,3],[5,17,7],[9,11,10]]\nOutput: 17\nExplanation: The numbers 1, 3, 9, 10, and 17 are all present on at least one of the diagonals. 17 is the largest prime, so we return 17."
        ],
        "constraints": "1 <= nums.length <= 300\nnums.length == numsi.length\n1 <= nums[i][j]\u00a0<= 4*106",
        "oracle_code": "class Solution {\n    public int diagonalPrime(int[][] nums) {\n        int n = nums.length;\n        int m = nums[0].length;\n        int maxim = 0;\n        for (int i = 0; i < n; i++) {\n                if (checkPrime(nums[i][i])) {\n                    maxim = Math.max(maxim, nums[i][i]);\n                } \n                if (checkPrime(nums[n-1-i][i])) {\n                    maxim = Math.max(maxim, nums[n - i - 1][i]);\n\n                }\n            \n        }\n        return maxim;\n    }\n    public boolean checkPrime(int k) {\n\n        int count = 0;\n        if (k == 1) {\n            return false;\n        }\n        for (int i = 1; i * i <= k; i++) {\n          if (k % i == 0) {\n              count += 2;\n          }\n      }\n      if (count == 2) {\n          return true; \n      } else {\n          return false;\n      }\n      \n    }\n\n}",
        "content": "**Must read if there is any doubt feel free to ask in comments**\\n\\nSomehow beginners face difficulty to understand the concept at first, but i will try my best to breakdown the question into simpler parts so that there would be ease to understand for beginners.\\n\\n\\n\\n**first we have to check prime number on the diagnol of the matrix.**\\n\\n**Step 1** -> so we make a function to check wether the given number is prime or not\\n\\n**Note** -> there are several functions to checkPrime as a naive/beginner you apply what you have learnt in fundamentals programming but it would not work\\n\\nBut here we have to create a checkPrime no. function that would be  optimized otherwise you will get **TLE** which is **Time Limit Exceeded** error.\\n\\n\\nTo find a prime number what we do firstly? -> find factors\\n\\ne.g\\n Num - > 12\\nfactors -> \\n\\n    **i** -------- **k**\\n    1 * 12 = 12\\n    2 * 6 = 12\\n    3 * 4 = 12\\n    4 * 3 = 12\\n    6 * 2 = 12\\n    12 * 1 = 12\\n\\nwe have total 6 factors \\n\\n**Trivial method: TLE occurs for this coz it isn\\'t optimized.**\\n\\nint count = 0;\\nif (k < 2) {\\n    return false;\\n}\\nfor (int i = 1; i < k; i++) {\\n    if (k % i == 0) {\\n        count++;        \\n    }\\n}\\nif (count == 2) {\\n    return true;\\n} else {\\n    return false;\\n}\\n\\nNow what if I say we do not need to iterate till k if we focus on the pattern we see that after i = 3 same numbers are repeating such as (4,3) despite (3,4) was there already , similarly (6,2) despite (2,6) is there etc...\\n\\nnow what we do is we would iterate our loop from **i to \\u221Ak** or we can write it as **i * i to k** also **so that our i iterate in the range between [1 - 3] so we have to take the square root of k. \\ni.e \\n1 * 12, 2 * 6, 3 * 4 and we get all the 6 factors till i = 3.**\\n\\n\\ne.g\\n Num - > 12\\nfactors -> 1, 2, 3, 4, 6, 12\\n**i ------- k**\\n1 * 12 = 12\\n2 * 6 = 12\\n3 * 4 = 12\\n\\n 4 * 3 = 12\\n 6 * 2 = 12\\n12 * 1 = 12\\n\\nfor (int i = 1; i * i <= k; i++) {\\n    if (k < 2) {\\n    return false;\\n    }\\n    if (k % i == 0) {\\n        count +=2; \\n//count + 2 because 1 * 12 we grab two factors from herethen why we need to go till 12.\\n\\n}\\nif (count == 2) {\\nreturn true\\n} else {\\nreturn false;\\n}\\n}\\n\\n**Now we have converted our problem in \\u221An time complexity.**\\n\\n\\n\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int diagonalPrime(int[][] nums) {\\n        int n = nums.length;\\n        int m = nums[0].length;\\n        int maxim = 0;\\n        for (int i = 0; i < n; i++) {\\n                if (checkPrime(nums[i][i])) {\\n                    maxim = Math.max(maxim, nums[i][i]);\\n                } \\n                if (checkPrime(nums[n-1-i][i])) {\\n                    maxim = Math.max(maxim, nums[n - i - 1][i]);\\n\\n                }\\n            \\n        }\\n        return maxim;\\n    }\\n    public boolean checkPrime(int k) {\\n\\n        int count = 0;\\n        if (k == 1) {\\n            return false;\\n        }\\n        for (int i = 1; i * i <= k; i++) {\\n          if (k % i == 0) {\\n              count += 2;\\n          }\\n      }\\n      if (count == 2) {\\n          return true; \\n      } else {\\n          return false;\\n      }\\n      \\n    }\\n\\n}\\n```",
        "level": "easy",
        "type": [
            "parentheses mismatch",
            "conditional statement error",
            "indexing error",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution {\n    public int diagonalPrime(int[][] nums) {\n        int n = nums.length;\n        int m = nums[0].length;\n        int maxim = 0;\n        for (int i = 0; i <= n; i++) {\n                if (nums[i][i] != null) {  \n                  if (checkPrime(nums[i][i])) {\n                      maxim = Math.max(maxim, nums[i][i]);\n                  } \n                }\n            \n        }\n        return maxim;\n    }\n    public boolean checkPrime(\n        }int k) {\n        int count = 0;\n        if (k == 1) {\n            return false;\n        }\n        for (int i = 1; i * i <= k; i++) {\n          if (k % i == 0) {\n              count += 2;\n          }\n      }\n      if (count == 2) {\n          return true; \n      } else {\n          return false;\n      }\n      \n    }\n}\n"
    },
    {
        "slug": "daily-temperatures",
        "description": "Given an array of integers temperatures represents the daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after the ith day to get a warmer temperature. If there is no future day for which this is possible, keep answer[i] == 0 instead.",
        "examples": [
            "Input: temperatures = [73,74,75,71,69,72,76,73]\nOutput: [1,1,4,2,1,1,0,0]",
            "Input: temperatures = [30,40,50,60]\nOutput: [1,1,1,0]",
            "Input: temperatures = [30,60,90]\nOutput: [1,1,0]"
        ],
        "constraints": "1 <=\u00a0temperatures.length <= 105\n30 <=\u00a0temperatures[i] <= 100",
        "oracle_code": "class Solution {\n    public int[] dailyTemperatures(int[] temperatures) {\n        \n        int[] arr = new int[temperatures.length]; \n        \n        ArrayDeque<int[]> st = new ArrayDeque<>(); \n        \n        int i=0, j=temperatures.length-1 ; \n        \n        while( j >= 0){\n            \n            if(st.size()==0){\n                arr[i++] = 0;\n            }\n            else  if (st.size()>0 && st.peek()[0]>temperatures[j])\n            {\n                arr[i++]=1;\n            } \n            else if (st.size()>0 && st.peek()[0]<=temperatures[j])\n            \n            {  while(st.size()>0 && st.peek()[0]<=temperatures[j]){\n                    st.pop();\n                    \n                }\n            if(st.size()==0){\n                arr[i++]=0;\n            }\n            else{\n                arr[i++]=st.peek()[1]-j;\n            }\n            } \n        st.push(new int[]{temperatures[j],j}); \n        j--;\n        }\n        \n      \n        int[] ans = new int[temperatures.length]; int k=0;\n        for(i=arr.length-1; i>=0; i--){\n            ans[k++]=arr[i];\n        }\n        return ans;\n    }\n}",
        "content": "```\\nclass Solution {\\n    public int[] dailyTemperatures(int[] temperatures) {\\n        \\n        int[] arr = new int[temperatures.length]; \\n        \\n        ArrayDeque<int[]> st = new ArrayDeque<>(); \\n        \\n        int i=0, j=temperatures.length-1 ; \\n        \\n        while( j >= 0){\\n            \\n            if(st.size()==0){\\n                arr[i++] = 0;\\n            }\\n            else  if (st.size()>0 && st.peek()[0]>temperatures[j])\\n            {\\n                arr[i++]=1;\\n            } \\n            else if (st.size()>0 && st.peek()[0]<=temperatures[j])\\n            \\n            {  while(st.size()>0 && st.peek()[0]<=temperatures[j]){\\n                    st.pop();\\n                    \\n                }\\n            if(st.size()==0){\\n                arr[i++]=0;\\n            }\\n            else{\\n                arr[i++]=st.peek()[1]-j;\\n            }\\n            } \\n        st.push(new int[]{temperatures[j],j}); \\n        j--;\\n        }\\n        \\n      \\n        int[] ans = new int[temperatures.length]; int k=0;\\n        for(i=arr.length-1; i>=0; i--){\\n            ans[k++]=arr[i];\\n        }\\n        return ans;\\n    }\\n}",
        "level": "medium",
        "type": [
            "variable value error",
            "indexing error",
            "undefined objects",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution {\n    public int[] dailyTemperatures(int[] temperatures) {\n        \n        let[] arr = new let[temperatures.length + 1]; \n        \n        ArrayDeque<int[]> st = new ArrayDeque<>(); \n        \n        int i=0, j=temperatures.length ; \n        \n        while( j >= 0){\n            \n            if(st.size()==0){\n                arr[i++] = 0;\n            }\n            else  if (st.size()>0 && st.peek()[0]>temperatures[j])\n            {\n                arr[i++]=1;\n            } \n            else if (st.size()>0 && st.peek()[0]<=temperatures[j])\n            \n            {  while(st.size()>0 && st.peek()[0]<=temperatures[j]){\n                    st.pop();\n                    \n                }\n            if(st.size()==0){\n                arr[i++]=0;\n            }\n            else{\n                arr[i++]=st.peek()[1]-j;\n            }\n            } \n        st.push(new int[]{temperatures[j],j}); \n        j--;\n        }\n        \n      \n        int[] ans = new int[temperatures.length]; int k=0;\n        for(i=arr.length-1 + ; \n        return ans;\n    }\n}\n\nlele\n"
    },
    {
        "slug": "sum-of-total-strength-of-wizards",
        "description": "As the ruler of a kingdom, you have an army of wizards at your command.\nYou are given a 0-indexed integer array strength, where strength[i] denotes the strength of the ith wizard. For a contiguous group of wizards (i.e. the wizards' strengths form a subarray of strength), the total strength is defined as the product of the following two values:\n\nThe strength of the weakest wizard in the group.\nThe total of all the individual strengths of the wizards in the group.\n\nReturn the sum of the total strengths of all contiguous groups of wizards. Since the answer may be very large, return it modulo 109 + 7.\nA subarray is a contiguous non-empty sequence of elements within an array.",
        "examples": [
            "Input: strength = [1,3,1,2]\nOutput: 44\nExplanation: The following are all the contiguous groups of wizards:\n- [1] from [1,3,1,2] has a total strength of min([1]) * sum([1]) = 1 * 1 = 1\n- [3] from [1,3,1,2] has a total strength of min([3]) * sum([3]) = 3 * 3 = 9\n- [1] from [1,3,1,2] has a total strength of min([1]) * sum([1]) = 1 * 1 = 1\n- [2] from [1,3,1,2] has a total strength of min([2]) * sum([2]) = 2 * 2 = 4\n- [1,3] from [1,3,1,2] has a total strength of min([1,3]) * sum([1,3]) = 1 * 4 = 4\n- [3,1] from [1,3,1,2] has a total strength of min([3,1]) * sum([3,1]) = 1 * 4 = 4\n- [1,2] from [1,3,1,2] has a total strength of min([1,2]) * sum([1,2]) = 1 * 3 = 3\n- [1,3,1] from [1,3,1,2] has a total strength of min([1,3,1]) * sum([1,3,1]) = 1 * 5 = 5\n- [3,1,2] from [1,3,1,2] has a total strength of min([3,1,2]) * sum([3,1,2]) = 1 * 6 = 6\n- [1,3,1,2] from [1,3,1,2] has a total strength of min([1,3,1,2]) * sum([1,3,1,2]) = 1 * 7 = 7\nThe sum of all the total strengths is 1 + 9 + 1 + 4 + 4 + 4 + 3 + 5 + 6 + 7 = 44.",
            "Input: strength = [5,4,6]\nOutput: 213\nExplanation: The following are all the contiguous groups of wizards: \n- [5] from [5,4,6] has a total strength of min([5]) * sum([5]) = 5 * 5 = 25\n- [4] from [5,4,6] has a total strength of min([4]) * sum([4]) = 4 * 4 = 16\n- [6] from [5,4,6] has a total strength of min([6]) * sum([6]) = 6 * 6 = 36\n- [5,4] from [5,4,6] has a total strength of min([5,4]) * sum([5,4]) = 4 * 9 = 36\n- [4,6] from [5,4,6] has a total strength of min([4,6]) * sum([4,6]) = 4 * 10 = 40\n- [5,4,6] from [5,4,6] has a total strength of min([5,4,6]) * sum([5,4,6]) = 4 * 15 = 60\nThe sum of all the total strengths is 25 + 16 + 36 + 36 + 40 + 60 = 213."
        ],
        "constraints": "1 <= strength.length <= 105\n1 <= strength[i] <= 109",
        "oracle_code": "class Solution {\n    public int totalStrength(int[] strength) {\n        int mod = 1000000007;\n        \n        int len = strength.length;\n        \n        long[] prefix = prefixSum(strength, len, mod);\n        \n        Deque<Integer> stack = new ArrayDeque<>();\n        stack.push(-1);\n\n        long ans = 0;\n        for(int i = 0; i < len; i++) {\n            while(stack.peek() != -1 && strength[i] <= strength[stack.peek()]) {\n                int mid = stack.pop();\n                int left = stack.peek() + 1;\n                int right = i - 1;\n                \n                int n = (mid - left);\n                int t = (right - mid);\n                \n                long val = (1l * (1 + n) * (prefix[right + 2] - prefix[mid + 1]) + mod) % mod;\n                val -= (1l * (1 + t) * (prefix[mid + 1] - prefix[left]) + mod) % mod;\n                val *= strength[mid];\n                \n                ans += val;\n                ans %= mod;\n            }\n            \n            stack.push(i);\n        }\n        \n        int right = len - 1;\n        while(stack.peek() != -1) {\n            int mid = stack.pop();\n            int left = stack.peek() + 1;\n            \n            int n = (mid - left);\n            int t = (right - mid);\n\n            long val = (1l * (1 + n) * (prefix[right + 2] - prefix[mid + 1]) + mod) % mod;\n            val -= (1l * (1 + t) * (prefix[mid + 1] - prefix[left]) + mod) % mod;\n            val *= strength[mid];\n\n            ans += val;\n            ans %= mod;\n        }\n        \n        return (int)((ans + mod) % mod);\n    }\n    \n    private long[] prefixSum(int[] strength, int len, int mod) {\n        long[] prefix = new long[len + 1];\n        \n        for(int i = 0; i < len; i++) {\n            prefix[i + 1] = prefix[i] + strength[i];\n        }\n        \n        long[] doublePrefix = new long[len + 2];\n        for(int i = 0; i <= len; i++) {\n            doublePrefix[i + 1] = (doublePrefix[i] + prefix[i]) % mod;\n        }\n\n        return doublePrefix;\n    }\n}",
        "content": "I could not figure out `o(n)` approach on my own. \\nI needed to read at least 3 solution by really brilliant people (top voted) to understand the approach.\\nThen I had to do the math on pen-paper 3 times (made mistake 2 time) to actually understand the approach.\\nThen when I actually started coding, I made some some silly mistakes around Stack boundry and \\nthe cherry on top was that you need to do `+ mod) % mod` at almost every place you are doing any calculation.\\n\\nOverall, very good learning experience but I really pity the ones who actually face this in interview.\\n\\nRun time complexity: `4 * O(n)` =  `O(n)` \\nSpace compexity: `O(n)`\\n\\nMy java solution -\\n```\\nclass Solution {\\n    public int totalStrength(int[] strength) {\\n        int mod = 1000000007;\\n        \\n        int len = strength.length;\\n        \\n        long[] prefix = prefixSum(strength, len, mod);\\n        \\n        Deque<Integer> stack = new ArrayDeque<>();\\n        stack.push(-1);\\n\\n        long ans = 0;\\n        for(int i = 0; i < len; i++) {\\n            while(stack.peek() != -1 && strength[i] <= strength[stack.peek()]) {\\n                int mid = stack.pop();\\n                int left = stack.peek() + 1;\\n                int right = i - 1;\\n                \\n                int n = (mid - left);\\n                int t = (right - mid);\\n                \\n                long val = (1l * (1 + n) * (prefix[right + 2] - prefix[mid + 1]) + mod) % mod;\\n                val -= (1l * (1 + t) * (prefix[mid + 1] - prefix[left]) + mod) % mod;\\n                val *= strength[mid];\\n                \\n                ans += val;\\n                ans %= mod;\\n            }\\n            \\n            stack.push(i);\\n        }\\n        \\n        int right = len - 1;\\n        while(stack.peek() != -1) {\\n            int mid = stack.pop();\\n            int left = stack.peek() + 1;\\n            \\n            int n = (mid - left);\\n            int t = (right - mid);\\n\\n            long val = (1l * (1 + n) * (prefix[right + 2] - prefix[mid + 1]) + mod) % mod;\\n            val -= (1l * (1 + t) * (prefix[mid + 1] - prefix[left]) + mod) % mod;\\n            val *= strength[mid];\\n\\n            ans += val;\\n            ans %= mod;\\n        }\\n        \\n        return (int)((ans + mod) % mod);\\n    }\\n    \\n    private long[] prefixSum(int[] strength, int len, int mod) {\\n        long[] prefix = new long[len + 1];\\n        \\n        for(int i = 0; i < len; i++) {\\n            prefix[i + 1] = prefix[i] + strength[i];\\n        }\\n        \\n        long[] doublePrefix = new long[len + 2];\\n        for(int i = 0; i <= len; i++) {\\n            doublePrefix[i + 1] = (doublePrefix[i] + prefix[i]) % mod;\\n        }\\n\\n        return doublePrefix;\\n    }\\n}\\n```",
        "level": "hard",
        "type": [
            "variable value error",
            "indexing error",
            "undefined objects",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution {\n    public int totalStrength(int[] strength) {\n        int mod = 1000000007;\n        \n        int len = strength.length;\n        \n        long[] prefix = prefixSum(strength, len, mod);\n        \n        Deque<Integer> stack = null; \n        stack.push(-1);\n\n        long ans = 0;\n        for(int i = 0; i < len; i++) {\n            const int mid;\n            while(stack.peek() != -1 && strength[i] <= strength[stack.peek()]) {\n                mid = stack.pop();\n                int left = stack.peek() + 1;\n                int right = i - 1;\n                \n                int n = (mid - left) + 1;\n                int t = (right - mid) + 1;\n                \n                long val = (1l * (1 + n) * (prefix[right + 2] - prefix[mid + 2]) + mod) % mod;\n                val -= (1l * (1 + t) * (prefix[mid + 1] - prefix[left]) + mod) % mod;\n                val *= strength[mid];\n                \n                ans += val;\n                ans %= mod;\n            }\n            \n            stack.push(i);\n        }\n        \n        int right = len - 1;\n        while(stack.peek() != -1) {\n            int mid = stack.pop();\n            int left = stack.peek() + 1;\n            \n            int n = (mid - left) + 1;\n            int t = (right - mid) + 1;\n\n            long val = (1l * (1 + n) * (prefix[right + 2] - prefix[mid + 1]) + mod) % mod;\n            val -= (1l * (1 + t) * (prefix[mid + 1] - prefix[left]) + mod) % mod;\n            val *= strength[mid];\n\n            ans += val;\n            ans %= mod;\n        }\n        \n        return (int)((ans + mod) % mod);\n    }\n    \n    private long[] prefixSum(int[] strength, int len, int mod) {\n        long[] prefix = new long[len + 1];\n        \n        for(int i = 0; i < len; i++) {\n            prefix[i + 1] = prefix[i] + strength[i];\n        }\n        \n        long[] doublePrefix = new long[len + 2];\n        for(int i = 0; i <= len; i++) {\n            doublePrefix[i + 1] = (doublePrefix[i] + prefix[i]) % mod;\n        }\n\n        return doublePrefix;\n    }\n}\n"
    },
    {
        "slug": "relative-ranks",
        "description": "You are given an integer array score of size n, where score[i] is the score of the ith athlete in a competition. All the scores are guaranteed to be unique.\nThe athletes are placed based on their scores, where the 1st place athlete has the highest score, the 2nd place athlete has the 2nd highest score, and so on. The placement of each athlete determines their rank:\n\nThe 1st place athlete's rank is \"Gold Medal\".\nThe 2nd place athlete's rank is \"Silver Medal\".\nThe 3rd place athlete's rank is \"Bronze Medal\".\nFor the 4th place to the nth place athlete, their rank is their placement number (i.e., the xth place athlete's rank is \"x\").\n\nReturn an array answer of size n where answer[i] is the rank of the ith athlete.",
        "examples": [
            "Input: score = [5,4,3,2,1]\nOutput: [\"Gold Medal\",\"Silver Medal\",\"Bronze Medal\",\"4\",\"5\"]\nExplanation: The placements are [1st, 2nd, 3rd, 4th, 5th].",
            "Input: score = [10,3,8,9,4]\nOutput: [\"Gold Medal\",\"5\",\"Bronze Medal\",\"Silver Medal\",\"4\"]\nExplanation: The placements are [1st, 5th, 3rd, 2nd, 4th]."
        ],
        "constraints": "n == score.length\n1 <= n <= 104\n0 <= score[i] <= 106\nAll the values in score are unique.",
        "oracle_code": "class Solution {\n    public String[] findRelativeRanks(int[] score) {\n         int n=score.length;\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[b]-score[a]);\n        for(int i=0;i<n;i++) pq.add(i);\n      String[] ans = new String[n];\n                int i=1;\n        while(!pq.isEmpty()){\n            int idx=pq.poll();\n         if(i==1)   { ans[idx]=\"Gold Medal\"; i++;}\n         else if(i==2)   { ans[idx]=\"Silver Medal\"; i++;}\n         else if(i==3)   { ans[idx]=\"Bronze Medal\"; i++;}\n         else ans[idx]=Integer.toString(i++);\n        }\n        return ans;  \n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String[] findRelativeRanks(int[] score) {\\n         int n=score.length;\\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[b]-score[a]);\\n        for(int i=0;i<n;i++) pq.add(i);\\n      String[] ans = new String[n];\\n                int i=1;\\n        while(!pq.isEmpty()){\\n            int idx=pq.poll();\\n         if(i==1)   { ans[idx]=\"Gold Medal\"; i++;}\\n         else if(i==2)   { ans[idx]=\"Silver Medal\"; i++;}\\n         else if(i==3)   { ans[idx]=\"Bronze Medal\"; i++;}\\n         else ans[idx]=Integer.toString(i++);\\n        }\\n        return ans;  \\n    }\\n}\\n```",
        "level": "easy",
        "type": [
            "parentheses mismatch",
            "undefined keywords from other languages",
            "unclosed string",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\n    public String[] findRelativeRanks(int[] score) {\n         int n=score.length;\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[b]-score[a]);\n        for(int i=0;i<n;i++) pq.add(i);\n      String[] ans = new String[n];\n                int i=1;\n        while(!pq.isEmpty()){\n            int idx=pq.poll();\n         if(i=1)   { ans[idx]=\"Gold Medal; i++;}\n         elif(i=2)   { ans[idx]=\"Silver Medal; i++;}\n         else if(i=3)   { ans[idx]=\"Bronze Medal; i++;}\n         else ans[idx]=Integer.toString(i++);\n        }\n        return reorderArray(ans);  \n    }\n\n    private String[] reorderArray(String[] ranks){\n        \n    }\n}\n"
    },
    {
        "slug": "same-tree",
        "description": "Given the roots of two binary trees p and q, write a function to check if they are the same or not.\nTwo binary trees are considered the same if they are structurally identical, and the nodes have the same value.",
        "examples": [
            "Input: p = [1,2,3], q = [1,2,3]\nOutput: true",
            "Input: p = [1,2], q = [1,null,2]\nOutput: false",
            "Input: p = [1,2,1], q = [1,1,2]\nOutput: false"
        ],
        "constraints": "The number of nodes in both trees is in the range [0, 100].\n-104 <= Node.val <= 104",
        "oracle_code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n   \n    public boolean isSameTree(TreeNode p, TreeNode q) {\n     if (p == null && q == null) {\n            return true;\n        }\n        \n        if (p == null || q == null) {\n            return false;\n        }\n        \n        if (p.val != q.val) {\n            return false;\n        }\n        \n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n\n        \n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n   \\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n     if (p == null && q == null) {\\n            return true;\\n        }\\n        \\n        if (p == null || q == null) {\\n            return false;\\n        }\\n        \\n        if (p.val != q.val) {\\n            return false;\\n        }\\n        \\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n\\n        \\n    }\\n}\\n```",
        "level": "easy",
        "type": [
            "parentheses mismatch",
            "wrong comment mark",
            "undefined keywords from other languages",
            "undefined methods"
        ],
        "buggy_code": "\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n   \n    public boolean isSameTree(TreeNode p, TreeNode q) {\n     if (p == null && q == null {\n            return true;\n        }\n        \n        if (p == null || q == null) {\n            return false;\n        }\n        \n        if (p.val !== q.val) {\n            return false;\n        }\n        \n        return checkSubTree(p.left, q./*left*/) && checkSubTree(p.right, q.right);    \n    }\n}\n"
    },
    {
        "slug": "rotating-the-box",
        "description": "You are given an m x n matrix of characters box representing a side-view of a box. Each cell of the box is one of the following:\n\nA stone '#'\nA stationary obstacle '*'\nEmpty '.'\n\nThe box is rotated 90 degrees clockwise, causing some of the stones to fall due to gravity. Each stone falls down until it lands on an obstacle, another stone, or the bottom of the box. Gravity does not affect the obstacles' positions, and the inertia from the box's rotation does not affect the stones' horizontal positions.\nIt is guaranteed that each stone in box rests on an obstacle, another stone, or the bottom of the box.\nReturn an n x m matrix representing the box after the rotation described above.",
        "examples": [
            "Input: box = [[\"#\",\".\",\"#\"]]\r\nOutput: [[\".\"],\r\n\u00a0        [\"#\"],\r\n\u00a0        [\"#\"]]",
            "Input: box = [[\"#\",\".\",\"*\",\".\"],\r\n\u00a0             [\"#\",\"#\",\"*\",\".\"]]\r\nOutput: [[\"#\",\".\"],\r\n\u00a0        [\"#\",\"#\"],\r\n\u00a0        [\"*\",\"*\"],\r\n\u00a0        [\".\",\".\"]]",
            "Input: box = [[\"#\",\"#\",\"*\",\".\",\"*\",\".\"],\r\n\u00a0             [\"#\",\"#\",\"#\",\"*\",\".\",\".\"],\r\n\u00a0             [\"#\",\"#\",\"#\",\".\",\"#\",\".\"]]\r\nOutput: [[\".\",\"#\",\"#\"],\r\n\u00a0        [\".\",\"#\",\"#\"],\r\n\u00a0        [\"#\",\"#\",\"*\"],\r\n\u00a0        [\"#\",\"*\",\".\"],\r\n\u00a0        [\"#\",\".\",\"*\"],\r\n\u00a0        [\"#\",\".\",\".\"]]"
        ],
        "constraints": "m == box.length\nn == box[i].length\n1 <= m, n <= 500\nbox[i][j] is either '#', '*', or '.'.",
        "oracle_code": "// O(n^2) time | O(n^2) space\nclass Solution {\n    public char[][] rotateTheBox(char[][] box) {\n        int m = box.length;\n        int n = box[0].length;\n        char[][] matrix = new char[n][m];   \n        \n        turnBox(box, matrix, m, n); // turn the box clockwise 90 degree\n        \n        turnGravity(matrix, n, m); // cause that falling effect, since matrix turned so n,m\n        \n        return matrix;\n    }\n    \n    public void turnGravity(char[][] matrix, int m, int n){\n        for(int c = 0; c < n; c++){\n            int last  = m-1;\n            for(int r = m-1; r >= 0; r--){\n                char val =  matrix[r][c];\n                if(val == '.') continue;\n                if(val == '*') last = r-1;\n                if(val == '#') {\n                    matrix[r][c] = '.';\n                    matrix[last][c] = '#';\n                    last--;\n                }\n            }\n        }\n    }\n    \n    public void turnBox(char[][] box, char[][] matrix, int m, int n){\n\t// numbers represents sequence it would be copied\n\t//[4][1]\n\t//[5][2]\n\t//[6][3]\n        for(int i = 0, c = m-1; i < m; i++,c--){ // c: 4,3,2,1..\n            for(int j = 0, r = 0; j < n; j++, r++){ // r:0,1,2,3..\n               matrix[r][c] = box[i][j];\n            }\n        }\n    }\n}",
        "content": "**So idea here is**\\n1. First turn 90 degree\\n2. Make things fall\\n\\n```\\n// O(n^2) time | O(n^2) space\\nclass Solution {\\n    public char[][] rotateTheBox(char[][] box) {\\n        int m = box.length;\\n        int n = box[0].length;\\n        char[][] matrix = new char[n][m];   \\n        \\n        turnBox(box, matrix, m, n); // turn the box clockwise 90 degree\\n        \\n        turnGravity(matrix, n, m); // cause that falling effect, since matrix turned so n,m\\n        \\n        return matrix;\\n    }\\n    \\n    public void turnGravity(char[][] matrix, int m, int n){\\n        for(int c = 0; c < n; c++){\\n            int last  = m-1;\\n            for(int r = m-1; r >= 0; r--){\\n                char val =  matrix[r][c];\\n                if(val == \\'.\\') continue;\\n                if(val == \\'*\\') last = r-1;\\n                if(val == \\'#\\') {\\n                    matrix[r][c] = \\'.\\';\\n                    matrix[last][c] = \\'#\\';\\n                    last--;\\n                }\\n            }\\n        }\\n    }\\n    \\n    public void turnBox(char[][] box, char[][] matrix, int m, int n){\\n\\t// numbers represents sequence it would be copied\\n\\t//[4][1]\\n\\t//[5][2]\\n\\t//[6][3]\\n        for(int i = 0, c = m-1; i < m; i++,c--){ // c: 4,3,2,1..\\n            for(int j = 0, r = 0; j < n; j++, r++){ // r:0,1,2,3..\\n               matrix[r][c] = box[i][j];\\n            }\\n        }\\n    }\\n}\\n```",
        "level": "medium",
        "type": [
            "== and = confusion",
            "colon missing",
            "other error",
            "wrong comment mark"
        ],
        "buggy_code": "\n// O(n^2) time | O(n^2) space\nclass Solution {\n    public char[][] rotateTheBox(char[][] box) {\n        int m = box.length;\n        int n = box[0].length;\n        char[][] matrix = new char[n][m]   \n        \n        turnBox(box, matrix, m, n); // turn the box clockwise 90 degree\n        \n        turnGravity(matrix, n, m); ' cause that falling effect, since matrix turned so n,m\n        \n        return matrix;\n    }\n    \n    public void turnGravity(char[][] matrix, int m, int n){\n        for(int c = 0; c < n; c++){\n            int last  = m-1;\n            for(int r = m-1; r >= 0; r--){\n                char val =  matrix[r][c];\n                if(val == '.') continue;\n                if(val = '*') last = r-1;  \n                if(val == '#') {\n                    matrix[r][c] = '.';\n                    matrix[last][c] = '#';\n                }\n            }\n        }\n    }\n    \n    public void turnBox(char[][] box, char[][] matrix, int m, int n){\n              for(int i = 0, c = m-1; i < m; i++,c--){ // c: 4,3,2,1..\n            for(int j = 0, r = 0; j < n; j++, r++){ // r:0,1,2,3..\n               matrix[r][1] = box[i][j];\n            }\n        }\n    }\n}\n"
    },
    {
        "slug": "minimum-score-triangulation-of-polygon",
        "description": "You have a convex n-sided polygon where each vertex has an integer value. You are given an integer array values where values[i] is the value of the ith vertex (i.e., clockwise order).\nYou will triangulate the polygon into n - 2 triangles. For each triangle, the value of that triangle is the product of the values of its vertices, and the total score of the triangulation is the sum of these values over all n - 2 triangles in the triangulation.\nReturn the smallest possible total score that you can achieve with some triangulation of the polygon.",
        "examples": [
            "Input: values = [1,2,3]\nOutput: 6\nExplanation: The polygon is already triangulated, and the score of the only triangle is 6.",
            "Input: values = [3,7,4,5]\nOutput: 144\nExplanation: There are two triangulations, with possible scores: 3*7*5 + 4*5*7 = 245, or 3*4*5 + 3*4*7 = 144.\nThe minimum score is 144.",
            "Input: values = [1,3,1,4,1,5]\nOutput: 13\nExplanation: The minimum score triangulation has score 1*1*3 + 1*1*4 + 1*1*5 + 1*1*1 = 13."
        ],
        "constraints": "n == values.length\n3 <= n <= 50\n1 <= values[i] <= 100",
        "oracle_code": "class Solution {\n    int[][] dp;\n    public int minScoreTriangulation(int[] values) {\n        int l=values.length;\n        dp = new int[l][l];\n        for(int[] i : dp) Arrays.fill(i,-1);\n        return solve(values,1,l-1); \n    }\n\n    public int solve(int[] values, int i,int j)\n    {\n        if(i>=j) return 0;\n        if(dp[i][j]!=-1) return dp[i][j];\n        int min=Integer.MAX_VALUE;\n        for(int k=i;k<j;k++)\n        {\n            int temp=solve(values,i,k)+solve(values,k+1,j)+\n                        values[i-1]*values[k]*values[j];\n            min=Math.min(min,temp);\n        }\n\n        return dp[i][j]=min;\n    }\n}",
        "content": "\\n# Complexity\\n- Time complexity: n^2\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: n^2\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int[][] dp;\\n    public int minScoreTriangulation(int[] values) {\\n        int l=values.length;\\n        dp = new int[l][l];\\n        for(int[] i : dp) Arrays.fill(i,-1);\\n        return solve(values,1,l-1); \\n    }\\n\\n    public int solve(int[] values, int i,int j)\\n    {\\n        if(i>=j) return 0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int min=Integer.MAX_VALUE;\\n        for(int k=i;k<j;k++)\\n        {\\n            int temp=solve(values,i,k)+solve(values,k+1,j)+\\n                        values[i-1]*values[k]*values[j];\\n            min=Math.min(min,temp);\\n        }\\n\\n        return dp[i][j]=min;\\n    }\\n}\\n```",
        "level": "medium",
        "type": [
            "variable value error",
            "parentheses mismatch",
            "colon missing",
            "wrong comment mark"
        ],
        "buggy_code": "\nclass Solution {\n    int[][] dp;\n    public int minScoreTriangulation(int[] values) {\n        int l=values.length;\n        dp = new int[l][l];\n        for int[] i : dp) Arrays.fill(i,-1);\n       0 \n    }\n\n    public int solve(int[] values, int i,int j)\n    {\n        if(i>=j) return 0;\n        if(dp[i][j]!=-1) return dp[i][j];\n        int min=Integer.MAX_VALUE;\n        for(int k=i;k<j;k++)\n        {\n            int temp=solve(values,i,k)+solve(values,k+1,j)\n                        values[i-1]*values[k]*values[j];\n            min=Math.min(min,temp);\n        }\n\n        return dp[i][j]=min;\n    }\n}\n"
    },
    {
        "slug": "count-negative-numbers-in-a-sorted-matrix",
        "description": "Given a m x n matrix grid which is sorted in non-increasing order both row-wise and column-wise, return the number of negative numbers in grid.",
        "examples": [
            "Input: grid = [[4,3,2,-1],[3,2,1,-1],[1,1,-1,-2],[-1,-1,-2,-3]]\nOutput: 8\nExplanation: There are 8 negatives number in the matrix.",
            "Input: grid = [[3,2],[1,0]]\nOutput: 0"
        ],
        "constraints": "m == grid.length\nn == grid[i].length\n1 <= m, n <= 100\n-100 <= grid[i][j] <= 100",
        "oracle_code": "class Solution:\n    def countNegatives(self, grid: List[List[int]]) -> int:\n        ROWS, COLS = len(grid), len(grid[0])\n        negatives = 0\n        col = 0\n        for row in range(ROWS - 1, -1, -1):\n            while col < COLS and grid[row][col] >= 0:\n                col += 1\n            negatives += COLS - col\n        return negatives",
        "content": "# Intuition\\nThe key idea is to take advantage of the sorted nature of the matrix, where both the rows and columns are sorted in non-increasing order. This means that once we find a negative number in a row, all the following numbers in that row will also be negative. Similarly, if a cell at the top of a column is negative, all the cells below it in that column will also be negative.\\n\\n# Approach\\nNegative numbers will form a staircase. So we start from the bottom-left, and follow along the staircase. For each row, we find the edge of the staircase, add all the count of elements to the right to the answer, and then move up a row and repeat.\\n\\n# Complexity\\n- Time complexity: O(m + n) - We visit each row and column at most once.\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def countNegatives(self, grid: List[List[int]]) -> int:\\n        ROWS, COLS = len(grid), len(grid[0])\\n        negatives = 0\\n        col = 0\\n        for row in range(ROWS - 1, -1, -1):\\n            while col < COLS and grid[row][col] >= 0:\\n                col += 1\\n            negatives += COLS - col\\n        return negatives\\n\\n```\\n\\n# Get Faster Interview Prep Results with Top Algos\\nWe all know how time-consuming it is to prepare for interviews and how frustratingly difficult it is to improve. We made **Top Algos** - a tool recommends the perfect algorithm problem based on your current skill level to help you improve the fastest in the shortest amount of time. Top Algos is your personalized coach that learns your skill level and finds the best problem you need to solve to improve.\\n\\nThe beta version of the product is available for **free** right now! You can sign up at https://topalgos.xyz/.",
        "level": "easy",
        "type": [
            "operation error",
            "colon missing",
            "undefined objects",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution:\n    def countNegatives(self, grid: List[List[int]]) -> int:\n        ROWS, COLS = len(grid), len(undefinedGridVar[0])\n        negatives = 0\n        for row in range(ROWS - 1, -1, -1):\n            col = 0\n            while col < COLS and grid[row][col] >= 0:\n                col += 1\n            negatives += COLS\n        return negatives\n\n    def undefinedMethod(self):\n        self.countPositives(grid)\n"
    },
    {
        "slug": "rotating-the-box",
        "description": "You are given an m x n matrix of characters box representing a side-view of a box. Each cell of the box is one of the following:\n\nA stone '#'\nA stationary obstacle '*'\nEmpty '.'\n\nThe box is rotated 90 degrees clockwise, causing some of the stones to fall due to gravity. Each stone falls down until it lands on an obstacle, another stone, or the bottom of the box. Gravity does not affect the obstacles' positions, and the inertia from the box's rotation does not affect the stones' horizontal positions.\nIt is guaranteed that each stone in box rests on an obstacle, another stone, or the bottom of the box.\nReturn an n x m matrix representing the box after the rotation described above.",
        "examples": [
            "Input: box = [[\"#\",\".\",\"#\"]]\r\nOutput: [[\".\"],\r\n\u00a0        [\"#\"],\r\n\u00a0        [\"#\"]]",
            "Input: box = [[\"#\",\".\",\"*\",\".\"],\r\n\u00a0             [\"#\",\"#\",\"*\",\".\"]]\r\nOutput: [[\"#\",\".\"],\r\n\u00a0        [\"#\",\"#\"],\r\n\u00a0        [\"*\",\"*\"],\r\n\u00a0        [\".\",\".\"]]",
            "Input: box = [[\"#\",\"#\",\"*\",\".\",\"*\",\".\"],\r\n\u00a0             [\"#\",\"#\",\"#\",\"*\",\".\",\".\"],\r\n\u00a0             [\"#\",\"#\",\"#\",\".\",\"#\",\".\"]]\r\nOutput: [[\".\",\"#\",\"#\"],\r\n\u00a0        [\".\",\"#\",\"#\"],\r\n\u00a0        [\"#\",\"#\",\"*\"],\r\n\u00a0        [\"#\",\"*\",\".\"],\r\n\u00a0        [\"#\",\".\",\"*\"],\r\n\u00a0        [\"#\",\".\",\".\"]]"
        ],
        "constraints": "m == box.length\nn == box[i].length\n1 <= m, n <= 500\nbox[i][j] is either '#', '*', or '.'.",
        "oracle_code": "// O(n^2) time | O(n^2) space\nclass Solution {\n    public char[][] rotateTheBox(char[][] box) {\n        int m = box.length;\n        int n = box[0].length;\n        char[][] matrix = new char[n][m];   \n        \n        turnBox(box, matrix, m, n); // turn the box clockwise 90 degree\n        \n        turnGravity(matrix, n, m); // cause that falling effect, since matrix turned so n,m\n        \n        return matrix;\n    }\n    \n    public void turnGravity(char[][] matrix, int m, int n){\n        for(int c = 0; c < n; c++){\n            int last  = m-1;\n            for(int r = m-1; r >= 0; r--){\n                char val =  matrix[r][c];\n                if(val == '.') continue;\n                if(val == '*') last = r-1;\n                if(val == '#') {\n                    matrix[r][c] = '.';\n                    matrix[last][c] = '#';\n                    last--;\n                }\n            }\n        }\n    }\n    \n    public void turnBox(char[][] box, char[][] matrix, int m, int n){\n\t// numbers represents sequence it would be copied\n\t//[4][1]\n\t//[5][2]\n\t//[6][3]\n        for(int i = 0, c = m-1; i < m; i++,c--){ // c: 4,3,2,1..\n            for(int j = 0, r = 0; j < n; j++, r++){ // r:0,1,2,3..\n               matrix[r][c] = box[i][j];\n            }\n        }\n    }\n}",
        "content": "**So idea here is**\\n1. First turn 90 degree\\n2. Make things fall\\n\\n```\\n// O(n^2) time | O(n^2) space\\nclass Solution {\\n    public char[][] rotateTheBox(char[][] box) {\\n        int m = box.length;\\n        int n = box[0].length;\\n        char[][] matrix = new char[n][m];   \\n        \\n        turnBox(box, matrix, m, n); // turn the box clockwise 90 degree\\n        \\n        turnGravity(matrix, n, m); // cause that falling effect, since matrix turned so n,m\\n        \\n        return matrix;\\n    }\\n    \\n    public void turnGravity(char[][] matrix, int m, int n){\\n        for(int c = 0; c < n; c++){\\n            int last  = m-1;\\n            for(int r = m-1; r >= 0; r--){\\n                char val =  matrix[r][c];\\n                if(val == \\'.\\') continue;\\n                if(val == \\'*\\') last = r-1;\\n                if(val == \\'#\\') {\\n                    matrix[r][c] = \\'.\\';\\n                    matrix[last][c] = \\'#\\';\\n                    last--;\\n                }\\n            }\\n        }\\n    }\\n    \\n    public void turnBox(char[][] box, char[][] matrix, int m, int n){\\n\\t// numbers represents sequence it would be copied\\n\\t//[4][1]\\n\\t//[5][2]\\n\\t//[6][3]\\n        for(int i = 0, c = m-1; i < m; i++,c--){ // c: 4,3,2,1..\\n            for(int j = 0, r = 0; j < n; j++, r++){ // r:0,1,2,3..\\n               matrix[r][c] = box[i][j];\\n            }\\n        }\\n    }\\n}\\n```",
        "level": "medium",
        "type": [
            "== and = confusion",
            "colon missing",
            "wrong comment mark",
            "unclosed string"
        ],
        "buggy_code": "\n// O(n^2) time | O(n^2) space\nclass Solution {\n    public char[][] rotateTheBox(char[][] box) {\n        int m = box.length;\n        int n = box[0].length;\n        char[][] matrix = new char[n][m]   \n        \n        turnBox(box, matrix, m, n); // turn the box clockwise 90 degree\n        \n        turnGravity(matrix, n, m); ' cause that falling effect, since matrix turned so n,m\n        \n        return matrix;\n    }\n    \n    public void turnGravity(char[][] matrix, int m, int n){\n        for(int c = 0; c < n; c++){\n            int last  = m-1;\n            for(int r = m-1; r >= 0; r--){\n                char val =  matrix[r][c];\n                if(val == '.') continue;\n                if(val = '*') last = r-1;  \n                if(val == '#') {\n                    matrix[r][c] = '.';\n                    matrix[last][c] = '#;\n                    last--;\n                }\n            }\n        }\n    }\n    \n    public void turnBox(char[][] box, char[][] matrix, int m, int n){\n                    for(int i = 0, c = m-1; i < m; i++,c--){ // c: 4,3,2,1..\n            for(int j = 0, r = 0; j < n; j++, r++){ // r:0,1,2,3..\n               matrix[r][c] = box[i][j];\n            }\n        }\n    }\n}\n"
    },
    {
        "slug": "rotating-the-box",
        "description": "You are given an m x n matrix of characters box representing a side-view of a box. Each cell of the box is one of the following:\n\nA stone '#'\nA stationary obstacle '*'\nEmpty '.'\n\nThe box is rotated 90 degrees clockwise, causing some of the stones to fall due to gravity. Each stone falls down until it lands on an obstacle, another stone, or the bottom of the box. Gravity does not affect the obstacles' positions, and the inertia from the box's rotation does not affect the stones' horizontal positions.\nIt is guaranteed that each stone in box rests on an obstacle, another stone, or the bottom of the box.\nReturn an n x m matrix representing the box after the rotation described above.",
        "examples": [
            "Input: box = [[\"#\",\".\",\"#\"]]\r\nOutput: [[\".\"],\r\n\u00a0        [\"#\"],\r\n\u00a0        [\"#\"]]",
            "Input: box = [[\"#\",\".\",\"*\",\".\"],\r\n\u00a0             [\"#\",\"#\",\"*\",\".\"]]\r\nOutput: [[\"#\",\".\"],\r\n\u00a0        [\"#\",\"#\"],\r\n\u00a0        [\"*\",\"*\"],\r\n\u00a0        [\".\",\".\"]]",
            "Input: box = [[\"#\",\"#\",\"*\",\".\",\"*\",\".\"],\r\n\u00a0             [\"#\",\"#\",\"#\",\"*\",\".\",\".\"],\r\n\u00a0             [\"#\",\"#\",\"#\",\".\",\"#\",\".\"]]\r\nOutput: [[\".\",\"#\",\"#\"],\r\n\u00a0        [\".\",\"#\",\"#\"],\r\n\u00a0        [\"#\",\"#\",\"*\"],\r\n\u00a0        [\"#\",\"*\",\".\"],\r\n\u00a0        [\"#\",\".\",\"*\"],\r\n\u00a0        [\"#\",\".\",\".\"]]"
        ],
        "constraints": "m == box.length\nn == box[i].length\n1 <= m, n <= 500\nbox[i][j] is either '#', '*', or '.'.",
        "oracle_code": "// O(n^2) time | O(n^2) space\nclass Solution {\n    public char[][] rotateTheBox(char[][] box) {\n        int m = box.length;\n        int n = box[0].length;\n        char[][] matrix = new char[n][m];   \n        \n        turnBox(box, matrix, m, n); // turn the box clockwise 90 degree\n        \n        turnGravity(matrix, n, m); // cause that falling effect, since matrix turned so n,m\n        \n        return matrix;\n    }\n    \n    public void turnGravity(char[][] matrix, int m, int n){\n        for(int c = 0; c < n; c++){\n            int last  = m-1;\n            for(int r = m-1; r >= 0; r--){\n                char val =  matrix[r][c];\n                if(val == '.') continue;\n                if(val == '*') last = r-1;\n                if(val == '#') {\n                    matrix[r][c] = '.';\n                    matrix[last][c] = '#';\n                    last--;\n                }\n            }\n        }\n    }\n    \n    public void turnBox(char[][] box, char[][] matrix, int m, int n){\n\t// numbers represents sequence it would be copied\n\t//[4][1]\n\t//[5][2]\n\t//[6][3]\n        for(int i = 0, c = m-1; i < m; i++,c--){ // c: 4,3,2,1..\n            for(int j = 0, r = 0; j < n; j++, r++){ // r:0,1,2,3..\n               matrix[r][c] = box[i][j];\n            }\n        }\n    }\n}",
        "content": "**So idea here is**\\n1. First turn 90 degree\\n2. Make things fall\\n\\n```\\n// O(n^2) time | O(n^2) space\\nclass Solution {\\n    public char[][] rotateTheBox(char[][] box) {\\n        int m = box.length;\\n        int n = box[0].length;\\n        char[][] matrix = new char[n][m];   \\n        \\n        turnBox(box, matrix, m, n); // turn the box clockwise 90 degree\\n        \\n        turnGravity(matrix, n, m); // cause that falling effect, since matrix turned so n,m\\n        \\n        return matrix;\\n    }\\n    \\n    public void turnGravity(char[][] matrix, int m, int n){\\n        for(int c = 0; c < n; c++){\\n            int last  = m-1;\\n            for(int r = m-1; r >= 0; r--){\\n                char val =  matrix[r][c];\\n                if(val == \\'.\\') continue;\\n                if(val == \\'*\\') last = r-1;\\n                if(val == \\'#\\') {\\n                    matrix[r][c] = \\'.\\';\\n                    matrix[last][c] = \\'#\\';\\n                    last--;\\n                }\\n            }\\n        }\\n    }\\n    \\n    public void turnBox(char[][] box, char[][] matrix, int m, int n){\\n\\t// numbers represents sequence it would be copied\\n\\t//[4][1]\\n\\t//[5][2]\\n\\t//[6][3]\\n        for(int i = 0, c = m-1; i < m; i++,c--){ // c: 4,3,2,1..\\n            for(int j = 0, r = 0; j < n; j++, r++){ // r:0,1,2,3..\\n               matrix[r][c] = box[i][j];\\n            }\\n        }\\n    }\\n}\\n```",
        "level": "medium",
        "type": [
            "== and = confusion",
            "colon missing",
            "other error",
            "unclosed string"
        ],
        "buggy_code": "\n// O(n^2) time | O(n^2) space\nclass Solution {\n    public char[][] rotateTheBox(char[][] box) {\n        int m = box.length;\n        int n = box[0].length;\n        char[][] matrix = new char[n][m]   \n        \n        turnBox(box, matrix, m, n); // turn the box clockwise 90 degree\n        \n        turnGravity(matrix, n, m); // cause that falling effect, since matrix turned so n,m\n        \n        return matrix;\n    }\n    \n    public void turnGravity(char[][] matrix, int m, int n){\n        for(int c = 0; c < n; c++){\n            int last  = m-1;\n            for(int r = m-1; r >= 0; r--){\n                char val =  matrix[r][c];\n                if(val == '.') continue;\n                if(val = '*') last = r-1;  \n                if(val == '#') {\n                    matrix[r][c] = '.';\n                    matrix[last][c] = '#;\n                }\n            }\n        }\n    }\n    \n    public void turnBox(char[][] box, char[][] matrix, int m, int n){\n  \n      \n      \n      \n        for(int i = 0, c = m-1; i < m; i++,c--){ // c: 4,3,2,1..\n            for(int j = 0, r = 0; j < n; j++, r++){ // r:0,1,2,3..\n               matrix[r][1] = box[i][j];\n            }\n        }\n    }\n}\n"
    },
    {
        "slug": "intersection-of-multiple-arrays",
        "description": "Given a 2D integer array nums where nums[i] is a non-empty array of distinct positive integers, return the list of integers that are present in each array of nums sorted in ascending order.",
        "examples": [
            "Input: nums = [[3,1,2,4,5],[1,2,3,4],[3,4,5,6]]\nOutput: [3,4]\nExplanation: \nThe only integers present in each of nums[0] = [3,1,2,4,5], nums[1] = [1,2,3,4], and nums[2] = [3,4,5,6] are 3 and 4, so we return [3,4].",
            "Input: nums = [[1,2,3],[4,5,6]]\nOutput: []\nExplanation: \nThere does not exist any integer present both in nums[0] and nums[1], so we return an empty list []."
        ],
        "constraints": "1 <= nums.length <= 1000\n1 <= sum(nums[i].length) <= 1000\n1 <= nums[i][j] <= 1000\nAll the values of nums[i] are unique.",
        "oracle_code": "class Solution {\n    public List<Integer> intersection(int[][] nums) {\n        \n        List<Integer> ans = new ArrayList<>();\n        \n        int[] count  = new int[1001];\n        \n        for(int[] arr : nums){\n            for(int i : arr){\n                count[i]++;\n            }\n        }\n        \n       for(int i=0;i<count.length;i++){\n           if(count[i]==nums.length){\n               ans.add(i);\n           }\n       }\n        \n        return ans;\n    }\n}",
        "content": "```\\n\\nclass Solution {\\n    public List<Integer> intersection(int[][] nums) {\\n        \\n        List<Integer> ans = new ArrayList<>();\\n        \\n        int[] count  = new int[1001];\\n        \\n        for(int[] arr : nums){\\n            for(int i : arr){\\n                count[i]++;\\n            }\\n        }\\n        \\n       for(int i=0;i<count.length;i++){\\n           if(count[i]==nums.length){\\n               ans.add(i);\\n           }\\n       }\\n        \\n        return ans;\\n    }\\n}\\n\\n```",
        "level": "easy",
        "type": [
            "== and = confusion",
            "wrong comment mark",
            "indexing error",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\n    public List<Integer> intersection(int[][] nums) {\n        \n        List<Integer> ans = new ArrayList<>();\n        \n        int[] count  = new int[1001];\n        \n        i=0; i<=nums.length; i++){\n            fo(int j[i]){\n                count[j]++;\n            }\n        }\n        \n        for(int i=0;i<count.length;i++){\n           if(count[i]=nums.length){\n               ans.add(i);\n           }\n        myRandomUndefinedFunction();\n        \n        }\n        \n        return ans;\n    }\n}\n"
    },
    {
        "slug": "daily-temperatures",
        "description": "Given an array of integers temperatures represents the daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after the ith day to get a warmer temperature. If there is no future day for which this is possible, keep answer[i] == 0 instead.",
        "examples": [
            "Input: temperatures = [73,74,75,71,69,72,76,73]\nOutput: [1,1,4,2,1,1,0,0]",
            "Input: temperatures = [30,40,50,60]\nOutput: [1,1,1,0]",
            "Input: temperatures = [30,60,90]\nOutput: [1,1,0]"
        ],
        "constraints": "1 <=\u00a0temperatures.length <= 105\n30 <=\u00a0temperatures[i] <= 100",
        "oracle_code": "class Solution {\n    public int[] dailyTemperatures(int[] temperatures) {\n        \n        int[] arr = new int[temperatures.length]; \n        \n        ArrayDeque<int[]> st = new ArrayDeque<>(); \n        \n        int i=0, j=temperatures.length-1 ; \n        \n        while( j >= 0){\n            \n            if(st.size()==0){\n                arr[i++] = 0;\n            }\n            else  if (st.size()>0 && st.peek()[0]>temperatures[j])\n            {\n                arr[i++]=1;\n            } \n            else if (st.size()>0 && st.peek()[0]<=temperatures[j])\n            \n            {  while(st.size()>0 && st.peek()[0]<=temperatures[j]){\n                    st.pop();\n                    \n                }\n            if(st.size()==0){\n                arr[i++]=0;\n            }\n            else{\n                arr[i++]=st.peek()[1]-j;\n            }\n            } \n        st.push(new int[]{temperatures[j],j}); \n        j--;\n        }\n        \n      \n        int[] ans = new int[temperatures.length]; int k=0;\n        for(i=arr.length-1; i>=0; i--){\n            ans[k++]=arr[i];\n        }\n        return ans;\n    }\n}",
        "content": "```\\nclass Solution {\\n    public int[] dailyTemperatures(int[] temperatures) {\\n        \\n        int[] arr = new int[temperatures.length]; \\n        \\n        ArrayDeque<int[]> st = new ArrayDeque<>(); \\n        \\n        int i=0, j=temperatures.length-1 ; \\n        \\n        while( j >= 0){\\n            \\n            if(st.size()==0){\\n                arr[i++] = 0;\\n            }\\n            else  if (st.size()>0 && st.peek()[0]>temperatures[j])\\n            {\\n                arr[i++]=1;\\n            } \\n            else if (st.size()>0 && st.peek()[0]<=temperatures[j])\\n            \\n            {  while(st.size()>0 && st.peek()[0]<=temperatures[j]){\\n                    st.pop();\\n                    \\n                }\\n            if(st.size()==0){\\n                arr[i++]=0;\\n            }\\n            else{\\n                arr[i++]=st.peek()[1]-j;\\n            }\\n            } \\n        st.push(new int[]{temperatures[j],j}); \\n        j--;\\n        }\\n        \\n      \\n        int[] ans = new int[temperatures.length]; int k=0;\\n        for(i=arr.length-1; i>=0; i--){\\n            ans[k++]=arr[i];\\n        }\\n        return ans;\\n    }\\n}",
        "level": "medium",
        "type": [
            "variable value error",
            "wrong comment mark",
            "indexing error",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\n    public int[] dailyTemperatures(int[] temperatures) {\n        \n        int[] arr = new int[temperatures.length + 1]; \n        \n        ArrayDeque<int[]> st = new ArrayDeque<>(); \n        \n        int i=0, j=temperatures.length ; \n        \n        while( j >= 0){\n            \n            if(st.size()==0){\n                arr[i++] = 0;\n            }\n            else  if (st.size()>0 && st.peek()[0]>temperatures[j])\n            {\n                arr[i++]=1;\n            } \n            else if (st.size()>0 && st.peek()[0]<=temperatures[j])\n            \n            {  while(st.size()>0 && st.peek()[0]<=temperatures[j]){\n                    st.pop();\n                    \n                }\n            if(st.size()==0){\n                arr[i++]=0;\n            }\n            else{\n                arr[i++]=st.peek()[1]-j;\n            }\n            } \n        st.push(new int[]{temperatures[j],j}); \n        j--;\n        }\n        \n      \n        int[] ans = new int[temperatures.length]; int k=0;\n        for(i=arr.length-1/**/ + \n        doSomething();\n\n1; i>=0; i--){\n            ans[k++]=arr[i];\n        }\n        return ans;\n    }\n}\n"
    },
    {
        "slug": "relative-ranks",
        "description": "You are given an integer array score of size n, where score[i] is the score of the ith athlete in a competition. All the scores are guaranteed to be unique.\nThe athletes are placed based on their scores, where the 1st place athlete has the highest score, the 2nd place athlete has the 2nd highest score, and so on. The placement of each athlete determines their rank:\n\nThe 1st place athlete's rank is \"Gold Medal\".\nThe 2nd place athlete's rank is \"Silver Medal\".\nThe 3rd place athlete's rank is \"Bronze Medal\".\nFor the 4th place to the nth place athlete, their rank is their placement number (i.e., the xth place athlete's rank is \"x\").\n\nReturn an array answer of size n where answer[i] is the rank of the ith athlete.",
        "examples": [
            "Input: score = [5,4,3,2,1]\nOutput: [\"Gold Medal\",\"Silver Medal\",\"Bronze Medal\",\"4\",\"5\"]\nExplanation: The placements are [1st, 2nd, 3rd, 4th, 5th].",
            "Input: score = [10,3,8,9,4]\nOutput: [\"Gold Medal\",\"5\",\"Bronze Medal\",\"Silver Medal\",\"4\"]\nExplanation: The placements are [1st, 5th, 3rd, 2nd, 4th]."
        ],
        "constraints": "n == score.length\n1 <= n <= 104\n0 <= score[i] <= 106\nAll the values in score are unique.",
        "oracle_code": "class Solution {\n    public String[] findRelativeRanks(int[] score) {\n         int n=score.length;\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[b]-score[a]);\n        for(int i=0;i<n;i++) pq.add(i);\n      String[] ans = new String[n];\n                int i=1;\n        while(!pq.isEmpty()){\n            int idx=pq.poll();\n         if(i==1)   { ans[idx]=\"Gold Medal\"; i++;}\n         else if(i==2)   { ans[idx]=\"Silver Medal\"; i++;}\n         else if(i==3)   { ans[idx]=\"Bronze Medal\"; i++;}\n         else ans[idx]=Integer.toString(i++);\n        }\n        return ans;  \n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String[] findRelativeRanks(int[] score) {\\n         int n=score.length;\\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[b]-score[a]);\\n        for(int i=0;i<n;i++) pq.add(i);\\n      String[] ans = new String[n];\\n                int i=1;\\n        while(!pq.isEmpty()){\\n            int idx=pq.poll();\\n         if(i==1)   { ans[idx]=\"Gold Medal\"; i++;}\\n         else if(i==2)   { ans[idx]=\"Silver Medal\"; i++;}\\n         else if(i==3)   { ans[idx]=\"Bronze Medal\"; i++;}\\n         else ans[idx]=Integer.toString(i++);\\n        }\\n        return ans;  \\n    }\\n}\\n```",
        "level": "easy",
        "type": [
            "== and = confusion",
            "parentheses mismatch",
            "undefined keywords from other languages",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\n    public String[] findRelativeRanks(int[] score) {\n         int n=score.length;\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[b]-score[a]);\n        for(int i=0;i<n;i++) pq.add(i);\n        String[] ans = new String[n];\n        int i=1;\n        while(!pq.isEmpty()){\n            int idx=pq.poll();\n            if(i=1) { ans[idx]=\"Gold Medal\"; i++;} \n            elif(i=2) { ans[idx]=\"Silver Medal\"; i++;} \n            else if(i=3) { ans[idx]=\"Bronze Medal\"; i++;} \n            else ans[idx]=Integer.toString(i++);\n        }\n        return reorderArray(ans);  \n    }\n\n    private String[] reorderArray(String[] ranks){\n        \n    }\n}\n"
    },
    {
        "slug": "add-strings",
        "description": "Given two non-negative integers, num1 and num2 represented as string, return the sum of num1 and num2 as a string.\nYou must solve the problem without using any built-in library for handling large integers (such as BigInteger). You must also not convert the inputs to integers directly.",
        "examples": [
            "Input: num1 = \"11\", num2 = \"123\"\nOutput: \"134\"",
            "Input: num1 = \"456\", num2 = \"77\"\nOutput: \"533\"",
            "Input: num1 = \"0\", num2 = \"0\"\nOutput: \"0\""
        ],
        "constraints": "1 <= num1.length, num2.length <= 104\nnum1 and num2 consist of only digits.\nnum1 and num2 don't have any leading zeros except for the zero itself.",
        "oracle_code": "class Solution:\n    def addStrings(self, num1: str, num2: str) -> str:\n        sys.set_int_max_str_digits(10000)\n        nattu = int(num1)\n        babu = int(num2)\n        result = str(nattu+babu)\n        return result",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def addStrings(self, num1: str, num2: str) -> str:\\n        sys.set_int_max_str_digits(10000)\\n        nattu = int(num1)\\n        babu = int(num2)\\n        result = str(nattu+babu)\\n        return result\\n\\n```",
        "level": "easy",
        "type": [
            "variable value error",
            "undefined objects",
            "undefined keywords from other languages",
            "statement separation"
        ],
        "buggy_code": "\nclass Solution:\n    def addStrings(self, num1: str, num2: str) -> str:\n        undefined_sys_obj.set_int_max_str_digits(10000)\n        nattu = int(num1) babu = int(num1)\n        result = str(nattu+babu)\n        return result\n"
    },
    {
        "slug": "count-largest-group",
        "description": "You are given an integer n.\nEach number from 1 to n is grouped according to the sum of its digits.\nReturn the number of groups that have the largest size.",
        "examples": [
            "Input: n = 13\nOutput: 4\nExplanation: There are 9 groups in total, they are grouped according sum of its digits of numbers from 1 to 13:\n[1,10], [2,11], [3,12], [4,13], [5], [6], [7], [8], [9].\nThere are 4 groups with largest size.",
            "Input: n = 2\nOutput: 2\nExplanation: There are 2 groups [1], [2] of size 1."
        ],
        "constraints": "1 <= n <= 104",
        "oracle_code": "class Solution {\n    \n    int countDigits(int n) {\n        if(n == 0) return 0;\n        return n%10 + countDigits(n/10);\n    }\n    \n    public int countLargestGroup(int n) {\n        \n        ArrayList<Integer> list = new ArrayList(Collections.nCopies(37, 0));\n        \n        for(int i=1;i<=n;i++) {\n            int cd = countDigits(i); // count digits\n            list.set(cd, list.get(cd)+1); // update count\n        }\n        \n        return Collections.frequency(list, Collections.max(list));\n    }\n}",
        "content": "```\\nclass Solution {\\n    \\n    int countDigits(int n) {\\n        if(n == 0) return 0;\\n        return n%10 + countDigits(n/10);\\n    }\\n    \\n    public int countLargestGroup(int n) {\\n        \\n        ArrayList<Integer> list = new ArrayList(Collections.nCopies(37, 0));\\n        \\n        for(int i=1;i<=n;i++) {\\n            int cd = countDigits(i); // count digits\\n            list.set(cd, list.get(cd)+1); // update count\\n        }\\n        \\n        return Collections.frequency(list, Collections.max(list));\\n    }\\n}\\n```",
        "level": "easy",
        "type": [
            "operation error",
            "undefined objects",
            "undefined keywords from other languages",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\n\n    int countDigits(int n) {\n        if(n == 0) return 0;\n        return 1 + countDigits(n/10);\n    }\n    \n    public int countLargestGroup(int n) {\n        \n        ArrayList<Integer> list = nul []; \n        \n        for(int i=1;i<=n;i++) {\n            int cd = missingMethod(i); \n            list.set(cd, list.get(cd)+1); \n            }\n        \n       return Collections.frequency(list, Collections.max(list));\n    }\n}\n"
    },
    {
        "slug": "largest-number-after-digit-swaps-by-parity",
        "description": "You are given a positive integer num. You may swap any two digits of num that have the same parity (i.e. both odd digits or both even digits).\nReturn the largest possible value of num after any number of swaps.",
        "examples": [
            "Input: num = 1234\nOutput: 3412\nExplanation: Swap the digit 3 with the digit 1, this results in the number 3214.\nSwap the digit 2 with the digit 4, this results in the number 3412.\nNote that there may be other sequences of swaps but it can be shown that 3412 is the largest possible number.\nAlso note that we may not swap the digit 4 with the digit 1 since they are of different parities.",
            "Input: num = 65875\nOutput: 87655\nExplanation: Swap the digit 8 with the digit 6, this results in the number 85675.\nSwap the first digit 5 with the digit 7, this results in the number 87655.\nNote that there may be other sequences of swaps but it can be shown that 87655 is the largest possible number."
        ],
        "constraints": "1 <= num <= 109",
        "oracle_code": "class Solution {\n    public int largestInteger(int num) {\n        String numString = \"\"+ num;\n        List<Integer> even = new ArrayList<>();\n        List<Integer> odd = new ArrayList<>();\n        for(Character c : numString.toCharArray()){\n            int n = Character.getNumericValue(c);\n            if(n%2==0){\n                even.add(n);\n            }else{\n                odd.add(n);\n            }\n        }\n        Collections.sort(even, Collections.reverseOrder());\n        Collections.sort(odd, Collections.reverseOrder());\n        String res =\"\";\n        int one=0, two=0;\n        for(int i=0; i<numString.length(); i++){\n            int n = Character.getNumericValue(numString.charAt(i));\n            if(n%2==0){\n                res += even.get(one);\n                one++;\n            }else{\n                res += odd.get(two);\n                two++;\n            }\n        }\n        return Integer.parseInt(res);\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nused string and list to store the even and odd elements\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nconverted num in string then added all values from string to even and odd list as per its type;\\nthen sorted both string in desc order\\nas we check from the original string if got even number we will put max even number from even list and incresed even list pointer same for the odd number\\n\\nConverted result string to integer to get int res and returned it\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int largestInteger(int num) {\\n        String numString = \"\"+ num;\\n        List<Integer> even = new ArrayList<>();\\n        List<Integer> odd = new ArrayList<>();\\n        for(Character c : numString.toCharArray()){\\n            int n = Character.getNumericValue(c);\\n            if(n%2==0){\\n                even.add(n);\\n            }else{\\n                odd.add(n);\\n            }\\n        }\\n        Collections.sort(even, Collections.reverseOrder());\\n        Collections.sort(odd, Collections.reverseOrder());\\n        String res =\"\";\\n        int one=0, two=0;\\n        for(int i=0; i<numString.length(); i++){\\n            int n = Character.getNumericValue(numString.charAt(i));\\n            if(n%2==0){\\n                res += even.get(one);\\n                one++;\\n            }else{\\n                res += odd.get(two);\\n                two++;\\n            }\\n        }\\n        return Integer.parseInt(res);\\n    }\\n}\\n```",
        "level": "easy",
        "type": [
            "colon missing",
            "wrong comment mark",
            "undefined keywords from other languages",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution {\n    public int largestInteger(int num) {\n        String numString = \"\"+ num;\n        /*List<Integer> even = new ArrayList<>();*/\n        List<Integer> odd = new ArrayList<>();\n        for(Character c : numString.toCharArray())\n            int n = Character.getNumericValue(c);\n            if(n%2==0){\n                even.add(n);\n            }else{\n                odd.add(n);\n            }\n        }\n        Collections.sort(even, Collections.reverseOrder());\n        Collections.sort(odd, Collections.reverseOrder());\n        String res =\"\"\n        int one=0, two=0;\n        for(int i=0; i<numString.length(); i++){\n            int n = Character.getNumericValue(numString.charAt(i));\n            if(n%2==0){\n                res += even.get(one);\n                one++;\n            }else{\n                res += odd.get(two);\n                two++;\n            }\n        }\n        return Integer.parse_int(res);\n    }\n}\n"
    },
    {
        "slug": "remove-colored-pieces-if-both-neighbors-are-the-same-color",
        "description": "There are n pieces arranged in a line, and each piece is colored either by 'A' or by 'B'. You are given a string colors of length n where colors[i] is the color of the ith piece.\nAlice and Bob are playing a game where they take alternating turns removing pieces from the line. In this game, Alice moves first.\n\nAlice is only allowed to remove a piece colored 'A' if both its neighbors are also colored 'A'. She is not allowed to remove pieces that are colored 'B'.\nBob is only allowed to remove a piece colored 'B' if both its neighbors are also colored 'B'. He is not allowed to remove pieces that are colored 'A'.\nAlice and Bob cannot remove pieces from the edge of the line.\nIf a player cannot make a move on their turn, that player loses and the other player wins.\n\nAssuming Alice and Bob play optimally, return true if Alice wins, or return false if Bob wins.",
        "examples": [
            "Input: colors = \"AAABABB\"\nOutput: true\nExplanation:\nAAABABB -> AABABB\nAlice moves first.\nShe removes the second 'A' from the left since that is the only 'A' whose neighbors are both 'A'.\n\nNow it's Bob's turn.\nBob cannot make a move on his turn since there are no 'B's whose neighbors are both 'B'.\nThus, Alice wins, so return true.",
            "Input: colors = \"AA\"\nOutput: false\nExplanation:\nAlice has her turn first.\nThere are only two 'A's and both are on the edge of the line, so she cannot move on her turn.\nThus, Bob wins, so return false.",
            "Input: colors = \"ABBBBBBBAAA\"\nOutput: false\nExplanation:\nABBBBBBBAAA -> ABBBBBBBAA\nAlice moves first.\nHer only option is to remove the second to last 'A' from the right.\n\nABBBBBBBAA -> ABBBBBBAA\nNext is Bob's turn.\nHe has many options for which 'B' piece to remove. He can pick any.\n\nOn Alice's second turn, she has no more pieces that she can remove.\nThus, Bob wins, so return false."
        ],
        "constraints": "1 <=\u00a0colors.length <= 105\ncolors\u00a0consists of only the letters\u00a0'A'\u00a0and\u00a0'B'",
        "oracle_code": "class Solution {\n    public boolean winnerOfGame(String s) {\n        //count the triplets\nint n = s.length();\n    \n        int a=0;\n        int b=0;\n        \n        for(int i=1; i<n-1; i++)\n        {\n            if(s.charAt(i)=='A' && s.charAt(i-1)=='A' && s.charAt(i+1)=='A' )\n        a++;\n            else if(s.charAt(i)=='B' && s.charAt(i-1)=='B' && s.charAt(i+1)=='B' )\n        b++;\n            \n            }\n        if(a<=b)\n            return false;\n        else\n            return true;\n        \n    \n    }\n}",
        "content": "Idea behind it is that you need to count the number of triplets of both A and B \\nint a -> number of triplets of \\'A\\'\\nint b -> number of triplets of \\'B\\'\\nif(b>=a) BOB wins else Alice wins\\n\\nAs Alice has to make a move first so if she wants to win there should be atleast  1 more  triplets of A than B\\n\\nEg There are 4 triplets of both A and B  (a=4, b=4) \\n1. Alice removes 1 A (a=3, b=4)\\n2. Bob removes 1 B (a=3, b=3)\\n3. (a=2, b=3)\\n4. (a=2, b=2)\\n5. (a=1, b=2)\\n6. (a=1, b=1)\\n7. (a=0, b=1)\\n\\nClearly Alice will lose if both have same number of triplets\\nCode \\n\\n```\\nclass Solution {\\n    public boolean winnerOfGame(String s) {\\n        //count the triplets\\nint n = s.length();\\n    \\n        int a=0;\\n        int b=0;\\n        \\n        for(int i=1; i<n-1; i++)\\n        {\\n            if(s.charAt(i)==\\'A\\' && s.charAt(i-1)==\\'A\\' && s.charAt(i+1)==\\'A\\' )\\n        a++;\\n            else if(s.charAt(i)==\\'B\\' && s.charAt(i-1)==\\'B\\' && s.charAt(i+1)==\\'B\\' )\\n        b++;\\n            \\n            }\\n        if(a<=b)\\n            return false;\\n        else\\n            return true;\\n        \\n    \\n    }\\n}\\n```\\nIf this helped you then please UpVote\\nThanks\\n\\n\\n",
        "level": "medium",
        "type": [
            "== and = confusion",
            "conditional statement error",
            "wrong comment mark",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\n    public boolean winnerOfGame(String s) {\n        /count the triplets\n        int n = s.length();\n    \n        int a=0;\n        int b=0;\n\n        for(int i=1; i<n; i++) \n        {\n            if(s.charAt(i)=='A' && s.charAt(i-1)=='A'&&s.charAt(i+1)=='A')\n            a++;\n            else if(s.charAt(i)=='B' && s.charAt(i-1)=='B' && s.charAt(i+1)=='B' )\n                            b++;\n        }\n\n        if(a<=                b)\n        returnfalse;else\n return true;\n}\n =ValidaResult() }\n\n    private boolean ValidateResult() {\n        \n    \n}\n"
    },
    {
        "slug": "number-of-laser-beams-in-a-bank",
        "description": "Anti-theft security devices are activated inside a bank. You are given a 0-indexed binary string array bank representing the floor plan of the bank, which is an m x n 2D matrix. bank[i] represents the ith row, consisting of '0's and '1's. '0' means the cell is empty, while'1' means the cell has a security device.\nThere is one laser beam between any two security devices if both conditions are met:\n\nThe two devices are located on two different rows: r1 and r2, where r1 < r2.\nFor each row i where r1 < i < r2, there are no security devices in the ith row.\n\nLaser beams are independent, i.e., one beam does not interfere nor join with another.\nReturn the total number of laser beams in the bank.",
        "examples": [
            "Input: bank = [\"011001\",\"000000\",\"010100\",\"001000\"]\nOutput: 8\nExplanation: Between each of the following device pairs, there is one beam. In total, there are 8 beams:\n * bank[0][1] -- bank[2][1]\n * bank[0][1] -- bank[2][3]\n * bank[0][2] -- bank[2][1]\n * bank[0][2] -- bank[2][3]\n * bank[0][5] -- bank[2][1]\n * bank[0][5] -- bank[2][3]\n * bank[2][1] -- bank[3][2]\n * bank[2][3] -- bank[3][2]\nNote that there is no beam between any device on the 0th row with any on the 3rd row.\nThis is because the 2nd row contains security devices, which breaks the second condition.",
            "Input: bank = [\"000\",\"111\",\"000\"]\nOutput: 0\nExplanation: There does not exist two devices located on two different rows."
        ],
        "constraints": "m == bank.length\nn == bank[i].length\n1 <= m, n <= 500\nbank[i][j] is either '0' or '1'.",
        "oracle_code": "class Solution {\n    public int numberOfBeams(String[] bank) {\n        int prevLazer =0;\n        int ans =0;\n        for(String s:bank){\n            int curLazer = 0;\n            for(char c: s.toCharArray()){\n                if(c=='1'){\n                    curLazer++;\n                }\n            }\n            if(curLazer >0){\n                ans += (curLazer * prevLazer);\n                prevLazer = curLazer;\n            }\n        }\n        return ans;\n    }\n}",
        "content": "\\n# java Code\\n```\\nclass Solution {\\n    public int numberOfBeams(String[] bank) {\\n        int prevLazer =0;\\n        int ans =0;\\n        for(String s:bank){\\n            int curLazer = 0;\\n            for(char c: s.toCharArray()){\\n                if(c==\\'1\\'){\\n                    curLazer++;\\n                }\\n            }\\n            if(curLazer >0){\\n                ans += (curLazer * prevLazer);\\n                prevLazer = curLazer;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
        "level": "medium",
        "type": [
            "variable value error",
            "== and = confusion",
            "wrong comment mark",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution {\n    public int numberOfBeams(String[] bank) {\n        int prevLazer =0;\n        int ans =0;\n        for(String s:bank){\n            int curLazer = 0;\n            for(char c: s.toCharArray()){\n                if(c=='1){\n                    curLazer++;\n            }\n\n                ans += (curLazer * prevLazer);\n                prevLazer = curLazer;\n            }\n        = } return ans;\n    le{\n                prevLazer = 0;\n            \n        }\n        return \"The total number of beams is: \" + ans;\n    }\n}\n"
    },
    {
        "slug": "reverse-words-in-a-string",
        "description": "Given an input string s, reverse the order of the words.\nA word is defined as a sequence of non-space characters. The words in s will be separated by at least one space.\nReturn a string of the words in reverse order concatenated by a single space.\nNote that s may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words. Do not include any extra spaces.",
        "examples": [
            "Input: s = \"the sky is blue\"\nOutput: \"blue is sky the\"",
            "Input: s = \"  hello world  \"\nOutput: \"world hello\"\nExplanation: Your reversed string should not contain leading or trailing spaces.",
            "Input: s = \"a good   example\"\nOutput: \"example good a\"\nExplanation: You need to reduce multiple spaces between two words to a single space in the reversed string."
        ],
        "constraints": "1 <= s.length <= 104\ns contains English letters (upper-case and lower-case), digits, and spaces ' '.\nThere is at least one word in s.\n\n\u00a0\nFollow-up:\u00a0If the string data type is mutable in your language, can\u00a0you solve it\u00a0in-place\u00a0with\u00a0O(1)\u00a0extra space?",
        "oracle_code": "class Solution {\n    public String reverseWords(String s) {\n        StringBuilder ans = new StringBuilder();\n        for(int i=s.length()-1; i>=0; i--){\n            if(s.charAt(i)==' '){\n                continue;\n            }\n            int start=-1;\n            for(int y=i-1; y>=0; y--){\n                if(s.charAt(y)==' '){\n                    start=y;\n                    break;\n                }\n            }\n            ans.append(s.substring(start+1, i+1) + \" \");\n            i=start;\n        }\n        ans.deleteCharAt(ans.length()-1);\n        return ans.toString();\n    }\n}",
        "content": "# Approach\\n- Two Pointer Approach\\n- Using Trim and Split\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public String reverseWords(String s) {\\n        StringBuilder ans = new StringBuilder();\\n        for(int i=s.length()-1; i>=0; i--){\\n            if(s.charAt(i)==\\' \\'){\\n                continue;\\n            }\\n            int start=-1;\\n            for(int y=i-1; y>=0; y--){\\n                if(s.charAt(y)==\\' \\'){\\n                    start=y;\\n                    break;\\n                }\\n            }\\n            ans.append(s.substring(start+1, i+1) + \" \");\\n            i=start;\\n        }\\n        ans.deleteCharAt(ans.length()-1);\\n        return ans.toString();\\n    }\\n}\\n```\\n```\\nclass Solution {\\n    public String reverseWords(String s) {\\n        String[] temp = s.trim().split(\" \");\\n        StringBuilder ans = new StringBuilder();\\n        for(int i=temp.length-1; i>0; i--){\\n            if(temp[i]==\"\"){\\n                continue;\\n            }\\n            ans.append(temp[i]+\" \");\\n        }\\n        ans.append(temp[0]);\\n        return ans.toString();\\n    }\\n}\\n```",
        "level": "medium",
        "type": [
            "operation error",
            "== and = confusion",
            "wrong comment mark",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution {\n    public String reverseWords(String s) {\n        StringBuilder ans = new StringBuilder();\n        for(int i=s.length()-1; i>=0; i--){\n            /*if(s.charAt(i)==' '){\n                continue;\n            }*/\n            int start=-1;\n            for(int y=i-1; y>=0; y--){\n                if(s.charAt(y)==' '){\n                    start=y;\n                    break;\n                }\n            }\n            ans.append(s.substring(start+1, i) + \" \";\n            i=start;\n        }\n        ans.deleteCharAt(ans.length()-1);\n        return ans.toString()==s;\n    }\n}\n"
    },
    {
        "slug": "reverse-words-in-a-string",
        "description": "Given an input string s, reverse the order of the words.\nA word is defined as a sequence of non-space characters. The words in s will be separated by at least one space.\nReturn a string of the words in reverse order concatenated by a single space.\nNote that s may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words. Do not include any extra spaces.",
        "examples": [
            "Input: s = \"the sky is blue\"\nOutput: \"blue is sky the\"",
            "Input: s = \"  hello world  \"\nOutput: \"world hello\"\nExplanation: Your reversed string should not contain leading or trailing spaces.",
            "Input: s = \"a good   example\"\nOutput: \"example good a\"\nExplanation: You need to reduce multiple spaces between two words to a single space in the reversed string."
        ],
        "constraints": "1 <= s.length <= 104\ns contains English letters (upper-case and lower-case), digits, and spaces ' '.\nThere is at least one word in s.\n\n\u00a0\nFollow-up:\u00a0If the string data type is mutable in your language, can\u00a0you solve it\u00a0in-place\u00a0with\u00a0O(1)\u00a0extra space?",
        "oracle_code": "class Solution {\n    public String reverseWords(String s) {\n        StringBuilder ans = new StringBuilder();\n        for(int i=s.length()-1; i>=0; i--){\n            if(s.charAt(i)==' '){\n                continue;\n            }\n            int start=-1;\n            for(int y=i-1; y>=0; y--){\n                if(s.charAt(y)==' '){\n                    start=y;\n                    break;\n                }\n            }\n            ans.append(s.substring(start+1, i+1) + \" \");\n            i=start;\n        }\n        ans.deleteCharAt(ans.length()-1);\n        return ans.toString();\n    }\n}",
        "content": "# Approach\\n- Two Pointer Approach\\n- Using Trim and Split\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public String reverseWords(String s) {\\n        StringBuilder ans = new StringBuilder();\\n        for(int i=s.length()-1; i>=0; i--){\\n            if(s.charAt(i)==\\' \\'){\\n                continue;\\n            }\\n            int start=-1;\\n            for(int y=i-1; y>=0; y--){\\n                if(s.charAt(y)==\\' \\'){\\n                    start=y;\\n                    break;\\n                }\\n            }\\n            ans.append(s.substring(start+1, i+1) + \" \");\\n            i=start;\\n        }\\n        ans.deleteCharAt(ans.length()-1);\\n        return ans.toString();\\n    }\\n}\\n```\\n```\\nclass Solution {\\n    public String reverseWords(String s) {\\n        String[] temp = s.trim().split(\" \");\\n        StringBuilder ans = new StringBuilder();\\n        for(int i=temp.length-1; i>0; i--){\\n            if(temp[i]==\"\"){\\n                continue;\\n            }\\n            ans.append(temp[i]+\" \");\\n        }\\n        ans.append(temp[0]);\\n        return ans.toString();\\n    }\\n}\\n```",
        "level": "medium",
        "type": [
            "operation error",
            "== and = confusion",
            "undefined objects",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution {\n    public String reverseWords(String s) {\n        StringBuilder ans = new StringBuilder();\n        String str = null;\n        for(int i=s.length()-1; i>=str.length(); i--){\n            if(s.charAt(i)==' '){\n                continue;\n            }\n            int start=-1;\n            for(int y=i-1; y>=0; y--){\n                if(s.charAt(y)==' '){\n                    start=y;\n                    break;\n                }\n            }\n            ans.append(s.substring(start+1, i) + \" \";\n            i=start;\n        }\n        ans.deleteCharAt(ans.length()-1);\n        return ans.toString()==s;\n    }\n}\n"
    },
    {
        "slug": "minimum-number-of-swaps-to-make-the-string-balanced",
        "description": "You are given a 0-indexed string s of even length n. The string consists of exactly n / 2 opening brackets '[' and n / 2 closing brackets ']'.\nA string is called balanced if and only if:\n\nIt is the empty string, or\nIt can be written as AB, where both A and B are balanced strings, or\nIt can be written as [C], where C is a balanced string.\n\nYou may swap the brackets at any two indices any number of times.\nReturn the minimum number of swaps to make s balanced.",
        "examples": [
            "Input: s = \"][][\"\nOutput: 1\nExplanation: You can make the string balanced by swapping index 0 with index 3.\nThe resulting string is \"[[]]\".",
            "Input: s = \"]]][[[\"\nOutput: 2\nExplanation: You can do the following to make the string balanced:\n- Swap index 0 with index 4. s = \"[]][][\".\n- Swap index 1 with index 5. s = \"[[][]]\".\nThe resulting string is \"[[][]]\".",
            "Input: s = \"[]\"\nOutput: 0\nExplanation: The string is already balanced."
        ],
        "constraints": "n == s.length\n2 <= n <= 106\nn is even.\ns[i] is either '[' or ']'.\nThe number of opening brackets '[' equals n / 2, and the number of closing brackets ']' equals n / 2.",
        "oracle_code": "class Solution {\n    public int minSwaps(String s) {\n        return util1(s);\n    }\n    public int util1(String str) {\n        Stack<Character> s = new Stack<>();\n        for (int i = 0; i < str.length(); i++) {\n            if (str.charAt(i) == '[') {\n                s.push(str.charAt(i));\n            } else {\n                if (s.isEmpty() == false && s.peek() == '[') {\n                    s.pop();\n                } else {\n                    s.push(str.charAt(i));\n                }\n            }\n        }\n        double pairs = s.size() / 2;\n        double a = pairs / 2.0;\n        int ans = (int) Math.ceil(a);\n        return ans;\n    }\n}",
        "content": "the trick behind is fairly easy\\n\\nfor the number of pairs which are not correct, the amount of swaps required to make them correct is Math.ceil(a), where a is the number of pairs which are not correct.\\n\\nfor eg\\nfor 5 incorrect pairs, we need 3 swaps\\nfor 3 incorrect pairs, we need 2 swaps\\nfor 2 incorrect pairs, we need 1 swap\\n\\nso simply, \\nwe need to firstly write code to remove all the valid pairs, that ways only the pairs which are incorrect will be in the stack\\nthen we simply do the calculations.\\n\\nrest the code should be self explanatory.\\n\\n# Code\\n```\\nclass Solution {\\n    public int minSwaps(String s) {\\n        return util1(s);\\n    }\\n    public int util1(String str) {\\n        Stack<Character> s = new Stack<>();\\n        for (int i = 0; i < str.length(); i++) {\\n            if (str.charAt(i) == \\'[\\') {\\n                s.push(str.charAt(i));\\n            } else {\\n                if (s.isEmpty() == false && s.peek() == \\'[\\') {\\n                    s.pop();\\n                } else {\\n                    s.push(str.charAt(i));\\n                }\\n            }\\n        }\\n        double pairs = s.size() / 2;\\n        double a = pairs / 2.0;\\n        int ans = (int) Math.ceil(a);\\n        return ans;\\n    }\\n}\\n```\\nyou can check out my github repository where i am uploading famous interview questions topic wise with solutions.\\nlink-- https://github.com/Abhaydutt2003/DataStructureAndAlgoPractice \\nkindly upvote if you like my solution. you can ask doubts below.\\n    \\n",
        "level": "medium",
        "type": [
            "operation error",
            "indexing error",
            "unclosed string",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\n    public int minSwaps(String s) {\n        return util(\"s);\n    }\n    public int util1(String str) {\n        Stack<Character> s = new Stack<>();\n        for (int i = 0; i <= str.length(); i++) {\n            if (str.charAt(i) == '[') {\n                s.push(str.charAt(i));\n            } else {\n                if (s.isEmpty() == false && s.peek() == '[') {\n                    s.pop();\n                } else {\n                    s.push(str.charAt(i));\n                }\n            }\n        }\n        double pairs = s.size() / 2;\n        double a = pairs / 10.0;\n        int ans = (int) Math.ceil(a);\n        return ans;\n    }\n}\n"
    },
    {
        "slug": "relative-ranks",
        "description": "You are given an integer array score of size n, where score[i] is the score of the ith athlete in a competition. All the scores are guaranteed to be unique.\nThe athletes are placed based on their scores, where the 1st place athlete has the highest score, the 2nd place athlete has the 2nd highest score, and so on. The placement of each athlete determines their rank:\n\nThe 1st place athlete's rank is \"Gold Medal\".\nThe 2nd place athlete's rank is \"Silver Medal\".\nThe 3rd place athlete's rank is \"Bronze Medal\".\nFor the 4th place to the nth place athlete, their rank is their placement number (i.e., the xth place athlete's rank is \"x\").\n\nReturn an array answer of size n where answer[i] is the rank of the ith athlete.",
        "examples": [
            "Input: score = [5,4,3,2,1]\nOutput: [\"Gold Medal\",\"Silver Medal\",\"Bronze Medal\",\"4\",\"5\"]\nExplanation: The placements are [1st, 2nd, 3rd, 4th, 5th].",
            "Input: score = [10,3,8,9,4]\nOutput: [\"Gold Medal\",\"5\",\"Bronze Medal\",\"Silver Medal\",\"4\"]\nExplanation: The placements are [1st, 5th, 3rd, 2nd, 4th]."
        ],
        "constraints": "n == score.length\n1 <= n <= 104\n0 <= score[i] <= 106\nAll the values in score are unique.",
        "oracle_code": "class Solution {\n    public String[] findRelativeRanks(int[] score) {\n         int n=score.length;\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[b]-score[a]);\n        for(int i=0;i<n;i++) pq.add(i);\n      String[] ans = new String[n];\n                int i=1;\n        while(!pq.isEmpty()){\n            int idx=pq.poll();\n         if(i==1)   { ans[idx]=\"Gold Medal\"; i++;}\n         else if(i==2)   { ans[idx]=\"Silver Medal\"; i++;}\n         else if(i==3)   { ans[idx]=\"Bronze Medal\"; i++;}\n         else ans[idx]=Integer.toString(i++);\n        }\n        return ans;  \n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String[] findRelativeRanks(int[] score) {\\n         int n=score.length;\\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[b]-score[a]);\\n        for(int i=0;i<n;i++) pq.add(i);\\n      String[] ans = new String[n];\\n                int i=1;\\n        while(!pq.isEmpty()){\\n            int idx=pq.poll();\\n         if(i==1)   { ans[idx]=\"Gold Medal\"; i++;}\\n         else if(i==2)   { ans[idx]=\"Silver Medal\"; i++;}\\n         else if(i==3)   { ans[idx]=\"Bronze Medal\"; i++;}\\n         else ans[idx]=Integer.toString(i++);\\n        }\\n        return ans;  \\n    }\\n}\\n```",
        "level": "easy",
        "type": [
            "== and = confusion",
            "undefined objects",
            "unclosed string",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\n    public String[] findRelativeRanks(int[] score) {\n         int n=score.length;\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[b]-score[a]);\n        for(int i=0;i<n;i++) pq.add(i);\n        String[] ans = null;\n        int i=1;\n        while(!pq.isEmpty()){\n            int idx=pq.poll();\n            if(i=1) { ans[idx]=\"Gold Medal; i++;} \n            else if(i=2) { ans[idx]=\"Silver Medal; i++;} \n            else if(i=3) { ans[idx]=\"Bronze Medal; i++;} \n            else ans[idx]=Integer.toString(i++);\n        }\n        return reorderArray(ans);  \n    }\n\n    private String[] reorderArray(String[] ranks){\n        \n    }\n}\n"
    },
    {
        "slug": "relative-ranks",
        "description": "You are given an integer array score of size n, where score[i] is the score of the ith athlete in a competition. All the scores are guaranteed to be unique.\nThe athletes are placed based on their scores, where the 1st place athlete has the highest score, the 2nd place athlete has the 2nd highest score, and so on. The placement of each athlete determines their rank:\n\nThe 1st place athlete's rank is \"Gold Medal\".\nThe 2nd place athlete's rank is \"Silver Medal\".\nThe 3rd place athlete's rank is \"Bronze Medal\".\nFor the 4th place to the nth place athlete, their rank is their placement number (i.e., the xth place athlete's rank is \"x\").\n\nReturn an array answer of size n where answer[i] is the rank of the ith athlete.",
        "examples": [
            "Input: score = [5,4,3,2,1]\nOutput: [\"Gold Medal\",\"Silver Medal\",\"Bronze Medal\",\"4\",\"5\"]\nExplanation: The placements are [1st, 2nd, 3rd, 4th, 5th].",
            "Input: score = [10,3,8,9,4]\nOutput: [\"Gold Medal\",\"5\",\"Bronze Medal\",\"Silver Medal\",\"4\"]\nExplanation: The placements are [1st, 5th, 3rd, 2nd, 4th]."
        ],
        "constraints": "n == score.length\n1 <= n <= 104\n0 <= score[i] <= 106\nAll the values in score are unique.",
        "oracle_code": "class Solution {\n    public String[] findRelativeRanks(int[] score) {\n         int n=score.length;\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[b]-score[a]);\n        for(int i=0;i<n;i++) pq.add(i);\n      String[] ans = new String[n];\n                int i=1;\n        while(!pq.isEmpty()){\n            int idx=pq.poll();\n         if(i==1)   { ans[idx]=\"Gold Medal\"; i++;}\n         else if(i==2)   { ans[idx]=\"Silver Medal\"; i++;}\n         else if(i==3)   { ans[idx]=\"Bronze Medal\"; i++;}\n         else ans[idx]=Integer.toString(i++);\n        }\n        return ans;  \n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String[] findRelativeRanks(int[] score) {\\n         int n=score.length;\\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[b]-score[a]);\\n        for(int i=0;i<n;i++) pq.add(i);\\n      String[] ans = new String[n];\\n                int i=1;\\n        while(!pq.isEmpty()){\\n            int idx=pq.poll();\\n         if(i==1)   { ans[idx]=\"Gold Medal\"; i++;}\\n         else if(i==2)   { ans[idx]=\"Silver Medal\"; i++;}\\n         else if(i==3)   { ans[idx]=\"Bronze Medal\"; i++;}\\n         else ans[idx]=Integer.toString(i++);\\n        }\\n        return ans;  \\n    }\\n}\\n```",
        "level": "easy",
        "type": [
            "operation error",
            "== and = confusion",
            "parentheses mismatch",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\n    public String[] findRelativeRanks(int[] score) {\n         int n = score.length;\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[a]-score[b]);\n        for(int i=0;i<n;i++) pq.add(i);\n          String[] ans = new String[n];\n        int i=1;\n        while(!pq.isEmpty()){\n            int idx=pq.poll();\n            if(i=1) { ans[idx]=\"Gold Medal\"; i++;} \n            else if(i=2) { ans[idx]=\"Silver Medal\"; i++;} \n            else if(i=3) { ans[idx]=\"Bronze Medal\"; i++;} \n            else ans[idx]=Integer.toString(i++);\n        }\n        return reorderArray(ans);  \n    }\n\n    private String[] reorderArray(String[] ranks){\n        \n    }\n}\n"
    },
    {
        "slug": "remove-colored-pieces-if-both-neighbors-are-the-same-color",
        "description": "There are n pieces arranged in a line, and each piece is colored either by 'A' or by 'B'. You are given a string colors of length n where colors[i] is the color of the ith piece.\nAlice and Bob are playing a game where they take alternating turns removing pieces from the line. In this game, Alice moves first.\n\nAlice is only allowed to remove a piece colored 'A' if both its neighbors are also colored 'A'. She is not allowed to remove pieces that are colored 'B'.\nBob is only allowed to remove a piece colored 'B' if both its neighbors are also colored 'B'. He is not allowed to remove pieces that are colored 'A'.\nAlice and Bob cannot remove pieces from the edge of the line.\nIf a player cannot make a move on their turn, that player loses and the other player wins.\n\nAssuming Alice and Bob play optimally, return true if Alice wins, or return false if Bob wins.",
        "examples": [
            "Input: colors = \"AAABABB\"\nOutput: true\nExplanation:\nAAABABB -> AABABB\nAlice moves first.\nShe removes the second 'A' from the left since that is the only 'A' whose neighbors are both 'A'.\n\nNow it's Bob's turn.\nBob cannot make a move on his turn since there are no 'B's whose neighbors are both 'B'.\nThus, Alice wins, so return true.",
            "Input: colors = \"AA\"\nOutput: false\nExplanation:\nAlice has her turn first.\nThere are only two 'A's and both are on the edge of the line, so she cannot move on her turn.\nThus, Bob wins, so return false.",
            "Input: colors = \"ABBBBBBBAAA\"\nOutput: false\nExplanation:\nABBBBBBBAAA -> ABBBBBBBAA\nAlice moves first.\nHer only option is to remove the second to last 'A' from the right.\n\nABBBBBBBAA -> ABBBBBBAA\nNext is Bob's turn.\nHe has many options for which 'B' piece to remove. He can pick any.\n\nOn Alice's second turn, she has no more pieces that she can remove.\nThus, Bob wins, so return false."
        ],
        "constraints": "1 <=\u00a0colors.length <= 105\ncolors\u00a0consists of only the letters\u00a0'A'\u00a0and\u00a0'B'",
        "oracle_code": "class Solution {\n    public boolean winnerOfGame(String s) {\n        //count the triplets\nint n = s.length();\n    \n        int a=0;\n        int b=0;\n        \n        for(int i=1; i<n-1; i++)\n        {\n            if(s.charAt(i)=='A' && s.charAt(i-1)=='A' && s.charAt(i+1)=='A' )\n        a++;\n            else if(s.charAt(i)=='B' && s.charAt(i-1)=='B' && s.charAt(i+1)=='B' )\n        b++;\n            \n            }\n        if(a<=b)\n            return false;\n        else\n            return true;\n        \n    \n    }\n}",
        "content": "Idea behind it is that you need to count the number of triplets of both A and B \\nint a -> number of triplets of \\'A\\'\\nint b -> number of triplets of \\'B\\'\\nif(b>=a) BOB wins else Alice wins\\n\\nAs Alice has to make a move first so if she wants to win there should be atleast  1 more  triplets of A than B\\n\\nEg There are 4 triplets of both A and B  (a=4, b=4) \\n1. Alice removes 1 A (a=3, b=4)\\n2. Bob removes 1 B (a=3, b=3)\\n3. (a=2, b=3)\\n4. (a=2, b=2)\\n5. (a=1, b=2)\\n6. (a=1, b=1)\\n7. (a=0, b=1)\\n\\nClearly Alice will lose if both have same number of triplets\\nCode \\n\\n```\\nclass Solution {\\n    public boolean winnerOfGame(String s) {\\n        //count the triplets\\nint n = s.length();\\n    \\n        int a=0;\\n        int b=0;\\n        \\n        for(int i=1; i<n-1; i++)\\n        {\\n            if(s.charAt(i)==\\'A\\' && s.charAt(i-1)==\\'A\\' && s.charAt(i+1)==\\'A\\' )\\n        a++;\\n            else if(s.charAt(i)==\\'B\\' && s.charAt(i-1)==\\'B\\' && s.charAt(i+1)==\\'B\\' )\\n        b++;\\n            \\n            }\\n        if(a<=b)\\n            return false;\\n        else\\n            return true;\\n        \\n    \\n    }\\n}\\n```\\nIf this helped you then please UpVote\\nThanks\\n\\n\\n",
        "level": "medium",
        "type": [
            "== and = confusion",
            "wrong comment mark",
            "unclosed string",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\n    public boolean winnerOfGame(String s) {\n        /count the triplets\n        int n = s.length();\n    \n        int a=0;\n        int b=0;\n\n        for(int i=1; i<n-1; i++) {\n            if(s.charAt(i)=='A' && s.charAt(i-1)=='A' && s.charAt(i+1)=='A' )\n                a++;\n            else if(s.charAt(i)=='B' && s.charAt(i-1)==''B'' && s.charAt(i+1)=='B' )\n                b++;\n        }\n        if(a == b)\n            return false;\n        else\n            return ValidateResult();}\n\n    private boolean ValidateResult() {\n        \n    }\n}\n"
    },
    {
        "slug": "maximum-binary-tree",
        "description": "You are given an integer array nums with no duplicates. A maximum binary tree can be built recursively from nums using the following algorithm:\n\nCreate a root node whose value is the maximum value in nums.\nRecursively build the left subtree on the subarray prefix to the left of the maximum value.\nRecursively build the right subtree on the subarray suffix to the right of the maximum value.\n\nReturn the maximum binary tree built from nums.",
        "examples": [
            "Input: nums = [3,2,1,6,0,5]\nOutput: [6,3,5,null,2,0,null,null,1]\nExplanation: The recursive calls are as follow:\n- The largest value in [3,2,1,6,0,5] is 6. Left prefix is [3,2,1] and right suffix is [0,5].\n    - The largest value in [3,2,1] is 3. Left prefix is [] and right suffix is [2,1].\n        - Empty array, so no child.\n        - The largest value in [2,1] is 2. Left prefix is [] and right suffix is [1].\n            - Empty array, so no child.\n            - Only one element, so child is a node with value 1.\n    - The largest value in [0,5] is 5. Left prefix is [0] and right suffix is [].\n        - Only one element, so child is a node with value 0.\n        - Empty array, so no child.",
            "Input: nums = [3,2,1]\nOutput: [3,null,2,null,1]"
        ],
        "constraints": "1 <= nums.length <= 1000\n0 <= nums[i] <= 1000\nAll integers in nums are unique.",
        "oracle_code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public TreeNode constructMaximumBinaryTree(int[] nums) {\n        TreeNode root= construct(nums,0,nums.length-1);\n        return root;\n    }\n    private static TreeNode construct(int arr[], int s, int e){\n        if(s>e)return null;\n        if(s==e) return new TreeNode(arr[s]);\n\n        int idx=findMax(arr,s,e);\n        TreeNode root=new TreeNode(arr[idx]);\n        root.left=construct(arr,s,idx-1);\n        root.right=construct(arr,idx+1,e);\n\n        return root;\n    }\n\n    private static int findMax(int arr[], int s, int e){\n        int max=Integer.MIN_VALUE;\n        int idx=-1;\n        for(int i=s;i<=e; i++)\n        {\n            if(arr[i]>max){\n                max=arr[i];\n                idx=i;\n            }\n        }\n         return idx;\n    }\n\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe code implements a solution to construct a maximum binary tree from an input array nums. The maximum binary tree is a binary tree where the root node has the maximum value in the array, and the left and right subtrees of the root are recursively constructed maximum binary trees from the elements to the left and right of the maximum value.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe code uses a recursive approach to construct the maximum binary tree. It defines two helper functions: constructMaximumBinaryTree and construct.\\n\\n1. constructMaximumBinaryTree function:\\n\\nThis is the main entry point of the code.\\nIt takes the input array nums as a parameter and returns the root of the constructed maximum binary tree.\\nInside this function, it calls the construct function, passing the nums array and the range from 0 to nums.length - 1.\\n2. construct function:\\n\\nThis function takes three parameters: the input array arr, the start index s, and the end index e of the current range.\\nIt constructs the maximum binary tree for the current range of elements in the array.\\nIt first checks if s is greater than e. If so, it means there are no elements in the current range, so it returns null.\\nIf s is equal to e, it means there is only one element in the current range. In this case, it creates a new TreeNode with the value of arr[s] and returns it.\\nIf there are more than one element in the current range, it finds the index of the maximum element using the findMax helper function.\\nIt creates a new TreeNode with the maximum value (arr[idx]) as the root.\\nIt recursively calls the construct function for the left subarray (from s to idx - 1) and assigns the returned value as the left child of the root.\\nIt recursively calls the construct function for the right subarray (from idx + 1 to e) and assigns the returned value as the right child of the root.\\nFinally, it returns the constructed root node of the maximum binary tree for the current range.\\n3. findMax function:\\n\\nThis helper function takes three parameters: the input array arr, the start index s, and the end index e of the current range.\\nIt iterates through the elements in the current range and finds the index of the maximum element.\\nIt initializes a variable max with the minimum integer value and idx with -1.\\nIt compares each element in the range with the current maximum value (max) and updates max and idx if a greater value is found.\\nFinally, it returns the index of the maximum element.\\nThe code uses recursion to divide the array into smaller subarrays and construct the maximum binary tree recursively. It constructs the root node based on the maximum value in the current range, assigns the left and right subtrees recursively, and returns the root node.\\n\\n# Complexity\\n- Time complexity: O(n^2) in worst case and O(n) in avg case.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe constructMaximumBinaryTree function calls the construct function, which performs a recursive construction of the maximum binary tree. The construct function divides the array into smaller subarrays and constructs the tree.\\nIn the worst case, each element in the array needs to be compared with every other element to find the maximum. This results in a time complexity of O(n^2), where n is the length of the nums array.\\nHowever, in the average case, the maximum element can be found in O(n) time. Therefore, the average time complexity of the construct function is O(n).\\nThe construct function is called recursively for each subarray, resulting in a total time complexity of O(n^2) in the worst case and O(n) in the average case.\\n\\n- Space complexity:  O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nThe space complexity is determined by the recursive calls and the stack space required for each call.\\nIn the worst case, when the construct function is called recursively for each subarray, the maximum stack depth is equal to the height of the binary tree. In the worst case, the height of the binary tree can be equal to n, resulting in a space complexity of O(n).\\nAdditionally, the construct function creates new TreeNode objects during the construction process. The number of TreeNode objects created is proportional to the number of elements in the nums array. Therefore, the space complexity for the TreeNode objects is also O(n).\\nOverall, the space complexity is O(n) due to the stack space and the space required for the TreeNode objects.\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode constructMaximumBinaryTree(int[] nums) {\\n        TreeNode root= construct(nums,0,nums.length-1);\\n        return root;\\n    }\\n    private static TreeNode construct(int arr[], int s, int e){\\n        if(s>e)return null;\\n        if(s==e) return new TreeNode(arr[s]);\\n\\n        int idx=findMax(arr,s,e);\\n        TreeNode root=new TreeNode(arr[idx]);\\n        root.left=construct(arr,s,idx-1);\\n        root.right=construct(arr,idx+1,e);\\n\\n        return root;\\n    }\\n\\n    private static int findMax(int arr[], int s, int e){\\n        int max=Integer.MIN_VALUE;\\n        int idx=-1;\\n        for(int i=s;i<=e; i++)\\n        {\\n            if(arr[i]>max){\\n                max=arr[i];\\n                idx=i;\\n            }\\n        }\\n         return idx;\\n    }\\n\\n}\\n```",
        "level": "medium",
        "type": [
            "== and = confusion",
            "conditional statement error",
            "indexing error",
            "statement separation"
        ],
        "buggy_code": "\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public TreeNode constructMaximumBinaryTree(int[] nums) {\n        TreeNode root= construct(nums,0,nums.length);\n        return root;\n    }\n    private static TreeNode construct(int arr[], int s, int e){\n        if(s>e)return null;\n        if(s = e) return new TreeNode(arr[s]);\n       \n        int idx=findMax(arr,s,e);\n        TreeNode root=new TreeNode(arr[idx]);\n        root.left=construct(arr,s,idx-1)\n        root.right=construct(arr,idx+1,e);\n\n        return root;\n    }\n\n    private static int findMax(int arr[], int s, int e){\n        int max=Integer.MIN_VALUE;\n        int idx=-1;\n        for(int i=s;i<=e; i++){\n            if(arr[i]>max){\n                max=arr[i];\n                idx=i;\n\n"
    },
    {
        "slug": "find-first-palindromic-string-in-the-array",
        "description": "Given an array of strings words, return the first palindromic string in the array. If there is no such string, return an empty string \"\".\nA string is palindromic if it reads the same forward and backward.",
        "examples": [
            "Input: words = [\"abc\",\"car\",\"ada\",\"racecar\",\"cool\"]\nOutput: \"ada\"\nExplanation: The first string that is palindromic is \"ada\".\nNote that \"racecar\" is also palindromic, but it is not the first.",
            "Input: words = [\"notapalindrome\",\"racecar\"]\nOutput: \"racecar\"\nExplanation: The first and only string that is palindromic is \"racecar\".",
            "Input: words = [\"def\",\"ghi\"]\nOutput: \"\"\nExplanation: There are no palindromic strings, so the empty string is returned."
        ],
        "constraints": "1 <= words.length <= 100\n1 <= words[i].length <= 100\nwords[i] consists only of lowercase English letters.",
        "oracle_code": "class Solution {\n    public String firstPalindrome(String[] words) {\n        for (String s : words) {\n            if (isPalindrome(s)) return s;\n        }\n\n        return \"\";\n    }\n\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n\n        while (i < j) {\n            if (s.charAt(i++) != s.charAt(j--)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n}\n\n// TC: O(n * k), SC: O(1)\n// n -> length of words\n// k -> length of longest string in words",
        "content": "### **Please Upvote** :D\\n##### 1. By checking if its a palindrome using two pointers:\\n```\\nclass Solution {\\n    public String firstPalindrome(String[] words) {\\n        for (String s : words) {\\n            if (isPalindrome(s)) return s;\\n        }\\n\\n        return \"\";\\n    }\\n\\n    public boolean isPalindrome(String s) {\\n        int i = 0, j = s.length() - 1;\\n\\n        while (i < j) {\\n            if (s.charAt(i++) != s.charAt(j--)) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n\\n// TC: O(n * k), SC: O(1)\\n// n -> length of words\\n// k -> length of longest string in words\\n```\\n##### 2. Using strinbuilder to reverse the strings and compare:\\n```\\nclass Solution {\\n    public String firstPalindrome(String[] words) {\\n        for (String s : words){\\n            StringBuilder sb = new StringBuilder();\\n            sb.append(s).reverse();\\n\\n            if (s.equals(sb.toString())){\\n                return s;\\n            }\\n        }\\n\\n        return \"\";\\n    }\\n}\\n\\n// TC: O(n * k), SC: O(1)\\n// n -> length of words\\n// k -> length of longest string in words\\n```",
        "level": "easy",
        "type": [
            "parentheses mismatch",
            "conditional statement error",
            "indexing error",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution {\n    public String firstPalindrome(String[] words) {\n        for (String s : words) {\n            if (isPalindrome(s) return s;\n        }\n\n        return \"\";\n    }\n\n    public bool isPalindrome(String s) {\n        int i = 0, j = s.length();\n\n        while (i < j) {\n            if (s.charAt(i++) != s.charAt(j--)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n}\n"
    },
    {
        "slug": "relative-ranks",
        "description": "You are given an integer array score of size n, where score[i] is the score of the ith athlete in a competition. All the scores are guaranteed to be unique.\nThe athletes are placed based on their scores, where the 1st place athlete has the highest score, the 2nd place athlete has the 2nd highest score, and so on. The placement of each athlete determines their rank:\n\nThe 1st place athlete's rank is \"Gold Medal\".\nThe 2nd place athlete's rank is \"Silver Medal\".\nThe 3rd place athlete's rank is \"Bronze Medal\".\nFor the 4th place to the nth place athlete, their rank is their placement number (i.e., the xth place athlete's rank is \"x\").\n\nReturn an array answer of size n where answer[i] is the rank of the ith athlete.",
        "examples": [
            "Input: score = [5,4,3,2,1]\nOutput: [\"Gold Medal\",\"Silver Medal\",\"Bronze Medal\",\"4\",\"5\"]\nExplanation: The placements are [1st, 2nd, 3rd, 4th, 5th].",
            "Input: score = [10,3,8,9,4]\nOutput: [\"Gold Medal\",\"5\",\"Bronze Medal\",\"Silver Medal\",\"4\"]\nExplanation: The placements are [1st, 5th, 3rd, 2nd, 4th]."
        ],
        "constraints": "n == score.length\n1 <= n <= 104\n0 <= score[i] <= 106\nAll the values in score are unique.",
        "oracle_code": "class Solution {\n    public String[] findRelativeRanks(int[] score) {\n         int n=score.length;\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[b]-score[a]);\n        for(int i=0;i<n;i++) pq.add(i);\n      String[] ans = new String[n];\n                int i=1;\n        while(!pq.isEmpty()){\n            int idx=pq.poll();\n         if(i==1)   { ans[idx]=\"Gold Medal\"; i++;}\n         else if(i==2)   { ans[idx]=\"Silver Medal\"; i++;}\n         else if(i==3)   { ans[idx]=\"Bronze Medal\"; i++;}\n         else ans[idx]=Integer.toString(i++);\n        }\n        return ans;  \n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String[] findRelativeRanks(int[] score) {\\n         int n=score.length;\\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[b]-score[a]);\\n        for(int i=0;i<n;i++) pq.add(i);\\n      String[] ans = new String[n];\\n                int i=1;\\n        while(!pq.isEmpty()){\\n            int idx=pq.poll();\\n         if(i==1)   { ans[idx]=\"Gold Medal\"; i++;}\\n         else if(i==2)   { ans[idx]=\"Silver Medal\"; i++;}\\n         else if(i==3)   { ans[idx]=\"Bronze Medal\"; i++;}\\n         else ans[idx]=Integer.toString(i++);\\n        }\\n        return ans;  \\n    }\\n}\\n```",
        "level": "easy",
        "type": [
            "operation error",
            "== and = confusion",
            "undefined keywords from other languages",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\n    public String[] findRelativeRanks(int[] score) {\n         int n = score.length;\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[a]-score[b]);\n        for(int i=0;i<n;i++) pq.add(i);\n          String[] ans = new String[n];\n        int i=1;\n        while(!pq.isEmpty()){\n            int idx=pq.poll();\n            if(i=1) { ans[idx]=\"Gold Medal\"; i++;} \n            elif(i=2) { ans[idx]=\"Silver Medal\"; i++;} \n            else if(i=3) { ans[idx]=\"Bronze Medal\"; i++;} \n            else ans[idx]=Integer.toString(i++);\n        }\n        return reorderArray(ans);  \n    }\n\n    private String[] reorderArray(String[] ranks){\n        \n    }\n}\n"
    },
    {
        "slug": "construct-binary-tree-from-inorder-and-postorder-traversal",
        "description": "Given two integer arrays inorder and postorder where inorder is the inorder traversal of a binary tree and postorder is the postorder traversal of the same tree, construct and return the binary tree.",
        "examples": [
            "Input: inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]\nOutput: [3,9,20,null,null,15,7]",
            "Input: inorder = [-1], postorder = [-1]\nOutput: [-1]"
        ],
        "constraints": "1 <= inorder.length <= 3000\npostorder.length == inorder.length\n-3000 <= inorder[i], postorder[i] <= 3000\ninorder and postorder consist of unique values.\nEach value of postorder also appears in inorder.\ninorder is guaranteed to be the inorder traversal of the tree.\npostorder is guaranteed to be the postorder traversal of the tree.",
        "oracle_code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    int index;\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\n        Map<Integer, Integer> m = new HashMap<>();\n\n        for(int i = 0; i < inorder.length; i++) {\n            m.put(inorder[i], i);\n        }\n        index = postorder.length - 1;\n        return buildTree(0, postorder.length - 1, postorder, m);\n    }\n\n    private TreeNode buildTree(int l, int r, int postorder[] , Map<Integer, Integer> m) {\n        if(l > r) return null;\n\n        int val = postorder[index];\n        index--;\n\n        TreeNode root = new TreeNode(val);\n        if(l == r) return root;\n\n        int in = m.get(val);\n\n        root.right = buildTree(in + 1, r, postorder, m);\n        root.left = buildTree(l, in - 1, postorder, m);\n\n        return root;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int index;\\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\\n        Map<Integer, Integer> m = new HashMap<>();\\n\\n        for(int i = 0; i < inorder.length; i++) {\\n            m.put(inorder[i], i);\\n        }\\n        index = postorder.length - 1;\\n        return buildTree(0, postorder.length - 1, postorder, m);\\n    }\\n\\n    private TreeNode buildTree(int l, int r, int postorder[] , Map<Integer, Integer> m) {\\n        if(l > r) return null;\\n\\n        int val = postorder[index];\\n        index--;\\n\\n        TreeNode root = new TreeNode(val);\\n        if(l == r) return root;\\n\\n        int in = m.get(val);\\n\\n        root.right = buildTree(in + 1, r, postorder, m);\\n        root.left = buildTree(l, in - 1, postorder, m);\\n\\n        return root;\\n    }\\n}\\n```",
        "level": "medium",
        "type": [
            "parentheses mismatch",
            "indexing error",
            "undefined objects",
            "undefined methods"
        ],
        "buggy_code": "\n\n\n\nclass Solution {\n    int index;\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\n        Map<Integer, Integer> m = new HashMap<>();\n\n        for(int i = 0; i <= inorder.length; i++) {\n            m.put(inorder[i], i);\n        }\n        index = postorder.length - 1;\n        return buildTree(0, postorder.length - 1, postorder, m;\n    }\n\n    private TreeNode buildTree(int l, int r, int postorder[] , Map<Integer, Integer> m) {\n        if(l > r) return null;\n\n        int val = postorder[index];\n        index--;\n\n        TreeNode root = new TreeNode(val);\n        if(l == r) return root;\n\n        int in = m.get(val);\n\n        root.right = null;\n        root.left = buildNewTree(l, in - 1, postorder, m); \n\n        return root;\n    }\n}\n"
    },
    {
        "slug": "maximum-number-of-points-from-grid-queries",
        "description": "You are given an m x n integer matrix grid and an array queries of size k.\nFind an array answer of size k such that for each integer queries[i] you start in the top left cell of the matrix and repeat the following process:\n\nIf queries[i] is strictly greater than the value of the current cell that you are in, then you get one point if it is your first time visiting this cell, and you can move to any adjacent cell in all 4 directions: up, down, left, and right.\nOtherwise, you do not get any points, and you end this process.\n\nAfter the process, answer[i] is the maximum number of points you can get. Note that for each query you are allowed to visit the same cell multiple times.\nReturn the resulting array answer.",
        "examples": [
            "Input: grid = [[1,2,3],[2,5,7],[3,5,1]], queries = [5,6,2]\nOutput: [5,8,1]\nExplanation: The diagrams above show which cells we visit to get points for each query.",
            "Input: grid = [[5,2,1],[1,1,2]], queries = [3]\nOutput: [0]\nExplanation: We can not get any points because the value of the top left cell is already greater than or equal to 3."
        ],
        "constraints": "m == grid.length\nn == grid[i].length\n2 <= m, n <= 1000\n4 <= m * n <= 105\nk == queries.length\n1 <= k <= 104\n1 <= grid[i][j], queries[i] <= 106",
        "oracle_code": "class Solution {\n    public int[] maxPoints(int[][] a, int[] q) {\n        \n        int n = a.length;\n        int m = a[0].length;\n        \n        int l = q.length;\n        int[][] p = new int[l][2];\n        \n        for(int i = 0 ; i < l ; i++) {\n            \n            p[i][0] = i;\n            p[i][1] = q[i];\n        }\n        \n        Arrays.sort(p, (o1,o2)-> {\n            \n            if(o1[1] == o2[1]) {\n                \n                Integer.compare(o1[0],o2[0]);\n            }\n            \n            return Integer.compare(o1[1],o2[1]);\n        });\n        \n        PriorityQueue<int[]> qu = new PriorityQueue<>((o1,o2)->{\n            \n            return Integer.compare(a[o1[0]][o1[1]],a[o2[0]][o2[1]]);\n        });\n        \n        qu.add(new int[]{0,0});\n        \n        boolean[][] v = new boolean[n][m];\n        int cnt = 0;\n        int idx = 0;\n        \n        while(qu.size() > 0 && idx < l) {\n            \n            int[] f = qu.remove();\n            int r = f[0] , c = f[1];\n            \n            if(v[r][c]) continue;\n            \n            v[r][c] = true;\n            \n            if(a[r][c] < p[idx][1]) {\n                \n                cnt++;\n            }\n            else{\n                \n                q[p[idx][0]] = cnt;\n                idx++;\n                qu.add(f);\n                v[r][c] = false;\n                continue;\n            }\n            \n            if(c+1 < m && v[r][c+1] == false) qu.add(new int[]{r,c+1});\n            if(r+1 < n && v[r+1][c] == false) qu.add(new int[]{r+1,c});\n            if(r-1 >=0 && v[r-1][c] == false) qu.add(new int[]{r-1,c});\n            if(c-1 >= 0 && v[r][c-1] == false) qu.add(new int[]{r,c-1});\n        }\n        \n        while(idx < l) {\n            \n            q[p[idx][0]] = cnt;\n            idx++;\n        }\n        \n        return q;\n    }\n}",
        "content": "# Intuition\\nUse the concept of offline query.\\n\\n# Approach\\nFirst sort the query and then use priorityqueue to get min value cell.\\nif value is less than query update count \\nelse cnt is ans for ith query.\\n\\n\\n# Complexity\\n- Time complexity: O(n*m*log(n*m))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n*m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] maxPoints(int[][] a, int[] q) {\\n        \\n        int n = a.length;\\n        int m = a[0].length;\\n        \\n        int l = q.length;\\n        int[][] p = new int[l][2];\\n        \\n        for(int i = 0 ; i < l ; i++) {\\n            \\n            p[i][0] = i;\\n            p[i][1] = q[i];\\n        }\\n        \\n        Arrays.sort(p, (o1,o2)-> {\\n            \\n            if(o1[1] == o2[1]) {\\n                \\n                Integer.compare(o1[0],o2[0]);\\n            }\\n            \\n            return Integer.compare(o1[1],o2[1]);\\n        });\\n        \\n        PriorityQueue<int[]> qu = new PriorityQueue<>((o1,o2)->{\\n            \\n            return Integer.compare(a[o1[0]][o1[1]],a[o2[0]][o2[1]]);\\n        });\\n        \\n        qu.add(new int[]{0,0});\\n        \\n        boolean[][] v = new boolean[n][m];\\n        int cnt = 0;\\n        int idx = 0;\\n        \\n        while(qu.size() > 0 && idx < l) {\\n            \\n            int[] f = qu.remove();\\n            int r = f[0] , c = f[1];\\n            \\n            if(v[r][c]) continue;\\n            \\n            v[r][c] = true;\\n            \\n            if(a[r][c] < p[idx][1]) {\\n                \\n                cnt++;\\n            }\\n            else{\\n                \\n                q[p[idx][0]] = cnt;\\n                idx++;\\n                qu.add(f);\\n                v[r][c] = false;\\n                continue;\\n            }\\n            \\n            if(c+1 < m && v[r][c+1] == false) qu.add(new int[]{r,c+1});\\n            if(r+1 < n && v[r+1][c] == false) qu.add(new int[]{r+1,c});\\n            if(r-1 >=0 && v[r-1][c] == false) qu.add(new int[]{r-1,c});\\n            if(c-1 >= 0 && v[r][c-1] == false) qu.add(new int[]{r,c-1});\\n        }\\n        \\n        while(idx < l) {\\n            \\n            q[p[idx][0]] = cnt;\\n            idx++;\\n        }\\n        \\n        return q;\\n    }\\n}\\n```",
        "level": "hard",
        "type": [
            "variable value error",
            "indexing error",
            "undefined objects",
            "statement separation"
        ],
        "buggy_code": "\nclass Solution {\n    public int[] maxPoints(int[][] a, int[] q) {\n        \n        int n = a.length;\n        int m = a[0].length;\n        \n        int l = q.length;\n        int[][] p = new int[l + 1][2];\n        \n        for(int i = 0 ; i < l ; i++) {\n            \n            p[i][0] = i;\n            p[i][1] = q[i];\n        }\n        \n        Arrays.sort(p, (o1,o2)-> {\n            \n            if(o1[1] == o2[1]) {\n                \n                return return Integer.compare(o1[0],o2[0]);\n            }\n            return Integer.compare(o1[1],o2[1]);\n        });\n        \n        PriorityQueue<int[]> qu = null\n        \n        qu.add(new int[]{0,1}); \n        \n        boolean[][] v = new boolean[n][m];\n        int cnt = 0;\n        int idx = 0;\n        \n        while(qu.size() > 0 && idx < l) {\n            \n            int[] f = qu.remove();\n            int r = f[0] , c = f[1];\n            \n            if(v[r][c]) continue;\n            \n            v[r][c] = true;\n            \n            if(a[r][c] < p[idx][1]) {\n                \n                cnt++;\n            }\n            else{\n                \n                q[p[idx][0]] = cnt;\n                idx++;\n                qu.add(f);\n                v[r][c] = false;\n                continue;\n            }\n            \n            if(c+1 < m && v[r][c+1] == false) qu.add(new int[]{r,c+1});\n            if(r+1 < n && v[r+1][c] == false) qu.add(new int[]{r+1,c});\n            if(r-1 >=0 && v[r-1][c] == false) qu.add(new int[]{r-1,c});\n            if(c-1 >= 0 && v[r][c-1] == false) qu.add(new int[]{r,c-1});\n        }\n        \n        while(idx < l) {\n            \n            q[p[idx][0]] = cnt;\n            idx++;\n        }\n        \n        return q;\n    }\n}\n"
    },
    {
        "slug": "minimum-number-of-swaps-to-make-the-string-balanced",
        "description": "You are given a 0-indexed string s of even length n. The string consists of exactly n / 2 opening brackets '[' and n / 2 closing brackets ']'.\nA string is called balanced if and only if:\n\nIt is the empty string, or\nIt can be written as AB, where both A and B are balanced strings, or\nIt can be written as [C], where C is a balanced string.\n\nYou may swap the brackets at any two indices any number of times.\nReturn the minimum number of swaps to make s balanced.",
        "examples": [
            "Input: s = \"][][\"\nOutput: 1\nExplanation: You can make the string balanced by swapping index 0 with index 3.\nThe resulting string is \"[[]]\".",
            "Input: s = \"]]][[[\"\nOutput: 2\nExplanation: You can do the following to make the string balanced:\n- Swap index 0 with index 4. s = \"[]][][\".\n- Swap index 1 with index 5. s = \"[[][]]\".\nThe resulting string is \"[[][]]\".",
            "Input: s = \"[]\"\nOutput: 0\nExplanation: The string is already balanced."
        ],
        "constraints": "n == s.length\n2 <= n <= 106\nn is even.\ns[i] is either '[' or ']'.\nThe number of opening brackets '[' equals n / 2, and the number of closing brackets ']' equals n / 2.",
        "oracle_code": "class Solution {\n    public int minSwaps(String s) {\n        return util1(s);\n    }\n    public int util1(String str) {\n        Stack<Character> s = new Stack<>();\n        for (int i = 0; i < str.length(); i++) {\n            if (str.charAt(i) == '[') {\n                s.push(str.charAt(i));\n            } else {\n                if (s.isEmpty() == false && s.peek() == '[') {\n                    s.pop();\n                } else {\n                    s.push(str.charAt(i));\n                }\n            }\n        }\n        double pairs = s.size() / 2;\n        double a = pairs / 2.0;\n        int ans = (int) Math.ceil(a);\n        return ans;\n    }\n}",
        "content": "the trick behind is fairly easy\\n\\nfor the number of pairs which are not correct, the amount of swaps required to make them correct is Math.ceil(a), where a is the number of pairs which are not correct.\\n\\nfor eg\\nfor 5 incorrect pairs, we need 3 swaps\\nfor 3 incorrect pairs, we need 2 swaps\\nfor 2 incorrect pairs, we need 1 swap\\n\\nso simply, \\nwe need to firstly write code to remove all the valid pairs, that ways only the pairs which are incorrect will be in the stack\\nthen we simply do the calculations.\\n\\nrest the code should be self explanatory.\\n\\n# Code\\n```\\nclass Solution {\\n    public int minSwaps(String s) {\\n        return util1(s);\\n    }\\n    public int util1(String str) {\\n        Stack<Character> s = new Stack<>();\\n        for (int i = 0; i < str.length(); i++) {\\n            if (str.charAt(i) == \\'[\\') {\\n                s.push(str.charAt(i));\\n            } else {\\n                if (s.isEmpty() == false && s.peek() == \\'[\\') {\\n                    s.pop();\\n                } else {\\n                    s.push(str.charAt(i));\\n                }\\n            }\\n        }\\n        double pairs = s.size() / 2;\\n        double a = pairs / 2.0;\\n        int ans = (int) Math.ceil(a);\\n        return ans;\\n    }\\n}\\n```\\nyou can check out my github repository where i am uploading famous interview questions topic wise with solutions.\\nlink-- https://github.com/Abhaydutt2003/DataStructureAndAlgoPractice \\nkindly upvote if you like my solution. you can ask doubts below.\\n    \\n",
        "level": "medium",
        "type": [
            "operation error",
            "parentheses mismatch",
            "unclosed string",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\n    public int minSwaps(String s) {\n        return util(\"s;\n    }\n    public int util1(String str) {\n        Stack<Character> s = new Stack<>();\n        for (int i = 0; i < str.length(); i++) {\n            if (str.charAt(i) == '[') {\n                s.push(str.charAt(i));\n            } else {\n                if (s.isEmpty() == false && s.peek() == '[') {\n                    s.pop();\n                } else {\n                    s.push(str.charAt(i));\n                }\n            }\n        }\n        double pairs = s.size() / 2;\n        double a = pairs / 10.0;\n        int ans = (int) Math.ceil(a);\n        return ans;\n    }\n}\n"
    },
    {
        "slug": "erect-the-fence",
        "description": "You are given an array trees where trees[i] = [xi, yi] represents the location of a tree in the garden.\nFence the entire garden using the minimum length of rope, as it is expensive. The garden is well-fenced only if all the trees are enclosed.\nReturn the coordinates of trees that are exactly located on the fence perimeter. You may return the answer in any order.",
        "examples": [
            "Input: trees = [[1,1],[2,2],[2,0],[2,4],[3,3],[4,2]]\nOutput: [[1,1],[2,0],[4,2],[3,3],[2,4]]\nExplanation: All the trees will be on the perimeter of the fence except the tree at [2, 2], which will be inside the fence.",
            "Input: trees = [[1,2],[2,2],[4,2]]\nOutput: [[4,2],[2,2],[1,2]]\nExplanation: The fence forms a line that passes through all the trees."
        ],
        "constraints": "1 <= trees.length <= 3000\ntrees[i].length == 2\n0 <= xi, yi <= 100\nAll the given positions are unique.",
        "oracle_code": "class Solution {\n    \n    public int[][] outerTrees(int[][] trees) {\n        if(trees.length == 3){\n            return trees;\n        }\n        Stack<int[]> upper = new Stack<>();\n        Stack<int[]> lower = new Stack<>();\n        \n        Arrays.sort(trees,(p,q) ->\n                  q[0]-p[0]==0?q[1]-p[1]:q[0]-p[0]);\n        \n        for(int i = 0 ; i < trees.length ; i++){\n            int size = trees.length;\n            while(upper.size() >= 2 && angle(upper.get(upper.size() - 2),upper.get(upper.size() - 1),trees[i]) > 0){\n                upper.pop();  \n                }\n            while(lower.size() >= 2 && angle(lower.get(lower.size() - 2),lower.get(lower.size() - 1),trees[i]) < 0){\n                 lower.pop();  \n              }\n            upper.push(trees[i]);\n            lower.push(trees[i]);\n        }\n        \n        \n        Set<int[]> res= new HashSet<>(lower);\n        res.addAll(upper);\n        return res.toArray(new int[res.size()][]);\n    }\n    \n    public int angle(int[] A , int[] B , int[] C){\n        return (C[0] - A[0]) * (B[1] - A[1]) - (B[0] - A[0]) * (C[1] - A[1]);\n    }\n}",
        "content": "```\\nclass Solution {\\n    \\n    public int[][] outerTrees(int[][] trees) {\\n        if(trees.length == 3){\\n            return trees;\\n        }\\n        Stack<int[]> upper = new Stack<>();\\n        Stack<int[]> lower = new Stack<>();\\n        \\n        Arrays.sort(trees,(p,q) ->\\n                  q[0]-p[0]==0?q[1]-p[1]:q[0]-p[0]);\\n        \\n        for(int i = 0 ; i < trees.length ; i++){\\n            int size = trees.length;\\n            while(upper.size() >= 2 && angle(upper.get(upper.size() - 2),upper.get(upper.size() - 1),trees[i]) > 0){\\n                upper.pop();  \\n                }\\n            while(lower.size() >= 2 && angle(lower.get(lower.size() - 2),lower.get(lower.size() - 1),trees[i]) < 0){\\n                 lower.pop();  \\n              }\\n            upper.push(trees[i]);\\n            lower.push(trees[i]);\\n        }\\n        \\n        \\n        Set<int[]> res= new HashSet<>(lower);\\n        res.addAll(upper);\\n        return res.toArray(new int[res.size()][]);\\n    }\\n    \\n    public int angle(int[] A , int[] B , int[] C){\\n        return (C[0] - A[0]) * (B[1] - A[1]) - (B[0] - A[0]) * (C[1] - A[1]);\\n    }\\n}\\n```\\n\\n**Upvote Please**",
        "level": "hard",
        "type": [
            "== and = confusion",
            "colon missing",
            "conditional statement error",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution {\n    public int[][] outerTrees(int[][] trees) {\n        if(trees.length = 3)\n            return trees;\n        Stack<int[]> upper = new Stack<>();\n        Stack<int[]> lower = null;\n        \n        Arrays.sort(trees,(p,q) ->q[0]-p[0]==0?q[1]-p[1]:q[0]-p[0]);\n        \n        for(int i = 0 ; i < trees.length ; i++){\n            while(upper.size() >= 2 && angle(upper.get(upper.size() - 2),upper.get(upper.size() - 1),trees[i]) > 0){\n                upper.pop();\n                }\n            while(lower.size() >= 2 && angle(lower.get(lower.size() - 2),lower.get(lower.size() - 1),trees[i]) > 0){\n                 lower.pop();   \n              }\n            upper.push(trees[i]);\n            lower.push(trees[i])\n        }\n        \n        \n        Set<int[]> res= new HashSet<>(lower);\n        res.addAll(upper);\n        return res.toArray(new int[res.size()][]);\n    }\n    \n    public int angle(int[] A , int[] B , int[] C){\n        return (C[0] - A[0]) * (B[1] - A[1]) - (B[0] - A[0]) * (C[1] - A[1]);\n    }\n}\n"
    },
    {
        "slug": "jewels-and-stones",
        "description": "You're given strings jewels representing the types of stones that are jewels, and stones representing the stones you have. Each character in stones is a type of stone you have. You want to know how many of the stones you have are also jewels.\nLetters are case sensitive, so \"a\" is considered a different type of stone from \"A\".",
        "examples": [
            "Input: jewels = \"aA\", stones = \"aAAbbbb\"\nOutput: 3",
            "Input: jewels = \"z\", stones = \"ZZ\"\nOutput: 0"
        ],
        "constraints": "1 <=\u00a0jewels.length, stones.length <= 50\njewels and stones consist of only English letters.\nAll the characters of\u00a0jewels are unique.",
        "oracle_code": "class Solution {\n    public int numJewelsInStones(String jewels, String stones) {\n        int count = 0;\n\n        for(int i=0; i<stones.length(); i++){\n            char c = stones.charAt(i);\n            if(jewels.contains(String.valueOf(c))){\n                count++;\n            }\n        }\n        return count;\n    }\n}",
        "content": "# Code\\n```\\nclass Solution {\\n    public int numJewelsInStones(String jewels, String stones) {\\n        int count = 0;\\n\\n        for(int i=0; i<stones.length(); i++){\\n            char c = stones.charAt(i);\\n            if(jewels.contains(String.valueOf(c))){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
        "level": "easy",
        "type": [
            "operation error",
            "wrong comment mark",
            "undefined keywords from other languages",
            "statement separation"
        ],
        "buggy_code": "\nclass Solution {\n    public int numJewelsInStones(String jewels, /*String stones) {\n        int count = 0;\n        let checkCharacter;\n\n        for(int i=0; i<stones.length(); i++)\n            checkCharacter = stones.charAt(i);\n            if(jewels.contains(String.valueOf(checkCharacter))){\n                count--;\n            }\n        return count;\n    } */\n}\n\n"
    },
    {
        "slug": "apply-discount-every-n-orders",
        "description": "There is a supermarket that is frequented by many customers. The products sold at the supermarket are represented as two parallel integer arrays products and prices, where the ith product has an ID of products[i] and a price of prices[i].\nWhen a customer is paying, their bill is represented as two parallel integer arrays product and amount, where the jth product they purchased has an ID of product[j], and amount[j] is how much of the product they bought. Their subtotal is calculated as the sum of each amount[j] * (price of the jth product).\nThe supermarket decided to have a sale. Every nth customer paying for their groceries will be given a percentage discount. The discount amount is given by discount, where they will be given discount percent off their subtotal. More formally, if their subtotal is bill, then they would actually pay bill * ((100 - discount) / 100).\nImplement the Cashier class:\n\nCashier(int n, int discount, int[] products, int[] prices) Initializes the object with n, the discount, and the products and their prices.\ndouble getBill(int[] product, int[] amount) Returns the final total of the bill with the discount applied (if any). Answers within 10-5 of the actual value will be accepted.",
        "examples": [
            "Input\n[\"Cashier\",\"getBill\",\"getBill\",\"getBill\",\"getBill\",\"getBill\",\"getBill\",\"getBill\"]\n[[3,50,[1,2,3,4,5,6,7],[100,200,300,400,300,200,100]],[[1,2],[1,2]],[[3,7],[10,10]],[[1,2,3,4,5,6,7],[1,1,1,1,1,1,1]],[[4],[10]],[[7,3],[10,10]],[[7,5,3,1,6,4,2],[10,10,10,9,9,9,7]],[[2,3,5],[5,3,2]]]\nOutput\n[null,500.0,4000.0,800.0,4000.0,4000.0,7350.0,2500.0]\nExplanation\nCashier cashier = new Cashier(3,50,[1,2,3,4,5,6,7],[100,200,300,400,300,200,100]);\ncashier.getBill([1,2],[1,2]);                        // return 500.0. 1st customer, no discount.\n                                                     // bill = 1 * 100 + 2 * 200 = 500.\ncashier.getBill([3,7],[10,10]);                      // return 4000.0. 2nd customer, no discount.\n                                                     // bill = 10 * 300 + 10 * 100 = 4000.\ncashier.getBill([1,2,3,4,5,6,7],[1,1,1,1,1,1,1]);    // return 800.0. 3rd customer, 50% discount.\n                                                     // Original bill = 1600\n                                                     // Actual bill = 1600 * ((100 - 50) / 100) = 800.\ncashier.getBill([4],[10]);                           // return 4000.0. 4th customer, no discount.\ncashier.getBill([7,3],[10,10]);                      // return 4000.0. 5th customer, no discount.\ncashier.getBill([7,5,3,1,6,4,2],[10,10,10,9,9,9,7]); // return 7350.0. 6th customer, 50% discount.\n                                                     // Original bill = 14700, but with\n                                                     // Actual bill = 14700 * ((100 - 50) / 100) = 7350.\ncashier.getBill([2,3,5],[5,3,2]);                    // return 2500.0.  7th customer, no discount."
        ],
        "constraints": "1 <= n <= 104\n0 <= discount <= 100\n1 <= products.length <= 200\nprices.length == products.length\n1 <= products[i] <= 200\n1 <= prices[i] <= 1000\nThe elements in products are unique.\n1 <= product.length <= products.length\namount.length == product.length\nproduct[j] exists in products.\n1 <= amount[j] <= 1000\nThe elements of product are unique.\nAt most 1000 calls will be made to getBill.\nAnswers within 10-5 of the actual value will be accepted.",
        "oracle_code": "class Cashier {\n    HashMap<Integer,Integer>stock=new HashMap<>();\n    int n;\n    int discount;\n    int itr=0;\n    public Cashier(int n, int discount, int[] products, int[] prices) {\n        for(int i=0;i<products.length;i++){\n            stock.put(products[i],prices[i]);\n        }\n        this.n=n;\n        this.discount=discount;\n    }\n    \n    public double getBill(int[] product, int[] amount) {\n        double total=0;\n        for(int i=0;i<product.length;i++){\n            total+=(double)(amount[i]*stock.get(product[i]));\n        }\n        itr++;\n        if(itr==n){\n            total*=(double)(((100-discount)/100d));\n            itr=0;\n        }\n        return total;\n    }\n}\n\n/**\n * Your Cashier object will be instantiated and called as such:\n * Cashier obj = new Cashier(n, discount, products, prices);\n * double param_1 = obj.getBill(product,amount);\n */",
        "content": "# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Cashier {\\n    HashMap<Integer,Integer>stock=new HashMap<>();\\n    int n;\\n    int discount;\\n    int itr=0;\\n    public Cashier(int n, int discount, int[] products, int[] prices) {\\n        for(int i=0;i<products.length;i++){\\n            stock.put(products[i],prices[i]);\\n        }\\n        this.n=n;\\n        this.discount=discount;\\n    }\\n    \\n    public double getBill(int[] product, int[] amount) {\\n        double total=0;\\n        for(int i=0;i<product.length;i++){\\n            total+=(double)(amount[i]*stock.get(product[i]));\\n        }\\n        itr++;\\n        if(itr==n){\\n            total*=(double)(((100-discount)/100d));\\n            itr=0;\\n        }\\n        return total;\\n    }\\n}\\n\\n/**\\n * Your Cashier object will be instantiated and called as such:\\n * Cashier obj = new Cashier(n, discount, products, prices);\\n * double param_1 = obj.getBill(product,amount);\\n */\\n```",
        "level": "medium",
        "type": [
            "parentheses mismatch",
            "colon missing",
            "conditional statement error",
            "wrong comment mark"
        ],
        "buggy_code": "\nclass Cashier {\n    HashMap<Integer,Integer>stock=new HashMap<>();\n    int n;\n    int discount;\n    int itr=0;\n    public Cashier(int n, int discount, int[] products, int[] prices {\n        for(int i=0;i<products.length;i++)\n            stock.put(products[i],prices[i]);\n        }\n        this.n=n;\n        this.discount=discount;\n    }\n    \n    public double getBill(int[] product, int[] amount) {\n        double total=0;\n        for(int i=0;i<product.length;i++)\n            total+=(double)(amount[i]*stock.get(product[i]));\n        }\n        itr++;\n        if(itr==n+1)\n            total*=(double)(((100-discount)/*100d*/));\n            itr=0;\n        }\n        return total;\n    }\n}\n\n\n"
    },
    {
        "slug": "probability-of-a-two-boxes-having-the-same-number-of-distinct-balls",
        "description": "Given 2n balls of k distinct colors. You will be given an integer array balls of size k where balls[i] is the number of balls of color i.\nAll the balls will be shuffled uniformly at random, then we will distribute the first n balls to the first box and the remaining n balls to the other box (Please read the explanation of the second example carefully).\nPlease note that the two boxes are considered different. For example, if we have two balls of colors a and b, and two boxes [] and (), then the distribution [a] (b) is considered different than the distribution [b] (a) (Please read the explanation of the first example carefully).\nReturn the probability that the two boxes have the same number of distinct balls. Answers within 10-5 of the actual value will be accepted as correct.",
        "examples": [
            "Input: balls = [1,1]\nOutput: 1.00000\nExplanation: Only 2 ways to divide the balls equally:\n- A ball of color 1 to box 1 and a ball of color 2 to box 2\n- A ball of color 2 to box 1 and a ball of color 1 to box 2\nIn both ways, the number of distinct colors in each box is equal. The probability is 2/2 = 1",
            "Input: balls = [2,1,1]\nOutput: 0.66667\nExplanation: We have the set of balls [1, 1, 2, 3]\nThis set of balls will be shuffled randomly and we may have one of the 12 distinct shuffles with equal probability (i.e. 1/12):\n[1,1 / 2,3], [1,1 / 3,2], [1,2 / 1,3], [1,2 / 3,1], [1,3 / 1,2], [1,3 / 2,1], [2,1 / 1,3], [2,1 / 3,1], [2,3 / 1,1], [3,1 / 1,2], [3,1 / 2,1], [3,2 / 1,1]\nAfter that, we add the first two balls to the first box and the second two balls to the second box.\nWe can see that 8 of these 12 possible random distributions have the same number of distinct colors of balls in each box.\nProbability is 8/12 = 0.66667",
            "Input: balls = [1,2,1,2]\nOutput: 0.60000\nExplanation: The set of balls is [1, 2, 2, 3, 4, 4]. It is hard to display all the 180 possible random shuffles of this set but it is easy to check that 108 of them will have the same number of distinct colors in each box.\nProbability = 108 / 180 = 0.6"
        ],
        "constraints": "1 <= balls.length <= 8\n1 <= balls[i] <= 6\nsum(balls) is even.",
        "oracle_code": "class Solution {\n    double possible = 0.0;\n    double valid = 0.0;\n    \n    public double getProbability(int[] balls) {\n        int[] first = new int[balls.length];\n        int[] second = new int[balls.length];\n        dfs(balls, first, second, 0, 0, 0);\n        return valid / possible;\n    }\n    \n    private void dfs(int[] balls, int[] first, int[] second, int num1, int num2, int idx) {\n        // finish all colors, check if this's a possible/valid distribution\n        if (idx == balls.length) {\n            // find one possible distribution\n            if (num1 == num2) {\n                // compute fake permutation\n                double distrib = permFake(first) * permFake(second);\n                possible += distrib;\n                \n                // find one valid distribution\n                if (unique(first) == unique(second)) {\n                    valid += distrib;\n                }\n            }\n            return;\n        }\n        \n        // distribute balls in current color to two bins\n        for (int b = 0; b <= balls[idx]; b++) {\n            first[idx] = b;\n            second[idx] = balls[idx] - b;\n            dfs (balls, first, second, num1 + first[idx], num2 + second[idx], idx + 1);\n        }\n    }\n    \n    // unique colors in \n    private int unique(int[] balls) {\n        int unique = 0;\n        for (int b: balls)\n            unique += b > 0 ? 1 : 0;\n        return unique;\n    }\n    \n    // return 1 / (b1!b2!b3!...bn!) \n    private double permFake(int[] balls) {\n        double ret = 1.0;\n        for (int b: balls)\n            ret /= factorial(b);\n        return ret;\n    }\n    \n    private int factorial(int n){\n        int ret = 1;\n        while (n > 0) {\n            ret *= n;\n            n--;\n        }\n        return ret;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    double possible = 0.0;\\n    double valid = 0.0;\\n    \\n    public double getProbability(int[] balls) {\\n        int[] first = new int[balls.length];\\n        int[] second = new int[balls.length];\\n        dfs(balls, first, second, 0, 0, 0);\\n        return valid / possible;\\n    }\\n    \\n    private void dfs(int[] balls, int[] first, int[] second, int num1, int num2, int idx) {\\n        // finish all colors, check if this\\'s a possible/valid distribution\\n        if (idx == balls.length) {\\n            // find one possible distribution\\n            if (num1 == num2) {\\n                // compute fake permutation\\n                double distrib = permFake(first) * permFake(second);\\n                possible += distrib;\\n                \\n                // find one valid distribution\\n                if (unique(first) == unique(second)) {\\n                    valid += distrib;\\n                }\\n            }\\n            return;\\n        }\\n        \\n        // distribute balls in current color to two bins\\n        for (int b = 0; b <= balls[idx]; b++) {\\n            first[idx] = b;\\n            second[idx] = balls[idx] - b;\\n            dfs (balls, first, second, num1 + first[idx], num2 + second[idx], idx + 1);\\n        }\\n    }\\n    \\n    // unique colors in \\n    private int unique(int[] balls) {\\n        int unique = 0;\\n        for (int b: balls)\\n            unique += b > 0 ? 1 : 0;\\n        return unique;\\n    }\\n    \\n    // return 1 / (b1!b2!b3!...bn!) \\n    private double permFake(int[] balls) {\\n        double ret = 1.0;\\n        for (int b: balls)\\n            ret /= factorial(b);\\n        return ret;\\n    }\\n    \\n    private int factorial(int n){\\n        int ret = 1;\\n        while (n > 0) {\\n            ret *= n;\\n            n--;\\n        }\\n        return ret;\\n    }\\n}\\n```",
        "level": "hard",
        "type": [
            "operation error",
            "== and = confusion",
            "undefined objects",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\n    double possible = 0.0;\n    double valid = 0.0;\n    \n    public double getProbability(int[] balls) {\n        int[] first = new int[balls.length];\n        int[] second = null;\n        dfs(balls, first, second, 0, 0, 0);\n        return valid / possible;\n    }\n    \n    private void dfs(int[] balls, int[] first, int[] second, int num1, int num2, int idx) {\n        if (idx == balls.length) {\n            if (num1 = num2) {\n                double distrib = permFake(first) * permFake(second);\n                possible += distrib;\n                if (unique(first) == unique(second)) {\n                    valid += distrib + 1;    \n                }\n            }\n            return;\n        }\n        for (int b = 0; b <= balls[idx]; b++) {\n            first[idx] = b;\n            second[idx] = balls[idx] - b;\n            dfs (balls, first, second, num1 + first[idx], num2 + second[idx], idx + 1);\n        }\n    }\n    \n    private int factorial(int n){\n        int ret = 1;\n        while (n > 0) {\n            ret *= n;\n            n--;\n        }\n        return ret;\n    }\n}\n"
    },
    {
        "slug": "lexicographically-smallest-equivalent-string",
        "description": "You are given two strings of the same length s1 and s2 and a string baseStr.\nWe say s1[i] and s2[i] are equivalent characters.\n\nFor example, if s1 = \"abc\" and s2 = \"cde\", then we have 'a' == 'c', 'b' == 'd', and 'c' == 'e'.\n\nEquivalent characters follow the usual rules of any equivalence relation:\n\nReflexivity: 'a' == 'a'.\nSymmetry: 'a' == 'b' implies 'b' == 'a'.\nTransitivity: 'a' == 'b' and 'b' == 'c' implies 'a' == 'c'.\n\nFor example, given the equivalency information from s1 = \"abc\" and s2 = \"cde\", \"acd\" and \"aab\" are equivalent strings of baseStr = \"eed\", and \"aab\" is the lexicographically smallest equivalent string of baseStr.\nReturn the lexicographically smallest equivalent string of baseStr by using the equivalency information from s1 and s2.",
        "examples": [
            "Input: s1 = \"parker\", s2 = \"morris\", baseStr = \"parser\"\nOutput: \"makkek\"\nExplanation: Based on the equivalency information in s1 and s2, we can group their characters as [m,p], [a,o], [k,r,s], [e,i].\nThe characters in each group are equivalent and sorted in lexicographical order.\nSo the answer is \"makkek\".",
            "Input: s1 = \"hello\", s2 = \"world\", baseStr = \"hold\"\nOutput: \"hdld\"\nExplanation: Based on the equivalency information in s1 and s2, we can group their characters as [h,w], [d,e,o], [l,r].\nSo only the second letter 'o' in baseStr is changed to 'd', the answer is \"hdld\".",
            "Input: s1 = \"leetcode\", s2 = \"programs\", baseStr = \"sourcecode\"\nOutput: \"aauaaaaada\"\nExplanation: We group the equivalent characters in s1 and s2 as [a,o,e,r,s,c], [l,p], [g,t] and [d,m], thus all letters in baseStr except 'u' and 'd' are transformed to 'a', the answer is \"aauaaaaada\"."
        ],
        "constraints": "1 <= s1.length, s2.length, baseStr <= 1000\ns1.length == s2.length\ns1, s2, and baseStr consist of lowercase English letters.",
        "oracle_code": "class Solution {\n    public String smallestEquivalentString(String s1, String s2, String baseStr) {\n        \n        UFDS dsu = new UFDS(26);\n        for(int i = 0; i < s1.length(); i++){\n            dsu.union(s1.charAt(i)-97,s2.charAt(i)-97);\n        }\n\n        StringBuilder sb = new StringBuilder(); \n\n        for(int i = 0; i < baseStr.length(); i++){\n            int root = dsu.root(baseStr.charAt(i) - 97);\n            sb.append((char)(dsu.min[root] + 97));\n\n        }\n        return sb.toString();\n    }\n    \n    class UFDS{\n        \n        int[] id;\n        int[] size;\n        int[] min;\n        \n        public UFDS(int N){\n            \n            id = new int[N];\n            size = new int[N];\n            min = new int[N];\n            for(int i = 0; i < N; i++){\n                id[i] = i;\n                size[i] = 1;\n                min[i] = i;\n            }\n        }\n        \n        private int root(int i){\n            while (i != id[i]){\n                id[i] = id[id[i]];\n                i = id[i];\n            }\n            return i;\n        }\n        \n        public void union(int p, int q){\n            \n            int i = root(p);\n            int j = root(q);\n            if(i == j)return;\n            if(size[i] < size[j]){\n                id[i] = id[j];\n                size[j] += size[i];\n                min[j] = Math.min(min[i],min[j]);\n            }\n            else{\n                id[j] = id[i];\n                size[i] += size[j];\n                min[i] = Math.min(min[i],min[j]);\n            }\n        }\n\n    }   \n}",
        "content": "# Intuition\\nThis is as straight forward of a DSU/UFDS problem as they come. One could think of equivalent characters as elements belonging to the same set. If a certain character of one set is found to be equivalent to be the character of some other set, a union of those two sets has to be performed. Also, the smallest character in each set has to be tracked so as to finally construct our answer.\\n\\n# Approach\\nStart by initialsing a UFDS class with 26 elements (elements being the characters of a set). Take union of two equivalent characters a/c to String S1 and S2, while taking union, keep tracking the minimum element of the sets involved using an extra \\'min\\' array. To finally construct the answer, find the min character for each set a character of the baseStr String belongs to. \\n\\n\\n# Code\\n```\\nclass Solution {\\n    public String smallestEquivalentString(String s1, String s2, String baseStr) {\\n        \\n        UFDS dsu = new UFDS(26);\\n        for(int i = 0; i < s1.length(); i++){\\n            dsu.union(s1.charAt(i)-97,s2.charAt(i)-97);\\n        }\\n\\n        StringBuilder sb = new StringBuilder(); \\n\\n        for(int i = 0; i < baseStr.length(); i++){\\n            int root = dsu.root(baseStr.charAt(i) - 97);\\n            sb.append((char)(dsu.min[root] + 97));\\n\\n        }\\n        return sb.toString();\\n    }\\n    \\n    class UFDS{\\n        \\n        int[] id;\\n        int[] size;\\n        int[] min;\\n        \\n        public UFDS(int N){\\n            \\n            id = new int[N];\\n            size = new int[N];\\n            min = new int[N];\\n            for(int i = 0; i < N; i++){\\n                id[i] = i;\\n                size[i] = 1;\\n                min[i] = i;\\n            }\\n        }\\n        \\n        private int root(int i){\\n            while (i != id[i]){\\n                id[i] = id[id[i]];\\n                i = id[i];\\n            }\\n            return i;\\n        }\\n        \\n        public void union(int p, int q){\\n            \\n            int i = root(p);\\n            int j = root(q);\\n            if(i == j)return;\\n            if(size[i] < size[j]){\\n                id[i] = id[j];\\n                size[j] += size[i];\\n                min[j] = Math.min(min[i],min[j]);\\n            }\\n            else{\\n                id[j] = id[i];\\n                size[i] += size[j];\\n                min[i] = Math.min(min[i],min[j]);\\n            }\\n        }\\n\\n    }   \\n}\\n```",
        "level": "medium",
        "type": [
            "operation error",
            "wrong comment mark",
            "undefined keywords from other languages",
            "statement separation"
        ],
        "buggy_code": "\nclass Solution {\n    public String smallestEquivalentString(String s1, String s2, /* String baseStr) {\n        \n        UFDS dsu = new UFDS(26);\n        for(int i = 0; i < s1.length(); i++)\n            dsu.union(s1.charAt(i)-97,s2.charAt(i)-97);\n\n        StringBuilder sb = new StringBuilder(); \n\n        for(int i = 0; i < baseStr.length(); i++)\n            int root = dsu.root(baseStr.charAt(i) - 97);\n            sb.append((char)(dsu.min[root] + 97));\n\n        return sb.reverse().toString();\n    }\n    \n    class UFDS{\n        \n        int[] id;\n        int[] size;\n        int[] min;\n        \n        public UFDS(int N){\n            \n            id = new int[N];\n            size = new int[N];\n            min = new int[N];\n            for(int i = 0; i < N; i++){\n                id[i] = i;\n                size[i] = 1;\n                min[i] = i;\n            }\n        }\n        \n        private int root(int i){\n            while (i != id[i]){\n                id[i] = id[id[i]];\n                global i = id[i];\n            }\n            return i;\n        }\n        \n        public void union(int p, int q){\n            \n            int i = root(p);\n            int j = root(q);\n            if(i == j)return;\n            if(size[i] < size[j]){\n                id[i] = id[j];\n                size[j] += size[i];\n                min[j] = Math.min(min[i],min[j]);\n            }\n            else{\n                id[j] = id[i];\n                size[i] += size[j];\n                min[i] = Math.min(min[i],min[j]);\n            }\n        }\n\n    }   \n}\n"
    },
    {
        "slug": "n-queens",
        "description": "The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.\nGiven an integer n, return all distinct solutions to the n-queens puzzle. You may return the answer in any order.\nEach solution contains a distinct board configuration of the n-queens' placement, where 'Q' and '.' both indicate a queen and an empty space, respectively.",
        "examples": [
            "Input: n = 4\nOutput: [[\".Q..\",\"...Q\",\"Q...\",\"..Q.\"],[\"..Q.\",\"Q...\",\"...Q\",\".Q..\"]]\nExplanation: There exist two distinct solutions to the 4-queens puzzle as shown above",
            "Input: n = 1\nOutput: [[\"Q\"]]"
        ],
        "constraints": "1 <= n <= 9",
        "oracle_code": "class Solution {\n    public List<List<String>> solveNQueens(int n) {\n        \n        char [][] board = new char[n][n];\n        for(int i = 0; i < board.length; i++) {\n            for(int j = 0; j < board.length; j++) {\n                board[i][j] = '.';\n            }\n        }\n        \n        List<List<String>> ans = new ArrayList<>();\n        queen(board, 0, ans);\n        return ans;\n    }\n\n    static void queen(char[][] board, int row, List<List<String>> list) {\n\n        if(row == board.length) {\n\n            list.add(construct(board));\n            return;\n        }\n\n        for (int col = 0; col < board.length; col++) {\n            if(isSafe(board, row, col)) {\n                board[row][col] = 'Q';\n                queen(board, row + 1, list);\n                board[row][col] = '.';\n            }\n        }\n    }\n\n    static List<String> construct(char[][] board) {\n\n        List<String> internal = new ArrayList<>();\n        for (int i = 0; i < board.length; i++) {\n            String row = new String(board[i]);\n            internal.add(row);\n        }\n        return internal;\n    }\n\n    static boolean isSafe(char[][] board, int row, int col) {\n\n        //for checking vertical row\n        for (int i = 0; i < row; i++) {\n            if(board[i][col] == 'Q') {\n                return false;\n            }\n        }\n\n        //for checking left diagonal\n\n        int maxLeft = Math.min(row, col);\n\n        for (int i = 1; i <= maxLeft; i++) {\n            if(board[row - i][col - i] == 'Q') {\n                return false;\n            }\n        }\n\n        //for checking right diagonal\n\n        int maxRight = Math.min(row, board.length - 1 - col);\n\n        for (int i = 1; i <= maxRight; i++) {\n            if(board[row - i][col + i] == 'Q') {\n                return false;\n            }\n        }\n\n        return true;\n    }\n}",
        "content": "# Intuition\\n<!--  -->\\nLet\\'s see the intuition behind this question.\\n\\n![WhatsApp Image 2023-07-12 at 5.11.51 PM.jpeg](https://assets.leetcode.com/users/images/d7c0148d-9d34-4e20-86a9-34da5b670c08_1689162264.640158.jpeg)\\n\\n# Approach\\n<!--  -->\\nSo, now when we know the question requires backtracking and recursion, let\\'s discuss the thought process and the approach!\\n\\n![WhatsApp Image 2023-07-12 at 5.11.52 PM.jpeg](https://assets.leetcode.com/users/images/76f56253-26ea-4299-9d02-604f8c1a88f1_1689162387.0847921.jpeg)\\n![WhatsApp Image 2023-07-12 at 5.11.53 PM.jpeg](https://assets.leetcode.com/users/images/2872576b-425c-48c9-a5c7-ee6c8b960b72_1689162414.789056.jpeg)\\n![WhatsApp Image 2023-07-12 at 5.18.32 PM.jpeg](https://assets.leetcode.com/users/images/74aa66cb-dc07-4001-a353-ae8220a3bf0d_1689162542.4049857.jpeg)\\n\\n## Please upvote if you loved it! \\n\\n![cat.jpeg](https://assets.leetcode.com/users/images/6caea43f-b90d-4e55-befe-e8963ec23424_1689162825.9038785.jpeg)\\n\\n\\n\\n# Complexity\\n- Time complexity: O(n! * n)\\n<!--  -->\\n\\n- Space complexity: O(n^2)\\n<!--  -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<String>> solveNQueens(int n) {\\n        \\n        char [][] board = new char[n][n];\\n        for(int i = 0; i < board.length; i++) {\\n            for(int j = 0; j < board.length; j++) {\\n                board[i][j] = \\'.\\';\\n            }\\n        }\\n        \\n        List<List<String>> ans = new ArrayList<>();\\n        queen(board, 0, ans);\\n        return ans;\\n    }\\n\\n    static void queen(char[][] board, int row, List<List<String>> list) {\\n\\n        if(row == board.length) {\\n\\n            list.add(construct(board));\\n            return;\\n        }\\n\\n        for (int col = 0; col < board.length; col++) {\\n            if(isSafe(board, row, col)) {\\n                board[row][col] = \\'Q\\';\\n                queen(board, row + 1, list);\\n                board[row][col] = \\'.\\';\\n            }\\n        }\\n    }\\n\\n    static List<String> construct(char[][] board) {\\n\\n        List<String> internal = new ArrayList<>();\\n        for (int i = 0; i < board.length; i++) {\\n            String row = new String(board[i]);\\n            internal.add(row);\\n        }\\n        return internal;\\n    }\\n\\n    static boolean isSafe(char[][] board, int row, int col) {\\n\\n        //for checking vertical row\\n        for (int i = 0; i < row; i++) {\\n            if(board[i][col] == \\'Q\\') {\\n                return false;\\n            }\\n        }\\n\\n        //for checking left diagonal\\n\\n        int maxLeft = Math.min(row, col);\\n\\n        for (int i = 1; i <= maxLeft; i++) {\\n            if(board[row - i][col - i] == \\'Q\\') {\\n                return false;\\n            }\\n        }\\n\\n        //for checking right diagonal\\n\\n        int maxRight = Math.min(row, board.length - 1 - col);\\n\\n        for (int i = 1; i <= maxRight; i++) {\\n            if(board[row - i][col + i] == \\'Q\\') {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
        "level": "hard",
        "type": [
            "conditional statement error",
            "wrong comment mark",
            "undefined objects",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution {\n    public List<List<String>> solveNQueens(int n) {\n        \n        char [][] board = new char[n][n];\n        for(int i = 0; i < board.length; i++) {\n            for(int j = 0; j < board.length; j++) {\n                board[i][j] = '.';\n            }\n        }\n        \n        List<List<String>> ans = new ArrayList<>();\n        queen(null, 0, ans);\n        return ans;\n    }\n\n    static void queen(char[][] board, int row, List<List<String>> list) {\n\n        if(row == board.length) {\n\n            list.add(construct(board));\n            /* return;\n        }\n\n        for (int col = 0; col < board.length - 1; col++) {\n            if(isSafe(board, row, col)) {\n                board[row][col] = 'Q';\n                queen(board, row + 1, list);\n                board[row][col] = '.';\n            }\n        }\n    }\n\n    static List<String> construct(char[][] board) {\n\n        List<String> internal = new ArrayList<>();\n        for (int i = 0; i < board.length; i++) {\n            String row = new String(board[i]);\n            internal.add(row);\n        }\n        return internal;\n    }\n\n    static boolean isSafe(char[][] board, int row, int col) {\n\n        //for checking vertical row\n        for (int i = 0; i < row; i++) {\n            if(board[i][col] == 'Q') {\n                return false;\n            }\n        }\n\n        //for checking left diagonal\n\n        int maxLeft = Math.min(row, col);\n\n        for (int i = 1; i <= maxLeft; i++) {\n            if(board[row - i][col - i] == 'Q') {\n                return false;\n            }\n        }\n\n        //for checking right diagonal\n\n        int maxRight = Math.min(row, board.length - 1 - col);\n\n        for (int i = 1; i <= maxRight; i++) {\n            if(board[row - i][col + i] == 'Q') {\n                return false;\n            }\n        }\n\n        return \"true;\n    }\n}\n"
    },
    {
        "slug": "jewels-and-stones",
        "description": "You're given strings jewels representing the types of stones that are jewels, and stones representing the stones you have. Each character in stones is a type of stone you have. You want to know how many of the stones you have are also jewels.\nLetters are case sensitive, so \"a\" is considered a different type of stone from \"A\".",
        "examples": [
            "Input: jewels = \"aA\", stones = \"aAAbbbb\"\nOutput: 3",
            "Input: jewels = \"z\", stones = \"ZZ\"\nOutput: 0"
        ],
        "constraints": "1 <=\u00a0jewels.length, stones.length <= 50\njewels and stones consist of only English letters.\nAll the characters of\u00a0jewels are unique.",
        "oracle_code": "class Solution {\n    public int numJewelsInStones(String jewels, String stones) {\n        int count = 0;\n\n        for(int i=0; i<stones.length(); i++){\n            char c = stones.charAt(i);\n            if(jewels.contains(String.valueOf(c))){\n                count++;\n            }\n        }\n        return count;\n    }\n}",
        "content": "# Code\\n```\\nclass Solution {\\n    public int numJewelsInStones(String jewels, String stones) {\\n        int count = 0;\\n\\n        for(int i=0; i<stones.length(); i++){\\n            char c = stones.charAt(i);\\n            if(jewels.contains(String.valueOf(c))){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
        "level": "easy",
        "type": [
            "operation error",
            "wrong comment mark",
            "undefined objects",
            "statement separation"
        ],
        "buggy_code": "\nclass Solution {\n    public int numJewelsInStones(String jewels, /*String stones) {\n        int count = 0;\n\n        for(int i=0; i<stones.length(); i++)\n            char c = stones.charAt(i);\n            String undefinedObject = null;\n            if(undefinedObject.contains(String.valueOf(c))){\n                count--;\n            }\n        return count;\n    } */\n}\n\n"
    },
    {
        "slug": "find-first-palindromic-string-in-the-array",
        "description": "Given an array of strings words, return the first palindromic string in the array. If there is no such string, return an empty string \"\".\nA string is palindromic if it reads the same forward and backward.",
        "examples": [
            "Input: words = [\"abc\",\"car\",\"ada\",\"racecar\",\"cool\"]\nOutput: \"ada\"\nExplanation: The first string that is palindromic is \"ada\".\nNote that \"racecar\" is also palindromic, but it is not the first.",
            "Input: words = [\"notapalindrome\",\"racecar\"]\nOutput: \"racecar\"\nExplanation: The first and only string that is palindromic is \"racecar\".",
            "Input: words = [\"def\",\"ghi\"]\nOutput: \"\"\nExplanation: There are no palindromic strings, so the empty string is returned."
        ],
        "constraints": "1 <= words.length <= 100\n1 <= words[i].length <= 100\nwords[i] consists only of lowercase English letters.",
        "oracle_code": "class Solution {\n    public String firstPalindrome(String[] words) {\n        for (String s : words) {\n            if (isPalindrome(s)) return s;\n        }\n\n        return \"\";\n    }\n\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n\n        while (i < j) {\n            if (s.charAt(i++) != s.charAt(j--)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n}\n\n// TC: O(n * k), SC: O(1)\n// n -> length of words\n// k -> length of longest string in words",
        "content": "### **Please Upvote** :D\\n##### 1. By checking if its a palindrome using two pointers:\\n```\\nclass Solution {\\n    public String firstPalindrome(String[] words) {\\n        for (String s : words) {\\n            if (isPalindrome(s)) return s;\\n        }\\n\\n        return \"\";\\n    }\\n\\n    public boolean isPalindrome(String s) {\\n        int i = 0, j = s.length() - 1;\\n\\n        while (i < j) {\\n            if (s.charAt(i++) != s.charAt(j--)) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n\\n// TC: O(n * k), SC: O(1)\\n// n -> length of words\\n// k -> length of longest string in words\\n```\\n##### 2. Using strinbuilder to reverse the strings and compare:\\n```\\nclass Solution {\\n    public String firstPalindrome(String[] words) {\\n        for (String s : words){\\n            StringBuilder sb = new StringBuilder();\\n            sb.append(s).reverse();\\n\\n            if (s.equals(sb.toString())){\\n                return s;\\n            }\\n        }\\n\\n        return \"\";\\n    }\\n}\\n\\n// TC: O(n * k), SC: O(1)\\n// n -> length of words\\n// k -> length of longest string in words\\n```",
        "level": "easy",
        "type": [
            "parentheses mismatch",
            "conditional statement error",
            "indexing error",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution {\n    public String firstPalindrome(String[] words) {\n        for (String s : words) {\n            if (isPalindrome(s) return \"s;\n        }\n\n        return \"\";\n    }\n\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length();\n\n        while (i < j) {\n            if (s.charAt(i++) != s.charAt(j--)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n}\n\n"
    },
    {
        "slug": "find-all-people-with-secret",
        "description": "You are given an integer n indicating there are n people numbered from 0 to n - 1. You are also given a 0-indexed 2D integer array meetings where meetings[i] = [xi, yi, timei] indicates that person xi and person yi have a meeting at timei. A person may attend multiple meetings at the same time. Finally, you are given an integer firstPerson.\nPerson 0 has a secret and initially shares the secret with a person firstPerson at time 0. This secret is then shared every time a meeting takes place with a person that has the secret. More formally, for every meeting, if a person xi has the secret at timei, then they will share the secret with person yi, and vice versa.\nThe secrets are shared instantaneously. That is, a person may receive the secret and share it with people in other meetings within the same time frame.\nReturn a list of all the people that have the secret after all the meetings have taken place. You may return the answer in any order.",
        "examples": [
            "Input: n = 6, meetings = [[1,2,5],[2,3,8],[1,5,10]], firstPerson = 1\nOutput: [0,1,2,3,5]\nExplanation:\nAt time 0, person 0 shares the secret with person 1.\nAt time 5, person 1 shares the secret with person 2.\nAt time 8, person 2 shares the secret with person 3.\nAt time 10, person 1 shares the secret with person 5.\u200b\u200b\u200b\u200b\nThus, people 0, 1, 2, 3, and 5 know the secret after all the meetings.",
            "Input: n = 4, meetings = [[3,1,3],[1,2,2],[0,3,3]], firstPerson = 3\nOutput: [0,1,3]\nExplanation:\nAt time 0, person 0 shares the secret with person 3.\nAt time 2, neither person 1 nor person 2 know the secret.\nAt time 3, person 3 shares the secret with person 0 and person 1.\nThus, people 0, 1, and 3 know the secret after all the meetings.",
            "Input: n = 5, meetings = [[3,4,2],[1,2,1],[2,3,1]], firstPerson = 1\nOutput: [0,1,2,3,4]\nExplanation:\nAt time 0, person 0 shares the secret with person 1.\nAt time 1, person 1 shares the secret with person 2, and person 2 shares the secret with person 3.\nNote that person 2 can share the secret at the same time as receiving it.\nAt time 2, person 3 shares the secret with person 4.\nThus, people 0, 1, 2, 3, and 4 know the secret after all the meetings."
        ],
        "constraints": "2 <= n <= 105\n1 <= meetings.length <= 105\nmeetings[i].length == 3\n0 <= xi, yi <= n - 1\nxi != yi\n1 <= timei <= 105\n1 <= firstPerson <= n - 1",
        "oracle_code": "class DisjointSet {\n    int[] root;\n    Long[] rank;\n    DisjointSet(int size, Set<Integer> secretKeepers) {\n        root = new int[size];\n        rank = new Long[size];\n        for (int i = 0; i < size; i++) {\n            root[i] = i;\n            rank[i] = secretKeepers.contains(i) ? Integer.MAX_VALUE : 1L;\n        }\n    }\n\n    public int find(int vertex) {\n        if(root[vertex] == vertex) return vertex;\n        return root[vertex] = find(root[vertex]);\n    }\n\n    public void union(int vertex1, int vertex2) {\n        int root1 = find(vertex1);\n        int root2 = find(vertex2);\n        if(root1 != root2) {\n            if(rank[root1] > rank[root2]) {\n                root[root2] = root1;\n            } else if (rank[root2] > rank[root1]) {\n                root[root1] = root2;\n            } else {\n                root[root2] = root1;\n                rank[root1]++;\n            }\n        }\n    }\n\n    public Set<Integer> getAllSecretKeepers(Set<Integer> secretKeepers, Set<Integer> visited) {\n        for (int vertex: visited) {\n            if(secretKeepers.contains(find(vertex)))\n                secretKeepers.add(vertex);\n            else \n                root[vertex] = vertex;\n        }\n        return secretKeepers;\n    }\n}\n\nclass Solution {\n    private int maxTime = Integer.MIN_VALUE;\n    private int minTime = Integer.MAX_VALUE;\n    public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {\n        Set<Integer> secretKeepers = new HashSet<>(List.of(0, firstPerson));\n        Map<Integer, List<Integer[]>> timeToMeetings = getTimeToMeetings(meetings);\n        DisjointSet disjointSet = new DisjointSet(n, secretKeepers);\n        for (int time = minTime; time <= maxTime; time++) {\n            if(!timeToMeetings.containsKey(time)) continue;\n            Set<Integer> visited = new HashSet<>();\n            for (Integer[] meeting: timeToMeetings.get(time)) {\n                int person1 = meeting[0], person2 = meeting[1];\n                disjointSet.union(person1, person2);\n                visited.add(person1);\n                visited.add(person2);\n            }\n            secretKeepers = disjointSet.getAllSecretKeepers(secretKeepers, visited);\n        }\n        return new ArrayList<>(secretKeepers);\n    }\n\n    private Map<Integer, List<Integer[]>> getTimeToMeetings(int[][] meetings) {\n        Map<Integer, List<Integer[]>> timeToMeetings = new HashMap<>();\n        for (int[] meeting: meetings) {\n            maxTime = Math.max(maxTime, meeting[2]);\n            minTime = Math.min(minTime, meeting[2]);\n            timeToMeetings.computeIfAbsent(meeting[2], e-> new ArrayList<>()).add(new Integer[]{meeting[0], meeting[1]});\n        }\n        return timeToMeetings;\n    }\n}",
        "content": "# Code\\n```\\nclass DisjointSet {\\n    int[] root;\\n    Long[] rank;\\n    DisjointSet(int size, Set<Integer> secretKeepers) {\\n        root = new int[size];\\n        rank = new Long[size];\\n        for (int i = 0; i < size; i++) {\\n            root[i] = i;\\n            rank[i] = secretKeepers.contains(i) ? Integer.MAX_VALUE : 1L;\\n        }\\n    }\\n\\n    public int find(int vertex) {\\n        if(root[vertex] == vertex) return vertex;\\n        return root[vertex] = find(root[vertex]);\\n    }\\n\\n    public void union(int vertex1, int vertex2) {\\n        int root1 = find(vertex1);\\n        int root2 = find(vertex2);\\n        if(root1 != root2) {\\n            if(rank[root1] > rank[root2]) {\\n                root[root2] = root1;\\n            } else if (rank[root2] > rank[root1]) {\\n                root[root1] = root2;\\n            } else {\\n                root[root2] = root1;\\n                rank[root1]++;\\n            }\\n        }\\n    }\\n\\n    public Set<Integer> getAllSecretKeepers(Set<Integer> secretKeepers, Set<Integer> visited) {\\n        for (int vertex: visited) {\\n            if(secretKeepers.contains(find(vertex)))\\n                secretKeepers.add(vertex);\\n            else \\n                root[vertex] = vertex;\\n        }\\n        return secretKeepers;\\n    }\\n}\\n\\nclass Solution {\\n    private int maxTime = Integer.MIN_VALUE;\\n    private int minTime = Integer.MAX_VALUE;\\n    public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {\\n        Set<Integer> secretKeepers = new HashSet<>(List.of(0, firstPerson));\\n        Map<Integer, List<Integer[]>> timeToMeetings = getTimeToMeetings(meetings);\\n        DisjointSet disjointSet = new DisjointSet(n, secretKeepers);\\n        for (int time = minTime; time <= maxTime; time++) {\\n            if(!timeToMeetings.containsKey(time)) continue;\\n            Set<Integer> visited = new HashSet<>();\\n            for (Integer[] meeting: timeToMeetings.get(time)) {\\n                int person1 = meeting[0], person2 = meeting[1];\\n                disjointSet.union(person1, person2);\\n                visited.add(person1);\\n                visited.add(person2);\\n            }\\n            secretKeepers = disjointSet.getAllSecretKeepers(secretKeepers, visited);\\n        }\\n        return new ArrayList<>(secretKeepers);\\n    }\\n\\n    private Map<Integer, List<Integer[]>> getTimeToMeetings(int[][] meetings) {\\n        Map<Integer, List<Integer[]>> timeToMeetings = new HashMap<>();\\n        for (int[] meeting: meetings) {\\n            maxTime = Math.max(maxTime, meeting[2]);\\n            minTime = Math.min(minTime, meeting[2]);\\n            timeToMeetings.computeIfAbsent(meeting[2], e-> new ArrayList<>()).add(new Integer[]{meeting[0], meeting[1]});\\n        }\\n        return timeToMeetings;\\n    }\\n}\\n```",
        "level": "hard",
        "type": [
            "variable value error",
            "colon missing",
            "undefined objects",
            "undefined methods"
        ],
        "buggy_code": "\nclass DisjointSet {\n    int[] root;\n    Long[] rank;\n    DisjointSet(int size, Set<Integer> secretKeepers) {\n        root = new int[size]\n        rank = new Long[size];\n        for (int i = 0; i < size; i++) {\n            root[i] = i;\n            rank[i] = (Long) secretKeepers.contains(i) ? Integer.MAX_VALUE : 1L;\n        }\n    }\n\n    public int find(int vertex) {\n        if(root[vertex] == vertex) return vertex;\n        return root[vertex] = find(root[vertex]);\n    }\n\n    public void union(int vertex1, int vertex2) {\n        int root1 = find(vertex1);\n        int root2 = find(vertex2);\n        if(root1 != root2) {\n            if(rank[root1] > rank[root2]) {\n                root[root2] = root1;\n            } else if (rank[root2] > rank[root1]) {\n                root[root1] = root2;\n            } else {\n                root[root2] = root1;\n                rank[root1]++;\n            }\n        }\n    }\n\n    public Set<Integer> getAllSecretKeepers(Set<Integer> secretKeepers, Set<Integer> visited) {\n        checkSecrets(vertex);\n        for (int vertex: visited) {\n            if(secretKeepers.contains(find(vertex)))\n                secretKeepers.add(vertex);\n            else \n                root[vertex] = vertex;\n        }\n        return secretKeepers;\n    }\n}\n\nclass Solution {\n    private int maxTime = Integer.MIN_VALUE;\n    private int minTime = Integer.MAX_VALUE;\n    public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {\n        Set<Integer> secretKeepers = new HashSet<>(List.of(0, firstPerson));\n        Map<Integer, List<Integer[]>> timeToMeetings = getTimeToMeetings(meetings);\n        DisjointSet disjointSet = new DisjointSet(n, secretKeepers);\n        for (int time = minTime; time <= maxTime; time++) {\n            if(!timeToMeetings.containsKey(time)) continue;\n            Set<Integer> visited = new HashSet<>();\n            for (Integer[] meeting: timeToMeetings.get(time)) {\n                int person1 = meeting[0], person2 = meeting[1];\n                disjointSet.union(person1, meeting[2]);\n                visited.add(person1);\n                visited.add(person2);\n            }\n            secretKeepers = disjointSet.getAllSecretKeepers(secretKeepers, visited);\n        }\n        return new ArrayList<>(secretKeepers);\n    }\n    private Map<Integer, List<Integer[]>> getTimeToMeetings(int[][] meetings) {\n        Map<Integer, List<Integer[]>> timeToMeetings = new HashMap<>();\n        for (int[] meeting: meetings) {\n            maxTime = Math.max(maxTime, meeting[2]);\n            minTime = Math.min(minTime, meeting[2]);\n            timeToMeetings.computeIfAbsent(meeting[2], e-> new ArrayList<>()).add(new Integer[]{meeting[0], meeting[1]});\n        }\n        return timeToMeetings;\n    }\n}\n"
    },
    {
        "slug": "minimum-score-triangulation-of-polygon",
        "description": "You have a convex n-sided polygon where each vertex has an integer value. You are given an integer array values where values[i] is the value of the ith vertex (i.e., clockwise order).\nYou will triangulate the polygon into n - 2 triangles. For each triangle, the value of that triangle is the product of the values of its vertices, and the total score of the triangulation is the sum of these values over all n - 2 triangles in the triangulation.\nReturn the smallest possible total score that you can achieve with some triangulation of the polygon.",
        "examples": [
            "Input: values = [1,2,3]\nOutput: 6\nExplanation: The polygon is already triangulated, and the score of the only triangle is 6.",
            "Input: values = [3,7,4,5]\nOutput: 144\nExplanation: There are two triangulations, with possible scores: 3*7*5 + 4*5*7 = 245, or 3*4*5 + 3*4*7 = 144.\nThe minimum score is 144.",
            "Input: values = [1,3,1,4,1,5]\nOutput: 13\nExplanation: The minimum score triangulation has score 1*1*3 + 1*1*4 + 1*1*5 + 1*1*1 = 13."
        ],
        "constraints": "n == values.length\n3 <= n <= 50\n1 <= values[i] <= 100",
        "oracle_code": "class Solution {\n    int[][] dp;\n    public int minScoreTriangulation(int[] values) {\n        int l=values.length;\n        dp = new int[l][l];\n        for(int[] i : dp) Arrays.fill(i,-1);\n        return solve(values,1,l-1); \n    }\n\n    public int solve(int[] values, int i,int j)\n    {\n        if(i>=j) return 0;\n        if(dp[i][j]!=-1) return dp[i][j];\n        int min=Integer.MAX_VALUE;\n        for(int k=i;k<j;k++)\n        {\n            int temp=solve(values,i,k)+solve(values,k+1,j)+\n                        values[i-1]*values[k]*values[j];\n            min=Math.min(min,temp);\n        }\n\n        return dp[i][j]=min;\n    }\n}",
        "content": "\\n# Complexity\\n- Time complexity: n^2\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: n^2\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int[][] dp;\\n    public int minScoreTriangulation(int[] values) {\\n        int l=values.length;\\n        dp = new int[l][l];\\n        for(int[] i : dp) Arrays.fill(i,-1);\\n        return solve(values,1,l-1); \\n    }\\n\\n    public int solve(int[] values, int i,int j)\\n    {\\n        if(i>=j) return 0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int min=Integer.MAX_VALUE;\\n        for(int k=i;k<j;k++)\\n        {\\n            int temp=solve(values,i,k)+solve(values,k+1,j)+\\n                        values[i-1]*values[k]*values[j];\\n            min=Math.min(min,temp);\\n        }\\n\\n        return dp[i][j]=min;\\n    }\\n}\\n```",
        "level": "medium",
        "type": [
            "variable value error",
            "parentheses mismatch",
            "wrong comment mark",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution {\n    int[][] dp;\n    public int minScoreTriangulation(int[] values) {\n        int l=values.length;\n        dp = new int[l][l];\n        for(int[] i : dp) Arrays.fill(i,-1);\n       0 \n    }\n\n    public int solve(int[] values, int i,int j)\n    {\n        if(i>=j) return 0;\n        if(dp[i][j]!=-1) return dp[i][j];\n        int min=Integer.MAX_VALUE;\n        for(int k=i;k<j;k++)\n        {\n            int temp=solve(values,i,k)+solve(values,k+1,j)\n                        values[i-1]*values[k]*values[undefined];\n            min=Math.min(min,temp);\n        }\n\n        return dp[i][j]=min;\n    }\n}\n"
    },
    {
        "slug": "minimum-number-of-swaps-to-make-the-string-balanced",
        "description": "You are given a 0-indexed string s of even length n. The string consists of exactly n / 2 opening brackets '[' and n / 2 closing brackets ']'.\nA string is called balanced if and only if:\n\nIt is the empty string, or\nIt can be written as AB, where both A and B are balanced strings, or\nIt can be written as [C], where C is a balanced string.\n\nYou may swap the brackets at any two indices any number of times.\nReturn the minimum number of swaps to make s balanced.",
        "examples": [
            "Input: s = \"][][\"\nOutput: 1\nExplanation: You can make the string balanced by swapping index 0 with index 3.\nThe resulting string is \"[[]]\".",
            "Input: s = \"]]][[[\"\nOutput: 2\nExplanation: You can do the following to make the string balanced:\n- Swap index 0 with index 4. s = \"[]][][\".\n- Swap index 1 with index 5. s = \"[[][]]\".\nThe resulting string is \"[[][]]\".",
            "Input: s = \"[]\"\nOutput: 0\nExplanation: The string is already balanced."
        ],
        "constraints": "n == s.length\n2 <= n <= 106\nn is even.\ns[i] is either '[' or ']'.\nThe number of opening brackets '[' equals n / 2, and the number of closing brackets ']' equals n / 2.",
        "oracle_code": "class Solution {\n    public int minSwaps(String s) {\n        return util1(s);\n    }\n    public int util1(String str) {\n        Stack<Character> s = new Stack<>();\n        for (int i = 0; i < str.length(); i++) {\n            if (str.charAt(i) == '[') {\n                s.push(str.charAt(i));\n            } else {\n                if (s.isEmpty() == false && s.peek() == '[') {\n                    s.pop();\n                } else {\n                    s.push(str.charAt(i));\n                }\n            }\n        }\n        double pairs = s.size() / 2;\n        double a = pairs / 2.0;\n        int ans = (int) Math.ceil(a);\n        return ans;\n    }\n}",
        "content": "the trick behind is fairly easy\\n\\nfor the number of pairs which are not correct, the amount of swaps required to make them correct is Math.ceil(a), where a is the number of pairs which are not correct.\\n\\nfor eg\\nfor 5 incorrect pairs, we need 3 swaps\\nfor 3 incorrect pairs, we need 2 swaps\\nfor 2 incorrect pairs, we need 1 swap\\n\\nso simply, \\nwe need to firstly write code to remove all the valid pairs, that ways only the pairs which are incorrect will be in the stack\\nthen we simply do the calculations.\\n\\nrest the code should be self explanatory.\\n\\n# Code\\n```\\nclass Solution {\\n    public int minSwaps(String s) {\\n        return util1(s);\\n    }\\n    public int util1(String str) {\\n        Stack<Character> s = new Stack<>();\\n        for (int i = 0; i < str.length(); i++) {\\n            if (str.charAt(i) == \\'[\\') {\\n                s.push(str.charAt(i));\\n            } else {\\n                if (s.isEmpty() == false && s.peek() == \\'[\\') {\\n                    s.pop();\\n                } else {\\n                    s.push(str.charAt(i));\\n                }\\n            }\\n        }\\n        double pairs = s.size() / 2;\\n        double a = pairs / 2.0;\\n        int ans = (int) Math.ceil(a);\\n        return ans;\\n    }\\n}\\n```\\nyou can check out my github repository where i am uploading famous interview questions topic wise with solutions.\\nlink-- https://github.com/Abhaydutt2003/DataStructureAndAlgoPractice \\nkindly upvote if you like my solution. you can ask doubts below.\\n    \\n",
        "level": "medium",
        "type": [
            "parentheses mismatch",
            "indexing error",
            "unclosed string",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\n    public int minSwaps(String s) {\n        return util(\"s;\n    }\n    public int util1(String str) {\n        Stack<Character> s = new Stack<>();\n        for (int i = 0; i <= str.length(); i++) {\n            if (str.charAt(i) == '[') {\n                s.push(str.charAt(i));\n            } else {\n                if (s.isEmpty() == false && s.peek() == '[') {\n                    s.pop();\n                } else {\n                    s.push(str.charAt(i));\n                }\n            }\n        }\n        double pairs = s.size() / 2;\n        double a = pairs / 2.0;\n        int ans = (int) Math.ceil(a);\n        return ans;\n    }\n}\n"
    },
    {
        "slug": "rotating-the-box",
        "description": "You are given an m x n matrix of characters box representing a side-view of a box. Each cell of the box is one of the following:\n\nA stone '#'\nA stationary obstacle '*'\nEmpty '.'\n\nThe box is rotated 90 degrees clockwise, causing some of the stones to fall due to gravity. Each stone falls down until it lands on an obstacle, another stone, or the bottom of the box. Gravity does not affect the obstacles' positions, and the inertia from the box's rotation does not affect the stones' horizontal positions.\nIt is guaranteed that each stone in box rests on an obstacle, another stone, or the bottom of the box.\nReturn an n x m matrix representing the box after the rotation described above.",
        "examples": [
            "Input: box = [[\"#\",\".\",\"#\"]]\r\nOutput: [[\".\"],\r\n\u00a0        [\"#\"],\r\n\u00a0        [\"#\"]]",
            "Input: box = [[\"#\",\".\",\"*\",\".\"],\r\n\u00a0             [\"#\",\"#\",\"*\",\".\"]]\r\nOutput: [[\"#\",\".\"],\r\n\u00a0        [\"#\",\"#\"],\r\n\u00a0        [\"*\",\"*\"],\r\n\u00a0        [\".\",\".\"]]",
            "Input: box = [[\"#\",\"#\",\"*\",\".\",\"*\",\".\"],\r\n\u00a0             [\"#\",\"#\",\"#\",\"*\",\".\",\".\"],\r\n\u00a0             [\"#\",\"#\",\"#\",\".\",\"#\",\".\"]]\r\nOutput: [[\".\",\"#\",\"#\"],\r\n\u00a0        [\".\",\"#\",\"#\"],\r\n\u00a0        [\"#\",\"#\",\"*\"],\r\n\u00a0        [\"#\",\"*\",\".\"],\r\n\u00a0        [\"#\",\".\",\"*\"],\r\n\u00a0        [\"#\",\".\",\".\"]]"
        ],
        "constraints": "m == box.length\nn == box[i].length\n1 <= m, n <= 500\nbox[i][j] is either '#', '*', or '.'.",
        "oracle_code": "// O(n^2) time | O(n^2) space\nclass Solution {\n    public char[][] rotateTheBox(char[][] box) {\n        int m = box.length;\n        int n = box[0].length;\n        char[][] matrix = new char[n][m];   \n        \n        turnBox(box, matrix, m, n); // turn the box clockwise 90 degree\n        \n        turnGravity(matrix, n, m); // cause that falling effect, since matrix turned so n,m\n        \n        return matrix;\n    }\n    \n    public void turnGravity(char[][] matrix, int m, int n){\n        for(int c = 0; c < n; c++){\n            int last  = m-1;\n            for(int r = m-1; r >= 0; r--){\n                char val =  matrix[r][c];\n                if(val == '.') continue;\n                if(val == '*') last = r-1;\n                if(val == '#') {\n                    matrix[r][c] = '.';\n                    matrix[last][c] = '#';\n                    last--;\n                }\n            }\n        }\n    }\n    \n    public void turnBox(char[][] box, char[][] matrix, int m, int n){\n\t// numbers represents sequence it would be copied\n\t//[4][1]\n\t//[5][2]\n\t//[6][3]\n        for(int i = 0, c = m-1; i < m; i++,c--){ // c: 4,3,2,1..\n            for(int j = 0, r = 0; j < n; j++, r++){ // r:0,1,2,3..\n               matrix[r][c] = box[i][j];\n            }\n        }\n    }\n}",
        "content": "**So idea here is**\\n1. First turn 90 degree\\n2. Make things fall\\n\\n```\\n// O(n^2) time | O(n^2) space\\nclass Solution {\\n    public char[][] rotateTheBox(char[][] box) {\\n        int m = box.length;\\n        int n = box[0].length;\\n        char[][] matrix = new char[n][m];   \\n        \\n        turnBox(box, matrix, m, n); // turn the box clockwise 90 degree\\n        \\n        turnGravity(matrix, n, m); // cause that falling effect, since matrix turned so n,m\\n        \\n        return matrix;\\n    }\\n    \\n    public void turnGravity(char[][] matrix, int m, int n){\\n        for(int c = 0; c < n; c++){\\n            int last  = m-1;\\n            for(int r = m-1; r >= 0; r--){\\n                char val =  matrix[r][c];\\n                if(val == \\'.\\') continue;\\n                if(val == \\'*\\') last = r-1;\\n                if(val == \\'#\\') {\\n                    matrix[r][c] = \\'.\\';\\n                    matrix[last][c] = \\'#\\';\\n                    last--;\\n                }\\n            }\\n        }\\n    }\\n    \\n    public void turnBox(char[][] box, char[][] matrix, int m, int n){\\n\\t// numbers represents sequence it would be copied\\n\\t//[4][1]\\n\\t//[5][2]\\n\\t//[6][3]\\n        for(int i = 0, c = m-1; i < m; i++,c--){ // c: 4,3,2,1..\\n            for(int j = 0, r = 0; j < n; j++, r++){ // r:0,1,2,3..\\n               matrix[r][c] = box[i][j];\\n            }\\n        }\\n    }\\n}\\n```",
        "level": "medium",
        "type": [
            "== and = confusion",
            "colon missing",
            "other error",
            "indexing error"
        ],
        "buggy_code": "\n// O(n^2) time | O(n^2) space\nclass Solution {\n    public char[][] rotateTheBox(char[][] box) {\n        int m = box.length;\n        int n = box[0].length + 1; \n        char[][] matrix = new char[n][m]   \n        \n        turnBox(box, matrix, m, n); // turn the box clockwise 90 degree\n        \n        turnGravity(matrix, n, m); // cause that falling effect, since matrix turned so n,m\n        \n        return matrix;\n    }\n    \n    public void turnGravity(char[][] matrix, int m, int n){\n        for(int c = 0; c < n; c++){\n            int last  = m-1;\n            for(int r = m-1; r >= 0; r--){\n                char val =  matrix[r][c];\n                if(val == '.') continue;\n                if(val = '*') last = r-1;  \n                if(val == '#') {\n                    matrix[r][c] = '.';\n                    matrix[last][c] = '#';\n                }\n            }\n        }\n    }\n    \n    public void turnBox(char[][] box, char[][] matrix, int m, int n){\n              for(int i = 0, c = m-1; i < m; i++,c--){\n            for(int j = 0, r = 0; j < n; j++, r++){\n               matrix[r][1] = box[i][j];\n            }\n        }\n    }\n}\n"
    },
    {
        "slug": "largest-3-same-digit-number-in-string",
        "description": "You are given a string num representing a large integer. An integer is good if it meets the following conditions:\n\nIt is a substring of num with length 3.\nIt consists of only one unique digit.\n\nReturn the maximum good integer as a string or an empty string \"\" if no such integer exists.\nNote:\n\nA substring is a contiguous sequence of characters within a string.\nThere may be leading zeroes in num or a good integer.",
        "examples": [
            "Input: num = \"6777133339\"\nOutput: \"777\"\nExplanation: There are two distinct good integers: \"777\" and \"333\".\n\"777\" is the largest, so we return \"777\".",
            "Input: num = \"2300019\"\nOutput: \"000\"\nExplanation: \"000\" is the only good integer.",
            "Input: num = \"42352338\"\nOutput: \"\"\nExplanation: No substring of length 3 consists of only one unique digit. Therefore, there are no good integers."
        ],
        "constraints": "3 <= num.length <= 1000\nnum only consists of digits.",
        "oracle_code": "class Solution {\n    public String largestGoodInteger(String num) {\n        int n=-1;\n        StringBuilder sb = new StringBuilder();\n        for(int i=0;i<num.length()-2;i++){\n            if(num.charAt(i)==num.charAt(i+1) && num.charAt(i)==num.charAt(i+2)){\n                sb.append(num.charAt(i));\n                sb.append(num.charAt(i));\n                sb.append(num.charAt(i));\n                if(Integer.parseInt(sb.toString())>n)\n                    n=Integer.parseInt(sb.toString());\n                sb.setLength(0);\n            }\n        }\n        if(n==-1)\n            return \"\";\n        String s = Integer.toString(n);\n        if(s.equals(\"0\"))\n            return \"000\";\n        return s;\n    }\n}",
        "content": "```\\nclass Solution {\\n    public String largestGoodInteger(String num) {\\n        int n=-1;\\n        StringBuilder sb = new StringBuilder();\\n        for(int i=0;i<num.length()-2;i++){\\n            if(num.charAt(i)==num.charAt(i+1) && num.charAt(i)==num.charAt(i+2)){\\n                sb.append(num.charAt(i));\\n                sb.append(num.charAt(i));\\n                sb.append(num.charAt(i));\\n                if(Integer.parseInt(sb.toString())>n)\\n                    n=Integer.parseInt(sb.toString());\\n                sb.setLength(0);\\n            }\\n        }\\n        if(n==-1)\\n            return \"\";\\n        String s = Integer.toString(n);\\n        if(s.equals(\"0\"))\\n            return \"000\";\\n        return s;\\n    }\\n}\\n```\\nKindly upvote if you like the code.",
        "level": "easy",
        "type": [
            "== and = confusion",
            "conditional statement error",
            "wrong comment mark",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution {\n    UndefinedObject largestGoodInteger; \n    public String largestGoodInteger(String num) {\n        int n=-1;\n        StringBuilder sb = new StringBuilder();\n        for(int i=0;i<=num.length()-2;i++){\n            if(num.charAt(i)==num.charAt(i+1) && num.charAt(i)==num.charAt(i+2)){\n                sb.append(num.charAt(i));\n                sb.append(num.charAt(i));\n                sb.append(num.charAt(i));\n                if(Integer.parseInt(sb.toString())=n)\n                    n=Integer.parseInt(sb.toString());\n                sb.setLength(0);\n                /*\n            }\n        }\n        if(n==-1)\n            return \"\";\n        String s = Integer.toString(n);\n        if(s.equals(\"0\"))\n            return \"000\";\n        return s;\n    }\n}\n"
    },
    {
        "slug": "maximum-ice-cream-bars",
        "description": "It is a sweltering summer day, and a boy wants to buy some ice cream bars.\nAt the store, there are n ice cream bars. You are given an array costs of length n, where costs[i] is the price of the ith ice cream bar in coins. The boy initially has coins coins to spend, and he wants to buy as many ice cream bars as possible.\u00a0\nNote: The boy can buy the ice cream bars in any order.\nReturn the maximum number of ice cream bars the boy can buy with coins coins.\nYou must solve the problem by counting sort.",
        "examples": [
            "Input: costs = [1,3,2,4,1], coins = 7\nOutput: 4\nExplanation: The boy can buy ice cream bars at indices 0,1,2,4 for a total price of 1 + 3 + 2 + 1 = 7.",
            "Input: costs = [10,6,8,7,7,8], coins = 5\nOutput: 0\nExplanation: The boy cannot afford any of the ice cream bars.",
            "Input: costs = [1,6,3,1,2,5], coins = 20\nOutput: 6\nExplanation: The boy can buy all the ice cream bars for a total price of 1 + 6 + 3 + 1 + 2 + 5 = 18."
        ],
        "constraints": "costs.length == n\n1 <= n <= 105\n1 <= costs[i] <= 105\n1 <= coins <= 108",
        "oracle_code": "class Solution {\n    public int maxIceCream(int[] costs, int coins) {\n        int [] arr = new int [100001];\n        for(int x : costs)arr[x]++;\n        int count = 0;\n        int index = 1;\n//If coins can buy all the ice-cream at ith index.\n        while(index<100001 && coins>=index*arr[index]){\n            coins-=index*arr[index];\n            count+=arr[index];\n            index++;\n        }\n//If coins can buy onyl some of the ice-creams at ith index.\n        while(index<100001 && coins>=index){\n            coins-=index;\n            count++;\n        }\n        return count;\n    }\n}",
        "content": "# Code\\n```\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        int [] arr = new int [100001];\\n        for(int x : costs)arr[x]++;\\n        int count = 0;\\n        int index = 1;\\n//If coins can buy all the ice-cream at ith index.\\n        while(index<100001 && coins>=index*arr[index]){\\n            coins-=index*arr[index];\\n            count+=arr[index];\\n            index++;\\n        }\\n//If coins can buy onyl some of the ice-creams at ith index.\\n        while(index<100001 && coins>=index){\\n            coins-=index;\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```\\n\\n# Using priority Queue\\n```\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<Integer>(Collections.reverseOrder());\\n        int sum = 0;\\n        for(int x : costs){\\n            if(sum<=coins){\\n                sum+=x;\\n                pq.add(x);\\n            }else if(pq.peek()>x){\\n                sum = sum - pq.poll() + x;\\n                pq.add(x);\\n            }\\n        }\\n        while(sum>coins){\\n            sum-=pq.poll();\\n        }\\n        return pq.size();\\n    }\\n}\\n```",
        "level": "medium",
        "type": [
            "parentheses mismatch",
            "colon missing",
            "other error",
            "statement separation"
        ],
        "buggy_code": "\nclass Solution {\n    public int maxIceCream(int[] costs, int coins) {\n        int [] arr = new int [100001];\n        for(int x : costs)arr[x]++;\n        int count = 0;\n        int index = 1;\n        while(index<100001 && coins>=index*arr[index])\n        \n            coins-=index*arr[index];\n            count+=arr[index];\n            index++\n        \n        while(index<100001 && coins>=index){\n            coins-=index;\n            index++;\n            count++;\n        }\n        return count;\n    }\n}\n"
    },
    {
        "slug": "max-sum-of-rectangle-no-larger-than-k",
        "description": "Given an m x n matrix matrix and an integer k, return the max sum of a rectangle in the matrix such that its sum is no larger than k.\nIt is guaranteed that there will be a rectangle with a sum no larger than k.",
        "examples": [
            "Input: matrix = [[1,0,1],[0,-2,3]], k = 2\nOutput: 2\nExplanation: Because the sum of the blue rectangle [[0, 1], [-2, 3]] is 2, and 2 is the max number no larger than k (k = 2).",
            "Input: matrix = [[2,2,-1]], k = 3\nOutput: 3"
        ],
        "constraints": "m == matrix.length\nn == matrix[i].length\n1 <= m, n <= 100\n-100 <= matrix[i][j] <= 100\n-105 <= k <= 105",
        "oracle_code": "//Kadane's Algorithm Approach\n//600ms+  explained in video\n\nclass Solution {\n    public int maxSumSubmatrix(int[][] matrix, int k) {\n        int result = Integer.MIN_VALUE;\n        \n        for(int left =0 ;left<matrix[0].length; left++){\n            \n            int[] rSum = new int[matrix.length];\n            \n            for(int right = left;right<matrix[0].length;right++){\n                for(int row=0; row < matrix.length; row++)\n                    rSum[row] += matrix[row][right];\n\t\t\t\t\t\n\t\t\t\t\t//explanation of these 3 loops starts from 02:00 in Video\n                \n                TreeSet<Integer> set = new TreeSet<>();\n                \n                set.add(0);\n                int cs = 0;\n                \n                for(int a: rSum){\n                    cs += a;\n\t\t\t\t\t\n                    //if you don't understand what exactly is going on here\n\t\t\t\t\t// then watch the video from 12:27\n\t\t\t\t\t\n                    Integer target = set.ceiling(cs-k);\n                    \n                    if(target !=null)\n                        result = Math.max(result,cs-target);\n                    set.add(cs);\n                }\n            }\n        }\n        return result;\n    }\n}",
        "content": "*Please **Upvote** if you find this explanation helpful*\\n\\n**Video Explanation**\\n[Max Sum of Rectangle No Larger Than K | YouTube](https://www.youtube.com/watch?v=rztZyG5kpvM&feature=youtu.be)\\n\\n**Java Solution**\\n\\n```\\n//Kadane\\'s Algorithm Approach\\n//600ms+  explained in video\\n\\nclass Solution {\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        int result = Integer.MIN_VALUE;\\n        \\n        for(int left =0 ;left<matrix[0].length; left++){\\n            \\n            int[] rSum = new int[matrix.length];\\n            \\n            for(int right = left;right<matrix[0].length;right++){\\n                for(int row=0; row < matrix.length; row++)\\n                    rSum[row] += matrix[row][right];\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t//explanation of these 3 loops starts from 02:00 in Video\\n                \\n                TreeSet<Integer> set = new TreeSet<>();\\n                \\n                set.add(0);\\n                int cs = 0;\\n                \\n                for(int a: rSum){\\n                    cs += a;\\n\\t\\t\\t\\t\\t\\n                    //if you don\\'t understand what exactly is going on here\\n\\t\\t\\t\\t\\t// then watch the video from 12:27\\n\\t\\t\\t\\t\\t\\n                    Integer target = set.ceiling(cs-k);\\n                    \\n                    if(target !=null)\\n                        result = Math.max(result,cs-target);\\n                    set.add(cs);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```\\n\\n**Faster Approach**\\n```\\n//32ms - faster than 100%\\n\\nclass Solution {\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        for (int i = 0; i < matrix.length; i++) {\\n            for (int j = 0; j < matrix[0].length; j++) {\\n                if (i > 0) {\\n                    matrix[i][j] += matrix[i - 1][j];\\n                }\\n                if (j > 0) {\\n                    matrix[i][j] += matrix[i][j - 1];\\n                }\\n                if (i > 0 && j > 0) {\\n                    matrix[i][j] -= matrix[i - 1][j - 1];\\n                }\\n            }\\n        }\\n        int result = Integer.MIN_VALUE;\\n        \\n        int[][] dpHigh = new int[matrix.length][matrix.length + 1];\\n        int[][] dpLow = new int[matrix.length][matrix.length + 1];\\n        \\n        for (int i = matrix.length - 1; i >= 0; i--) {\\n            for (int h = 1; h <= matrix.length - i; h++) {\\n                int theValue = getSum(matrix, i, matrix[0].length - 1, h, 1);\\n                dpLow[i][h] = theValue;\\n                dpHigh[i][h] = theValue;\\n                if (theValue == k) {\\n                    return theValue;\\n                }\\n                if (theValue < k) {\\n                    result = Math.max(result, theValue);\\n                }\\n            }\\n        }\\n        \\n        for (int i = matrix.length - 1; i >= 0; i--) {\\n            for (int j = matrix[0].length - 2; j >= 0; j--) {\\n                for (int h = 1; h <= matrix.length - i; h++) {\\n                    int newSum = getSum(matrix, i, j, h, 1);\\n                    if (dpLow[i][h] > 0) {\\n                        dpHigh[i][h] += newSum;\\n                        dpLow[i][h] = newSum;\\n                    } else if (dpHigh[i][h] < 0) {\\n                        dpLow[i][h] += newSum;\\n                        dpHigh[i][h] = newSum;\\n                    } else {\\n                        dpHigh[i][h] += newSum;\\n                        dpLow[i][h] += newSum;\\n                    }\\n                    if (dpHigh[i][h] >= result && dpLow[i][h] <= k) {\\n                        for (int w = 1; w <= matrix[0].length - j; w++) {\\n                            int sum = getSum(matrix, i, j, h, w);\\n                            if (sum == k) {\\n                                return sum;\\n                            } else if (sum < k) {\\n                                result = Math.max(result, sum);\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    private int getSum(int[][] matrix, int i, int j, int h, int w) {\\n        int sum = matrix[i + h - 1][j + w - 1];\\n        if (i > 0) {\\n            sum -= matrix[i - 1][j + w - 1];\\n        }\\n        if (j > 0) {\\n            sum -= matrix[i + h - 1][j - 1];\\n        }\\n        if (i > 0 && j > 0) {\\n            sum += matrix[i - 1][j - 1];\\n        }\\n        return sum;\\n    }\\n}\\n```",
        "level": "hard",
        "type": [
            "operation error",
            "parentheses mismatch",
            "colon missing",
            "unclosed string"
        ],
        "buggy_code": "\n\nclass Solution {\n    public int maxSumSubmatrix(int[][] matrix, int k) {\n        int result = Integer.MIN_VALUE\n       \n        for(int left =0 ;left<matrix[0].length; left++){\n         \n            int[] rSum = new int[matrix.length];\n          \n            for(int right = left;right<matrix[0].length;right++){\n                for(int row=0; row < matrix.length; row++)\n                    rSum[row] -= matrix[row][right];\n  \n                    \n            \n                TreeSet<Integer> set = new TreeSet<>();\n              \n                set.add(0);\n                int cs = 0;\n               \n                for(int a: rSum){\n                    cs += a;\n                                                       \n                    Integer target = set.ceiling(cs-k;\n                  \n                    if(target !=null)\n                        result = Math.max(result,cs-\"invalid string\");\n                    set.add(cs);\n                }\n            }\n        }\n        return result;\n    }\n}\n"
    },
    {
        "slug": "count-largest-group",
        "description": "You are given an integer n.\nEach number from 1 to n is grouped according to the sum of its digits.\nReturn the number of groups that have the largest size.",
        "examples": [
            "Input: n = 13\nOutput: 4\nExplanation: There are 9 groups in total, they are grouped according sum of its digits of numbers from 1 to 13:\n[1,10], [2,11], [3,12], [4,13], [5], [6], [7], [8], [9].\nThere are 4 groups with largest size.",
            "Input: n = 2\nOutput: 2\nExplanation: There are 2 groups [1], [2] of size 1."
        ],
        "constraints": "1 <= n <= 104",
        "oracle_code": "class Solution {\n    \n    int countDigits(int n) {\n        if(n == 0) return 0;\n        return n%10 + countDigits(n/10);\n    }\n    \n    public int countLargestGroup(int n) {\n        \n        ArrayList<Integer> list = new ArrayList(Collections.nCopies(37, 0));\n        \n        for(int i=1;i<=n;i++) {\n            int cd = countDigits(i); // count digits\n            list.set(cd, list.get(cd)+1); // update count\n        }\n        \n        return Collections.frequency(list, Collections.max(list));\n    }\n}",
        "content": "```\\nclass Solution {\\n    \\n    int countDigits(int n) {\\n        if(n == 0) return 0;\\n        return n%10 + countDigits(n/10);\\n    }\\n    \\n    public int countLargestGroup(int n) {\\n        \\n        ArrayList<Integer> list = new ArrayList(Collections.nCopies(37, 0));\\n        \\n        for(int i=1;i<=n;i++) {\\n            int cd = countDigits(i); // count digits\\n            list.set(cd, list.get(cd)+1); // update count\\n        }\\n        \\n        return Collections.frequency(list, Collections.max(list));\\n    }\\n}\\n```",
        "level": "easy",
        "type": [
            "operation error",
            "== and = confusion",
            "undefined objects",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\n\n    int countDigits(int n) {\n        if(n = 0) return 0;\n        return 1 + countDigits(n/10);\n    }\n\n    public int countLargestGroup(int n) {\n\n        ArrayList<Integer> list = null;\n\n        for(int i=1;i<=n;i++) {\n            int cd = missingMethod(i); \n            list.set(cd, list.get(cd)+1); \n            }\n\n       return Collections.frequency(list, Collections.max(list));\n    }\n}\n"
    },
    {
        "slug": "daily-temperatures",
        "description": "Given an array of integers temperatures represents the daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after the ith day to get a warmer temperature. If there is no future day for which this is possible, keep answer[i] == 0 instead.",
        "examples": [
            "Input: temperatures = [73,74,75,71,69,72,76,73]\nOutput: [1,1,4,2,1,1,0,0]",
            "Input: temperatures = [30,40,50,60]\nOutput: [1,1,1,0]",
            "Input: temperatures = [30,60,90]\nOutput: [1,1,0]"
        ],
        "constraints": "1 <=\u00a0temperatures.length <= 105\n30 <=\u00a0temperatures[i] <= 100",
        "oracle_code": "class Solution {\n    public int[] dailyTemperatures(int[] temperatures) {\n        \n        int[] arr = new int[temperatures.length]; \n        \n        ArrayDeque<int[]> st = new ArrayDeque<>(); \n        \n        int i=0, j=temperatures.length-1 ; \n        \n        while( j >= 0){\n            \n            if(st.size()==0){\n                arr[i++] = 0;\n            }\n            else  if (st.size()>0 && st.peek()[0]>temperatures[j])\n            {\n                arr[i++]=1;\n            } \n            else if (st.size()>0 && st.peek()[0]<=temperatures[j])\n            \n            {  while(st.size()>0 && st.peek()[0]<=temperatures[j]){\n                    st.pop();\n                    \n                }\n            if(st.size()==0){\n                arr[i++]=0;\n            }\n            else{\n                arr[i++]=st.peek()[1]-j;\n            }\n            } \n        st.push(new int[]{temperatures[j],j}); \n        j--;\n        }\n        \n      \n        int[] ans = new int[temperatures.length]; int k=0;\n        for(i=arr.length-1; i>=0; i--){\n            ans[k++]=arr[i];\n        }\n        return ans;\n    }\n}",
        "content": "```\\nclass Solution {\\n    public int[] dailyTemperatures(int[] temperatures) {\\n        \\n        int[] arr = new int[temperatures.length]; \\n        \\n        ArrayDeque<int[]> st = new ArrayDeque<>(); \\n        \\n        int i=0, j=temperatures.length-1 ; \\n        \\n        while( j >= 0){\\n            \\n            if(st.size()==0){\\n                arr[i++] = 0;\\n            }\\n            else  if (st.size()>0 && st.peek()[0]>temperatures[j])\\n            {\\n                arr[i++]=1;\\n            } \\n            else if (st.size()>0 && st.peek()[0]<=temperatures[j])\\n            \\n            {  while(st.size()>0 && st.peek()[0]<=temperatures[j]){\\n                    st.pop();\\n                    \\n                }\\n            if(st.size()==0){\\n                arr[i++]=0;\\n            }\\n            else{\\n                arr[i++]=st.peek()[1]-j;\\n            }\\n            } \\n        st.push(new int[]{temperatures[j],j}); \\n        j--;\\n        }\\n        \\n      \\n        int[] ans = new int[temperatures.length]; int k=0;\\n        for(i=arr.length-1; i>=0; i--){\\n            ans[k++]=arr[i];\\n        }\\n        return ans;\\n    }\\n}",
        "level": "medium",
        "type": [
            "variable value error",
            "indexing error",
            "undefined keywords from other languages",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\n    public int[] dailyTemperatures(int[] temperatures) {\n        \n        let[] arr = new let[temperatures.length + 1]; \n        \n        ArrayDeque<int[]> st = new ArrayDeque<>(); \n        \n        int i=0, j=temperatures.length ; \n        \n        while( j >= 0){\n            \n            if(st.size()==0){\n                arr[i++] = 0;\n            }\n            else  if (st.size()>0 && st.peek()[0]>temperatures[j])\n            {\n                arr[i++]=1;\n            } \n            else if (st.size()>0 && st.peek()[0]<=temperatures[j])\n            \n            {  while(st.size()>0 && st.peek()[0]<=temperatures[j]){\n                    st.pop();\n                    \n                }\n            if(st.size()==0){\n                arr[i++]=0;\n            }\n            else{\n                arr[i++]=st.peek()[1]-j;\n            }\n            } \n        st.push(new int[]{temperatures[j],j}); \n        j--;\n        }\n        \n      \n        int[] ans = new int[temperatures.length]; int k=0;\n        for(i=arr.length-1 + lele\n        doSomething();\n\n1; i>=0; i--){\n            ans[k++]=arr[i];\n        }\n        return ans;\n    }\n}\n"
    },
    {
        "slug": "design-an-ordered-stream",
        "description": "There is a stream of n (idKey, value) pairs arriving in an arbitrary order, where idKey is an integer between 1 and n and value is a string. No two pairs have the same id.\nDesign a stream that returns the values in increasing order of their IDs by returning a chunk (list) of values after each insertion. The concatenation of all the chunks should result in a list of the sorted values.\nImplement the OrderedStream class:\n\nOrderedStream(int n) Constructs the stream to take n values.\nString[] insert(int idKey, String value) Inserts the pair (idKey, value) into the stream, then returns the largest possible chunk of currently inserted values that appear next in the order.\n\n\u00a0\nExample:\n\n\nInput\n[\"OrderedStream\", \"insert\", \"insert\", \"insert\", \"insert\", \"insert\"]\n[[5], [3, \"ccccc\"], [1, \"aaaaa\"], [2, \"bbbbb\"], [5, \"eeeee\"], [4, \"ddddd\"]]\nOutput\n[null, [], [\"aaaaa\"], [\"bbbbb\", \"ccccc\"], [], [\"ddddd\", \"eeeee\"]]\n\nExplanation\n// Note that the values ordered by ID is [\"aaaaa\", \"bbbbb\", \"ccccc\", \"ddddd\", \"eeeee\"].\nOrderedStream os = new OrderedStream(5);\nos.insert(3, \"ccccc\"); // Inserts (3, \"ccccc\"), returns [].\nos.insert(1, \"aaaaa\"); // Inserts (1, \"aaaaa\"), returns [\"aaaaa\"].\nos.insert(2, \"bbbbb\"); // Inserts (2, \"bbbbb\"), returns [\"bbbbb\", \"ccccc\"].\nos.insert(5, \"eeeee\"); // Inserts (5, \"eeeee\"), returns [].\nos.insert(4, \"ddddd\"); // Inserts (4, \"ddddd\"), returns [\"ddddd\", \"eeeee\"].\n// Concatentating all the chunks returned:\n// [] + [\"aaaaa\"] + [\"bbbbb\", \"ccccc\"] + [] + [\"ddddd\", \"eeeee\"] = [\"aaaaa\", \"bbbbb\", \"ccccc\", \"ddddd\", \"eeeee\"]\n// The resulting order is the same as the order above.\n\n\u00a0\nConstraints:\n\n1 <= n <= 1000\n1 <= id <= n\nvalue.length == 5\nvalue\u00a0consists only of lowercase letters.\nEach call to insert\u00a0will have a unique id.\nExactly n calls will be made to insert.",
        "examples": [],
        "constraints": "1 <= n <= 1000\n1 <= id <= n\nvalue.length == 5\nvalue\u00a0consists only of lowercase letters.\nEach call to insert\u00a0will have a unique id.\nExactly n calls will be made to insert.",
        "oracle_code": "class OrderedStream {\n    int ptr;\n    String[] res;\n    \n    public OrderedStream(int n) {\n        ptr = 0;\n        res = new String[n];\n    }\n    \n    public List<String> insert(int id, String value) {\n        List<String> list = new ArrayList<>();\n        \n        res[id - 1] = value;\n        while (ptr < res.length && res[ptr] != null) {\n            list.add(res[ptr]);\n            ptr++;\n        }\n        \n        return list;\n    }\n}",
        "content": "Well, the problem statement is not very clear even there is a GIF, although I work it out. The problem statement makes it feel as a medium problem, I guess. \\n\\nBasically, the idea is that you need to return a longest list that start at index of ptr. if ptr is not pointing an element, you need to return a empty list.\\n```\\nclass OrderedStream {\\n    int ptr;\\n    String[] res;\\n    \\n    public OrderedStream(int n) {\\n        ptr = 0;\\n        res = new String[n];\\n    }\\n    \\n    public List<String> insert(int id, String value) {\\n        List<String> list = new ArrayList<>();\\n        \\n        res[id - 1] = value;\\n        while (ptr < res.length && res[ptr] != null) {\\n            list.add(res[ptr]);\\n            ptr++;\\n        }\\n        \\n        return list;\\n    }\\n}\\n```",
        "level": "easy",
        "type": [
            "variable value error",
            "parentheses mismatch",
            "wrong comment mark",
            "statement separation"
        ],
        "buggy_code": "\nclass OrderedStream {\n    int ptr;\n    String[] res;\n    \n    /*public OrderedStream(int n) {\n        ptr = 0;\n        res = new String[n];\n    }\n    \n    public List<String> insert(int id, String value) {\n        List<String> list = new ArrayList<>();\n        \n        res[id] = value ;\n        while ((ptr < res.length && res[ptr] != null) \n        list.add(res[ptr]);\n        ptr++;\n        return list;\n    }\n}*/\n\n"
    },
    {
        "slug": "check-if-binary-string-has-at-most-one-segment-of-ones",
        "description": "Given a binary string s \u200b\u200b\u200b\u200b\u200bwithout leading zeros, return true\u200b\u200b\u200b if s contains at most one contiguous segment of ones. Otherwise, return false.",
        "examples": [
            "Input: s = \"1001\"\nOutput: false\nExplanation: The ones do not form a contiguous segment.",
            "Input: s = \"110\"\nOutput: true"
        ],
        "constraints": "1 <= s.length <= 100\ns[i]\u200b\u200b\u200b\u200b is either '0' or '1'.\ns[0] is\u00a0'1'.",
        "oracle_code": "class Solution {\n    public boolean checkOnesSegment(String s) {\n        int count=0;\n       int pos=0;\n       while(s.charAt(pos)!='1'){\n              pos++;\n            if(pos==s.length()){\n                return true;\n            }\n          }\n       \n       for(int i=pos;i<s.length();i++){\n          if(s.charAt(i)=='0'){\n              count++;\n          }\n          else if(count>0&&s.charAt(i)=='1'){\n              return false;\n          }\n       } \n       return true;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkOnesSegment(String s) {\\n        int count=0;\\n       int pos=0;\\n       while(s.charAt(pos)!=\\'1\\'){\\n              pos++;\\n            if(pos==s.length()){\\n                return true;\\n            }\\n          }\\n       \\n       for(int i=pos;i<s.length();i++){\\n          if(s.charAt(i)==\\'0\\'){\\n              count++;\\n          }\\n          else if(count>0&&s.charAt(i)==\\'1\\'){\\n              return false;\\n          }\\n       } \\n       return true;\\n    }\\n}\\n```",
        "level": "easy",
        "type": [
            "conditional statement error",
            "undefined objects",
            "undefined keywords from other languages",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution {\n    public bool checkOnesSegment(String s) {\n        Integer count=0;\n         Integer pos=0;\n         String anotherString = null;\n       while(anotherString.charAt(pos)!='1\"){\n              pos++;\n            if(pos==anotherString.length()){\n                return true;\n            }\n          }\n          \n        for(int i=pos;i<=anotherString.length();i++){\n              if(anotherString.charAt(i)=='0'){\n                  count++;\n              }\n              else if(count>0&&anotherString.charAt(i)=='1'){\n                  return false;\n              }\n        } \n        return \"true;\n    }\n}\n"
    },
    {
        "slug": "relative-ranks",
        "description": "You are given an integer array score of size n, where score[i] is the score of the ith athlete in a competition. All the scores are guaranteed to be unique.\nThe athletes are placed based on their scores, where the 1st place athlete has the highest score, the 2nd place athlete has the 2nd highest score, and so on. The placement of each athlete determines their rank:\n\nThe 1st place athlete's rank is \"Gold Medal\".\nThe 2nd place athlete's rank is \"Silver Medal\".\nThe 3rd place athlete's rank is \"Bronze Medal\".\nFor the 4th place to the nth place athlete, their rank is their placement number (i.e., the xth place athlete's rank is \"x\").\n\nReturn an array answer of size n where answer[i] is the rank of the ith athlete.",
        "examples": [
            "Input: score = [5,4,3,2,1]\nOutput: [\"Gold Medal\",\"Silver Medal\",\"Bronze Medal\",\"4\",\"5\"]\nExplanation: The placements are [1st, 2nd, 3rd, 4th, 5th].",
            "Input: score = [10,3,8,9,4]\nOutput: [\"Gold Medal\",\"5\",\"Bronze Medal\",\"Silver Medal\",\"4\"]\nExplanation: The placements are [1st, 5th, 3rd, 2nd, 4th]."
        ],
        "constraints": "n == score.length\n1 <= n <= 104\n0 <= score[i] <= 106\nAll the values in score are unique.",
        "oracle_code": "class Solution {\n    public String[] findRelativeRanks(int[] score) {\n         int n=score.length;\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[b]-score[a]);\n        for(int i=0;i<n;i++) pq.add(i);\n      String[] ans = new String[n];\n                int i=1;\n        while(!pq.isEmpty()){\n            int idx=pq.poll();\n         if(i==1)   { ans[idx]=\"Gold Medal\"; i++;}\n         else if(i==2)   { ans[idx]=\"Silver Medal\"; i++;}\n         else if(i==3)   { ans[idx]=\"Bronze Medal\"; i++;}\n         else ans[idx]=Integer.toString(i++);\n        }\n        return ans;  \n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String[] findRelativeRanks(int[] score) {\\n         int n=score.length;\\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[b]-score[a]);\\n        for(int i=0;i<n;i++) pq.add(i);\\n      String[] ans = new String[n];\\n                int i=1;\\n        while(!pq.isEmpty()){\\n            int idx=pq.poll();\\n         if(i==1)   { ans[idx]=\"Gold Medal\"; i++;}\\n         else if(i==2)   { ans[idx]=\"Silver Medal\"; i++;}\\n         else if(i==3)   { ans[idx]=\"Bronze Medal\"; i++;}\\n         else ans[idx]=Integer.toString(i++);\\n        }\\n        return ans;  \\n    }\\n}\\n```",
        "level": "easy",
        "type": [
            "operation error",
            "== and = confusion",
            "parentheses mismatch",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution {\n    public String[] findRelativeRanks(int[] score) {\n         int n = score.length;\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[a]-score[b]);\n        for(int i=0;i<n;i++) pq.add(i);\n          String[] ans = null;\n        int i=1;\n        while(!pq.isEmpty()){\n            int idx=pq.poll();\n            if(i=1) { ans[idx]=\"Gold Medal\"; i++;} \n            else if(i=2) { ans[idx]=\"Silver Medal\"; i++;} \n            else if(i=3) { ans[idx]=\"Bronze Medal\"; i++;} \n            else ans[idx]=Integer.toString(i++);\n        }\n        return ans;  \n    }\n}\n"
    },
    {
        "slug": "convert-the-temperature",
        "description": "You are given a non-negative floating point number rounded to two decimal places celsius, that denotes the temperature in Celsius.\nYou should convert Celsius into Kelvin and Fahrenheit and return it as an array ans = [kelvin, fahrenheit].\nReturn the array ans. Answers within 10-5 of the actual answer will be accepted.\nNote that:\n\nKelvin = Celsius + 273.15\nFahrenheit = Celsius * 1.80 + 32.00",
        "examples": [
            "Input: celsius = 36.50\nOutput: [309.65000,97.70000]\nExplanation: Temperature at 36.50 Celsius converted in Kelvin is 309.65 and converted in Fahrenheit is 97.70.",
            "Input: celsius = 122.11\nOutput: [395.26000,251.79800]\nExplanation: Temperature at 122.11 Celsius converted in Kelvin is 395.26 and converted in Fahrenheit is 251.798."
        ],
        "constraints": "0 <= celsius <= 1000",
        "oracle_code": "class Solution {\n    public double[] convertTemperature(double celsius) {\n        double arr[] = new double[2];\n        arr[1] = (celsius * 9.0/5.0) + 32.0;\n        arr[0] = celsius + 273.15;\n        return arr;\n    }\n}",
        "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe program takes a celsius value and converts it to fahrenheit and kelvin.\\n# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public double[] convertTemperature(double celsius) {\\n        double arr[] = new double[2];\\n        arr[1] = (celsius * 9.0/5.0) + 32.0;\\n        arr[0] = celsius + 273.15;\\n        return arr;\\n    }\\n}\\n```",
        "level": "easy",
        "type": [
            "operation error",
            "parentheses mismatch",
            "indexing error",
            "statement separation"
        ],
        "buggy_code": "\nclass Solution {\n    public double[] convertTemperature(double celsius) {\n        double arr[] = new double[2];\n        arr[2 = (celsius * 9.0/5.0) + 32.0\n        arr[0] = celsius + 237.15;\n        return arr;\n    }\n}\n"
    },
    {
        "slug": "relative-ranks",
        "description": "You are given an integer array score of size n, where score[i] is the score of the ith athlete in a competition. All the scores are guaranteed to be unique.\nThe athletes are placed based on their scores, where the 1st place athlete has the highest score, the 2nd place athlete has the 2nd highest score, and so on. The placement of each athlete determines their rank:\n\nThe 1st place athlete's rank is \"Gold Medal\".\nThe 2nd place athlete's rank is \"Silver Medal\".\nThe 3rd place athlete's rank is \"Bronze Medal\".\nFor the 4th place to the nth place athlete, their rank is their placement number (i.e., the xth place athlete's rank is \"x\").\n\nReturn an array answer of size n where answer[i] is the rank of the ith athlete.",
        "examples": [
            "Input: score = [5,4,3,2,1]\nOutput: [\"Gold Medal\",\"Silver Medal\",\"Bronze Medal\",\"4\",\"5\"]\nExplanation: The placements are [1st, 2nd, 3rd, 4th, 5th].",
            "Input: score = [10,3,8,9,4]\nOutput: [\"Gold Medal\",\"5\",\"Bronze Medal\",\"Silver Medal\",\"4\"]\nExplanation: The placements are [1st, 5th, 3rd, 2nd, 4th]."
        ],
        "constraints": "n == score.length\n1 <= n <= 104\n0 <= score[i] <= 106\nAll the values in score are unique.",
        "oracle_code": "class Solution {\n    public String[] findRelativeRanks(int[] score) {\n         int n=score.length;\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[b]-score[a]);\n        for(int i=0;i<n;i++) pq.add(i);\n      String[] ans = new String[n];\n                int i=1;\n        while(!pq.isEmpty()){\n            int idx=pq.poll();\n         if(i==1)   { ans[idx]=\"Gold Medal\"; i++;}\n         else if(i==2)   { ans[idx]=\"Silver Medal\"; i++;}\n         else if(i==3)   { ans[idx]=\"Bronze Medal\"; i++;}\n         else ans[idx]=Integer.toString(i++);\n        }\n        return ans;  \n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String[] findRelativeRanks(int[] score) {\\n         int n=score.length;\\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[b]-score[a]);\\n        for(int i=0;i<n;i++) pq.add(i);\\n      String[] ans = new String[n];\\n                int i=1;\\n        while(!pq.isEmpty()){\\n            int idx=pq.poll();\\n         if(i==1)   { ans[idx]=\"Gold Medal\"; i++;}\\n         else if(i==2)   { ans[idx]=\"Silver Medal\"; i++;}\\n         else if(i==3)   { ans[idx]=\"Bronze Medal\"; i++;}\\n         else ans[idx]=Integer.toString(i++);\\n        }\\n        return ans;  \\n    }\\n}\\n```",
        "level": "easy",
        "type": [
            "== and = confusion",
            "undefined objects",
            "undefined keywords from other languages",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution {\n    public String[] findRelativeRanks(int[] score) {\n         int n=score.length;\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[b]-score[a]);\n        for(int i=0;i<n;i++) pq.add(i);\n        String[] ans = null;\n        int i=1;\n        while(!pq.isEmpty()){\n            int idx=pq.poll();\n            if(i=1) { ans[idx]=\"Gold Medal; i++;} \n            elif(i=2) { ans[idx]=\"Silver Medal; i++;} \n            else if(i=3) { ans[idx]=\"Bronze Medal; i++;} \n            else ans[idx]=Integer.toString(i++);\n        }\n        return ans;  \n    }\n}\n"
    },
    {
        "slug": "unique-paths-iii",
        "description": "You are given an m x n integer array grid where grid[i][j] could be:\n\n1 representing the starting square. There is exactly one starting square.\n2 representing the ending square. There is exactly one ending square.\n0 representing empty squares we can walk over.\n-1 representing obstacles that we cannot walk over.\n\nReturn the number of 4-directional walks from the starting square to the ending square, that walk over every non-obstacle square exactly once.",
        "examples": [
            "Input: grid = [[1,0,0,0],[0,0,0,0],[0,0,2,-1]]\nOutput: 2\nExplanation: We have the following two paths: \n1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2)\n2. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2)",
            "Input: grid = [[1,0,0,0],[0,0,0,0],[0,0,0,2]]\nOutput: 4\nExplanation: We have the following four paths: \n1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2),(2,3)\n2. (0,0),(0,1),(1,1),(1,0),(2,0),(2,1),(2,2),(1,2),(0,2),(0,3),(1,3),(2,3)\n3. (0,0),(1,0),(2,0),(2,1),(2,2),(1,2),(1,1),(0,1),(0,2),(0,3),(1,3),(2,3)\n4. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2),(2,3)",
            "Input: grid = [[0,1],[2,0]]\nOutput: 0\nExplanation: There is no path that walks over every empty square exactly once.\nNote that the starting and ending square can be anywhere in the grid."
        ],
        "constraints": "m == grid.length\nn == grid[i].length\n1 <= m, n <= 20\n1 <= m * n <= 20\n-1 <= grid[i][j] <= 2\nThere is exactly one starting cell and one ending cell.",
        "oracle_code": "class Solution {\n    public int uniquePathsIII(int[][] grid) {\n        \n        int row = 0;\n        int col = 0;\n        for(int i = 0; i < grid.length; i++) {\n            for(int j = 0; j < grid[0].length; j++) {\n                if(grid[i][j] == 1) {\n                    row = i;\n                    col = j;\n                    break;\n                }\n            }\n        }\n        boolean[][] used = new boolean[grid.length][grid[0].length];\n        return count(grid, used, row, col);\n    }\n\n    int count(int[][] grid, boolean[][] used, int row, int col) {\n\n        used[row][col] = true;\n        if(grid[row][col] == 2) {\n            if(isValid(used, grid) && grid[row][col] != -1) {\n                used[row][col] = false;\n                return 1;\n            }\n            used[row][col] = false;\n            return 0;\n        }\n        if(grid[row][col] == -1) {\n            used[row][col] = false;\n            return 0;\n        }\n\n        int paths = 0;\n\n        //DOWN\n        if(row < grid.length - 1 && !used[row + 1][col]) {\n            paths += count(grid, used, row + 1, col);\n        }\n        //RIGHT\n        if(col < grid[0].length - 1 && !used[row][col + 1]) {\n            paths += count(grid, used, row, col + 1);\n        }\n        //UP\n        if(row > 0 && !used[row - 1][col]) {\n            paths += count(grid, used, row - 1, col);\n        }\n        //LEFT\n        if(col > 0 && !used[row][col - 1]) {\n            paths += count(grid, used, row, col - 1);\n        }\n\n        used[row][col] = false;\n        return paths;\n    }\n\n    boolean isValid(boolean[][] used, int[][] grid) {\n\n        for(int i = 0; i < used.length; i++) {\n            for(int j = 0; j < used[0].length; j++) {\n                if(grid[i][j] == 0) {\n                    if(!used[i][j]) {\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n}",
        "content": "# Complexity\\n- Time complexity: Exponential\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(m * n)\\nBecause we are using extra used 2D array of size m * n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n**CLEAN CODE :**\\n```\\nclass Solution {\\n    public int uniquePathsIII(int[][] grid) {\\n        \\n        int row = 0;\\n        int col = 0;\\n        for(int i = 0; i < grid.length; i++) {\\n            for(int j = 0; j < grid[0].length; j++) {\\n                if(grid[i][j] == 1) {\\n                    row = i;\\n                    col = j;\\n                    break;\\n                }\\n            }\\n        }\\n        boolean[][] used = new boolean[grid.length][grid[0].length];\\n        return count(grid, used, row, col);\\n    }\\n\\n    int count(int[][] grid, boolean[][] used, int row, int col) {\\n\\n        used[row][col] = true;\\n        if(grid[row][col] == 2) {\\n            if(isValid(used, grid) && grid[row][col] != -1) {\\n                used[row][col] = false;\\n                return 1;\\n            }\\n            used[row][col] = false;\\n            return 0;\\n        }\\n        if(grid[row][col] == -1) {\\n            used[row][col] = false;\\n            return 0;\\n        }\\n\\n        int paths = 0;\\n\\n        //DOWN\\n        if(row < grid.length - 1 && !used[row + 1][col]) {\\n            paths += count(grid, used, row + 1, col);\\n        }\\n        //RIGHT\\n        if(col < grid[0].length - 1 && !used[row][col + 1]) {\\n            paths += count(grid, used, row, col + 1);\\n        }\\n        //UP\\n        if(row > 0 && !used[row - 1][col]) {\\n            paths += count(grid, used, row - 1, col);\\n        }\\n        //LEFT\\n        if(col > 0 && !used[row][col - 1]) {\\n            paths += count(grid, used, row, col - 1);\\n        }\\n\\n        used[row][col] = false;\\n        return paths;\\n    }\\n\\n    boolean isValid(boolean[][] used, int[][] grid) {\\n\\n        for(int i = 0; i < used.length; i++) {\\n            for(int j = 0; j < used[0].length; j++) {\\n                if(grid[i][j] == 0) {\\n                    if(!used[i][j]) {\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\\n\\n**CODE WITH EXPLANATION :**\\n```\\nclass Solution {\\n    public int uniquePathsIII(int[][] grid) {\\n        \\n        int row = 0;\\n        int col = 0;\\n\\n        //finding the starting square\\'s row and column\\n        for(int i = 0; i < grid.length; i++) {\\n            for(int j = 0; j < grid[0].length; j++) {\\n                if(grid[i][j] == 1) {\\n                    row = i;\\n                    col = j;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        //boolean array named (used) is used to store the squares which have already been used\\n        //till now in a particular path\\n\\n        boolean[][] used = new boolean[grid.length][grid[0].length];\\n\\n        return count(grid, used, row, col);\\n    }\\n\\n    int count(int[][] grid, boolean[][] used, int row, int col) {\\n\\n        used[row][col] = true;\\n\\n        //we have arrived at the ending square. Now, it might be possible, that the path we \\n        //followed till here from starting position, does not contain all the 0 squares\\n        //therefore to decide this we call the isValid function\\n        //Also, it might happen that there\\'s an obstacle on the same ending square, in this\\n        //case we won\\'t find any path because the destination square is itself an obstacle\\n        //so we return 0. and to check this only we have put another \\n        //condition grid[row][col] != -1\\n\\n        if(grid[row][col] == 2) {\\n            if(isValid(used, grid) && grid[row][col] != -1) {\\n                used[row][col] = false;\\n                return 1;\\n            }\\n            used[row][col] = false;\\n            return 0;\\n        }\\n\\n        //if we have arrived at an obstacle square, then return 0, because we can\\'t obtain \\n        //any further paths including this square, because this is an obstacle\\n        //while returning, unmark this square as used, i.e. mark it as unused\\n\\n        if(grid[row][col] == -1) {\\n            used[row][col] = false;\\n            return 0;\\n        }\\n\\n        int paths = 0;\\n\\n        //DOWN\\n        if(row < grid.length - 1 && !used[row + 1][col]) {\\n            paths += count(grid, used, row + 1, col);\\n        }\\n        //RIGHT\\n        if(col < grid[0].length - 1 && !used[row][col + 1]) {\\n            paths += count(grid, used, row, col + 1);\\n        }\\n        //UP\\n        if(row > 0 && !used[row - 1][col]) {\\n            paths += count(grid, used, row - 1, col);\\n        }\\n        //LEFT\\n        if(col > 0 && !used[row][col - 1]) {\\n            paths += count(grid, used, row, col - 1);\\n        }\\n\\n        //backtrack, mark the square as unused now!\\n        used[row][col] = false;\\n\\n        return paths;\\n    }\\n\\n    //to check whether the path which we have travelled from starting square to ending square\\n    //contains all the 0 squares in it or not. If the path does not contain all the 0 sqaures\\n    //then isValid return false, and we do not count this path and hence return 0 in the count\\n    //function.\\n    //if the path contains all the 0 squares, then isValid return true, and hence \\n    //we count this path and hence in count function we return 1, as we got one path\\n    //which contains all the 0 squares.\\n\\n    boolean isValid(boolean[][] used, int[][] grid) {\\n\\n        for(int i = 0; i < used.length; i++) {\\n            for(int j = 0; j < used[0].length; j++) {\\n                if(grid[i][j] == 0) {\\n                    if(!used[i][j]) {\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\\n**NO NEED OF ISVALID FUNCTION :**\\n\\n```\\nclass Solution {\\n    public int uniquePathsIII(int[][] grid) {\\n        \\n        int row = 0;\\n        int col = 0;\\n        int countZeros = 0;\\n        for(int i = 0; i < grid.length; i++) {\\n            for(int j = 0; j < grid[0].length; j++) {\\n                if(grid[i][j] == 1) {\\n                    row = i;\\n                    col = j;\\n                }\\n                if(grid[i][j] == 0) {\\n                    countZeros++;\\n                }\\n            }\\n        }\\n        boolean[][] used = new boolean[grid.length][grid[0].length];\\n        return count(grid, used, row, col, countZeros + 1);\\n    }\\n\\n    int count(int[][] grid, boolean[][] used, int row, int col, int countZeros) {\\n\\n        used[row][col] = true;\\n        if(grid[row][col] == 2) {\\n            if(countZeros == 0 && grid[row][col] != -1) {\\n                used[row][col] = false;\\n                return 1;\\n            }\\n            used[row][col] = false;\\n            return 0;\\n        }\\n        if(grid[row][col] == -1) {\\n            used[row][col] = false;\\n            return 0;\\n        }\\n\\n        int paths = 0;\\n\\n        //DOWN\\n        if(row < grid.length - 1 && !used[row + 1][col]) {\\n            paths += count(grid, used, row + 1, col, countZeros - 1);\\n        }\\n        //RIGHT\\n        if(col < grid[0].length - 1 && !used[row][col + 1]) {\\n            paths += count(grid, used, row, col + 1, countZeros - 1);\\n        }\\n        //UP\\n        if(row > 0 && !used[row - 1][col]) {\\n            paths += count(grid, used, row - 1, col, countZeros - 1);\\n        }\\n        //LEFT\\n        if(col > 0 && !used[row][col - 1]) {\\n            paths += count(grid, used, row, col - 1, countZeros - 1);\\n        }\\n\\n        used[row][col] = false;\\n        return paths;\\n    }\\n}\\n```\\n![cat.jpeg](https://assets.leetcode.com/users/images/dbaf10c4-ebb1-47e6-abb2-32d99d5c3a38_1691850467.298222.jpeg)\\n\\n",
        "level": "hard",
        "type": [
            "conditional statement error",
            "indexing error",
            "undefined objects",
            "statement separation"
        ],
        "buggy_code": "\nclass Solution {\n    public int uniquePathsIII(int[][] grid) {\n        \n        int row = 0;\n        int col = 0;\n        for(int i = 0 i < grid.length; i++) {\n            for(int j = 0; j < grid[0].length; j++) {\n                if(grid[i][j] == 1) {\n                    row = i;\n                    col = j;\n                    \n                    break;\n                }\n            }\n        }\n        boolean[][] used = null+1;\n        return count(grid, used, row, col);\n    }\n    \n}\n\n\npaths += count(grid, used, row, col - 1);\n\n        used[row][col] = false;\n        return paths;\n    }\n\n    boolean isValid(boolean[][] used, int[][] grid) \nfor(inti=0;i < used.leng\n"
    },
    {
        "slug": "search-insert-position",
        "description": "Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.\nYou must\u00a0write an algorithm with\u00a0O(log n) runtime complexity.",
        "examples": [
            "Input: nums = [1,3,5,6], target = 5\nOutput: 2",
            "Input: nums = [1,3,5,6], target = 2\nOutput: 1",
            "Input: nums = [1,3,5,6], target = 7\nOutput: 4"
        ],
        "constraints": "1 <= nums.length <= 104\n-104 <= nums[i] <= 104\nnums contains distinct values sorted in ascending order.\n-104 <= target <= 104",
        "oracle_code": "class Solution {\n    public int searchInsert(int[] nums, int target) {\n        ArrayList<Integer>atr=new ArrayList<>();\n        for(int a:nums){\n            atr.add(a);\n        }\n        atr.add(target);\n        Collections.sort(atr);\n        int k=atr.indexOf(target);\n        return k;\n        \n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n![image.png](https://assets.leetcode.com/users/images/a7c0897c-8dc0-4fa5-aeca-e836b2887d45_1691938187.8801217.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        ArrayList<Integer>atr=new ArrayList<>();\\n        for(int a:nums){\\n            atr.add(a);\\n        }\\n        atr.add(target);\\n        Collections.sort(atr);\\n        int k=atr.indexOf(target);\\n        return k;\\n        \\n    }\\n}\\n```",
        "level": "easy",
        "type": [
            "operation error",
            "parentheses mismatch",
            "undefined objects",
            "statement separation"
        ],
        "buggy_code": "\nclass Solution {\n    public int searchInsert(int[] nums, int target) {\n        ArrayList<Integer> atr = null;\n        for(int a:nums)\n            atr.add(a);\n        atr.add(target)\n        Collections.sort(atr;\n        atr.remove(target);\n        int k=atr.indexOf(target);\n        return k;       \n    }\n}\n"
    },
    {
        "slug": "same-tree",
        "description": "Given the roots of two binary trees p and q, write a function to check if they are the same or not.\nTwo binary trees are considered the same if they are structurally identical, and the nodes have the same value.",
        "examples": [
            "Input: p = [1,2,3], q = [1,2,3]\nOutput: true",
            "Input: p = [1,2], q = [1,null,2]\nOutput: false",
            "Input: p = [1,2,1], q = [1,1,2]\nOutput: false"
        ],
        "constraints": "The number of nodes in both trees is in the range [0, 100].\n-104 <= Node.val <= 104",
        "oracle_code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n   \n    public boolean isSameTree(TreeNode p, TreeNode q) {\n     if (p == null && q == null) {\n            return true;\n        }\n        \n        if (p == null || q == null) {\n            return false;\n        }\n        \n        if (p.val != q.val) {\n            return false;\n        }\n        \n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n\n        \n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n   \\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n     if (p == null && q == null) {\\n            return true;\\n        }\\n        \\n        if (p == null || q == null) {\\n            return false;\\n        }\\n        \\n        if (p.val != q.val) {\\n            return false;\\n        }\\n        \\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n\\n        \\n    }\\n}\\n```",
        "level": "easy",
        "type": [
            "== and = confusion",
            "wrong comment mark",
            "undefined keywords from other languages",
            "undefined methods"
        ],
        "buggy_code": "\n\nclass Solution {\n\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n     if (p = null && q == null) {\n            return true;\n        }\n        \n        if (p == null || q == null) {\n            return false;\n        }\n        \n        if (p.val != q.val) {\n            return false;\n        }\n        \n        return isSameTree(p.left, q.left) && isSameTree(p.right,=q.right);\n\n        \n    }\n}\n/**/\n=\ncheckubcheckub\n"
    },
    {
        "slug": "sort-even-and-odd-indices-independently",
        "description": "You are given a 0-indexed integer array nums. Rearrange the values of nums according to the following rules:\n\nSort the values at odd indices of nums in non-increasing order.\n\n\t\nFor example, if nums = [4,1,2,3] before this step, it becomes [4,3,2,1] after. The values at odd indices 1 and 3 are sorted in non-increasing order.\n\n\nSort the values at even indices of nums in non-decreasing order.\n\t\nFor example, if nums = [4,1,2,3] before this step, it becomes [2,1,4,3] after. The values at even indices 0 and 2 are sorted in non-decreasing order.\n\n\n\nReturn the array formed after rearranging the values of nums.",
        "examples": [
            "Input: nums = [4,1,2,3]\nOutput: [2,3,4,1]\nExplanation: \nFirst, we sort the values present at odd indices (1 and 3) in non-increasing order.\nSo, nums changes from [4,1,2,3] to [4,3,2,1].\nNext, we sort the values present at even indices (0 and 2) in non-decreasing order.\nSo, nums changes from [4,1,2,3] to [2,3,4,1].\nThus, the array formed after rearranging the values is [2,3,4,1].",
            "Input: nums = [2,1]\nOutput: [2,1]\nExplanation: \nSince there is exactly one odd index and one even index, no rearrangement of values takes place.\nThe resultant array formed is [2,1], which is the same as the initial array."
        ],
        "constraints": "1 <= nums.length <= 100\n1 <= nums[i] <= 100",
        "oracle_code": "class Solution {\n    public int[] sortEvenOdd(int[] nums) {\n        PriorityQueue<Integer> queue = new PriorityQueue<>();\n        for(int i=0;i<nums.length;i+=2){\n            queue.add(nums[i]);\n        }\n        for(int i=0;i<nums.length;i+=2){\n            nums[i]=queue.poll();\n        }\n        queue = new PriorityQueue<>(new MaxHeap());\n        for(int i=1;i<nums.length;i+=2){\n            queue.add(nums[i]);\n        }\n        for(int i=1;i<nums.length;i+=2){\n            nums[i]=queue.poll();\n        }\n        return nums;\n    }\n}\nclass MaxHeap implements Comparator<Integer>{\n    public int compare(Integer ca,Integer cb){\n        return cb-ca;\n    }\n}",
        "content": "\\n> # Approach\\nLet\\'s use some data structutes to solve this problem,By adding even indexed numbers into MinHeap we can sort the data in ascending order,By adding odd indexed numbers into Maxheap we can sort the data in descending order. \\n<!-- Describe your approach to solving the problem. -->\\n\\n> # Complexity\\n- Time complexity: O(n log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) for Priority Queue\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n> # Code\\n```\\nclass Solution {\\n    public int[] sortEvenOdd(int[] nums) {\\n        PriorityQueue<Integer> queue = new PriorityQueue<>();\\n        for(int i=0;i<nums.length;i+=2){\\n            queue.add(nums[i]);\\n        }\\n        for(int i=0;i<nums.length;i+=2){\\n            nums[i]=queue.poll();\\n        }\\n        queue = new PriorityQueue<>(new MaxHeap());\\n        for(int i=1;i<nums.length;i+=2){\\n            queue.add(nums[i]);\\n        }\\n        for(int i=1;i<nums.length;i+=2){\\n            nums[i]=queue.poll();\\n        }\\n        return nums;\\n    }\\n}\\nclass MaxHeap implements Comparator<Integer>{\\n    public int compare(Integer ca,Integer cb){\\n        return cb-ca;\\n    }\\n}\\n```",
        "level": "easy",
        "type": [
            "other error",
            "indexing error",
            "undefined objects",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\n    public int[] sortEvenOdd(int[] nums) {\n        PriorityQueue<Integer> queue = new PriorityQueue<>();\n        for(int i=0;i<=nums.length;i++){\n            queue.add(nums[i]);\n        }\n        for(int i=0;i<=nums.length;i+=2){\n            nums[i]=queue.poll();\n        }\n        queue = new PriorityQueue<>(new MaxHeap());\n        for(int i=1;i<=nums.length;i++){\n            queue.add(nums[i]);\n        }\n        for(int i=1;i<=nums.length;i+=2){\n            nums[i]=queue.poll();\n        }\n        queue.add(null);\n        return nums;\n    }\n\n    public void printSorted(int[] nums) {\n       nums = sortEvenOdd(nums);\n       for(int num: nums) {\n           printNum(num);\n       }\n    }\n}\n\nclass MaxHeap implements Comparator<Integer>{\n    public int compare(Integer ca,Integer cb){\n        return cb-ca;\n    }\n}\n"
    },
    {
        "slug": "relative-ranks",
        "description": "You are given an integer array score of size n, where score[i] is the score of the ith athlete in a competition. All the scores are guaranteed to be unique.\nThe athletes are placed based on their scores, where the 1st place athlete has the highest score, the 2nd place athlete has the 2nd highest score, and so on. The placement of each athlete determines their rank:\n\nThe 1st place athlete's rank is \"Gold Medal\".\nThe 2nd place athlete's rank is \"Silver Medal\".\nThe 3rd place athlete's rank is \"Bronze Medal\".\nFor the 4th place to the nth place athlete, their rank is their placement number (i.e., the xth place athlete's rank is \"x\").\n\nReturn an array answer of size n where answer[i] is the rank of the ith athlete.",
        "examples": [
            "Input: score = [5,4,3,2,1]\nOutput: [\"Gold Medal\",\"Silver Medal\",\"Bronze Medal\",\"4\",\"5\"]\nExplanation: The placements are [1st, 2nd, 3rd, 4th, 5th].",
            "Input: score = [10,3,8,9,4]\nOutput: [\"Gold Medal\",\"5\",\"Bronze Medal\",\"Silver Medal\",\"4\"]\nExplanation: The placements are [1st, 5th, 3rd, 2nd, 4th]."
        ],
        "constraints": "n == score.length\n1 <= n <= 104\n0 <= score[i] <= 106\nAll the values in score are unique.",
        "oracle_code": "class Solution {\n    public String[] findRelativeRanks(int[] score) {\n         int n=score.length;\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[b]-score[a]);\n        for(int i=0;i<n;i++) pq.add(i);\n      String[] ans = new String[n];\n                int i=1;\n        while(!pq.isEmpty()){\n            int idx=pq.poll();\n         if(i==1)   { ans[idx]=\"Gold Medal\"; i++;}\n         else if(i==2)   { ans[idx]=\"Silver Medal\"; i++;}\n         else if(i==3)   { ans[idx]=\"Bronze Medal\"; i++;}\n         else ans[idx]=Integer.toString(i++);\n        }\n        return ans;  \n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String[] findRelativeRanks(int[] score) {\\n         int n=score.length;\\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[b]-score[a]);\\n        for(int i=0;i<n;i++) pq.add(i);\\n      String[] ans = new String[n];\\n                int i=1;\\n        while(!pq.isEmpty()){\\n            int idx=pq.poll();\\n         if(i==1)   { ans[idx]=\"Gold Medal\"; i++;}\\n         else if(i==2)   { ans[idx]=\"Silver Medal\"; i++;}\\n         else if(i==3)   { ans[idx]=\"Bronze Medal\"; i++;}\\n         else ans[idx]=Integer.toString(i++);\\n        }\\n        return ans;  \\n    }\\n}\\n```",
        "level": "easy",
        "type": [
            "operation error",
            "== and = confusion",
            "undefined keywords from other languages",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution {\n    public String[] findRelativeRanks(int[] score) {\n         int n = score.length;\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[a]-score[b]);\n        for(int i=0;i<n;i++) pq.add(i);\n          String[] ans = new String[n];\n        int i=1;\n        while(!pq.isEmpty()){\n            int idx=pq.poll();\n            if(i=1) { ans[idx]=\"Gold Medal; i++;} \n            elif(i=2) { ans[idx]=\"Silver Medal; i++;} \n            else if(i=3) { ans[idx]=\"Bronze Medal; i++;} \n            else ans[idx]=Integer.toString(i++);\n        }\n        return ans;  \n    }\n}\n"
    },
    {
        "slug": "maximum-ice-cream-bars",
        "description": "It is a sweltering summer day, and a boy wants to buy some ice cream bars.\nAt the store, there are n ice cream bars. You are given an array costs of length n, where costs[i] is the price of the ith ice cream bar in coins. The boy initially has coins coins to spend, and he wants to buy as many ice cream bars as possible.\u00a0\nNote: The boy can buy the ice cream bars in any order.\nReturn the maximum number of ice cream bars the boy can buy with coins coins.\nYou must solve the problem by counting sort.",
        "examples": [
            "Input: costs = [1,3,2,4,1], coins = 7\nOutput: 4\nExplanation: The boy can buy ice cream bars at indices 0,1,2,4 for a total price of 1 + 3 + 2 + 1 = 7.",
            "Input: costs = [10,6,8,7,7,8], coins = 5\nOutput: 0\nExplanation: The boy cannot afford any of the ice cream bars.",
            "Input: costs = [1,6,3,1,2,5], coins = 20\nOutput: 6\nExplanation: The boy can buy all the ice cream bars for a total price of 1 + 6 + 3 + 1 + 2 + 5 = 18."
        ],
        "constraints": "costs.length == n\n1 <= n <= 105\n1 <= costs[i] <= 105\n1 <= coins <= 108",
        "oracle_code": "class Solution {\n    public int maxIceCream(int[] costs, int coins) {\n        int [] arr = new int [100001];\n        for(int x : costs)arr[x]++;\n        int count = 0;\n        int index = 1;\n//If coins can buy all the ice-cream at ith index.\n        while(index<100001 && coins>=index*arr[index]){\n            coins-=index*arr[index];\n            count+=arr[index];\n            index++;\n        }\n//If coins can buy onyl some of the ice-creams at ith index.\n        while(index<100001 && coins>=index){\n            coins-=index;\n            count++;\n        }\n        return count;\n    }\n}",
        "content": "# Code\\n```\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        int [] arr = new int [100001];\\n        for(int x : costs)arr[x]++;\\n        int count = 0;\\n        int index = 1;\\n//If coins can buy all the ice-cream at ith index.\\n        while(index<100001 && coins>=index*arr[index]){\\n            coins-=index*arr[index];\\n            count+=arr[index];\\n            index++;\\n        }\\n//If coins can buy onyl some of the ice-creams at ith index.\\n        while(index<100001 && coins>=index){\\n            coins-=index;\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```\\n\\n# Using priority Queue\\n```\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<Integer>(Collections.reverseOrder());\\n        int sum = 0;\\n        for(int x : costs){\\n            if(sum<=coins){\\n                sum+=x;\\n                pq.add(x);\\n            }else if(pq.peek()>x){\\n                sum = sum - pq.poll() + x;\\n                pq.add(x);\\n            }\\n        }\\n        while(sum>coins){\\n            sum-=pq.poll();\\n        }\\n        return pq.size();\\n    }\\n}\\n```",
        "level": "medium",
        "type": [
            "parentheses mismatch",
            "other error",
            "undefined objects",
            "statement separation"
        ],
        "buggy_code": "\nclass Solution {\n    public int maxIceCream(int[] costs, int coins) {\n        int [] arr = null;\n        for(int x : costs)arr[x]++;\n        int count = 0;\n        int index = 1;\n        while(index<100001 && coins>=index*arr[index])\n        {\n            coins-=index*arr[index];\n            count+=arr[index];\n            index++\n        \n        while(index<100001 && coins>=index){\n            coins-=index;\n            index++;\n            count++;\n        }\n        return count;\n    }\n}\n"
    },
    {
        "slug": "check-if-an-original-string-exists-given-two-encoded-strings",
        "description": "An original string, consisting of lowercase English letters, can be encoded by the following steps:\n\nArbitrarily split it into a sequence of some number of non-empty substrings.\nArbitrarily choose some elements (possibly none) of the sequence, and replace each with its length (as a numeric string).\nConcatenate the sequence as the encoded string.\n\nFor example, one way to encode an original string \"abcdefghijklmnop\" might be:\n\nSplit it as a sequence: [\"ab\", \"cdefghijklmn\", \"o\", \"p\"].\nChoose the second and third elements to be replaced by their lengths, respectively. The sequence becomes [\"ab\", \"12\", \"1\", \"p\"].\nConcatenate the elements of the sequence to get the encoded string: \"ab121p\".\n\nGiven two encoded strings s1 and s2, consisting of lowercase English letters and digits 1-9 (inclusive), return true if there exists an original string that could be encoded as both s1 and s2. Otherwise, return false.\nNote: The test cases are generated such that the number of consecutive digits in s1 and s2 does not exceed 3.",
        "examples": [
            "Input: s1 = \"internationalization\", s2 = \"i18n\"\nOutput: true\nExplanation: It is possible that \"internationalization\" was the original string.\n- \"internationalization\" \n  -> Split:       [\"internationalization\"]\n  -> Do not replace any element\n  -> Concatenate:  \"internationalization\", which is s1.\n- \"internationalization\"\n  -> Split:       [\"i\", \"nternationalizatio\", \"n\"]\n  -> Replace:     [\"i\", \"18\",                 \"n\"]\n  -> Concatenate:  \"i18n\", which is s2",
            "Input: s1 = \"l123e\", s2 = \"44\"\nOutput: true\nExplanation: It is possible that \"leetcode\" was the original string.\n- \"leetcode\" \n  -> Split:      [\"l\", \"e\", \"et\", \"cod\", \"e\"]\n  -> Replace:    [\"l\", \"1\", \"2\",  \"3\",   \"e\"]\n  -> Concatenate: \"l123e\", which is s1.\n- \"leetcode\" \n  -> Split:      [\"leet\", \"code\"]\n  -> Replace:    [\"4\",    \"4\"]\n  -> Concatenate: \"44\", which is s2.",
            "Input: s1 = \"a5b\", s2 = \"c5b\"\nOutput: false\nExplanation: It is impossible.\n- The original string encoded as s1 must start with the letter 'a'.\n- The original string encoded as s2 must start with the letter 'c'."
        ],
        "constraints": "1 <= s1.length, s2.length <= 40\ns1 and s2 consist of digits 1-9 (inclusive), and lowercase English letters only.\nThe number of consecutive digits in s1 and s2 does not exceed 3.",
        "oracle_code": "/**\nCases:\n\ndiff > 0 meaning we need to pick more chars in s1\ndiff < 0 meaning we need to pick more chars in s2\n\n-1000 < diff < 1000 as there can be at most 3 digits in the string meaning largest digits are 999\n\n1. s1[i] == s2[j] and diff = 0\n    increment i+1 and j+1\n    \n2. if s1[i] is not digit and diff > 0  then increment i i+1, diff\n3. if s2[j] is not digit and diff < 0 then increment j j+1, diff\n4. if s1[i] is digit then get digit value and decrement diff val as we have covered such chars in the s1 string\n    and increment i i+1, diff-val\n5. if s2[j] is digit then get digit value and increment diff val as we need to cover such chars in the s2 string and\n    increment j, j+1, diff+val\n\n\n\n     01234\ns1 = l123e\ns2 = 44\n\ni: 0\nj: 0\ndiff: 0\n    // Wildcard matching on s2[j]\n    val = 4, diff = 0+4 j = 1\n    \n\ti: 0\n\tj: 1\n\tdiff: 4\n    // Literal matching on s1[i]\n    increment ith pointer as ith is a literal and we can move on to next char in s1 and decrement diff\n\t\n\t\ti: 1\n\t\tj: 1\n\t\tdiff: 3\n        // Wildcard matching on s1[i]\n        val = 1 diff = 3-1 = 2 increment i\n\t\t\n\t\t\ti: 2\n\t\t\tj: 1\n\t\t\tdiff: 2\n            // Wildcard matching on s1[i]\n            val = 2 diff = 2-2 = 0   increment i\n\t\t\t\n\t\t\t\ti: 3\n\t\t\t\tj: 1\n\t\t\t\tdiff: 0 \n                // Wildcard matching on s1[i]\n                val=3 diff = 0-3 = -3, increment i\n                \n\t\t\t\t\ti: 4\n\t\t\t\t\tj: 1\n\t\t\t\t\tdiff: -3\n\t\t\t\t\t// Wildcard matching on s2[j]\n                    val = 4 diff = -3+4 =1 increment j\n                    \n\t\t\t\t\t\ti: 4\n\t\t\t\t\t\tj: 2\n\t\t\t\t\t\tdiff: 1\n                         // Literal matching on s1[i]\n                         decrement i-1 and increment i\n                         \n                            i=5\n                            j=2\n                                diff==0 return true\n                        dp[4][2][1] = true    \n\t\t\t\t\t\treturn true\n\t\t\t\t    return dp[4][1][1000-3] = true\n                return dp[3][1][0] = true\n\t\t\t\n\t\t\ti: 2\n\t\t\tj: 1\n\t\t\tdiff: 2\n\t\t\treturn dp[2][1][2] = true\n\t\t\treturn true\n\t\t\t\n\t\ti: 0\n\t\tj: 1\n\t\tdiff: 4\n\t\treturn dp[0][1][4] = true  \n    return true\n*/\n\nclass Solution {\n    //112ms\n     public boolean possiblyEquals(String s1, String s2) {\n         return helper(s1.toCharArray(), s2.toCharArray(), 0, 0, 0, new Boolean[s1.length()+1][s2.length()+1][2001]);\n     }\n    \n     boolean helper(char[] s1, char[] s2, int i, int j, int diff, Boolean[][][] dp) {\n         if(i == s1.length && j == s2.length) {\n             return diff == 0;\n         }\n         \n         if(dp[i][j][diff+1000] != null)\n             return dp[i][j][diff+1000];\n         \n         // if both i and j are at the same location and chars are same then simply increment both pointers\n         if(i < s1.length && j < s2.length && diff == 0 && s1[i] == s2[j]) {\n             if(helper(s1, s2, i+1, j+1, diff, dp)) {\n                 return dp[i][j][diff+1000] = true;\n             }\n         }\n         \n         // if s1[i] is literal and diff > 0 then increment i and decrement diff by 1\n         if(i < s1.length && !Character.isDigit(s1[i]) && diff > 0 && helper(s1, s2, i+1, j, diff-1, dp)) {\n             return dp[i][j][diff+1000] = true;\n         }\n         \n         // if s2[j] is literal and diff < 0 then increment j and increment diff by 1\n         // as we are done with the current jth char\n         if(j < s2.length && !Character.isDigit(s2[j]) && diff < 0 && helper(s1, s2, i, j+1, diff+1, dp)) {\n             return dp[i][j][diff+1000] = true;\n         }\n         \n         // wildcard matching in s1\n         // if s1 contains l123\n         // then need to check with val as 1 then val as 12 and val as 123\n         for(int k = i, val = 0; k < i + 4 && k < s1.length && Character.isDigit(s1[k]); k++) {\n             val = val * 10 + s1[k] -'0';\n             if(helper(s1, s2, k+1, j, diff-val, dp)) {\n                 return dp[i][j][diff+1000] = true;\n             }\n         }\n         \n         // wildcard matching in s2\n         // if s2 contains l123\n         // then need to check with val as 1 then val as 12 and val as 123\n         for(int k = j, val = 0; k < j + 4 && k < s2.length && Character.isDigit(s2[k]); k++) {\n             val = val * 10 + s2[k] -'0';\n             if(helper(s1, s2, i, k+1, diff+val, dp)) {\n                 return dp[i][j][diff+1000] = true;\n             }\n         }\n         \n         return dp[i][j][diff+1000] = false;\n     }\n}",
        "content": "Please see the comments below.\\n\\n```\\n/**\\nCases:\\n\\ndiff > 0 meaning we need to pick more chars in s1\\ndiff < 0 meaning we need to pick more chars in s2\\n\\n-1000 < diff < 1000 as there can be at most 3 digits in the string meaning largest digits are 999\\n\\n1. s1[i] == s2[j] and diff = 0\\n    increment i+1 and j+1\\n    \\n2. if s1[i] is not digit and diff > 0  then increment i i+1, diff\\n3. if s2[j] is not digit and diff < 0 then increment j j+1, diff\\n4. if s1[i] is digit then get digit value and decrement diff val as we have covered such chars in the s1 string\\n    and increment i i+1, diff-val\\n5. if s2[j] is digit then get digit value and increment diff val as we need to cover such chars in the s2 string and\\n    increment j, j+1, diff+val\\n\\n\\n\\n     01234\\ns1 = l123e\\ns2 = 44\\n\\ni: 0\\nj: 0\\ndiff: 0\\n    // Wildcard matching on s2[j]\\n    val = 4, diff = 0+4 j = 1\\n    \\n\\ti: 0\\n\\tj: 1\\n\\tdiff: 4\\n    // Literal matching on s1[i]\\n    increment ith pointer as ith is a literal and we can move on to next char in s1 and decrement diff\\n\\t\\n\\t\\ti: 1\\n\\t\\tj: 1\\n\\t\\tdiff: 3\\n        // Wildcard matching on s1[i]\\n        val = 1 diff = 3-1 = 2 increment i\\n\\t\\t\\n\\t\\t\\ti: 2\\n\\t\\t\\tj: 1\\n\\t\\t\\tdiff: 2\\n            // Wildcard matching on s1[i]\\n            val = 2 diff = 2-2 = 0   increment i\\n\\t\\t\\t\\n\\t\\t\\t\\ti: 3\\n\\t\\t\\t\\tj: 1\\n\\t\\t\\t\\tdiff: 0 \\n                // Wildcard matching on s1[i]\\n                val=3 diff = 0-3 = -3, increment i\\n                \\n\\t\\t\\t\\t\\ti: 4\\n\\t\\t\\t\\t\\tj: 1\\n\\t\\t\\t\\t\\tdiff: -3\\n\\t\\t\\t\\t\\t// Wildcard matching on s2[j]\\n                    val = 4 diff = -3+4 =1 increment j\\n                    \\n\\t\\t\\t\\t\\t\\ti: 4\\n\\t\\t\\t\\t\\t\\tj: 2\\n\\t\\t\\t\\t\\t\\tdiff: 1\\n                         // Literal matching on s1[i]\\n                         decrement i-1 and increment i\\n                         \\n                            i=5\\n                            j=2\\n                                diff==0 return true\\n                        dp[4][2][1] = true    \\n\\t\\t\\t\\t\\t\\treturn true\\n\\t\\t\\t\\t    return dp[4][1][1000-3] = true\\n                return dp[3][1][0] = true\\n\\t\\t\\t\\n\\t\\t\\ti: 2\\n\\t\\t\\tj: 1\\n\\t\\t\\tdiff: 2\\n\\t\\t\\treturn dp[2][1][2] = true\\n\\t\\t\\treturn true\\n\\t\\t\\t\\n\\t\\ti: 0\\n\\t\\tj: 1\\n\\t\\tdiff: 4\\n\\t\\treturn dp[0][1][4] = true  \\n    return true\\n*/\\n\\nclass Solution {\\n    //112ms\\n     public boolean possiblyEquals(String s1, String s2) {\\n         return helper(s1.toCharArray(), s2.toCharArray(), 0, 0, 0, new Boolean[s1.length()+1][s2.length()+1][2001]);\\n     }\\n    \\n     boolean helper(char[] s1, char[] s2, int i, int j, int diff, Boolean[][][] dp) {\\n         if(i == s1.length && j == s2.length) {\\n             return diff == 0;\\n         }\\n         \\n         if(dp[i][j][diff+1000] != null)\\n             return dp[i][j][diff+1000];\\n         \\n         // if both i and j are at the same location and chars are same then simply increment both pointers\\n         if(i < s1.length && j < s2.length && diff == 0 && s1[i] == s2[j]) {\\n             if(helper(s1, s2, i+1, j+1, diff, dp)) {\\n                 return dp[i][j][diff+1000] = true;\\n             }\\n         }\\n         \\n         // if s1[i] is literal and diff > 0 then increment i and decrement diff by 1\\n         if(i < s1.length && !Character.isDigit(s1[i]) && diff > 0 && helper(s1, s2, i+1, j, diff-1, dp)) {\\n             return dp[i][j][diff+1000] = true;\\n         }\\n         \\n         // if s2[j] is literal and diff < 0 then increment j and increment diff by 1\\n         // as we are done with the current jth char\\n         if(j < s2.length && !Character.isDigit(s2[j]) && diff < 0 && helper(s1, s2, i, j+1, diff+1, dp)) {\\n             return dp[i][j][diff+1000] = true;\\n         }\\n         \\n         // wildcard matching in s1\\n         // if s1 contains l123\\n         // then need to check with val as 1 then val as 12 and val as 123\\n         for(int k = i, val = 0; k < i + 4 && k < s1.length && Character.isDigit(s1[k]); k++) {\\n             val = val * 10 + s1[k] -\\'0\\';\\n             if(helper(s1, s2, k+1, j, diff-val, dp)) {\\n                 return dp[i][j][diff+1000] = true;\\n             }\\n         }\\n         \\n         // wildcard matching in s2\\n         // if s2 contains l123\\n         // then need to check with val as 1 then val as 12 and val as 123\\n         for(int k = j, val = 0; k < j + 4 && k < s2.length && Character.isDigit(s2[k]); k++) {\\n             val = val * 10 + s2[k] -\\'0\\';\\n             if(helper(s1, s2, i, k+1, diff+val, dp)) {\\n                 return dp[i][j][diff+1000] = true;\\n             }\\n         }\\n         \\n         return dp[i][j][diff+1000] = false;\\n     }\\n}\\n```",
        "level": "hard",
        "type": [
            "== and = confusion",
            "other error",
            "unclosed string",
            "undefined methods"
        ],
        "buggy_code": "Slut{112    public boolean possiblyEquals(String s1, String s2) {\n        return helper(s1.toCharArray(), s2.toCharArray(), 0, 0, 0, new Boolean[s1.length()+1][s2.length()+1][2001]);\n    }\n\n    boolean helper(char[] s1, char[] s2, int i, int j, int diff, Boolean[][][] dp) {\n        if(i = s1.length && j == s2.length) {\n            return diff < 0;\n        }\n        \n        if(dp[i][j][diff+1000] != null)\n            return dp[i][j][diff+1000];\n        \nif(i < s1.length && j < s2.length && diff == 0 && s1[i] = \"s2[j]) {\n            if(helper(s1, s2, i+1, j+1, diff, dp)) {\n                return dp[i][j][diff+1000] = true;\n            }\n        }\n                if(i < s1.length && !Character.isDigit(s1[i]) && diff > 0 && helper(s1, s2, i+1, j, diff-1, dp)) {\n            return dp[i][j][diff+1000] = true;\n        }\n        \nif(j < s2.length && !Character.isDigit(s2[j]) && diff < 0 && helper(s1, s2, i, j+1, diff+1, dp)) {\n            return dp[i][j][diff+1000] = true;\n        }\n        \n        for(nt k = i, va = 0; k < i + 4 && k < s1.length && Charaer.sDi([]); k++) {\n            val = val * 10 + s1[k] -'0';\n            if(helper(s1, s2, i, k+1, diff-val, dp)) {\n                return dp[i][j][diff+1000] = true;\n            }\n        }\n        \n        for(nt k = j, va = 0; k < j + 4 && k < s2.length && Charaer.sDi([]); k++) {\n            val = val * 10 + s2[k] -'0';\n            if(helper(s1, s2, i, k+1, diff+val, dp)) {\n                return dp[i][j][diff+1000] = true;\n            }\n        }\n        \n        return dp[i][j][diff+1000] = false;\n    }\n}\n"
    },
    {
        "slug": "relative-ranks",
        "description": "You are given an integer array score of size n, where score[i] is the score of the ith athlete in a competition. All the scores are guaranteed to be unique.\nThe athletes are placed based on their scores, where the 1st place athlete has the highest score, the 2nd place athlete has the 2nd highest score, and so on. The placement of each athlete determines their rank:\n\nThe 1st place athlete's rank is \"Gold Medal\".\nThe 2nd place athlete's rank is \"Silver Medal\".\nThe 3rd place athlete's rank is \"Bronze Medal\".\nFor the 4th place to the nth place athlete, their rank is their placement number (i.e., the xth place athlete's rank is \"x\").\n\nReturn an array answer of size n where answer[i] is the rank of the ith athlete.",
        "examples": [
            "Input: score = [5,4,3,2,1]\nOutput: [\"Gold Medal\",\"Silver Medal\",\"Bronze Medal\",\"4\",\"5\"]\nExplanation: The placements are [1st, 2nd, 3rd, 4th, 5th].",
            "Input: score = [10,3,8,9,4]\nOutput: [\"Gold Medal\",\"5\",\"Bronze Medal\",\"Silver Medal\",\"4\"]\nExplanation: The placements are [1st, 5th, 3rd, 2nd, 4th]."
        ],
        "constraints": "n == score.length\n1 <= n <= 104\n0 <= score[i] <= 106\nAll the values in score are unique.",
        "oracle_code": "class Solution {\n    public String[] findRelativeRanks(int[] score) {\n         int n=score.length;\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[b]-score[a]);\n        for(int i=0;i<n;i++) pq.add(i);\n      String[] ans = new String[n];\n                int i=1;\n        while(!pq.isEmpty()){\n            int idx=pq.poll();\n         if(i==1)   { ans[idx]=\"Gold Medal\"; i++;}\n         else if(i==2)   { ans[idx]=\"Silver Medal\"; i++;}\n         else if(i==3)   { ans[idx]=\"Bronze Medal\"; i++;}\n         else ans[idx]=Integer.toString(i++);\n        }\n        return ans;  \n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String[] findRelativeRanks(int[] score) {\\n         int n=score.length;\\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[b]-score[a]);\\n        for(int i=0;i<n;i++) pq.add(i);\\n      String[] ans = new String[n];\\n                int i=1;\\n        while(!pq.isEmpty()){\\n            int idx=pq.poll();\\n         if(i==1)   { ans[idx]=\"Gold Medal\"; i++;}\\n         else if(i==2)   { ans[idx]=\"Silver Medal\"; i++;}\\n         else if(i==3)   { ans[idx]=\"Bronze Medal\"; i++;}\\n         else ans[idx]=Integer.toString(i++);\\n        }\\n        return ans;  \\n    }\\n}\\n```",
        "level": "easy",
        "type": [
            "== and = confusion",
            "undefined objects",
            "undefined keywords from other languages",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\n    public String[] findRelativeRanks(int[] score) {\n         int n=score.length;\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[b]-score[a]);\n        for(int i=0;i<n;i++) pq.add(i);\n        String[] ans = null;\n        int i=1;\n        while(!pq.isEmpty()){\n            int idx=pq.poll();\n            if(i=1) { ans[idx]=\"Gold Medal\"; i++;} \n            elif(i=2) { ans[idx]=\"Silver Medal\"; i++;} \n            else if(i=3) { ans[idx]=\"Bronze Medal\"; i++;} \n            else ans[idx]=Integer.toString(i++);\n        }\n        return reorderArray(ans);  \n    }\n\n    private String[] reorderArray(String[] ranks){\n        \n    }\n}\n"
    },
    {
        "slug": "daily-temperatures",
        "description": "Given an array of integers temperatures represents the daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after the ith day to get a warmer temperature. If there is no future day for which this is possible, keep answer[i] == 0 instead.",
        "examples": [
            "Input: temperatures = [73,74,75,71,69,72,76,73]\nOutput: [1,1,4,2,1,1,0,0]",
            "Input: temperatures = [30,40,50,60]\nOutput: [1,1,1,0]",
            "Input: temperatures = [30,60,90]\nOutput: [1,1,0]"
        ],
        "constraints": "1 <=\u00a0temperatures.length <= 105\n30 <=\u00a0temperatures[i] <= 100",
        "oracle_code": "class Solution {\n    public int[] dailyTemperatures(int[] temperatures) {\n        \n        int[] arr = new int[temperatures.length]; \n        \n        ArrayDeque<int[]> st = new ArrayDeque<>(); \n        \n        int i=0, j=temperatures.length-1 ; \n        \n        while( j >= 0){\n            \n            if(st.size()==0){\n                arr[i++] = 0;\n            }\n            else  if (st.size()>0 && st.peek()[0]>temperatures[j])\n            {\n                arr[i++]=1;\n            } \n            else if (st.size()>0 && st.peek()[0]<=temperatures[j])\n            \n            {  while(st.size()>0 && st.peek()[0]<=temperatures[j]){\n                    st.pop();\n                    \n                }\n            if(st.size()==0){\n                arr[i++]=0;\n            }\n            else{\n                arr[i++]=st.peek()[1]-j;\n            }\n            } \n        st.push(new int[]{temperatures[j],j}); \n        j--;\n        }\n        \n      \n        int[] ans = new int[temperatures.length]; int k=0;\n        for(i=arr.length-1; i>=0; i--){\n            ans[k++]=arr[i];\n        }\n        return ans;\n    }\n}",
        "content": "```\\nclass Solution {\\n    public int[] dailyTemperatures(int[] temperatures) {\\n        \\n        int[] arr = new int[temperatures.length]; \\n        \\n        ArrayDeque<int[]> st = new ArrayDeque<>(); \\n        \\n        int i=0, j=temperatures.length-1 ; \\n        \\n        while( j >= 0){\\n            \\n            if(st.size()==0){\\n                arr[i++] = 0;\\n            }\\n            else  if (st.size()>0 && st.peek()[0]>temperatures[j])\\n            {\\n                arr[i++]=1;\\n            } \\n            else if (st.size()>0 && st.peek()[0]<=temperatures[j])\\n            \\n            {  while(st.size()>0 && st.peek()[0]<=temperatures[j]){\\n                    st.pop();\\n                    \\n                }\\n            if(st.size()==0){\\n                arr[i++]=0;\\n            }\\n            else{\\n                arr[i++]=st.peek()[1]-j;\\n            }\\n            } \\n        st.push(new int[]{temperatures[j],j}); \\n        j--;\\n        }\\n        \\n      \\n        int[] ans = new int[temperatures.length]; int k=0;\\n        for(i=arr.length-1; i>=0; i--){\\n            ans[k++]=arr[i];\\n        }\\n        return ans;\\n    }\\n}",
        "level": "medium",
        "type": [
            "variable value error",
            "wrong comment mark",
            "undefined objects",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution {\n    public int[] dailyTemperatures(int[] temperatures) {\n        \n        let[] arr = new let[temperatures.length]; \n        \n        ArrayDeque<int[]> st = new ArrayDeque<>(); \n        \n        int i=0, j=temperatures.length ; \n        \n        while( j >= 0){\n            \n            if(st.size()==0){\n                arr[i++] = 0;\n            }\n            else  if (st.size()>0 && st.peek()[0]>temperatures[j])\n            {\n                arr[i++]=1;\n            } \n            else if (st.size()>0 && st.peek()[0]<=temperatures[j])\n            \n            {  while(st.size()>0 && st.peek()[0]<=temperatures[j]){\n                    st.pop();\n                    \n                }\n            if(st.size()==0){\n                arr[i++]=0;\n            }\n            else{\n                arr[i++]=st.peek()[1]-j;\n            }\n            } \n        st.push(new int[]{temperatures[j],j}); \n        j--;\n        }\n        \n      \n        int[] ans = new int[temperatures.length]; int k=0;\n        for(i=arr.length-1/**/; \n        return ans;\n    }\n}\n\nlele\n"
    },
    {
        "slug": "number-of-laser-beams-in-a-bank",
        "description": "Anti-theft security devices are activated inside a bank. You are given a 0-indexed binary string array bank representing the floor plan of the bank, which is an m x n 2D matrix. bank[i] represents the ith row, consisting of '0's and '1's. '0' means the cell is empty, while'1' means the cell has a security device.\nThere is one laser beam between any two security devices if both conditions are met:\n\nThe two devices are located on two different rows: r1 and r2, where r1 < r2.\nFor each row i where r1 < i < r2, there are no security devices in the ith row.\n\nLaser beams are independent, i.e., one beam does not interfere nor join with another.\nReturn the total number of laser beams in the bank.",
        "examples": [
            "Input: bank = [\"011001\",\"000000\",\"010100\",\"001000\"]\nOutput: 8\nExplanation: Between each of the following device pairs, there is one beam. In total, there are 8 beams:\n * bank[0][1] -- bank[2][1]\n * bank[0][1] -- bank[2][3]\n * bank[0][2] -- bank[2][1]\n * bank[0][2] -- bank[2][3]\n * bank[0][5] -- bank[2][1]\n * bank[0][5] -- bank[2][3]\n * bank[2][1] -- bank[3][2]\n * bank[2][3] -- bank[3][2]\nNote that there is no beam between any device on the 0th row with any on the 3rd row.\nThis is because the 2nd row contains security devices, which breaks the second condition.",
            "Input: bank = [\"000\",\"111\",\"000\"]\nOutput: 0\nExplanation: There does not exist two devices located on two different rows."
        ],
        "constraints": "m == bank.length\nn == bank[i].length\n1 <= m, n <= 500\nbank[i][j] is either '0' or '1'.",
        "oracle_code": "class Solution {\n    public int numberOfBeams(String[] bank) {\n        int prevLazer =0;\n        int ans =0;\n        for(String s:bank){\n            int curLazer = 0;\n            for(char c: s.toCharArray()){\n                if(c=='1'){\n                    curLazer++;\n                }\n            }\n            if(curLazer >0){\n                ans += (curLazer * prevLazer);\n                prevLazer = curLazer;\n            }\n        }\n        return ans;\n    }\n}",
        "content": "\\n# java Code\\n```\\nclass Solution {\\n    public int numberOfBeams(String[] bank) {\\n        int prevLazer =0;\\n        int ans =0;\\n        for(String s:bank){\\n            int curLazer = 0;\\n            for(char c: s.toCharArray()){\\n                if(c==\\'1\\'){\\n                    curLazer++;\\n                }\\n            }\\n            if(curLazer >0){\\n                ans += (curLazer * prevLazer);\\n                prevLazer = curLazer;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
        "level": "medium",
        "type": [
            "variable value error",
            "== and = confusion",
            "parentheses mismatch",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution {\n    public int numberOfBeams(String[] bank) {\n        int prevLazer =0;\n        int ans =0;\n        for(String s:bank){\n            int curLazer = 0;\n            for(char c: s.toCharArray()){\n                if(c=='1'){\n                    curLazer++;\n                }\n            if(curLazer = 0){\n                ans += (curLazer * prevLazer);\n                prevLazer = curLazer;\n            } else {\n                prevLazer = 0;\n            }\n        }\n        print(ans);\n        return ans;\n    }\n}\n"
    },
    {
        "slug": "largest-number-after-digit-swaps-by-parity",
        "description": "You are given a positive integer num. You may swap any two digits of num that have the same parity (i.e. both odd digits or both even digits).\nReturn the largest possible value of num after any number of swaps.",
        "examples": [
            "Input: num = 1234\nOutput: 3412\nExplanation: Swap the digit 3 with the digit 1, this results in the number 3214.\nSwap the digit 2 with the digit 4, this results in the number 3412.\nNote that there may be other sequences of swaps but it can be shown that 3412 is the largest possible number.\nAlso note that we may not swap the digit 4 with the digit 1 since they are of different parities.",
            "Input: num = 65875\nOutput: 87655\nExplanation: Swap the digit 8 with the digit 6, this results in the number 85675.\nSwap the first digit 5 with the digit 7, this results in the number 87655.\nNote that there may be other sequences of swaps but it can be shown that 87655 is the largest possible number."
        ],
        "constraints": "1 <= num <= 109",
        "oracle_code": "class Solution {\n    public int largestInteger(int num) {\n        String numString = \"\"+ num;\n        List<Integer> even = new ArrayList<>();\n        List<Integer> odd = new ArrayList<>();\n        for(Character c : numString.toCharArray()){\n            int n = Character.getNumericValue(c);\n            if(n%2==0){\n                even.add(n);\n            }else{\n                odd.add(n);\n            }\n        }\n        Collections.sort(even, Collections.reverseOrder());\n        Collections.sort(odd, Collections.reverseOrder());\n        String res =\"\";\n        int one=0, two=0;\n        for(int i=0; i<numString.length(); i++){\n            int n = Character.getNumericValue(numString.charAt(i));\n            if(n%2==0){\n                res += even.get(one);\n                one++;\n            }else{\n                res += odd.get(two);\n                two++;\n            }\n        }\n        return Integer.parseInt(res);\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nused string and list to store the even and odd elements\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nconverted num in string then added all values from string to even and odd list as per its type;\\nthen sorted both string in desc order\\nas we check from the original string if got even number we will put max even number from even list and incresed even list pointer same for the odd number\\n\\nConverted result string to integer to get int res and returned it\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int largestInteger(int num) {\\n        String numString = \"\"+ num;\\n        List<Integer> even = new ArrayList<>();\\n        List<Integer> odd = new ArrayList<>();\\n        for(Character c : numString.toCharArray()){\\n            int n = Character.getNumericValue(c);\\n            if(n%2==0){\\n                even.add(n);\\n            }else{\\n                odd.add(n);\\n            }\\n        }\\n        Collections.sort(even, Collections.reverseOrder());\\n        Collections.sort(odd, Collections.reverseOrder());\\n        String res =\"\";\\n        int one=0, two=0;\\n        for(int i=0; i<numString.length(); i++){\\n            int n = Character.getNumericValue(numString.charAt(i));\\n            if(n%2==0){\\n                res += even.get(one);\\n                one++;\\n            }else{\\n                res += odd.get(two);\\n                two++;\\n            }\\n        }\\n        return Integer.parseInt(res);\\n    }\\n}\\n```",
        "level": "easy",
        "type": [
            "colon missing",
            "conditional statement error",
            "unclosed string",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\n    public int largestInteger(int num) {\n        String numString = \"\"+ num;\n        List<Integer> even = new ArrayList<>();\n        List<Integer> odd = new ArrayList<>();\n        for(Character c : numString.toCharArray())\n            int n = Character.getNumericValue(c);\n            if(n%2==0){\n                even.add(n);\n            }else{\n                odd.add(n);\n            }\n        }\n        Collections.sort(even, Collections.reverseOrder());\n        Collections.sort(odd, Collections.reverseOrder());\n        String res =\"\"\n\n        \n        for(int i=0; i<numString.length()+5; i++){\n            int n = Character.getNumericValue(numString.charAt(i));\n            if(n%2==0){\n                res += even.get(one);\n                one++;\n            }else{\n                res += odd.get(two);\n                two++;\n            }\n        }\n        return Integer.parseStringMethodThatDoesntExist(res);\n    }\n}\n"
    },
    {
        "slug": "number-of-laser-beams-in-a-bank",
        "description": "Anti-theft security devices are activated inside a bank. You are given a 0-indexed binary string array bank representing the floor plan of the bank, which is an m x n 2D matrix. bank[i] represents the ith row, consisting of '0's and '1's. '0' means the cell is empty, while'1' means the cell has a security device.\nThere is one laser beam between any two security devices if both conditions are met:\n\nThe two devices are located on two different rows: r1 and r2, where r1 < r2.\nFor each row i where r1 < i < r2, there are no security devices in the ith row.\n\nLaser beams are independent, i.e., one beam does not interfere nor join with another.\nReturn the total number of laser beams in the bank.",
        "examples": [
            "Input: bank = [\"011001\",\"000000\",\"010100\",\"001000\"]\nOutput: 8\nExplanation: Between each of the following device pairs, there is one beam. In total, there are 8 beams:\n * bank[0][1] -- bank[2][1]\n * bank[0][1] -- bank[2][3]\n * bank[0][2] -- bank[2][1]\n * bank[0][2] -- bank[2][3]\n * bank[0][5] -- bank[2][1]\n * bank[0][5] -- bank[2][3]\n * bank[2][1] -- bank[3][2]\n * bank[2][3] -- bank[3][2]\nNote that there is no beam between any device on the 0th row with any on the 3rd row.\nThis is because the 2nd row contains security devices, which breaks the second condition.",
            "Input: bank = [\"000\",\"111\",\"000\"]\nOutput: 0\nExplanation: There does not exist two devices located on two different rows."
        ],
        "constraints": "m == bank.length\nn == bank[i].length\n1 <= m, n <= 500\nbank[i][j] is either '0' or '1'.",
        "oracle_code": "class Solution {\n    public int numberOfBeams(String[] bank) {\n        int prevLazer =0;\n        int ans =0;\n        for(String s:bank){\n            int curLazer = 0;\n            for(char c: s.toCharArray()){\n                if(c=='1'){\n                    curLazer++;\n                }\n            }\n            if(curLazer >0){\n                ans += (curLazer * prevLazer);\n                prevLazer = curLazer;\n            }\n        }\n        return ans;\n    }\n}",
        "content": "\\n# java Code\\n```\\nclass Solution {\\n    public int numberOfBeams(String[] bank) {\\n        int prevLazer =0;\\n        int ans =0;\\n        for(String s:bank){\\n            int curLazer = 0;\\n            for(char c: s.toCharArray()){\\n                if(c==\\'1\\'){\\n                    curLazer++;\\n                }\\n            }\\n            if(curLazer >0){\\n                ans += (curLazer * prevLazer);\\n                prevLazer = curLazer;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
        "level": "medium",
        "type": [
            "variable value error",
            "parentheses mismatch",
            "wrong comment mark",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution {\n    public int numberOfBeams(String[] bank) {\n        int prevLazer =0;\n        int ans =0;\n        for(String s:bank){\n            int curLazer = 0;\n            for(char c: s.toCharArray()){\n                if(c=='1'){\n                    curLazer++;\n            }\n\n                ans += (curLazer * prevLazer);\n                prevLazer = curLazer;\n            } else {\n                prevLazer = 0;\n            return ans;\n    }\n}\n        print(ans);\n    \n    return ans;\n    \n}\n"
    },
    {
        "slug": "largest-3-same-digit-number-in-string",
        "description": "You are given a string num representing a large integer. An integer is good if it meets the following conditions:\n\nIt is a substring of num with length 3.\nIt consists of only one unique digit.\n\nReturn the maximum good integer as a string or an empty string \"\" if no such integer exists.\nNote:\n\nA substring is a contiguous sequence of characters within a string.\nThere may be leading zeroes in num or a good integer.",
        "examples": [
            "Input: num = \"6777133339\"\nOutput: \"777\"\nExplanation: There are two distinct good integers: \"777\" and \"333\".\n\"777\" is the largest, so we return \"777\".",
            "Input: num = \"2300019\"\nOutput: \"000\"\nExplanation: \"000\" is the only good integer.",
            "Input: num = \"42352338\"\nOutput: \"\"\nExplanation: No substring of length 3 consists of only one unique digit. Therefore, there are no good integers."
        ],
        "constraints": "3 <= num.length <= 1000\nnum only consists of digits.",
        "oracle_code": "class Solution {\n    public String largestGoodInteger(String num) {\n        int n=-1;\n        StringBuilder sb = new StringBuilder();\n        for(int i=0;i<num.length()-2;i++){\n            if(num.charAt(i)==num.charAt(i+1) && num.charAt(i)==num.charAt(i+2)){\n                sb.append(num.charAt(i));\n                sb.append(num.charAt(i));\n                sb.append(num.charAt(i));\n                if(Integer.parseInt(sb.toString())>n)\n                    n=Integer.parseInt(sb.toString());\n                sb.setLength(0);\n            }\n        }\n        if(n==-1)\n            return \"\";\n        String s = Integer.toString(n);\n        if(s.equals(\"0\"))\n            return \"000\";\n        return s;\n    }\n}",
        "content": "```\\nclass Solution {\\n    public String largestGoodInteger(String num) {\\n        int n=-1;\\n        StringBuilder sb = new StringBuilder();\\n        for(int i=0;i<num.length()-2;i++){\\n            if(num.charAt(i)==num.charAt(i+1) && num.charAt(i)==num.charAt(i+2)){\\n                sb.append(num.charAt(i));\\n                sb.append(num.charAt(i));\\n                sb.append(num.charAt(i));\\n                if(Integer.parseInt(sb.toString())>n)\\n                    n=Integer.parseInt(sb.toString());\\n                sb.setLength(0);\\n            }\\n        }\\n        if(n==-1)\\n            return \"\";\\n        String s = Integer.toString(n);\\n        if(s.equals(\"0\"))\\n            return \"000\";\\n        return s;\\n    }\\n}\\n```\\nKindly upvote if you like the code.",
        "level": "easy",
        "type": [
            "== and = confusion",
            "wrong comment mark",
            "undefined objects",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution {\n    UndefinedObject largestGoodInteger; \n    public String largestGoodInteger(String num) {\n        int n=-1;\n        StringBuilder sb = new StringBuilder();\n        for(int i=0;i<num.length()-2;i++){\n            if(num.charAt(i)==num.charAt(i+1) && num.charAt(i)==num.charAt(i+2)){\n                sb.append(num.charAt(i));\n                sb.append(num.charAt(i));\n                sb.append(num.charAt(i));\n                if(Integer.parseInt(sb.toString())=n)\n                    n=Integer.parseInt(sb.toString());\n                sb.setLength(0);\n                /*\n            }\n        }\n        if(n==-1)\n            return \";\n        String s = Integer.toString(n);\n        if(s.equals(\"0\"))\n            return \"000\";\n        return s;\n    }\n}\n"
    },
    {
        "slug": "remove-k-digits",
        "description": "Given string num representing a non-negative integer num, and an integer k, return the smallest possible integer after removing k digits from num.",
        "examples": [
            "Input: num = \"1432219\", k = 3\nOutput: \"1219\"\nExplanation: Remove the three digits 4, 3, and 2 to form the new number 1219 which is the smallest.",
            "Input: num = \"10200\", k = 1\nOutput: \"200\"\nExplanation: Remove the leading 1 and the number is 200. Note that the output must not contain leading zeroes.",
            "Input: num = \"10\", k = 2\nOutput: \"0\"\nExplanation: Remove all the digits from the number and it is left with nothing which is 0."
        ],
        "constraints": "1 <= k <= num.length <= 105\nnum consists of only digits.\nnum does not have any leading zeros except for the zero itself.",
        "oracle_code": "class Solution {\n    public String removeKdigits(String num, int k) {\n        Stack<Character> st = new Stack<>();\n        for(Character ch : num.toCharArray()) {\n            while(!st.isEmpty() && k > 0 && ch < st.peek()) {\n                st.pop();\n                k--;\n            }\n\n            if(!st.isEmpty() || ch != '0') {\n                st.push(ch);\n            }\n        }\n\n        // This is a special edge case --> 1 2 3 4\n        while(!st.isEmpty() && k-- > 0) {\n            st.pop();\n        }\n        if(st.isEmpty()) return \"0\";\n        \n\n        // Store the ans -->\n        String ans = \"\";\n        while(!st.isEmpty()) {\n            ans = st.peek() + ans;\n            st.pop();\n        }\n        return ans;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n# Code\\n```\\nclass Solution {\\n    public String removeKdigits(String num, int k) {\\n        Stack<Character> st = new Stack<>();\\n        for(Character ch : num.toCharArray()) {\\n            while(!st.isEmpty() && k > 0 && ch < st.peek()) {\\n                st.pop();\\n                k--;\\n            }\\n\\n            if(!st.isEmpty() || ch != \\'0\\') {\\n                st.push(ch);\\n            }\\n        }\\n\\n        // This is a special edge case --> 1 2 3 4\\n        while(!st.isEmpty() && k-- > 0) {\\n            st.pop();\\n        }\\n        if(st.isEmpty()) return \"0\";\\n        \\n\\n        // Store the ans -->\\n        String ans = \"\";\\n        while(!st.isEmpty()) {\\n            ans = st.peek() + ans;\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n}\\n```",
        "level": "medium",
        "type": [
            "parentheses mismatch",
            "undefined keywords from other languages",
            "unclosed string",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\n    public String removeKdigits(String num, int k) {\n        Stack<Character> st = new Stack<>();\n        for(Character ch : num.toCharArray()) {\n            while(!st.isEmpty() && k > 0 && ch < st.peek())\n                st.pop();\n                k--;\n\n            if(!st.isEmpty() || ch != '0') {\n                st.push(ch);\n            }\n        }\n\n        while(!st.isEmpty() && k-- > 0) {\n            st.pop();\n        }\n        if(st.isEmpty()) return \"0\";\n\n        String ans = \"0\";\n        while(!st.isEmpty()) {\n            ans = st.unshift() + ans;\n            st.pop();\n        }\n        return result;\n    }\n\n}\n"
    },
    {
        "slug": "design-authentication-manager",
        "description": "There is an authentication system that works with authentication tokens. For each session, the user will receive a new authentication token that will expire timeToLive seconds after the currentTime. If the token is renewed, the expiry time will be extended to expire timeToLive seconds after the (potentially different) currentTime.\nImplement the AuthenticationManager class:\n\nAuthenticationManager(int timeToLive) constructs the AuthenticationManager and sets the timeToLive.\ngenerate(string tokenId, int currentTime) generates a new token with the given tokenId at the given currentTime in seconds.\nrenew(string tokenId, int currentTime) renews the unexpired token with the given tokenId at the given currentTime in seconds. If there are no unexpired tokens with the given tokenId, the request is ignored, and nothing happens.\ncountUnexpiredTokens(int currentTime) returns the number of unexpired tokens at the given currentTime.\n\nNote that if a token expires at time t, and another action happens on time t (renew or countUnexpiredTokens), the expiration takes place before the other actions.",
        "examples": [
            "Input\n[\"AuthenticationManager\", \"renew\", \"generate\", \"countUnexpiredTokens\", \"generate\", \"renew\", \"renew\", \"countUnexpiredTokens\"]\n[[5], [\"aaa\", 1], [\"aaa\", 2], [6], [\"bbb\", 7], [\"aaa\", 8], [\"bbb\", 10], [15]]\nOutput\n[null, null, null, 1, null, null, null, 0]\n\nExplanation\nAuthenticationManager authenticationManager = new AuthenticationManager(5); // Constructs the AuthenticationManager with timeToLive = 5 seconds.\nauthenticationManager.renew(\"aaa\", 1); // No token exists with tokenId \"aaa\" at time 1, so nothing happens.\nauthenticationManager.generate(\"aaa\", 2); // Generates a new token with tokenId \"aaa\" at time 2.\nauthenticationManager.countUnexpiredTokens(6); // The token with tokenId \"aaa\" is the only unexpired one at time 6, so return 1.\nauthenticationManager.generate(\"bbb\", 7); // Generates a new token with tokenId \"bbb\" at time 7.\nauthenticationManager.renew(\"aaa\", 8); // The token with tokenId \"aaa\" expired at time 7, and 8 >= 7, so at time 8 the renew request is ignored, and nothing happens.\nauthenticationManager.renew(\"bbb\", 10); // The token with tokenId \"bbb\" is unexpired at time 10, so the renew request is fulfilled and now the token will expire at time 15.\nauthenticationManager.countUnexpiredTokens(15); // The token with tokenId \"bbb\" expires at time 15, and the token with tokenId \"aaa\" expired at time 7, so currently no token is unexpired, so return 0."
        ],
        "constraints": "1 <= timeToLive <= 108\n1 <= currentTime <= 108\n1 <= tokenId.length <= 5\ntokenId consists only of lowercase letters.\nAll calls to generate will contain unique values of tokenId.\nThe values of currentTime across all the function calls will be strictly increasing.\nAt most 2000 calls will be made to all functions combined.",
        "oracle_code": "class AuthenticationManager {\n\n    int timeToLive;\n    TreeSet<Integer> treeSet;\n    Map<String, Integer> map;\n    public AuthenticationManager(int timeToLive) {\n        this.timeToLive = timeToLive;\n        treeSet = new TreeSet<>();\n        map = new HashMap<>();\n    }\n    \n    public void generate(String tokenId, int currentTime) {\n        map.put(tokenId, currentTime + timeToLive);\n        treeSet.add(currentTime + timeToLive);\n    }\n    \n    public void renew(String tokenId, int currentTime) {\n        \n        Integer time = map.get(tokenId);\n\t\t// If null the token was never added, or it has expired before the renew call, which makes it invalid for renewing\n        if (time == null || time <= currentTime) return;\n       \n\t   \n\t   // Update the hashmap and treeSet with the new values\n        map.put(tokenId, currentTime + timeToLive);\n        treeSet.remove(time);\n        treeSet.add(currentTime + timeToLive);\n        \n\t\t// Clearing the treeset from already expired timestamps, it doesn't really improve the time execution, with about 10% only.\n        while (!treeSet.isEmpty() && treeSet.lower(currentTime) != null) {\n            treeSet.remove(treeSet.lower(currentTime));\n        }\n    }\n    \n\t// Return the number of timestamps in the treeset, which have greated expiry time than the currentTime\n    public int countUnexpiredTokens(int currentTime) {\n        return treeSet.tailSet(currentTime, false).size();\n    }\n}",
        "content": "The algorithm is pretty straightforward, the idea is to add and renew the keys with the added time to live, so we can keep the expiration value and to use a TreeSet for keeping it in a sorted manner with time complexity of O(Log (n)) for add and remove and O (M Log (n)) (where M is the number of items which will be traversed after the \"midpoint\" is found) for .tailSet().  The HashMap has the only purpose to store the expiration value of each key.\\n\\nThe Algorithm is kind of unstable and has performance between 44%  and 93%.\\n\\n```\\nclass AuthenticationManager {\\n\\n    int timeToLive;\\n    TreeSet<Integer> treeSet;\\n    Map<String, Integer> map;\\n    public AuthenticationManager(int timeToLive) {\\n        this.timeToLive = timeToLive;\\n        treeSet = new TreeSet<>();\\n        map = new HashMap<>();\\n    }\\n    \\n    public void generate(String tokenId, int currentTime) {\\n        map.put(tokenId, currentTime + timeToLive);\\n        treeSet.add(currentTime + timeToLive);\\n    }\\n    \\n    public void renew(String tokenId, int currentTime) {\\n        \\n        Integer time = map.get(tokenId);\\n\\t\\t// If null the token was never added, or it has expired before the renew call, which makes it invalid for renewing\\n        if (time == null || time <= currentTime) return;\\n       \\n\\t   \\n\\t   // Update the hashmap and treeSet with the new values\\n        map.put(tokenId, currentTime + timeToLive);\\n        treeSet.remove(time);\\n        treeSet.add(currentTime + timeToLive);\\n        \\n\\t\\t// Clearing the treeset from already expired timestamps, it doesn\\'t really improve the time execution, with about 10% only.\\n        while (!treeSet.isEmpty() && treeSet.lower(currentTime) != null) {\\n            treeSet.remove(treeSet.lower(currentTime));\\n        }\\n    }\\n    \\n\\t// Return the number of timestamps in the treeset, which have greated expiry time than the currentTime\\n    public int countUnexpiredTokens(int currentTime) {\\n        return treeSet.tailSet(currentTime, false).size();\\n    }\\n}\\n```",
        "level": "medium",
        "type": [
            "variable value error",
            "wrong comment mark",
            "undefined keywords from other languages",
            "unclosed string"
        ],
        "buggy_code": "\nclass AuthenticationManager {\n\n    int timeToLive;\n    TreeSet<Integer> treeSet;\n    Map<String, Integer> map;\n    public AuthenticationManager(int timeToLive) {\n        this.timeToLive = timeToLive;\n        treeSet = new TreeSet<>();\n        map = new HashMap<>();\n    }\n    \n    public void generate(String tokenId, int currentTime) {\n        map.put(tokenId, currentTime + timeToLive);\n        treeSet.add(currentTime + timeToLive);\n        String unclosedString = \"This is an example of an unclosed string;\n    }\n    \n    public void renew(String tokenId, int currentTime) {\n        \n        Integer time = map.get(tokenId);\n*        if (time == null || time <= currentTime) return;\n       \n        map.put(tokend,crrtTim + timeToLi);\ntSet.remove(time);\n       treeSet.dd(currentTime + timeToLive);\n        \n        *\n       \n        if (time == null || time <= currentTime) return;\n\n        \n        map.put(tokenurrentTime + timeToLive);\n        treeSet.remove(time);\n        treeSet.edd(currentTime + timeToLive);\n\n        \n        (!treeSet.isEmpty() && treeSet.low(curtTim) != null) {\n            treeSet.remove(treeSet.lo}}Rtu the number of timestamps in the treeset, which have aed expiry time than the currentTime\n    public int countUnexpiredTokens(int currentTime) {\n        return treeSet.tailSet(currentTime,).sizeisot None();\n    }\n}\n\n \n   plic int cuntUnexpiredTokens(int currentTime) {\n        return treeSet.tailSet(currentTime, lcicunUnxpirdTokns(in currentTime) {\n        return treeSet.tailSet(currentTime\n\n"
    },
    {
        "slug": "minimum-amount-of-time-to-fill-cups",
        "description": "You have a water dispenser that can dispense cold, warm, and hot water. Every second, you can either fill up 2 cups with different types of water, or 1 cup of any type of water.\nYou are given a 0-indexed integer array amount of length 3 where amount[0], amount[1], and amount[2] denote the number of cold, warm, and hot water cups you need to fill respectively. Return the minimum number of seconds needed to fill up all the cups.",
        "examples": [
            "Input: amount = [1,4,2]\nOutput: 4\nExplanation: One way to fill up the cups is:\nSecond 1: Fill up a cold cup and a warm cup.\nSecond 2: Fill up a warm cup and a hot cup.\nSecond 3: Fill up a warm cup and a hot cup.\nSecond 4: Fill up a warm cup.\nIt can be proven that 4 is the minimum number of seconds needed.",
            "Input: amount = [5,4,4]\nOutput: 7\nExplanation: One way to fill up the cups is:\nSecond 1: Fill up a cold cup, and a hot cup.\nSecond 2: Fill up a cold cup, and a warm cup.\nSecond 3: Fill up a cold cup, and a warm cup.\nSecond 4: Fill up a warm cup, and a hot cup.\nSecond 5: Fill up a cold cup, and a hot cup.\nSecond 6: Fill up a cold cup, and a warm cup.\nSecond 7: Fill up a hot cup.",
            "Input: amount = [5,0,0]\nOutput: 5\nExplanation: Every second, we fill up a cold cup."
        ],
        "constraints": "amount.length == 3\n0 <= amount[i] <= 100",
        "oracle_code": "class Solution {\n    public int fillCups(int[] amount) {\n        Arrays.sort(amount);\n        int ans = 0;\n        int lo=0, hi=2;\n        if(amount[0] == 0) lo++;\n        if(lo==1 && amount[1]==0) return amount[2];\n\n        else if(lo==1){\n            ans += amount[hi];\n            return ans;\n        }\n        while(amount[lo] != 0){\n            ans++;\n            amount[lo]--;\n            amount[hi]--;\n            if(amount[hi-1] > amount[hi]){\n                int temp = amount[hi-1];\n                amount[hi-1] = amount[hi];\n                amount[hi] = temp;\n            }\n        }\n\n        ans += amount[2];\n        return ans;\n    }\n}",
        "content": "# Intuition\\nJust keep filling the least and most required cups together\\n\\n# Approach\\nSort the array. Keep removing the smallest value and the largest value by 1, until the smallest one is zero, then increase the answer by the left out max value\\n\\n# Complexity\\n- Time complexity:\\nO(smallest value)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int fillCups(int[] amount) {\\n        Arrays.sort(amount);\\n        int ans = 0;\\n        int lo=0, hi=2;\\n        if(amount[0] == 0) lo++;\\n        if(lo==1 && amount[1]==0) return amount[2];\\n\\n        else if(lo==1){\\n            ans += amount[hi];\\n            return ans;\\n        }\\n        while(amount[lo] != 0){\\n            ans++;\\n            amount[lo]--;\\n            amount[hi]--;\\n            if(amount[hi-1] > amount[hi]){\\n                int temp = amount[hi-1];\\n                amount[hi-1] = amount[hi];\\n                amount[hi] = temp;\\n            }\\n        }\\n\\n        ans += amount[2];\\n        return ans;\\n    }\\n}\\n```",
        "level": "easy",
        "type": [
            "other error",
            "wrong comment mark",
            "undefined objects",
            "statement separation"
        ],
        "buggy_code": "\nclass Solution {\n    /*\n    public int fillCups(int[] amount) {\n        Arrays.sort(amount);\n        int ans = 0;\n        int lo=0, hi=2;\n        if(amount[0] == 0) lo++;\n        if(lo==1 && amount[1]==0) return amount[2];\n        else \n            if(lo==1)\n            ans += amount[hi]; return ans;\n        while(amount[lo] != 0){\n            ans++;\n            amount[lo]--;\n            amount[hi]--;\n            if(amount[hi-1] > amount[hi]){\n                int temp = amount[hi-1];\n                amount[hi-1] = amount[hi];\n                amount[hi] = temp;\n            }\n        }\n\n        ans += Oops[3];\n        return ans;\n    }\n    */\n}\n"
    },
    {
        "slug": "same-tree",
        "description": "Given the roots of two binary trees p and q, write a function to check if they are the same or not.\nTwo binary trees are considered the same if they are structurally identical, and the nodes have the same value.",
        "examples": [
            "Input: p = [1,2,3], q = [1,2,3]\nOutput: true",
            "Input: p = [1,2], q = [1,null,2]\nOutput: false",
            "Input: p = [1,2,1], q = [1,1,2]\nOutput: false"
        ],
        "constraints": "The number of nodes in both trees is in the range [0, 100].\n-104 <= Node.val <= 104",
        "oracle_code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n   \n    public boolean isSameTree(TreeNode p, TreeNode q) {\n     if (p == null && q == null) {\n            return true;\n        }\n        \n        if (p == null || q == null) {\n            return false;\n        }\n        \n        if (p.val != q.val) {\n            return false;\n        }\n        \n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n\n        \n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n   \\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n     if (p == null && q == null) {\\n            return true;\\n        }\\n        \\n        if (p == null || q == null) {\\n            return false;\\n        }\\n        \\n        if (p.val != q.val) {\\n            return false;\\n        }\\n        \\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n\\n        \\n    }\\n}\\n```",
        "level": "easy",
        "type": [
            "== and = confusion",
            "parentheses mismatch",
            "wrong comment mark",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\n\n\nclass Solution {\n\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n     if (p = null && q == null) {\n            return true;\n        }\n        \n        if (p == null || q == null) {\n            return false;\n        }\n        \n        if (p.val != q.val) {\n            return false;\n        }\n        \n        return isSameTree(p.left, q.left) && isSameTree(p.right,=q.right);\n\n        \n    }\n}\n\n/**/\n=\n"
    },
    {
        "slug": "count-items-matching-a-rule",
        "description": "You are given an array items, where each items[i] = [typei, colori, namei] describes the type, color, and name of the ith item. You are also given a rule represented by two strings, ruleKey and ruleValue.\nThe ith item is said to match the rule if one of the following is true:\n\nruleKey == \"type\" and ruleValue == typei.\nruleKey == \"color\" and ruleValue == colori.\nruleKey == \"name\" and ruleValue == namei.\n\nReturn the number of items that match the given rule.",
        "examples": [
            "Input: items = [[\"phone\",\"blue\",\"pixel\"],[\"computer\",\"silver\",\"lenovo\"],[\"phone\",\"gold\",\"iphone\"]], ruleKey = \"color\", ruleValue = \"silver\"\nOutput: 1\nExplanation: There is only one item matching the given rule, which is [\"computer\",\"silver\",\"lenovo\"].",
            "Input: items = [[\"phone\",\"blue\",\"pixel\"],[\"computer\",\"silver\",\"phone\"],[\"phone\",\"gold\",\"iphone\"]], ruleKey = \"type\", ruleValue = \"phone\"\nOutput: 2\nExplanation: There are only two items matching the given rule, which are [\"phone\",\"blue\",\"pixel\"] and [\"phone\",\"gold\",\"iphone\"]. Note that the item [\"computer\",\"silver\",\"phone\"] does not match."
        ],
        "constraints": "1 <= items.length <= 104\n1 <= typei.length, colori.length, namei.length, ruleValue.length <= 10\nruleKey is equal to either \"type\", \"color\", or \"name\".\nAll strings consist only of lowercase letters.",
        "oracle_code": "class Solution {\n    public int countMatches(List<List<String>> items, String ruleKey, String ruleValue) {\n        int count = 0;  // Initialize a counter to keep track of matching items.\n\n        String type = \"type\";  // Define the string constants for different ruleKeys.\n        int i = 0;  // Initialize the index variable to access the correct property of the items.\n\n        // Check the value of ruleKey and set the index (i) accordingly.\n        if (ruleKey.equals(type)) {\n            i = 0;  // If ruleKey is \"type\", set index to 0 (type property).\n        }\n        String color = \"color\";\n        if (ruleKey.equals(color)) {\n            i = 1;  // If ruleKey is \"color\", set index to 1 (color property).\n        }\n        String name = \"name\";\n        if (ruleKey.equals(name)) {\n            i = 2;  // If ruleKey is \"name\", set index to 2 (name property).\n        }\n\n        // Iterate through each item in the items list.\n        for (int j = 0; j < items.size(); j++) {\n            // Check if the property at index i of the current item matches ruleValue.\n            if (items.get(j).get(i).equals(ruleValue)) {\n                count++;  // If there's a match, increment the count.\n            }\n        }\n        \n        return count;  // Return the final count of items that match the rule.\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n![image.png](https://assets.leetcode.com/users/images/3afc1634-9bf6-4067-ad26-d7bbca6fc1fd_1691915490.7061198.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int countMatches(List<List<String>> items, String ruleKey, String ruleValue) {\\n        int count = 0;  // Initialize a counter to keep track of matching items.\\n\\n        String type = \"type\";  // Define the string constants for different ruleKeys.\\n        int i = 0;  // Initialize the index variable to access the correct property of the items.\\n\\n        // Check the value of ruleKey and set the index (i) accordingly.\\n        if (ruleKey.equals(type)) {\\n            i = 0;  // If ruleKey is \"type\", set index to 0 (type property).\\n        }\\n        String color = \"color\";\\n        if (ruleKey.equals(color)) {\\n            i = 1;  // If ruleKey is \"color\", set index to 1 (color property).\\n        }\\n        String name = \"name\";\\n        if (ruleKey.equals(name)) {\\n            i = 2;  // If ruleKey is \"name\", set index to 2 (name property).\\n        }\\n\\n        // Iterate through each item in the items list.\\n        for (int j = 0; j < items.size(); j++) {\\n            // Check if the property at index i of the current item matches ruleValue.\\n            if (items.get(j).get(i).equals(ruleValue)) {\\n                count++;  // If there\\'s a match, increment the count.\\n            }\\n        }\\n        \\n        return count;  // Return the final count of items that match the rule.\\n    }\\n}\\n\\n```",
        "level": "easy",
        "type": [
            "variable value error",
            "undefined objects",
            "undefined keywords from other languages",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution {\n    public int countMatches(List<List<String>> items, String ruleKey, String ruleValue) {\n        int count = 0;  \n\n        String type = \"type;  \n        int i = 0;  \n\n        if (ruleKey.equals(type)) {\n            i = 0;  \n        }\n        String color = \"color\";\n        if (ruleKey.equals(color)) {\n            i = 2;  \n        }\n        String color;\n        if (ruleKey.equals(color)) {\n            i = 1;  // If ruleKey is \"color\", set index to 1 (color property).\n        }\n        String name = \"name\";\n        if (ruleKey.equals(name)) {\n            i = 2;  // If ruleKey is \"name\", set index to 2 (name property).\n        }\n\n        let item_count = items.length;\n        // Iterate through each item in the items list.\n        for (int j = 1; \n     }\n        Strng name =amname2j < item_count; j++) {\n            if (items.get(j).get(i).equals(ruleValue)) {\n                count++;  \n            }\n        }\n        \n        return count;  \n    }\n}\n"
    },
    {
        "slug": "relative-ranks",
        "description": "You are given an integer array score of size n, where score[i] is the score of the ith athlete in a competition. All the scores are guaranteed to be unique.\nThe athletes are placed based on their scores, where the 1st place athlete has the highest score, the 2nd place athlete has the 2nd highest score, and so on. The placement of each athlete determines their rank:\n\nThe 1st place athlete's rank is \"Gold Medal\".\nThe 2nd place athlete's rank is \"Silver Medal\".\nThe 3rd place athlete's rank is \"Bronze Medal\".\nFor the 4th place to the nth place athlete, their rank is their placement number (i.e., the xth place athlete's rank is \"x\").\n\nReturn an array answer of size n where answer[i] is the rank of the ith athlete.",
        "examples": [
            "Input: score = [5,4,3,2,1]\nOutput: [\"Gold Medal\",\"Silver Medal\",\"Bronze Medal\",\"4\",\"5\"]\nExplanation: The placements are [1st, 2nd, 3rd, 4th, 5th].",
            "Input: score = [10,3,8,9,4]\nOutput: [\"Gold Medal\",\"5\",\"Bronze Medal\",\"Silver Medal\",\"4\"]\nExplanation: The placements are [1st, 5th, 3rd, 2nd, 4th]."
        ],
        "constraints": "n == score.length\n1 <= n <= 104\n0 <= score[i] <= 106\nAll the values in score are unique.",
        "oracle_code": "class Solution {\n    public String[] findRelativeRanks(int[] score) {\n         int n=score.length;\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[b]-score[a]);\n        for(int i=0;i<n;i++) pq.add(i);\n      String[] ans = new String[n];\n                int i=1;\n        while(!pq.isEmpty()){\n            int idx=pq.poll();\n         if(i==1)   { ans[idx]=\"Gold Medal\"; i++;}\n         else if(i==2)   { ans[idx]=\"Silver Medal\"; i++;}\n         else if(i==3)   { ans[idx]=\"Bronze Medal\"; i++;}\n         else ans[idx]=Integer.toString(i++);\n        }\n        return ans;  \n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String[] findRelativeRanks(int[] score) {\\n         int n=score.length;\\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[b]-score[a]);\\n        for(int i=0;i<n;i++) pq.add(i);\\n      String[] ans = new String[n];\\n                int i=1;\\n        while(!pq.isEmpty()){\\n            int idx=pq.poll();\\n         if(i==1)   { ans[idx]=\"Gold Medal\"; i++;}\\n         else if(i==2)   { ans[idx]=\"Silver Medal\"; i++;}\\n         else if(i==3)   { ans[idx]=\"Bronze Medal\"; i++;}\\n         else ans[idx]=Integer.toString(i++);\\n        }\\n        return ans;  \\n    }\\n}\\n```",
        "level": "easy",
        "type": [
            "== and = confusion",
            "parentheses mismatch",
            "undefined keywords from other languages",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution {\n    public String[] findRelativeRanks(int[] score) {\n         int n=score.length;\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[b]-score[a]);\n        for(int i=0;i<n;i++) pq.add(i);\n        String[] ans = new String[n];\n        int i=1;\n        while(!pq.isEmpty()){\n            int idx=pq.poll();\n            if(i=1) { ans[idx]=\"Gold Medal; i++;} \n            elif(i=2) { ans[idx]=\"Silver Medal; i++;} \n            else if(i=3) { ans[idx]=\"Bronze Medal; i++;} \n            else ans[idx]=Integer.toString(i++);\n        }\n        return ans;  \n    }\n}\n"
    },
    {
        "slug": "number-of-students-doing-homework-at-a-given-time",
        "description": "Given two integer arrays startTime and endTime and given an integer queryTime.\nThe ith student started doing their homework at the time startTime[i] and finished it at time endTime[i].\nReturn the number of students doing their homework at time queryTime. More formally, return the number of students where queryTime lays in the interval [startTime[i], endTime[i]] inclusive.",
        "examples": [
            "Input: startTime = [1,2,3], endTime = [3,2,7], queryTime = 4\nOutput: 1\nExplanation: We have 3 students where:\nThe first student started doing homework at time 1 and finished at time 3 and wasn't doing anything at time 4.\nThe second student started doing homework at time 2 and finished at time 2 and also wasn't doing anything at time 4.\nThe third student started doing homework at time 3 and finished at time 7 and was the only student doing homework at time 4.",
            "Input: startTime = [4], endTime = [4], queryTime = 4\nOutput: 1\nExplanation: The only student was doing their homework at the queryTime."
        ],
        "constraints": "startTime.length == endTime.length\n1 <= startTime.length <= 100\n1 <= startTime[i] <= endTime[i] <= 1000\n1 <= queryTime <= 1000",
        "oracle_code": "class Solution {\n    public int busyStudent(int[] startTime, int[] endTime, int queryTime) {\n        int n=endTime.length;\n    int cnt=0;\n        for(int i=0;i<n;i++)\n        {\n            if(endTime[i]>=queryTime && queryTime>=startTime[i] )\n            {\n                cnt++;\n            }\n        }\n        return cnt;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int busyStudent(int[] startTime, int[] endTime, int queryTime) {\\n        int n=endTime.length;\\n    int cnt=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(endTime[i]>=queryTime && queryTime>=startTime[i] )\\n            {\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n}\\n```",
        "level": "easy",
        "type": [
            "parentheses mismatch",
            "conditional statement error",
            "wrong comment mark",
            "statement separation"
        ],
        "buggy_code": "\nclass Solution {\n    public int busyStudent(int[] startTime, int[] endTime, int queryTime) {\n        int n=endTime.length;\n        int cnt=0;\n        for(int i=0;i<=n;i++)\n         /*    if(endTime[i]>=queryTime && queryTime>=startTime[i])\n            {\n                cnt++;\n            } */\n            {\n        return cnt;  \n    return cnt\n    }\n}\n\n"
    },
    {
        "slug": "swap-adjacent-in-lr-string",
        "description": "In a string composed of 'L', 'R', and 'X' characters, like \"RXXLRXRXL\", a move consists of either replacing one occurrence of \"XL\" with \"LX\", or replacing one occurrence of \"RX\" with \"XR\". Given the starting string start and the ending string end, return True if and only if there exists a sequence of moves to transform one string to the other.",
        "examples": [
            "Input: start = \"RXXLRXRXL\", end = \"XRLXXRRLX\"\nOutput: true\nExplanation: We can transform start to end following these steps:\nRXXLRXRXL ->\nXRXLRXRXL ->\nXRLXRXRXL ->\nXRLXXRRXL ->\nXRLXXRRLX",
            "Input: start = \"X\", end = \"L\"\nOutput: false"
        ],
        "constraints": "1 <= start.length\u00a0<= 104\nstart.length == end.length\nBoth start and end will only consist of characters in 'L', 'R', and\u00a0'X'.",
        "oracle_code": "class Solution {\n    public boolean canTransform(String start, String end) {\n        Queue<Node> logs = new LinkedList<>();\n\n        int count = 0;\n        for (char c : start.toCharArray()) {\n            if (c == 'X') count++;\n            else {\n                logs.add(new Node(c, count));\n            }\n        }\n\n        count = 0;\n        for (char c : end.toCharArray()) {\n            if (c == 'X') count++;\n            else {\n                if (logs.isEmpty()) return false;\n\n                Node node = logs.poll();\n                if (c != node.c) return false;\n\n                if (c == 'L' && count > node.count) return false;\n                if (c == 'R' && count < node.count) return false;                \n            }\n        }\n\n        return logs.isEmpty();\n    }\n\n    class Node {\n        public Character c;\n        public int count;\n\n        public Node(Character c, int count) {\n            this.c = c;\n            this.count = count;\n        }\n    }\n}",
        "content": "The idea is must guarantee:\\n- Number of L, R are the same and keep ordering. \\n- Number of X on the left of L from `end` always less than or equal the corresponding L from `start`\\n- Number of X on the right of R from `end` always more than or equal the corresponding R from `start`\\n\\nWe can terminate the process early once got the first violation, no need to loop through the end of `start`.\\n\\n# Complexity\\n- Time complexity: `O(n)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: `O(n)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean canTransform(String start, String end) {\\n        Queue<Node> logs = new LinkedList<>();\\n\\n        int count = 0;\\n        for (char c : start.toCharArray()) {\\n            if (c == \\'X\\') count++;\\n            else {\\n                logs.add(new Node(c, count));\\n            }\\n        }\\n\\n        count = 0;\\n        for (char c : end.toCharArray()) {\\n            if (c == \\'X\\') count++;\\n            else {\\n                if (logs.isEmpty()) return false;\\n\\n                Node node = logs.poll();\\n                if (c != node.c) return false;\\n\\n                if (c == \\'L\\' && count > node.count) return false;\\n                if (c == \\'R\\' && count < node.count) return false;                \\n            }\\n        }\\n\\n        return logs.isEmpty();\\n    }\\n\\n    class Node {\\n        public Character c;\\n        public int count;\\n\\n        public Node(Character c, int count) {\\n            this.c = c;\\n            this.count = count;\\n        }\\n    }\\n}\\n```",
        "level": "medium",
        "type": [
            "conditional statement error",
            "undefined objects",
            "unclosed string",
            "statement separation"
        ],
        "buggy_code": "\nclass Solution {\n    public boolean canTransform(String start, String end) {\n        Queue<Node> logs = new LinkedList<>();\n\n        int count = 0;\n        for (char c : start.toCharArray()) {\n            if (c == 'X') count++;\n            else {\n                logs.add(new Node1(c, count);\n            }\n        }\n\n        count = 0;\n        for (char c : end.toCharArray()) {\n            if (c == 'X') count++;\n            else {\n                if (logs.isEmpty()) return false;\n\n                Node node = logs.poll();\n                if (c != node.c) return false;\n\n                if (c == 'L' && count < node.count) return false; \n                if (c == 'R' && count > node.count) return false;                \n            }\n        }\n\n        return logs.isEmpty()\n    }\n\n    class Node {\n        public Character c;\n        public int count;\n\n        public Node(Character c, int count) {\n            this.c = c;\n            this.count = count;\n        }\n    }\n}\n"
    },
    {
        "slug": "probability-of-a-two-boxes-having-the-same-number-of-distinct-balls",
        "description": "Given 2n balls of k distinct colors. You will be given an integer array balls of size k where balls[i] is the number of balls of color i.\nAll the balls will be shuffled uniformly at random, then we will distribute the first n balls to the first box and the remaining n balls to the other box (Please read the explanation of the second example carefully).\nPlease note that the two boxes are considered different. For example, if we have two balls of colors a and b, and two boxes [] and (), then the distribution [a] (b) is considered different than the distribution [b] (a) (Please read the explanation of the first example carefully).\nReturn the probability that the two boxes have the same number of distinct balls. Answers within 10-5 of the actual value will be accepted as correct.",
        "examples": [
            "Input: balls = [1,1]\nOutput: 1.00000\nExplanation: Only 2 ways to divide the balls equally:\n- A ball of color 1 to box 1 and a ball of color 2 to box 2\n- A ball of color 2 to box 1 and a ball of color 1 to box 2\nIn both ways, the number of distinct colors in each box is equal. The probability is 2/2 = 1",
            "Input: balls = [2,1,1]\nOutput: 0.66667\nExplanation: We have the set of balls [1, 1, 2, 3]\nThis set of balls will be shuffled randomly and we may have one of the 12 distinct shuffles with equal probability (i.e. 1/12):\n[1,1 / 2,3], [1,1 / 3,2], [1,2 / 1,3], [1,2 / 3,1], [1,3 / 1,2], [1,3 / 2,1], [2,1 / 1,3], [2,1 / 3,1], [2,3 / 1,1], [3,1 / 1,2], [3,1 / 2,1], [3,2 / 1,1]\nAfter that, we add the first two balls to the first box and the second two balls to the second box.\nWe can see that 8 of these 12 possible random distributions have the same number of distinct colors of balls in each box.\nProbability is 8/12 = 0.66667",
            "Input: balls = [1,2,1,2]\nOutput: 0.60000\nExplanation: The set of balls is [1, 2, 2, 3, 4, 4]. It is hard to display all the 180 possible random shuffles of this set but it is easy to check that 108 of them will have the same number of distinct colors in each box.\nProbability = 108 / 180 = 0.6"
        ],
        "constraints": "1 <= balls.length <= 8\n1 <= balls[i] <= 6\nsum(balls) is even.",
        "oracle_code": "class Solution {\n    double possible = 0.0;\n    double valid = 0.0;\n    \n    public double getProbability(int[] balls) {\n        int[] first = new int[balls.length];\n        int[] second = new int[balls.length];\n        dfs(balls, first, second, 0, 0, 0);\n        return valid / possible;\n    }\n    \n    private void dfs(int[] balls, int[] first, int[] second, int num1, int num2, int idx) {\n        // finish all colors, check if this's a possible/valid distribution\n        if (idx == balls.length) {\n            // find one possible distribution\n            if (num1 == num2) {\n                // compute fake permutation\n                double distrib = permFake(first) * permFake(second);\n                possible += distrib;\n                \n                // find one valid distribution\n                if (unique(first) == unique(second)) {\n                    valid += distrib;\n                }\n            }\n            return;\n        }\n        \n        // distribute balls in current color to two bins\n        for (int b = 0; b <= balls[idx]; b++) {\n            first[idx] = b;\n            second[idx] = balls[idx] - b;\n            dfs (balls, first, second, num1 + first[idx], num2 + second[idx], idx + 1);\n        }\n    }\n    \n    // unique colors in \n    private int unique(int[] balls) {\n        int unique = 0;\n        for (int b: balls)\n            unique += b > 0 ? 1 : 0;\n        return unique;\n    }\n    \n    // return 1 / (b1!b2!b3!...bn!) \n    private double permFake(int[] balls) {\n        double ret = 1.0;\n        for (int b: balls)\n            ret /= factorial(b);\n        return ret;\n    }\n    \n    private int factorial(int n){\n        int ret = 1;\n        while (n > 0) {\n            ret *= n;\n            n--;\n        }\n        return ret;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    double possible = 0.0;\\n    double valid = 0.0;\\n    \\n    public double getProbability(int[] balls) {\\n        int[] first = new int[balls.length];\\n        int[] second = new int[balls.length];\\n        dfs(balls, first, second, 0, 0, 0);\\n        return valid / possible;\\n    }\\n    \\n    private void dfs(int[] balls, int[] first, int[] second, int num1, int num2, int idx) {\\n        // finish all colors, check if this\\'s a possible/valid distribution\\n        if (idx == balls.length) {\\n            // find one possible distribution\\n            if (num1 == num2) {\\n                // compute fake permutation\\n                double distrib = permFake(first) * permFake(second);\\n                possible += distrib;\\n                \\n                // find one valid distribution\\n                if (unique(first) == unique(second)) {\\n                    valid += distrib;\\n                }\\n            }\\n            return;\\n        }\\n        \\n        // distribute balls in current color to two bins\\n        for (int b = 0; b <= balls[idx]; b++) {\\n            first[idx] = b;\\n            second[idx] = balls[idx] - b;\\n            dfs (balls, first, second, num1 + first[idx], num2 + second[idx], idx + 1);\\n        }\\n    }\\n    \\n    // unique colors in \\n    private int unique(int[] balls) {\\n        int unique = 0;\\n        for (int b: balls)\\n            unique += b > 0 ? 1 : 0;\\n        return unique;\\n    }\\n    \\n    // return 1 / (b1!b2!b3!...bn!) \\n    private double permFake(int[] balls) {\\n        double ret = 1.0;\\n        for (int b: balls)\\n            ret /= factorial(b);\\n        return ret;\\n    }\\n    \\n    private int factorial(int n){\\n        int ret = 1;\\n        while (n > 0) {\\n            ret *= n;\\n            n--;\\n        }\\n        return ret;\\n    }\\n}\\n```",
        "level": "hard",
        "type": [
            "operation error",
            "colon missing",
            "unclosed string",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\n    double possible = 0.0;\n    double valid = 0.0;\n    \n    public double getProbability(int[] balls) {\n        int[] first = new int[balls.length];\n        int[] second = new int[balls.length];\n        dfs(balls, first, second, 0, 0, 0)\n        return valid / possible;\n    }\n    \n    private void dfs(int[] balls, int[] first, int[] second, int num1, int num2, int idx) {\n        if (idx == balls.length) {if (num1 == num2) {\n                double distrib = permFake(first) * permFake(second);\n                possible += distrib;\n                if (unique(first) == unique(second)) {\n                    valid += distrib + 1;    \n                }\n            }\n            return;\n        }\n        for (int b = 0; b <= balls[idx]; b++) {\n            first[idx] = b;\n            second[idx] = balls[idx] - b;\n            dfs (balls, first, second, num1 + first[idx], num2 + second[idx], idx + 1);\n        }\n    }\n    \n    private int([] balls) {\n       =0;for ( b: balls)\n           +b > b > \"?10;returnprivate int factorial(int n){\n        int ret = 1;\n        while (n > 0) {\n            ret *= n;\n            n--;\n        }\n        return ret;\n    }\n}\n"
    },
    {
        "slug": "add-strings",
        "description": "Given two non-negative integers, num1 and num2 represented as string, return the sum of num1 and num2 as a string.\nYou must solve the problem without using any built-in library for handling large integers (such as BigInteger). You must also not convert the inputs to integers directly.",
        "examples": [
            "Input: num1 = \"11\", num2 = \"123\"\nOutput: \"134\"",
            "Input: num1 = \"456\", num2 = \"77\"\nOutput: \"533\"",
            "Input: num1 = \"0\", num2 = \"0\"\nOutput: \"0\""
        ],
        "constraints": "1 <= num1.length, num2.length <= 104\nnum1 and num2 consist of only digits.\nnum1 and num2 don't have any leading zeros except for the zero itself.",
        "oracle_code": "class Solution:\n    def addStrings(self, num1: str, num2: str) -> str:\n        sys.set_int_max_str_digits(10000)\n        nattu = int(num1)\n        babu = int(num2)\n        result = str(nattu+babu)\n        return result",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def addStrings(self, num1: str, num2: str) -> str:\\n        sys.set_int_max_str_digits(10000)\\n        nattu = int(num1)\\n        babu = int(num2)\\n        result = str(nattu+babu)\\n        return result\\n\\n```",
        "level": "easy",
        "type": [
            "colon missing",
            "undefined objects",
            "undefined keywords from other languages",
            "statement separation"
        ],
        "buggy_code": "\nclass Solution:\n    def addStrings(self, num1: str, num2: str) -> str:\n        undefined_sys_obj.set_int_max_str_digits 10000\n        nattu = int(num1) babu = int(num2)\n        result = str(nattu+babu)\n        return result\n"
    },
    {
        "slug": "add-strings",
        "description": "Given two non-negative integers, num1 and num2 represented as string, return the sum of num1 and num2 as a string.\nYou must solve the problem without using any built-in library for handling large integers (such as BigInteger). You must also not convert the inputs to integers directly.",
        "examples": [
            "Input: num1 = \"11\", num2 = \"123\"\nOutput: \"134\"",
            "Input: num1 = \"456\", num2 = \"77\"\nOutput: \"533\"",
            "Input: num1 = \"0\", num2 = \"0\"\nOutput: \"0\""
        ],
        "constraints": "1 <= num1.length, num2.length <= 104\nnum1 and num2 consist of only digits.\nnum1 and num2 don't have any leading zeros except for the zero itself.",
        "oracle_code": "class Solution:\n    def addStrings(self, num1: str, num2: str) -> str:\n        sys.set_int_max_str_digits(10000)\n        nattu = int(num1)\n        babu = int(num2)\n        result = str(nattu+babu)\n        return result",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def addStrings(self, num1: str, num2: str) -> str:\\n        sys.set_int_max_str_digits(10000)\\n        nattu = int(num1)\\n        babu = int(num2)\\n        result = str(nattu+babu)\\n        return result\\n\\n```",
        "level": "easy",
        "type": [
            "variable value error",
            "colon missing",
            "undefined objects",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution:\n    def addStrings(self, num1: str, num2: str) -> str:\n        undefined_sys_obj.set_int_max_str_digits 10000\n        nattu = int(num1)\n        babu = int(num1)\n        result = str(nattu+babu)\n        return result\n"
    },
    {
        "slug": "number-of-laser-beams-in-a-bank",
        "description": "Anti-theft security devices are activated inside a bank. You are given a 0-indexed binary string array bank representing the floor plan of the bank, which is an m x n 2D matrix. bank[i] represents the ith row, consisting of '0's and '1's. '0' means the cell is empty, while'1' means the cell has a security device.\nThere is one laser beam between any two security devices if both conditions are met:\n\nThe two devices are located on two different rows: r1 and r2, where r1 < r2.\nFor each row i where r1 < i < r2, there are no security devices in the ith row.\n\nLaser beams are independent, i.e., one beam does not interfere nor join with another.\nReturn the total number of laser beams in the bank.",
        "examples": [
            "Input: bank = [\"011001\",\"000000\",\"010100\",\"001000\"]\nOutput: 8\nExplanation: Between each of the following device pairs, there is one beam. In total, there are 8 beams:\n * bank[0][1] -- bank[2][1]\n * bank[0][1] -- bank[2][3]\n * bank[0][2] -- bank[2][1]\n * bank[0][2] -- bank[2][3]\n * bank[0][5] -- bank[2][1]\n * bank[0][5] -- bank[2][3]\n * bank[2][1] -- bank[3][2]\n * bank[2][3] -- bank[3][2]\nNote that there is no beam between any device on the 0th row with any on the 3rd row.\nThis is because the 2nd row contains security devices, which breaks the second condition.",
            "Input: bank = [\"000\",\"111\",\"000\"]\nOutput: 0\nExplanation: There does not exist two devices located on two different rows."
        ],
        "constraints": "m == bank.length\nn == bank[i].length\n1 <= m, n <= 500\nbank[i][j] is either '0' or '1'.",
        "oracle_code": "class Solution {\n    public int numberOfBeams(String[] bank) {\n        int prevLazer =0;\n        int ans =0;\n        for(String s:bank){\n            int curLazer = 0;\n            for(char c: s.toCharArray()){\n                if(c=='1'){\n                    curLazer++;\n                }\n            }\n            if(curLazer >0){\n                ans += (curLazer * prevLazer);\n                prevLazer = curLazer;\n            }\n        }\n        return ans;\n    }\n}",
        "content": "\\n# java Code\\n```\\nclass Solution {\\n    public int numberOfBeams(String[] bank) {\\n        int prevLazer =0;\\n        int ans =0;\\n        for(String s:bank){\\n            int curLazer = 0;\\n            for(char c: s.toCharArray()){\\n                if(c==\\'1\\'){\\n                    curLazer++;\\n                }\\n            }\\n            if(curLazer >0){\\n                ans += (curLazer * prevLazer);\\n                prevLazer = curLazer;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
        "level": "medium",
        "type": [
            "variable value error",
            "wrong comment mark",
            "undefined keywords from other languages",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution {\n    public int numberOfBeams(String[] bank) {\n        int prevLazer =0;\n        int ans =0;\n        for(String s:bank){\n            int curLazer = 0;\n            for(char c: s.toCharArray()){\n                if(c=='1){\n                    curLazer++;\n            }\n\n                ans += (curLazer * prevLazer);\n                prevLazer = curLazer;\n            }\n        } return ans;\n    le{\n                prevLazer = 0;\n            \n        }\n        print(ans);\n        return ans;\n    }\n}\n\"The total number of beams is: \" + \n"
    },
    {
        "slug": "intersection-of-multiple-arrays",
        "description": "Given a 2D integer array nums where nums[i] is a non-empty array of distinct positive integers, return the list of integers that are present in each array of nums sorted in ascending order.",
        "examples": [
            "Input: nums = [[3,1,2,4,5],[1,2,3,4],[3,4,5,6]]\nOutput: [3,4]\nExplanation: \nThe only integers present in each of nums[0] = [3,1,2,4,5], nums[1] = [1,2,3,4], and nums[2] = [3,4,5,6] are 3 and 4, so we return [3,4].",
            "Input: nums = [[1,2,3],[4,5,6]]\nOutput: []\nExplanation: \nThere does not exist any integer present both in nums[0] and nums[1], so we return an empty list []."
        ],
        "constraints": "1 <= nums.length <= 1000\n1 <= sum(nums[i].length) <= 1000\n1 <= nums[i][j] <= 1000\nAll the values of nums[i] are unique.",
        "oracle_code": "class Solution {\n    public List<Integer> intersection(int[][] nums) {\n        \n        List<Integer> ans = new ArrayList<>();\n        \n        int[] count  = new int[1001];\n        \n        for(int[] arr : nums){\n            for(int i : arr){\n                count[i]++;\n            }\n        }\n        \n       for(int i=0;i<count.length;i++){\n           if(count[i]==nums.length){\n               ans.add(i);\n           }\n       }\n        \n        return ans;\n    }\n}",
        "content": "```\\n\\nclass Solution {\\n    public List<Integer> intersection(int[][] nums) {\\n        \\n        List<Integer> ans = new ArrayList<>();\\n        \\n        int[] count  = new int[1001];\\n        \\n        for(int[] arr : nums){\\n            for(int i : arr){\\n                count[i]++;\\n            }\\n        }\\n        \\n       for(int i=0;i<count.length;i++){\\n           if(count[i]==nums.length){\\n               ans.add(i);\\n           }\\n       }\\n        \\n        return ans;\\n    }\\n}\\n\\n```",
        "level": "easy",
        "type": [
            "== and = confusion",
            "colon missing",
            "wrong comment mark",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\n    public List<Integer> intersection(int[][] nums) {\n        \n        List<Integer> ans = new ArrayList<>();\n        \n        int[] count  = new int[1001]\n        \n        \n            for(int i : arr){\n                count[i]++;\n            }\n        }\n        \n       for(int i=0;i<count.length;i++){\n           if(count[i]=nums.length){\n               ans.add(i);\n           }\n       }\n        \n        myRandomUndefinedFunction();\n        \n        return ans;\n    }\n}\n"
    },
    {
        "slug": "add-strings",
        "description": "Given two non-negative integers, num1 and num2 represented as string, return the sum of num1 and num2 as a string.\nYou must solve the problem without using any built-in library for handling large integers (such as BigInteger). You must also not convert the inputs to integers directly.",
        "examples": [
            "Input: num1 = \"11\", num2 = \"123\"\nOutput: \"134\"",
            "Input: num1 = \"456\", num2 = \"77\"\nOutput: \"533\"",
            "Input: num1 = \"0\", num2 = \"0\"\nOutput: \"0\""
        ],
        "constraints": "1 <= num1.length, num2.length <= 104\nnum1 and num2 consist of only digits.\nnum1 and num2 don't have any leading zeros except for the zero itself.",
        "oracle_code": "class Solution:\n    def addStrings(self, num1: str, num2: str) -> str:\n        sys.set_int_max_str_digits(10000)\n        nattu = int(num1)\n        babu = int(num2)\n        result = str(nattu+babu)\n        return result",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def addStrings(self, num1: str, num2: str) -> str:\\n        sys.set_int_max_str_digits(10000)\\n        nattu = int(num1)\\n        babu = int(num2)\\n        result = str(nattu+babu)\\n        return result\\n\\n```",
        "level": "easy",
        "type": [
            "variable value error",
            "colon missing",
            "undefined keywords from other languages",
            "statement separation"
        ],
        "buggy_code": "\nclass Solution:\n    def addStrings(self, num1: str, num2: str) -> str:\n        sys.set_int_max_str_digits 10000\n        nattu = int(num1) babu = int(num1)\n        result = str(nattu+babu)\n        return result\n"
    },
    {
        "slug": "maximum-average-pass-ratio",
        "description": "There is a school that has classes of students and each class will be having a final exam. You are given a 2D integer array classes, where classes[i] = [passi, totali]. You know beforehand that in the ith class, there are totali total students, but only passi number of students will pass the exam.\nYou are also given an integer extraStudents. There are another extraStudents brilliant students that are guaranteed to pass the exam of any class they are assigned to. You want to assign each of the extraStudents students to a class in a way that maximizes the average pass ratio across all the classes.\nThe pass ratio of a class is equal to the number of students of the class that will pass the exam divided by the total number of students of the class. The average pass ratio is the sum of pass ratios of all the classes divided by the number of the classes.\nReturn the maximum possible average pass ratio after assigning the extraStudents students. Answers within 10-5 of the actual answer will be accepted.",
        "examples": [
            "Input: classes = [[1,2],[3,5],[2,2]], extraStudents = 2\nOutput: 0.78333\nExplanation: You can assign the two extra students to the first class. The average pass ratio will be equal to (3/4 + 3/5 + 2/2) / 3 = 0.78333.",
            "Input: classes = [[2,4],[3,9],[4,5],[2,10]], extraStudents = 4\nOutput: 0.53485"
        ],
        "constraints": "1 <= classes.length <= 105\nclasses[i].length == 2\n1 <= passi <= totali <= 105\n1 <= extraStudents <= 105",
        "oracle_code": "class Solution {\n    public double maxAverageRatio(int[][] classes, int extraStudents) {\n        PriorityQueue<Class> pq = new PriorityQueue<>(new Compare());\n        for(int[] cl : classes){\n            pq.add(new Class(cl));\n        }\n        while(extraStudents > 0){\n            Class c = pq.remove();\n            c.addExtraStudent();\n            extraStudents--;\n            pq.add(c);\n        }\n        double sum = 0;\n        while(!pq.isEmpty()){\n            Class c = pq.remove();\n            sum += c.pass / c.total;\n        }\n        return sum / classes.length;\n    }\n}\nclass Class{\n    double pass;\n    double total;\n    double inc;\n    public Class(int[] cl){\n        pass = cl[0];\n        total = cl[1];\n        inc = (pass + 1) / (total + 1) - pass / total;\n    }\n    public void addExtraStudent(){\n        pass += 1;\n        total += 1;\n        inc = (pass + 1) / (total + 1) - pass / total;\n    }\n}\nclass Compare implements Comparator<Class>{\n    public int compare(Class c1, Class c2){\n        if(c1.inc < c2.inc){\n            return 1;\n        }else if(c1.inc > c2.inc){\n            return -1;\n        }else{\n            return 0;\n        }\n    }\n}",
        "content": "\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public double maxAverageRatio(int[][] classes, int extraStudents) {\\n        PriorityQueue<Class> pq = new PriorityQueue<>(new Compare());\\n        for(int[] cl : classes){\\n            pq.add(new Class(cl));\\n        }\\n        while(extraStudents > 0){\\n            Class c = pq.remove();\\n            c.addExtraStudent();\\n            extraStudents--;\\n            pq.add(c);\\n        }\\n        double sum = 0;\\n        while(!pq.isEmpty()){\\n            Class c = pq.remove();\\n            sum += c.pass / c.total;\\n        }\\n        return sum / classes.length;\\n    }\\n}\\nclass Class{\\n    double pass;\\n    double total;\\n    double inc;\\n    public Class(int[] cl){\\n        pass = cl[0];\\n        total = cl[1];\\n        inc = (pass + 1) / (total + 1) - pass / total;\\n    }\\n    public void addExtraStudent(){\\n        pass += 1;\\n        total += 1;\\n        inc = (pass + 1) / (total + 1) - pass / total;\\n    }\\n}\\nclass Compare implements Comparator<Class>{\\n    public int compare(Class c1, Class c2){\\n        if(c1.inc < c2.inc){\\n            return 1;\\n        }else if(c1.inc > c2.inc){\\n            return -1;\\n        }else{\\n            return 0;\\n        }\\n    }\\n}\\n```",
        "level": "medium",
        "type": [
            "colon missing",
            "other error",
            "indexing error",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution {\n    public double maxAverageRatio(int[][] classes, int extraStudents) {\n        PriorityQueue<Class> pq = new PriorityQueue<>(new Compare());\n        for(int[] cl : classes){\n            pq.add(new Class(cl));\n        }\n        while(extraStudents > 0){\n            Class c = pq.remove();\n            c.addExtraStudent()\n            extraStudents--;\n        }\n        double sum = 0;\n        while(!pq.isEmpty()){\n            Class c = pq.remove();\n            sum += c.pass / (c.total - 1);\n        }\n        return sum / classes.length;\n    }\n}\nclass Class{\n    double pass;\n    double total;\n    double inc;\n    public Class(int[] cl){\n        pass = cl[0];\n        total = cl[1];\n        inc = (pass + 1) / (total + 1) - pass / total;\n    }\n    public void addExtraStudent(){\n        pass += 1;\n        total += 1;\n        def inc = (pass + 1) / (total + 1) - pass / total;\n    }\n}\nclass Compare implements Comparator<Class>{\n    public int compare(Class c1, Class c2){\n        if(c1.inc < c2.inc){\n            return 1;\n        }else if(c1.inc > c2.inc){\n            return -1;\n        }else{\n            return 0;\n        }\n    }\n}\n"
    },
    {
        "slug": "add-strings",
        "description": "Given two non-negative integers, num1 and num2 represented as string, return the sum of num1 and num2 as a string.\nYou must solve the problem without using any built-in library for handling large integers (such as BigInteger). You must also not convert the inputs to integers directly.",
        "examples": [
            "Input: num1 = \"11\", num2 = \"123\"\nOutput: \"134\"",
            "Input: num1 = \"456\", num2 = \"77\"\nOutput: \"533\"",
            "Input: num1 = \"0\", num2 = \"0\"\nOutput: \"0\""
        ],
        "constraints": "1 <= num1.length, num2.length <= 104\nnum1 and num2 consist of only digits.\nnum1 and num2 don't have any leading zeros except for the zero itself.",
        "oracle_code": "class Solution:\n    def addStrings(self, num1: str, num2: str) -> str:\n        sys.set_int_max_str_digits(10000)\n        nattu = int(num1)\n        babu = int(num2)\n        result = str(nattu+babu)\n        return result",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def addStrings(self, num1: str, num2: str) -> str:\\n        sys.set_int_max_str_digits(10000)\\n        nattu = int(num1)\\n        babu = int(num2)\\n        result = str(nattu+babu)\\n        return result\\n\\n```",
        "level": "easy",
        "type": [
            "variable value error",
            "colon missing",
            "undefined objects",
            "statement separation"
        ],
        "buggy_code": "\nclass Solution:\n    def addStrings(self, num1: str, num2: str) -> str:\n        undefined_sys_obj.set_int_max_str_digits 10000\n        nattu = int(num1) babu = int(num1)\n        result = str(nattu+babu)\n        return result\n"
    },
    {
        "slug": "relative-ranks",
        "description": "You are given an integer array score of size n, where score[i] is the score of the ith athlete in a competition. All the scores are guaranteed to be unique.\nThe athletes are placed based on their scores, where the 1st place athlete has the highest score, the 2nd place athlete has the 2nd highest score, and so on. The placement of each athlete determines their rank:\n\nThe 1st place athlete's rank is \"Gold Medal\".\nThe 2nd place athlete's rank is \"Silver Medal\".\nThe 3rd place athlete's rank is \"Bronze Medal\".\nFor the 4th place to the nth place athlete, their rank is their placement number (i.e., the xth place athlete's rank is \"x\").\n\nReturn an array answer of size n where answer[i] is the rank of the ith athlete.",
        "examples": [
            "Input: score = [5,4,3,2,1]\nOutput: [\"Gold Medal\",\"Silver Medal\",\"Bronze Medal\",\"4\",\"5\"]\nExplanation: The placements are [1st, 2nd, 3rd, 4th, 5th].",
            "Input: score = [10,3,8,9,4]\nOutput: [\"Gold Medal\",\"5\",\"Bronze Medal\",\"Silver Medal\",\"4\"]\nExplanation: The placements are [1st, 5th, 3rd, 2nd, 4th]."
        ],
        "constraints": "n == score.length\n1 <= n <= 104\n0 <= score[i] <= 106\nAll the values in score are unique.",
        "oracle_code": "class Solution {\n    public String[] findRelativeRanks(int[] score) {\n         int n=score.length;\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[b]-score[a]);\n        for(int i=0;i<n;i++) pq.add(i);\n      String[] ans = new String[n];\n                int i=1;\n        while(!pq.isEmpty()){\n            int idx=pq.poll();\n         if(i==1)   { ans[idx]=\"Gold Medal\"; i++;}\n         else if(i==2)   { ans[idx]=\"Silver Medal\"; i++;}\n         else if(i==3)   { ans[idx]=\"Bronze Medal\"; i++;}\n         else ans[idx]=Integer.toString(i++);\n        }\n        return ans;  \n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String[] findRelativeRanks(int[] score) {\\n         int n=score.length;\\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[b]-score[a]);\\n        for(int i=0;i<n;i++) pq.add(i);\\n      String[] ans = new String[n];\\n                int i=1;\\n        while(!pq.isEmpty()){\\n            int idx=pq.poll();\\n         if(i==1)   { ans[idx]=\"Gold Medal\"; i++;}\\n         else if(i==2)   { ans[idx]=\"Silver Medal\"; i++;}\\n         else if(i==3)   { ans[idx]=\"Bronze Medal\"; i++;}\\n         else ans[idx]=Integer.toString(i++);\\n        }\\n        return ans;  \\n    }\\n}\\n```",
        "level": "easy",
        "type": [
            "operation error",
            "undefined objects",
            "unclosed string",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\n    public String[] findRelativeRanks(int[] score) {\n         int n = score.length;\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[a]-score[b]);\n        for(int i=0;i<n;i++) pq.add(i);\n        String[] ans = null;\n                int i=1;\n        while(!pq.isEmpty()){\n            int idx=pq.poll();\n         if(i==1)   { ans[idx]=\"Gold Medal; i++;}\n         else if(i==2)   { ans[idx]=\"Silver Medal; i++;}\n         else if(i==3)   { ans[idx]=\"Bronze Medal; i++;}\n         else ans[idx]=Integer.toString(i++);\n        }\n        return reorderArray(ans);  \n    }\n\n    private String[] reorderArray(String[] ranks){\n        \n    }\n}\n"
    },
    {
        "slug": "construct-binary-tree-from-inorder-and-postorder-traversal",
        "description": "Given two integer arrays inorder and postorder where inorder is the inorder traversal of a binary tree and postorder is the postorder traversal of the same tree, construct and return the binary tree.",
        "examples": [
            "Input: inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]\nOutput: [3,9,20,null,null,15,7]",
            "Input: inorder = [-1], postorder = [-1]\nOutput: [-1]"
        ],
        "constraints": "1 <= inorder.length <= 3000\npostorder.length == inorder.length\n-3000 <= inorder[i], postorder[i] <= 3000\ninorder and postorder consist of unique values.\nEach value of postorder also appears in inorder.\ninorder is guaranteed to be the inorder traversal of the tree.\npostorder is guaranteed to be the postorder traversal of the tree.",
        "oracle_code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    int index;\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\n        Map<Integer, Integer> m = new HashMap<>();\n\n        for(int i = 0; i < inorder.length; i++) {\n            m.put(inorder[i], i);\n        }\n        index = postorder.length - 1;\n        return buildTree(0, postorder.length - 1, postorder, m);\n    }\n\n    private TreeNode buildTree(int l, int r, int postorder[] , Map<Integer, Integer> m) {\n        if(l > r) return null;\n\n        int val = postorder[index];\n        index--;\n\n        TreeNode root = new TreeNode(val);\n        if(l == r) return root;\n\n        int in = m.get(val);\n\n        root.right = buildTree(in + 1, r, postorder, m);\n        root.left = buildTree(l, in - 1, postorder, m);\n\n        return root;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int index;\\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\\n        Map<Integer, Integer> m = new HashMap<>();\\n\\n        for(int i = 0; i < inorder.length; i++) {\\n            m.put(inorder[i], i);\\n        }\\n        index = postorder.length - 1;\\n        return buildTree(0, postorder.length - 1, postorder, m);\\n    }\\n\\n    private TreeNode buildTree(int l, int r, int postorder[] , Map<Integer, Integer> m) {\\n        if(l > r) return null;\\n\\n        int val = postorder[index];\\n        index--;\\n\\n        TreeNode root = new TreeNode(val);\\n        if(l == r) return root;\\n\\n        int in = m.get(val);\\n\\n        root.right = buildTree(in + 1, r, postorder, m);\\n        root.left = buildTree(l, in - 1, postorder, m);\\n\\n        return root;\\n    }\\n}\\n```",
        "level": "medium",
        "type": [
            "operation error",
            "parentheses mismatch",
            "indexing error",
            "undefined objects"
        ],
        "buggy_code": "\n\n\n\nclass Solution {\n    int index;\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\n        Map<Integer, Integer> m = new HashMap<>();\n\n        for(int i = 0; i <= inorder.length; i++) {\n            m.put(inorder[i], i);\n        }\n        index = postorder.length - 1;\n        \n        return buildTree(0, postorder.length - 2, postorder, m;\n    }\n\n    private TreeNode buildTree(int l, int r, int postorder[] , Map<Integer, Integer> m) {\n        if(l > r) return null;\n\n        int val = postorder[index];\n        index--;\n\n        TreeNode root = new TreeNode(val);\n        if(l == r) return root;\n\n        int in = m.get(val);\n\n        root.right = null;\n        root.left = buildTree(l, in - 1, postorder, m);\n\n        return root;\n    }\n}\n"
    }
]