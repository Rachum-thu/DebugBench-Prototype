[
    {
        "slug": "path-with-maximum-probability",
        "description": "You are given an undirected weighted graph of\u00a0n\u00a0nodes (0-indexed), represented by an edge list where\u00a0edges[i] = [a, b]\u00a0is an undirected edge connecting the nodes\u00a0a\u00a0and\u00a0b\u00a0with a probability of success of traversing that edge\u00a0succProb[i].\nGiven two nodes\u00a0start\u00a0and\u00a0end, find the path with the maximum probability of success to go from\u00a0start\u00a0to\u00a0end\u00a0and return its success probability.\nIf there is no path from\u00a0start\u00a0to\u00a0end, return\u00a00. Your answer will be accepted if it differs from the correct answer by at most 1e-5.",
        "examples": [
            "Input: n = 3, edges = [[0,1],[1,2],[0,2]], succProb = [0.5,0.5,0.2], start = 0, end = 2\nOutput: 0.25000\nExplanation:\u00a0There are two paths from start to end, one having a probability of success = 0.2 and the other has 0.5 * 0.5 = 0.25.",
            "Input: n = 3, edges = [[0,1],[1,2],[0,2]], succProb = [0.5,0.5,0.3], start = 0, end = 2\nOutput: 0.30000",
            "Input: n = 3, edges = [[0,1]], succProb = [0.5], start = 0, end = 2\nOutput: 0.00000\nExplanation:\u00a0There is no path between 0 and 2."
        ],
        "constraints": "2 <= n <= 10^4\n0 <= start, end < n\nstart != end\n0 <= a, b < n\na != b\n0 <= succProb.length == edges.length <= 2*10^4\n0 <= succProb[i] <= 1\nThere is at most one edge between every two nodes.",
        "release_time": 1687928964,
        "oracle_code": "class Solution {\npublic:\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\n        unordered_map<int, vector<pair<int, int>>> graph;\n        \n        // Build the graph using an adjacency list representation\n        // Each edge is represented as a pair (neighbor node, edge index)\n        for (int i = 0; i < edges.size(); i++) {\n            int u = edges[i][0], v = edges[i][1], edgeIdx = i;\n            graph[u].push_back({v, edgeIdx});\n            graph[v].push_back({u, edgeIdx});\n        }\n        \n        vector<double> probabilities(n, 0.0);\n        probabilities[start] = 1.0;\n        \n        priority_queue<pair<double, int>> nodesToExplore;\n        // Add the start node to the priority queue with probability 1.0\n        nodesToExplore.push({1.0, start});\n        \n        while (!nodesToExplore.empty()) {\n            auto [prob, u] = nodesToExplore.top();\n            nodesToExplore.pop();\n            \n            // If we've reached the end node, return the probability\n            if (u == end) \n                return prob;\n            // If we've already explored this node with a higher probability, skip it\n            if (probabilities[u] > prob) \n                continue;\n                \n            // Explore the neighbors of the current node\n            for (auto [v, edgeIdx] : graph[u]) {\n                double newProb = prob * succProb[edgeIdx];\n                \n                // Update the probability of the neighbor node if we've found a higher probability\n                if (newProb > probabilities[v]) {\n                    probabilities[v] = newProb;\n                    \n                    // Add the neighbor node to the priority queue with its new probability\n                    nodesToExplore.push({newProb, v});\n                }\n            }\n        }\n        \n        // If we've explored all nodes and haven't reached the end node, return 0.0\n        return 0.0;\n    }\n};",
        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        unordered_map<int, vector<pair<int, int>>> graph;\\n        \\n        // Build the graph using an adjacency list representation\\n        // Each edge is represented as a pair (neighbor node, edge index)\\n        for (int i = 0; i < edges.size(); i++) {\\n            int u = edges[i][0], v = edges[i][1], edgeIdx = i;\\n            graph[u].push_back({v, edgeIdx});\\n            graph[v].push_back({u, edgeIdx});\\n        }\\n        \\n        vector<double> probabilities(n, 0.0);\\n        probabilities[start] = 1.0;\\n        \\n        priority_queue<pair<double, int>> nodesToExplore;\\n        // Add the start node to the priority queue with probability 1.0\\n        nodesToExplore.push({1.0, start});\\n        \\n        while (!nodesToExplore.empty()) {\\n            auto [prob, u] = nodesToExplore.top();\\n            nodesToExplore.pop();\\n            \\n            // If we\\'ve reached the end node, return the probability\\n            if (u == end) \\n                return prob;\\n            // If we\\'ve already explored this node with a higher probability, skip it\\n            if (probabilities[u] > prob) \\n                continue;\\n                \\n            // Explore the neighbors of the current node\\n            for (auto [v, edgeIdx] : graph[u]) {\\n                double newProb = prob * succProb[edgeIdx];\\n                \\n                // Update the probability of the neighbor node if we\\'ve found a higher probability\\n                if (newProb > probabilities[v]) {\\n                    probabilities[v] = newProb;\\n                    \\n                    // Add the neighbor node to the priority queue with its new probability\\n                    nodesToExplore.push({newProb, v});\\n                }\\n            }\\n        }\\n        \\n        // If we\\'ve explored all nodes and haven\\'t reached the end node, return 0.0\\n        return 0.0;\\n    }\\n};\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\npublic:\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\n        unordered_map<int, vector<pair<int, int>>> graph;\n\n        // Build the graph using an adjacency list representation\n        for (int i = 0; i < edges.size(); i++) {\n            int u = edges[i][0], v = edges[i][1], edgeIdx = i;\n            graph[u].push_back({v, edgeIdx});\n            graph[v].push_back({u, edgeIdx});\n        }\n      \n        vector<double> probabilities;\n        probabilities[start] = 1.0;\n      \n        priority_queue<pair<double, int>> nodesToExplore;\n        nodesToExplore.push({1.0, start});\n      \n        while (!nodesToExplore.empty()) {\n            auto [prob, u] = nodesToExplore.top();\n            nodesToExplore.pop();\n        \n            if (u == end) \n                return prob;\n            if (probabilities[u] > prob) \n                continue;\n\n            // Explore the neighbors of the current node\n            for (auto [v, edgeIdx] : graph[u]) {\n                double newProb = prob * succProb[edgeIdx];\n\n                if (newProb > probabilities[v]) {\n                    probabilities[v] = newProb;\n                    nodesToExplore.push({newProb, v});\n                }\n            }\n        }\n      \n        return 0.0;\n    }\n};\n",
        "explanations": "\nThe bug is that the probabilities vector isn't initialized with a size of n, leading to undefined behavior.\n"
    },
    {
        "slug": "ugly-number-ii",
        "description": "An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5.\nGiven an integer n, return the nth ugly number.",
        "examples": [
            "Input: n = 10\nOutput: 12\nExplanation: [1, 2, 3, 4, 5, 6, 8, 9, 10, 12] is the sequence of the first 10 ugly numbers.",
            "Input: n = 1\nOutput: 1\nExplanation: 1 has no prime factors, therefore all of its prime factors are limited to 2, 3, and 5."
        ],
        "constraints": "1 <= n <= 1690",
        "release_time": 1690716711,
        "oracle_code": "class Solution {\npublic:\n    int nthUglyNumber(int n) \n    {\n        vector<int>dp(n);\n        dp[0]=1;\n        int p1=0;\n        int p2=0;\n        int p3=0;\n        for(int i=1;i<n;i++)\n        {\n            int two=dp[p1]*2;\n            int three=dp[p2]*3;\n            int five=dp[p3]*5;\n            dp[i]=min(two,min(three,five));\n            if(dp[i]==two)\n            p1++;\n            if(dp[i]==three)\n            p2++;\n            if(dp[i]==five)\n            p3++;\n        }\n        return dp[n-1];\n        \n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n) \\n    {\\n        vector<int>dp(n);\\n        dp[0]=1;\\n        int p1=0;\\n        int p2=0;\\n        int p3=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            int two=dp[p1]*2;\\n            int three=dp[p2]*3;\\n            int five=dp[p3]*5;\\n            dp[i]=min(two,min(three,five));\\n            if(dp[i]==two)\\n            p1++;\\n            if(dp[i]==three)\\n            p2++;\\n            if(dp[i]==five)\\n            p3++;\\n        }\\n        return dp[n-1];\\n        \\n    }\\n};\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\npublic:\n    int nthUglyNumber(int n) \n    {\n        vector<int>dp(n);\n        dp[0]=1;\n        int p1=0;\n        int p2=0;\n        int p3=0;\n        for(int i=1;i<=n;i++)\n        {\n            int two=dp[p1]*2;\n            int three=dp[p2]*3;\n            int five=dp[p3]*5;\n            dp[i]=min(two,min(three,five));\n            if(dp[i]==two)\n            p1++;\n            if(dp[i]==three)\n            p2++;\n            if(dp[i]==five)\n            p3++;\n        }\n        return dp[n];\n    }\n};\n",
        "explanations": "\nVector dp has n elements, but loop runs n+1 times, causing an out-of-bound error.\n"
    },
    {
        "slug": "magical-string",
        "description": "A magical string s consists of only '1' and '2' and obeys the following rules:\n\nThe string s is magical because concatenating the number of contiguous occurrences of characters '1' and '2' generates the string s itself.\n\nThe first few elements of s is s = \"1221121221221121122\u2026\u2026\". If we group the consecutive 1's and 2's in s, it will be \"1 22 11 2 1 22 1 22 11 2 11 22 ......\" and the occurrences of 1's or 2's in each group are \"1 2 2 1 1 2 1 2 2 1 2 2 ......\". You can see that the occurrence sequence is s itself.\nGiven an integer n, return the number of 1's in the first n number in the magical string s.",
        "examples": [
            "Input: n = 6\nOutput: 3\nExplanation: The first 6 elements of magical string s is \"122112\" and it contains three 1's, so return 3.",
            "Input: n = 1\nOutput: 1"
        ],
        "constraints": "1 <= n <= 105",
        "release_time": 1673536160,
        "oracle_code": "class Solution {\npublic:\n    int magicalString(int n) {\n        string s=\"\";\n        s+=\"122\";\n        int i=2,c=1;\n        while(i<n && s.size()<n)\n        {\n            if(s[i]=='1')\n            {\n                c++;\n                if(s[s.size()-1]=='2')\n                s+='1';\n                else\n                {\n                    s+='2';\n                }\n            }\n            else\n            {\n                if(s[s.size()-1]=='2')\n                s+=\"11\";\n                else\n                {\n                    s+=\"22\";\n                }\n            }\n            i++;\n        }\n        while(i<n)\n        {\n            if(s[i]=='1')\n            c++;\n            i++;\n        }\n        return c;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIntution was to find the repeating part first, then i saw the pattern carefully and tried to make it.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can make the string using first three digits only \"122\",my intution is to make whole string upto length n,and count ones side by side. Also to count the remaining 1\\'s after while loop breaks\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int magicalString(int n) {\\n        string s=\"\";\\n        s+=\"122\";\\n        int i=2,c=1;\\n        while(i<n && s.size()<n)\\n        {\\n            if(s[i]==\\'1\\')\\n            {\\n                c++;\\n                if(s[s.size()-1]==\\'2\\')\\n                s+=\\'1\\';\\n                else\\n                {\\n                    s+=\\'2\\';\\n                }\\n            }\\n            else\\n            {\\n                if(s[s.size()-1]==\\'2\\')\\n                s+=\"11\";\\n                else\\n                {\\n                    s+=\"22\";\\n                }\\n            }\\n            i++;\\n        }\\n        while(i<n)\\n        {\\n            if(s[i]==\\'1\\')\\n            c++;\\n            i++;\\n        }\\n        return c;\\n    }\\n};\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\npublic:\n    int magicalString(int n) {\n        string s=\"\";\n        s+=\"122\";\n        int i=2,c=1;\n        while(i<n && s.size()<n)\n        {\n            if(s[i]=='1')\n            {\n                c++;\n                if(s[s.size()-1]=='2')\n                s+='1';\n                else\n                {\n                    s+='2';\n                }\n            }\n            else\n            {\n                if(s[s.size()-1]=='2')\n                s+=\"11\";\n                else\n                {\n                    s+=\"22\";\n                }\n            }\n            i++;\n        }\n        while(i<n)\n        {\n            if(s[i]=='1')\n            c++;\n            i++;\n        }\n        undefinedObject.callMethod();\n        return c;\n    }\n}; \n",
        "explanations": "\n\"undefinedObject\" is not defined causing a runtime error when the callMethod() is invoked.\n"
    },
    {
        "slug": "buddy-strings",
        "description": "Given two strings s and goal, return true if you can swap two letters in s so the result is equal to goal, otherwise, return false.\nSwapping letters is defined as taking two indices i and j (0-indexed) such that i != j and swapping the characters at s[i] and s[j].\n\nFor example, swapping at indices 0 and 2 in \"abcd\" results in \"cbad\".",
        "examples": [
            "Input: s = \"ab\", goal = \"ba\"\nOutput: true\nExplanation: You can swap s[0] = 'a' and s[1] = 'b' to get \"ba\", which is equal to goal.",
            "Input: s = \"ab\", goal = \"ab\"\nOutput: false\nExplanation: The only letters you can swap are s[0] = 'a' and s[1] = 'b', which results in \"ba\" != goal.",
            "Input: s = \"aa\", goal = \"aa\"\nOutput: true\nExplanation: You can swap s[0] = 'a' and s[1] = 'a' to get \"aa\", which is equal to goal."
        ],
        "constraints": "1 <= s.length, goal.length <= 2 * 104\ns and goal consist of lowercase letters.",
        "release_time": 1688356386,
        "oracle_code": "class Solution {\npublic:\n    bool buddyStrings(string s, string p) {\n        int n=s.length(), m=p.length();\n        if(n!=m) return false;\n        \n        vector<int> freq(26,0);\n        \n        int first=-1, second=-1;\n        for(int i=0;i<n;i++){\n            if(s[i] != p[i]){\n                if(first==-1){\n                    first=i;\n                }else if(second==-1){\n                    second=i;\n                }else{\n                    return false; // more than 2 mismatching characters\n                }\n            }\n            freq[s[i]-'a']++;\n        }\n        \n\t\t// similar strings\n        if(first == -1 && second == -1){\n            for(int i=0;i<26;i++) if(freq[i] > 1) return true; // can swap similar characters\n            return false; // all characters occur only once\n        }else if(second == -1){\n            return false; // exactly 1 mismatch\n        }\n        \n        return (s[first]==p[second] && s[second]==p[first]); // check similarity on 2 mismatched indexes\n    }\n};",
        "content": "**Connect with me on LinkedIn**: https://www.linkedin.com/in/abhay5349singh/\\n\\n```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string p) {\\n        int n=s.length(), m=p.length();\\n        if(n!=m) return false;\\n        \\n        vector<int> freq(26,0);\\n        \\n        int first=-1, second=-1;\\n        for(int i=0;i<n;i++){\\n            if(s[i] != p[i]){\\n                if(first==-1){\\n                    first=i;\\n                }else if(second==-1){\\n                    second=i;\\n                }else{\\n                    return false; // more than 2 mismatching characters\\n                }\\n            }\\n            freq[s[i]-\\'a\\']++;\\n        }\\n        \\n\\t\\t// similar strings\\n        if(first == -1 && second == -1){\\n            for(int i=0;i<26;i++) if(freq[i] > 1) return true; // can swap similar characters\\n            return false; // all characters occur only once\\n        }else if(second == -1){\\n            return false; // exactly 1 mismatch\\n        }\\n        \\n        return (s[first]==p[second] && s[second]==p[first]); // check similarity on 2 mismatched indexes\\n    }\\n};\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\npublic:\n    bool buddyStrings(string s, string p) {\n        int n=s.length(), m=p.length();\n        if(n!=m) return false;\n        \n        vector<int> freq(26,0);\n        \n        int first=-1, second=-1;\n        char *undefinedObject;\n\n        for(int i=0;i<n;i++){\n            if(s[i] != p[i]){\n                if(first==-1){\n                    first=i;\n                }else if(second==-1){\n                    second=i;\n                }else{\n                    return false; // more than 2 mismatching characters\n                }\n            }\n            freq[undefinedObject[i]-'a']++;\n        }\n        \n        \n        if(first == -1 && second == -1){\n            for(int i=0;i<26;i++) if(freq[i] > 1) return true; // can swap similar characters\n            return false; // all characters occur only once\n        }else if(second == -1){\n            return false; // exactly 1 mismatch\n        }\n        \n        return (s[first]==p[second] && s[second]==p[first]); // check similarity on 2 mismatched indexes\n    }\n};\n",
        "explanations": "\nAdding values to non-existent object \"undefinedObject\" causes the program to go haywire.\n"
    },
    {
        "slug": "maximum-rows-covered-by-columns",
        "description": "You are given a 0-indexed m x n binary matrix matrix and an integer numSelect, which denotes the number of distinct columns you must select from matrix.\nLet us consider s = {c1, c2, ...., cnumSelect} as the set of columns selected by you. A row row is covered by s if:\n\nFor each cell matrix[row][col] (0 <= col <= n - 1) where matrix[row][col] == 1, col is present in s or,\nNo cell in row has a value of 1.\n\nYou need to choose numSelect columns such that the number of rows that are covered is maximized.\nReturn the maximum number of rows that can be covered by a set of numSelect columns.",
        "examples": [
            "Input: matrix = [[0,0,0],[1,0,1],[0,1,1],[0,0,1]], numSelect = 2\nOutput: 3\nExplanation: One possible way to cover 3 rows is shown in the diagram above.\nWe choose s = {0, 2}.\n- Row 0 is covered because it has no occurrences of 1.\n- Row 1 is covered because the columns with value 1, i.e. 0 and 2 are present in s.\n- Row 2 is not covered because matrix[2][1] == 1 but 1 is not present in s.\n- Row 3 is covered because matrix[2][2] == 1 and 2 is present in s.\nThus, we can cover three rows.\nNote that s = {1, 2} will also cover 3 rows, but it can be shown that no more than three rows can be covered.",
            "Input: matrix = [[1],[0]], numSelect = 1\nOutput: 2\nExplanation: Selecting the only column will result in both rows being covered since the entire matrix is selected.\nTherefore, we return 2."
        ],
        "constraints": "m == matrix.length\nn == matrix[i].length\n1 <= m, n <= 12\nmatrix[i][j] is either 0 or 1.\n1 <= numSelect\u00a0<= n",
        "release_time": 1662227882,
        "oracle_code": "class Solution {\npublic:\n    // Global Vector to all possible column combinations\n    vector<vector<int>>comb;\n\t\n    // Function to find the number of rows a particular column combination can capture\n    int find(vector<vector<int>>& mat1)\n    {\n        int c = 0;\n        for(int i = 0; i < mat1.size(); i++)\n        {\n            int flg = 0;\n            for(int j = 0; j < mat1[0].size(); j++)\n                if(mat1[i][j] == 1)\n                    flg = 1;\n            if(flg == 0)\n                c++;\n        }\n        return c;\n    }\n    \n\t// Function to Traverse for each Column Combination Present\n    int find_ans(vector<vector<int>>& mat)\n    {\n        int ans = 0;\n        for(int i = 0; i < comb.size(); i++)\n        {\n            vector<int>temp = comb[i];\n            vector<vector<int>> mat1 = mat;\n            for(int j = 0; j < temp.size(); j++)\n            {\n                int col_val = temp[j];\n                for(int k = 0; k < mat1.size(); k++)\n                    mat1[k][col_val] = 0;\n            }\n            ans = max(ans, find(mat1));\n        }\n        return ans;\n    }\n    // Function to Find all possible column combinations\n    void helper(vector<vector<int>>& mat, int cols, int count, int idx, vector<int>tans)\n    {\n        int col = mat[0].size();\n        if(count == cols)\n        {\n            comb.push_back(tans);\n            return;\n        }\n        if(idx >= col)\n            return;\n        \n        helper(mat, cols, count, idx+1, tans);\n        tans.push_back(idx);\n        helper(mat, cols, count+1, idx+1, tans);\n    }\n    \n    int maximumRows(vector<vector<int>>& mat, int cols) {\n        \n        vector<int>tans;\n        helper(mat, cols, 0, 0, tans);\n        return find_ans(mat);\n    }\n};",
        "content": "```\\nclass Solution {\\npublic:\\n    // Global Vector to all possible column combinations\\n    vector<vector<int>>comb;\\n\\t\\n    // Function to find the number of rows a particular column combination can capture\\n    int find(vector<vector<int>>& mat1)\\n    {\\n        int c = 0;\\n        for(int i = 0; i < mat1.size(); i++)\\n        {\\n            int flg = 0;\\n            for(int j = 0; j < mat1[0].size(); j++)\\n                if(mat1[i][j] == 1)\\n                    flg = 1;\\n            if(flg == 0)\\n                c++;\\n        }\\n        return c;\\n    }\\n    \\n\\t// Function to Traverse for each Column Combination Present\\n    int find_ans(vector<vector<int>>& mat)\\n    {\\n        int ans = 0;\\n        for(int i = 0; i < comb.size(); i++)\\n        {\\n            vector<int>temp = comb[i];\\n            vector<vector<int>> mat1 = mat;\\n            for(int j = 0; j < temp.size(); j++)\\n            {\\n                int col_val = temp[j];\\n                for(int k = 0; k < mat1.size(); k++)\\n                    mat1[k][col_val] = 0;\\n            }\\n            ans = max(ans, find(mat1));\\n        }\\n        return ans;\\n    }\\n    // Function to Find all possible column combinations\\n    void helper(vector<vector<int>>& mat, int cols, int count, int idx, vector<int>tans)\\n    {\\n        int col = mat[0].size();\\n        if(count == cols)\\n        {\\n            comb.push_back(tans);\\n            return;\\n        }\\n        if(idx >= col)\\n            return;\\n        \\n        helper(mat, cols, count, idx+1, tans);\\n        tans.push_back(idx);\\n        helper(mat, cols, count+1, idx+1, tans);\\n    }\\n    \\n    int maximumRows(vector<vector<int>>& mat, int cols) {\\n        \\n        vector<int>tans;\\n        helper(mat, cols, 0, 0, tans);\\n        return find_ans(mat);\\n    }\\n};\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\npublic:\n    // Global Vector to all possible column combinations\n    vector<vector<int>>comb = undefined_object;\n\t\n    // Function to find the number of rows a particular column combination can capture\n    int find(vector<vector<int>>& mat1)\n    {\n        int c = 0;\n        for(int i = 0; i < mat1.size(); i++)\n        {\n            int flg = 0;\n            for(int j = 0; j < mat1[0].size(); j++)\n                if(mat1[i][j] == 1)\n                    flg = 1;\n            if(flg == 0)\n                c++;\n        }\n        return c;\n    }\n    \n\t// Function to Traverse for each Column Combination Present\n    int find_ans(vector<vector<int>>& mat)\n    {\n        int ans = 0;\n        for(int i = 0; i < comb.size(); i++)\n        {\n            vector<int>temp = comb[i];\n            vector<vector<int>> mat1 = mat;\n            for(int j = 0; j < temp.size(); j++)\n            {\n                int col_val = temp[j];\n                for(int k = 0; k < mat1.size(); k++)\n                    mat1[k][col_val] = 0;\n            }\n            ans = max(ans, find(mat1));\n        }\n        return ans;\n    }\n    // Function to Find all possible column combinations\n    void helper(vector<vector<int>>& mat, int cols, int count, int idx, vector<int>tans)\n    {\n        int col = mat[0].size();\n        if(count == cols)\n        {\n            comb.push_back(tans);\n            return;\n        }\n        if(idx >= col)\n            return;\n        \n        helper(mat, cols, count, idx+1, tans);\n        tans.push_back(idx);\n        helper(mat, cols, count+1, idx+1, tans);\n    }\n    \n    int maximumRows(vector<vector<int>>& mat, int cols) {\n        \n        vector<int>tans;\n        helper(mat, cols, 0, 0, tans);\n        return find_ans(mat);\n    }\n};\n",
        "explanations": "\nAccessing undefined_object instead of an actual vector object in the global scope causes a run-time error.\n"
    },
    {
        "slug": "filter-restaurants-by-vegan-friendly-price-and-distance",
        "description": "Given the array restaurants where \u00a0restaurants[i] = [idi, ratingi, veganFriendlyi, pricei, distancei]. You have to filter the restaurants using three filters.\nThe veganFriendly filter will be either true (meaning you should only include restaurants with veganFriendlyi set to true)\u00a0or false\u00a0(meaning you can include any restaurant). In addition, you have the filters\u00a0maxPrice and maxDistance\u00a0which\u00a0are the maximum value for price and distance of restaurants you should consider respectively.\nReturn the array of restaurant IDs after filtering, ordered by rating from highest to lowest. For restaurants with the same rating, order them by id from highest to lowest. For simplicity veganFriendlyi and veganFriendly take value 1 when it is true, and 0 when it is false.",
        "examples": [
            "Input: restaurants = [[1,4,1,40,10],[2,8,0,50,5],[3,8,1,30,4],[4,10,0,10,3],[5,1,1,15,1]], veganFriendly = 1, maxPrice = 50, maxDistance = 10\nOutput: [3,1,5] \nExplanation: \nThe restaurants are:\nRestaurant 1 [id=1, rating=4, veganFriendly=1, price=40, distance=10]\nRestaurant 2 [id=2, rating=8, veganFriendly=0, price=50, distance=5]\nRestaurant 3 [id=3, rating=8, veganFriendly=1, price=30, distance=4]\nRestaurant 4 [id=4, rating=10, veganFriendly=0, price=10, distance=3]\nRestaurant 5 [id=5, rating=1, veganFriendly=1, price=15, distance=1] \nAfter filter restaurants with veganFriendly = 1, maxPrice = 50 and maxDistance = 10 we have restaurant 3, restaurant 1 and restaurant 5 (ordered by rating from highest to lowest).",
            "Input: restaurants = [[1,4,1,40,10],[2,8,0,50,5],[3,8,1,30,4],[4,10,0,10,3],[5,1,1,15,1]], veganFriendly = 0, maxPrice = 50, maxDistance = 10\nOutput: [4,3,2,1,5]\nExplanation: The restaurants are the same as in example 1, but in this case the filter veganFriendly = 0, therefore all restaurants are considered.",
            "Input: restaurants = [[1,4,1,40,10],[2,8,0,50,5],[3,8,1,30,4],[4,10,0,10,3],[5,1,1,15,1]], veganFriendly = 0, maxPrice = 30, maxDistance = 3\nOutput: [4,5]"
        ],
        "constraints": "1 <=\u00a0restaurants.length <= 10^4\nrestaurants[i].length == 5\n1 <=\u00a0idi, ratingi, pricei, distancei <= 10^5\n1 <=\u00a0maxPrice,\u00a0maxDistance <= 10^5\nveganFriendlyi and\u00a0veganFriendly\u00a0are\u00a00 or 1.\nAll idi are distinct.",
        "release_time": 1692446889,
        "oracle_code": "class Solution {\npublic:\n    vector<int> filterRestaurants(vector<vector<int>>& restaurants, int veganFriendly, int maxPrice, int maxDistance) {\n        if(veganFriendly == 1){\n            for(int i = 0; i<restaurants.size(); i++){\n                if(restaurants[i][2] != veganFriendly){\n                    restaurants[i][0] = -1;\n                }\n            }\n        }\n\n        for(int i = 0; i<restaurants.size(); i++){\n            if(restaurants[i][3] > maxPrice){   \n                restaurants[i][0] = -1;\n            }\n            if(restaurants[i][4] > maxDistance){  \n                restaurants[i][0]=-1;\n            }\n        }\n\n        vector<int> id;\n        vector<int>rating;\n        for(int i=0; i<restaurants.size(); i++){\n            if(restaurants[i][0]>0){\n                id.push_back(restaurants[i][0]);\n                rating.push_back(restaurants[i][1]);\n            }\n            \n        }\n\n        for(int i=0; i<rating.size(); i++){\n            for(int j=i+1; j<rating.size(); j++){\n                if(rating[i] < rating[j]){\n                    swap(rating[i], rating[j]);\n                    swap(id[i], id[j]);\n                }\n            }\n        }\n\n        for(int i=0; i<rating.size(); i++){\n            for(int j=i+1; j<rating.size(); j++){\n                if(rating[i] == rating[j] && id[i] < id[j]){\n                    swap(id[i], id[j]);\n                }\n            }\n        }\n\n        return id;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> filterRestaurants(vector<vector<int>>& restaurants, int veganFriendly, int maxPrice, int maxDistance) {\\n        if(veganFriendly == 1){\\n            for(int i = 0; i<restaurants.size(); i++){\\n                if(restaurants[i][2] != veganFriendly){\\n                    restaurants[i][0] = -1;\\n                }\\n            }\\n        }\\n\\n        for(int i = 0; i<restaurants.size(); i++){\\n            if(restaurants[i][3] > maxPrice){   \\n                restaurants[i][0] = -1;\\n            }\\n            if(restaurants[i][4] > maxDistance){  \\n                restaurants[i][0]=-1;\\n            }\\n        }\\n\\n        vector<int> id;\\n        vector<int>rating;\\n        for(int i=0; i<restaurants.size(); i++){\\n            if(restaurants[i][0]>0){\\n                id.push_back(restaurants[i][0]);\\n                rating.push_back(restaurants[i][1]);\\n            }\\n            \\n        }\\n\\n        for(int i=0; i<rating.size(); i++){\\n            for(int j=i+1; j<rating.size(); j++){\\n                if(rating[i] < rating[j]){\\n                    swap(rating[i], rating[j]);\\n                    swap(id[i], id[j]);\\n                }\\n            }\\n        }\\n\\n        for(int i=0; i<rating.size(); i++){\\n            for(int j=i+1; j<rating.size(); j++){\\n                if(rating[i] == rating[j] && id[i] < id[j]){\\n                    swap(id[i], id[j]);\\n                }\\n            }\\n        }\\n\\n        return id;\\n    }\\n};\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\npublic:\n    vector<int> filterRestaurants(vector<vector<int>>& restaurants, int veganFriendly, int maxPrice, int maxDistance) {\n        if(veganFriendly == 1){\n            for(int i = 0; i<restaurants.size(); i++){\n                if(restaurants[i][2] != veganFriendly){\n                    restaurants[i][0] = -1;\n                }\n            }\n        }\n\n        for(int i = 0; i<restaurants.size(); i++){\n            if(restaurants[i][3] > maxPrice){   \n                restaurants[i][0] = -1;\n            }\n            if(restaurants[i][4] > maxDistance){  \n                restaurants[i][0]=-1;\n            }\n        }\n\n        vector<int> id;\n        vector<int>rating;\n        for(int i=0; i<restaurants.size(); i++){\n            if(restaurants[i][0]>0){\n                id.push_back(restaurants[i][0]);\n                rating.push_back(restaurants[i][1]);\n            }\n            \n        }\n\n        for(int i=0; i<rating.size(); i++){\n            for(int j=i+1; j<rating.size(); j++){\n                if(rating[i] < rating[j]){\n                    swap(rating[i], rating[j]);\n                    swap(id[i], id[j]);\n                }\n            }\n        }\n\n        for(int i=0; i<rating.size(); i++){\n            for(int j=i+1; j<rating.size(); j++){\n                if(rating[i] == rating[j] && id[i] < id[j]){\n                    swap(id[i], id[j]);\n                }\n            }\n        }\n\n        vector<int> id_new(id.size());\n        return id_new;\n    }\n};\n",
        "explanations": "\nThe bug is returning vector 'id_new' instread of 'id', which will always be an empty vector.\n"
    },
    {
        "slug": "most-frequent-even-element",
        "description": "Given an integer array nums, return the most frequent even element.\nIf there is a tie, return the smallest one. If there is no such element, return -1.",
        "examples": [
            "Input: nums = [0,1,2,2,4,4,1]\nOutput: 2\nExplanation:\nThe even elements are 0, 2, and 4. Of these, 2 and 4 appear the most.\nWe return the smallest one, which is 2.",
            "Input: nums = [4,4,4,9,2,4]\nOutput: 4\nExplanation: 4 is the even element appears the most.",
            "Input: nums = [29,47,21,41,13,37,25,7]\nOutput: -1\nExplanation: There is no even element."
        ],
        "constraints": "1 <= nums.length <= 2000\n0 <= nums[i] <= 105",
        "release_time": 1673020570,
        "oracle_code": "class Solution {\npublic:\n    int mostFrequentEven(vector<int>& nums) {\n        int n = nums.size(),i;\n        map<int , int> freq;\n        for(auto x:nums){\n            freq[x]++;\n        }\n        int evefreq=0,ans=-1;\n        for(auto y:freq){\n            if(y.first%2==0 && y.second> evefreq){\n                ans=y.first;\n                evefreq=y.second;\n            }\n        }\n        return ans;\n    }\n};",
        "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mostFrequentEven(vector<int>& nums) {\\n        int n = nums.size(),i;\\n        map<int , int> freq;\\n        for(auto x:nums){\\n            freq[x]++;\\n        }\\n        int evefreq=0,ans=-1;\\n        for(auto y:freq){\\n            if(y.first%2==0 && y.second> evefreq){\\n                ans=y.first;\\n                evefreq=y.second;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\npublic:\n    int mostFrequentEven(vector<int>& nums) {\n        int n = nums.size(),i;\n        map<int , int> freq;\n        for(auto x:nums){\n            freq[x]++;\n        }\n        int evefreq=0,ans;\n        for(auto y:freq){\n            if(y.first%2==0 && y.second> evefreq){\n                ans=y.first;\n                evefreq=y.second;\n            }\n        }\n        return ans;\n    }\n};\n",
        "explanations": "\n'ans' potentially uninitialized if there is no even frequency. Results in undefined behavior.\n"
    },
    {
        "slug": "perfect-squares",
        "description": "Given an integer n, return the least number of perfect square numbers that sum to n.\nA perfect square is an integer that is the square of an integer; in other words, it is the product of some integer with itself. For example, 1, 4, 9, and 16 are perfect squares while 3 and 11 are not.",
        "examples": [
            "Input: n = 12\nOutput: 3\nExplanation: 12 = 4 + 4 + 4.",
            "Input: n = 13\nOutput: 2\nExplanation: 13 = 4 + 9."
        ],
        "constraints": "1 <= n <= 104",
        "release_time": 1669088721,
        "oracle_code": "class Solution {\npublic:\n\n    // declare a dp\n\n    int dp[105][10005];\n\n    int helper(vector<int>& arr, int i, int n, int sum)\n    {\n        // base case\n\n        if(sum == 0)\n        {\n            return 0;\n        }\n\n        if(i >= n || sum < 0)\n        {\n            return INT_MAX - 1000;\n        }\n\n        // if already calculated\n\n        if(dp[i][sum] != -1)\n        {\n            return dp[i][sum];\n        }\n\n        // at each ith element we have two options either include or exclude\n\n        int mini = INT_MAX;\n\n        // inclusion part\n\n        if(arr[i] <= sum)\n        {\n            mini = min(mini, 1 + helper(arr, i, n, sum - arr[i]));\n        }\n\n        // exclusion part\n\n        mini = min(mini, helper(arr, i + 1, n, sum));\n\n        // store the res in dp\n\n        return dp[i][sum] = mini;\n    }\n\n    int numSquares(int n) {\n\n        vector<int> arr;\n\n        // find all the squares between 1 to n\n\n        for(int i = 1; i * i <= n; i++)\n        {\n            arr.push_back(i * i);\n        }\n\n        // initialize dp with -1\n\n        memset(dp, -1, sizeof(dp));\n\n        return helper(arr, 0, arr.size(), n);\n    }\n};",
        "content": "* ***Using Recursion && Memoization***\\n\\n* ***Time Complexity :- O(N * sqrt(N))***\\n\\n* ***Space Complexity :- O(N * sqrt(N))***\\n\\n* ***There are sqrt(N), squares between 1 to N***\\n\\n```\\nclass Solution {\\npublic:\\n\\n    // declare a dp\\n\\n    int dp[105][10005];\\n\\n    int helper(vector<int>& arr, int i, int n, int sum)\\n    {\\n        // base case\\n\\n        if(sum == 0)\\n        {\\n            return 0;\\n        }\\n\\n        if(i >= n || sum < 0)\\n        {\\n            return INT_MAX - 1000;\\n        }\\n\\n        // if already calculated\\n\\n        if(dp[i][sum] != -1)\\n        {\\n            return dp[i][sum];\\n        }\\n\\n        // at each ith element we have two options either include or exclude\\n\\n        int mini = INT_MAX;\\n\\n        // inclusion part\\n\\n        if(arr[i] <= sum)\\n        {\\n            mini = min(mini, 1 + helper(arr, i, n, sum - arr[i]));\\n        }\\n\\n        // exclusion part\\n\\n        mini = min(mini, helper(arr, i + 1, n, sum));\\n\\n        // store the res in dp\\n\\n        return dp[i][sum] = mini;\\n    }\\n\\n    int numSquares(int n) {\\n\\n        vector<int> arr;\\n\\n        // find all the squares between 1 to n\\n\\n        for(int i = 1; i * i <= n; i++)\\n        {\\n            arr.push_back(i * i);\\n        }\\n\\n        // initialize dp with -1\\n\\n        memset(dp, -1, sizeof(dp));\\n\\n        return helper(arr, 0, arr.size(), n);\\n    }\\n};\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\npublic:\n    int dp[105][10005];\n    \n    int helper(int i, int n, int sum)\n    {\n        vector<int>& arr;\n\n        if(sum == 0)\n        {\n            return 0;\n        }\n\n        if(i >= n || sum < 0)\n        {\n            return INT_MAX - 1000;\n        }\n\n        if(dp[i][sum] != -1)\n        {\n            return dp[i][sum];\n        }\n\n        int mini = INT_MAX;\n\n        if(arr[i] <= sum)\n        {\n            mini = min(mini, 1 + helper(i, n, sum - arr[i]));\n        }\n\n        mini = min(mini, helper(i + 1, n, sum));\n\n        return dp[i][sum] = mini;\n    }\n\n    int numSquares(int n) {\n\n        vector<int> arr;\n\n        for(int i = 1; i * i <= n; i++)\n        {\n            arr.push_back(i * i);\n        }\n\n        memset(dp, -1, sizeof(dp));\n\n        return helper(0, arr.size(), n);\n    }\n};\n",
        "explanations": "\nThe vector 'arr' is declared in 'helper' but not defined, causing an undefined behavior.\n"
    },
    {
        "slug": "largest-1-bordered-square",
        "description": "Given a 2D grid of 0s and 1s, return the number of elements in\u00a0the largest square\u00a0subgrid that has all 1s on its border, or 0 if such a subgrid\u00a0doesn't exist in the grid.",
        "examples": [
            "Input: grid = [[1,1,1],[1,0,1],[1,1,1]]\r\nOutput: 9",
            "Input: grid = [[1,1,0,0]]\r\nOutput: 1"
        ],
        "constraints": "1 <= grid.length <= 100\n1 <= grid[0].length <= 100\ngrid[i][j] is 0 or 1",
        "release_time": 1689400545,
        "oracle_code": "class Solution {\npublic:\n    int largest1BorderedSquare(vector<vector<int>>& grid) {\n        int r = grid.size();\n        int c = grid[0].size();\n        vector<vector<pair<int,int>>> dp(r, vector<pair<int,int>>(c,{0,0}));\n        \n        int mx = 0;\n\n        for(int i=0;i<r;i++){\n            for(int j=0;j<c;j++){\n                if(grid[i][j]!=0){\n                    \n                    dp[i][j].first = i == 0 ? 1 : dp[i-1][j].first+1;\n                    dp[i][j].second = j == 0 ? 1 : dp[i][j-1].second+1;\n                    \n                    int sz = min(dp[i][j].first, dp[i][j].second);\n                    while(sz>mx){\n                        int p = min(dp[i-sz+1][j].second,dp[i][j-sz+1].first);\n                        if(p>=sz)\n                            mx = max(mx,sz);\n                        sz--;\n                    }\n                }\n            }\n        }\n            \n        return mx*mx;\n    }\n};",
        "content": "```\\nclass Solution {\\npublic:\\n    int largest1BorderedSquare(vector<vector<int>>& grid) {\\n        int r = grid.size();\\n        int c = grid[0].size();\\n        vector<vector<pair<int,int>>> dp(r, vector<pair<int,int>>(c,{0,0}));\\n        \\n        int mx = 0;\\n\\n        for(int i=0;i<r;i++){\\n            for(int j=0;j<c;j++){\\n                if(grid[i][j]!=0){\\n                    \\n                    dp[i][j].first = i == 0 ? 1 : dp[i-1][j].first+1;\\n                    dp[i][j].second = j == 0 ? 1 : dp[i][j-1].second+1;\\n                    \\n                    int sz = min(dp[i][j].first, dp[i][j].second);\\n                    while(sz>mx){\\n                        int p = min(dp[i-sz+1][j].second,dp[i][j-sz+1].first);\\n                        if(p>=sz)\\n                            mx = max(mx,sz);\\n                        sz--;\\n                    }\\n                }\\n            }\\n        }\\n            \\n        return mx*mx;\\n    }\\n};\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\npublic:\n    int largest1BorderedSquare(vector<vector<int>>& grid) {\n        int r = grid.size();\n        int c = undefined_object.size();    \n        vector<vector<pair<int,int>>> dp(r, vector<pair<int,int>>(c,{0,0}));\n        \n        int mx = 0;\n\n        for(int i=0;i<r;i++){\n            for(int j=0;j<c;j++){\n                if(grid[i][j]!=0){\n                    \n                    dp[i][j].first = i == 0 ? 1 : dp[i-1][j].first+1;\n                    dp[i][j].second = j == 0 ? 1 : dp[i][j-1].second+1;\n                    \n                    int sz = min(dp[i][j].first, dp[i][j].second);\n                    while(sz>mx){\n                        int p = min(dp[i-sz+1][j].second,dp[i][j-sz+1].first);\n                        if(p>=sz)\n                            mx = max(mx,sz);\n                        sz--;\n                    }\n                }\n            }\n        }\n            \n        return mx*mx;\n    }\n};\n",
        "explanations": "\nUsing 'undefined_object' (which doesn't exist in this scope) results in a compile error.\n"
    },
    {
        "slug": "binary-string-with-substrings-representing-1-to-n",
        "description": "Given a binary string s and a positive integer n, return true if the binary representation of all the integers in the range [1, n] are substrings of s, or false otherwise.\nA substring is a contiguous sequence of characters within a string.",
        "examples": [
            "Input: s = \"0110\", n = 3\nOutput: true",
            "Input: s = \"0110\", n = 4\nOutput: false"
        ],
        "constraints": "1 <= s.length <= 1000\ns[i] is either '0' or '1'.\n1 <= n <= 109",
        "release_time": 1680016299,
        "oracle_code": "class Solution {\npublic:\n    bool queryString(string s, int n)\n     {\n        unordered_set<int> seen;\n        int len = s.length();\n        for(int i=len-1;i>=0;i--)\n        {\n            int num = 0;\n            for(int j=1;j<=min(len-i,31);j++)\n            { \n                num = num*2 + (s[i+j-1] == '1' ? 1 : 0);\n                if(0 < num && num <= n) seen.insert(num);\n            }\n            if(seen.size() == n) return true;\n        }\n        return false;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool queryString(string s, int n)\\n     {\\n        unordered_set<int> seen;\\n        int len = s.length();\\n        for(int i=len-1;i>=0;i--)\\n        {\\n            int num = 0;\\n            for(int j=1;j<=min(len-i,31);j++)\\n            { \\n                num = num*2 + (s[i+j-1] == \\'1\\' ? 1 : 0);\\n                if(0 < num && num <= n) seen.insert(num);\\n            }\\n            if(seen.size() == n) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\npublic:\n    bool queryString(string s, int n)\n     {\n        unordered_set<int> seen;\n        int len = s.length();\n        bool doesNotExist;\n        string temp = s + doesNotExist;\n        for(int i=len-1;i>=0;i--)\n        {\n            int num = 0;\n            for(int j=1;j<=min(len-i,31);j++)\n            { \n                num = num*2 + (temp[i+j-1] == '1' ? 1 : 0);\n                if(0 < num && num <= n) seen.insert(num);\n            }\n            if(seen.size() == n) return true;\n        }\n        return false;\n    }\n};\n",
        "explanations": "\nThe bug is an undefined boolean variable \"doesNotExist\" being used to concatenate the string.\n"
    },
    {
        "slug": "brace-expansion-ii",
        "description": "Under the grammar given below, strings can represent a set of lowercase words. Let\u00a0R(expr)\u00a0denote the set of words the expression represents.\nThe grammar can best be understood through simple examples:\n\nSingle letters represent a singleton set containing that word.\n\t\nR(\"a\") = {\"a\"}\nR(\"w\") = {\"w\"}\n\n\nWhen we take a comma-delimited list of two or more expressions, we take the union of possibilities.\n\t\nR(\"{a,b,c}\") = {\"a\",\"b\",\"c\"}\nR(\"{{a,b},{b,c}}\") = {\"a\",\"b\",\"c\"} (notice the final set only contains each word at most once)\n\n\nWhen we concatenate two expressions, we take the set of possible concatenations between two words where the first word comes from the first expression and the second word comes from the second expression.\n\t\nR(\"{a,b}{c,d}\") = {\"ac\",\"ad\",\"bc\",\"bd\"}\nR(\"a{b,c}{d,e}f{g,h}\") = {\"abdfg\", \"abdfh\", \"abefg\", \"abefh\", \"acdfg\", \"acdfh\", \"acefg\", \"acefh\"}\n\n\n\nFormally, the three rules for our grammar:\n\nFor every lowercase letter x, we have R(x) = {x}.\nFor expressions e1, e2, ... , ek with k >= 2, we have R({e1, e2, ...}) = R(e1) \u222a R(e2) \u222a ...\nFor expressions e1 and e2, we have R(e1 + e2) = {a + b for (a, b) in R(e1) \u00d7 R(e2)}, where + denotes concatenation, and \u00d7 denotes the cartesian product.\n\nGiven an expression representing a set of words under the given grammar, return the sorted list of words that the expression represents.",
        "examples": [
            "Input: expression = \"{a,b}{c,{d,e}}\"\nOutput: [\"ac\",\"ad\",\"ae\",\"bc\",\"bd\",\"be\"]",
            "Input: expression = \"{{a,z},a{b,c},{ab,z}}\"\nOutput: [\"a\",\"ab\",\"ac\",\"z\"]\nExplanation: Each distinct word is written only once in the final answer."
        ],
        "constraints": "1 <= expression.length <= 60\nexpression[i] consists of '{', '}', ','or lowercase English letters.\nThe given\u00a0expression\u00a0represents a set of words based on the grammar given in the description.",
        "release_time": 1677655008,
        "oracle_code": "class Solution {\npublic:\n    \n    vector<string> multiply(vector<string>& a, vector<string>& b){\n        if(a.empty()) return b;\n        if(b.empty()) return a;\n        vector<string> ans;\n        for(auto&i:a){\n            for(auto&j:b) ans.push_back(i+j);\n        }\n        return ans;\n    }\n    \n    vector<string> braceExpansionII(string expression) {\n        vector<string>  res, curr;\n        stack<vector<string>> st;\n        for(auto&x:expression){\n            if(x >= 'a' and x <= 'z'){\n                if(curr.size()) for(auto&i:curr) i += x;\n                else curr.push_back(string(1, x));\n            }\n            else if(x == '{'){\n                st.push(res); st.push(curr);\n                res.clear(), curr.clear();\n            }\n            else if(x == '}'){\n                vector<string> preCurr = st.top(); st.pop();\n                vector<string> preRes = st.top(); st.pop();\n                for(auto&i:curr) res.push_back(i);\n                curr = multiply(preCurr, res);\n                res = preRes;\n            }\n            else if(x == ','){\n                for(auto&i:curr) res.push_back(i);\n                curr.clear();\n            }\n        }\n        for(auto&i:curr) res.push_back(i);\n        sort(res.begin(), res.end());\n        return vector<string>(res.begin(), unique(res.begin(), res.end()));\n    }\n};",
        "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nUse stack to keep track of previous two lists\\n<!-- Describe your approach to solving the problem. -->\\n<!-- \\n# Complexity\\n- Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    vector<string> multiply(vector<string>& a, vector<string>& b){\\n        if(a.empty()) return b;\\n        if(b.empty()) return a;\\n        vector<string> ans;\\n        for(auto&i:a){\\n            for(auto&j:b) ans.push_back(i+j);\\n        }\\n        return ans;\\n    }\\n    \\n    vector<string> braceExpansionII(string expression) {\\n        vector<string>  res, curr;\\n        stack<vector<string>> st;\\n        for(auto&x:expression){\\n            if(x >= \\'a\\' and x <= \\'z\\'){\\n                if(curr.size()) for(auto&i:curr) i += x;\\n                else curr.push_back(string(1, x));\\n            }\\n            else if(x == \\'{\\'){\\n                st.push(res); st.push(curr);\\n                res.clear(), curr.clear();\\n            }\\n            else if(x == \\'}\\'){\\n                vector<string> preCurr = st.top(); st.pop();\\n                vector<string> preRes = st.top(); st.pop();\\n                for(auto&i:curr) res.push_back(i);\\n                curr = multiply(preCurr, res);\\n                res = preRes;\\n            }\\n            else if(x == \\',\\'){\\n                for(auto&i:curr) res.push_back(i);\\n                curr.clear();\\n            }\\n        }\\n        for(auto&i:curr) res.push_back(i);\\n        sort(res.begin(), res.end());\\n        return vector<string>(res.begin(), unique(res.begin(), res.end()));\\n    }\\n};\\n```",
        "level": "hard",
        "buggy_code": "\nclass Solution {\npublic:\n    \n    vector<string> multiply(vector<string>& a, vector<string>& b){\n        if(a.empty()) return b;\n        if(b.empty()) return a;\n        vector<string> ans;\n        for(auto&i:a){\n            for(auto&j:b) ans.push_back(i+j);\n        }\n        return ans;\n    }\n    \n    vector<string> braceExpansionII(string expression) {\n        vector<string>  res, curr;\n        stack<vector<string>> st;\n        for(auto&x:expression){\n            if(x >= 'a' and x <= 'z'){\n                if(curr.size()) for(auto&i:curr) i += x;\n                else curr.push_back(string(1, x));\n            }\n            else if(x == '{'){\n                st.push(res); st.push(curr);\n                res.clear(), curr.clear();\n            }\n            else if(x == '}'){\n                vector<string> preCurr;\n                vector<string> preRes = st.top(); st.pop();\n                for(auto&i:curr) res.push_back(i);\n                curr = multiply(preCurr, res);\n                res = preRes;\n            }\n            else if(x == ','){\n                for(auto&i:curr) res.push_back(i);\n                curr.clear();\n            }\n        }\n        for(auto&i:curr) res.push_back(i);\n        sort(res.begin(), res.end());\n        return vector<string>(res.begin(), unique(res.begin(), res.end()));\n    }\n};\n",
        "explanations": "\n'preCurr' has been declared but is never defined before it's used in the 'multiply()' function.\n"
    },
    {
        "slug": "number-of-matching-subsequences",
        "description": "Given a string s and an array of strings words, return the number of words[i] that is a subsequence of s.\nA subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.\n\nFor example, \"ace\" is a subsequence of \"abcde\".",
        "examples": [
            "Input: s = \"abcde\", words = [\"a\",\"bb\",\"acd\",\"ace\"]\nOutput: 3\nExplanation: There are three strings in words that are a subsequence of s: \"a\", \"acd\", \"ace\".",
            "Input: s = \"dsahjpjauf\", words = [\"ahjpjau\",\"ja\",\"ahbwzgqnuk\",\"tnmlanowax\"]\nOutput: 2"
        ],
        "constraints": "1 <= s.length <= 5 * 104\n1 <= words.length <= 5000\n1 <= words[i].length <= 50\ns and words[i] consist of only lowercase English letters.",
        "release_time": 1675105253,
        "oracle_code": "class Solution {\npublic:\nmap<char,vector<int>> count;\n    int numMatchingSubseq(string s, vector<string>& words) {\n        for(int i=0;i<s.size();i++){\n            count[s[i]].push_back(i);//add each position of each char\n        }\n        int z=0;\n        for(auto& x:words){\n            int p=-1;//find element greater thn this index\n            int r=0;//flag bit\n            for(int j=0;j<x.size();j++){\n                if(count.find(x[j])==count.end()){r=1;break;}\n                if(upper_bound(count[x[j]].begin(),count[x[j]].end(),p)==count[x[j]].end()){r=1;break;}//if grtr position not found\n                p=count[x[j]][upper_bound(count[x[j]].begin(),count[x[j]].end(),p)-count[x[j]].begin()];//updating search index\n                }\n            if(r==0)z+=1;\n        }\n        return z;\n    }\n};",
        "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\nmap<char,vector<int>> count;\\n    int numMatchingSubseq(string s, vector<string>& words) {\\n        for(int i=0;i<s.size();i++){\\n            count[s[i]].push_back(i);//add each position of each char\\n        }\\n        int z=0;\\n        for(auto& x:words){\\n            int p=-1;//find element greater thn this index\\n            int r=0;//flag bit\\n            for(int j=0;j<x.size();j++){\\n                if(count.find(x[j])==count.end()){r=1;break;}\\n                if(upper_bound(count[x[j]].begin(),count[x[j]].end(),p)==count[x[j]].end()){r=1;break;}//if grtr position not found\\n                p=count[x[j]][upper_bound(count[x[j]].begin(),count[x[j]].end(),p)-count[x[j]].begin()];//updating search index\\n                }\\n            if(r==0)z+=1;\\n        }\\n        return z;\\n    }\\n};\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\npublic:\nmap<char,vector<int>> count;\n    int numMatchingSubseq(string s, vector<string>& words) {\n        for(int i=0;i<s.size();i++){\n            count[s[i]].push_back(i);//add each position of each char\n        }\n        int z=0;\n        for(auto& x:words){\n            int p=-1;//find element greater thn this index\n            int r=0;//flag bit\n            for(int j=0;j<x.size();j++){\n                if(count.find(x[j])==count.end()){r=1;break;}\n                if(upper_bound(count[x[j]].begin(),count[x[j]].end(),p)==count[x[j]].end()){r=1;break;}//if grtr position not found\n                p=count[x[j]][upper_bound(count[x[j]].begin(),count[x[j]].end(),p)-count[x[j]].begin()];//updating search index\n                }\n            if(r==0)z+=1;\n        }\n        delete &count;\n        return z;\n    }\n};\n",
        "explanations": "\nCalling delete on an object that was not allocated dynamically using new, causes undefined behavior.\n"
    },
    {
        "slug": "apply-operations-to-an-array",
        "description": "You are given a 0-indexed array nums of size n consisting of non-negative integers.\nYou need to apply n - 1 operations to this array where, in the ith operation (0-indexed), you will apply the following on the ith element of nums:\n\nIf nums[i] == nums[i + 1], then multiply nums[i] by 2 and set nums[i + 1] to 0. Otherwise, you skip this operation.\n\nAfter performing all the operations, shift all the 0's to the end of the array.\n\nFor example, the array [1,0,2,0,0,1] after shifting all its 0's to the end, is [1,2,1,0,0,0].\n\nReturn the resulting array.\nNote that the operations are applied sequentially, not all at once.",
        "examples": [
            "Input: nums = [1,2,2,1,1,0]\nOutput: [1,4,2,0,0,0]\nExplanation: We do the following operations:\n- i = 0: nums[0] and nums[1] are not equal, so we skip this operation.\n- i = 1: nums[1] and nums[2] are equal, we multiply nums[1] by 2 and change nums[2] to 0. The array becomes [1,4,0,1,1,0].\n- i = 2: nums[2] and nums[3] are not equal, so we skip this operation.\n- i = 3: nums[3] and nums[4] are equal, we multiply nums[3] by 2 and change nums[4] to 0. The array becomes [1,4,0,2,0,0].\n- i = 4: nums[4] and nums[5] are equal, we multiply nums[4] by 2 and change nums[5] to 0. The array becomes [1,4,0,2,0,0].\nAfter that, we shift the 0's to the end, which gives the array [1,4,2,0,0,0].",
            "Input: nums = [0,1]\nOutput: [1,0]\nExplanation: No operation can be applied, we just shift the 0 to the end."
        ],
        "constraints": "2 <= nums.length <= 2000\n0 <= nums[i] <= 1000",
        "release_time": 1667707492,
        "oracle_code": "class Solution {\npublic:\n    vector<int> applyOperations(vector<int>& nums) {\n        for(int i =0 ;i<nums.size()-1;i++){\n            if(nums[i] == nums[i+1]){\n                nums[i] *=2;\n                nums[i+1] = 0;\n            }\n        };\n        vector<int> ans;\n        for(auto ele:nums){\n            if(ele!=0)ans.push_back(ele);\n        };\n        for(auto ele:nums){\n            if(ele == 0)ans.push_back(ele);\n        };\n        return ans;\n    }\n};",
        "content": "\\n```\\nclass Solution {\\npublic:\\n    vector<int> applyOperations(vector<int>& nums) {\\n        for(int i =0 ;i<nums.size()-1;i++){\\n            if(nums[i] == nums[i+1]){\\n                nums[i] *=2;\\n                nums[i+1] = 0;\\n            }\\n        };\\n        vector<int> ans;\\n        for(auto ele:nums){\\n            if(ele!=0)ans.push_back(ele);\\n        };\\n        for(auto ele:nums){\\n            if(ele == 0)ans.push_back(ele);\\n        };\\n        return ans;\\n    }\\n};\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\npublic:\n    vector<int> applyOperations(vector<int>& nums) {\n        for(int i =0 ;i<nums.size()-1;i++){\n            if(nums[i] == nums[i+1]){\n                nums[i] *=2;\n                nums[i+1] = 0;\n            }\n        };\n        vector<int> ans;\n        for(auto ele:nums){\n            if(ele!=0)ans.push_back(ele);\n        };\n        vector<int> ans;\n        for(auto ele:nums){\n            if(ele == 0)ans.push_back(ele);\n        };\n        return ans;\n    }\n};\n",
        "explanations": "\nThe bug is that there are two objects with the same name 'ans'.\n"
    },
    {
        "slug": "bitwise-and-of-numbers-range",
        "description": "Given two integers left and right that represent the range [left, right], return the bitwise AND of all numbers in this range, inclusive.",
        "examples": [
            "Input: left = 5, right = 7\nOutput: 4",
            "Input: left = 0, right = 0\nOutput: 0",
            "Input: left = 1, right = 2147483647\nOutput: 0"
        ],
        "constraints": "0 <= left <= right <= 231 - 1",
        "release_time": 1689346823,
        "oracle_code": "class Solution {\npublic:\n    int solve(int left , int right){\n        if(left == 0)return 0;\n        int bit1 = log2(left);\n        int bit2 = log2(right);\n        if(bit1 < bit2)return 0;\n        return (1<<bit1) | solve((left^(1<<bit1)) , (right^(1<<bit1))); \n    }\n    int rangeBitwiseAnd(int left, int right) {\n         return solve(left , right);\n    }\n};",
        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int left , int right){\\n        if(left == 0)return 0;\\n        int bit1 = log2(left);\\n        int bit2 = log2(right);\\n        if(bit1 < bit2)return 0;\\n        return (1<<bit1) | solve((left^(1<<bit1)) , (right^(1<<bit1))); \\n    }\\n    int rangeBitwiseAnd(int left, int right) {\\n         return solve(left , right);\\n    }\\n};\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\npublic:\n    int solve(int left , int right){\n        int bit1 = log2(left);\n        int bit2 = log2(right);\n        if(bit1 < bit2)return 0;\n        return (1<<bit1) | solve((left^(1<<bit1)) , (right^(1<<bit1))); \n    }\n    int rangeBitwiseAnd(int left, int right) {\n         return solve(left , right);\n    }\n};\n",
        "explanations": "\nThe `solve` function does not handle the case when `left` is 0, causing a runtime error.\n"
    },
    {
        "slug": "sort-list",
        "description": "Given the head of a linked list, return the list after sorting it in ascending order.",
        "examples": [
            "Input: head = [4,2,1,3]\nOutput: [1,2,3,4]",
            "Input: head = [-1,5,3,4,0]\nOutput: [-1,0,3,4,5]",
            "Input: head = []\nOutput: []"
        ],
        "constraints": "The number of nodes in the list is in the range [0, 5 * 104].\n-105 <= Node.val <= 105",
        "release_time": 1692157711,
        "oracle_code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* sortList(ListNode* head) {\n        vector<int>vec1;\n    ListNode*temp= head;\n    while(temp!=NULL){\nvec1.push_back(temp->val);\ntemp= temp->next;\n    }\n    sort(vec1.begin(),vec1.end());\n    ListNode*curr= head;\n   for(int i=0;i<vec1.size();i++){\n       curr->val=vec1[i];\n       curr= curr->next;\n   }\n   return head;\n    }\n    \n\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* sortList(ListNode* head) {\\n        vector<int>vec1;\\n    ListNode*temp= head;\\n    while(temp!=NULL){\\nvec1.push_back(temp->val);\\ntemp= temp->next;\\n    }\\n    sort(vec1.begin(),vec1.end());\\n    ListNode*curr= head;\\n   for(int i=0;i<vec1.size();i++){\\n       curr->val=vec1[i];\\n       curr= curr->next;\\n   }\\n   return head;\\n    }\\n    \\n\\n};\\n\\n```",
        "level": "medium",
        "buggy_code": "\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* sortList(ListNode* head) {\n        vector<int>vec1;\n    ListNode*temp= nullptr;\n    while(temp!=NULL){\nvec1.push_back(temp->val);\ntemp= temp->next;\n    }\n    sort(vec1.begin(),vec1.end());\n    ListNode*curr= head;\n   for(int i=0;i<vec1.size();i++){\n       curr->val=vec1[i];\n       curr= curr->next;\n   }\n   return head;\n    }\n    \n\n};\n",
        "explanations": "\nThe \"temp\" pointer is null, but the program tries to access its value. \n"
    },
    {
        "slug": "determine-color-of-a-chessboard-square",
        "description": "You are given coordinates, a string that represents the coordinates of a square of the chessboard. Below is a chessboard for your reference.\n\nReturn true if the square is white, and false if the square is black.\nThe coordinate will always represent a valid chessboard square. The coordinate will always have the letter first, and the number second.",
        "examples": [
            "Input: coordinates = \"a1\"\nOutput: false\nExplanation: From the chessboard above, the square with coordinates \"a1\" is black, so return false.",
            "Input: coordinates = \"h3\"\nOutput: true\nExplanation: From the chessboard above, the square with coordinates \"h3\" is white, so return true.",
            "Input: coordinates = \"c7\"\nOutput: false"
        ],
        "constraints": "coordinates.length == 2\n'a' <= coordinates[0] <= 'h'\n'1' <= coordinates[1] <= '8'",
        "release_time": 1687862385,
        "oracle_code": "class Solution {\npublic:\n    bool squareIsWhite(string coordinates) {\n        if(coordinates[0]%2==0 && coordinates[1]%2!=0) return true;\n        else if(coordinates[0]%2!=0 && coordinates[1]%2==0) return true;\n        else return false;\n    }\n};",
        "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool squareIsWhite(string coordinates) {\\n        if(coordinates[0]%2==0 && coordinates[1]%2!=0) return true;\\n        else if(coordinates[0]%2!=0 && coordinates[1]%2==0) return true;\\n        else return false;\\n    }\\n};\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\npublic:\n    bool squareIsWhite(string coordinates) {\n        string undefinedObject;\n        if(undefinedObject[0]%2==0 && coordinates[1]%2!=0) return true;\n        else if(coordinates[0]%2!=0 && coordinates[1]%2==0) return true;\n        else return false;\n    }\n};\n",
        "explanations": "\nAccessing an index of an undefined string object can cause unexpected behaviors or crashes.\n"
    },
    {
        "slug": "neighboring-bitwise-xor",
        "description": "A 0-indexed array derived with length n is derived by computing the bitwise XOR\u00a0(\u2295) of adjacent values in a binary array original of length n.\nSpecifically, for each index i in the range [0, n - 1]:\n\nIf i = n - 1, then derived[i] = original[i] \u2295 original[0].\nOtherwise, derived[i] = original[i] \u2295 original[i + 1].\n\nGiven an array derived, your task is to determine whether there exists a valid binary array original that could have formed derived.\nReturn true if such an array exists or false otherwise.\n\nA binary array is an array containing only 0's and 1's",
        "examples": [
            "Input: derived = [1,1,0]\nOutput: true\nExplanation: A valid original array that gives derived is [0,1,0].\nderived[0] = original[0] \u2295 original[1] = 0 \u2295 1 = 1 \nderived[1] = original[1] \u2295 original[2] = 1 \u2295 0 = 1\nderived[2] = original[2] \u2295 original[0] = 0 \u2295 0 = 0",
            "Input: derived = [1,1]\nOutput: true\nExplanation: A valid original array that gives derived is [0,1].\nderived[0] = original[0] \u2295 original[1] = 1\nderived[1] = original[1] \u2295 original[0] = 1",
            "Input: derived = [1,0]\nOutput: false\nExplanation: There is no valid original array that gives derived."
        ],
        "constraints": "n == derived.length\n1 <= n\u00a0<= 105\nThe values in derived\u00a0are either 0's or 1's",
        "release_time": 1687118835,
        "oracle_code": "class Solution {\npublic:\n    bool doesValidArrayExist(vector<int>& derived) {\n        int xoor = 0;\n        for (auto i: derived) xoor ^= i;\n        return !xoor;\n    }\n};",
        "content": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int xoor = 0;\\n        for (auto i: derived) xoor ^= i;\\n        return !xoor;\\n    }\\n};\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\npublic:\n    bool doesValidArrayExist(vector<int>& derived) {\n        int xoor = 0;\n        vector<int>& undefined;\n        for (auto i: derived) xoor ^= i;\n        xoor ^= undefined[0];\n        return !xoor;\n    }\n};\n",
        "explanations": "\nThe bug is in `vector<int>& undefined;` the vector undefined is declared but never defined.\n"
    },
    {
        "slug": "merge-two-binary-trees",
        "description": "You are given two binary trees root1 and root2.\nImagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge the two trees into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of the new tree.\nReturn the merged tree.\nNote: The merging process must start from the root nodes of both trees.",
        "examples": [
            "Input: root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]\nOutput: [3,4,5,5,4,null,7]",
            "Input: root1 = [1], root2 = [1,2]\nOutput: [2,2]"
        ],
        "constraints": "The number of nodes in both trees is in the range [0, 2000].\n-104 <= Node.val <= 104",
        "release_time": 1673784101,
        "oracle_code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {\n        if ( t1 && t2 ) {\n            TreeNode * root = new TreeNode(t1->val + t2->val);\n            root->left = mergeTrees(t1->left, t2->left);\n            root->right = mergeTrees(t1->right, t2->right);\n            return root;\n        } else {\n            return t1 ? t1 : t2;\n        }\n    }\n};",
        "content": "\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {\\n        if ( t1 && t2 ) {\\n            TreeNode * root = new TreeNode(t1->val + t2->val);\\n            root->left = mergeTrees(t1->left, t2->left);\\n            root->right = mergeTrees(t1->right, t2->right);\\n            return root;\\n        } else {\\n            return t1 ? t1 : t2;\\n        }\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
        "level": "easy",
        "buggy_code": "\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {\n        if ( t1 && t2 ) {\n            TreeNode * root = new TreeNode(t1->val + t2->val);\n            root->left = mergeTrees(t1->left, t2->left);\n            root->right = mergeTrees(t1->right, t2->right);\n            return root;\n        } else {\n            return t1 ? new TreeNode(t1->val) : new TreeNode(t2->val);\n        }\n    }\n};\n",
        "explanations": "\nWhen t1 or t2 is null, the function creates a new unattached TreeNode, causing memory leak.\n"
    },
    {
        "slug": "relative-ranks",
        "description": "You are given an integer array score of size n, where score[i] is the score of the ith athlete in a competition. All the scores are guaranteed to be unique.\nThe athletes are placed based on their scores, where the 1st place athlete has the highest score, the 2nd place athlete has the 2nd highest score, and so on. The placement of each athlete determines their rank:\n\nThe 1st place athlete's rank is \"Gold Medal\".\nThe 2nd place athlete's rank is \"Silver Medal\".\nThe 3rd place athlete's rank is \"Bronze Medal\".\nFor the 4th place to the nth place athlete, their rank is their placement number (i.e., the xth place athlete's rank is \"x\").\n\nReturn an array answer of size n where answer[i] is the rank of the ith athlete.",
        "examples": [
            "Input: score = [5,4,3,2,1]\nOutput: [\"Gold Medal\",\"Silver Medal\",\"Bronze Medal\",\"4\",\"5\"]\nExplanation: The placements are [1st, 2nd, 3rd, 4th, 5th].",
            "Input: score = [10,3,8,9,4]\nOutput: [\"Gold Medal\",\"5\",\"Bronze Medal\",\"Silver Medal\",\"4\"]\nExplanation: The placements are [1st, 5th, 3rd, 2nd, 4th]."
        ],
        "constraints": "n == score.length\n1 <= n <= 104\n0 <= score[i] <= 106\nAll the values in score are unique.",
        "release_time": 1688035608,
        "oracle_code": "class Solution {\npublic:\n    vector<string> findRelativeRanks(vector<int>& score) {\n        int n = score.size();\n        \n        vector<pair<int, int>> arr;\n        for (int i=0; i<n; i++) arr.push_back({score[i], i});\n\n        sort(rbegin(arr), rend(arr));\n\n        vector<string> res(n);\n        for (int i=0; i<n; i++) \n            res[arr[i].second] = i==0? \"Gold Medal\": (i==1? \"Silver Medal\": (i==2? \"Bronze Medal\": to_string(i+1)));\n\n        return res;\n    }\n};",
        "content": "**vector solution**\\n```\\nclass Solution {\\npublic:\\n    vector<string> findRelativeRanks(vector<int>& score) {\\n        int n = score.size();\\n        \\n        vector<pair<int, int>> arr;\\n        for (int i=0; i<n; i++) arr.push_back({score[i], i});\\n\\n        sort(rbegin(arr), rend(arr));\\n\\n        vector<string> res(n);\\n        for (int i=0; i<n; i++) \\n            res[arr[i].second] = i==0? \"Gold Medal\": (i==1? \"Silver Medal\": (i==2? \"Bronze Medal\": to_string(i+1)));\\n\\n        return res;\\n    }\\n};\\n```\\n---\\n**priority queue solution**\\n```\\nclass Solution {\\npublic:\\n    vector<string> findRelativeRanks(vector<int>& score) {\\n        int n = score.size();\\n        \\n        priority_queue< pair<int, int>, vector<pair<int,int>> > pq;\\n        for (int i=0; i<n; i++) pq.push({score[i], i});\\n\\n        vector<string> res(n);\\n        while (!pq.empty()) {\\n            auto x = pq.top();\\n            int size = pq.size();\\n            res[x.second] = (size == n? \"Gold Medal\": (size == n-1? \"Silver Medal\": (size == n-2? \"Bronze Medal\": to_string(n-size+1))));\\n            pq.pop();\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\npublic:\n    vector<string> findRelativeRanks(vector<int>& score) {\n        int n = score.size();\n        \n        vector<pair<int, int>> arr;\n        for (int i=0; i<n; i++) arr.push_back({score[i], i});\n\n        sort(rbegin(arr), rend(arr));\n        \n        vector<string> rank;\n\n        for (int i=0; i<n; i++) \n            rank[arr[i].second] = i==0? \"Gold Medal\": (i==1? \"Silver Medal\": (i==2? \"Bronze Medal\": to_string(i+1)));\n\n        return rank;\n    }\n};\n",
        "explanations": "\nReturning 'rank' vector, although it was not resized, which results in accessing undefined objects.\n"
    },
    {
        "slug": "distribute-coins-in-binary-tree",
        "description": "You are given the root of a binary tree with n nodes where each node in the tree has node.val coins. There are n coins in total throughout the whole tree.\nIn one move, we may choose two adjacent nodes and move one coin from one node to another. A move may be from parent to child, or from child to parent.\nReturn the minimum number of moves required to make every node have exactly one coin.",
        "examples": [
            "Input: root = [3,0,0]\nOutput: 2\nExplanation: From the root of the tree, we move one coin to its left child, and one coin to its right child.",
            "Input: root = [0,3,0]\nOutput: 3\nExplanation: From the left child of the root, we move two coins to the root [taking two moves]. Then, we move one coin from the root of the tree to the right child."
        ],
        "constraints": "The number of nodes in the tree is n.\n1 <= n <= 100\n0 <= Node.val <= n\nThe sum of all Node.val is n.",
        "release_time": 1686750328,
        "oracle_code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\n    // bs ye dhyan rkho leaf node se backtrack kro and return kro iss node ko kitne coins ki \n    // jarurat hai.. if -2 means 2 coins ki jarurat hai and 0 means no coins need\n    // 2 means 2 coins extra hai...iss node + iske neeche saare nodes ke bharne ke baad\n    // to kisi nodes ko kitne coins chahiye :- root->value ,-1 for this node coin\n    // +l for left side se jo ans aaya if -ve ans aaya to subtract wrna add nd same for right\n    // so, curr-1+l+r iss node ki requirement hai and iska parent itna coins isko lautaega if\n    // this is -ve or ye itna coin parent ko lauta rha hai if it is +ve so \n    // in final cnt ... add its abs(...) since dono case mein coin parent to child ya child to parent move karega\n    private:\n    int cnt=0;\n    int func(TreeNode *root) {\n        if(!root) return 0;\n\n        int l = func(root->left);\n        int r = func(root->right);\n\n        int temp = root->val -1 +l+r;\n        cnt += abs(temp);\n\n        return temp;\n    }\npublic:\n    int distributeCoins(TreeNode* root) {\n        func(root);\n        return cnt;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    // bs ye dhyan rkho leaf node se backtrack kro and return kro iss node ko kitne coins ki \\n    // jarurat hai.. if -2 means 2 coins ki jarurat hai and 0 means no coins need\\n    // 2 means 2 coins extra hai...iss node + iske neeche saare nodes ke bharne ke baad\\n    // to kisi nodes ko kitne coins chahiye :- root->value ,-1 for this node coin\\n    // +l for left side se jo ans aaya if -ve ans aaya to subtract wrna add nd same for right\\n    // so, curr-1+l+r iss node ki requirement hai and iska parent itna coins isko lautaega if\\n    // this is -ve or ye itna coin parent ko lauta rha hai if it is +ve so \\n    // in final cnt ... add its abs(...) since dono case mein coin parent to child ya child to parent move karega\\n    private:\\n    int cnt=0;\\n    int func(TreeNode *root) {\\n        if(!root) return 0;\\n\\n        int l = func(root->left);\\n        int r = func(root->right);\\n\\n        int temp = root->val -1 +l+r;\\n        cnt += abs(temp);\\n\\n        return temp;\\n    }\\npublic:\\n    int distributeCoins(TreeNode* root) {\\n        func(root);\\n        return cnt;\\n    }\\n};\\n```",
        "level": "medium",
        "buggy_code": "\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\nprivate:\n    int cnt=0;\n    TreeNode* newNode;\n\n    int func(TreeNode *root) {\n        if(!root) return 0;\n\n        int l = func(root->left);\n        int r = func(root->right);\n\n        int temp = newNode->val -1 +l+r; \n        cnt += abs(temp);\n\n        return temp;\n    }\npublic:\n    int distributeCoins(TreeNode* root) {\n        func(root);\n        return cnt;\n    }\n};\n",
        "explanations": "\nThe bug is an undefined objects error. 'newNode' is declared but not initialized. \n"
    },
    {
        "slug": "search-insert-position",
        "description": "Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.\nYou must\u00a0write an algorithm with\u00a0O(log n) runtime complexity.",
        "examples": [
            "Input: nums = [1,3,5,6], target = 5\nOutput: 2",
            "Input: nums = [1,3,5,6], target = 2\nOutput: 1",
            "Input: nums = [1,3,5,6], target = 7\nOutput: 4"
        ],
        "constraints": "1 <= nums.length <= 104\n-104 <= nums[i] <= 104\nnums contains distinct values sorted in ascending order.\n-104 <= target <= 104",
        "release_time": 1676910439,
        "oracle_code": "class Solution {\npublic:\n    int searchInsert(vector<int>& nums, int target) {\n        int l=0;\n        int r=nums.size()-1;\n        int m;\n        while(l<=r){\n            m=(l+r)/2;\n            if(nums[m]==target){\n                return m;\n            }else if(nums[m]>target){\n                r=m-1;\n            }\n            else{\n                l=m+1;\n            }\n        }\n        return l;\n    }\n};",
        "content": "# Complexity\\n- Time complexity: O(log(n)) -> Binary Search\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        int l=0;\\n        int r=nums.size()-1;\\n        int m;\\n        while(l<=r){\\n            m=(l+r)/2;\\n            if(nums[m]==target){\\n                return m;\\n            }else if(nums[m]>target){\\n                r=m-1;\\n            }\\n            else{\\n                l=m+1;\\n            }\\n        }\\n        return l;\\n    }\\n};\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\npublic:\n    int searchInsert(vector<int>& nums, int target) {\n        int l=0;\n        int r=nums.size();\n        int m;\n        while(l<=r){\n            m=(l+r)/2;\n            if(nums[m]==target){\n                return m;\n            }else if(nums[m]>target){\n                r=m-1;\n            }\n            else{\n                l=m+1;\n            }\n        }\n        return l;\n    }\n};\n",
        "explanations": "\nThe bug is at 'r=nums.size()'. This will go beyond the vector and create undefined behaviors.\n"
    },
    {
        "slug": "longest-increasing-subsequence",
        "description": "Given an integer array nums, return the length of the longest strictly increasing subsequence.",
        "examples": [
            "Input: nums = [10,9,2,5,3,7,101,18]\nOutput: 4\nExplanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.",
            "Input: nums = [0,1,0,3,2,3]\nOutput: 4",
            "Input: nums = [7,7,7,7,7,7,7]\nOutput: 1"
        ],
        "constraints": "1 <= nums.length <= 2500\n-104 <= nums[i] <= 104",
        "release_time": 1686036144,
        "oracle_code": "class Solution {\npublic:\n    int lengthOfLIS(vector<int>& nums) {\n        //array to store max length subsequence till that place\n        vector<int> dp(nums.size(),0);\n        int maxlength = 0;//to store maxlength of subsequence\n        dp[0] = 1;//length will be 1 at first index \n        for(int i = 0;i<nums.size();i++){\n            int currentMaxLen = 0; //to store maxlength at till this index\n            for(int j = 0;j<i;j++){\n                // only check when the subsequence is increasing\n                if(nums[i]>nums[j]){\n                    if(currentMaxLen<dp[j]){\n                        currentMaxLen = dp[j]; //update currentMaxLen accordingly\n                    }\n                }\n            }\n            dp[i] = currentMaxLen + 1; //set the maxLength till ith index, which will be maxlenth so far + 1\n            maxlength = max(maxlength,dp[i]); //update maxlength\n        }\n        \n        return maxlength;\n    }\n};",
        "content": "# Intuition\\nThe problem asks us to find the length of the longest strictly increasing subsequence in the given array. To solve this problem efficiently, we can use dynamic programming.\\n\\n# Approach\\n1. Create a vector dp of size nums.size(), where dp[i] will store the length of the longest increasing subsequence ending at index i.\\n2. Initialize a variable maxlength to store the maximum length of the subsequence.\\n3. Set dp[0] to 1, as the length of the subsequence ending at the first index is always 1.\\n4. Iterate through each element in nums using the outer loop. For each element at index i, iterate through all the previous elements using the inner loop (from 0 to i-1).\\n5. Check if nums[i] is greater than nums[j], indicating that we can extend the increasing subsequence.\\n    - If the condition is satisfied, update the currentMaxLen variable with the maximum length of the subsequence so far at index j.\\n6. After the inner loop, update dp[i] with currentMaxLen + 1, which represents the maximum length of the subsequence ending at index i.\\nUpdate maxlength by taking the maximum value between maxlength and dp[i].\\n7. After the loop, maxlength will contain the length of the longest increasing subsequence.\\n8. Return maxlength.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of this solution is O(n^2), where n is the size of the input array nums. The outer loop runs for n iterations, and the inner loop also runs for a maximum of n iterations.\\n\\n- Space complexity:\\nThe space complexity is O(n) since we are using an additional vector dp of size n to store the lengths of subsequences.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums) {\\n        //array to store max length subsequence till that place\\n        vector<int> dp(nums.size(),0);\\n        int maxlength = 0;//to store maxlength of subsequence\\n        dp[0] = 1;//length will be 1 at first index \\n        for(int i = 0;i<nums.size();i++){\\n            int currentMaxLen = 0; //to store maxlength at till this index\\n            for(int j = 0;j<i;j++){\\n                // only check when the subsequence is increasing\\n                if(nums[i]>nums[j]){\\n                    if(currentMaxLen<dp[j]){\\n                        currentMaxLen = dp[j]; //update currentMaxLen accordingly\\n                    }\\n                }\\n            }\\n            dp[i] = currentMaxLen + 1; //set the maxLength till ith index, which will be maxlenth so far + 1\\n            maxlength = max(maxlength,dp[i]); //update maxlength\\n        }\\n        \\n        return maxlength;\\n    }\\n};\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\npublic:\n    int lengthOfLIS(vector<int>& nums) {\n        //array to store max length subsequence till that place\n        vector<int> dp(0,0);\n        int maxlength = 0;//to store maxlength of subsequence\n        dp[0] = 1;//length will be 1 at first index \n        for(int i = 0;i<nums.size();i++){\n            int currentMaxLen = 0; //to store maxlength at till this index\n            for(int j = 0;j<i;j++){\n                // only check when the subsequence is increasing\n                if(nums[i]>nums[j]){\n                    if(currentMaxLen<dp[j]){\n                        currentMaxLen = dp[j]; //update currentMaxLen accordingly\n                    }\n                }\n            }\n            dp[i] = currentMaxLen + 1; //set the maxLength till ith index, which will be maxlenth so far + 1\n            maxlength = max(maxlength,dp[i]); //update maxlength\n        }\n        \n        return maxlength;\n    }\n};\n",
        "explanations": "\nThe bug is in the initialization of vector 'dp' with zero elements causing it to throw an out-of-range error.\n"
    },
    {
        "slug": "minimum-time-to-complete-trips",
        "description": "You are given an array time where time[i] denotes the time taken by the ith bus to complete one trip.\nEach bus can make multiple trips successively; that is, the next trip can start immediately after completing the current trip. Also, each bus operates independently; that is, the trips of one bus do not influence the trips of any other bus.\nYou are also given an integer totalTrips, which denotes the number of trips all buses should make in total. Return the minimum time required for all buses to complete at least totalTrips trips.",
        "examples": [
            "Input: time = [1,2,3], totalTrips = 5\nOutput: 3\nExplanation:\n- At time t = 1, the number of trips completed by each bus are [1,0,0]. \n  The total number of trips completed is 1 + 0 + 0 = 1.\n- At time t = 2, the number of trips completed by each bus are [2,1,0]. \n  The total number of trips completed is 2 + 1 + 0 = 3.\n- At time t = 3, the number of trips completed by each bus are [3,1,1]. \n  The total number of trips completed is 3 + 1 + 1 = 5.\nSo the minimum time needed for all buses to complete at least 5 trips is 3.",
            "Input: time = [2], totalTrips = 1\nOutput: 2\nExplanation:\nThere is only one bus, and it will complete its first trip at t = 2.\nSo the minimum time needed to complete 1 trip is 2."
        ],
        "constraints": "1 <= time.length <= 105\n1 <= time[i], totalTrips <= 107",
        "release_time": 1678208037,
        "oracle_code": "#define ll long long \nclass Solution {\npublic:\n    long long minimumTime(vector<int>& time, int totalTrips) {\n        ll l = 1, r = 1e14;\n        while(l <= r) {\n            ll trip = 0, mid = (l + r) / 2;\n            for(int i=0; i<time.size(); i++) trip += mid / time[i];\n            if(trip < totalTrips) l = mid + 1;\n            else r = mid - 1;\n        }\n        return l;\n    }\n};",
        "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    Binary Search\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N * logN)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\n```\\n#define ll long long \\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        ll l = 1, r = 1e14;\\n        while(l <= r) {\\n            ll trip = 0, mid = (l + r) / 2;\\n            for(int i=0; i<time.size(); i++) trip += mid / time[i];\\n            if(trip < totalTrips) l = mid + 1;\\n            else r = mid - 1;\\n        }\\n        return l;\\n    }\\n};\\n```",
        "level": "medium",
        "buggy_code": "\n#define ll long long \nclass Solution {\npublic:\n    long long minimumTime(vector<int>& time, int totalTrips) {\n        ll l = 1, r = 1e14;\n        Solution obj;\n        while(l <= r) {\n            ll trip = 0, mid = (l + r) / 2;\n            for(int i=0; i<time.size(); i++) trip += mid / time[i];\n            if(trip < totalTrips) l = mid + 1;\n            else r = mid - 1;\n        }\n        return obj.minimumTime(time, totalTrips);\n    }\n};\n",
        "explanations": "\nThe program will recursively call itself without terminating, leading to a stack overflow.\n"
    },
    {
        "slug": "middle-of-the-linked-list",
        "description": "Given the head of a singly linked list, return the middle node of the linked list.\nIf there are two middle nodes, return the second middle node.",
        "examples": [
            "Input: head = [1,2,3,4,5]\nOutput: [3,4,5]\nExplanation: The middle node of the list is node 3.",
            "Input: head = [1,2,3,4,5,6]\nOutput: [4,5,6]\nExplanation: Since the list has two middle nodes with values 3 and 4, we return the second one."
        ],
        "constraints": "The number of nodes in the list is in the range [1, 100].\n1 <= Node.val <= 100",
        "release_time": 1687519093,
        "oracle_code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* middleNode(ListNode* head) {\n        ListNode* temp = head;\n        ListNode* mid = head;\n        while(temp != NULL && temp -> next != NULL){\n            mid = mid -> next;\n            temp = temp->next-> next;\n        }\n        return mid;\n    }\n};",
        "content": "## INITIALIZE BOTH POINTS FROM HEAD AND THEN TRAVERSE\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# FIRST POINT SHOULD TRAVERSE AT A NORMAL PACE\\n# BUT THE OTHER POINTER (ie. FAST) SHOULD SKIP ONE NODE AND THUS YOU WILL REACH THE SOLUTION IN O(n) TIME COMPLEXITY.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* middleNode(ListNode* head) {\\n        ListNode* temp = head;\\n        ListNode* mid = head;\\n        while(temp != NULL && temp -> next != NULL){\\n            mid = mid -> next;\\n            temp = temp->next-> next;\\n        }\\n        return mid;\\n    }\\n};\\n```",
        "level": "easy",
        "buggy_code": "\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* middleNode(ListNode* head) {\n        ListNode* temp = head;\n        ListNode* mid = head;\n        while(temp != NULL && temp -> next != NULL){\n            mid = mid -> next;\n            temp = temp->next-> undefined;\n        }\n        return mid;\n    }\n};\n",
        "explanations": "\nThe 'undefined' reference in temp->next->undefined will cause a compile error.\n"
    },
    {
        "slug": "hamming-distance",
        "description": "The Hamming distance between two integers is the number of positions at which the corresponding bits are different.\nGiven two integers x and y, return the Hamming distance between them.",
        "examples": [
            "Input: x = 1, y = 4\nOutput: 2\nExplanation:\n1   (0 0 0 1)\n4   (0 1 0 0)\n       \u2191   \u2191\nThe above arrows point to positions where the corresponding bits are different.",
            "Input: x = 3, y = 1\nOutput: 1"
        ],
        "constraints": "0 <=\u00a0x, y <= 231 - 1",
        "release_time": 1692183390,
        "oracle_code": "class Solution {\npublic:\n    int hammingDistance(int x, int y) {\n        int ans=0;\n        while(x || y){\n            int mask=x&1;\n            int mask2=y&1;\n            if(mask!=mask2){\n                ans++;\n            }\n            x>>=1;\n            y>>=1;\n        }\n        return ans;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe just have to check the number of bits that are different.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor this approach we follow these steps.\\n1.Run a loop until both the numbers are zero.\\n2.Get the last bit of the two numbers and compare them.\\n3.If the two bits didn\\'t match increase the count.\\n4.After each iteration right shift both the numbers by 1.\\n5.At last return the count.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int hammingDistance(int x, int y) {\\n        int ans=0;\\n        while(x || y){\\n            int mask=x&1;\\n            int mask2=y&1;\\n            if(mask!=mask2){\\n                ans++;\\n            }\\n            x>>=1;\\n            y>>=1;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# **PLEASE DO UPVOTE!!!\\uD83E\\uDD79**",
        "level": "easy",
        "buggy_code": "\nclass Solution {\npublic:\n    int hammingDistance(int x, int y) {\n        int ans;\n        while(x || y){\n            int mask=x&1;\n            int mask2=y&1;\n            if(mask!=mask2){\n                ans++;\n            }\n            x>>=1;\n            y>>=1;\n        }\n        return ans;\n    }\n};\n",
        "explanations": "\nThe variable 'ans' is not initialized before it is incremented, causing undefined behavior.\n"
    },
    {
        "slug": "domino-and-tromino-tiling",
        "description": "You have two types of tiles: a 2 x 1 domino shape and a tromino shape. You may rotate these shapes.\n\nGiven an integer n, return the number of ways to tile an 2 x n board. Since the answer may be very large, return it modulo 109 + 7.\nIn a tiling, every square must be covered by a tile. Two tilings are different if and only if there are two 4-directionally adjacent cells on the board such that exactly one of the tilings has both squares occupied by a tile.",
        "examples": [
            "Input: n = 3\nOutput: 5\nExplanation: The five different ways are show above.",
            "Input: n = 1\nOutput: 1"
        ],
        "constraints": "1 <= n <= 1000",
        "release_time": 1671865863,
        "oracle_code": "class Solution {\npublic:\n    int mod=1e9+7;\n    long helper(int n, vector<long>& dp){\n        if(n==1) return 1;\n        if(n==2) return 2;\n        if(n==3) return 5;\n\n        if(dp[n]!=-1) return dp[n]%mod;\n\n        long smallAns1=0, smallAns2=0;\n        smallAns1=helper(n-1,dp)%mod;\n        smallAns2=helper(n-3,dp)%mod;\n\n        dp[n]=(smallAns1*2+smallAns2)%mod;\n        return dp[n]%mod;\n    }\n    \n    int numTilings(int n) {\n        vector<long> dp(n+1,-1);\n        long ans=helper(n,dp)%mod;\n        return (int)ans;        \n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nfor n , we want answer for n-1 and n-3\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n) + Recurisve Stack Space \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    long helper(int n, vector<long>& dp){\\n        if(n==1) return 1;\\n        if(n==2) return 2;\\n        if(n==3) return 5;\\n\\n        if(dp[n]!=-1) return dp[n]%mod;\\n\\n        long smallAns1=0, smallAns2=0;\\n        smallAns1=helper(n-1,dp)%mod;\\n        smallAns2=helper(n-3,dp)%mod;\\n\\n        dp[n]=(smallAns1*2+smallAns2)%mod;\\n        return dp[n]%mod;\\n    }\\n    \\n    int numTilings(int n) {\\n        vector<long> dp(n+1,-1);\\n        long ans=helper(n,dp)%mod;\\n        return (int)ans;        \\n    }\\n};\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\npublic:\n    int mod=1e9+7;\n    long helper(int n, vector<long>& dp){\n        if(n==1) return 1;\n        if(n==2) return 2;\n        if(n==3) return 5;\n\n        if(dp[n]!=-1) return dp[n]%mod;\n\n        long smallAns1=0, smallAns2=0;\n        smallAns1=helper(n-1,dp)%mod;\n        smallAns2=helper(n-3,dp)%mod;\n\n        dp[n]=(smallAns1*2+smallAns2)%mod;\n        helper(n+1,dp)%mod;\n        return dp[n]%mod;\n    }\n    \n    int numTilings(int n) {\n        vector<long> dp(n+1,-1);\n        long ans=helper(n,dp)%mod;\n        return (int)ans;        \n    }\n};\n",
        "explanations": "\nThe code contains an undefined behavior because it accesses dp[n+1] which may exceed dp's size.\n"
    },
    {
        "slug": "minimum-operations-to-make-the-array-increasing",
        "description": "You are given an integer array nums (0-indexed). In one operation, you can choose an element of the array and increment it by 1.\n\nFor example, if nums = [1,2,3], you can choose to increment nums[1] to make nums = [1,3,3].\n\nReturn the minimum number of operations needed to make nums strictly increasing.\nAn array nums is strictly increasing if nums[i] < nums[i+1] for all 0 <= i < nums.length - 1. An array of length 1 is trivially strictly increasing.",
        "examples": [
            "Input: nums = [1,1,1]\r\nOutput: 3\r\nExplanation: You can do the following operations:\r\n1) Increment nums[2], so nums becomes [1,1,2].\r\n2) Increment nums[1], so nums becomes [1,2,2].\r\n3) Increment nums[2], so nums becomes [1,2,3].",
            "Input: nums = [1,5,2,4,1]\r\nOutput: 14",
            "Input: nums = [8]\r\nOutput: 0"
        ],
        "constraints": "1 <= nums.length <= 5000\n1 <= nums[i] <= 104",
        "release_time": 1687530268,
        "oracle_code": "class Solution {\npublic:\n    int minOperations(vector<int>& nums) {\n       int count = 0; \n       for(int i=1; i<nums.size(); i++) if(nums[i] <= nums[i-1]) { count += nums[i-1]+1-nums[i]; nums[i] = nums[i-1]+1; }\n\n       return count; \n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nPlease upvote if you find it helpful \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n       int count = 0; \\n       for(int i=1; i<nums.size(); i++) if(nums[i] <= nums[i-1]) { count += nums[i-1]+1-nums[i]; nums[i] = nums[i-1]+1; }\\n\\n       return count; \\n    }\\n};\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\npublic:\n    int minOperations(vector<int>& nums) {\n       int count = 0; \n       vector<int> undefinedNumbers;\n       for(int i=1; i<undefinedNumbers.size(); i++) if(undefinedNumbers[i] <= undefinedNumbers[i-1]) { count += undefinedNumbers[i-1]+1-undefinedNumbers[i]; undefinedNumbers[i] = undefinedNumbers[i-1]+1; }\n\n       return count; \n    }\n};\n",
        "explanations": "\nThe undefinedNumbers vector is never defined with values, it's empty causing unexpected behavior.\n"
    },
    {
        "slug": "minimum-operations-to-halve-array-sum",
        "description": "You are given an array nums of positive integers. In one operation, you can choose any number from nums and reduce it to exactly half the number. (Note that you may choose this reduced number in future operations.)\nReturn the minimum number of operations to reduce the sum of nums by at least half.",
        "examples": [
            "Input: nums = [5,19,8,1]\nOutput: 3\nExplanation: The initial sum of nums is equal to 5 + 19 + 8 + 1 = 33.\nThe following is one of the ways to reduce the sum by at least half:\nPick the number 19 and reduce it to 9.5.\nPick the number 9.5 and reduce it to 4.75.\nPick the number 8 and reduce it to 4.\nThe final array is [5, 4.75, 4, 1] with a total sum of 5 + 4.75 + 4 + 1 = 14.75. \nThe sum of nums has been reduced by 33 - 14.75 = 18.25, which is at least half of the initial sum, 18.25 >= 33/2 = 16.5.\nOverall, 3 operations were used so we return 3.\nIt can be shown that we cannot reduce the sum by at least half in less than 3 operations.",
            "Input: nums = [3,8,20]\nOutput: 3\nExplanation: The initial sum of nums is equal to 3 + 8 + 20 = 31.\nThe following is one of the ways to reduce the sum by at least half:\nPick the number 20 and reduce it to 10.\nPick the number 10 and reduce it to 5.\nPick the number 3 and reduce it to 1.5.\nThe final array is [1.5, 8, 5] with a total sum of 1.5 + 8 + 5 = 14.5. \nThe sum of nums has been reduced by 31 - 14.5 = 16.5, which is at least half of the initial sum, 16.5 >= 31/2 = 15.5.\nOverall, 3 operations were used so we return 3.\nIt can be shown that we cannot reduce the sum by at least half in less than 3 operations."
        ],
        "constraints": "1 <= nums.length <= 105\n1 <= nums[i] <= 107",
        "release_time": 1675094747,
        "oracle_code": "class Solution {\npublic:\n\n    int halveArray(vector<int>& nums) \n    {\n        // use priority Queue to store elements in assending order\n        // So Biggest element is always on top of Queue\n        priority_queue<double>Q;\n\n        double sum=0;   //Total sum of element\n\n        //store all elments in Queue\n        for(auto ele : nums)\n        {\n            sum+=ele;\n            Q.push(ele);\n            \n        }\n        \n        //half of total\n        double half=sum/2;\n\n        //count operations until sum is greater than half \n        int count=0;\n        while(sum>half)\n        { \n            double max=Q.top();     //maximum emement of Queue\n            Q.pop();                //remove it from Queue\n\n            max/=2;                 \n            Q.push(max);            //add half of that element\n            count++;                //count accurance of operation\n\n            sum-=max;               //substarct half of element from sum \n        }\n       \n        return count;\n        \n    }\n};",
        "content": "\\n# Complexity\\n- Time complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int halveArray(vector<int>& nums) \\n    {\\n        // use priority Queue to store elements in assending order\\n        // So Biggest element is always on top of Queue\\n        priority_queue<double>Q;\\n\\n        double sum=0;   //Total sum of element\\n\\n        //store all elments in Queue\\n        for(auto ele : nums)\\n        {\\n            sum+=ele;\\n            Q.push(ele);\\n            \\n        }\\n        \\n        //half of total\\n        double half=sum/2;\\n\\n        //count operations until sum is greater than half \\n        int count=0;\\n        while(sum>half)\\n        { \\n            double max=Q.top();     //maximum emement of Queue\\n            Q.pop();                //remove it from Queue\\n\\n            max/=2;                 \\n            Q.push(max);            //add half of that element\\n            count++;                //count accurance of operation\\n\\n            sum-=max;               //substarct half of element from sum \\n        }\\n       \\n        return count;\\n        \\n    }\\n};\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\npublic:\n\n    int halveArray(vector<int>& nums) \n    {\n        priority_queue<double>Q;\n\n        double sum=0;\n\n        for(auto ele : nums)\n        {\n            sum+=ele;\n            Q.push(ele);\n            \n        }\n        \n        double half=sum/2;\n\n        int count=0;\n        while(sum>half)\n        { \n            double max=Q.top();\n            Q.pop();\n\n            max/=2;                 \n            Q.push(max);            \n            count++;                \n\n            sum-=max;               \n        }\n        \n        double temp = sum1;\n\n        return count;\n        \n    }\n};\n",
        "explanations": "\nThe variable 'sum1' is undefined, it hasn't been declared anywhere in the code earlier.\n"
    },
    {
        "slug": "find-elements-in-a-contaminated-binary-tree",
        "description": "Given a binary tree with the following rules:\n\nroot.val == 0\nIf treeNode.val == x and treeNode.left != null, then treeNode.left.val == 2 * x + 1\nIf treeNode.val == x and treeNode.right != null, then treeNode.right.val == 2 * x + 2\n\nNow the binary tree is contaminated, which means all treeNode.val have been changed to -1.\nImplement the FindElements class:\n\nFindElements(TreeNode* root) Initializes the object with a contaminated binary tree and recovers it.\nbool find(int target) Returns true if the target value exists in the recovered binary tree.",
        "examples": [
            "Input\n[\"FindElements\",\"find\",\"find\"]\n[[[-1,null,-1]],[1],[2]]\nOutput\n[null,false,true]\nExplanation\nFindElements findElements = new FindElements([-1,null,-1]); \nfindElements.find(1); // return False \nfindElements.find(2); // return True",
            "Input\n[\"FindElements\",\"find\",\"find\",\"find\"]\n[[[-1,-1,-1,-1,-1]],[1],[3],[5]]\nOutput\n[null,true,true,false]\nExplanation\nFindElements findElements = new FindElements([-1,-1,-1,-1,-1]);\nfindElements.find(1); // return True\nfindElements.find(3); // return True\nfindElements.find(5); // return False",
            "Input\n[\"FindElements\",\"find\",\"find\",\"find\",\"find\"]\n[[[-1,null,-1,-1,null,-1]],[2],[3],[4],[5]]\nOutput\n[null,true,false,false,true]\nExplanation\nFindElements findElements = new FindElements([-1,null,-1,-1,null,-1]);\nfindElements.find(2); // return True\nfindElements.find(3); // return False\nfindElements.find(4); // return False\nfindElements.find(5); // return True"
        ],
        "constraints": "TreeNode.val == -1\nThe height of the binary tree is less than or equal to 20\nThe total number of nodes is between [1, 104]\nTotal calls of find() is between [1, 104]\n0 <= target <= 106",
        "release_time": 1666144088,
        "oracle_code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass FindElements {\n  unordered_set<int> set;\npublic:\n    void recover(TreeNode* root, int x) {\n        if (!root) return;\n        root->val = x;\n        set.emplace(x);\n        recover(root->left, 2 * x + 1);\n        recover(root->right, 2 * x + 2);\n    }\n    \n    FindElements(TreeNode* root) {\n        recover(root, 0);\n    }\n    \n    bool find(int target) {\n        return set.count(target);\n    }\n};\n\n/**\n * Your FindElements object will be instantiated and called as such:\n * FindElements* obj = new FindElements(root);\n * bool param_1 = obj->find(target);\n */",
        "content": "\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\n  unordered_set<int> set;\\npublic:\\n    void recover(TreeNode* root, int x) {\\n        if (!root) return;\\n        root->val = x;\\n        set.emplace(x);\\n        recover(root->left, 2 * x + 1);\\n        recover(root->right, 2 * x + 2);\\n    }\\n    \\n    FindElements(TreeNode* root) {\\n        recover(root, 0);\\n    }\\n    \\n    bool find(int target) {\\n        return set.count(target);\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
        "level": "medium",
        "buggy_code": "\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass FindElements {\n  unordered_set<int> set;\npublic:\n    void recover(TreeNode* root, int x) {\n        if (!root) return;\n        root->val = x;\n        set.emplace(x);\n        recover(root->left, 2 * x + 1);\n        recover(root->right);\n    }\n    \n    FindElements(TreeNode* root) {\n        recover(root, 0);\n    }\n    \n    bool find(int target) {\n        return set.count(target);\n    }\n};\n\n/**\n * Your FindElements object will be instantiated and called as such:\n * FindElements* obj = new FindElements(root);\n * bool param_1 = obj->find(target);\n */\n",
        "explanations": "\nThe function recover(root->right) is missing an argument, causing an undefined objects bug.\n"
    },
    {
        "slug": "lru-cache",
        "description": "Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.\nImplement the LRUCache class:\n\nLRUCache(int capacity) Initialize the LRU cache with positive size capacity.\nint get(int key) Return the value of the key if the key exists, otherwise return -1.\nvoid put(int key, int value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key.\n\nThe functions get and put must each run in O(1) average time complexity.",
        "examples": [
            "Input\n[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"]\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\nOutput\n[null, null, null, 1, null, -1, null, -1, 3, 4]\n\nExplanation\nLRUCache lRUCache = new LRUCache(2);\nlRUCache.put(1, 1); // cache is {1=1}\nlRUCache.put(2, 2); // cache is {1=1, 2=2}\nlRUCache.get(1);    // return 1\nlRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}\nlRUCache.get(2);    // returns -1 (not found)\nlRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}\nlRUCache.get(1);    // return -1 (not found)\nlRUCache.get(3);    // return 3\nlRUCache.get(4);    // return 4"
        ],
        "constraints": "1 <= capacity <= 3000\n0 <= key <= 104\n0 <= value <= 105\nAt most 2 * 105 calls will be made to get and put.",
        "release_time": 1689644680,
        "oracle_code": "class LRUCache {\npublic:\nclass node\n{\n  public:\n  int key;\n  int val;\n  node* next;\n  node* prev;\n  node(int _key,int _val)\n  {\n    key = _key;\n    val = _val;\n  }\n};\nnode* head = new node(-1,-1);\nnode* tail = new node(-1,-1);\n\nint size;\nunordered_map<int,node*>mpp;\n    LRUCache(int capacity) {\n       size = capacity; \n       head->next = tail;\n       tail->prev = head;  \n    }\n\n    void addNode(node* newNode){\n       \n       node* temp = head->next;\n       newNode->next = temp;\n       newNode->prev = head;\n       head->next = newNode;\n       temp->prev = newNode;\n    }\n\n    void deleteNode(node* delNode){\n         \n       node* delprev = delNode->prev;\n       node* delnext = delNode->next;\n       delprev->next = delnext;\n       delnext->prev = delprev;\n    }\n    \n    int get(int _key) {\n        \n        if(mpp.count(_key))\n        {\n          node* nde = mpp[_key];\n          int curr = nde->val;\n          mpp.erase(_key);\n          deleteNode(nde);\n          addNode(nde);\n          mpp[_key] = head->next;\n          return curr;\n        }\n        return -1;\n    }\n    \n    void put(int _key, int value) {\n        \n        if(mpp.count(_key))\n        {\n           node* nde = mpp[_key];\n           mpp.erase(_key);\n           deleteNode(nde);\n        }\n        if(mpp.size()==size)\n        {\n           mpp.erase(tail->prev->key);\n           deleteNode(tail->prev);\n        }\n        addNode(new node(_key,value));\n        mpp[_key] = head->next;\n    }\n};",
        "content": "# PLEASE DO UPVOTE!!!!!\\n\\n**CONNECT WITH ME ON LINKEDIN :  https://www.linkedin.com/in/md-kamran-55b98521a/**\\n\\n## INTUITION\\nTo Implement LRU(Least recently used), we need to have a track of the usage of the keys, in the order of there usage, as we have a limited capacity we cant extend our capacity beyond \"capacity\", so we always we will take out those values which has\\'nt been acccess in the recent time.So, we have to think of something that can kind of sort our keys according to usage on the go, the best Data Structure for this purpose is Doubly linked List.\\n                             A Doubly linked list will have a Head node as well as a tail node, and whenever a key is used we will place it just next to the head node,in this fashions, the one\\'s which are closer to head are the most recently used ones, and as we go closer to the tail node, those are the less recently used ones while the node just previous to tail is the \"LEAST RECENTLY USED\". \\nSo whenever we add a key or use a key(get()), we will move it right after the head node, and whenever we call the (put() function), if size if greater we have to delete the LRU node, if key is not present, (if present then too we will delete that node so as to update the value and still move it right after head node), and place new node right after head node.                        \\n\\n\\n**Ask Furthur Doubts in the Comment Section**\\n# Code\\n```\\nclass LRUCache {\\npublic:\\nclass node\\n{\\n  public:\\n  int key;\\n  int val;\\n  node* next;\\n  node* prev;\\n  node(int _key,int _val)\\n  {\\n    key = _key;\\n    val = _val;\\n  }\\n};\\nnode* head = new node(-1,-1);\\nnode* tail = new node(-1,-1);\\n\\nint size;\\nunordered_map<int,node*>mpp;\\n    LRUCache(int capacity) {\\n       size = capacity; \\n       head->next = tail;\\n       tail->prev = head;  \\n    }\\n\\n    void addNode(node* newNode){\\n       \\n       node* temp = head->next;\\n       newNode->next = temp;\\n       newNode->prev = head;\\n       head->next = newNode;\\n       temp->prev = newNode;\\n    }\\n\\n    void deleteNode(node* delNode){\\n         \\n       node* delprev = delNode->prev;\\n       node* delnext = delNode->next;\\n       delprev->next = delnext;\\n       delnext->prev = delprev;\\n    }\\n    \\n    int get(int _key) {\\n        \\n        if(mpp.count(_key))\\n        {\\n          node* nde = mpp[_key];\\n          int curr = nde->val;\\n          mpp.erase(_key);\\n          deleteNode(nde);\\n          addNode(nde);\\n          mpp[_key] = head->next;\\n          return curr;\\n        }\\n        return -1;\\n    }\\n    \\n    void put(int _key, int value) {\\n        \\n        if(mpp.count(_key))\\n        {\\n           node* nde = mpp[_key];\\n           mpp.erase(_key);\\n           deleteNode(nde);\\n        }\\n        if(mpp.size()==size)\\n        {\\n           mpp.erase(tail->prev->key);\\n           deleteNode(tail->prev);\\n        }\\n        addNode(new node(_key,value));\\n        mpp[_key] = head->next;\\n    }\\n};\\n\\n```\\n![b62ab1be-232a-438f-9524-7d8ca4dbd5fe_1675328166.1161866.png](https://assets.leetcode.com/users/images/8d5343b1-0eb4-4111-a914-40ce968fd034_1675389764.2273676.png)",
        "level": "medium",
        "buggy_code": "\nclass LRUCache {\npublic:\nclass node\n{\n  public:\n  int key;\n  int val;\n  node* next;\n  node* prev;\n  node(int _key,int _val)\n  {\n    key = _key;\n    val = _val;\n  }\n};\nnode* head = nullptr;\nnode* tail = nullptr;\n\nint size;\nunordered_map<int,node*>mpp;\n    LRUCache(int capacity) {\n       size = capacity; \n       head->next = tail;\n       tail->prev = head;  \n    }\n\n    void addNode(node* newNode){\n       \n       node* temp = head->next;\n       newNode->next = temp;\n       newNode->prev = head;\n       head->next = newNode;\n       temp->prev = newNode;\n    }\n\n    void deleteNode(node* delNode){\n         \n       node* delprev = delNode->prev;\n       node* delnext = delNode->next;\n       delprev->next = delnext;\n       delnext->prev = delprev;\n    }\n    \n    int get(int _key) {\n        \n        if(mpp.count(_key))\n        {\n          node* nde = mpp[_key];\n          int curr = nde->val;\n          mpp.erase(_key);\n          deleteNode(nde);\n          addNode(nde);\n          mpp[_key] = head->next;\n          return curr;\n        }\n        return -1;\n    }\n    \n    void put(int _key, int value) {\n        \n        if(mpp.count(_key))\n        {\n           node* nde = mpp[_key];\n           mpp.erase(_key);\n           deleteNode(nde);\n        }\n        if(mpp.size()==size)\n        {\n           mpp.erase(tail->prev->key);\n           deleteNode(tail->prev);\n        }\n        addNode(new node(_key,value));\n        mpp[_key] = head->next;\n    }\n};\n",
        "explanations": "\nhead and tail are initialized as null. It will cause a null pointer dereference.\n"
    },
    {
        "slug": "smallest-string-starting-from-leaf",
        "description": "You are given the root of a binary tree where each node has a value in the range [0, 25] representing the letters 'a' to 'z'.\nReturn the lexicographically smallest string that starts at a leaf of this tree and ends at the root.\nAs a reminder, any shorter prefix of a string is lexicographically smaller.\n\nFor example, \"ab\" is lexicographically smaller than \"aba\".\n\nA leaf of a node is a node that has no children.",
        "examples": [
            "Input: root = [0,1,2,3,4,3,4]\nOutput: \"dba\"",
            "Input: root = [25,1,3,1,3,0,2]\nOutput: \"adz\"",
            "Input: root = [2,2,1,null,1,0,null,0]\nOutput: \"abc\""
        ],
        "constraints": "The number of nodes in the tree is in the range [1, 8500].\n0 <= Node.val <= 25",
        "release_time": 1689057293,
        "oracle_code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    string BFS(TreeNode* root)\n    {\n        if(!root) return \"\";\n        queue<pair<TreeNode*,string>> q;\n        vector<string> ans;\n        string s = \"\";\n        s+=root->val+97;\n        q.push({root,s});\n        while(!q.empty())\n        {\n            TreeNode* node = q.front().first;\n            string str = q.front().second;\n            q.pop();\n            if(!node->left && !node->right)\n            {\n                reverse(str.begin(),str.end());\n                ans.push_back(str);\n            }\n            if(node->left)\n            {\n                string tmp = str;\n                tmp+=node->left->val+97;\n                q.push({node->left,tmp});\n            }\n            if(node->right)\n            {\n                string tmp = str;\n                tmp+=node->right->val+97;\n                q.push({node->right,tmp});\n            }\n        }\n        sort(ans.begin(),ans.end());\n        return ans[0];\n    }\n    string smallestFromLeaf(TreeNode* root) {\n       return BFS(root);\n    }\n};",
        "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDo the BFS Traversal from  **Root Node** to **Leaf Node** and Store the **Path as a string** and return the **lexicographically smallest** string.\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    string BFS(TreeNode* root)\\n    {\\n        if(!root) return \"\";\\n        queue<pair<TreeNode*,string>> q;\\n        vector<string> ans;\\n        string s = \"\";\\n        s+=root->val+97;\\n        q.push({root,s});\\n        while(!q.empty())\\n        {\\n            TreeNode* node = q.front().first;\\n            string str = q.front().second;\\n            q.pop();\\n            if(!node->left && !node->right)\\n            {\\n                reverse(str.begin(),str.end());\\n                ans.push_back(str);\\n            }\\n            if(node->left)\\n            {\\n                string tmp = str;\\n                tmp+=node->left->val+97;\\n                q.push({node->left,tmp});\\n            }\\n            if(node->right)\\n            {\\n                string tmp = str;\\n                tmp+=node->right->val+97;\\n                q.push({node->right,tmp});\\n            }\\n        }\\n        sort(ans.begin(),ans.end());\\n        return ans[0];\\n    }\\n    string smallestFromLeaf(TreeNode* root) {\\n       return BFS(root);\\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/67c6667a-66b6-4d36-846d-56e86a3b137a_1689057284.4817927.jpeg)\\n",
        "level": "medium",
        "buggy_code": "\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    string BFS(TreeNode* root)\n    {\n        if(!root) return \"\";\n        queue<pair<TreeNode*,string>> q;\n        vector<string> ans;\n        string s = \"\";\n        s+=root->val+97;\n        q.push({root,s});\n        while(!q.empty())\n        {\n            TreeNode* node = q.front().first;\n            string str = q.front().second;\n            q.pop();\n            if(!node->left && !node->right)\n            {\n                reverse(str.begin(),str.end());\n                ans.push_back(str);\n            }\n            if(node->left)\n            {\n                string tmp = str;\n                tmp+=node->left->val+97;\n                q.push({node->left,tmp});\n            }\n            TreeNode* undefinedNode;\n            if(undefinedNode->right)\n            {\n                string tmp = str;\n                tmp+=undefinedNode->right->val+97;\n                q.push({undefinedNode->right,tmp});\n            }\n        }\n        sort(ans.begin(),ans.end());\n        return ans[0];\n    }\n    string smallestFromLeaf(TreeNode* root) {\n       return BFS(root);\n    }\n};\n",
        "explanations": "\nThe bug is an undefined object 'undefinedNode'. Any reference to it potentially causes a crash.\n"
    },
    {
        "slug": "factorial-trailing-zeroes",
        "description": "Given an integer n, return the number of trailing zeroes in n!.\nNote that n! = n * (n - 1) * (n - 2) * ... * 3 * 2 * 1.",
        "examples": [
            "Input: n = 3\nOutput: 0\nExplanation: 3! = 6, no trailing zero.",
            "Input: n = 5\nOutput: 1\nExplanation: 5! = 120, one trailing zero.",
            "Input: n = 0\nOutput: 0"
        ],
        "constraints": "0 <= n <= 104",
        "release_time": 1682961619,
        "oracle_code": "class Solution {\npublic:\n    unordered_map<long long int,long long int>mp;\n    int trailingZeroes(int n) {\n        for(int i=n;i>=1;i--)\n         fun(i);\n         \n\t\t return min(mp[2],mp[5]); \n    }\n     void fun(int n)\n    {\n         for(int i=2;i*i<=n;i++)\n         {\n         \twhile((n%i) == 0)\n         \t{\n         \t    mp[i]++;\n\t\t\t\tn = n / i;\t\n\t\t\t}\n\t\t }\n\t\t if(n > 1)\n\t\t mp[n]++;\n    }\n};",
        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    unordered_map<long long int,long long int>mp;\\n    int trailingZeroes(int n) {\\n        for(int i=n;i>=1;i--)\\n         fun(i);\\n         \\n\\t\\t return min(mp[2],mp[5]); \\n    }\\n     void fun(int n)\\n    {\\n         for(int i=2;i*i<=n;i++)\\n         {\\n         \\twhile((n%i) == 0)\\n         \\t{\\n         \\t    mp[i]++;\\n\\t\\t\\t\\tn = n / i;\\t\\n\\t\\t\\t}\\n\\t\\t }\\n\\t\\t if(n > 1)\\n\\t\\t mp[n]++;\\n    }\\n};\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\npublic:\n    unordered_map<long long int,long long int>mp;\n    int trailingZeroes(int n) {\n        for(int i=n;i>=1;i--)\n         fun(i);\n         \n\t\t Solution s;\n\t\t return s.min(mp[2],mp[5]); \n    }\n     void fun(int n)\n    {\n         for(int i=2;i*i<=n;i++)\n         {\n         \twhile((n%i) == 0)\n         \t{\n         \t    mp[i]++;\n\t\t\t\tn = n / i;\t\n\t\t\t}\n\t\t }\n\t\t if(n > 1)\n\t\t mp[n]++;\n    }\n};\n",
        "explanations": "\nAn instance of class Solution is created and tries to call min method that doesn't exist.\n"
    },
    {
        "slug": "kth-ancestor-of-a-tree-node",
        "description": "You are given a tree with n nodes numbered from 0 to n - 1 in the form of a parent array parent where parent[i] is the parent of ith node. The root of the tree is node 0. Find the kth ancestor of a given node.\nThe kth ancestor of a tree node is the kth node in the path from that node to the root node.\nImplement the TreeAncestor class:\n\nTreeAncestor(int n, int[] parent) Initializes the object with the number of nodes in the tree and the parent array.\nint getKthAncestor(int node, int k) return the kth ancestor of the given node node. If there is no such ancestor, return -1.",
        "examples": [
            "Input\n[\"TreeAncestor\", \"getKthAncestor\", \"getKthAncestor\", \"getKthAncestor\"]\n[[7, [-1, 0, 0, 1, 1, 2, 2]], [3, 1], [5, 2], [6, 3]]\nOutput\n[null, 1, 0, -1]\n\nExplanation\nTreeAncestor treeAncestor = new TreeAncestor(7, [-1, 0, 0, 1, 1, 2, 2]);\ntreeAncestor.getKthAncestor(3, 1); // returns 1 which is the parent of 3\ntreeAncestor.getKthAncestor(5, 2); // returns 0 which is the grandparent of 5\ntreeAncestor.getKthAncestor(6, 3); // returns -1 because there is no such ancestor"
        ],
        "constraints": "1 <= k <= n <= 5 * 104\nparent.length == n\nparent[0] == -1\n0 <= parent[i] < n for all 0 < i < n\n0 <= node < n\nThere will be at most 5 * 104 queries.",
        "release_time": 1667792667,
        "oracle_code": "class TreeAncestor {\npublic:\n    vector<vector<int>>v;\n    TreeAncestor(int n, vector<int>& parent) {\n        vector<vector<int>> par(n, vector<int>(20));\n        for (int i = 0; i < n; i++) par[i][0] = parent[i];\n        for (int j = 1; j < 20; j++) {\n            for (int i = 0; i < n; i++) {\n                if (par[i][j - 1] == -1) par[i][j] = -1;\n                else par[i][j] = par[par[i][j - 1]][j - 1];\n            }\n        }\n        swap(v, par);\n    }\n    int getKthAncestor(int node, int k) {\n        for (int i = 0; i < 20; i++) {\n            if ((k >> i) & 1) {\n                node = v[node][i];\n                if (node == -1) return -1;\n            }\n        }\n        return node;\n    }\n};\n\n/**\n * Your TreeAncestor object will be instantiated and called as such:\n * TreeAncestor* obj = new TreeAncestor(n, parent);\n * int param_1 = obj->getKthAncestor(node,k);\n */",
        "content": "\\n\\n# Code\\n```\\nclass TreeAncestor {\\npublic:\\n    vector<vector<int>>v;\\n    TreeAncestor(int n, vector<int>& parent) {\\n        vector<vector<int>> par(n, vector<int>(20));\\n        for (int i = 0; i < n; i++) par[i][0] = parent[i];\\n        for (int j = 1; j < 20; j++) {\\n            for (int i = 0; i < n; i++) {\\n                if (par[i][j - 1] == -1) par[i][j] = -1;\\n                else par[i][j] = par[par[i][j - 1]][j - 1];\\n            }\\n        }\\n        swap(v, par);\\n    }\\n    int getKthAncestor(int node, int k) {\\n        for (int i = 0; i < 20; i++) {\\n            if ((k >> i) & 1) {\\n                node = v[node][i];\\n                if (node == -1) return -1;\\n            }\\n        }\\n        return node;\\n    }\\n};\\n\\n/**\\n * Your TreeAncestor object will be instantiated and called as such:\\n * TreeAncestor* obj = new TreeAncestor(n, parent);\\n * int param_1 = obj->getKthAncestor(node,k);\\n */\\n```",
        "level": "hard",
        "buggy_code": "\nclass TreeAncestor {\npublic:\n    vector<vector<int>>v;\n    TreeAncestor(int n, vector<int>& parent) {\n        vector<vector<int>> par(n, vector<int>(20));\n        for (int i = 0; i < n; i++) par[i][0] = parent[i];\n        for (int j = 1; j < 20; j++) {\n            for (int i = 0; i < n; i++) {\n                if (par[i][j - 1] == -1) par[i][j] = -1;\n                else par[i][j] = par[par[i][j - 1]][j - 1];\n            }\n        }\n        int getKthAncestor(int node, int k) {\n            for (int i = 0; i < 20; i++) {\n                if ((k >> i) & 1) {\n                    node = v[node][i];\n                    if (node == -1) return -1;\n                }\n            }\n            return node;\n        }\n    }   \n    swap(v, par);\n};\n",
        "explanations": "\nThe function getKthAncestor was mistakenly placed inside the constructor causing compile errors.\n"
    },
    {
        "slug": "target-sum",
        "description": "You are given an integer array nums and an integer target.\nYou want to build an expression out of nums by adding one of the symbols '+' and '-' before each integer in nums and then concatenate all the integers.\n\nFor example, if nums = [2, 1], you can add a '+' before 2 and a '-' before 1 and concatenate them to build the expression \"+2-1\".\n\nReturn the number of different expressions that you can build, which evaluates to target.",
        "examples": [
            "Input: nums = [1,1,1,1,1], target = 3\nOutput: 5\nExplanation: There are 5 ways to assign symbols to make the sum of nums be target 3.\n-1 + 1 + 1 + 1 + 1 = 3\n+1 - 1 + 1 + 1 + 1 = 3\n+1 + 1 - 1 + 1 + 1 = 3\n+1 + 1 + 1 - 1 + 1 = 3\n+1 + 1 + 1 + 1 - 1 = 3",
            "Input: nums = [1], target = 1\nOutput: 1"
        ],
        "constraints": "1 <= nums.length <= 20\n0 <= nums[i] <= 1000\n0 <= sum(nums[i]) <= 1000\n-1000 <= target <= 1000",
        "release_time": 1689667126,
        "oracle_code": "class Solution {\npublic:\n    int findTargetSumWays(vector<int>& nums, int target) {\n        // idx, target -> no of ways\n        map<pair<int, int>, int> memo;\n        return dp(nums, target, 0, memo); \n    }\n\nprivate:\n    int dp(vector<int>& nums, int target, int idx, map<pair<int, int>, int>& memo) {\n        if (idx == nums.size()) return target == 0;\n        if (memo.count({idx, target})) return memo[{idx, target}];\n\n        int positive = dp(nums, target + nums[idx], idx + 1, memo);\n        int negative = dp(nums, target - nums[idx], idx + 1, memo);\n\n        return memo[{idx, target}] = positive + negative;\n    }\n};",
        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        // idx, target -> no of ways\\n        map<pair<int, int>, int> memo;\\n        return dp(nums, target, 0, memo); \\n    }\\n\\nprivate:\\n    int dp(vector<int>& nums, int target, int idx, map<pair<int, int>, int>& memo) {\\n        if (idx == nums.size()) return target == 0;\\n        if (memo.count({idx, target})) return memo[{idx, target}];\\n\\n        int positive = dp(nums, target + nums[idx], idx + 1, memo);\\n        int negative = dp(nums, target - nums[idx], idx + 1, memo);\\n\\n        return memo[{idx, target}] = positive + negative;\\n    }\\n};\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\npublic:\n    int findTargetSumWays(vector<int>& nums, int target) {\n        // idx, target -> no of ways\n        map<pair<int, int>, int> memo;\n        int objVal;\n        return objVal.dp(nums, target, 0, memo); \n    }\n\nprivate:\n    int dp(vector<int>& nums, int target, int idx, map<pair<int, int>, int>& memo) {\n        if (idx == nums.size()) return target == 0;\n        if (memo.count({idx, target})) return memo[{idx, target}];\n\n        int positive = dp(nums, target + nums[idx], idx + 1, memo);\n        int negative = dp(nums, target - nums[idx], idx + 1, memo);\n\n        return memo[{idx, target}] = positive + negative;\n    }\n};\n",
        "explanations": "\nCalled non-static function on an uninitialized object objVal leading to undefined behavior.\n"
    },
    {
        "slug": "prime-in-diagonal",
        "description": "You are given a 0-indexed two-dimensional integer array nums.\nReturn the largest prime number that lies on at least one of the diagonals of nums. In case, no prime is present on any of the diagonals, return 0.\nNote that:\n\nAn integer is prime if it is greater than 1 and has no positive integer divisors other than 1 and itself.\nAn integer val is on one of the diagonals of nums if there exists an integer i for which nums[i][i] = val or an i for which nums[i][nums.length - i - 1] = val.\n\n\nIn the above diagram, one diagonal is [1,5,9] and another diagonal is [3,5,7].",
        "examples": [
            "Input: nums = [[1,2,3],[5,6,7],[9,10,11]]\nOutput: 11\nExplanation: The numbers 1, 3, 6, 9, and 11 are the only numbers present on at least one of the diagonals. Since 11 is the largest prime, we return 11.",
            "Input: nums = [[1,2,3],[5,17,7],[9,11,10]]\nOutput: 17\nExplanation: The numbers 1, 3, 9, 10, and 17 are all present on at least one of the diagonals. 17 is the largest prime, so we return 17."
        ],
        "constraints": "1 <= nums.length <= 300\nnums.length == numsi.length\n1 <= nums[i][j]\u00a0<= 4*106",
        "release_time": 1683960047,
        "oracle_code": "class Solution {\npublic:\n    bool check(int x){\n        if(x==1)return false;\n        for(int i = 2; i*i<=x; i++){\n            if(x%i==0)return false;\n        }\n        return true;\n    }\n    int diagonalPrime(vector<vector<int>>& nums) {\n        int i,ans=0,n=nums.size();\n        for(i = 0; i < n; i++){\n            if(check(nums[i][i]) && nums[i][i]>ans){\n                ans = nums[i][i];\n            }\n            if(check(nums[i][n-1-i]) && nums[i][n-1-i]>ans){\n                ans = nums[i][n-1-i];\n            }\n        }\n        return ans;\n    }\n};",
        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(int x){\\n        if(x==1)return false;\\n        for(int i = 2; i*i<=x; i++){\\n            if(x%i==0)return false;\\n        }\\n        return true;\\n    }\\n    int diagonalPrime(vector<vector<int>>& nums) {\\n        int i,ans=0,n=nums.size();\\n        for(i = 0; i < n; i++){\\n            if(check(nums[i][i]) && nums[i][i]>ans){\\n                ans = nums[i][i];\\n            }\\n            if(check(nums[i][n-1-i]) && nums[i][n-1-i]>ans){\\n                ans = nums[i][n-1-i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\npublic:\n    bool check(int x){\n        if(x==1)return false;\n        for(int i = 2; i*i<=x; i++){\n            if(x%i==0)return false;\n        }\n        return true;\n    }\n    int diagonalPrime(vector<vector<int>>& nums) {\n        int i,ans=0,n=nums.size();\n        for(i = 0; i < n; i++){\n            if(check(nums[i][i]) && nums[i][i]>ans){\n                ans = nums[i][i];\n            }\n            if(check(nums[i][n-i]) && nums[i][n-i]>ans){\n                ans = nums[i][n-i];\n            }\n        }\n        return ans;\n    }\n};\n",
        "explanations": "\nThe second diagonal ends up with an out-of-bounds error if the matrix is not square.\n"
    },
    {
        "slug": "array-with-elements-not-equal-to-average-of-neighbors",
        "description": "You are given a 0-indexed array nums of distinct integers. You want to rearrange the elements in the array such that every element in the rearranged array is not equal to the average of its neighbors.\nMore formally, the rearranged array should have the property such that for every i in the range 1 <= i < nums.length - 1, (nums[i-1] + nums[i+1]) / 2 is not equal to nums[i].\nReturn any rearrangement of nums that meets the requirements.",
        "examples": [
            "Input: nums = [1,2,3,4,5]\nOutput: [1,2,4,5,3]\nExplanation:\nWhen i=1, nums[i] = 2, and the average of its neighbors is (1+4) / 2 = 2.5.\nWhen i=2, nums[i] = 4, and the average of its neighbors is (2+5) / 2 = 3.5.\nWhen i=3, nums[i] = 5, and the average of its neighbors is (4+3) / 2 = 3.5.",
            "Input: nums = [6,2,0,9,7]\nOutput: [9,7,6,2,0]\nExplanation:\nWhen i=1, nums[i] = 7, and the average of its neighbors is (9+6) / 2 = 7.5.\nWhen i=2, nums[i] = 6, and the average of its neighbors is (7+2) / 2 = 4.5.\nWhen i=3, nums[i] = 2, and the average of its neighbors is (6+0) / 2 = 3."
        ],
        "constraints": "3 <= nums.length <= 105\n0 <= nums[i] <= 105",
        "release_time": 1664849911,
        "oracle_code": "class Solution {\npublic:\n    vector<int> rearrangeArray(vector<int>& nums) {\n        int size=nums.size();\n        for(int i=1;i<size-1;i++){\n            if((nums[i-1]<nums[i] && nums[i]<nums[i+1])||(nums[i-1]>nums[i] && nums[i]>nums[i+1]))   //If the array is strictly increasing or decreasing then swap the vlaue at current index  with value at index+1\n                swap(nums[i],nums[i+1]);\n        }\n        return nums;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int size=nums.size();\\n        for(int i=1;i<size-1;i++){\\n            if((nums[i-1]<nums[i] && nums[i]<nums[i+1])||(nums[i-1]>nums[i] && nums[i]>nums[i+1]))   //If the array is strictly increasing or decreasing then swap the vlaue at current index  with value at index+1\\n                swap(nums[i],nums[i+1]);\\n        }\\n        return nums;\\n    }\\n};\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\npublic:\n    vector<int> rearrangeArray(vector<int>& nums) {\n        int size=nums.size();\n        for(int i=1;i<size-1;i++){\n            if((nums[i-1]<nums[i] && nums[i]<nums[i+1])||(nums[i-1]>nums[i] && nums[i]>nums[i+1]))\n                swap(nums[i],nums[i+2]);\n        }\n        return nums;\n    }\n};\n",
        "explanations": "\nSwapping with non-existent 'nums[i+2]' for 'i' close to 'size-1' causes an undefined behavior.\n"
    },
    {
        "slug": "queries-on-number-of-points-inside-a-circle",
        "description": "You are given an array points where points[i] = [xi, yi] is the coordinates of the ith point on a 2D plane. Multiple points can have the same coordinates.\nYou are also given an array queries where queries[j] = [xj, yj, rj] describes a circle centered at (xj, yj) with a radius of rj.\nFor each query queries[j], compute the number of points inside the jth circle. Points on the border of the circle are considered inside.\nReturn an array answer, where answer[j] is the answer to the jth query.",
        "examples": [
            "Input: points = [[1,3],[3,3],[5,3],[2,2]], queries = [[2,3,1],[4,3,1],[1,1,2]]\nOutput: [3,2,2]\nExplanation: The points and circles are shown above.\nqueries[0] is the green circle, queries[1] is the red circle, and queries[2] is the blue circle.",
            "Input: points = [[1,1],[2,2],[3,3],[4,4],[5,5]], queries = [[1,2,2],[2,2,2],[4,3,2],[4,3,3]]\nOutput: [2,3,2,4]\nExplanation: The points and circles are shown above.\nqueries[0] is green, queries[1] is red, queries[2] is blue, and queries[3] is purple."
        ],
        "constraints": "1 <= points.length <= 500\npoints[i].length == 2\n0 <= x\u200b\u200b\u200b\u200b\u200b\u200bi, y\u200b\u200b\u200b\u200b\u200b\u200bi <= 500\n1 <= queries.length <= 500\nqueries[j].length == 3\n0 <= xj, yj <= 500\n1 <= rj <= 500\nAll coordinates are integers.",
        "release_time": 1670308045,
        "oracle_code": "class Solution {\npublic:\n\n    bool Manhattan(int x1,int x2,int y1,int y2,int r){\n        int dist= pow((x2-x1),2) + pow((y2-y1),2);\n\n        if(dist<=r*r) return true;\n        return false;\n    }\n    vector<int> countPoints(vector<vector<int>>& points, vector<vector<int>>& queries) {\n\n        vector<int> ans;\n\n        for( auto c: queries){\n            int x1=c[0];\n            int y1=c[1];\n            int r=c[2];\n            int temp=0;\n            \n            for(auto i:points){\n                int x2=i[0];\n                int y2=i[1];\n\n                if(Manhattan(x1,x2,y1,y2,r)){\n                    temp++;\n                }\n\n            }\n\n            ans.push_back(temp);\n\n        }\n        return ans;\n\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool Manhattan(int x1,int x2,int y1,int y2,int r){\\n        int dist= pow((x2-x1),2) + pow((y2-y1),2);\\n\\n        if(dist<=r*r) return true;\\n        return false;\\n    }\\n    vector<int> countPoints(vector<vector<int>>& points, vector<vector<int>>& queries) {\\n\\n        vector<int> ans;\\n\\n        for( auto c: queries){\\n            int x1=c[0];\\n            int y1=c[1];\\n            int r=c[2];\\n            int temp=0;\\n            \\n            for(auto i:points){\\n                int x2=i[0];\\n                int y2=i[1];\\n\\n                if(Manhattan(x1,x2,y1,y2,r)){\\n                    temp++;\\n                }\\n\\n            }\\n\\n            ans.push_back(temp);\\n\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\npublic:\n\n    bool Manhattan(int x1,int x2,int y1,int y2,int r){\n        int dist= pow(x2-x1,2) + pow(y2-y1,2);\n\n        if(dist==r*r) return true;\n        return false;\n    }\n    vector<int> countPoints(vector<vector<int>>& points, vector<vector<int>>& queries) {\n        vector<int> ans;\n\n        for( auto c: queries){\n            int x1=c[0];\n            int y1=c[1];\n            int r=c[2];\n            int temp=0;\n            \n            for(auto i: points){\n                if(Manhattan(x1,i[0],y1,i[1],r)){\n                    temp++;\n                }\n\n                ans.push_back(temp);\n            }\n\n        }\n        return ans;\n    }\n};\n",
        "explanations": "\n\"ans.push_back(temp)\" placed inside inner for loop, causing multiple incorrect entries.\n"
    },
    {
        "slug": "maximum-frequency-stack",
        "description": "Design a stack-like data structure to push elements to the stack and pop the most frequent element from the stack.\nImplement the FreqStack class:\n\nFreqStack() constructs an empty frequency stack.\nvoid push(int val) pushes an integer val onto the top of the stack.\nint pop() removes and returns the most frequent element in the stack.\n\t\nIf there is a tie for the most frequent element, the element closest to the stack's top is removed and returned.",
        "examples": [
            "Input\n[\"FreqStack\", \"push\", \"push\", \"push\", \"push\", \"push\", \"push\", \"pop\", \"pop\", \"pop\", \"pop\"]\n[[], [5], [7], [5], [7], [4], [5], [], [], [], []]\nOutput\n[null, null, null, null, null, null, null, 5, 7, 5, 4]\n\nExplanation\nFreqStack freqStack = new FreqStack();\nfreqStack.push(5); // The stack is [5]\nfreqStack.push(7); // The stack is [5,7]\nfreqStack.push(5); // The stack is [5,7,5]\nfreqStack.push(7); // The stack is [5,7,5,7]\nfreqStack.push(4); // The stack is [5,7,5,7,4]\nfreqStack.push(5); // The stack is [5,7,5,7,4,5]\nfreqStack.pop();   // return 5, as 5 is the most frequent. The stack becomes [5,7,5,7,4].\nfreqStack.pop();   // return 7, as 5 and 7 is the most frequent, but 7 is closest to the top. The stack becomes [5,7,5,4].\nfreqStack.pop();   // return 5, as 5 is the most frequent. The stack becomes [5,7,4].\nfreqStack.pop();   // return 4, as 4, 5 and 7 is the most frequent, but 4 is closest to the top. The stack becomes [5,7]."
        ],
        "constraints": "0 <= val <= 109\nAt most 2 * 104 calls will be made to push and pop.\nIt is guaranteed that there will be at least one element in the stack before calling pop.",
        "release_time": 1689270384,
        "oracle_code": "class FreqStack {\npublic:\n    \n    unordered_map<int,int> mp; // It will map x->val ,i.e val for every x\n// bcoz we will not push val into set,so we will get val from mp.\n    unordered_map<int,int> freq; // It will keep freq of the val\n    set<pair<int,int>> s; // {freq,x};\n    int x=0; // x is maintained for second condition i.e \n// if freq tie, then we need to return latest element pushed.\n    FreqStack() {\n        \n    }\n    \n    void push(int val) {\n        freq[val]++; // increase the freq of val.\n        mp[x]=val; // map x->val\n        s.insert({freq[val],x++}); // {freq,x}\n    }\n    \n    int pop() {\n        auto it2=s.rbegin(); // return the iterater to last element in set i.e\n// the one which is our ans with highest freq,if freq ties,\n//then latest pushed,i.e having higher value of x.\n        auto it=*(it2);// it gets the pair from the it2\n        s.erase(it); // remove this pair from set\n        int f=it.first;// freq\n        int cur_x=it.second; // x\n        int val=mp[cur_x]; // val i.e ans\n        freq[val]--; // reduce the freq of val\n        return val;\n    }\n};",
        "content": "# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FreqStack {\\npublic:\\n    \\n    unordered_map<int,int> mp; // It will map x->val ,i.e val for every x\\n// bcoz we will not push val into set,so we will get val from mp.\\n    unordered_map<int,int> freq; // It will keep freq of the val\\n    set<pair<int,int>> s; // {freq,x};\\n    int x=0; // x is maintained for second condition i.e \\n// if freq tie, then we need to return latest element pushed.\\n    FreqStack() {\\n        \\n    }\\n    \\n    void push(int val) {\\n        freq[val]++; // increase the freq of val.\\n        mp[x]=val; // map x->val\\n        s.insert({freq[val],x++}); // {freq,x}\\n    }\\n    \\n    int pop() {\\n        auto it2=s.rbegin(); // return the iterater to last element in set i.e\\n// the one which is our ans with highest freq,if freq ties,\\n//then latest pushed,i.e having higher value of x.\\n        auto it=*(it2);// it gets the pair from the it2\\n        s.erase(it); // remove this pair from set\\n        int f=it.first;// freq\\n        int cur_x=it.second; // x\\n        int val=mp[cur_x]; // val i.e ans\\n        freq[val]--; // reduce the freq of val\\n        return val;\\n    }\\n};\\n\\n\\n```",
        "level": "hard",
        "buggy_code": "\nclass FreqStack {\npublic:\n    \n    unordered_map<int,int> mp; \n    unordered_map<int,int> freq; \n    set<pair<int,int>> s; \n    int x=0; \n\n    FreqStack() {\n        \n    }\n    \n    void push(int val) {\n        freq[val]++;\n        mp[x]=val; \n        s.insert({freq[val],x++}); \n        mp.clear();\n    }\n    \n    int pop() {\n        auto it2=s.rbegin(); \n        auto it=*(it2);\n        s.erase(it); \n        int f=it.first;\n        int cur_x=it.second; \n        int val=mp[cur_x]; \n        freq[val]--;\n        return val;\n    }\n};    \n",
        "explanations": "\nClearing the map 'mp' in push method results in undefined values while popping elements.\n"
    },
    {
        "slug": "shortest-distance-to-target-string-in-a-circular-array",
        "description": "You are given a 0-indexed circular string array words and a string target. A circular array means that the array's end connects to the array's beginning.\n\nFormally, the next element of words[i] is words[(i + 1) % n] and the previous element of words[i] is words[(i - 1 + n) % n], where n is the length of words.\n\nStarting from startIndex, you can move to either the next word or the previous word with 1 step at a time.\nReturn the shortest distance needed to reach the string target. If the string target does not exist in words, return -1.",
        "examples": [
            "Input: words = [\"hello\",\"i\",\"am\",\"leetcode\",\"hello\"], target = \"hello\", startIndex = 1\nOutput: 1\nExplanation: We start from index 1 and can reach \"hello\" by\n- moving 3 units to the right to reach index 4.\n- moving 2 units to the left to reach index 4.\n- moving 4 units to the right to reach index 0.\n- moving 1 unit to the left to reach index 0.\nThe shortest distance to reach \"hello\" is 1.",
            "Input: words = [\"a\",\"b\",\"leetcode\"], target = \"leetcode\", startIndex = 0\nOutput: 1\nExplanation: We start from index 0 and can reach \"leetcode\" by\n- moving 2 units to the right to reach index 3.\n- moving 1 unit to the left to reach index 3.\nThe shortest distance to reach \"leetcode\" is 1.",
            "Input: words = [\"i\",\"eat\",\"leetcode\"], target = \"ate\", startIndex = 0\nOutput: -1\nExplanation: Since \"ate\" does not exist in words, we return -1."
        ],
        "constraints": "1 <= words.length <= 100\n1 <= words[i].length <= 100\nwords[i] and target consist of only lowercase English letters.\n0 <= startIndex < words.length",
        "release_time": 1671945764,
        "oracle_code": "class Solution {\npublic:\n    int closetTarget(vector<string>& words, string target, int startIndex) {\n         int ind= find(words.begin(),words.end(),target)-words.begin();\n        int n= words.size();\n        if (ind==n)return -1;\n        if (words[startIndex]==target) return 0;\n        int i= startIndex-1;\n        int j= startIndex+1;\n        int cnt1=0; int cnt2=0;\n        while (true){\n            cnt1++; cnt2++;\n            if ((i>=0 && words[i%n]==target) || words[(n+i)%n]==target){\n                return cnt1;\n            }\n            if ((j<n && words[j%n]==target) || words[(n+j)%n]==target){\n                return cnt2;\n            }\n            i--; j++;\n        }\n        \n        return -1;\n    }\n};",
        "content": "## Code\\n```\\nclass Solution {\\npublic:\\n    int closetTarget(vector<string>& words, string target, int startIndex) {\\n         int ind= find(words.begin(),words.end(),target)-words.begin();\\n        int n= words.size();\\n        if (ind==n)return -1;\\n        if (words[startIndex]==target) return 0;\\n        int i= startIndex-1;\\n        int j= startIndex+1;\\n        int cnt1=0; int cnt2=0;\\n        while (true){\\n            cnt1++; cnt2++;\\n            if ((i>=0 && words[i%n]==target) || words[(n+i)%n]==target){\\n                return cnt1;\\n            }\\n            if ((j<n && words[j%n]==target) || words[(n+j)%n]==target){\\n                return cnt2;\\n            }\\n            i--; j++;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n\\n```\\n### Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n",
        "level": "easy",
        "buggy_code": "\nclass Solution {\npublic:\n    int closetTarget(vector<string>& words, string target, int startIndex) {\n         int ind= find(words.begin(),words.end(),target)-words.begin();\n        int n= words.size();\n        if (ind==n)return -1;\n        if (words[startIndex]==target) return 0;\n        int i= startIndex-1;\n        int j= startIndex+1;\n        int cnt1=0; int cnt2=0;\n        while (true){\n            cnt1++; cnt2++;\n            if ((i>=0 && words[i%n]==target) || words[(n+i)%n]==target){\n                return cnt1;\n            }\n            if ((j<n && words[j%n]==target) || words[(n+j)%n]==target){\n                return cnt2;\n            }\n        }\n        \n        return -1;\n    }\n};\n",
        "explanations": "\nThe j++ in the loop will cause an out-of-range error when j >= words.size().\n"
    },
    {
        "slug": "maximum-number-of-pairs-in-array",
        "description": "You are given a 0-indexed integer array nums. In one operation, you may do the following:\n\nChoose two integers in nums that are equal.\nRemove both integers from nums, forming a pair.\n\nThe operation is done on nums as many times as possible.\nReturn a 0-indexed integer array answer of size 2 where answer[0] is the number of pairs that are formed and answer[1] is the number of leftover integers in nums after doing the operation as many times as possible.",
        "examples": [
            "Input: nums = [1,3,2,1,3,2,2]\nOutput: [3,1]\nExplanation:\nForm a pair with nums[0] and nums[3] and remove them from nums. Now, nums = [3,2,3,2,2].\nForm a pair with nums[0] and nums[2] and remove them from nums. Now, nums = [2,2,2].\nForm a pair with nums[0] and nums[1] and remove them from nums. Now, nums = [2].\nNo more pairs can be formed. A total of 3 pairs have been formed, and there is 1 number leftover in nums.",
            "Input: nums = [1,1]\nOutput: [1,0]\nExplanation: Form a pair with nums[0] and nums[1] and remove them from nums. Now, nums = [].\nNo more pairs can be formed. A total of 1 pair has been formed, and there are 0 numbers leftover in nums.",
            "Input: nums = [0]\nOutput: [0,1]\nExplanation: No pairs can be formed, and there is 1 number leftover in nums."
        ],
        "constraints": "1 <= nums.length <= 100\n0 <= nums[i] <= 100",
        "release_time": 1691523060,
        "oracle_code": "class Solution {\npublic:\n    vector<int> numberOfPairs(vector<int>& nums) {\n        int n = nums.size();\n        vector<int>ans;\n        int cnt = 0;\n        sort(nums.begin(),nums.end());\n        for(int i = 1; i<n; i++){\n            if(nums[i]==nums[i-1]){\n                nums[i]=-1;\n                nums[i-1] = -1;\n                cnt++;\n            }\n        }\n        ans.push_back(cnt);\n        ans.push_back(n-2*cnt);\n\n        return ans;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> numberOfPairs(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int>ans;\\n        int cnt = 0;\\n        sort(nums.begin(),nums.end());\\n        for(int i = 1; i<n; i++){\\n            if(nums[i]==nums[i-1]){\\n                nums[i]=-1;\\n                nums[i-1] = -1;\\n                cnt++;\\n            }\\n        }\\n        ans.push_back(cnt);\\n        ans.push_back(n-2*cnt);\\n\\n        return ans;\\n    }\\n};\\n\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\npublic:\n    vector<int> numberOfPairs(vector<int>& nums) {\n        int n = nums.size();\n        vector<int>ans;\n        int cnt = 0;\n        sort(nums.begin(),nums.end());\n        for(int i = 1; i<n; i++){\n            if(nums[i]==nums[i-1]){\n                nums[i]=-1;\n                nums[-1] = -1;\n                cnt++;\n            }\n        }\n        ans.push_back(cnt);\n        ans.push_back(n-2*cnt);\n\n        return ans;\n    }\n};\n",
        "explanations": "\nI have accessed the element with the index -1, which is not defined.\n"
    },
    {
        "slug": "check-knight-tour-configuration",
        "description": "There is a knight on an n x n chessboard. In a valid configuration, the knight starts at the top-left cell of the board and visits every cell on the board exactly once.\nYou are given an n x n integer matrix grid consisting of distinct integers from the range [0, n * n - 1] where grid[row][col] indicates that the cell (row, col) is the grid[row][col]th cell that the knight visited. The moves are 0-indexed.\nReturn true if grid represents a valid configuration of the knight's movements or false otherwise.\nNote that a valid knight move consists of moving two squares vertically and one square horizontally, or two squares horizontally and one square vertically. The figure below illustrates all the possible eight moves of a knight from some cell.",
        "examples": [
            "Input: grid = [[0,11,16,5,20],[17,4,19,10,15],[12,1,8,21,6],[3,18,23,14,9],[24,13,2,7,22]]\nOutput: true\nExplanation: The above diagram represents the grid. It can be shown that it is a valid configuration.",
            "Input: grid = [[0,3,6],[5,8,1],[2,7,4]]\nOutput: false\nExplanation: The above diagram represents the grid. The 8th move of the knight is not valid considering its position after the 7th move."
        ],
        "constraints": "n == grid.length == grid[i].length\n3 <= n <= 7\n0 <= grid[row][col] < n * n\nAll integers in grid are unique.",
        "release_time": 1685738927,
        "oracle_code": "class Solution {\nprivate:\n    bool helper(vector<vector<int>>& grid, int row, int col, int num){\n        int n = grid.size();\n        if(num == n*n) return true;\n        int i = row-2;\n        int j = col+1;\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row-2;\n        j = col-1;\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 2;\n        j = col - 1;\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 2;\n        j = col + 1;\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 1;\n        j = col + 2;\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row - 1;\n        j = col + 2;\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row - 1;\n        j = col - 2;\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 1;\n        j = col - 2;\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        return false;\n    }\npublic:\n    bool checkValidGrid(vector<vector<int>>& grid) {\n        ios::sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);\n        if(grid[0][0] != 0) return false;\n        return helper(grid,0,0,1);\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    bool helper(vector<vector<int>>& grid, int row, int col, int num){\\n        int n = grid.size();\\n        if(num == n*n) return true;\\n        int i = row-2;\\n        int j = col+1;\\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row-2;\\n        j = col-1;\\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row + 2;\\n        j = col - 1;\\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row + 2;\\n        j = col + 1;\\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row + 1;\\n        j = col + 2;\\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row - 1;\\n        j = col + 2;\\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row - 1;\\n        j = col - 2;\\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row + 1;\\n        j = col - 2;\\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        return false;\\n    }\\npublic:\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(0);\\n        cout.tie(0);\\n        if(grid[0][0] != 0) return false;\\n        return helper(grid,0,0,1);\\n    }\\n};\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\nprivate:\n    bool helper(vector<vector<int>>& grid, int row, int col, int num){\n        int n = grid.size();\n\n        undefinedObject test;  \n\n        if(num == n*n) return true;\n        int i = row-2;\n        int j = col+1;\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row-2;\n        j = col-1;\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 2;\n        j = col - 1;\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 2;\n        j = col + 1;\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 1;\n        j = col + 2;\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row - 1;\n        j = col + 2;\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row - 1;\n        j = col - 2;\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 1;\n        j = col - 2;\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        return false;\n    }\npublic:\n    bool checkValidGrid(vector<vector<int>>& grid) {\n        ios::sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);\n        if(grid[0][0] != 0) return false;\n        return helper(grid,0,0,1);\n    }\n};\n",
        "explanations": "\nThe variable \"undefinedObject\" is not declared, causing a compile error.\n"
    },
    {
        "slug": "longest-ideal-subsequence",
        "description": "You are given a string s consisting of lowercase letters and an integer k. We call a string t ideal if the following conditions are satisfied:\n\nt is a subsequence of the string s.\nThe absolute difference in the alphabet order of every two adjacent letters in t is less than or equal to k.\n\nReturn the length of the longest ideal string.\nA subsequence is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.\nNote that the alphabet order is not cyclic. For example, the absolute difference in the alphabet order of 'a' and 'z' is 25, not 1.",
        "examples": [
            "Input: s = \"acfgbd\", k = 2\nOutput: 4\nExplanation: The longest ideal string is \"acbd\". The length of this string is 4, so 4 is returned.\nNote that \"acfgbd\" is not ideal because 'c' and 'f' have a difference of 3 in alphabet order.",
            "Input: s = \"abcd\", k = 3\nOutput: 4\nExplanation: The longest ideal string is \"abcd\". The length of this string is 4, so 4 is returned."
        ],
        "constraints": "1 <= s.length <= 105\n0 <= k <= 25\ns consists of lowercase English letters.",
        "release_time": 1665172616,
        "oracle_code": "class Solution {\n\n\n   int SolveByMemo(string &s , int &k , int index , int prev , vector<vector<int>> &dp)\n   {\n       if(index == s.length())\n       return 0;\n\n       if(dp[index][prev] != -1)\n       return dp[index][prev];\n\n       int op1 = 0 + SolveByMemo(s, k , index+1 , prev , dp);\n\n       int op2 = 0 ;\n\n       if(prev == 26)\n       op2 = 1 + SolveByMemo(s, k , index+1 , s[index]-'a' , dp);\n       else if(abs(s[index]-'a' - prev) <= k)\n       op2 = 1 + SolveByMemo(s, k , index+1 , s[index]-'a' , dp);\n\n       return dp[index][prev] = max(op1 , op2);\n   }\n\n   int SolveByTab(string &s , int &k )\n   {\n        vector<vector<int>> dp(s.length()+1 , vector<int> (27, 0));\n       \n        for(int index = s.length()-1 ; index>=0 ; index--)\n        {\n            for(int prev = 0 ; prev<= 26 ; prev++)\n            {\n                int op1 = 0 + dp[index+1][prev];\n                int op2 = 0 ;\n\n               if(prev == 26)\n               op2 = 1 + dp[index+1][s[index]-'a'];\n               else if(abs(s[index]-'a' - prev) <= k)\n               op2 = 1 + dp[index+1][s[index]-'a'];\n\n               dp[index][prev] = max(op1 , op2);\n            }\n        }\n\n       return max(dp[0][s[0]-'a'] , dp[0][26]);\n   }\n\n   int SolveByTabSpaceOptimised(string &s , int &k )\n   {\n        vector<int> next(27, 0) ;\n        vector<int> curr(27, 0);\n       \n        for(int index = s.length()-1 ; index>=0 ; index--)\n        {\n            for(int prev = 0 ; prev<= 26 ; prev++)\n            {\n                int op1 = 0 + next[prev];\n                int op2 = 0 ;\n\n               if(prev == 26)\n               op2 = 1 + next[s[index]-'a'];\n               else if(abs(s[index]-'a' - prev) <= k)\n               op2 = 1 + next[s[index]-'a'];\n\n               curr[prev] = max(op1 , op2);\n            }\n            next = curr;\n        }\n\n       return max(curr[s[0]-'a'] , curr[26]);\n   }\n\npublic:\n    int longestIdealString(string s, int k) {\n        \n        // 1. Recursion + Memoization || Top Down Approach\n        // vector<vector<int>> dp(s.length() , vector<int> (27, -1));\n        // return SolveByMemo(s, k , 0 , 26, dp);\n\n        // 2. Tabulation Method || Bottom Up Approach\n        // return SolveByTab(s, k);\n\n        // 3. Space Optimisation using Tabulation\n        return SolveByTabSpaceOptimised(s , k);\n    }\n};",
        "content": "\\n# Approach\\nWe Have Use Three Different Approaches :\\n1. Recursion + Memoization \\n    TC : O(n^2) , SC : O(n)\\n2. Tabulation Method \\n    TC : O(n^2) , SC : O(n)\\n3.  Tabulatuon With SOace Optimised\\n    TC : O(n^2) , SC : O(1) \\n\\n\\n#Note\\nSC In first two methods is On) and not O(n^2) as size is fixed to 27 for each index hence it is Linear Space ,Similarly for 3rd Method we have optimised to constant space as at any instant we onlt need memory of next 27 blocks  only.\\n\\n#Hope You Liekd It and Upvote are appreciated \\n\\n# Code\\n```\\nclass Solution {\\n\\n\\n   int SolveByMemo(string &s , int &k , int index , int prev , vector<vector<int>> &dp)\\n   {\\n       if(index == s.length())\\n       return 0;\\n\\n       if(dp[index][prev] != -1)\\n       return dp[index][prev];\\n\\n       int op1 = 0 + SolveByMemo(s, k , index+1 , prev , dp);\\n\\n       int op2 = 0 ;\\n\\n       if(prev == 26)\\n       op2 = 1 + SolveByMemo(s, k , index+1 , s[index]-\\'a\\' , dp);\\n       else if(abs(s[index]-\\'a\\' - prev) <= k)\\n       op2 = 1 + SolveByMemo(s, k , index+1 , s[index]-\\'a\\' , dp);\\n\\n       return dp[index][prev] = max(op1 , op2);\\n   }\\n\\n   int SolveByTab(string &s , int &k )\\n   {\\n        vector<vector<int>> dp(s.length()+1 , vector<int> (27, 0));\\n       \\n        for(int index = s.length()-1 ; index>=0 ; index--)\\n        {\\n            for(int prev = 0 ; prev<= 26 ; prev++)\\n            {\\n                int op1 = 0 + dp[index+1][prev];\\n                int op2 = 0 ;\\n\\n               if(prev == 26)\\n               op2 = 1 + dp[index+1][s[index]-\\'a\\'];\\n               else if(abs(s[index]-\\'a\\' - prev) <= k)\\n               op2 = 1 + dp[index+1][s[index]-\\'a\\'];\\n\\n               dp[index][prev] = max(op1 , op2);\\n            }\\n        }\\n\\n       return max(dp[0][s[0]-\\'a\\'] , dp[0][26]);\\n   }\\n\\n   int SolveByTabSpaceOptimised(string &s , int &k )\\n   {\\n        vector<int> next(27, 0) ;\\n        vector<int> curr(27, 0);\\n       \\n        for(int index = s.length()-1 ; index>=0 ; index--)\\n        {\\n            for(int prev = 0 ; prev<= 26 ; prev++)\\n            {\\n                int op1 = 0 + next[prev];\\n                int op2 = 0 ;\\n\\n               if(prev == 26)\\n               op2 = 1 + next[s[index]-\\'a\\'];\\n               else if(abs(s[index]-\\'a\\' - prev) <= k)\\n               op2 = 1 + next[s[index]-\\'a\\'];\\n\\n               curr[prev] = max(op1 , op2);\\n            }\\n            next = curr;\\n        }\\n\\n       return max(curr[s[0]-\\'a\\'] , curr[26]);\\n   }\\n\\npublic:\\n    int longestIdealString(string s, int k) {\\n        \\n        // 1. Recursion + Memoization || Top Down Approach\\n        // vector<vector<int>> dp(s.length() , vector<int> (27, -1));\\n        // return SolveByMemo(s, k , 0 , 26, dp);\\n\\n        // 2. Tabulation Method || Bottom Up Approach\\n        // return SolveByTab(s, k);\\n\\n        // 3. Space Optimisation using Tabulation\\n        return SolveByTabSpaceOptimised(s , k);\\n    }\\n};\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\n\n\n   int SolveByMemo(string &s , int &k , int index , int prev , vector<vector<int>> &dp)\n   {\n       if(index == s.length())\n       return 0;\n\n       if(dp[index][prev] != -1)\n       return dp[index][prev];\n\n       int op1 = 0 + SolveByMemo(s, k , index+1 , prev , dp);\n\n       int op2 = 0 ;\n\n       if(prev == 26)\n       op2 = 1 + SolveByMemo(s, string() , index+1 , s[index]-'a' , dp);\n       else if(abs(s[index]-'a' - prev) <= k)\n       op2 = 1 + SolveByMemo(s, k , index+1 , s[index]-'a' , dp);\n\n       return dp[index][prev] = max(op1 , op2);\n   }\n...\n\n",
        "explanations": "\nThe bug is passing an nonexistent/undefined string object to the SolveByMemo function.\n"
    },
    {
        "slug": "find-all-numbers-disappeared-in-an-array",
        "description": "Given an array nums of n integers where nums[i] is in the range [1, n], return an array of all the integers in the range [1, n] that do not appear in nums.",
        "examples": [
            "Input: nums = [4,3,2,7,8,2,3,1]\nOutput: [5,6]",
            "Input: nums = [1,1]\nOutput: [2]"
        ],
        "constraints": "n == nums.length\n1 <= n <= 105\n1 <= nums[i] <= n",
        "release_time": 1687767620,
        "oracle_code": "class Solution {\npublic:\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\n        int n = nums.size();\n        int i = 0;\n        while (i<n) {\n            if (nums[i] != nums[nums[i]-1] && i != nums[i]-1)\n                swap(nums[i], nums[nums[i]-1]);\n            else i++;\n        }\n        \n        vector<int> res;\n        for (int i=0; i<n; i++) {\n            if (nums[i] != i+1) res.push_back(i+1);\n        }\n\n        return res;\n    }\n};",
        "content": "**Swap Sort** can be used in various problems where we have to find the **missing or duplicates values** in array and the array must contain **values in range [1..n]**.\\n```\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        int n = nums.size();\\n        int i = 0;\\n        while (i<n) {\\n            if (nums[i] != nums[nums[i]-1] && i != nums[i]-1)\\n                swap(nums[i], nums[nums[i]-1]);\\n            else i++;\\n        }\\n        \\n        vector<int> res;\\n        for (int i=0; i<n; i++) {\\n            if (nums[i] != i+1) res.push_back(i+1);\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\npublic:\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\n        int n = nums.size();\n        int i = 0;\n        while (i<n) {\n            if (nums[i] != nums[nums[i]-1] && i != nums[i]-1)\n                swap(nums[i], nums[nums[i]-1]);\n            else i++;\n        }\n        \n        vector<int> res;\n        for (int i=0; i<n; i++) {\n            if (nums[i] != i+1) res.push_back(i+1);\n        }\n\n        vector<int> undefinedVector;\n        res = undefinedVector;\n\n        return res;\n    }\n};\n",
        "explanations": "\nThe returned vector is overridden by an undefined vector leading to incorrect results.\n"
    },
    {
        "slug": "longest-well-performing-interval",
        "description": "We are given hours, a list of the number of hours worked per day for a given employee.\nA day is considered to be a tiring day if and only if the number of hours worked is (strictly) greater than 8.\nA well-performing interval is an interval of days for which the number of tiring days is strictly larger than the number of non-tiring days.\nReturn the length of the longest well-performing interval.",
        "examples": [
            "Input: hours = [9,9,6,0,6,6,9]\nOutput: 3\nExplanation: The longest well-performing interval is [9,9,6].",
            "Input: hours = [6,6,6]\nOutput: 0"
        ],
        "constraints": "1 <= hours.length <= 104\n0 <= hours[i] <= 16",
        "release_time": 1688530675,
        "oracle_code": "class Solution {\npublic:\n    int longestWPI(vector<int>& hours) {\n    map<int,int> mp;\n    int k=0,ans=0;\n    for(int i=0;i<hours.size();i++)\n    {\n        if(hours[i]>8)  k++; else   k--;\n        if(k>0)\n        {\n        ans=max(ans,i+1);\n        } else{\n            if(mp.find(k-1)!=mp.end()){\n                ans=max(ans,i-mp[k-1]);\n            }\n             if(mp.find(k)==mp.end()){\n                mp[k]=i;\n            }\n        }\n       \n    }    \n    return ans;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestWPI(vector<int>& hours) {\\n    map<int,int> mp;\\n    int k=0,ans=0;\\n    for(int i=0;i<hours.size();i++)\\n    {\\n        if(hours[i]>8)  k++; else   k--;\\n        if(k>0)\\n        {\\n        ans=max(ans,i+1);\\n        } else{\\n            if(mp.find(k-1)!=mp.end()){\\n                ans=max(ans,i-mp[k-1]);\\n            }\\n             if(mp.find(k)==mp.end()){\\n                mp[k]=i;\\n            }\\n        }\\n       \\n    }    \\n    return ans;\\n    }\\n};\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\npublic:\n    int longestWPI(vector<int>& hours) {\n    map<int,int> mp;\n    int k=0,ans=0;\n    for(int i=0;i<hours.size();i++)\n    {\n        if(hours[i]>8)  k++; else   k--;\n        if(k>0)\n        {\n        ans=max(ans,i+1);\n        } else{\n            if(mp.find(k-1)!=mp.end()){\n                ans=max(ans,i-mp[k-1]);\n            }\n            if(mp.find(k)==mp.end()){\n                mp[k+1]=i;\n            }\n        }\n\n    }    \n    return ans;\n    }\n};\n",
        "explanations": "\nThe map assignment, mp[k+1]=i, should be mp[k]=i; the current version will cause unexpected mapping.\n"
    },
    {
        "slug": "find-peak-element",
        "description": "A peak element is an element that is strictly greater than its neighbors.\nGiven a 0-indexed integer array nums, find a peak element, and return its index. If the array contains multiple peaks, return the index to any of the peaks.\nYou may imagine that nums[-1] = nums[n] = -\u221e. In other words, an element is always considered to be strictly greater than a neighbor that is outside the array.\nYou must write an algorithm that runs in O(log n) time.",
        "examples": [
            "Input: nums = [1,2,3,1]\nOutput: 2\nExplanation: 3 is a peak element and your function should return the index number 2.",
            "Input: nums = [1,2,1,3,5,6,4]\nOutput: 5\nExplanation: Your function can return either index number 1 where the peak element is 2, or index number 5 where the peak element is 6."
        ],
        "constraints": "1 <= nums.length <= 1000\n-231 <= nums[i] <= 231 - 1\nnums[i] != nums[i + 1] for all valid i.",
        "release_time": 1692100702,
        "oracle_code": "class Solution {\npublic:\n    int findPeakElement(vector<int>& nums) {\n    int n=nums.size();\n    if(n==1)\n    {\n      return 0;\n    } \n    if(nums[0]>nums[1])\n    {\n      return 0;\n    }\n    if(nums[n-1]>nums[n-2])\n    {\n      return n-1;\n    }\n    int left=1;\n    int right=n-2;\n    while(left<=right)\n    {\n      int mid=(left+right)/2;\n      if(nums[mid]>nums[mid-1]&& nums[mid]>nums[mid+1])\n      {\n        return mid;\n      }\n      else if(nums[mid]>nums[mid-1])\n      {\n        left=mid+1;\n      }\n      else{\n        right=mid-1;\n      }\n    }\nreturn -1;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n    int n=nums.size();\\n    if(n==1)\\n    {\\n      return 0;\\n    } \\n    if(nums[0]>nums[1])\\n    {\\n      return 0;\\n    }\\n    if(nums[n-1]>nums[n-2])\\n    {\\n      return n-1;\\n    }\\n    int left=1;\\n    int right=n-2;\\n    while(left<=right)\\n    {\\n      int mid=(left+right)/2;\\n      if(nums[mid]>nums[mid-1]&& nums[mid]>nums[mid+1])\\n      {\\n        return mid;\\n      }\\n      else if(nums[mid]>nums[mid-1])\\n      {\\n        left=mid+1;\\n      }\\n      else{\\n        right=mid-1;\\n      }\\n    }\\nreturn -1;\\n    }\\n};\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\npublic:\n    int findPeakElement(vector<int>& nums) {\n    int n=nums.size();\n    if(n==1)\n    {\n      return 0;\n    } \n    if(nums[0]>nums[1])\n    {\n      return 0;\n    }\n    vector<int> emptyVector; \n    if(emptyVector[n-1]>emptyVector[n-2])\n    {\n      return n-1;\n    }\n    int left=1;\n    int right=n-2;\n    while(left<=right)\n    {\n      int mid=(left+right)/2;\n      if(nums[mid]>nums[mid-1]&& nums[mid]>nums[mid+1])\n      {\n        return mid;\n      }\n      else if(nums[mid]>nums[mid-1])\n      {\n        left=mid+1;\n      }\n      else{\n        right=mid-1;\n      }\n    }\nreturn -1;\n    }\n};\n",
        "explanations": "\nThe bug is accessing elements from an empty vector, causing out of range exception.\n"
    },
    {
        "slug": "longest-alternating-subarray",
        "description": "You are given a 0-indexed integer array nums. A subarray s of length m is called alternating if:\n\nm is greater than 1.\ns1 = s0 + 1.\nThe 0-indexed subarray s looks like [s0, s1, s0, s1,...,s(m-1) % 2]. In other words, s1 - s0 = 1, s2 - s1 = -1, s3 - s2 = 1, s4 - s3 = -1, and so on up to s[m - 1] - s[m - 2] = (-1)m.\n\nReturn the maximum length of all alternating subarrays present in nums or -1 if no such subarray exists.\nA subarray is a contiguous non-empty sequence of elements within an array.",
        "examples": [
            "Input: nums = [2,3,4,3,4]\nOutput: 4\nExplanation: The alternating subarrays are [3,4], [3,4,3], and [3,4,3,4]. The longest of these is [3,4,3,4], which is of length 4.",
            "Input: nums = [4,5,6]\nOutput: 2\nExplanation: [4,5] and [5,6] are the only two alternating subarrays. They are both of length 2."
        ],
        "constraints": "2 <= nums.length <= 100\n1 <= nums[i] <= 104",
        "release_time": 1688832407,
        "oracle_code": "class Solution {\npublic:\n    int alternatingSubarray(vector<int>& v) {\n        int ans = 0;\n        for(int i = 0; i < v.size() - 1; i += 1) {\n            bool flag = true;\n            int cnt = 1;\n            for(int j = i + 1; j < v.size(); j += 1) {\n                if(v[j] - v[j - 1] != (flag ? 1 : -1)) break;\n                flag = !flag;\n                cnt += 1;\n            }\n            ans = max(ans, cnt);\n        }\n        return ans <= 1 ? -1 : ans;\n    }\n};",
        "content": "```\\nclass Solution {\\npublic:\\n    int alternatingSubarray(vector<int>& v) {\\n        int ans = 0;\\n        for(int i = 0; i < v.size() - 1; i += 1) {\\n            bool flag = true;\\n            int cnt = 1;\\n            for(int j = i + 1; j < v.size(); j += 1) {\\n                if(v[j] - v[j - 1] != (flag ? 1 : -1)) break;\\n                flag = !flag;\\n                cnt += 1;\\n            }\\n            ans = max(ans, cnt);\\n        }\\n        return ans <= 1 ? -1 : ans;\\n    }\\n};\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\npublic:\n    int alternatingSubarray(vector<int>& v) {\n        int ans = 0;\n        int cnt = 1;\n        for(int i = 0; i < v.size() - 1; i += 1) {\n            bool flag = true;\n            for(int j = i + 1; j < v.size(); j += 1) {\n                if(v[j] - v[j - 1] != (flag ? 1 : -1)) break;\n                flag = !flag;\n                cnt += 1;\n            }\n            ans = max(ans, cnt);\n        }\n        return ans <= 1 ? -1 : ans;\n    }\n};\n",
        "explanations": "\nThe counter 'cnt' should be initialized inside the first loop, not outside.\n"
    },
    {
        "slug": "is-graph-bipartite",
        "description": "There is an undirected graph with n nodes, where each node is numbered between 0 and n - 1. You are given a 2D array graph, where graph[u] is an array of nodes that node u is adjacent to. More formally, for each v in graph[u], there is an undirected edge between node u and node v. The graph has the following properties:\n\nThere are no self-edges (graph[u] does not contain u).\nThere are no parallel edges (graph[u] does not contain duplicate values).\nIf v is in graph[u], then u is in graph[v] (the graph is undirected).\nThe graph may not be connected, meaning there may be two nodes u and v such that there is no path between them.\n\nA graph is bipartite if the nodes can be partitioned into two independent sets A and B such that every edge in the graph connects a node in set A and a node in set B.\nReturn true if and only if it is bipartite.",
        "examples": [
            "Input: graph = [[1,2,3],[0,2],[0,1,3],[0,2]]\nOutput: false\nExplanation: There is no way to partition the nodes into two independent sets such that every edge connects a node in one and a node in the other.",
            "Input: graph = [[1,3],[0,2],[1,3],[0,2]]\nOutput: true\nExplanation: We can partition the nodes into two sets: {0, 2} and {1, 3}."
        ],
        "constraints": "graph.length == n\n1 <= n <= 100\n0 <= graph[u].length < n\n0 <= graph[u][i] <= n - 1\ngraph[u]\u00a0does not contain\u00a0u.\nAll the values of graph[u] are unique.\nIf graph[u] contains v, then graph[v] contains u.",
        "release_time": 1684525813,
        "oracle_code": "class Solution {\npublic:\n    //graph coloring\n\n    //flag variable, to be turned on when an error of two neighbouring nodes having same colour is detected\n    bool flag = false;\n\n    //dfs traversal\n    void dfs(int ind, vector<vector<int>>& graph, vector<int>& color, int currcolor)\n    {\n\n        //color the current node\n        color[ind]=currcolor;\n\n\n        for(auto it: graph[ind])\n        {\n\n            //if a neighbour node is not coloured yet then color it with opposite color \n            if(color[it] == 0) dfs(it, graph, color, currcolor*(-1));\n\n            //if a neighbour node is already coloured then it should have opposite colour what current node is having right now\n            //else if a neighbour have same colour then making this graph a bipartite is not possible\n            else if(color[it] == currcolor)\n            {\n                flag=true;\n                return;\n            }\n        }\n    }\n    bool isBipartite(vector<vector<int>>& graph) {\n        \n        //no of nodes in graph\n        int n = graph.size();\n        \n        //coloring array\n        vector<int> color(n, 0);\n\n        for(int i=0; i<graph.size(); i++)\n        {\n            //if a uncolored node in encountered then color it and it's corresponding uncoloured neighbouring node\n            if(color[i]==0) dfs(i, graph, color, 1);\n\n            //if flag got turned on then making this graph bipartite is not possible\n            if(flag) return false;\n        }\n\n        return true;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor making a graph bipartite any two of it\\'s adjacent node should come under two different sections.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Denoting two different section as two different colors (here, 1 & -1).\\n- Implementing dfs and start coloring the graph.\\n- Coloring every adjacent node of current node with opposite color of current node.\\n- If two adjacent nodes are encountered with same colour then return false, because in this case making this graph bipartite is not possible.\\n- If whole graph is coloured, then this graph can be bipartite, so return true.\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    //graph coloring\\n\\n    //flag variable, to be turned on when an error of two neighbouring nodes having same colour is detected\\n    bool flag = false;\\n\\n    //dfs traversal\\n    void dfs(int ind, vector<vector<int>>& graph, vector<int>& color, int currcolor)\\n    {\\n\\n        //color the current node\\n        color[ind]=currcolor;\\n\\n\\n        for(auto it: graph[ind])\\n        {\\n\\n            //if a neighbour node is not coloured yet then color it with opposite color \\n            if(color[it] == 0) dfs(it, graph, color, currcolor*(-1));\\n\\n            //if a neighbour node is already coloured then it should have opposite colour what current node is having right now\\n            //else if a neighbour have same colour then making this graph a bipartite is not possible\\n            else if(color[it] == currcolor)\\n            {\\n                flag=true;\\n                return;\\n            }\\n        }\\n    }\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        \\n        //no of nodes in graph\\n        int n = graph.size();\\n        \\n        //coloring array\\n        vector<int> color(n, 0);\\n\\n        for(int i=0; i<graph.size(); i++)\\n        {\\n            //if a uncolored node in encountered then color it and it\\'s corresponding uncoloured neighbouring node\\n            if(color[i]==0) dfs(i, graph, color, 1);\\n\\n            //if flag got turned on then making this graph bipartite is not possible\\n            if(flag) return false;\\n        }\\n\\n        return true;\\n    }\\n};\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\npublic:\n    bool flag = false;\n\n    vector<int> color;\n\n    void dfs(int ind, vector<vector<int>>& graph, int currcolor)\n    {\n        color[ind]=currcolor;\n\n        for(auto it: graph[ind])\n        {\n            if(color[it] == 0) dfs(it, graph, currcolor*(-1));\n            else if(color[it] == currcolor)\n            {\n                flag=true;\n                return;\n            }\n        }\n    }\n    bool isBipartite(vector<vector<int>>& graph) {\n        \n        int n = graph.size();\n\n        for(int i=0; i<graph.size(); i++)\n        {\n            if(color[i]==0) dfs(i, graph, 1);\n            if(flag) return false;\n        }\n        return true;\n    }\n};\n",
        "explanations": "\nThe color vector is not initialized and resized, leading to accessing undefined objects.\n"
    },
    {
        "slug": "calculate-money-in-leetcode-bank",
        "description": "Hercy wants to save money for his first car. He puts money in the Leetcode\u00a0bank every day.\nHe starts by putting in $1 on Monday, the first day. Every day from Tuesday to Sunday, he will put in $1 more than the day before. On every subsequent Monday, he will put in $1 more than the previous Monday. \nGiven n, return the total amount of money he will have in the Leetcode bank at the end of the nth day.",
        "examples": [
            "Input: n = 4\nOutput: 10\nExplanation:\u00a0After the 4th day, the total is 1 + 2 + 3 + 4 = 10.",
            "Input: n = 10\nOutput: 37\nExplanation:\u00a0After the 10th day, the total is (1 + 2 + 3 + 4 + 5 + 6 + 7) + (2 + 3 + 4) = 37. Notice that on the 2nd Monday, Hercy only puts in $2.",
            "Input: n = 20\nOutput: 96\nExplanation:\u00a0After the 20th day, the total is (1 + 2 + 3 + 4 + 5 + 6 + 7) + (2 + 3 + 4 + 5 + 6 + 7 + 8) + (3 + 4 + 5 + 6 + 7 + 8) = 96."
        ],
        "constraints": "1 <= n <= 1000",
        "release_time": 1677320292,
        "oracle_code": "class Solution {\npublic:\n    int Rem(int a)\n    {\n        return (a * (a+1) )/2;\n    }\n    int totalMoney(int n) {\n        int ans = 0,dif=28;\n        int a = 0;\n\n        a = n/7;\n        \n        for(int i=0;i<a;i++)\n        {\n            ans+=dif;\n            dif+=7;\n        }\n\n        int b = n%7;\n        int ad = Rem(b);\n        ad+= a*b;\n\n        ans+=ad;\n\n\n        return ans;\n    }\n};",
        "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBasically This Question Try to Test Pattern Finding Skill.\\nThis Problem has 2 things two Consider.\\n1) Firstly We Divide n by 7 ( as Week is of  Days ) So that We get Value Which Indicates that Total Number of Weeks need to Consider in Final Answer.\\n\\n2) Now We Do n%7 which gives answer between 0 to 6 which indicates Remaining Days after Step 1. So We need To calculate Sum of Savings for That n%7 days Separately.\\n\\nAs Sum of\\n \\nWeek 1 : 28\\nWeek 2 : 35\\nWeek 3 : 42\\nWeek 4 : 49\\nWeek 5 : 56\\nand so on...\\n Indicates Pattern that We only need How many Whole Week Need to Consider in answer and that We got in Step 1.\\nSo add 28+35+.. upto n/7 terms\\n\\n\\nNow , In Step 2 , We need to consider Saving For Remainig Days which is n%7.\\nSuppose Rem Day is B then B*(B+1)/2 Will be Saving at B day of Week 1.We know that we have n/7 week so n/7*b will be added to B*(B+1)/2\\n.This is Final answer of Step 2.\\n\\n3) Add Both answer of Step 1 and Step 2.\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int Rem(int a)\\n    {\\n        return (a * (a+1) )/2;\\n    }\\n    int totalMoney(int n) {\\n        int ans = 0,dif=28;\\n        int a = 0;\\n\\n        a = n/7;\\n        \\n        for(int i=0;i<a;i++)\\n        {\\n            ans+=dif;\\n            dif+=7;\\n        }\\n\\n        int b = n%7;\\n        int ad = Rem(b);\\n        ad+= a*b;\\n\\n        ans+=ad;\\n\\n\\n        return ans;\\n    }\\n};\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\nprivate:\n    int* num;\n\npublic:\n\n    Solution() {\n        num = new int[10];\n    }\n    \n    ~Solution() {\n        delete[] num;\n    }\n\n    int Rem(int a)\n    {\n        return (num[a] * (a+1) )/2;\n    }\n    int totalMoney(int n) {\n        int ans = 0,dif=28;\n        int a = 0;\n        \n        num[5] = n/7;\n\n        for(int i=0;i<num[5];i++)\n        {\n            ans+=dif;\n            dif+=7;\n        }\n\n        int b = n%7;\n        int ad = Rem(b);\n        ad+= num[5]*b;\n\n        ans+=ad;\n\n        return ans;\n    }\n};\n",
        "explanations": "\nAn array is accessed beyond its limit in the Rem method, causing undefined behavior.\n"
    },
    {
        "slug": "tallest-billboard",
        "description": "You are installing a billboard and want it to have the largest height. The billboard will have two steel supports, one on each side. Each steel support must be an equal height.\nYou are given a collection of rods that can be welded together. For example, if you have rods of lengths 1, 2, and 3, you can weld them together to make a support of length 6.\nReturn the largest possible height of your billboard installation. If you cannot support the billboard, return 0.",
        "examples": [
            "Input: rods = [1,2,3,6]\nOutput: 6\nExplanation: We have two disjoint subsets {1,2,3} and {6}, which have the same sum = 6.",
            "Input: rods = [1,2,3,4,5,6]\nOutput: 10\nExplanation: We have two disjoint subsets {2,3,5} and {4,6}, which have the same sum = 10.",
            "Input: rods = [1,2]\nOutput: 0\nExplanation: The billboard cannot be supported, so we return 0."
        ],
        "constraints": "1 <= rods.length <= 20\n1 <= rods[i] <= 1000\nsum(rods[i]) <= 5000",
        "release_time": 1687588495,
        "oracle_code": "class Solution {\npublic:\n\n    int build_board(vector<int> &rods, int balance,int i,vector<vector<int>> &memo)\n    {\n        if(i>=rods.size() && balance==0)\n            return 0;\n        if(i>=rods.size() && balance!=0)\n            return INT_MIN;\n\n        if(memo[i][balance+5000]!=-1)\n            return memo[i][balance+5000];\n        int left= build_board(rods,balance+rods[i],i+1,memo);\n        int right= build_board(rods,balance-rods[i],i+1,memo);\n\n        int ans= rods[i]+max(left,right);\n\n        int skip= build_board(rods,balance,i+1,memo);\n\n        ans= max(ans,skip);\n\n        memo[i][balance+5000]=ans;\n        return ans;\n\n    }\n\n    int tallestBillboard(vector<int>& rods) {\n        \n        vector<vector<int>> memo(rods.size(),vector<int>(10001,-1));\n        int ans= build_board(rods,0,0,memo);\n\n        if(ans<=0)\n            return 0;\n        else\n            return ans/2;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust as any dp problem where we have to select the item or leave it, same idea is being used here.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor any given rod we have 3 optins to add it to the right leg or left leg or leave the rod. Now for the states of the dp one has to be the i that will iterate through the rods array. And if we maintain two additional states for left and the right leg then a total of 3 states was giving a memory limit exceed(in my case).\\n\\nTo reduce the a state, I used a balance state that will denote the difference between the legs\\' height. If we add the ith rod in the right leg then we increase the balance by rod[i] and if we add it to the left leg then we decerase the balance by rod[i], remains unchanged if we choose to skip the rod. \\n\\n**Balance ==0 will denote both legs are of same height, balance>0 means right leg is longer ans balance<0 means left is longer.**\\n\\n**Now, sum(rods[i])<=5000 (as given). Then our balance could range from -5000 to 5000. So in the memo table I am shifting the balance by 5000 to handle the negative indixes.**\\n\\n  \\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int build_board(vector<int> &rods, int balance,int i,vector<vector<int>> &memo)\\n    {\\n        if(i>=rods.size() && balance==0)\\n            return 0;\\n        if(i>=rods.size() && balance!=0)\\n            return INT_MIN;\\n\\n        if(memo[i][balance+5000]!=-1)\\n            return memo[i][balance+5000];\\n        int left= build_board(rods,balance+rods[i],i+1,memo);\\n        int right= build_board(rods,balance-rods[i],i+1,memo);\\n\\n        int ans= rods[i]+max(left,right);\\n\\n        int skip= build_board(rods,balance,i+1,memo);\\n\\n        ans= max(ans,skip);\\n\\n        memo[i][balance+5000]=ans;\\n        return ans;\\n\\n    }\\n\\n    int tallestBillboard(vector<int>& rods) {\\n        \\n        vector<vector<int>> memo(rods.size(),vector<int>(10001,-1));\\n        int ans= build_board(rods,0,0,memo);\\n\\n        if(ans<=0)\\n            return 0;\\n        else\\n            return ans/2;\\n    }\\n};\\n```",
        "level": "hard",
        "buggy_code": "\nclass Solution {\npublic:\n\n    int build_board(vector<int> &rods, int balance,int i,vector<vector<int>> &memo)\n    {\n        if(i>=rods.size() && balance==0)\n            return 0;\n        if(i>=rods.size() && balance!=0)\n            return INT_MIN;\n\n        if(memo[i][balance+5000]!=-1)\n            return memo[i][balance+5000];\n        int left= build_board(rods,balance+rods[i],i+1,memo);\n        int right= build_board(rods,balance-rods[i],i+1,memo);\n\n        int ans= rods[i]+max(left,right);\n\n        int skip= build_board(rods,balance,i+1,memo);\n\n        ans= max(ans,skip);\n\n        memo[i][balance+5000]=ans;\n        return ans;\n\n    }\n\n    int tallestBillboard(vector<int>& rods) {\n        \n        vector<vector<int>> memo(rods.size(),vector<int>(10001,-1));\n        int ans= build_board(rods,0,0,memo);\n\n        Solution s;\n        return s.tallestBillboard(rods);\n    }\n};\n",
        "explanations": "\nIn tallestBillboard function, it is recursively calling itself causing stack overflow.\n"
    },
    {
        "slug": "special-array-with-x-elements-greater-than-or-equal-x",
        "description": "You are given an array nums of non-negative integers. nums is considered special if there exists a number x such that there are exactly x numbers in nums that are greater than or equal to x.\nNotice that x does not have to be an element in nums.\nReturn x if the array is special, otherwise, return -1. It can be proven that if nums is special, the value for x is unique.",
        "examples": [
            "Input: nums = [3,5]\nOutput: 2\nExplanation: There are 2 values (3 and 5) that are greater than or equal to 2.",
            "Input: nums = [0,0]\nOutput: -1\nExplanation: No numbers fit the criteria for x.\nIf x = 0, there should be 0 numbers >= x, but there are 2.\nIf x = 1, there should be 1 number >= x, but there are 0.\nIf x = 2, there should be 2 numbers >= x, but there are 0.\nx cannot be greater since there are only 2 numbers in nums.",
            "Input: nums = [0,4,3,0,4]\nOutput: 3\nExplanation: There are 3 values that are greater than or equal to 3."
        ],
        "constraints": "1 <= nums.length <= 100\n0 <= nums[i] <= 1000",
        "release_time": 1683882134,
        "oracle_code": "class Solution {\npublic:\n    int specialArray(vector<int>& nums) {\n        int n = nums.size();\n        sort(nums.begin(),nums.end(),greater<int>());\n        for(int i=1;i<=n;i++){\n            int cnt=0;\n            for(int j=0;j<n;j++){\n                if(nums[j]>=i){\n                    cnt++;\n                }\n            }\n            if(cnt==i){\n                return i;\n            }\n        }\n        return -1;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can iterate over all possible values of x and check if there are exactly x numbers in nums that are greater than or equal to x. If we find such a value of x, we can return it as the answer. If we have checked all possible values of x and none of them satisfy the condition, we can return -1.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Sort the array in descending order.\\n- Iterate over all possible values of x from 1 to n (the length of the array).\\n- For each value of x, count the number of elements in the array that are greater than or equal to x. If the count is exactly x, return x as the answer.\\n- If we have checked all possible values of x and none of them satisfy the condition, return -1.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n^2)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Brute force Code\\n```\\nclass Solution {\\npublic:\\n    int specialArray(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end(),greater<int>());\\n        for(int i=1;i<=n;i++){\\n            int cnt=0;\\n            for(int j=0;j<n;j++){\\n                if(nums[j]>=i){\\n                    cnt++;\\n                }\\n            }\\n            if(cnt==i){\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n# Please Upvote if it was helpful\\u2B06\\uFE0F\\n# Optimized Approach (Using Binary Search)\\n# Intuition\\n\\nwe can optimize the time complexity of the solution from O(n^2) to O(n log n) by using binary search instead of iterating over all possible values of x.\\n# Approach\\n- Sort the array in non-increasing order.\\n- Set the left pointer to 1 and the right pointer to n (the length of the array).\\n- While the left pointer is less than or equal to the right pointer:\\n  - Set the mid pointer to the average of the left and right pointers.\\n  -  Count the number of elements in the array that are greater than or equal to mid. If the count is less than mid, set the right pointer to mid-1. If the count is greater than or equal to mid, set the left pointer to mid+1.\\n- If we have checked all possible values of x and none of them satisfy the condition, return -1. Otherwise, return the value of mid.\\n\\n\\nThe key idea behind this algorithm is that the number of elements in the array that are greater than or equal to x is a monotonic function of x. Therefore, we can use binary search to find the smallest value of x such that there are exactly x elements in the array that are greater than or equal to x.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int specialArray(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end(),greater<int>());\\n        int left=1,right=n;\\n        \\n        while(left<=right){\\n            int mid=(left+right)/2;\\n            int cnt=0;\\n            for(int i=0;i<n;i++){\\n                if(nums[i]>=mid){\\n                    cnt++;\\n                }else{\\n                    break;\\n                }\\n            }\\n            if(cnt<mid){\\n                right=mid-1;\\n            }else{\\n                left=mid+1;\\n            }\\n        }\\n        \\n        if(right<1 || nums[right-1]<right){\\n            return -1;\\n        }\\n        int cal=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]>=right){\\n                cal++;\\n            }\\n        }\\n        if(cal==right){\\n            return right;\\n        }else{\\n            return -1;\\n        }\\n        return right;\\n    }\\n};\\n```\\n# Time Complexity \\n$$O(nlogn)$$\\n# Space Complexity\\n$$O(1)$$\\n\\n# One Upvote can be really encouraging\\u2B06\\uFE0F",
        "level": "easy",
        "buggy_code": "\nclass Solution {\npublic:\n    int specialArray(vector<int>& nums) {\n        int n = nums.size();\n        sort(nums.begin(),nums.end(),greater<int>());\n        for(int i=1;i<=n;i++){\n            int cnt=0;\n            for(int j=0;j<n;j++){\n                if(nums[j]>=i){\n                    cnt++;\n                }\n            }\n            if(cnt==n){\n                return i;\n            }\n        }\n        return -1;\n    }\n};\n",
        "explanations": "\nThis bug will cause the function to return the wrong result, as it compares 'cnt' with 'n' instead of 'i'.\n"
    },
    {
        "slug": "moving-stones-until-consecutive-ii",
        "description": "There are some stones in different positions on the X-axis. You are given an integer array stones, the positions of the stones.\nCall a stone an endpoint stone if it has the smallest or largest position. In one move, you pick up an endpoint stone and move it to an unoccupied position so that it is no longer an endpoint stone.\n\nIn particular, if the stones are at say, stones = [1,2,5], you cannot move the endpoint stone at position 5, since moving it to any position (such as 0, or 3) will still keep that stone as an endpoint stone.\n\nThe game ends when you cannot make any more moves (i.e., the stones are in three consecutive positions).\nReturn an integer array answer of length 2 where:\n\nanswer[0] is the minimum number of moves you can play, and\nanswer[1] is the maximum number of moves you can play.",
        "examples": [
            "Input: stones = [7,4,9]\nOutput: [1,2]\nExplanation: We can move 4 -> 8 for one move to finish the game.\nOr, we can move 9 -> 5, 4 -> 6 for two moves to finish the game.",
            "Input: stones = [6,5,4,3,10]\nOutput: [2,3]\nExplanation: We can move 3 -> 8 then 10 -> 7 to finish the game.\nOr, we can move 3 -> 7, 4 -> 8, 5 -> 9 to finish the game.\nNotice we cannot move 10 -> 2 to finish the game, because that would be an illegal move."
        ],
        "constraints": "3 <= stones.length <= 104\n1 <= stones[i] <= 109\nAll the values of stones are unique.",
        "release_time": 1682433907,
        "oracle_code": "class Solution {\npublic:\n    vector<int> numMovesStonesII(vector<int>& stones) {\n        sort(stones.begin(), stones.end());\n\n        int N = stones.size(), low = N;\n        for (int i = 0, j = 0; j < N; ++j) {\n            while (stones[j] - stones[i] + 1 > N) {\n                ++i;\n            }\n            if (N - (j - i + 1) == 1 && N - (stones[j] - stones[i] + 1) == 1) {\n                low = min(low, 2);\n            } else {\n                low = min(low, N - (j - i + 1));\n            }\n        }\n\n        int high = 1 + max((stones[N - 1] - stones[1] + 1) - N,  // Move to right most\n                           (stones[N - 2] - stones[0] + 1) - N); // Move to left most\n        return {low, high};\n    }\n};",
        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> numMovesStonesII(vector<int>& stones) {\\n        sort(stones.begin(), stones.end());\\n\\n        int N = stones.size(), low = N;\\n        for (int i = 0, j = 0; j < N; ++j) {\\n            while (stones[j] - stones[i] + 1 > N) {\\n                ++i;\\n            }\\n            if (N - (j - i + 1) == 1 && N - (stones[j] - stones[i] + 1) == 1) {\\n                low = min(low, 2);\\n            } else {\\n                low = min(low, N - (j - i + 1));\\n            }\\n        }\\n\\n        int high = 1 + max((stones[N - 1] - stones[1] + 1) - N,  // Move to right most\\n                           (stones[N - 2] - stones[0] + 1) - N); // Move to left most\\n        return {low, high};\\n    }\\n};\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\npublic:\n    vector<int> numMovesStonesII(vector<int>& stones) {\n        sort(stones.begin(), stones.end());\n\n        int N = stones.size(), low = N;\n        vector<int> result;\n        for (int i = 0, j = 0; j < N; ++j) {\n            while (stones[j] - stones[i] + 1 > N) {\n                ++i;\n            }\n            if (N - (j - i + 1) == 1 && N - (stones[j] - stones[i] + 1) == 1) {\n                low = min(low, 2);\n            } else {\n                low = min(low, N - (j - i + 1));\n            }\n        }\n\n        int high = 1 + max((stones[N - 1] - stones[1] + 1) - N,  // Move to right most\n                           (stones[N - 2] - stones[0] + 1) - N); // Move to left most\n        return result;\n    }\n};\n",
        "explanations": "\nThe variable \"result\" is not defined or assigned any value, leading to undefined behavior.\n"
    },
    {
        "slug": "count-negative-numbers-in-a-sorted-matrix",
        "description": "Given a m x n matrix grid which is sorted in non-increasing order both row-wise and column-wise, return the number of negative numbers in grid.",
        "examples": [
            "Input: grid = [[4,3,2,-1],[3,2,1,-1],[1,1,-1,-2],[-1,-1,-2,-3]]\nOutput: 8\nExplanation: There are 8 negatives number in the matrix.",
            "Input: grid = [[3,2],[1,0]]\nOutput: 0"
        ],
        "constraints": "m == grid.length\nn == grid[i].length\n1 <= m, n <= 100\n-100 <= grid[i][j] <= 100",
        "release_time": 1686192488,
        "oracle_code": "class Solution {\npublic:\n    int binaryS(vector<int>& v, int sz) {\n        int l=0, r=sz, mid;\n        while(l<r){\n            mid=l+(r-l)/2;\n            if(v[mid]<0) r=mid;\n            else l=mid+1;\n        }\n        return r;  // Returns the index\n        // The binaryS function is used to find the index where \n        // negative numbers start in a sorted vector.\n        // It performs a binary search to locate the first \n        // occurrence of a negative number.\n        //////////////////////////////////////\n        // C++ STL upper_bound\n        //  return upper_bound(v.begin(),v.end(),0,greater<int>())\n        //    -v.begin(); \n    }\n\n    int countNegatives(vector<vector<int>>& grid) {\n        int n=grid.size();\n        int m=grid[0].size();\n        int sum=0;\n\n        // Using binaryS to find the number i_max\n        vector<int> col0(n);\n        for(int i=0; i<n; i++) col0[i]=grid[i][0];\n        int i_max=binaryS(col0, n);\n        // The binaryS function is called to find the number of\n        // negative numbers in the first column of the grid.\n        // It returns the index where the negative numbers start,\n        // which represents the number of negative numbers in \n        // that column.\n\n        for (int i=0; i<i_max; i++){\n            sum+= m-binaryS(grid[i], m);\n        }\n        // Iterate through the rows up to i_max.\n        // For each row, binaryS is called to find the number of\n        // negative numbers in that row.\n        // Subtracting this count from m gives the number of\n        // non-negative numbers in the row.\n        // The result is added to the sum.\n\n        sum+=(n-i_max)*m;\n        // Add the number of non-negative numbers in the remaining\n        // rows (n-i_max) to the sum.\n        // Since all elements in these rows are non-negative, the \n        //count is simply m (the number of columns).\n\n        return sum;  // Return the total count of negative numbers\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nC++ solution using binary search to find  the least upper bound i_max for the column vector grid[i][0] first.\\n\\nThen using a for-loop to sum up the values for m-binarS(grid[i]) where i<i_max\\n\\nFinally,  add the number (n-i_max)*m to the desired variable sum.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int binaryS(vector<int>& v, int sz) {\\n        int l=0, r=sz, mid;\\n        while(l<r){\\n            mid=l+(r-l)/2;\\n            if(v[mid]<0) r=mid;\\n            else l=mid+1;\\n        }\\n        return r;  // Returns the index\\n        // The binaryS function is used to find the index where \\n        // negative numbers start in a sorted vector.\\n        // It performs a binary search to locate the first \\n        // occurrence of a negative number.\\n        //////////////////////////////////////\\n        // C++ STL upper_bound\\n        //  return upper_bound(v.begin(),v.end(),0,greater<int>())\\n        //    -v.begin(); \\n    }\\n\\n    int countNegatives(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int sum=0;\\n\\n        // Using binaryS to find the number i_max\\n        vector<int> col0(n);\\n        for(int i=0; i<n; i++) col0[i]=grid[i][0];\\n        int i_max=binaryS(col0, n);\\n        // The binaryS function is called to find the number of\\n        // negative numbers in the first column of the grid.\\n        // It returns the index where the negative numbers start,\\n        // which represents the number of negative numbers in \\n        // that column.\\n\\n        for (int i=0; i<i_max; i++){\\n            sum+= m-binaryS(grid[i], m);\\n        }\\n        // Iterate through the rows up to i_max.\\n        // For each row, binaryS is called to find the number of\\n        // negative numbers in that row.\\n        // Subtracting this count from m gives the number of\\n        // non-negative numbers in the row.\\n        // The result is added to the sum.\\n\\n        sum+=(n-i_max)*m;\\n        // Add the number of non-negative numbers in the remaining\\n        // rows (n-i_max) to the sum.\\n        // Since all elements in these rows are non-negative, the \\n        //count is simply m (the number of columns).\\n\\n        return sum;  // Return the total count of negative numbers\\n    }\\n};\\n\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\npublic:\n    int binaryS(vector<int>& v, int sz) {\n        int l=0, r=sz, mid;\n        while(l<r){\n            Solution ob;\n            mid=l+(r-l)/2;\n            if(ob.v[mid]<0) r=mid;\n            else l=mid+1;\n        }\n        return r;  \n    }\n\n    int countNegatives(vector<vector<int>>& grid) {\n        int n=grid.size();\n        int m=grid[0].size();\n        int sum=0;\n\n        vector<int> col0(n);\n        for(int i=0; i<n; i++) col0[i]=grid[i][0];\n        int i_max=binaryS(col0, n);\n\n        for (int i=0; i<i_max; i++){\n            sum+= m-binaryS(grid[i], m);\n        }\n\n        sum+=(n-i_max)*m;\n        return sum;  \n    }\n};\n",
        "explanations": "\nObject 'ob' is undefined in function binaryS accessing nonexistent vector 'ob.v'.\n"
    },
    {
        "slug": "count-good-numbers",
        "description": "A digit string is good if the digits (0-indexed) at even indices are even and the digits at odd indices are prime (2, 3, 5, or 7).\n\nFor example, \"2582\" is good because the digits (2 and 8) at even positions are even and the digits (5 and 2) at odd positions are prime. However, \"3245\" is not good because 3 is at an even index but is not even.\n\nGiven an integer n, return the total number of good digit strings of length n. Since the answer may be large, return it modulo 109 + 7.\nA digit string is a string consisting of digits 0 through 9 that may contain leading zeros.",
        "examples": [
            "Input: n = 1\nOutput: 5\nExplanation: The good numbers of length 1 are \"0\", \"2\", \"4\", \"6\", \"8\".",
            "Input: n = 4\nOutput: 400",
            "Input: n = 50\nOutput: 564908303"
        ],
        "constraints": "1 <= n <= 1015",
        "release_time": 1690970857,
        "oracle_code": "class Solution {\npublic:\n    int mod=1e9+7;\n    int binExpo(long long x,long long n){\n        int ans=1;\n        while(n){\n            if(n&1){\n                ans=(ans*x)%mod;\n            }\n            x=(x*x)%mod;\n            n>>=1;\n        }\n        return ans;\n    }\n    int countGoodNumbers(long long n) {\n        long long even=n/2+n%2,odd=n/2;\n        int even_val=binExpo(5,even);\n        int odd_val=binExpo(4,odd);\n        return (1ll*even_val*odd_val)%mod;\n\n        \n    }\n};",
        "content": "Here we can use the concept of binary exponentiation.\\nAs 2^7==2^(0111) in binary.\\nso 2^7=(2^4)*(2^2)*(2^1).\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int binExpo(long long x,long long n){\\n        int ans=1;\\n        while(n){\\n            if(n&1){\\n                ans=(ans*x)%mod;\\n            }\\n            x=(x*x)%mod;\\n            n>>=1;\\n        }\\n        return ans;\\n    }\\n    int countGoodNumbers(long long n) {\\n        long long even=n/2+n%2,odd=n/2;\\n        int even_val=binExpo(5,even);\\n        int odd_val=binExpo(4,odd);\\n        return (1ll*even_val*odd_val)%mod;\\n\\n        \\n    }\\n};\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\npublic:\n    int mod=1e9+7;\n    int binExpo(long long x,long long n){\n        int ans=1;\n        while(n){\n            if(n&1){\n                ans=(ans*x)%mod;\n            }\n            x=(x*x)%mod;\n            n>>=1;\n        }\n        return ans;\n    }\n    int countGoodNumbers(long long n) {\n        long long even=n/2+n%2,odd=n/2;\n        int even_val=binExpo(5,even);\n        int odd_val=undefined_object;\n        return (1ll*even_val*odd_val)%mod;\n\n        \n    }\n};\n",
        "explanations": "\nundefined_object in countGoodNumbers function is not defined which can lead to an error.\n"
    },
    {
        "slug": "divide-array-in-sets-of-k-consecutive-numbers",
        "description": "Given an array of integers nums and a positive integer k, check whether it is possible to divide this array into sets of k consecutive numbers.\nReturn true if it is possible. Otherwise, return false.",
        "examples": [
            "Input: nums = [1,2,3,3,4,4,5,6], k = 4\nOutput: true\nExplanation: Array can be divided into [1,2,3,4] and [3,4,5,6].",
            "Input: nums = [3,2,1,2,3,4,3,4,5,9,10,11], k = 3\nOutput: true\nExplanation: Array can be divided into [1,2,3] , [2,3,4] , [3,4,5] and [9,10,11].",
            "Input: nums = [1,2,3,4], k = 3\nOutput: false\nExplanation: Each array should be divided in subarrays of size 3."
        ],
        "constraints": "1 <= k <= nums.length <= 105\n1 <= nums[i] <= 109\n\n\u00a0\nNote: This question is the same as\u00a0846:\u00a0https://leetcode.com/problems/hand-of-straights/",
        "release_time": 1678827516,
        "oracle_code": "class Solution {\npublic:\n    bool isPossibleDivide(vector<int>& nums, int k) {\n        unordered_map<int,int> mpp;\n        sort(nums.begin(), nums.end());\n        if(nums.size()%k!=0){\n            return false;\n        }\n\n\n        for(int i=0; i<nums.size(); i++){\n            mpp[nums[i]]++;\n        }\n        for(int i=0; i<nums.size(); i++){\n            if(mpp[nums[i]]<=0){\n                continue;\n            }\n            for(int j=nums[i] ; j<nums[i]+ k; j++){\n                if(mpp[j]<=0){\n                    return false;\n                }\n                \n                    mpp[j]--;\n                \n            }\n        }\n        return true;\n    }\n};",
        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPossibleDivide(vector<int>& nums, int k) {\\n        unordered_map<int,int> mpp;\\n        sort(nums.begin(), nums.end());\\n        if(nums.size()%k!=0){\\n            return false;\\n        }\\n\\n\\n        for(int i=0; i<nums.size(); i++){\\n            mpp[nums[i]]++;\\n        }\\n        for(int i=0; i<nums.size(); i++){\\n            if(mpp[nums[i]]<=0){\\n                continue;\\n            }\\n            for(int j=nums[i] ; j<nums[i]+ k; j++){\\n                if(mpp[j]<=0){\\n                    return false;\\n                }\\n                \\n                    mpp[j]--;\\n                \\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\npublic:\n    bool isPossibleDivide(vector<int>& nums, int k) {\n        unordered_map<int,int> mpp;\n        sort(nums.begin(), nums.end());\n        if(nums.size()%k!=0){\n            return false;\n        }\n\n\n        for(int i=0; i<nums.size(); i++){\n            mpp[nums[i]]++;\n        }\n        for(int i=0; i<nums.size(); i++){\n            if(mpp[nums[i]]<=0){\n                continue;\n            }\n            for(int j=nums[i] ; j<nums[i]+ k; j++){\n                if(mpp[j]<=0){\n                    return false;\n                }\n                mpp[j]--;\n            }\n        }\n        vector<int> undefinedObject;\n        int n = undefinedObject[0];\n        return true;\n    }\n};\n",
        "explanations": "\nThe code tries to access an element of an undefined object which is not declared. \n"
    },
    {
        "slug": "gray-code",
        "description": "An n-bit gray code sequence is a sequence of 2n integers where:\n\nEvery integer is in the inclusive range [0, 2n - 1],\nThe first integer is 0,\nAn integer appears no more than once in the sequence,\nThe binary representation of every pair of adjacent integers differs by exactly one bit, and\nThe binary representation of the first and last integers differs by exactly one bit.\n\nGiven an integer n, return any valid n-bit gray code sequence.",
        "examples": [
            "Input: n = 2\nOutput: [0,1,3,2]\nExplanation:\nThe binary representation of [0,1,3,2] is [00,01,11,10].\n- 00 and 01 differ by one bit\n- 01 and 11 differ by one bit\n- 11 and 10 differ by one bit\n- 10 and 00 differ by one bit\n[0,2,3,1] is also a valid gray code sequence, whose binary representation is [00,10,11,01].\n- 00 and 10 differ by one bit\n- 10 and 11 differ by one bit\n- 11 and 01 differ by one bit\n- 01 and 00 differ by one bit",
            "Input: n = 1\nOutput: [0,1]"
        ],
        "constraints": "1 <= n <= 16",
        "release_time": 1688835462,
        "oracle_code": "class Solution {\npublic:\n    vector<int> grayCode(int n) {\n        vector<int> res;\n        res.push_back( 0 );\n        for( int k = 0; k<n; k++ ) {\n            int i = res.size(), t = (1<<k) ;\n            while( i ) {\n                int temp = res[--i] | t;\n                res.push_back( temp );\n            }\n        }\n        return res;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int> res;\\n        res.push_back( 0 );\\n        for( int k = 0; k<n; k++ ) {\\n            int i = res.size(), t = (1<<k) ;\\n            while( i ) {\\n                int temp = res[--i] | t;\\n                res.push_back( temp );\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\npublic:\n    vector<int> grayCode(int n) {\n        vector<int> res;\n        for( int k = 0; k<n; k++ ) {\n            int i = res.size(), t = (1<<k) ;\n            while( i ) {\n                int temp = res[--i] | t;\n                res.push_back( temp );\n            }\n        }\n        return res;\n    }\n};\n",
        "explanations": "\nThe vector 'res' is empty, causing undefined elements to be accessed in the loop.\n"
    },
    {
        "slug": "average-salary-excluding-the-minimum-and-maximum-salary",
        "description": "You are given an array of unique integers salary where salary[i] is the salary of the ith employee.\nReturn the average salary of employees excluding the minimum and maximum salary. Answers within 10-5 of the actual answer will be accepted.",
        "examples": [
            "Input: salary = [4000,3000,1000,2000]\nOutput: 2500.00000\nExplanation: Minimum salary and maximum salary are 1000 and 4000 respectively.\nAverage salary excluding minimum and maximum salary is (2000+3000) / 2 = 2500",
            "Input: salary = [1000,2000,3000]\nOutput: 2000.00000\nExplanation: Minimum salary and maximum salary are 1000 and 3000 respectively.\nAverage salary excluding minimum and maximum salary is (2000) / 1 = 2000"
        ],
        "constraints": "3 <= salary.length <= 100\n1000 <= salary[i] <= 106\nAll the integers of salary are unique.",
        "release_time": 1682952594,
        "oracle_code": "class Solution {\npublic:\n    double average(vector<int>& salary) {\n        int n=salary.size(),sum=0,Min=INT_MAX,Max=INT_MIN;\n        for(int i:salary){\n            Max = Max < i ? i : Max ;\n            Min = Min > i ? i : Min ;\n            sum += i;\n        }\n        sum -= (Min + Max);\n        return sum/(n-2.0);\n    }\n};",
        "content": "# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double average(vector<int>& salary) {\\n        int n=salary.size(),sum=0,Min=INT_MAX,Max=INT_MIN;\\n        for(int i:salary){\\n            Max = Max < i ? i : Max ;\\n            Min = Min > i ? i : Min ;\\n            sum += i;\\n        }\\n        sum -= (Min + Max);\\n        return sum/(n-2.0);\\n    }\\n};\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\npublic:\n    double average(vector<int>& salary) {\n        int n=salary.size(),sum=0,Min=INT_MAX,Max=INT_MIN;\n        for(int i:salary){\n            Max = Max < i ? i : Max ;\n            Min = Min > i ? i : Min ;\n            sum += i;\n        }\n        sum -= (Min + Max);\n        return sum/(n-2.0);\n    }\n    double result = average(undefined);\n};\n",
        "explanations": "\nCalling the average function with an undefined variable results in a compilation error.\n"
    },
    {
        "slug": "reverse-odd-levels-of-binary-tree",
        "description": "Given the root of a perfect binary tree, reverse the node values at each odd level of the tree.\n\nFor example, suppose the node values at level 3 are [2,1,3,4,7,11,29,18], then it should become [18,29,11,7,4,3,1,2].\n\nReturn the root of the reversed tree.\nA binary tree is perfect if all parent nodes have two children and all leaves are on the same level.\nThe level of a node is the number of edges along the path between it and the root node.",
        "examples": [
            "Input: root = [2,3,5,8,13,21,34]\nOutput: [2,5,3,8,13,21,34]\nExplanation: \nThe tree has only one odd level.\nThe nodes at level 1 are 3, 5 respectively, which are reversed and become 5, 3.",
            "Input: root = [7,13,11]\nOutput: [7,11,13]\nExplanation: \nThe nodes at level 1 are 13, 11, which are reversed and become 11, 13.",
            "Input: root = [0,1,2,0,0,0,0,1,1,1,1,2,2,2,2]\nOutput: [0,2,1,0,0,0,0,2,2,2,2,1,1,1,1]\nExplanation: \nThe odd levels have non-zero values.\nThe nodes at level 1 were 1, 2, and are 2, 1 after the reversal.\nThe nodes at level 3 were 1, 1, 1, 1, 2, 2, 2, 2, and are 2, 2, 2, 2, 1, 1, 1, 1 after the reversal."
        ],
        "constraints": "The number of nodes in the tree is in the range [1, 214].\n0 <= Node.val <= 105\nroot is a perfect binary tree.",
        "release_time": 1665040875,
        "oracle_code": "class Solution {\npublic:\n    TreeNode* reverseOddLevels(TreeNode* root) {\n        queue<TreeNode*> q;\n        q.push(root);\n        int x = 1,n,i,z;\n        vector<TreeNode*> tmp;\n        TreeNode* node;\n        while(!q.empty()){\n            tmp.clear();\n            n = q.size();\n            // cout<<n<<\" \";\n            while(n--){\n                node = q.front();q.pop();\n                // cout<<node->val<<\" \";\n                if(x==0){\n                    tmp.push_back(node);\n                }\n                if(node->left)\n                    q.push(node->left);\n                if(node->right){\n                    q.push(node->right);\n                }\n            }\n            n = tmp.size();\n            for(i = 0; i < n/2; i++){\n                z = tmp[i]->val;\n                tmp[i]->val = tmp[n-1-i]->val;\n                tmp[n-1-i]->val = z;\n            }\n            x ^= 1;\n            n = 0;\n        }\n        return root;\n    }\n};",
        "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* reverseOddLevels(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        int x = 1,n,i,z;\\n        vector<TreeNode*> tmp;\\n        TreeNode* node;\\n        while(!q.empty()){\\n            tmp.clear();\\n            n = q.size();\\n            // cout<<n<<\" \";\\n            while(n--){\\n                node = q.front();q.pop();\\n                // cout<<node->val<<\" \";\\n                if(x==0){\\n                    tmp.push_back(node);\\n                }\\n                if(node->left)\\n                    q.push(node->left);\\n                if(node->right){\\n                    q.push(node->right);\\n                }\\n            }\\n            n = tmp.size();\\n            for(i = 0; i < n/2; i++){\\n                z = tmp[i]->val;\\n                tmp[i]->val = tmp[n-1-i]->val;\\n                tmp[n-1-i]->val = z;\\n            }\\n            x ^= 1;\\n            n = 0;\\n        }\\n        return root;\\n    }\\n};\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\npublic:\n    TreeNode* reverseOddLevels(TreeNode* root) {\n        queue<TreeNode*> q;\n        q.push(root);\n        int x = 1,n,i,z;\n        vector<TreeNode*> tmp;\n        TreeNode* node;\n        TreeNode* undefinedNode;\n        while(!q.empty()){\n            tmp.clear();\n            n = q.size();\n            while(n--){\n                node = q.front();q.pop();\n                if(x==0){\n                    tmp.push_back(undefinedNode);\n                }\n                if(node->left)\n                    q.push(node->left);\n                if(node->right){\n                    q.push(node->right);\n                }\n            }\n            n = tmp.size();\n            for(i = 0; i < n/2; i++){\n                z = tmp[i]->val;\n                tmp[i]->val = tmp[n-1-i]->val;\n                tmp[n-1-i]->val = z;\n            }\n            x ^= 1;\n            n = 0;\n        }\n        return root;\n    }\n};\n",
        "explanations": "\nPushed 'undefinedNode' to vector tmp instead of 'node' causing undefined behavior/accessing uninitialized memory.\n"
    },
    {
        "slug": "remove-outermost-parentheses",
        "description": "A valid parentheses string is either empty \"\", \"(\" + A + \")\", or A + B, where A and B are valid parentheses strings, and + represents string concatenation.\n\nFor example, \"\", \"()\", \"(())()\", and \"(()(()))\" are all valid parentheses strings.\n\nA valid parentheses string s is primitive if it is nonempty, and there does not exist a way to split it into s = A + B, with A and B nonempty valid parentheses strings.\nGiven a valid parentheses string s, consider its primitive decomposition: s = P1 + P2 + ... + Pk, where Pi are primitive valid parentheses strings.\nReturn s after removing the outermost parentheses of every primitive string in the primitive decomposition of s.",
        "examples": [
            "Input: s = \"(()())(())\"\nOutput: \"()()()\"\nExplanation: \nThe input string is \"(()())(())\", with primitive decomposition \"(()())\" + \"(())\".\nAfter removing outer parentheses of each part, this is \"()()\" + \"()\" = \"()()()\".",
            "Input: s = \"(()())(())(()(()))\"\nOutput: \"()()()()(())\"\nExplanation: \nThe input string is \"(()())(())(()(()))\", with primitive decomposition \"(()())\" + \"(())\" + \"(()(()))\".\nAfter removing outer parentheses of each part, this is \"()()\" + \"()\" + \"()(())\" = \"()()()()(())\".",
            "Input: s = \"()()\"\nOutput: \"\"\nExplanation: \nThe input string is \"()()\", with primitive decomposition \"()\" + \"()\".\nAfter removing outer parentheses of each part, this is \"\" + \"\" = \"\"."
        ],
        "constraints": "1 <= s.length <= 105\ns[i] is either '(' or ')'.\ns is a valid parentheses string.",
        "release_time": 1687925926,
        "oracle_code": "class Solution {\npublic:\n    string removeOuterParentheses(string s) {\n        stack<char> st;\n        string res=\"\";\n        for(int i=0;i<s.size();i++){\n            if(s[i]=='(' && st.empty()){\n                st.push(s[i]);\n            }\n            else if(s[i]=='('){\n                st.push(s[i]);\n                res+=s[i];\n            }\n            else{\n                st.pop();\n                if(st.size()){\n                    res+=s[i];\n                }\n            }\n        }\n        return res;\n    }\n};",
        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        stack<char> st;\\n        string res=\"\";\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'(\\' && st.empty()){\\n                st.push(s[i]);\\n            }\\n            else if(s[i]==\\'(\\'){\\n                st.push(s[i]);\\n                res+=s[i];\\n            }\\n            else{\\n                st.pop();\\n                if(st.size()){\\n                    res+=s[i];\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\npublic:\n    string removeOuterParentheses(string s) {\n        stack<char> st;\n        string res=\"\";\n        for(int i=0;i<s.size();i++){\n            if(s[i]=='(' && st.empty()){\n                st.push(s[i]);\n            }\n            else if(s[i]=='('){\n                st.push(s[i]);\n                undefinedObject+=s[i]; \n            }\n            else{\n                st.pop();\n                if(st.size()){\n                    res+=s[i];\n                }\n            }\n        }\n        return res;\n    }\n};\n",
        "explanations": "\nThe object 'undefinedObject' is used without being defined, causing an undefined object error.\n"
    },
    {
        "slug": "palindrome-linked-list",
        "description": "Given the head of a singly linked list, return true if it is a palindrome or false otherwise.",
        "examples": [
            "Input: head = [1,2,2,1]\nOutput: true",
            "Input: head = [1,2]\nOutput: false"
        ],
        "constraints": "The number of nodes in the list is in the range [1, 105].\n0 <= Node.val <= 9",
        "release_time": 1684173184,
        "oracle_code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    bool flag;\n    ListNode*Head;\n    void checkpalindrome(ListNode* Revhead){\n        if(Revhead==NULL){\n            return;\n        }\n         checkpalindrome(Revhead->next);\n         if(Revhead!=NULL){\n             if(Revhead->val!=Head->val){\n                 flag=false;\n             }\n             Head=Head->next;\n         }\n    }\n    bool isPalindrome(ListNode* head) {\n        flag=true;\n        Head=head;\n        checkpalindrome(head);\n        return flag;\n    }\n};",
        "content": "\\n# Complexity\\n- Time complexity:\\no(n)\\n\\n- Space complexity:\\no(n)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool flag;\\n    ListNode*Head;\\n    void checkpalindrome(ListNode* Revhead){\\n        if(Revhead==NULL){\\n            return;\\n        }\\n         checkpalindrome(Revhead->next);\\n         if(Revhead!=NULL){\\n             if(Revhead->val!=Head->val){\\n                 flag=false;\\n             }\\n             Head=Head->next;\\n         }\\n    }\\n    bool isPalindrome(ListNode* head) {\\n        flag=true;\\n        Head=head;\\n        checkpalindrome(head);\\n        return flag;\\n    }\\n};\\n```",
        "level": "easy",
        "buggy_code": "\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    bool flag;\n    ListNode*Head;\n    ListNode* undefinedObject; \n    void checkpalindrome(ListNode* Revhead){\n        if(Revhead==NULL){\n            return;\n        }\n         checkpalindrome(Revhead->next);\n         if(Revhead!=NULL){\n             if(Revhead->val!=undefinedObject->val){ \n                 flag=false;\n             }\n             Head=Head->next;\n         }\n    }\n    bool isPalindrome(ListNode* head) {\n        flag=true;\n        Head=head;\n        checkpalindrome(head);\n        return flag;\n    }\n};\n",
        "explanations": "\nThe variable 'undefinedObject' is declared but not defined, which leads to undefined behavior.\n"
    },
    {
        "slug": "detect-cycles-in-2d-grid",
        "description": "Given a 2D array of characters grid of size m x n, you need to find if there exists any cycle consisting of the same value in grid.\nA cycle is a path of length 4 or more in the grid that starts and ends at the same cell. From a given cell, you can move to one of the cells adjacent to it - in one of the four directions (up, down, left, or right), if it has the same value of the current cell.\nAlso, you cannot move to the cell that you visited in your last move. For example, the cycle (1, 1) -> (1, 2) -> (1, 1) is invalid because from (1, 2) we visited (1, 1) which was the last visited cell.\nReturn true if any cycle of the same value exists in grid, otherwise, return false.",
        "examples": [
            "Input: grid = [[\"a\",\"a\",\"a\",\"a\"],[\"a\",\"b\",\"b\",\"a\"],[\"a\",\"b\",\"b\",\"a\"],[\"a\",\"a\",\"a\",\"a\"]]\nOutput: true\nExplanation: There are two valid cycles shown in different colors in the image below:",
            "Input: grid = [[\"c\",\"c\",\"c\",\"a\"],[\"c\",\"d\",\"c\",\"c\"],[\"c\",\"c\",\"e\",\"c\"],[\"f\",\"c\",\"c\",\"c\"]]\nOutput: true\nExplanation: There is only one valid cycle highlighted in the image below:",
            "Input: grid = [[\"a\",\"b\",\"b\"],[\"b\",\"z\",\"b\"],[\"b\",\"b\",\"a\"]]\nOutput: false"
        ],
        "constraints": "m == grid.length\nn == grid[i].length\n1 <= m, n <= 500\ngrid consists only of lowercase English letters.",
        "release_time": 1665809409,
        "oracle_code": "class Solution {\npublic:\n   vector<int> dir = { 0, 1, 0, -1, 0 }; \n    bool isCyclic(vector<vector<char>>& grid, vector<vector<bool>>& visited, int i, int j, int x, int y)\n    {\n        visited[i][j] = true;\n        for(int d = 0; d < 4; ++d)\n        {\n            int a = i+dir[d];\n            int b = j+dir[d+1];\n            if(a >= 0 && a < grid.size() && b >= 0 && b < grid[0].size() && grid[a][b] == grid[i][j] && !(x == a && y == b))\n                if(visited[a][b] || isCyclic(grid, visited, a,b,i,j))\n                    return true;\n        }\n        return false;\n    }\n    bool containsCycle(vector<vector<char>>& grid) {\n        int n = grid.size(), m = grid[0].size();\n        vector<vector<bool>> visited(n, vector<bool>(m, false));\n        for(int i = 0; i < n; ++i)\n            for(int j = 0; j < m; ++j)\n                if(!visited[i][j] && isCyclic(grid, visited, i, j, -1, -1))\n                    return true;\n        return false;\n    }\n};",
        "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n   vector<int> dir = { 0, 1, 0, -1, 0 }; \\n    bool isCyclic(vector<vector<char>>& grid, vector<vector<bool>>& visited, int i, int j, int x, int y)\\n    {\\n        visited[i][j] = true;\\n        for(int d = 0; d < 4; ++d)\\n        {\\n            int a = i+dir[d];\\n            int b = j+dir[d+1];\\n            if(a >= 0 && a < grid.size() && b >= 0 && b < grid[0].size() && grid[a][b] == grid[i][j] && !(x == a && y == b))\\n                if(visited[a][b] || isCyclic(grid, visited, a,b,i,j))\\n                    return true;\\n        }\\n        return false;\\n    }\\n    bool containsCycle(vector<vector<char>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<bool>> visited(n, vector<bool>(m, false));\\n        for(int i = 0; i < n; ++i)\\n            for(int j = 0; j < m; ++j)\\n                if(!visited[i][j] && isCyclic(grid, visited, i, j, -1, -1))\\n                    return true;\\n        return false;\\n    }\\n};\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\npublic:\n   vector<int> dir = { 0, 1, 0, -1, 0 }; \n    bool isCyclic(vector<vector<char>>& grid, vector<vector<bool>>& visited, int i, int j, int x, int y)\n    {\n        visited[i][j] = true;\n        for(int d = 0; d < 4; ++d)\n        {\n            int a = i+dir[d];\n            int b = j+dir[d+1];\n            if(a >= 0 && a < grid.size() && b >= 0 && b < grid[0].size() && grid[a][b] == grid[i][j] && !(x == a && y == b))\n                if((!visited[a][b] && isCyclic(grid, visited, a,b,i,j)) || visited[a][b])\n                    return true;\n        }\n        return false;\n    }\n    bool containsCycle(vector<vector<char>>& grid) {\n        int n = grid.size(), m = grid[0].size();\n        vector<vector<bool>> visited(n, vector<bool>(m, false));\n        for(int i = 0; i < n; ++i)\n            for(int j = 0; j < m; ++j)\n                if(!visited[i][j] && isCyclic(grid, visited, i, j, -1, -1))\n                    return true;\n        return false;\n    }\n};\n",
        "explanations": "\nReturning true when grid point is visited causes false positives for cyclical checks.\n"
    },
    {
        "slug": "construct-binary-tree-from-preorder-and-inorder-traversal",
        "description": "Given two integer arrays preorder and inorder where preorder is the preorder traversal of a binary tree and inorder is the inorder traversal of the same tree, construct and return the binary tree.",
        "examples": [
            "Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]\nOutput: [3,9,20,null,null,15,7]",
            "Input: preorder = [-1], inorder = [-1]\nOutput: [-1]"
        ],
        "constraints": "1 <= preorder.length <= 3000\ninorder.length == preorder.length\n-3000 <= preorder[i], inorder[i] <= 3000\npreorder and inorder consist of unique values.\nEach value of inorder also appears in preorder.\npreorder is guaranteed to be the preorder traversal of the tree.\ninorder is guaranteed to be the inorder traversal of the tree.",
        "release_time": 1690986169,
        "oracle_code": "class Solution {\npublic:\n    int find(vector<int>& inorder, int k) {\n        for (int i = 0; i < inorder.size(); i++) if (inorder[i] == k) return i;\n        return -1;\n    }\n\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\n        int preIndex = 0, inStart = 0, inend = inorder.size() - 1;\n        return build(preorder, inorder, preIndex, inStart, inend);\n    }\n\n    TreeNode* build(vector<int>& preorder, vector<int>& inorder, int& preIndex, int inStart, int inend) {\n        if (inStart > inend) {\n            return NULL;\n        }\n\n        int ele = preorder[preIndex++];\n        TreeNode* root = new TreeNode(ele);\n        int pos_in_inorder = find(inorder, ele);\n\n        root->left = build(preorder, inorder, preIndex, inStart, pos_in_inorder - 1);\n        root->right = build(preorder, inorder, preIndex, pos_in_inorder + 1, inend);\n        return root;\n    }\n};",
        "content": "# Intuition : First take a node from preorder, We know that for pre order traversal D-L-R and for inorder L-D-R. \\nFor this we have to build a tree according to preorder traversal one by one (by making that element as pivot) and by using inorder we have to find how many elements are left or right to that pivot element accordingly.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach : Simple Recursion \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: \\n- 1) For making a tree in recursive function we\\'ll required O(n).\\n- 2) For finding element in inorder traversal we\\'ll required again O(n).\\n- Overall Complexity will be O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int find(vector<int>& inorder, int k) {\\n        for (int i = 0; i < inorder.size(); i++) if (inorder[i] == k) return i;\\n        return -1;\\n    }\\n\\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n        int preIndex = 0, inStart = 0, inend = inorder.size() - 1;\\n        return build(preorder, inorder, preIndex, inStart, inend);\\n    }\\n\\n    TreeNode* build(vector<int>& preorder, vector<int>& inorder, int& preIndex, int inStart, int inend) {\\n        if (inStart > inend) {\\n            return NULL;\\n        }\\n\\n        int ele = preorder[preIndex++];\\n        TreeNode* root = new TreeNode(ele);\\n        int pos_in_inorder = find(inorder, ele);\\n\\n        root->left = build(preorder, inorder, preIndex, inStart, pos_in_inorder - 1);\\n        root->right = build(preorder, inorder, preIndex, pos_in_inorder + 1, inend);\\n        return root;\\n    }\\n};\\n\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\npublic:\n    int find(vector<int>& inorder, int k) {\n        for (int i = 0; i < inorder.size(); i++) if (inorder[i] == k) return i;\n        return -1;\n    }\n\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\n        int preIndex = 0, inStart = 0, inend = inorder.size() - 1;\n        return build(preorder, inorder, preIndex, inStart, inend);\n    }\n\n    TreeNode* build(vector<int>& preorder, vector<int>& inorder, int& preIndex, int inStart, int inend) {\n        if (inStart > inend) {\n            return NULL;\n        }\n\n        TreeNode* root;\n        int ele = preorder[preIndex++];\n        int pos_in_inorder = find(inorder, ele);\n\n        root->left = build(preorder, inorder, preIndex, inStart, pos_in_inorder - 1);\n        root->right = build(preorder, inorder, preIndex, pos_in_inorder + 1, inend);\n        return root;\n    }\n};\n",
        "explanations": "\nThe bug was to not assign memory to the \"root\" pointer before using it.\n"
    }
]