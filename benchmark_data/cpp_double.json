[
    {
        "slug": "count-the-number-of-beautiful-subarrays",
        "description": "You are given a 0-indexed integer array nums. In one operation, you can:\n\nChoose two different indices i and j such that 0 <= i, j < nums.length.\nChoose a non-negative integer k such that the kth bit (0-indexed) in the binary representation of nums[i] and nums[j] is 1.\nSubtract 2k from nums[i] and nums[j].\n\nA subarray is beautiful if it is possible to make all of its elements equal to 0 after applying the above operation any number of times.\nReturn the number of beautiful subarrays in the array nums.\nA subarray is a contiguous non-empty sequence of elements within an array.",
        "examples": [
            "Input: nums = [4,3,1,2,4]\nOutput: 2\nExplanation: There are 2 beautiful subarrays in nums: [4,3,1,2,4] and [4,3,1,2,4].\n- We can make all elements in the subarray [3,1,2] equal to 0 in the following way:\n  - Choose [3, 1, 2] and k = 1. Subtract 21 from both numbers. The subarray becomes [1, 1, 0].\n  - Choose [1, 1, 0] and k = 0. Subtract 20 from both numbers. The subarray becomes [0, 0, 0].\n- We can make all elements in the subarray [4,3,1,2,4] equal to 0 in the following way:\n  - Choose [4, 3, 1, 2, 4] and k = 2. Subtract 22 from both numbers. The subarray becomes [0, 3, 1, 2, 0].\n  - Choose [0, 3, 1, 2, 0] and k = 0. Subtract 20 from both numbers. The subarray becomes [0, 2, 0, 2, 0].\n  - Choose [0, 2, 0, 2, 0] and k = 1. Subtract 21 from both numbers. The subarray becomes [0, 0, 0, 0, 0].",
            "Input: nums = [1,10,4]\nOutput: 0\nExplanation: There are no beautiful subarrays in nums."
        ],
        "constraints": "1 <= nums.length <= 105\n0 <= nums[i] <= 106",
        "oracle_code": "class Solution {\npublic:\n    long long beautifulSubarrays(vector<int>& nums) {\n        \n        int n = nums.size();\n        \n        long long ans = 0;\n        \n        // declare an unordered map\n        \n        unordered_map<int, int> mp;\n        \n        // insert 0 with the frequncy of 1\n        \n        mp[0] = 1;\n        \n        int curr_xorr = 0;\n        \n        // traverse over the nums\n        \n        for(int i = 0; i < n; i++)\n        {\n            // find xorr\n            \n            curr_xorr = (curr_xorr ^ nums[i]);\n            \n            // if curr_xorr exit in map then update ans\n            \n            if(mp.count(curr_xorr))\n            {\n                ans += mp[curr_xorr];\n            }\n            \n            // increment the freq of curr_xorr\n            \n            mp[curr_xorr]++;\n        }\n        \n        return ans;\n    }\n};",
        "content": "* ***Using Hashmap && Bit Manipulation***\\n\\n* ***Time Complexity :- O(N)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        long long ans = 0;\\n        \\n        // declare an unordered map\\n        \\n        unordered_map<int, int> mp;\\n        \\n        // insert 0 with the frequncy of 1\\n        \\n        mp[0] = 1;\\n        \\n        int curr_xorr = 0;\\n        \\n        // traverse over the nums\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            // find xorr\\n            \\n            curr_xorr = (curr_xorr ^ nums[i]);\\n            \\n            // if curr_xorr exit in map then update ans\\n            \\n            if(mp.count(curr_xorr))\\n            {\\n                ans += mp[curr_xorr];\\n            }\\n            \\n            // increment the freq of curr_xorr\\n            \\n            mp[curr_xorr]++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "other error",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    long long beautifulSubarrays(vector<int>& nums) {\n        \n        int n = nums.size();\n        \n        long long ans = 0;\n        \n        // declare an unordered map\n        \n        unordered_map<int, int> mp;\n        \n        \n        \n        mp[0] = 1;\n        \n        int curr_xorr = 0;\n        \n        // traverse over the nums\n        \n        for(int i = 0; i <= n; i++)\n        {\n            // find xorr\n            \n            curr_xorr = (curr_xorr ^ nums[i]);\n            \n            // if curr_xorr exit in map then update ans\n            \n            if(mp.count(curr_xorr))\n            {\n                ans += mp[curr_xorr];\n            }\n            \n            // increment the freq of curr_xorr\n            \n            mp[curr_xorr]++;\n        }\n        \n        return ans;\n    }\n};\n"
    },
    {
        "slug": "buddy-strings",
        "description": "Given two strings s and goal, return true if you can swap two letters in s so the result is equal to goal, otherwise, return false.\nSwapping letters is defined as taking two indices i and j (0-indexed) such that i != j and swapping the characters at s[i] and s[j].\n\nFor example, swapping at indices 0 and 2 in \"abcd\" results in \"cbad\".",
        "examples": [
            "Input: s = \"ab\", goal = \"ba\"\nOutput: true\nExplanation: You can swap s[0] = 'a' and s[1] = 'b' to get \"ba\", which is equal to goal.",
            "Input: s = \"ab\", goal = \"ab\"\nOutput: false\nExplanation: The only letters you can swap are s[0] = 'a' and s[1] = 'b', which results in \"ba\" != goal.",
            "Input: s = \"aa\", goal = \"aa\"\nOutput: true\nExplanation: You can swap s[0] = 'a' and s[1] = 'a' to get \"aa\", which is equal to goal."
        ],
        "constraints": "1 <= s.length, goal.length <= 2 * 104\ns and goal consist of lowercase letters.",
        "oracle_code": "class Solution {\npublic:\n    bool buddyStrings(string s, string p) {\n        int n=s.length(), m=p.length();\n        if(n!=m) return false;\n        \n        vector<int> freq(26,0);\n        \n        int first=-1, second=-1;\n        for(int i=0;i<n;i++){\n            if(s[i] != p[i]){\n                if(first==-1){\n                    first=i;\n                }else if(second==-1){\n                    second=i;\n                }else{\n                    return false; // more than 2 mismatching characters\n                }\n            }\n            freq[s[i]-'a']++;\n        }\n        \n\t\t// similar strings\n        if(first == -1 && second == -1){\n            for(int i=0;i<26;i++) if(freq[i] > 1) return true; // can swap similar characters\n            return false; // all characters occur only once\n        }else if(second == -1){\n            return false; // exactly 1 mismatch\n        }\n        \n        return (s[first]==p[second] && s[second]==p[first]); // check similarity on 2 mismatched indexes\n    }\n};",
        "content": "**Connect with me on LinkedIn**: https://www.linkedin.com/in/abhay5349singh/\\n\\n```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string p) {\\n        int n=s.length(), m=p.length();\\n        if(n!=m) return false;\\n        \\n        vector<int> freq(26,0);\\n        \\n        int first=-1, second=-1;\\n        for(int i=0;i<n;i++){\\n            if(s[i] != p[i]){\\n                if(first==-1){\\n                    first=i;\\n                }else if(second==-1){\\n                    second=i;\\n                }else{\\n                    return false; // more than 2 mismatching characters\\n                }\\n            }\\n            freq[s[i]-\\'a\\']++;\\n        }\\n        \\n\\t\\t// similar strings\\n        if(first == -1 && second == -1){\\n            for(int i=0;i<26;i++) if(freq[i] > 1) return true; // can swap similar characters\\n            return false; // all characters occur only once\\n        }else if(second == -1){\\n            return false; // exactly 1 mismatch\\n        }\\n        \\n        return (s[first]==p[second] && s[second]==p[first]); // check similarity on 2 mismatched indexes\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "indexing error",
            "operation error"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    bool buddyStrings(string s, string p) {\n        int n=s.length(), m=p.length();\n        if(n!=m) return false;\n        \n        vector<int> freq(26,0);\n        \n        int first=-1, second=-1;\n        for(int i=0;i<=n;i++){\n            if(s[i] != p[i]){\n                if(first==-1){\n                    first=i;\n                }else if(second==-1){\n                    second=i;\n                }else{\n                    return false;\n                }\n            }\n            freq[s[i]-'z']++; \n        }\n        \n\t\tif(first == -1 && second == -1){\n            for(int i=0;i<26;i++) if(freq[i] > 1) return true;\n            return false;\n        }else if(second == -1){\n            return false;\n        }\n        \n        return (s[first]==p[second] && s[second]==p[first]);\n    }\n};\n"
    },
    {
        "slug": "most-beautiful-item-for-each-query",
        "description": "You are given a 2D integer array items where items[i] = [pricei, beautyi] denotes the price and beauty of an item respectively.\nYou are also given a 0-indexed integer array queries. For each queries[j], you want to determine the maximum beauty of an item whose price is less than or equal to queries[j]. If no such item exists, then the answer to this query is 0.\nReturn an array answer of the same length as queries where answer[j] is the answer to the jth query.",
        "examples": [
            "Input: items = [[1,2],[3,2],[2,4],[5,6],[3,5]], queries = [1,2,3,4,5,6]\nOutput: [2,4,5,5,6,6]\nExplanation:\n- For queries[0]=1, [1,2] is the only item which has price <= 1. Hence, the answer for this query is 2.\n- For queries[1]=2, the items which can be considered are [1,2] and [2,4]. \n  The maximum beauty among them is 4.\n- For queries[2]=3 and queries[3]=4, the items which can be considered are [1,2], [3,2], [2,4], and [3,5].\n  The maximum beauty among them is 5.\n- For queries[4]=5 and queries[5]=6, all items can be considered.\n  Hence, the answer for them is the maximum beauty of all items, i.e., 6.",
            "Input: items = [[1,2],[1,2],[1,3],[1,4]], queries = [1]\nOutput: [4]\nExplanation: \nThe price of every item is equal to 1, so we choose the item with the maximum beauty 4. \nNote that multiple items can have the same price and/or beauty.",
            "Input: items = [[10,1000]], queries = [5]\nOutput: [0]\nExplanation:\nNo item has a price less than or equal to 5, so no item can be chosen.\nHence, the answer to the query is 0."
        ],
        "constraints": "1 <= items.length, queries.length <= 105\nitems[i].length == 2\n1 <= pricei, beautyi, queries[j] <= 109",
        "oracle_code": "class Solution {\n    int bs(vector<vector<int>>& items, int t, vector<int> &beauty) {\n        int ans = 0, s = 0, e = items.size() - 1;\n        while(s <= e) {\n            int m = (s + e) / 2;\n            if(items[m][0] <= t) ans = beauty[m], s = m + 1;\n            else e = m - 1;\n        }\n        return ans;\n    }\n\npublic:\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\n        sort(items.begin(), items.end());\n        vector<int> ans, beauty(items.size(), items[0][1]);\n\n        for(int i=1; i<items.size(); i++) beauty[i] = max(beauty[i - 1], items[i][1]);\n\n        for(int i : queries) ans.push_back(bs(items, i, beauty));\n        return ans;\n    }\n};",
        "content": "\\n# C++\\n```\\nclass Solution {\\n    int bs(vector<vector<int>>& items, int t, vector<int> &beauty) {\\n        int ans = 0, s = 0, e = items.size() - 1;\\n        while(s <= e) {\\n            int m = (s + e) / 2;\\n            if(items[m][0] <= t) ans = beauty[m], s = m + 1;\\n            else e = m - 1;\\n        }\\n        return ans;\\n    }\\n\\npublic:\\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\\n        sort(items.begin(), items.end());\\n        vector<int> ans, beauty(items.size(), items[0][1]);\\n\\n        for(int i=1; i<items.size(); i++) beauty[i] = max(beauty[i - 1], items[i][1]);\\n\\n        for(int i : queries) ans.push_back(bs(items, i, beauty));\\n        return ans;\\n    }\\n};\\n```\\n\\n# Python\\n```\\nclass Solution(object):\\n    def maximumBeauty(self, items, queries):\\n        items.sort()\\n        ans, beauty = [], [items[0][1]] * len(items)\\n        for i in range(1, len(items)): beauty[i] = max(beauty[i - 1], items[i][1])\\n\\n        def bs(t):\\n            ans, s, e = 0, 0, len(items) - 1\\n            while s <= e:\\n                m = (s + e) // 2\\n                if items[m][0] <= t:\\n                    ans = beauty[m]\\n                    s = m + 1\\n                else: e = m - 1\\n            return ans\\n\\n        for i in queries: ans.append(bs(i))\\n        return ans\\n```\\n",
        "level": "medium",
        "type": [
            "indexing error",
            "wrong comment mark"
        ],
        "buggy_code": "\nclass Solution {\n    int bs(vector<vector<int>>& items, int t, vector<int> &beauty) {\n        int ans = 0, s = 0, e = items.size();\n        while(s <= e) {\n\n            if(items[m][0] <= t) ans = beauty[m], s = m + 1;\n            else e = m - 1;\n        }\n        return ans;\n    }\n\npublic:\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\n        sort(items.begin(), items.end());\n        vector<int> ans, beauty(items.size(), items[0][1]);\n\n        for(int i=1; i<items.size(); i++) beauty[i] = max(beauty[i - 1], items[i][1]);\n\n        for(int i : queries) ans.push_back(bs(items, i, beauty));\n        return ans;\n    }\n};\n"
    },
    {
        "slug": "kth-largest-element-in-a-stream",
        "description": "Design a class to find the kth largest element in a stream. Note that it is the kth largest element in the sorted order, not the kth distinct element.\nImplement KthLargest class:\n\nKthLargest(int k, int[] nums) Initializes the object with the integer k and the stream of integers nums.\nint add(int val) Appends the integer val to the stream and returns the element representing the kth largest element in the stream.",
        "examples": [
            "Input\n[\"KthLargest\", \"add\", \"add\", \"add\", \"add\", \"add\"]\n[[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]\nOutput\n[null, 4, 5, 5, 8, 8]\n\nExplanation\nKthLargest kthLargest = new KthLargest(3, [4, 5, 8, 2]);\nkthLargest.add(3);   // return 4\nkthLargest.add(5);   // return 5\nkthLargest.add(10);  // return 5\nkthLargest.add(9);   // return 8\nkthLargest.add(4);   // return 8"
        ],
        "constraints": "1 <= k <= 104\n0 <= nums.length <= 104\n-104 <= nums[i] <= 104\n-104 <= val <= 104\nAt most 104 calls will be made to add.\nIt is guaranteed that there will be at least k elements in the array when you search for the kth element.",
        "oracle_code": "class KthLargest {\npublic:\n    priority_queue<int,vector<int>,greater<int>> pq;\n    int position;\n    KthLargest(int k, vector<int>& nums) {\n        position=k;\n        for(int i=0; i<nums.size(); i++){\n            if(pq.size()<k){\n                pq.push(nums[i]);\n            }\n            else if(pq.top()<nums[i]){\n                pq.pop();\n                pq.push(nums[i]);\n            }\n        }\n    }\n    \n    int add(int val) {\n        if(pq.size()<position){\n            pq.push(val);\n        }\n        else if(pq.top()<val){\n            pq.pop();\n            pq.push(val);\n        }\n        return pq.top();\n    }\n};\n\n/**\n * Your KthLargest object will be instantiated and called as such:\n * KthLargest* obj = new KthLargest(k, nums);\n * int param_1 = obj->add(val);\n */",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass KthLargest {\\npublic:\\n    priority_queue<int,vector<int>,greater<int>> pq;\\n    int position;\\n    KthLargest(int k, vector<int>& nums) {\\n        position=k;\\n        for(int i=0; i<nums.size(); i++){\\n            if(pq.size()<k){\\n                pq.push(nums[i]);\\n            }\\n            else if(pq.top()<nums[i]){\\n                pq.pop();\\n                pq.push(nums[i]);\\n            }\\n        }\\n    }\\n    \\n    int add(int val) {\\n        if(pq.size()<position){\\n            pq.push(val);\\n        }\\n        else if(pq.top()<val){\\n            pq.pop();\\n            pq.push(val);\\n        }\\n        return pq.top();\\n    }\\n};\\n\\n/**\\n * Your KthLargest object will be instantiated and called as such:\\n * KthLargest* obj = new KthLargest(k, nums);\\n * int param_1 = obj->add(val);\\n */\\n```",
        "level": "easy",
        "type": [
            "indexing error",
            "conditional statement error"
        ],
        "buggy_code": "\nclass KthLargest {\npublic:\n    priority_queue<int,vector<int>,greater<int>> pq;\n    int position;\n    KthLargest(int k, vector<int>& nums) {\n        position=k;\n        for(int i=0; i<=nums.size(); i++){\n            if(pq.size()<k){\n                pq.push(nums[i]);\n            }\n            else if(pq.top()<nums[i]){\n                pq.pop();\n                pq.push(nums[i]);\n            }\n        }\n    }\n    \n    int add(int val) {\n        if(pq.size()<position){\n            pq.push(val);\n        }\n        return pq.top();\n    }\n};\n"
    },
    {
        "slug": "find-the-minimum-and-maximum-number-of-nodes-between-critical-points",
        "description": "A critical point in a linked list is defined as either a local maxima or a local minima.\nA node is a local maxima if the current node has a value strictly greater than the previous node and the next node.\nA node is a local minima if the current node has a value strictly smaller than the previous node and the next node.\nNote that a node can only be a local maxima/minima if there exists both a previous node and a next node.\nGiven a linked list head, return an array of length 2 containing [minDistance, maxDistance] where minDistance is the minimum distance between any\u00a0two distinct critical points and maxDistance is the maximum distance between any\u00a0two distinct critical points. If there are fewer than two critical points, return [-1, -1].",
        "examples": [
            "Input: head = [3,1]\nOutput: [-1,-1]\nExplanation: There are no critical points in [3,1].",
            "Input: head = [5,3,1,2,5,1,2]\nOutput: [1,3]\nExplanation: There are three critical points:\n- [5,3,1,2,5,1,2]: The third node is a local minima because 1 is less than 3 and 2.\n- [5,3,1,2,5,1,2]: The fifth node is a local maxima because 5 is greater than 2 and 1.\n- [5,3,1,2,5,1,2]: The sixth node is a local minima because 1 is less than 5 and 2.\nThe minimum distance is between the fifth and the sixth node. minDistance = 6 - 5 = 1.\nThe maximum distance is between the third and the sixth node. maxDistance = 6 - 3 = 3.",
            "Input: head = [1,3,2,2,3,2,2,2,7]\nOutput: [3,3]\nExplanation: There are two critical points:\n- [1,3,2,2,3,2,2,2,7]: The second node is a local maxima because 3 is greater than 1 and 2.\n- [1,3,2,2,3,2,2,2,7]: The fifth node is a local maxima because 3 is greater than 2 and 2.\nBoth the minimum and maximum distances are between the second and the fifth node.\nThus, minDistance and maxDistance is 5 - 2 = 3.\nNote that the last node is not considered a local maxima because it does not have a next node."
        ],
        "constraints": "The number of nodes in the list is in the range [2, 105].\n1 <= Node.val <= 105",
        "oracle_code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\n        ios_base::sync_with_stdio(false);\n if(head==NULL || head->next==NULL ||head->next->next==NULL){\n     return {-1,-1};\n }\n        ListNode* temp2=head->next;\n        ListNode* temp3=head->next->next;\n      vector<int>v;\n      int i=2;\n      while(temp3){\n          if((head->val<temp2->val)&&(temp3->val<temp2->val)){\n              v.push_back(i);\n          }\n          else if((head->val>temp2->val)&&(temp3->val>temp2->val)){\n              v.push_back(i);\n          }\n          i++;\n          head=head->next;\n          temp2=temp2->next;\n          temp3=temp3->next;\n      }\n      if(v.size()<2){\n           return {-1,-1};\n      }\n      int mini=INT_MAX;\n      for(int i=1;i<v.size();i++){\n          mini=min(mini,(v[i]-v[i-1]));\n      }\n        return {mini,(v[v.size()-1]-v[0])};\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhen faced with a problem involving linked lists, the first intuition should be to think about how to traverse the list efficiently to extract the required information.\\n\\nIn the case of this problem, the required information is the minimum and maximum distance between any two critical points in the list. A critical point is defined as a node where the value is either the maximum or minimum among its adjacent nodes.\\n\\nTo solve this problem, we need to traverse the list and identify the critical points. Once we have the critical points, we can calculate the distances between them and find the minimum and maximum distances.\\n\\nTherefore, the first intuition for this problem should be to think about how to traverse the list and identify critical points efficiently. We can then use this information to calculate the minimum and maximum distances between critical points.\\n\\n\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe code first checks if the list has at least three nodes, as it is not possible to have a critical point with less than two adjacent nodes. If the list does not meet this condition, the function returns {-1,-1}.\\n\\nThen, the code initializes three pointers, head, temp2, and temp3. The head pointer is used to traverse the list, while temp2 and temp3 are used to check if the current node is a critical point. The i variable is also initialized to 2, as the first two nodes are not considered critical points.\\n\\nNext, the code enters a loop that traverses the list using the temp3 pointer. For each node, the code checks if it is a critical point by comparing its value to the values of its adjacent nodes. If it is a critical point, the current value of i is pushed to a vector v.\\n\\nAfter the loop finishes, the code checks if there are at least two critical points in the list. If there are less than two, the function returns {-1,-1}.\\n\\nIf there are at least two critical points, the code calculates the minimum and maximum distances between adjacent critical points. The minimum distance is the minimum difference between the indices of adjacent critical points in the v vector, and the maximum distance is the difference between the indices of the first and last elements in the v vector.\\n\\nFinally, the function returns a vector containing the minimum and maximum distances as its two elements.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this code is O(n), where n is the length of the input singly-linked list. This is because the code only traverses the list once in the while loop, and performs constant time operations (comparisons, pointer assignments, and vector operations) for each node. The vector operations inside the loop take constant time on average, as the vector is not resized during the loop. Therefore, the overall time complexity of the code is O(n).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of this code is O(1) if we ignore the space used by the input linked list. The code only uses a constant amount of extra space to store three pointers (head, temp2, temp3) and a vector v to store the indices of critical points. The size of v is proportional to the number of critical points in the list, which is at most n-2 (where n is the length of the list), as there can be at most one critical point per node except for the first and last nodes. Therefore, the size of v is bounded by O(n), but since the space used by v is not a function of the input size, we consider it as a constant space usage. Therefore, the overall space complexity of the code is O(1).\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        ios_base::sync_with_stdio(false);\\n if(head==NULL || head->next==NULL ||head->next->next==NULL){\\n     return {-1,-1};\\n }\\n        ListNode* temp2=head->next;\\n        ListNode* temp3=head->next->next;\\n      vector<int>v;\\n      int i=2;\\n      while(temp3){\\n          if((head->val<temp2->val)&&(temp3->val<temp2->val)){\\n              v.push_back(i);\\n          }\\n          else if((head->val>temp2->val)&&(temp3->val>temp2->val)){\\n              v.push_back(i);\\n          }\\n          i++;\\n          head=head->next;\\n          temp2=temp2->next;\\n          temp3=temp3->next;\\n      }\\n      if(v.size()<2){\\n           return {-1,-1};\\n      }\\n      int mini=INT_MAX;\\n      for(int i=1;i<v.size();i++){\\n          mini=min(mini,(v[i]-v[i-1]));\\n      }\\n        return {mini,(v[v.size()-1]-v[0])};\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "== and = confusion",
            "colon missing"
        ],
        "buggy_code": "\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\n        ios_base::sync_with_stdio(false);\n if(head==NULL || head->next==NULL ||head->next->next==NULL){\n     return {-1,-1};\n }\n        ListNode* temp2=head->next;\n        ListNode* temp3=head->next-next;\n      vector<int>v;\n      int i=2;\n      while(temp3){\n          if((head->val<temp2->val)&&(temp3->val=temp2->val)){ \n              v.push_back(i);\n          }\n          else if((head->val>temp2->val)&&(temp3->val>temp2->val)){\n              v.push_back(i);\n          }\n          i++;\n          head=head;\n          temp2=temp2.next;\n          temp3=temp3.next;\n      }\n      if(v.size()<2){\n           return {-1,-1};\n      }\n      int mini=INT_MAX;\n      for(int i=1;i<v.size();i++){\n          mini=min(mini,(v[i]-v[i-1]));\n      }\n        return {mini,(v[v.size()-1]-v[0])};\n    }\n};\n"
    },
    {
        "slug": "shortest-path-to-get-all-keys",
        "description": "You are given an m x n grid grid where:\n\n'.' is an empty cell.\n'#' is a wall.\n'@' is the starting point.\nLowercase letters represent keys.\nUppercase letters represent locks.\n\nYou start at the starting point and one move consists of walking one space in one of the four cardinal directions. You cannot walk outside the grid, or walk into a wall.\nIf you walk over a key, you can pick it up and you cannot walk over a lock unless you have its corresponding key.\nFor some 1 <= k <= 6, there is exactly one lowercase and one uppercase letter of the first k letters of the English alphabet in the grid. This means that there is exactly one key for each lock, and one lock for each key; and also that the letters used to represent the keys and locks were chosen in the same order as the English alphabet.\nReturn the lowest number of moves to acquire all keys. If it is impossible, return -1.",
        "examples": [
            "Input: grid = [\"@.a..\",\"###.#\",\"b.A.B\"]\nOutput: 8\nExplanation: Note that the goal is to obtain all the keys not to open all the locks.",
            "Input: grid = [\"@..aA\",\"..B#.\",\"....b\"]\nOutput: 6",
            "Input: grid = [\"@Aa\"]\nOutput: -1"
        ],
        "constraints": "m == grid.length\nn == grid[i].length\n1 <= m, n <= 30\ngrid[i][j] is either an English letter, '.', '#', or '@'.\u00a0\nThere is exactly one\u00a0'@'\u00a0in the grid.\nThe number of keys in the grid is in the range [1, 6].\nEach key in the grid is unique.\nEach key in the grid has a matching lock.",
        "oracle_code": "class Solution {\npublic:\n\n    int dir[4][2] = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};\n\n    int shortestPathAllKeys(vector<string>& grid) {\n        \n        int m = grid.size();\n        int n = grid[0].size();\n        queue<pair<pair<int, int>, int>> que;\n        vector<vector<unsigned long>> mapKey(m, vector<unsigned long>(n, 0));\n        int target = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if ('a' <= grid[i][j] && grid[i][j] <= 'f') {\n                    target |= 1 << (grid[i][j] - 'a');\n                    continue;\n                }\n\n                if (grid[i][j] == '@') {\n                    que.emplace(pair<int, int>(i, j), 0);\n                    mapKey[i][j] = 1;\n                }\n            }\n        }\n\n\n        int step = 0;\n        while (!que.empty()) {\n            int size = que.size();\n            for (int s = 0; s < size; s++) {\n                int i = que.front().first.first;\n                int j = que.front().first.second;\n                int key = que.front().second;\n                que.pop();\n                \n                if ('a' <= grid[i][j] && grid[i][j] <= 'f') {\n                    key |= 1 << (grid[i][j] - 'a');\n                    if (key == target)\n                        return step;\n\n                    mapKey[i][j] |= 1l << key;\n                }\n\n                for (int d = 0; d < 4; d++) {\n                    int newi = i + dir[d][0];\n                    int newj = j + dir[d][1];\n                    \n                    if (!(0 <= newi && newi < m && 0 <= newj && newj < n))\n                        continue;\n                        \n                    int val = grid[newi][newj];\n                    if (val == '#')\n                        continue;\n                        \n                    if ('A' <= val && val <= 'F' && (key & (1 << (val - 'A'))) == 0)\n                        continue;\n                        \n                    if (mapKey[newi][newj] & (1l << key))\n                        continue;\n                        \n                     mapKey[newi][newj] |= 1l << key;\n                     que.emplace(pair<int, int>(newi, newj), key);\n                }\n            }\n            step++;\n        }\n        return -1;\n    }\n};",
        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int dir[4][2] = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};\\n\\n    int shortestPathAllKeys(vector<string>& grid) {\\n        \\n        int m = grid.size();\\n        int n = grid[0].size();\\n        queue<pair<pair<int, int>, int>> que;\\n        vector<vector<unsigned long>> mapKey(m, vector<unsigned long>(n, 0));\\n        int target = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (\\'a\\' <= grid[i][j] && grid[i][j] <= \\'f\\') {\\n                    target |= 1 << (grid[i][j] - \\'a\\');\\n                    continue;\\n                }\\n\\n                if (grid[i][j] == \\'@\\') {\\n                    que.emplace(pair<int, int>(i, j), 0);\\n                    mapKey[i][j] = 1;\\n                }\\n            }\\n        }\\n\\n\\n        int step = 0;\\n        while (!que.empty()) {\\n            int size = que.size();\\n            for (int s = 0; s < size; s++) {\\n                int i = que.front().first.first;\\n                int j = que.front().first.second;\\n                int key = que.front().second;\\n                que.pop();\\n                \\n                if (\\'a\\' <= grid[i][j] && grid[i][j] <= \\'f\\') {\\n                    key |= 1 << (grid[i][j] - \\'a\\');\\n                    if (key == target)\\n                        return step;\\n\\n                    mapKey[i][j] |= 1l << key;\\n                }\\n\\n                for (int d = 0; d < 4; d++) {\\n                    int newi = i + dir[d][0];\\n                    int newj = j + dir[d][1];\\n                    \\n                    if (!(0 <= newi && newi < m && 0 <= newj && newj < n))\\n                        continue;\\n                        \\n                    int val = grid[newi][newj];\\n                    if (val == \\'#\\')\\n                        continue;\\n                        \\n                    if (\\'A\\' <= val && val <= \\'F\\' && (key & (1 << (val - \\'A\\'))) == 0)\\n                        continue;\\n                        \\n                    if (mapKey[newi][newj] & (1l << key))\\n                        continue;\\n                        \\n                     mapKey[newi][newj] |= 1l << key;\\n                     que.emplace(pair<int, int>(newi, newj), key);\\n                }\\n            }\\n            step++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
        "level": "hard",
        "type": [
            "statement separation",
            "colon missing"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n\n    int dir[4][2] = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};\n\n    int shortestPathAllKeys(vector<string>& grid) {\n        \n        int m = grid.size();\n        int n = grid[0].size();\n        queue<pair<pair<int, int>, int>> que;\n        vector<vector<unsigned long>> mapKey(m, vector<unsigned long>(n, 0));\n        int target = 0;\n        for (int i = 0; i < m; i++) \n            for (int j = 0; j < n; j++) \n                if ('a' <= grid[i][j] && grid[i][j] <= 'f') {\n                    target |= 1  (grid[i][j] - 'a');\n                    continue;\n\n                if (grid[i][j] == '@') {\n                    que.emplace(pair<int, int>(i, j), 0);\n                    mapKey[i][j] = 1;\n                }\n            \n\n\n        int step = 0;\n        while (!que.empty()) {\n            int size = que.size();\n            for (int s = 0; s < size; s++) {\n                int i = que.front().first.first;\n                int j = que.front().first.second;\n                int key = que.front().second;\n                que.pop();\n                \n                if ('a' <= grid[i][j] && grid[i][j] <= 'f') {\n                    key |= 1  (grid[i][j] - 'a');\n                    if (key == target)\n                        return step;\n\n                    mapKey[i][j] |= 1l << key;\n                }\n\n                for (int d = 0; d < 4; d++) {\n                    int newi = i + dir[d][0];\n                    int newj = j + dir[d][1];\n                    \n                    if (!(0 <= newi && newi < m && 0 <= newj && newj < n))\n                        continue;\n                        \n                    int val = grid[newi][newj];\n                    if (val == '#')\n                        continue;\n                        \n                    if ('A' <= val && val <= 'F' && (key & (1  (val - 'A'))) == 0)\n                        continue;\n                        \n                    if (mapKey[newi][newj] & (1l << key))\n                        continue;\n                        \n                     mapKey[newi][newj] |= 1l << key;\n                     que.emplace(pair<int, int>(newi, newj), key);\n                }\n            }\n            step++;\n        }\n        return -1;\n    }\n};\n"
    },
    {
        "slug": "coin-change-ii",
        "description": "You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\nReturn the number of combinations that make up that amount. If that amount of money cannot be made up by any combination of the coins, return 0.\nYou may assume that you have an infinite number of each kind of coin.\nThe answer is guaranteed to fit into a signed 32-bit integer.",
        "examples": [
            "Input: amount = 5, coins = [1,2,5]\nOutput: 4\nExplanation: there are four ways to make up the amount:\n5=5\n5=2+2+1\n5=2+1+1+1\n5=1+1+1+1+1",
            "Input: amount = 3, coins = [2]\nOutput: 0\nExplanation: the amount of 3 cannot be made up just with coins of 2.",
            "Input: amount = 10, coins = [10]\nOutput: 1"
        ],
        "constraints": "1 <= coins.length <= 300\n1 <= coins[i] <= 5000\nAll the values of coins are unique.\n0 <= amount <= 5000",
        "oracle_code": "class Solution\n{\npublic:\n    int change(int amount, vector<int> &coins)\n    {\n        ios_base::sync_with_stdio(0);\n        int st = 0;\n        sort(coins.begin(), coins.end());\n        int ways_to_do[5001] = {0};\n        // If there is a coin of value 1\n        // There will be always a way to make every amount\n        // From [1, amount]\n        // Hence all the values should be initialised at 1\n        if (coins[0] == 1)\n        {\n            for (int i = 1; i <= amount; i++)\n                ways_to_do[i] = 1;\n            st = 1;\n        }\n        // There is always 1 way to make a zero amount \n        ways_to_do[0] = 1;\n        // For every coin_value\n        // Add the number of ways to make current_amount - coin_value \n        // To the number of ways to make the current AMOUNT\n        for (int i = st; i < coins.size(); i++)\n            for (int j = coins[i]; j <= amount; j++)\n                ways_to_do[j] += ways_to_do[j - coins[i]];\n        return ways_to_do[amount];\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nNumber of ways a particular `amount` can be generated with a `coin_value` is equal to the current number of ways to generate the `current_amount` + number of ways to generate `current_amount - coin_value`\\n\\n\\n# Complexity\\n- Time complexity: $$O(N * Amount)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(Amount)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution\\n{\\npublic:\\n    int change(int amount, vector<int> &coins)\\n    {\\n        ios_base::sync_with_stdio(0);\\n        int st = 0;\\n        sort(coins.begin(), coins.end());\\n        int ways_to_do[5001] = {0};\\n        // If there is a coin of value 1\\n        // There will be always a way to make every amount\\n        // From [1, amount]\\n        // Hence all the values should be initialised at 1\\n        if (coins[0] == 1)\\n        {\\n            for (int i = 1; i <= amount; i++)\\n                ways_to_do[i] = 1;\\n            st = 1;\\n        }\\n        // There is always 1 way to make a zero amount \\n        ways_to_do[0] = 1;\\n        // For every coin_value\\n        // Add the number of ways to make current_amount - coin_value \\n        // To the number of ways to make the current AMOUNT\\n        for (int i = st; i < coins.size(); i++)\\n            for (int j = coins[i]; j <= amount; j++)\\n                ways_to_do[j] += ways_to_do[j - coins[i]];\\n        return ways_to_do[amount];\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "other error",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution\n{\npublic:\n    int change(int amount, vector<int> &coins)\n    {\n        ios_base::sync_with_stdio(0);\n        sort(coins.begin(), coins.end());\n        getWays(amount, coins);\n    }\n\n    int getWays(int amount, vector<int> &coins){\n        int st = 0;\n        int ways_to_do[5001] = {0};\n\n        if (coins[0] == 1)\n        {\n            for (int i = 1; i <= amount; i++)\n                ways_to_do[i] = 1;\n        }\n\n        ways_to_do[0] = 1 \n       0;\n\n        for (int i = st; i < coins.size(); i++)\n            for (int j = coins[i]; j <= amount; j++)\n                ways_to_do[j] += ways_to_do[j - coins[i]];\n\n        return ways_to_do[amount];\n    }\n};\n"
    },
    {
        "slug": "most-beautiful-item-for-each-query",
        "description": "You are given a 2D integer array items where items[i] = [pricei, beautyi] denotes the price and beauty of an item respectively.\nYou are also given a 0-indexed integer array queries. For each queries[j], you want to determine the maximum beauty of an item whose price is less than or equal to queries[j]. If no such item exists, then the answer to this query is 0.\nReturn an array answer of the same length as queries where answer[j] is the answer to the jth query.",
        "examples": [
            "Input: items = [[1,2],[3,2],[2,4],[5,6],[3,5]], queries = [1,2,3,4,5,6]\nOutput: [2,4,5,5,6,6]\nExplanation:\n- For queries[0]=1, [1,2] is the only item which has price <= 1. Hence, the answer for this query is 2.\n- For queries[1]=2, the items which can be considered are [1,2] and [2,4]. \n  The maximum beauty among them is 4.\n- For queries[2]=3 and queries[3]=4, the items which can be considered are [1,2], [3,2], [2,4], and [3,5].\n  The maximum beauty among them is 5.\n- For queries[4]=5 and queries[5]=6, all items can be considered.\n  Hence, the answer for them is the maximum beauty of all items, i.e., 6.",
            "Input: items = [[1,2],[1,2],[1,3],[1,4]], queries = [1]\nOutput: [4]\nExplanation: \nThe price of every item is equal to 1, so we choose the item with the maximum beauty 4. \nNote that multiple items can have the same price and/or beauty.",
            "Input: items = [[10,1000]], queries = [5]\nOutput: [0]\nExplanation:\nNo item has a price less than or equal to 5, so no item can be chosen.\nHence, the answer to the query is 0."
        ],
        "constraints": "1 <= items.length, queries.length <= 105\nitems[i].length == 2\n1 <= pricei, beautyi, queries[j] <= 109",
        "oracle_code": "class Solution {\n    int bs(vector<vector<int>>& items, int t, vector<int> &beauty) {\n        int ans = 0, s = 0, e = items.size() - 1;\n        while(s <= e) {\n            int m = (s + e) / 2;\n            if(items[m][0] <= t) ans = beauty[m], s = m + 1;\n            else e = m - 1;\n        }\n        return ans;\n    }\n\npublic:\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\n        sort(items.begin(), items.end());\n        vector<int> ans, beauty(items.size(), items[0][1]);\n\n        for(int i=1; i<items.size(); i++) beauty[i] = max(beauty[i - 1], items[i][1]);\n\n        for(int i : queries) ans.push_back(bs(items, i, beauty));\n        return ans;\n    }\n};",
        "content": "\\n# C++\\n```\\nclass Solution {\\n    int bs(vector<vector<int>>& items, int t, vector<int> &beauty) {\\n        int ans = 0, s = 0, e = items.size() - 1;\\n        while(s <= e) {\\n            int m = (s + e) / 2;\\n            if(items[m][0] <= t) ans = beauty[m], s = m + 1;\\n            else e = m - 1;\\n        }\\n        return ans;\\n    }\\n\\npublic:\\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\\n        sort(items.begin(), items.end());\\n        vector<int> ans, beauty(items.size(), items[0][1]);\\n\\n        for(int i=1; i<items.size(); i++) beauty[i] = max(beauty[i - 1], items[i][1]);\\n\\n        for(int i : queries) ans.push_back(bs(items, i, beauty));\\n        return ans;\\n    }\\n};\\n```\\n\\n# Python\\n```\\nclass Solution(object):\\n    def maximumBeauty(self, items, queries):\\n        items.sort()\\n        ans, beauty = [], [items[0][1]] * len(items)\\n        for i in range(1, len(items)): beauty[i] = max(beauty[i - 1], items[i][1])\\n\\n        def bs(t):\\n            ans, s, e = 0, 0, len(items) - 1\\n            while s <= e:\\n                m = (s + e) // 2\\n                if items[m][0] <= t:\\n                    ans = beauty[m]\\n                    s = m + 1\\n                else: e = m - 1\\n            return ans\\n\\n        for i in queries: ans.append(bs(i))\\n        return ans\\n```\\n",
        "level": "medium",
        "type": [
            "wrong comment mark",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\n    int bs(vector<vector<int>>& items, int t, vector<int> &beauty) {\n        int ans = 0, s = 0, e = items.size() - 1;\n        while(s <= e) {\n\n            if(items[m][0] <= t) ans = beauty[m], s = m + 1;\n            else e = m - 1;\n        }\n        return ans;\n    }\n\npublic:\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\n        sort(items.begin(), items.end());\n        vector<int> ans, beauty(items.size(), items[0][1]);\n\n        for(int i=1; i<items.size(); i++) beauty[i] = max(beauty[i - 1], items[i][1]);\n\n        for(int i : queries) ans.push_back(bs(items, i, beauty));\n        return ans;\n    }\n    \n    void foo(){\n        bar();\n    }\n};\n"
    },
    {
        "slug": "count-good-numbers",
        "description": "A digit string is good if the digits (0-indexed) at even indices are even and the digits at odd indices are prime (2, 3, 5, or 7).\n\nFor example, \"2582\" is good because the digits (2 and 8) at even positions are even and the digits (5 and 2) at odd positions are prime. However, \"3245\" is not good because 3 is at an even index but is not even.\n\nGiven an integer n, return the total number of good digit strings of length n. Since the answer may be large, return it modulo 109 + 7.\nA digit string is a string consisting of digits 0 through 9 that may contain leading zeros.",
        "examples": [
            "Input: n = 1\nOutput: 5\nExplanation: The good numbers of length 1 are \"0\", \"2\", \"4\", \"6\", \"8\".",
            "Input: n = 4\nOutput: 400",
            "Input: n = 50\nOutput: 564908303"
        ],
        "constraints": "1 <= n <= 1015",
        "oracle_code": "class Solution {\npublic:\n    int mod=1e9+7;\n    int binExpo(long long x,long long n){\n        int ans=1;\n        while(n){\n            if(n&1){\n                ans=(ans*x)%mod;\n            }\n            x=(x*x)%mod;\n            n>>=1;\n        }\n        return ans;\n    }\n    int countGoodNumbers(long long n) {\n        long long even=n/2+n%2,odd=n/2;\n        int even_val=binExpo(5,even);\n        int odd_val=binExpo(4,odd);\n        return (1ll*even_val*odd_val)%mod;\n\n        \n    }\n};",
        "content": "Here we can use the concept of binary exponentiation.\\nAs 2^7==2^(0111) in binary.\\nso 2^7=(2^4)*(2^2)*(2^1).\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int binExpo(long long x,long long n){\\n        int ans=1;\\n        while(n){\\n            if(n&1){\\n                ans=(ans*x)%mod;\\n            }\\n            x=(x*x)%mod;\\n            n>>=1;\\n        }\\n        return ans;\\n    }\\n    int countGoodNumbers(long long n) {\\n        long long even=n/2+n%2,odd=n/2;\\n        int even_val=binExpo(5,even);\\n        int odd_val=binExpo(4,odd);\\n        return (1ll*even_val*odd_val)%mod;\\n\\n        \\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "variable value error",
            "colon missing"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    int mod=1e9+7\n    int binExpo(long long x,long long n){\n        int ans=1;\n        while(n){\n            if(n&1){\n                ans=(ans*x)%mod;\n            }\n            x=(x*x)%mod;\n            n=1;\n        }\n        return ans;\n    }\n    int countGoodNumbers(long long n) {\n        long long even=n/2+n%2,odd=n/2;\n        int even_val=binExpo(5,even);\n        int odd_val=binExpo(4,odd);\n        return (1ll*even_val*odd_val)%mod;\n    }\n};\n"
    },
    {
        "slug": "magical-string",
        "description": "A magical string s consists of only '1' and '2' and obeys the following rules:\n\nThe string s is magical because concatenating the number of contiguous occurrences of characters '1' and '2' generates the string s itself.\n\nThe first few elements of s is s = \"1221121221221121122\u2026\u2026\". If we group the consecutive 1's and 2's in s, it will be \"1 22 11 2 1 22 1 22 11 2 11 22 ......\" and the occurrences of 1's or 2's in each group are \"1 2 2 1 1 2 1 2 2 1 2 2 ......\". You can see that the occurrence sequence is s itself.\nGiven an integer n, return the number of 1's in the first n number in the magical string s.",
        "examples": [
            "Input: n = 6\nOutput: 3\nExplanation: The first 6 elements of magical string s is \"122112\" and it contains three 1's, so return 3.",
            "Input: n = 1\nOutput: 1"
        ],
        "constraints": "1 <= n <= 105",
        "oracle_code": "class Solution {\npublic:\n    int magicalString(int n) {\n        string s=\"\";\n        s+=\"122\";\n        int i=2,c=1;\n        while(i<n && s.size()<n)\n        {\n            if(s[i]=='1')\n            {\n                c++;\n                if(s[s.size()-1]=='2')\n                s+='1';\n                else\n                {\n                    s+='2';\n                }\n            }\n            else\n            {\n                if(s[s.size()-1]=='2')\n                s+=\"11\";\n                else\n                {\n                    s+=\"22\";\n                }\n            }\n            i++;\n        }\n        while(i<n)\n        {\n            if(s[i]=='1')\n            c++;\n            i++;\n        }\n        return c;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIntution was to find the repeating part first, then i saw the pattern carefully and tried to make it.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can make the string using first three digits only \"122\",my intution is to make whole string upto length n,and count ones side by side. Also to count the remaining 1\\'s after while loop breaks\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int magicalString(int n) {\\n        string s=\"\";\\n        s+=\"122\";\\n        int i=2,c=1;\\n        while(i<n && s.size()<n)\\n        {\\n            if(s[i]==\\'1\\')\\n            {\\n                c++;\\n                if(s[s.size()-1]==\\'2\\')\\n                s+=\\'1\\';\\n                else\\n                {\\n                    s+=\\'2\\';\\n                }\\n            }\\n            else\\n            {\\n                if(s[s.size()-1]==\\'2\\')\\n                s+=\"11\";\\n                else\\n                {\\n                    s+=\"22\";\\n                }\\n            }\\n            i++;\\n        }\\n        while(i<n)\\n        {\\n            if(s[i]==\\'1\\')\\n            c++;\\n            i++;\\n        }\\n        return c;\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "== and = confusion",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    int magicalString(int n) {\n        string s=\"\";\n        s+=\"122\";\n        int i=2,c=1;\n        while(i<n && s.size()<n)\n        {\n            if(s[i]='1') \n            {\n                c++;\n                if(s[s.size()-1]=='2')\n                s+='1';\n                else\n                {\n                    s+='2';\n                }\n            }\n            else\n            {\n                if(s[s.size()-1]=='2')\n                s+=\"11\";\n                else\n                {\n                    s+='22'; \n                }\n            }\n            i++;\n        }\n        while(i<n)\n        {\n            if(s[i]='1') \n            c++;\n            i++;\n        }\n        return c;\n    }\n};\n"
    },
    {
        "slug": "factorial-trailing-zeroes",
        "description": "Given an integer n, return the number of trailing zeroes in n!.\nNote that n! = n * (n - 1) * (n - 2) * ... * 3 * 2 * 1.",
        "examples": [
            "Input: n = 3\nOutput: 0\nExplanation: 3! = 6, no trailing zero.",
            "Input: n = 5\nOutput: 1\nExplanation: 5! = 120, one trailing zero.",
            "Input: n = 0\nOutput: 0"
        ],
        "constraints": "0 <= n <= 104",
        "oracle_code": "class Solution {\npublic:\n    unordered_map<long long int,long long int>mp;\n    int trailingZeroes(int n) {\n        for(int i=n;i>=1;i--)\n         fun(i);\n         \n\t\t return min(mp[2],mp[5]); \n    }\n     void fun(int n)\n    {\n         for(int i=2;i*i<=n;i++)\n         {\n         \twhile((n%i) == 0)\n         \t{\n         \t    mp[i]++;\n\t\t\t\tn = n / i;\t\n\t\t\t}\n\t\t }\n\t\t if(n > 1)\n\t\t mp[n]++;\n    }\n};",
        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    unordered_map<long long int,long long int>mp;\\n    int trailingZeroes(int n) {\\n        for(int i=n;i>=1;i--)\\n         fun(i);\\n         \\n\\t\\t return min(mp[2],mp[5]); \\n    }\\n     void fun(int n)\\n    {\\n         for(int i=2;i*i<=n;i++)\\n         {\\n         \\twhile((n%i) == 0)\\n         \\t{\\n         \\t    mp[i]++;\\n\\t\\t\\t\\tn = n / i;\\t\\n\\t\\t\\t}\\n\\t\\t }\\n\\t\\t if(n > 1)\\n\\t\\t mp[n]++;\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "wrong comment mark",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    unordered_map<long long int,long long int>mp;\n    int trailingZeroes(int n) {\n        for(int i=n;i>=1;i--)\n        \n         \n\t\t Solution s;\n\t\t return s.min(mp[2],mp[5]); \n    }\n     void fun(int n)\n    {\n         for(int i=2;i*i<=n;i++)\n         {\n         \twhile((n%i) == 0)\n         \t{\n         \t    mp[i]++;\n\t\t\t\tn = n / i;\t\n\t\t\t}\n\t\t }\n\t\t if(n > 1)\n\t\t mp[n]++;\n    }\n};\n"
    },
    {
        "slug": "grumpy-bookstore-owner",
        "description": "There is a bookstore owner that has a store open for n minutes. Every minute, some number of customers enter the store. You are given an integer array customers of length n where customers[i] is the number of the customer that enters the store at the start of the ith minute and all those customers leave after the end of that minute.\nOn some minutes, the bookstore owner is grumpy. You are given a binary array grumpy where grumpy[i] is 1 if the bookstore owner is grumpy during the ith minute, and is 0 otherwise.\nWhen the bookstore owner is grumpy, the customers of that minute are not satisfied, otherwise, they are satisfied.\nThe bookstore owner knows a secret technique to keep themselves not grumpy for minutes consecutive minutes, but can only use it once.\nReturn the maximum number of customers that can be satisfied throughout the day.",
        "examples": [
            "Input: customers = [1,0,1,2,1,1,7,5], grumpy = [0,1,0,1,0,1,0,1], minutes = 3\nOutput: 16\nExplanation: The bookstore owner keeps themselves not grumpy for the last 3 minutes. \nThe maximum number of customers that can be satisfied = 1 + 1 + 1 + 1 + 7 + 5 = 16.",
            "Input: customers = [1], grumpy = [0], minutes = 1\nOutput: 1"
        ],
        "constraints": "n == customers.length == grumpy.length\n1 <= minutes <= n <= 2 * 104\n0 <= customers[i] <= 1000\ngrumpy[i] is either 0 or 1.",
        "oracle_code": "class Solution {\npublic:\n    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int minutes) {\n       int count = 0; \n       for(int i=0; i<customers.size(); i++) if(grumpy[i] == 0) count+= customers[i]; \n       for(int i=0; i<customers.size(); i++) customers[i] *= grumpy[i]; \n       int max = 0, temp = 0; \n       for(int i=0; i<minutes; i++) temp += customers[i]; \n       if(max < temp) max = temp; \n       for(int i=minutes; i<customers.size(); i++) {\n           temp -= customers[i - minutes]; temp += customers[i]; \n           if(max < temp) max = temp; \n       }\n\n       return count + max; \n\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhenever the shopowner is not grumpy, the customers are added irrespective of when the minutes are, so add the customers to ans whenever he is not grumpy. Now change customers to 0 whenever the shop owner is not grumpy. \\nNow the question is changed to the maximum sum of subarray with window size minutes. (standard sliding window problem)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nPlease upvote if you find it helpful \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int minutes) {\\n       int count = 0; \\n       for(int i=0; i<customers.size(); i++) if(grumpy[i] == 0) count+= customers[i]; \\n       for(int i=0; i<customers.size(); i++) customers[i] *= grumpy[i]; \\n       int max = 0, temp = 0; \\n       for(int i=0; i<minutes; i++) temp += customers[i]; \\n       if(max < temp) max = temp; \\n       for(int i=minutes; i<customers.size(); i++) {\\n           temp -= customers[i - minutes]; temp += customers[i]; \\n           if(max < temp) max = temp; \\n       }\\n\\n       return count + max; \\n\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "== and = confusion",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int minutes) {\n       int count = 0;\n       for(int i=0; i<customers.size(); i++) if(grumpy[i] = 0) count+= customers[i];\n       for(int i=0; i<customers.size(); i++) customers[i] *= grumpy[i];\n       int max = 0, temp = 0;\n       for(int i=0; i<minutes; i++) temp += customers[i];\n       if(max = temp) max = temp; \n       for(int i=minutes; i<customers.size(); i++) {\n           temp -= customers[i - minutes]; temp += customers[i]; \n           if(max = temp=) max = temp; \n       }\n\n       return count + max;\n\n    }\n};\n"
    },
    {
        "slug": "reverse-vowels-of-a-string",
        "description": "Given a string s, reverse only all the vowels in the string and return it.\nThe vowels are 'a', 'e', 'i', 'o', and 'u', and they can appear in both lower and upper cases, more than once.",
        "examples": [
            "Input: s = \"hello\"\nOutput: \"holle\"",
            "Input: s = \"leetcode\"\nOutput: \"leotcede\""
        ],
        "constraints": "1 <= s.length <= 3 * 105\ns consist of printable ASCII characters.",
        "oracle_code": "class Solution {\npublic:\n    string reverseVowels(string s) {\n        \n        vector<char> v;\n        for(int i = 0 ; i < s.length(); i++)\n        {\n            if(s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u'\n              || s[i] == 'A' || s[i] == 'E' || s[i] == 'O' || s[i] == 'I' || s[i] == 'U')\n                v.push_back(s[i]);\n        }\n        reverse(v.begin(), v.end());\n        int rev = 0;\n        for(int i = 0 ; i < s.length(); i++)\n        {\n            if(s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u'\n              || s[i] == 'A' || s[i] == 'E' || s[i] == 'O' || s[i] == 'I' || s[i] == 'U'){\n                s[i] = v[rev];\n                rev++;\n            }\n        }\n        return s;\n    }\n};",
        "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        \\n        vector<char> v;\\n        for(int i = 0 ; i < s.length(); i++)\\n        {\\n            if(s[i] == \\'a\\' || s[i] == \\'e\\' || s[i] == \\'i\\' || s[i] == \\'o\\' || s[i] == \\'u\\'\\n              || s[i] == \\'A\\' || s[i] == \\'E\\' || s[i] == \\'O\\' || s[i] == \\'I\\' || s[i] == \\'U\\')\\n                v.push_back(s[i]);\\n        }\\n        reverse(v.begin(), v.end());\\n        int rev = 0;\\n        for(int i = 0 ; i < s.length(); i++)\\n        {\\n            if(s[i] == \\'a\\' || s[i] == \\'e\\' || s[i] == \\'i\\' || s[i] == \\'o\\' || s[i] == \\'u\\'\\n              || s[i] == \\'A\\' || s[i] == \\'E\\' || s[i] == \\'O\\' || s[i] == \\'I\\' || s[i] == \\'U\\'){\\n                s[i] = v[rev];\\n                rev++;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "== and = confusion",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    string reverseVowels(string s) {\n        \n        vector<char> v;\n        for(int i = 0 ; i < s.length(); i++)\n        {\n            if(s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u'\n              || s[i] == 'A' || s[i] == 'E' || s[i] == 'O' || s[i] == 'I' || s[i] == 'U')\n                v.push_back(s[i]);\n        }\n        reverseString(v);\n        int rev = 0;\n        for(int i = 0 ; i < s.length(); i++)\n        {\n            if(s[i] = 'a' || s[i] = 'e' || s[i] = 'i' || s[i] = 'o' || s[i] = 'u'\n              || s[i] = 'A' || s[i] = 'E' || s[i] = 'O' || s[i] = 'I' || s[i] = 'U'){\n                s[i] = v[rev];\n                rev++;\n            }\n        }\n        return s;\n    }\n};\n"
    },
    {
        "slug": "find-the-longest-valid-obstacle-course-at-each-position",
        "description": "You want to build some obstacle courses. You are given a 0-indexed integer array obstacles of length n, where obstacles[i] describes the height of the ith obstacle.\nFor every index i between 0 and n - 1 (inclusive), find the length of the longest obstacle course in obstacles such that:\n\nYou choose any number of obstacles between 0 and i inclusive.\nYou must include the ith obstacle in the course.\nYou must put the chosen obstacles in the same order as they appear in obstacles.\nEvery obstacle (except the first) is taller than or the same height as the obstacle immediately before it.\n\nReturn an array ans of length n, where ans[i] is the length of the longest obstacle course for index i as described above.",
        "examples": [
            "Input: obstacles = [1,2,3,2]\nOutput: [1,2,3,3]\nExplanation: The longest valid obstacle course at each position is:\n- i = 0: [1], [1] has length 1.\n- i = 1: [1,2], [1,2] has length 2.\n- i = 2: [1,2,3], [1,2,3] has length 3.\n- i = 3: [1,2,3,2], [1,2,2] has length 3.",
            "Input: obstacles = [2,2,1]\nOutput: [1,2,1]\nExplanation: The longest valid obstacle course at each position is:\n- i = 0: [2], [2] has length 1.\n- i = 1: [2,2], [2,2] has length 2.\n- i = 2: [2,2,1], [1] has length 1.",
            "Input: obstacles = [3,1,5,6,4,2]\nOutput: [1,1,2,3,2,2]\nExplanation: The longest valid obstacle course at each position is:\n- i = 0: [3], [3] has length 1.\n- i = 1: [3,1], [1] has length 1.\n- i = 2: [3,1,5], [3,5] has length 2. [1,5] is also valid.\n- i = 3: [3,1,5,6], [3,5,6] has length 3. [1,5,6] is also valid.\n- i = 4: [3,1,5,6,4], [3,4] has length 2. [1,4] is also valid.\n- i = 5: [3,1,5,6,4,2], [1,2] has length 2."
        ],
        "constraints": "n == obstacles.length\n1 <= n <= 105\n1 <= obstacles[i] <= 107",
        "oracle_code": "class Solution {\npublic:\n    vector<int> longestObstacleCourseAtEachPosition(vector<int>& nums) {\n        \n        int n = nums.size();\n        \n        // lis store elements of longest increasing subsequence till ith\n        \n        vector<int> lis;\n        \n        // ans[i] store, no of elements satisfying the condition including ith\n        \n        vector<int> ans;\n\n        for(int i = 0; i < n; i++)\n        {\n            int idx = upper_bound(lis.begin(), lis.end(), nums[i]) - lis.begin();\n                \n            ans.push_back(idx + 1);\n            \n            if(idx == lis.size())\n                lis.push_back(nums[i]);\n            \n            else\n            {\n                lis[idx] = nums[i];\n            }\n        }\n        \n        return ans;\n    }\n};",
        "content": "* ***Binary Search***\\n\\n* ***Time Complexity :- O(NlogN)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> longestObstacleCourseAtEachPosition(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        // lis store elements of longest increasing subsequence till ith\\n        \\n        vector<int> lis;\\n        \\n        // ans[i] store, no of elements satisfying the condition including ith\\n        \\n        vector<int> ans;\\n\\n        for(int i = 0; i < n; i++)\\n        {\\n            int idx = upper_bound(lis.begin(), lis.end(), nums[i]) - lis.begin();\\n                \\n            ans.push_back(idx + 1);\\n            \\n            if(idx == lis.size())\\n                lis.push_back(nums[i]);\\n            \\n            else\\n            {\\n                lis[idx] = nums[i];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
        "level": "hard",
        "type": [
            "indexing error",
            "colon missing"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    vector<int> longestObstacleCourseAtEachPosition(vector<int>& nums) {\n        \n        int n = nums.size();\n        \n        // lis store elements of longest increasing subsequence till ith\n        \n        vector<int> lis;\n        \n        // ans[i] store, no of elements satisfying the condition including ith\n        \n        vector<int> ans;\n\n        for(int i = 0; i <= n; i++)\n        {\n            int idx = upper_bound(lis.begin(), lis.end(), nums[i]) - lis.begin();\n                \n            ans.push_back(idx + 1);\n            \n            if(idx = lis.size())\n                lis.push_back(nums[i]);\n            \n            else\n            {\n                lis[idx] = nums[i];\n            }\n        }\n        \n        return ans;\n    }\n};\n"
    },
    {
        "slug": "find-the-minimum-and-maximum-number-of-nodes-between-critical-points",
        "description": "A critical point in a linked list is defined as either a local maxima or a local minima.\nA node is a local maxima if the current node has a value strictly greater than the previous node and the next node.\nA node is a local minima if the current node has a value strictly smaller than the previous node and the next node.\nNote that a node can only be a local maxima/minima if there exists both a previous node and a next node.\nGiven a linked list head, return an array of length 2 containing [minDistance, maxDistance] where minDistance is the minimum distance between any\u00a0two distinct critical points and maxDistance is the maximum distance between any\u00a0two distinct critical points. If there are fewer than two critical points, return [-1, -1].",
        "examples": [
            "Input: head = [3,1]\nOutput: [-1,-1]\nExplanation: There are no critical points in [3,1].",
            "Input: head = [5,3,1,2,5,1,2]\nOutput: [1,3]\nExplanation: There are three critical points:\n- [5,3,1,2,5,1,2]: The third node is a local minima because 1 is less than 3 and 2.\n- [5,3,1,2,5,1,2]: The fifth node is a local maxima because 5 is greater than 2 and 1.\n- [5,3,1,2,5,1,2]: The sixth node is a local minima because 1 is less than 5 and 2.\nThe minimum distance is between the fifth and the sixth node. minDistance = 6 - 5 = 1.\nThe maximum distance is between the third and the sixth node. maxDistance = 6 - 3 = 3.",
            "Input: head = [1,3,2,2,3,2,2,2,7]\nOutput: [3,3]\nExplanation: There are two critical points:\n- [1,3,2,2,3,2,2,2,7]: The second node is a local maxima because 3 is greater than 1 and 2.\n- [1,3,2,2,3,2,2,2,7]: The fifth node is a local maxima because 3 is greater than 2 and 2.\nBoth the minimum and maximum distances are between the second and the fifth node.\nThus, minDistance and maxDistance is 5 - 2 = 3.\nNote that the last node is not considered a local maxima because it does not have a next node."
        ],
        "constraints": "The number of nodes in the list is in the range [2, 105].\n1 <= Node.val <= 105",
        "oracle_code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\n        ios_base::sync_with_stdio(false);\n if(head==NULL || head->next==NULL ||head->next->next==NULL){\n     return {-1,-1};\n }\n        ListNode* temp2=head->next;\n        ListNode* temp3=head->next->next;\n      vector<int>v;\n      int i=2;\n      while(temp3){\n          if((head->val<temp2->val)&&(temp3->val<temp2->val)){\n              v.push_back(i);\n          }\n          else if((head->val>temp2->val)&&(temp3->val>temp2->val)){\n              v.push_back(i);\n          }\n          i++;\n          head=head->next;\n          temp2=temp2->next;\n          temp3=temp3->next;\n      }\n      if(v.size()<2){\n           return {-1,-1};\n      }\n      int mini=INT_MAX;\n      for(int i=1;i<v.size();i++){\n          mini=min(mini,(v[i]-v[i-1]));\n      }\n        return {mini,(v[v.size()-1]-v[0])};\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhen faced with a problem involving linked lists, the first intuition should be to think about how to traverse the list efficiently to extract the required information.\\n\\nIn the case of this problem, the required information is the minimum and maximum distance between any two critical points in the list. A critical point is defined as a node where the value is either the maximum or minimum among its adjacent nodes.\\n\\nTo solve this problem, we need to traverse the list and identify the critical points. Once we have the critical points, we can calculate the distances between them and find the minimum and maximum distances.\\n\\nTherefore, the first intuition for this problem should be to think about how to traverse the list and identify critical points efficiently. We can then use this information to calculate the minimum and maximum distances between critical points.\\n\\n\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe code first checks if the list has at least three nodes, as it is not possible to have a critical point with less than two adjacent nodes. If the list does not meet this condition, the function returns {-1,-1}.\\n\\nThen, the code initializes three pointers, head, temp2, and temp3. The head pointer is used to traverse the list, while temp2 and temp3 are used to check if the current node is a critical point. The i variable is also initialized to 2, as the first two nodes are not considered critical points.\\n\\nNext, the code enters a loop that traverses the list using the temp3 pointer. For each node, the code checks if it is a critical point by comparing its value to the values of its adjacent nodes. If it is a critical point, the current value of i is pushed to a vector v.\\n\\nAfter the loop finishes, the code checks if there are at least two critical points in the list. If there are less than two, the function returns {-1,-1}.\\n\\nIf there are at least two critical points, the code calculates the minimum and maximum distances between adjacent critical points. The minimum distance is the minimum difference between the indices of adjacent critical points in the v vector, and the maximum distance is the difference between the indices of the first and last elements in the v vector.\\n\\nFinally, the function returns a vector containing the minimum and maximum distances as its two elements.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this code is O(n), where n is the length of the input singly-linked list. This is because the code only traverses the list once in the while loop, and performs constant time operations (comparisons, pointer assignments, and vector operations) for each node. The vector operations inside the loop take constant time on average, as the vector is not resized during the loop. Therefore, the overall time complexity of the code is O(n).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of this code is O(1) if we ignore the space used by the input linked list. The code only uses a constant amount of extra space to store three pointers (head, temp2, temp3) and a vector v to store the indices of critical points. The size of v is proportional to the number of critical points in the list, which is at most n-2 (where n is the length of the list), as there can be at most one critical point per node except for the first and last nodes. Therefore, the size of v is bounded by O(n), but since the space used by v is not a function of the input size, we consider it as a constant space usage. Therefore, the overall space complexity of the code is O(1).\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        ios_base::sync_with_stdio(false);\\n if(head==NULL || head->next==NULL ||head->next->next==NULL){\\n     return {-1,-1};\\n }\\n        ListNode* temp2=head->next;\\n        ListNode* temp3=head->next->next;\\n      vector<int>v;\\n      int i=2;\\n      while(temp3){\\n          if((head->val<temp2->val)&&(temp3->val<temp2->val)){\\n              v.push_back(i);\\n          }\\n          else if((head->val>temp2->val)&&(temp3->val>temp2->val)){\\n              v.push_back(i);\\n          }\\n          i++;\\n          head=head->next;\\n          temp2=temp2->next;\\n          temp3=temp3->next;\\n      }\\n      if(v.size()<2){\\n           return {-1,-1};\\n      }\\n      int mini=INT_MAX;\\n      for(int i=1;i<v.size();i++){\\n          mini=min(mini,(v[i]-v[i-1]));\\n      }\\n        return {mini,(v[v.size()-1]-v[0])};\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "== and = confusion",
            "conditional statement error"
        ],
        "buggy_code": "\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\n        ios_base::sync_with_stdio(false);\n if(head==NULL || head->next==NULL ||head->next->next==NULL){\n     return {-1,-1};\n }\n        ListNode* temp2=head->next;\n        ListNode* temp3=head->next->next;\n      vector<int>v;\n      int i=2;\n      while(head){\n          if((head->val<temp2->val)&&(temp3->val=temp2->val)){ \n              v.push_back(i);\n          }\n          else if((head->val>temp2->val)&&(temp3->val>temp2->val)){\n              v.push_back(i);\n          }\n          i++;\n          head=head->next;\n          temp2=temp2->next;\n          temp3=temp3->next;\n      }\n      if(v.size()<2){\n           return {-1,-1};\n      }\n      int mini=INT_MAX;\n      for(int i=1;i<v.size();i++){\n          mini=min(mini,(v[i]-v[i-1]));\n      }\n        return {mini,(v[v.size()-1]-v[0])};\n    }\n};\n"
    },
    {
        "slug": "merge-two-binary-trees",
        "description": "You are given two binary trees root1 and root2.\nImagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge the two trees into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of the new tree.\nReturn the merged tree.\nNote: The merging process must start from the root nodes of both trees.",
        "examples": [
            "Input: root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]\nOutput: [3,4,5,5,4,null,7]",
            "Input: root1 = [1], root2 = [1,2]\nOutput: [2,2]"
        ],
        "constraints": "The number of nodes in both trees is in the range [0, 2000].\n-104 <= Node.val <= 104",
        "oracle_code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {\n        if ( t1 && t2 ) {\n            TreeNode * root = new TreeNode(t1->val + t2->val);\n            root->left = mergeTrees(t1->left, t2->left);\n            root->right = mergeTrees(t1->right, t2->right);\n            return root;\n        } else {\n            return t1 ? t1 : t2;\n        }\n    }\n};",
        "content": "\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {\\n        if ( t1 && t2 ) {\\n            TreeNode * root = new TreeNode(t1->val + t2->val);\\n            root->left = mergeTrees(t1->left, t2->left);\\n            root->right = mergeTrees(t1->right, t2->right);\\n            return root;\\n        } else {\\n            return t1 ? t1 : t2;\\n        }\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
        "level": "easy",
        "type": [
            "colon missing",
            "undefined objects"
        ],
        "buggy_code": "\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {\n        if ( t1 && t2 ) {\n            TreeNode * root = new TreeNode(t1->val + t2->val);\n            root->left = mergeTrees(t1->left, t2->left)\n            root->right = mergeTrees(t1->right, t2->right);\n            return root;\n        } else {\n            return t1 ? new TreeNode(t1->val) : new TreeNode(t2->val);\n        }\n    }\n};\n"
    },
    {
        "slug": "score-after-flipping-matrix",
        "description": "You are given an m x n binary matrix grid.\nA move consists of choosing any row or column and toggling each value in that row or column (i.e., changing all 0's to 1's, and all 1's to 0's).\nEvery row of the matrix is interpreted as a binary number, and the score of the matrix is the sum of these numbers.\nReturn the highest possible score after making any number of moves (including zero moves).",
        "examples": [
            "Input: grid = [[0,0,1,1],[1,0,1,0],[1,1,0,0]]\nOutput: 39\nExplanation: 0b1111 + 0b1001 + 0b1111 = 15 + 9 + 15 = 39",
            "Input: grid = [[0]]\nOutput: 1"
        ],
        "constraints": "m == grid.length\nn == grid[i].length\n1 <= m, n <= 20\ngrid[i][j] is either 0 or 1.",
        "oracle_code": "class Solution {\npublic:\n    void fliprow(int &r,vector<vector<int>>& grid) //function to toggle row\n    {\n        for(int i=0; i<grid[0].size(); i++){\n            grid[r][i]=1-grid[r][i];\n        }\n    }\n\n    void flipcol(int &c,vector<vector<int>>& grid){ //function to toggle column\n        for(int j=0; j<grid.size(); j++){\n            grid[j][c]=1-grid[j][c];\n        }\n    }\n\n    int matrixScore(vector<vector<int>>& grid) {\n        int n=grid.size();\n        int m=grid[0].size();\n//Making the MSB to 1, all values in column 0 should be 1 to get max value\n        for(int i=0; i<n; i++){\n            if(grid[i][0]==0){    \n                fliprow(i,grid);\n            }\n        }\n//traversing and checking which colums have more zeroes than 1, toggling them too\n        for(int j=0; j<m; j++){\n            int cnt0=0;\n            int cnt1=0;\n            for(int i=0; i<n; i++){\n                if(grid[i][j]==0) cnt0++;\n                else cnt1++;\n            }\n            if(cnt0>cnt1){\n                flipcol(j,grid);\n            }\n        }\n//finally calculating the ans\n        int sum=0;\n        for(int i=0; i<n; i++){\n            for(int j=0; j<m; j++){\n                if(grid[i][j]==1){\n                    sum+= (1<<(m-j-1));\n                }\n            }\n        }\n        return sum;\n        \n\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void fliprow(int &r,vector<vector<int>>& grid) //function to toggle row\\n    {\\n        for(int i=0; i<grid[0].size(); i++){\\n            grid[r][i]=1-grid[r][i];\\n        }\\n    }\\n\\n    void flipcol(int &c,vector<vector<int>>& grid){ //function to toggle column\\n        for(int j=0; j<grid.size(); j++){\\n            grid[j][c]=1-grid[j][c];\\n        }\\n    }\\n\\n    int matrixScore(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n//Making the MSB to 1, all values in column 0 should be 1 to get max value\\n        for(int i=0; i<n; i++){\\n            if(grid[i][0]==0){    \\n                fliprow(i,grid);\\n            }\\n        }\\n//traversing and checking which colums have more zeroes than 1, toggling them too\\n        for(int j=0; j<m; j++){\\n            int cnt0=0;\\n            int cnt1=0;\\n            for(int i=0; i<n; i++){\\n                if(grid[i][j]==0) cnt0++;\\n                else cnt1++;\\n            }\\n            if(cnt0>cnt1){\\n                flipcol(j,grid);\\n            }\\n        }\\n//finally calculating the ans\\n        int sum=0;\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(grid[i][j]==1){\\n                    sum+= (1<<(m-j-1));\\n                }\\n            }\\n        }\\n        return sum;\\n        \\n\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "indexing error",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    void fliprow(int &r,vector<vector<int>>& grid) //function to toggle row\n    {\n        for(int i=0; i<=grid[0].size(); i++){\n            grid[r][i]=1-grid[r][i];\n        }\n    }\n\n    void flipcol(int &c,vector<vector<int>>& grid){ //function to toggle column\n        for(int j=0; j<=grid.size(); j++){\n            grid[j][c]=1-grid[j][c];\n        }\n    }\n\n    int matrixScore(vector<vector<int>>& grid) {\n        int n=grid.size();\n        int m=grid[0].size();\n//Making the MSB to 1, all values in column 0 should be 1 to get max value\n        for(int i=0; i<=n; i++){\n            if(grid[i][0]==0){    \n                fliprow(i,grid);\n            }\n        }\n//traversing and checking which colums have more zeroes than 1, toggling them too\n        for(int j=0; j<=m; j++){\n            int cnt0=0;\n            int cnt1=0;\n            for(int i=0; i<=n; i++){\n                if(grid[i][j]==0) cnt0++;\n                else cnt1++;\n            }\n            if(cnt0>cnt1){\n                flipcol(j,grid);\n            }\n        }\n//finally calculating the ans\n        int sum=0;\n        forEach(int i=0; i<=n; i++){\n            for(int j=0; j<=m; j++){\n                if(grid[i][j]==1){\n                    sum+= (1<<(m-j-1));\n                }\n            }\n        }\n        return sum;\n    }\n};\n"
    },
    {
        "slug": "widest-vertical-area-between-two-points-containing-no-points",
        "description": "Given n points on a 2D plane where points[i] = [xi, yi], Return\u00a0the widest vertical area between two points such that no points are inside the area.\nA vertical area is an area of fixed-width extending infinitely along the y-axis (i.e., infinite height). The widest vertical area is the one with the maximum width.\nNote that points on the edge of a vertical area are not considered included in the area.",
        "examples": [
            "\u200b\n\nInput: points = [[8,7],[9,9],[7,4],[9,7]]\nOutput: 1\nExplanation: Both the red and the blue area are optimal.",
            "Input: points = [[3,1],[9,0],[1,0],[1,4],[5,3],[8,8]]\nOutput: 3"
        ],
        "constraints": "n == points.length\n2 <= n <= 105\npoints[i].length == 2\n0 <= xi, yi\u00a0<= 109",
        "oracle_code": "class Solution {\npublic:\n  int maxWidthOfVerticalArea(vector<vector<int>>& points) {\n    set<int> x;\n    int res = 0;\n    for (auto &p : points)\n        x.insert(p[0]);\n    for (auto it = next(begin(x)); it != end(x); ++it)\n        res = max(res, *it - *prev(it));\n    return res;\n}\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  int maxWidthOfVerticalArea(vector<vector<int>>& points) {\\n    set<int> x;\\n    int res = 0;\\n    for (auto &p : points)\\n        x.insert(p[0]);\\n    for (auto it = next(begin(x)); it != end(x); ++it)\\n        res = max(res, *it - *prev(it));\\n    return res;\\n}\\n};\\n```",
        "level": "medium",
        "type": [
            "indexing error",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n  int maxWidthOfVerticalArea(vector<vector<int>>& points) {\n    set<int> x;\n    int res = 0;\n    for (auto &p : points)\n        x.insert(p[2]);\n    for (auto it = next(begin(x)); it != end(x); ++it)\n        res = max(res, *it - *prev(it));\n    return calculateArea();\n}\nprivate:\n    int calculateArea();\n};\n"
    },
    {
        "slug": "minimum-incompatibility",
        "description": "You are given an integer array nums\u200b\u200b\u200b and an integer k. You are asked to distribute this array into k subsets of equal size such that there are no two equal elements in the same subset.\nA subset's incompatibility is the difference between the maximum and minimum elements in that array.\nReturn the minimum possible sum of incompatibilities of the k subsets after distributing the array optimally, or return -1 if it is not possible.\nA subset is a group integers that appear in the array with no particular order.",
        "examples": [
            "Input: nums = [1,2,1,4], k = 2\nOutput: 4\nExplanation: The optimal distribution of subsets is [1,2] and [1,4].\nThe incompatibility is (2-1) + (4-1) = 4.\nNote that [1,1] and [2,4] would result in a smaller sum, but the first subset contains 2 equal elements.",
            "Input: nums = [6,3,8,1,3,1,2,2], k = 4\nOutput: 6\nExplanation: The optimal distribution of subsets is [1,2], [2,3], [6,8], and [1,3].\nThe incompatibility is (2-1) + (3-2) + (8-6) + (3-1) = 6.",
            "Input: nums = [5,3,3,6,3,3], k = 3\nOutput: -1\nExplanation: It is impossible to distribute nums into 3 subsets where no two elements are equal in the same subset."
        ],
        "constraints": "1 <= k <= nums.length <= 16\nnums.length is divisible by k\n1 <= nums[i] <= nums.length",
        "oracle_code": "class Solution {\npublic:\n    const int inf = 0x3f3f3f3f;\n    int minimumIncompatibility(vector<int>& nums, int k) {\n      int n = nums.size();\n      int sz = n/k; // size of every group\n      //dp(mask, i) select mask, pre select i\n      //if (bit set of mask) == sz, select first available\n      //else select first after i available\n      sort(nums.begin(), nums.end());\n      int dp[1<<n][n];\n      memset(dp, inf, sizeof(dp));\n      for (int i = 0; i < n; ++i) { dp[0][i] = 0; }\n      for (int m = 0; m < (1<<n)-1; ++m) {\n        int cnt = __builtin_popcount(m);\n        for (int i = 0; i < n; ++i) {\n          if (dp[m][i] == inf) { continue; }\n          if (cnt%sz == 0) {\n            int j = __builtin_ffs(~m)-1;\n            dp[m|(1<<j)][j] = min(dp[m|(1<<j)][j],dp[m][i]);\n          } else {\n            for (int j = i+1; j < n; ++j) {\n              if (m&(1<<j) || nums[j] == nums[i]) { continue; }\n              dp[m|(1<<j)][j] = min(dp[m|(1<<j)][j],dp[m][i]+nums[j]-nums[i]);\n            }\n          }\n        }\n      }\n      return dp[(1<<n)-1][n-1] == inf? -1: dp[(1<<n)-1][n-1];\n    }\n};",
        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    const int inf = 0x3f3f3f3f;\\n    int minimumIncompatibility(vector<int>& nums, int k) {\\n      int n = nums.size();\\n      int sz = n/k; // size of every group\\n      //dp(mask, i) select mask, pre select i\\n      //if (bit set of mask) == sz, select first available\\n      //else select first after i available\\n      sort(nums.begin(), nums.end());\\n      int dp[1<<n][n];\\n      memset(dp, inf, sizeof(dp));\\n      for (int i = 0; i < n; ++i) { dp[0][i] = 0; }\\n      for (int m = 0; m < (1<<n)-1; ++m) {\\n        int cnt = __builtin_popcount(m);\\n        for (int i = 0; i < n; ++i) {\\n          if (dp[m][i] == inf) { continue; }\\n          if (cnt%sz == 0) {\\n            int j = __builtin_ffs(~m)-1;\\n            dp[m|(1<<j)][j] = min(dp[m|(1<<j)][j],dp[m][i]);\\n          } else {\\n            for (int j = i+1; j < n; ++j) {\\n              if (m&(1<<j) || nums[j] == nums[i]) { continue; }\\n              dp[m|(1<<j)][j] = min(dp[m|(1<<j)][j],dp[m][i]+nums[j]-nums[i]);\\n            }\\n          }\\n        }\\n      }\\n      return dp[(1<<n)-1][n-1] == inf? -1: dp[(1<<n)-1][n-1];\\n    }\\n};\\n```",
        "level": "hard",
        "type": [
            "indexing error",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    const int inf = 0x3f3f3f3f;\n    int minimumIncompatibility(vector<int>& nums, int k) {\n      int n = nums.size();\n      int sz = n/k; // size of every group\n      sort(nums.begin(), nums.end());\n      int dp[1<<n][n+1];  \n      memset(dp, inf, sizeof(dp));\n      for (int i = 0; i <= n; ++i) { dp[0][i] = 0; }  \n      for (int m = 0; m < (1<<n)-1; ++m) {\n        int cnt = __builtin_popcount(m);\n        for (int i = 0; i <= n; ++i) {  \n          if (dp[m][i] == inf) { continue; }\n          if (cnt%sz == 0) {\n            int j = __builtin_ffs(~m)-1;\n            dp[m|(1<<j)][j] = min(dp[m|(1<<j)][j],dp[m][i]);\n          } else {\n            for (int j = i+1; j <= n; ++j) { \n              if (m&(1<<j) && nums[j] == nums[i]) { continue; } \n              dp[m|(1<<j)][j] = min(dp[m|(1<<j)][j],dp[m][i]+nums[j]-nums[i]);\n            }\n          }\n        }\n      }\n      return dp[(1<<n)-1][n-1] == inf? -1: dp[(1<<n)-1][n-1];\n    }\n}] == inf? :dp[(1<<);  \n\n"
    },
    {
        "slug": "remove-outermost-parentheses",
        "description": "A valid parentheses string is either empty \"\", \"(\" + A + \")\", or A + B, where A and B are valid parentheses strings, and + represents string concatenation.\n\nFor example, \"\", \"()\", \"(())()\", and \"(()(()))\" are all valid parentheses strings.\n\nA valid parentheses string s is primitive if it is nonempty, and there does not exist a way to split it into s = A + B, with A and B nonempty valid parentheses strings.\nGiven a valid parentheses string s, consider its primitive decomposition: s = P1 + P2 + ... + Pk, where Pi are primitive valid parentheses strings.\nReturn s after removing the outermost parentheses of every primitive string in the primitive decomposition of s.",
        "examples": [
            "Input: s = \"(()())(())\"\nOutput: \"()()()\"\nExplanation: \nThe input string is \"(()())(())\", with primitive decomposition \"(()())\" + \"(())\".\nAfter removing outer parentheses of each part, this is \"()()\" + \"()\" = \"()()()\".",
            "Input: s = \"(()())(())(()(()))\"\nOutput: \"()()()()(())\"\nExplanation: \nThe input string is \"(()())(())(()(()))\", with primitive decomposition \"(()())\" + \"(())\" + \"(()(()))\".\nAfter removing outer parentheses of each part, this is \"()()\" + \"()\" + \"()(())\" = \"()()()()(())\".",
            "Input: s = \"()()\"\nOutput: \"\"\nExplanation: \nThe input string is \"()()\", with primitive decomposition \"()\" + \"()\".\nAfter removing outer parentheses of each part, this is \"\" + \"\" = \"\"."
        ],
        "constraints": "1 <= s.length <= 105\ns[i] is either '(' or ')'.\ns is a valid parentheses string.",
        "oracle_code": "class Solution {\npublic:\n    string removeOuterParentheses(string s) {\n        stack<char> st;\n        string res=\"\";\n        for(int i=0;i<s.size();i++){\n            if(s[i]=='(' && st.empty()){\n                st.push(s[i]);\n            }\n            else if(s[i]=='('){\n                st.push(s[i]);\n                res+=s[i];\n            }\n            else{\n                st.pop();\n                if(st.size()){\n                    res+=s[i];\n                }\n            }\n        }\n        return res;\n    }\n};",
        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        stack<char> st;\\n        string res=\"\";\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'(\\' && st.empty()){\\n                st.push(s[i]);\\n            }\\n            else if(s[i]==\\'(\\'){\\n                st.push(s[i]);\\n                res+=s[i];\\n            }\\n            else{\\n                st.pop();\\n                if(st.size()){\\n                    res+=s[i];\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "colon missing",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    string removeOuterParentheses(string s) {\n        stack<char> st;\n        string res=\"\";\n        for(int i=0;i<s.size();i++)\n            if(s[i]=='(' && st.empty())\n                st.push(s[i]);\n            else if(s[i]=='(')\n                st.push(s[i]);\n                res+=s[i];\n            else{\n                st.pop();\n                if(st.size())\n                    res+=s[i];\n                }\n        undfinedObject }\n        return res;\n    }\n};\n\n"
    },
    {
        "slug": "largest-substring-between-two-equal-characters",
        "description": "Given a string s, return the length of the longest substring between two equal characters, excluding the two characters. If there is no such substring return -1.\nA substring is a contiguous sequence of characters within a string.",
        "examples": [
            "Input: s = \"aa\"\nOutput: 0\nExplanation: The optimal substring here is an empty substring between the two 'a's.",
            "Input: s = \"abca\"\nOutput: 2\nExplanation: The optimal substring here is \"bc\".",
            "Input: s = \"cbzxy\"\nOutput: -1\nExplanation: There are no characters that appear twice in s."
        ],
        "constraints": "1 <= s.length <= 300\ns contains only lowercase English letters.",
        "oracle_code": "class Solution {\npublic:\n    int maxLengthBetweenEqualCharacters(string s) {\n        int v[26];\n        memset(v,-1,sizeof v);\n        int ans=-1;\n        for(int i=0;i<s.size();i++){\n            if(v[s[i]-'a']==-1){\n                v[s[i]-'a']=i;\n            }\n            int res=i-v[s[i]-'a']-1;\n            ans=max(ans,res);\n        }\n        return ans;\n    }\n};",
        "content": "# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxLengthBetweenEqualCharacters(string s) {\\n        int v[26];\\n        memset(v,-1,sizeof v);\\n        int ans=-1;\\n        for(int i=0;i<s.size();i++){\\n            if(v[s[i]-\\'a\\']==-1){\\n                v[s[i]-\\'a\\']=i;\\n            }\\n            int res=i-v[s[i]-\\'a\\']-1;\\n            ans=max(ans,res);\\n        }\\n        return ans;\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "unclosed string",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    int maxLengthBetweenEqualCharacters(string s) {\n        int v[26];\n        memset(v,-1,sizeof v);\n        int ans=-1;\n        for(int i=0;i<s.size();i++){\n            if(v[s[i]-'a']==-1){\n                v[s[i]-'a' \"=i;\n            }\n            int res= computeResult(i, v, s); \n            ans=max(ans,res);\n        }\n        return ans;\n    }\n};\n"
    },
    {
        "slug": "lru-cache",
        "description": "Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.\nImplement the LRUCache class:\n\nLRUCache(int capacity) Initialize the LRU cache with positive size capacity.\nint get(int key) Return the value of the key if the key exists, otherwise return -1.\nvoid put(int key, int value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key.\n\nThe functions get and put must each run in O(1) average time complexity.",
        "examples": [
            "Input\n[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"]\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\nOutput\n[null, null, null, 1, null, -1, null, -1, 3, 4]\n\nExplanation\nLRUCache lRUCache = new LRUCache(2);\nlRUCache.put(1, 1); // cache is {1=1}\nlRUCache.put(2, 2); // cache is {1=1, 2=2}\nlRUCache.get(1);    // return 1\nlRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}\nlRUCache.get(2);    // returns -1 (not found)\nlRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}\nlRUCache.get(1);    // return -1 (not found)\nlRUCache.get(3);    // return 3\nlRUCache.get(4);    // return 4"
        ],
        "constraints": "1 <= capacity <= 3000\n0 <= key <= 104\n0 <= value <= 105\nAt most 2 * 105 calls will be made to get and put.",
        "oracle_code": "class LRUCache {\npublic:\nclass node\n{\n  public:\n  int key;\n  int val;\n  node* next;\n  node* prev;\n  node(int _key,int _val)\n  {\n    key = _key;\n    val = _val;\n  }\n};\nnode* head = new node(-1,-1);\nnode* tail = new node(-1,-1);\n\nint size;\nunordered_map<int,node*>mpp;\n    LRUCache(int capacity) {\n       size = capacity; \n       head->next = tail;\n       tail->prev = head;  \n    }\n\n    void addNode(node* newNode){\n       \n       node* temp = head->next;\n       newNode->next = temp;\n       newNode->prev = head;\n       head->next = newNode;\n       temp->prev = newNode;\n    }\n\n    void deleteNode(node* delNode){\n         \n       node* delprev = delNode->prev;\n       node* delnext = delNode->next;\n       delprev->next = delnext;\n       delnext->prev = delprev;\n    }\n    \n    int get(int _key) {\n        \n        if(mpp.count(_key))\n        {\n          node* nde = mpp[_key];\n          int curr = nde->val;\n          mpp.erase(_key);\n          deleteNode(nde);\n          addNode(nde);\n          mpp[_key] = head->next;\n          return curr;\n        }\n        return -1;\n    }\n    \n    void put(int _key, int value) {\n        \n        if(mpp.count(_key))\n        {\n           node* nde = mpp[_key];\n           mpp.erase(_key);\n           deleteNode(nde);\n        }\n        if(mpp.size()==size)\n        {\n           mpp.erase(tail->prev->key);\n           deleteNode(tail->prev);\n        }\n        addNode(new node(_key,value));\n        mpp[_key] = head->next;\n    }\n};",
        "content": "# PLEASE DO UPVOTE!!!!!\\n\\n**CONNECT WITH ME ON LINKEDIN :  https://www.linkedin.com/in/md-kamran-55b98521a/**\\n\\n## INTUITION\\nTo Implement LRU(Least recently used), we need to have a track of the usage of the keys, in the order of there usage, as we have a limited capacity we cant extend our capacity beyond \"capacity\", so we always we will take out those values which has\\'nt been acccess in the recent time.So, we have to think of something that can kind of sort our keys according to usage on the go, the best Data Structure for this purpose is Doubly linked List.\\n                             A Doubly linked list will have a Head node as well as a tail node, and whenever a key is used we will place it just next to the head node,in this fashions, the one\\'s which are closer to head are the most recently used ones, and as we go closer to the tail node, those are the less recently used ones while the node just previous to tail is the \"LEAST RECENTLY USED\". \\nSo whenever we add a key or use a key(get()), we will move it right after the head node, and whenever we call the (put() function), if size if greater we have to delete the LRU node, if key is not present, (if present then too we will delete that node so as to update the value and still move it right after head node), and place new node right after head node.                        \\n\\n\\n**Ask Furthur Doubts in the Comment Section**\\n# Code\\n```\\nclass LRUCache {\\npublic:\\nclass node\\n{\\n  public:\\n  int key;\\n  int val;\\n  node* next;\\n  node* prev;\\n  node(int _key,int _val)\\n  {\\n    key = _key;\\n    val = _val;\\n  }\\n};\\nnode* head = new node(-1,-1);\\nnode* tail = new node(-1,-1);\\n\\nint size;\\nunordered_map<int,node*>mpp;\\n    LRUCache(int capacity) {\\n       size = capacity; \\n       head->next = tail;\\n       tail->prev = head;  \\n    }\\n\\n    void addNode(node* newNode){\\n       \\n       node* temp = head->next;\\n       newNode->next = temp;\\n       newNode->prev = head;\\n       head->next = newNode;\\n       temp->prev = newNode;\\n    }\\n\\n    void deleteNode(node* delNode){\\n         \\n       node* delprev = delNode->prev;\\n       node* delnext = delNode->next;\\n       delprev->next = delnext;\\n       delnext->prev = delprev;\\n    }\\n    \\n    int get(int _key) {\\n        \\n        if(mpp.count(_key))\\n        {\\n          node* nde = mpp[_key];\\n          int curr = nde->val;\\n          mpp.erase(_key);\\n          deleteNode(nde);\\n          addNode(nde);\\n          mpp[_key] = head->next;\\n          return curr;\\n        }\\n        return -1;\\n    }\\n    \\n    void put(int _key, int value) {\\n        \\n        if(mpp.count(_key))\\n        {\\n           node* nde = mpp[_key];\\n           mpp.erase(_key);\\n           deleteNode(nde);\\n        }\\n        if(mpp.size()==size)\\n        {\\n           mpp.erase(tail->prev->key);\\n           deleteNode(tail->prev);\\n        }\\n        addNode(new node(_key,value));\\n        mpp[_key] = head->next;\\n    }\\n};\\n\\n```\\n![b62ab1be-232a-438f-9524-7d8ca4dbd5fe_1675328166.1161866.png](https://assets.leetcode.com/users/images/8d5343b1-0eb4-4111-a914-40ce968fd034_1675389764.2273676.png)",
        "level": "medium",
        "type": [
            "undefined keywords from other languages",
            "variable value error"
        ],
        "buggy_code": "\nclass LRUCache {\npublic:\nclass node\n{\n  public:\n  int key;\n  int val;\n  node* next;\n  node* prev;\n  node(int _key,int _val)\n  {\n    key = _key;\n    val = _val;\n  }\n};\nnode* head = new node(-1,-1);\nnode* tail = new node(-1,-1);\n\nint size;\nunordered_map<int,node*>mpp;\n    LRUCache(int capacity) {\n       size = capacity; \n       head->next = tail;\n       tail->prev = head;  \n    }\n\n    void addNode(node* newNode){\n       \n       node* temp = head->next;\n       newNode->next = temp;\n       newNode->prev = head;\n       head->next = newNode;\n       temp->prev = newNode;\n    }\n\n    void deleteNode(node* delNode){\n         \n       node* delprev = delNode->prev;\n       node* delnext = delNode->next;\n       delprev->next = delnext;\n       delnext->prev = delprev;\n    }\n    \n    int get(int _key) {\n        \n        if(mpp.count(_key))\n        {\n          node* nde = mpp[_key];\n          int curr = nde->val;\n          mpp.erase(_key);\n          deleteNode(nde);\n          addNode(nde);\n          mpp[_key] = head->next;\n          return curr;\n        }\n        return -1;\n    }\n    \n    void put(int _key, int value) {\n        \n        if(mpp.count(_key))\n        {\n           node* nde = mpp[_key];\n           mpp.erase(_key);\n           deleteNode(nde);\n        }\n        if(mpp.size()==size)\n        {\n           mpp.erase(tail->prev->key);\n           deleteNode(tail->prev);\n        }\n        addNode(new node(_key,var));\n        mpp[_key] = tail->next;\n    }\n};\n"
    },
    {
        "slug": "sort-list",
        "description": "Given the head of a linked list, return the list after sorting it in ascending order.",
        "examples": [
            "Input: head = [4,2,1,3]\nOutput: [1,2,3,4]",
            "Input: head = [-1,5,3,4,0]\nOutput: [-1,0,3,4,5]",
            "Input: head = []\nOutput: []"
        ],
        "constraints": "The number of nodes in the list is in the range [0, 5 * 104].\n-105 <= Node.val <= 105",
        "oracle_code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* sortList(ListNode* head) {\n        vector<int>vec1;\n    ListNode*temp= head;\n    while(temp!=NULL){\nvec1.push_back(temp->val);\ntemp= temp->next;\n    }\n    sort(vec1.begin(),vec1.end());\n    ListNode*curr= head;\n   for(int i=0;i<vec1.size();i++){\n       curr->val=vec1[i];\n       curr= curr->next;\n   }\n   return head;\n    }\n    \n\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* sortList(ListNode* head) {\\n        vector<int>vec1;\\n    ListNode*temp= head;\\n    while(temp!=NULL){\\nvec1.push_back(temp->val);\\ntemp= temp->next;\\n    }\\n    sort(vec1.begin(),vec1.end());\\n    ListNode*curr= head;\\n   for(int i=0;i<vec1.size();i++){\\n       curr->val=vec1[i];\\n       curr= curr->next;\\n   }\\n   return head;\\n    }\\n    \\n\\n};\\n\\n```",
        "level": "medium",
        "type": [
            "conditional statement error",
            "undefined objects"
        ],
        "buggy_code": "\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* sortList(ListNode* head) {\n        vector<int>vec1;\n    ListNode*temp= nullptr;\n    while(temp!=NULL){\nvec1.push_back(temp->val);\ntemp= temp->next;\n    }\n    sort(vec1.begin(),vec1.end());\n    ListNode*curr= head;\n   for(int i=0;i<vec1.size();i++){\n       curr->val=vec1[i+1];\n       curr= curr->next;\n   }\n   return head;\n    }\n    \n\n};\n"
    },
    {
        "slug": "buddy-strings",
        "description": "Given two strings s and goal, return true if you can swap two letters in s so the result is equal to goal, otherwise, return false.\nSwapping letters is defined as taking two indices i and j (0-indexed) such that i != j and swapping the characters at s[i] and s[j].\n\nFor example, swapping at indices 0 and 2 in \"abcd\" results in \"cbad\".",
        "examples": [
            "Input: s = \"ab\", goal = \"ba\"\nOutput: true\nExplanation: You can swap s[0] = 'a' and s[1] = 'b' to get \"ba\", which is equal to goal.",
            "Input: s = \"ab\", goal = \"ab\"\nOutput: false\nExplanation: The only letters you can swap are s[0] = 'a' and s[1] = 'b', which results in \"ba\" != goal.",
            "Input: s = \"aa\", goal = \"aa\"\nOutput: true\nExplanation: You can swap s[0] = 'a' and s[1] = 'a' to get \"aa\", which is equal to goal."
        ],
        "constraints": "1 <= s.length, goal.length <= 2 * 104\ns and goal consist of lowercase letters.",
        "oracle_code": "class Solution {\npublic:\n    bool buddyStrings(string s, string p) {\n        int n=s.length(), m=p.length();\n        if(n!=m) return false;\n        \n        vector<int> freq(26,0);\n        \n        int first=-1, second=-1;\n        for(int i=0;i<n;i++){\n            if(s[i] != p[i]){\n                if(first==-1){\n                    first=i;\n                }else if(second==-1){\n                    second=i;\n                }else{\n                    return false; // more than 2 mismatching characters\n                }\n            }\n            freq[s[i]-'a']++;\n        }\n        \n\t\t// similar strings\n        if(first == -1 && second == -1){\n            for(int i=0;i<26;i++) if(freq[i] > 1) return true; // can swap similar characters\n            return false; // all characters occur only once\n        }else if(second == -1){\n            return false; // exactly 1 mismatch\n        }\n        \n        return (s[first]==p[second] && s[second]==p[first]); // check similarity on 2 mismatched indexes\n    }\n};",
        "content": "**Connect with me on LinkedIn**: https://www.linkedin.com/in/abhay5349singh/\\n\\n```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string p) {\\n        int n=s.length(), m=p.length();\\n        if(n!=m) return false;\\n        \\n        vector<int> freq(26,0);\\n        \\n        int first=-1, second=-1;\\n        for(int i=0;i<n;i++){\\n            if(s[i] != p[i]){\\n                if(first==-1){\\n                    first=i;\\n                }else if(second==-1){\\n                    second=i;\\n                }else{\\n                    return false; // more than 2 mismatching characters\\n                }\\n            }\\n            freq[s[i]-\\'a\\']++;\\n        }\\n        \\n\\t\\t// similar strings\\n        if(first == -1 && second == -1){\\n            for(int i=0;i<26;i++) if(freq[i] > 1) return true; // can swap similar characters\\n            return false; // all characters occur only once\\n        }else if(second == -1){\\n            return false; // exactly 1 mismatch\\n        }\\n        \\n        return (s[first]==p[second] && s[second]==p[first]); // check similarity on 2 mismatched indexes\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "== and = confusion",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    bool buddyStrings(string s, string p) {\n        int n=s.length(), m=p.length();\n        if(n!=m) return false;\n        \n        vector<int> freq(26,0);\n        \n        int first=-1, second=-1;\n        for(int i=0;i<n;i++){\n            if(s[i] = p[i]){\n                if(first==-1){\n                    first=i;\n                }else if(second==-1){\n                    second=i;\n                }else{\n                    return false; \n                }\n            }\n            freq[s[i]-'a']++;\n        }\n        \n        if(first == -1 && second == -1){\n            for(int i=0;i<26;i++) if(freq[i] > 1) return true; \n            return false\"false\"; \n        }else if(second == -1){\n            return ; excty1 mismat\n       }\n        \n        ret(s[first]==p[second] && s[second]==p[first]);check similarity on 2 mismatched inde\n    }\n};\n"
    },
    {
        "slug": "add-two-numbers",
        "description": "You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum\u00a0as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.",
        "examples": [
            "Input: l1 = [2,4,3], l2 = [5,6,4]\nOutput: [7,0,8]\nExplanation: 342 + 465 = 807.",
            "Input: l1 = [0], l2 = [0]\nOutput: [0]",
            "Input: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\nOutput: [8,9,9,9,0,0,0,1]"
        ],
        "constraints": "The number of nodes in each linked list is in the range [1, 100].\n0 <= Node.val <= 9\nIt is guaranteed that the list represents a number that does not have leading zeros.",
        "oracle_code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        //initializing tem and temp so that l1 and l2 reamins preserved,\n        //though this isn't needed but it a good practice\n        ListNode* temp=l1;\n        ListNode* tem=l2;\n        ListNode *ans;\n        ListNode *head;\n        int carry=0;\n        int valu;\n        //initiallize the first node of answer\n        int sum=tem->val+temp->val+carry;\n        valu=sum%10;\n        carry=sum/10;\n        ListNode* node =new ListNode(valu);\n        ans=node;\n        head=ans;\n        tem=tem->next;\n        temp=temp->next;\n        while(tem!=NULL && temp!=NULL)\n        {\n            sum=tem->val+temp->val+carry;\n            valu=sum%10;\n            carry=sum/10;\n            ListNode* node =new ListNode(valu);\n            ans->next=node;\n            ans=ans->next;\n            temp=temp->next;\n            tem=tem->next;\n        }\n        //if l1 gets over and there are still some elements in l2\n        if(tem==NULL && temp!=NULL)\n        {\n            while(temp!=NULL)\n            {\n                sum=temp->val+carry;\n                valu=sum%10;\n                carry=sum/10;\n                ListNode* node =new ListNode(valu);\n                ans->next=node;\n                ans=ans->next;\n                temp=temp->next;\n            }\n        }\n        //if l2 gets over and there are still some elements in l1\n        if(tem!=NULL && temp==NULL)\n        {\n            while(tem!=NULL)\n            {\n                sum=tem->val+carry;\n                valu=sum%10;\n                carry=sum/10;\n                ListNode* node =new ListNode(valu);\n                ans->next=node;\n                ans=ans->next;\n                tem=tem->next;\n            }\n        }\n        //if there is still a carry left\n        if(carry!=0)\n        {\n            ListNode* node =new ListNode(carry);\n            ans->next=node;\n        }\n        return head;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe code might seem really complex for the first time, but this only because i have specified every corner case differently, cmon i will give u a walk through my code.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe are just using a variable for the value we want as node\\'s vale and a carry, rest the operation is as simple as we add two numbers.\\n\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        //initializing tem and temp so that l1 and l2 reamins preserved,\\n        //though this isn\\'t needed but it a good practice\\n        ListNode* temp=l1;\\n        ListNode* tem=l2;\\n        ListNode *ans;\\n        ListNode *head;\\n        int carry=0;\\n        int valu;\\n        //initiallize the first node of answer\\n        int sum=tem->val+temp->val+carry;\\n        valu=sum%10;\\n        carry=sum/10;\\n        ListNode* node =new ListNode(valu);\\n        ans=node;\\n        head=ans;\\n        tem=tem->next;\\n        temp=temp->next;\\n        while(tem!=NULL && temp!=NULL)\\n        {\\n            sum=tem->val+temp->val+carry;\\n            valu=sum%10;\\n            carry=sum/10;\\n            ListNode* node =new ListNode(valu);\\n            ans->next=node;\\n            ans=ans->next;\\n            temp=temp->next;\\n            tem=tem->next;\\n        }\\n        //if l1 gets over and there are still some elements in l2\\n        if(tem==NULL && temp!=NULL)\\n        {\\n            while(temp!=NULL)\\n            {\\n                sum=temp->val+carry;\\n                valu=sum%10;\\n                carry=sum/10;\\n                ListNode* node =new ListNode(valu);\\n                ans->next=node;\\n                ans=ans->next;\\n                temp=temp->next;\\n            }\\n        }\\n        //if l2 gets over and there are still some elements in l1\\n        if(tem!=NULL && temp==NULL)\\n        {\\n            while(tem!=NULL)\\n            {\\n                sum=tem->val+carry;\\n                valu=sum%10;\\n                carry=sum/10;\\n                ListNode* node =new ListNode(valu);\\n                ans->next=node;\\n                ans=ans->next;\\n                tem=tem->next;\\n            }\\n        }\\n        //if there is still a carry left\\n        if(carry!=0)\\n        {\\n            ListNode* node =new ListNode(carry);\\n            ans->next=node;\\n        }\\n        return head;\\n    }\\n};\\n\\n```",
        "level": "medium",
        "type": [
            "statement separation",
            "undefined methods"
        ],
        "buggy_code": "\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        //initializing tem and temp so that l1 and l2 reamins preserved,\n        //though this isn't needed but it a good practice\n        ListNode* temp=l1;\n        ListNode* tem=l2;\n        ListNode *ans;\n        ListNode *head;\n        int carry=0;\n        int valu;\n        //initiallize the first node of answer\n        int sum=tem->val+temp->val+carry;\n        valu=sum%10;\n        carry=sum/10;\n        ListNode* node =new ListNode(valu);\n        ans=node;\n        head=ans\n        tem=tem->next;\n        temp=temp->next;\n        while(tem!=NULL && temp!=NULL)\n        {\n            sum=tem->val+temp->val+carry;\n            valu=sum%10;\n            carry=sum/10;\n            ListNode* node =new ListNode(valu);\n            ans->next=node;\n            ans=ans->next;\n            temp=temp->next;\n            tem=tem->next;\n        }\n        //if l1 gets over and there are still some elements in l2\n        if(tem==NULL && temp!=NULL)\n        {\n            while(temp!=NULL)\n            {\n                sum=temp->val+carry;\n                valu=sum%10;\n                carry=sum/10;\n                ListNode* node =new ListNode(valu);\n                ans->next=node;\n                ans=ans->next;\n                temp=temp->next;\n            }\n        }\n        //if l2 gets over and there are still some elements in l1\n        void CopyRestOfL1(ListNode* tem, ListNode* ans, int& carry);\n        \n    }\n    \n    void CopyRestOfL1(ListNode* tem, ListNode* ans, int& carry)\n    {\n        int sum;\n        int valu;\n        while(tem!=NULL)\n        {\n            sum=tem->val+carry;\n            valu=sum%10;\n            carry=sum/10;\n            ListNode* node =new ListNode(valu);\n            ans->next=node;\n            ans=ans->next;\n            tem=tem->next;\n        }\n    }\n};    \n\n"
    },
    {
        "slug": "search-in-a-binary-search-tree",
        "description": "You are given the root of a binary search tree (BST) and an integer val.\nFind the node in the BST that the node's value equals val and return the subtree rooted with that node. If such a node does not exist, return null.",
        "examples": [
            "Input: root = [4,2,7,1,3], val = 2\nOutput: [2,1,3]",
            "Input: root = [4,2,7,1,3], val = 5\nOutput: []"
        ],
        "constraints": "The number of nodes in the tree is in the range [1, 5000].\n1 <= Node.val <= 107\nroot is a binary search tree.\n1 <= val <= 107",
        "oracle_code": "class Solution {\npublic:\n    TreeNode* searchBST(TreeNode* root, int val) {\n       if(root==NULL) \n       return NULL;\n       if(root->val==val)\n       {\n           return root;\n       }\n       if(root->val>val){\n          return  searchBST(root->left,val);\n       }\n        return searchBST(root->right,val);\n    }\n};",
        "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n       if(root==NULL) \\n       return NULL;\\n       if(root->val==val)\\n       {\\n           return root;\\n       }\\n       if(root->val>val){\\n          return  searchBST(root->left,val);\\n       }\\n        return searchBST(root->right,val);\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "statement separation",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    TreeNode* searchBST(TreeNode* root, int val) {\n       if(root==None) \n       return NULL;\n       if(root->val==val);\n       {\n           return root;\n       }\n       if(root->val>val){\n          return  searchBST(root->left,val);\n       }\n        return searchBST(root->right,val);\n    }\n};\n"
    },
    {
        "slug": "shortest-bridge",
        "description": "You are given an n x n binary matrix grid where 1 represents land and 0 represents water.\nAn island is a 4-directionally connected group of 1's not connected to any other 1's. There are exactly two islands in grid.\nYou may change 0's to 1's to connect the two islands to form one island.\nReturn the smallest number of 0's you must flip to connect the two islands.",
        "examples": [
            "Input: grid = [[0,1],[1,0]]\nOutput: 1",
            "Input: grid = [[0,1,0],[0,0,0],[0,0,1]]\nOutput: 2",
            "Input: grid = [[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]]\nOutput: 1"
        ],
        "constraints": "n == grid.length == grid[i].length\n2 <= n <= 100\ngrid[i][j] is either 0 or 1.\nThere are exactly two islands in grid.",
        "oracle_code": "class Solution {\npublic:\n\nint r[4] = {-1 , 0, 1, 0};\nint c[4] = {0 ,1 , 0 , -1};\n\nvoid dfs(int row ,int col , vector<pair<int,int>> &v,vector<vector<int>>&vis,vector<vector<int>>&grid)\n{\n    int n = vis[0].size();\n    vis[row][col] = 1;\n    v.push_back({row , col});\n    for(int i=0; i<4; i++)\n    {\n        int nrow = row + r[i];\n        int ncol = col + c[i];\n\n        if(nrow>=0 and ncol>=0 and nrow<n and ncol<n and vis[nrow][ncol] == 0 and grid[nrow][ncol] == 1)\n        {\n            dfs(nrow , ncol , v , vis , grid);\n        }\n    }\n\n}\n\n    int shortestBridge(vector<vector<int>>& grid) {\n        \n        vector<pair<int,int>> v;\n        vector<pair<int,int>> v1;\n        vector<pair<int,int>> v2;\n        int n = grid.size();\n        vector<vector<int>> vis(n , vector<int>(n , 0));\n        bool flag = 0;\n        for(int i=0; i<n; i++)\n        {\n            for(int j=0; j<n; j++)\n            {\n                if(grid[i][j] == 1 and vis[i][j] == 0)\n                {\n                    dfs(i , j , v , vis, grid);\n                    if(flag == 0)\n                    {\n                        v1 = v;\n                        flag = 1;\n                        v.clear();\n                    }\n                    else\n                    {\n                        v2 = v;\n                    }\n                }\n            \n            }\n           \n        }\n        //printed just to check the co-ordinates****\n        //for(auto it: v1)\n        //{\n        //    cout<<it.first<<\" \"<<it.second<<endl;\n        //}\n        //for(auto it: v2)\n        //{\n        //    cout<<it.first<<\" \"<<it.second<<endl;\n        //}\n        int ans = 1e9;\n\n\n        for(auto it: v1)\n        {\n            int row1 = it.first;\n            int col1 = it.second;\n\n            for(auto itt: v2)\n            {\n                int row2 = itt.first;\n                int col2 = itt.second;\n\n                int dist = abs(row1 - row2) + abs(col1 - col2);\n                dist--;\n                ans = min(ans , dist);\n            }\n        }\n    \n        return ans;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nsimple push all the co-ordinates of the first and second island in two vectors by using dfs and then just calculate the distance between each point to every other point in both the vectors and since n is very small we will not get tle and this solution is accepted.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n**1.Push all the co-ordinates of the first and second island in two vectors\\n2.then calculate the distance between each point to every point \\n3.take the minimum distance \\n4.return the minimum distance**\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\ncomment time complexity in comments \\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\ncomment space complexity in comments \\n# Code\\n```\\nclass Solution {\\npublic:\\n\\nint r[4] = {-1 , 0, 1, 0};\\nint c[4] = {0 ,1 , 0 , -1};\\n\\nvoid dfs(int row ,int col , vector<pair<int,int>> &v,vector<vector<int>>&vis,vector<vector<int>>&grid)\\n{\\n    int n = vis[0].size();\\n    vis[row][col] = 1;\\n    v.push_back({row , col});\\n    for(int i=0; i<4; i++)\\n    {\\n        int nrow = row + r[i];\\n        int ncol = col + c[i];\\n\\n        if(nrow>=0 and ncol>=0 and nrow<n and ncol<n and vis[nrow][ncol] == 0 and grid[nrow][ncol] == 1)\\n        {\\n            dfs(nrow , ncol , v , vis , grid);\\n        }\\n    }\\n\\n}\\n\\n    int shortestBridge(vector<vector<int>>& grid) {\\n        \\n        vector<pair<int,int>> v;\\n        vector<pair<int,int>> v1;\\n        vector<pair<int,int>> v2;\\n        int n = grid.size();\\n        vector<vector<int>> vis(n , vector<int>(n , 0));\\n        bool flag = 0;\\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=0; j<n; j++)\\n            {\\n                if(grid[i][j] == 1 and vis[i][j] == 0)\\n                {\\n                    dfs(i , j , v , vis, grid);\\n                    if(flag == 0)\\n                    {\\n                        v1 = v;\\n                        flag = 1;\\n                        v.clear();\\n                    }\\n                    else\\n                    {\\n                        v2 = v;\\n                    }\\n                }\\n            \\n            }\\n           \\n        }\\n        //printed just to check the co-ordinates****\\n        //for(auto it: v1)\\n        //{\\n        //    cout<<it.first<<\" \"<<it.second<<endl;\\n        //}\\n        //for(auto it: v2)\\n        //{\\n        //    cout<<it.first<<\" \"<<it.second<<endl;\\n        //}\\n        int ans = 1e9;\\n\\n\\n        for(auto it: v1)\\n        {\\n            int row1 = it.first;\\n            int col1 = it.second;\\n\\n            for(auto itt: v2)\\n            {\\n                int row2 = itt.first;\\n                int col2 = itt.second;\\n\\n                int dist = abs(row1 - row2) + abs(col1 - col2);\\n                dist--;\\n                ans = min(ans , dist);\\n            }\\n        }\\n    \\n        return ans;\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "statement separation",
            "variable value error"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n\nint r[4] = {-1 , 0, 1, 0};\nint c[4] = {0 ,1 , 0 , -1};\n\nvoid dfs(int row ,int col , vector<pair<int,int>> &v,vector<vector<int>>&vis,vector<vector<int>>&grid)\n{\n    int n = grid[0].size();\n    vis[row][col] = 1;\n    v.push_back({row , col});\n    for(int i=0; i<4; i++)\n    {\n        int nrow = row + r[i];\n        int ncol = col + c[i];\n\n        if(nrow>=0 and ncol>=0 and nrow<n and ncol<n and vis[nrow][ncol] == 0 and grid[nrow][ncol] == 1);\n        {\n            dfs(nrow , ncol , v , vis , grid);\n        }\n    }\n\n}\n\n    int shortestBridge(vector<vector<int>>& grid) {\n        \n        vector<pair<int,int>> v;\n        vector<pair<int,int>> v1;\n        vector<pair<int,int>> v2;\n        int n = grid.size();\n        vector<vector<int>> vis(n , vector<int>(n , 0));\n        bool flag = 0;\n        for(int i=0; i<n; i++)\n        {\n            for(int j=0; j<n; j++)\n            {\n                if(grid[i][j] == 1 and vis[i][j] == 0)\n                {\n                    dfs(i , j , v , vis, grid);\n                    if(flag == 0)\n                    {\n                        v1 = v;\n                        flag = 1;\n                        v.clear();\n                    }\n                    else\n                    {\n                        v2 = v;\n                    }\n                }\n            \n            }\n           \n        }\n\n        int ans = 1e9;\n\n\n        for(auto it: v1)\n        {\n            int row1 = it.first;\n            int col1 = it.second;\n\n            for(auto itt: v2)\n            {\n                int row2 = itt.first;\n                int col2 = itt.second;\n\n                int dist = abs(row1 - row2)+ab(col1-);\n                ans = min(ans , dist);\n            }\n        }\n    \n        return ans;\n    }\n};\n"
    },
    {
        "slug": "count-of-range-sum",
        "description": "Given an integer array nums and two integers lower and upper, return the number of range sums that lie in [lower, upper] inclusive.\nRange sum S(i, j) is defined as the sum of the elements in nums between indices i and j inclusive, where i <= j.",
        "examples": [
            "Input: nums = [-2,5,-1], lower = -2, upper = 2\nOutput: 3\nExplanation: The three ranges are: [0,0], [2,2], and [0,2] and their respective sums are: -2, -1, 2.",
            "Input: nums = [0], lower = 0, upper = 0\nOutput: 1"
        ],
        "constraints": "1 <= nums.length <= 105\n-231 <= nums[i] <= 231 - 1\n-105 <= lower <= upper <= 105\nThe answer is guaranteed to fit in a 32-bit integer.",
        "oracle_code": "class Solution {\npublic:\n    \n    int countWithMergeSort(vector<long> &sums, int left, int right, int lower, int upper)\n    {\n        int count = 0;\n        \n        if(right - left <= 1)\n        {\n            if(right - left == 1)\n            {\n                return (lower <= sums[left] && sums[left] <= upper);\n            }\n            else\n            {\n                return 0;\n            }\n        }\n        \n        int mid = (left + right)/2;\n        \n        int leftSideSum = countWithMergeSort(sums, left, mid, lower, upper);\n        int rightSideSum = countWithMergeSort(sums, mid, right, lower, upper);\n        \n        \n        int i = left;\n        int j = mid;\n        \n        int n = 0;\n        int m = 0;\n        \n        vector<long> cache(right - left, 0);\n        \n        int k = 0;\n        \n        \n        while(i < mid)\n        {\n            \n\n            while(mid+n < right && sums[mid+n] < sums[i]+lower)\n                {\n                    n++;\n                }\n            \n            while(mid+m < right && sums[mid+m] <= sums[i] + upper)\n                {\n                    m++;\n                }\n            \n            while(j < right && sums[j] < sums[i])\n            {\n                cache[k++] = sums[j++];\n            }\n            \n            cache[k++] = sums[i++];\n            \n            count += m-n;\n        }\n        \n        \n        while(j < right)\n        {\n            cache[k++] = sums[j++];\n        }\n        \n        \n        for(int idx = 0; idx<cache.size(); idx++)\n        {\n            sums[left + idx] = cache[idx];\n        }\n    \n        return leftSideSum + rightSideSum + count;\n        \n    }\n    \n    int countRangeSum(vector<int>& nums, int lower, int upper) {\n        \n        vector<long> prefixSum(nums.size(),0);\n        \n        int n = nums.size();\n        \n        prefixSum[0] = nums[0];\n        \n        for(int i = 1; i<nums.size(); i++)\n        {\n            prefixSum[i] = nums[i] + prefixSum[i-1];\n        }\n        \n        return countWithMergeSort(prefixSum, 0, n, lower, upper);\n    }\n};",
        "content": "Hello, with this post I want to explain the solution to this problem to those who are encountering this problem for the first time (i.e. have not solved any other problems with this pattern), and are **NEW to solving HARD problems** in general. I will be explaining the solution found in this post https://leetcode.com/problems/count-of-range-sum/discuss/1178174/Java-Clean-Merge-Sort-O(N-logN)-Solution-oror-with-detailed-Explanation because this version of the solution applies commonly known concepts which anyone with basic data structures background should be able to grasp **(no BIT, fenwick tree or anything else which usually is not covered in a basic data structures course)**. Moreover, this approach is also applicable to other problems which are linked in the answer, hence it is most suitable for a beginner looking to learn general approaches/patterns.\\n\\nSo, the naive approach, which after some experience with medium problems, particularly like subarray sum etc. should come to one within a few minutes of thinking: Find the array of prefix sums, then use a nested loop to find all the sums which satisfy the given criteria. Of course O(n^2) will give TLE which is why this is HARD. \\n\\nSince I am also a beginner, I thought about it for a while and then moved on to reading a solution to understand what was the next step.\\n\\nI suppose for someone experienced, they may try some patterns with which n^2 problems are simplified, like DP or divide-and-conquer. The point of the hard problem is to start teaching you to inculcate this thinking of approaches when TLE after the naive solution is reached. So here, the mental question that should come to one\\'s mind is, \\n\\n* For DP: If I know the solution to nums[start:i-1], can I calculate the solution to nums[start:i]?\\n* For divide-and-conquer: If I know the solution to nums[start:mid] and nums[mid+1:end] (where mid = (start+end)/2 and end is the length of the array), can I calculate the solution to nums[start:end]?\\n\\nIn this case, it turns out that there is a divide and conquer solution. The solution is similar to **merge sort**.\\n\\nTake the PREFIX SUM array (and not the original array). Let this be called **sums**. \\n\\nIf we have the solution to the left and right halves of the array, we can find the solution to the complete array by finding suitable pairs of prefix sums, one from the left half and the other from the right half, and adding these to the solution from the left and right halves of the array.\\n\\nNow I will quote the crucial step from here: https://leetcode.com/problems/count-of-range-sum/discuss/1178174/Java-Clean-Merge-Sort-O(N-logN)-Solution-oror-with-detailed-Explanation\\n\\nThe merge sort based solution counts the answer while doing the merge. During the merge stage, we have already sorted the left half [start, mid) and right half [mid, end). We then iterate through the left half with index i. For each i, we need to find two indices k and j in the right half where\\n\\n* j is the first index satisfy sums[j] - sums[i] > upper and\\n* k is the first index satisfy sums[k] - sums[i] >= lower.\\n\\nThen the number of sums in [lower, upper] is j-k.\\n\\nTo understand this, consider any prefix sum after x elements. Consider another prefix sum after y elements such that x <= y. Then, if we know sums[x], then for x and y to form a range with a sum within the lower and upper bounds,  then the conditions sums[y] - sums[x] >= lower and sums[y] - sums[x] <= upper, should be satisfied. \\n\\nThis gives the **condition for y** as sums[y] <= sums[x] + upper and sums[y] >= sums[x] + lower, and y >= x.\\n\\nDuring merge sort note that the **relative ordering between the left and right halves is maintained** before the merging, so letting x belong to the left side of the array, y to the right half of the array maintains x <= y.\\n\\nHence if we make the count for each element in the left half of the array during the merge, then the count is guaranteed to be correct. \\n\\nAlso, due to sorted nature of subarrays used during merge, for a given x in the left subarray, since the right subarray is also sorted, it means that the elements within the desired range sums[x] + lower and sums[x] + upper are **found in a contiguous chunk** of the right subarray. \\n\\nMoreover, since the left subarray is also sorted, sums[x] increases with x **(monotonicity)**. This means that every time x is incremented, we can use the indices obtained for the range in the right subarray for the previous x, instead of starting both from 0, since both sums[x] + lower and sums[x] + upper can only increase. \\n\\n In the quoted bullet points above, the updates ensure that at the end of the updating, the indices cover the required range for each index.\\n\\nThe base case here is that a single element will add to the count if the element value lies between lower and upper otherwise the solution will be zero. \\n\\n**To write the solution** after understanding these steps, I used the following approach: Write merge sort in the usual way. Use two indices/pointers m and n starting from the beginning of the right subarray before the merge. At any block where the left subarray index is updated, update these two m and n. Add these to the total count. The function should return the sum of the counts of the left half, right half and the total count during the merge. \\n\\nMy first working solution in which I used the conventional merge sort template where following the main merge step there are two while loops, had to make the counts twice, once in the nested loop and once in the outside loop (since left subarray index is updated in these places). To get the form of the elegant solutions such as in the linked answer, I made the change to use an alternative form of merging where during every loop iteration, an update to the left index is guaranteed, and the merge concludes when the left subarray is completely traversed. \\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int countWithMergeSort(vector<long> &sums, int left, int right, int lower, int upper)\\n    {\\n        int count = 0;\\n        \\n        if(right - left <= 1)\\n        {\\n            if(right - left == 1)\\n            {\\n                return (lower <= sums[left] && sums[left] <= upper);\\n            }\\n            else\\n            {\\n                return 0;\\n            }\\n        }\\n        \\n        int mid = (left + right)/2;\\n        \\n        int leftSideSum = countWithMergeSort(sums, left, mid, lower, upper);\\n        int rightSideSum = countWithMergeSort(sums, mid, right, lower, upper);\\n        \\n        \\n        int i = left;\\n        int j = mid;\\n        \\n        int n = 0;\\n        int m = 0;\\n        \\n        vector<long> cache(right - left, 0);\\n        \\n        int k = 0;\\n        \\n        \\n        while(i < mid)\\n        {\\n            \\n\\n            while(mid+n < right && sums[mid+n] < sums[i]+lower)\\n                {\\n                    n++;\\n                }\\n            \\n            while(mid+m < right && sums[mid+m] <= sums[i] + upper)\\n                {\\n                    m++;\\n                }\\n            \\n            while(j < right && sums[j] < sums[i])\\n            {\\n                cache[k++] = sums[j++];\\n            }\\n            \\n            cache[k++] = sums[i++];\\n            \\n            count += m-n;\\n        }\\n        \\n        \\n        while(j < right)\\n        {\\n            cache[k++] = sums[j++];\\n        }\\n        \\n        \\n        for(int idx = 0; idx<cache.size(); idx++)\\n        {\\n            sums[left + idx] = cache[idx];\\n        }\\n    \\n        return leftSideSum + rightSideSum + count;\\n        \\n    }\\n    \\n    int countRangeSum(vector<int>& nums, int lower, int upper) {\\n        \\n        vector<long> prefixSum(nums.size(),0);\\n        \\n        int n = nums.size();\\n        \\n        prefixSum[0] = nums[0];\\n        \\n        for(int i = 1; i<nums.size(); i++)\\n        {\\n            prefixSum[i] = nums[i] + prefixSum[i-1];\\n        }\\n        \\n        return countWithMergeSort(prefixSum, 0, n, lower, upper);\\n    }\\n};\\n```\\n\\nAny comments or suggestions are welcome as I am also a beginner (took me 3+ hours to get this) who has spent some time in learning/convincing myself of the approach. I tried to address the points which took up a lot of my time while trying to understand some of the other solutions. \\n\\n\\n\\n\\n",
        "level": "hard",
        "type": [
            "variable value error",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    \n    int countWithMergeSort(vector<long> &sums, int left, int right, int lower, int upper)\n    {\n        int count = 0;\n        \n        if(right - left <= 1)\n        {\n            if(right - left == 1)\n            {\n                return (lower <= sums[left] && sums[left] <= upper);\n            }\n            else\n            {\n                return 0;\n            }\n        }\n        \n        int mid = (left + right)/2;\n        \n        int leftSideSum = countWithMergeSort(sums, left, mid, lower, upper);\n        int rightSideSum = countWithMergeSort(sums, mid, right, lower, upper);\n        \n        \n        int i = left;\n        int j = mid;\n        \n        int n = 0;\n        int m = right;\n        \n        vector<long> cache(right - left, 0);\n        \n        int k = 0;\n        \n        \n        while(i < mid)\n        {\n            \n            while(mid+n < right && sums[mid+n] < sums[i]+lower)\n            {\n                n++;\n            }\n            \n            while(mid+m < right && sums[mid+m] <= sums[i] + upper)\n            {\n                m++;\n            }\n            \n            while(j < mid && sums[j] < sums[i])\n            {\n                cache[k++] = sums[j++];\n            }\n            \n            cache[k++] = sums[i++];\n            \n            count += m-n;\n        }\n\n        \n        while(i < mid)\n        {\n        }\n        \n        \n        while(j < right)\n        {\n            cache[k++] = sums[j++];\n        }\n        \n        \n        for(int idx = 0; idx<cache.size(); idx++)\n        {\n            sums[left + idx] = cache[idx];\n        }\n    \n        return leftSideSum + rightSideSum + count;\n        \n    }\n    \n    int countRangeSum(vector<int>& nums, int lower, int upper) {\n        \n        vector<long> prefixSum(nums.size(),0);\n        \n        int n = nums.size();\n        \n        prefixSum[0] = nums[0];\n        \n        for(int i = 1; i<nums.size(); i++)\n        {\n            prefixSum[i] = nums[i] + prefixSum[i-1];\n        }\n        \n        return countWithMergeSort(prefixSum, 0, n, lower, upper);\n    }\n};\n"
    },
    {
        "slug": "largest-rectangle-in-histogram",
        "description": "Given an array of integers heights representing the histogram's bar height where the width of each bar is 1, return the area of the largest rectangle in the histogram.",
        "examples": [
            "Input: heights = [2,1,5,6,2,3]\nOutput: 10\nExplanation: The above is a histogram where width of each bar is 1.\nThe largest rectangle is shown in the red area, which has an area = 10 units.",
            "Input: heights = [2,4]\nOutput: 4"
        ],
        "constraints": "1 <= heights.length <= 105\n0 <= heights[i] <= 104",
        "oracle_code": "#include<stack>\n \nclass Solution {\npublic:\n    //function to find the index of next smallerNumber\n    vector<int> nextSmallNumberIndex(vector<int>& v){\n        int n=v.size(),num=0;\n        vector<int> ans(n);\n        stack<int> s;\n        s.push(-1);\n        for(int i=n-1;i>=0;i--){\n            num=v[i];\n            while(s.top()!=-1 && v[s.top()]>=num){\n                s.pop();\n            }\n            ans[i]=s.top();\n            s.push(i);\n        }\n        return ans;\n\n    }\n    //function to find the index of prev smallerNumber\n    vector<int> prevSmallNumberIndex(vector<int>& v){\n        int n=v.size(),num=0;\n        vector<int> ans(n);\n        stack<int> s;\n        s.push(-1);\n        for(int i=0;i<n;i++){\n            num=v[i];\n            while(s.top()!=-1 && v[s.top()]>=num){\n                s.pop();\n            }\n            ans[i]=s.top();\n            s.push(i);\n        }\n        return ans;\n\n    }\n    int largestRectangleArea(vector<int>& heights) {\n        int size=heights.size(),h,l,area=0,curArea;\n        vector<int> next=nextSmallNumberIndex(heights);\n         vector<int> prev=prevSmallNumberIndex(heights);\n         for(int i=0;i<size;i++){\n            h=heights[i];\n            //if index of next smaller number is -1 we change its value to size \n            if(next[i]==-1)next[i]=size;\n            l=next[i]-prev[i]-1;\n            curArea=l*h;\n             area=max(area,curArea);\n\n        }\n        return area;\n        \n    }\n};",
        "content": "\\n\\n# Code\\n```\\n#include<stack>\\n \\nclass Solution {\\npublic:\\n    //function to find the index of next smallerNumber\\n    vector<int> nextSmallNumberIndex(vector<int>& v){\\n        int n=v.size(),num=0;\\n        vector<int> ans(n);\\n        stack<int> s;\\n        s.push(-1);\\n        for(int i=n-1;i>=0;i--){\\n            num=v[i];\\n            while(s.top()!=-1 && v[s.top()]>=num){\\n                s.pop();\\n            }\\n            ans[i]=s.top();\\n            s.push(i);\\n        }\\n        return ans;\\n\\n    }\\n    //function to find the index of prev smallerNumber\\n    vector<int> prevSmallNumberIndex(vector<int>& v){\\n        int n=v.size(),num=0;\\n        vector<int> ans(n);\\n        stack<int> s;\\n        s.push(-1);\\n        for(int i=0;i<n;i++){\\n            num=v[i];\\n            while(s.top()!=-1 && v[s.top()]>=num){\\n                s.pop();\\n            }\\n            ans[i]=s.top();\\n            s.push(i);\\n        }\\n        return ans;\\n\\n    }\\n    int largestRectangleArea(vector<int>& heights) {\\n        int size=heights.size(),h,l,area=0,curArea;\\n        vector<int> next=nextSmallNumberIndex(heights);\\n         vector<int> prev=prevSmallNumberIndex(heights);\\n         for(int i=0;i<size;i++){\\n            h=heights[i];\\n            //if index of next smaller number is -1 we change its value to size \\n            if(next[i]==-1)next[i]=size;\\n            l=next[i]-prev[i]-1;\\n            curArea=l*h;\\n             area=max(area,curArea);\\n\\n        }\\n        return area;\\n        \\n    }\\n};\\n```",
        "level": "hard",
        "type": [
            "operation error",
            "colon missing"
        ],
        "buggy_code": "\n#include<stack>\n\nclass Solution {\npublic:\n    //function to find the index of next smallerNumber\n    vector<int> nextSmallNumberIndex(vector<int>& v){\n        int n=v.size(),num=0;\n        vector<int> ans(n);\n        stack<int> s;\n        s.push(-1);\n        for(int i=n-1;i>=0;i--){\n            num=v[i];\n            while(s.top()!=-1 && v[s.top()]>=num){\n                s.pop();\n            }\n            ans[i]=s.top());\n            s.push(i);\n        }\n        return ans;\n\n    }\n    //function to find the index of prev smallerNumber\n    vector<int> prevSmallNumberIndex(vector<int>& v){\n        int n=v.size(),num=0;\n        vector<int> ans(n);\n        stack<int> s;\n        s.push(-1);\n        for(int i=0;i<n;i++){\n            num=v[i];\n            while(s.top()!=-1 && v[s.top()]>=num){\n                s.pop();\n            }\n            ans[i]=s.top();\n            s.push(i);\n        }\n        return ans;\n\n    }\n    int largestRectangleArea(vector<int>& heights) {\n        int size=heights.size(),h,l,area=0,curArea;\n        vector<int> next=nextSmallNumberIndex(heights);\n        vector<int> prev=prevSmallNumberIndex(heights);\n        for(int i=0;i<size;i++){\n            h=heights[i];\n            //if index of next smaller number is -1 we change its value to size \n            if(next[i]==-1)next[i]=size;\n            l=next[i]-prev[i]-1;\n            curArea=l*h;\n            area=max(area,curArea);\n        }\n        return area*2;        \n    }\n};\n"
    },
    {
        "slug": "climbing-stairs",
        "description": "You are climbing a staircase. It takes n steps to reach the top.\nEach time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?",
        "examples": [
            "Input: n = 2\nOutput: 2\nExplanation: There are two ways to climb to the top.\n1. 1 step + 1 step\n2. 2 steps",
            "Input: n = 3\nOutput: 3\nExplanation: There are three ways to climb to the top.\n1. 1 step + 1 step + 1 step\n2. 1 step + 2 steps\n3. 2 steps + 1 step"
        ],
        "constraints": "1 <= n <= 45",
        "oracle_code": "class Solution {\npublic:\n    int solve(int n,vector<int> &dp){\n        //base case\n        if(n<=2)\n          return n;\n        \n        if(dp[n]!=-1) \n          return dp[n]; \n        \n        dp[n]=solve(n-1,dp)+solve(n-2,dp);\n        return dp[n];\n    }\n    int climbStairs(int n) {\n        if(n<=2)\n         return n;\n        vector<int> dp(n+1);\n        for(int i=0;i<=n;i++)\n         dp[i]=-1;\n        \n        return solve(n,dp);\n    }\n};",
        "content": "# Intuition\\nUsing Top - Down Approach -> Recursion + Memorization.\\n\\n# Approach\\nStoring the values of overlapping sub - problems in a vector.\\n\\n# Complexity\\n- Time complexity:\\nO(n) -> As we are visiting all values of n atleast 1 time.\\n\\n- Space complexity:\\nO(n) + O(n)  - > (Recursive calls + Array of size n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int n,vector<int> &dp){\\n        //base case\\n        if(n<=2)\\n          return n;\\n        \\n        if(dp[n]!=-1) \\n          return dp[n]; \\n        \\n        dp[n]=solve(n-1,dp)+solve(n-2,dp);\\n        return dp[n];\\n    }\\n    int climbStairs(int n) {\\n        if(n<=2)\\n         return n;\\n        vector<int> dp(n+1);\\n        for(int i=0;i<=n;i++)\\n         dp[i]=-1;\\n        \\n        return solve(n,dp);\\n    }\\n};\\n```\\n\\n# Intuition\\nUsing Bottom - up Approach -> Tabulation.\\n\\n# Approach\\nStoring the values of overlapping sub - problems in a vector.\\n\\n# Complexity\\n- Time complexity:\\nO(n) -> As we are traversing the vector atleast 1 time.\\n\\n- Space complexity:\\nO(n) - > (Array of size n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n<=2)\\n         return n;\\n        vector<int> dp(n+1);\\n        dp[0]=0;\\n        dp[1]=1;\\n        dp[2]=2;\\n        for(int i=3;i<=n;i++)\\n         dp[i]=dp[i-1]+dp[i-2];\\n        \\n        return dp[n];\\n    }\\n};\\n```\\n\\n# Python Code :\\nContributed by : Aarya_R\\n\\n# Complexity\\n- Time complexity:\\nO(n) -> As we are traversing the vector atleast 1 time.\\n\\n- Space complexity:\\nO(1) \\n```\\ndef climbStairs(self, n):\\n        prev = 1\\n        prev2 = 0\\n        for i in range(1, n+1):\\n            curi = prev + prev2\\n            prev2 = prev\\n            prev = curi\\n        return prev \\n```\\n![upvote.jfif](https://assets.leetcode.com/users/images/995d917b-6ea2-4b6b-8baa-6ce7bc6441fd_1676965776.537627.jpeg)\\n\\n",
        "level": "easy",
        "type": [
            "operation error",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    int solve(int n,vector<int> &dp){\n        //base case\n        if(n<=2)\n          return n;\n        \n        if(dp[n]!=-1) \n          return dp[n]; \n        \n        dp[n]=solve(n-1,dp)+solve(n-3,dp); \n        return dp[n];\n    }\n    int climbStairs(int n) {\n        if(n<=2)\n         return n;\n        array<int> dp(n+1);\n        for(int i=0;i<=n;i++)\n         dp[i]=-1;\n        \n        return solve(n,dp);\n    }\n};\n"
    },
    {
        "slug": "longest-common-prefix",
        "description": "Write a function to find the longest common prefix string amongst an array of strings.\nIf there is no common prefix, return an empty string \"\".",
        "examples": [
            "Input: strs = [\"flower\",\"flow\",\"flight\"]\nOutput: \"fl\"",
            "Input: strs = [\"dog\",\"racecar\",\"car\"]\nOutput: \"\"\nExplanation: There is no common prefix among the input strings."
        ],
        "constraints": "1 <= strs.length <= 200\n0 <= strs[i].length <= 200\nstrs[i] consists of only lowercase English letters.",
        "oracle_code": "class Solution {\npublic:\n    string longestCommonPrefix(vector<string>& str) \n    {\n        sort(str.begin(), str.end()); //sorting the array\n        string ans=\"\"; //creating a new empty string to store the common prefixes\n        for(int i=0;i<str[0].length();i++) // max iterations = length of the first string\n        {\n            if(str[0][i]!=str[str.size()-1][i]) // checking the characters of the first and last string\n                break;\n            ans+=str[0][i]; // concatinate if the characters are matching\n        }\n        return ans;\n    }\n};",
        "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWhen you sort an array, it is enough to check for the common characters of the the first & last string of the sorted vector.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& str) \\n    {\\n        sort(str.begin(), str.end()); //sorting the array\\n        string ans=\"\"; //creating a new empty string to store the common prefixes\\n        for(int i=0;i<str[0].length();i++) // max iterations = length of the first string\\n        {\\n            if(str[0][i]!=str[str.size()-1][i]) // checking the characters of the first and last string\\n                break;\\n            ans+=str[0][i]; // concatinate if the characters are matching\\n        }\\n        return ans;\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "unclosed string",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    string longestCommonPrefix(vector<string>& str) \n    {\n        sort(str.begin(), str.end()); //sorting the array\n        string ans=\"; \n        for(int i=0;i<str[0].length();i++) // max iterations = length of the first string\n        {\n            if(str[0][i]!=str[str.size()-1][i]] \n                break;\n            ans+=str[0][i]; // concatinate if the characters are matching\n        }\n        return ans;\n    }\n};\n"
    },
    {
        "slug": "find-the-punishment-number-of-an-integer",
        "description": "Given a positive integer n, return the punishment number of n.\nThe punishment number of n is defined as the sum of the squares of all integers i such that:\n\n1 <= i <= n\nThe decimal representation of i * i can be partitioned into contiguous substrings such that the sum of the integer values of these substrings equals i.",
        "examples": [
            "Input: n = 10\nOutput: 182\nExplanation: There are exactly 3 integers i that satisfy the conditions in the statement:\n- 1 since 1 * 1 = 1\n- 9 since 9 * 9 = 81 and 81 can be partitioned into 8 + 1.\n- 10 since 10 * 10 = 100 and 100 can be partitioned into 10 + 0.\nHence, the punishment number of 10 is 1 + 81 + 100 = 182",
            "Input: n = 37\nOutput: 1478\nExplanation: There are exactly 4 integers i that satisfy the conditions in the statement:\n- 1 since 1 * 1 = 1. \n- 9 since 9 * 9 = 81 and 81 can be partitioned into 8 + 1. \n- 10 since 10 * 10 = 100 and 100 can be partitioned into 10 + 0. \n- 36 since 36 * 36 = 1296 and 1296 can be partitioned into 1 + 29 + 6.\nHence, the punishment number of 37 is 1 + 81 + 100 + 1296 = 1478"
        ],
        "constraints": "1 <= n <= 1000",
        "oracle_code": "class Solution {\npublic:\n    \n    bool valid(int n, string s,int sum){\n        // empty string indicates we have completed one partition\n        if(s==\"\") if(sum==n) return true;\n\n        // We use backtracking to check for all partitions if it is possible to generate required sum \n        // and if we find sum we immediately return true immediately\n        for(int i=1;i<=s.size();i++){\n            int x  = stoi(s.substr(0,i));\n            if(valid(n, s.substr(i), sum+x)) return true;\n        }\n        \n        //If no partition could add up to required sum n\n        return false;\n    }\n    int punishmentNumber(int n) {\n        int ans = 0;\n\n        //generate all possible squares and check them if they satisfy the given statement\n        for(int i=1;i<=n;i++){\n            int sq = i*i;\n            string x = to_string(sq);\n            if(valid(i,x,0)) ans += i*i;\n        }\n        \n        return ans;\n        \n    }\n};",
        "content": "# Intuition\\nThe main idea of this problem is to generate all non empty partitions of a string using Backtracking.\\n\\nFor example let\\'s  say i = 36, it\\'s square = 36*36 = 1296\\nTo check if some partition of 1296 satisfy given statement, we make all partitions e.g\\n[1,2,9,6], [1,29,6], [1,296], [12,9,6] , [12,96], [129,6]\\n\\nAmong these only [1,29,6] satisfies the constraint.\\n\\nWe only need one of these set to satisfy the statement, hence we break immediately if we find any valid set.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n* Generate all possible squares and check if they satisfy the given statement\\n* To check if a square satisfies the given constraint or not generate all possible partitions using backtracking.\\n* If any single partition satisfy the statement then this square will be added to solution\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity :  O(n*(2^6)), here 6 is the maxm square length that is len(1000*1000) = 6\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    bool valid(int n, string s,int sum){\\n        // empty string indicates we have completed one partition\\n        if(s==\"\") if(sum==n) return true;\\n\\n        // We use backtracking to check for all partitions if it is possible to generate required sum \\n        // and if we find sum we immediately return true immediately\\n        for(int i=1;i<=s.size();i++){\\n            int x  = stoi(s.substr(0,i));\\n            if(valid(n, s.substr(i), sum+x)) return true;\\n        }\\n        \\n        //If no partition could add up to required sum n\\n        return false;\\n    }\\n    int punishmentNumber(int n) {\\n        int ans = 0;\\n\\n        //generate all possible squares and check them if they satisfy the given statement\\n        for(int i=1;i<=n;i++){\\n            int sq = i*i;\\n            string x = to_string(sq);\\n            if(valid(i,x,0)) ans += i*i;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "== and = confusion",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    \n    bool valid(int n, string s,int sum){\n        // empty string indicates we have completed one partition\n        if(s==\"\") if(sum=n) return true; \n\n        // We use backtracking to check for all partitions if it is possible to generate required sum \n        // and if we find sum we immediately return true immediately\n        for(int i=1;i<=s.size();i++){\n            int x  = parseInt(s.substr(0,i));\n            if(valid(n, s.substr(i), sum+x)) return true;\n        }\n        \n        //If no partition could add up to required sum n\n        return false;\n    }\n    int punishmentNumber(int n) {\n        int ans = 0;\n\n        //generate all possible squares and check them if they satisfy the given statement\n        for(int i=1;i<=n;i++){\n            int sq = i*i;\n            string x = to_string(sq);\n            if(valid(i,x,0)) ans += i*i;\n        }\n        \n        return ans;\n        \n    }\n};\n"
    },
    {
        "slug": "minimum-sideway-jumps",
        "description": "There is a 3 lane road of length n that consists of n + 1 points labeled from 0 to n. A frog starts at point 0 in the second lane and wants to jump to point n. However, there could be obstacles along the way.\nYou are given an array obstacles of length n + 1 where each obstacles[i] (ranging from 0 to 3) describes an obstacle on the lane obstacles[i] at point i. If obstacles[i] == 0, there are no obstacles at point i. There will be at most one obstacle in the 3 lanes at each point.\n\nFor example, if obstacles[2] == 1, then there is an obstacle on lane 1 at point 2.\n\nThe frog can only travel from point i to point i + 1 on the same lane if there is not an obstacle on the lane at point i + 1. To avoid obstacles, the frog can also perform a side jump to jump to another lane (even if they are not adjacent) at the same point if there is no obstacle on the new lane.\n\nFor example, the frog can jump from lane 3 at point 3 to lane 1 at point 3.\n\nReturn the minimum number of side jumps the frog needs to reach any lane at point n starting from lane 2 at point 0.\nNote: There will be no obstacles on points 0 and n.",
        "examples": [
            "Input: obstacles = [0,1,2,3,0]\nOutput: 2 \nExplanation: The optimal solution is shown by the arrows above. There are 2 side jumps (red arrows).\nNote that the frog can jump over obstacles only when making side jumps (as shown at point 2).",
            "Input: obstacles = [0,1,1,3,3,0]\nOutput: 0\nExplanation: There are no obstacles on lane 2. No side jumps are required.",
            "Input: obstacles = [0,2,1,0,3,0]\nOutput: 2\nExplanation: The optimal solution is shown by the arrows above. There are 2 side jumps."
        ],
        "constraints": "obstacles.length == n + 1\n1 <= n <= 5 * 105\n0 <= obstacles[i] <= 3\nobstacles[0] == obstacles[n] == 0",
        "oracle_code": "class Solution {\npublic:\n    int func(int i,int l,vector<int>&obstacles,vector<vector<int>>&dp){\n        if(i==obstacles.size()-2){\n            if(obstacles[i+1]==l)return 1;\n            return 0;\n        }\n\n        if(dp[i][l]!=-1)return dp[i][l];\n\n        if(obstacles[i+1]!=l){\n            return dp[i][l] = func(i+1,l,obstacles,dp);\n        }\n\n    \n        int b=INT_MAX;\n        for(int j=1;j<=3;j++){\n            if(l==j)continue;\n            if(obstacles[i]==j)continue;\n            b=min(b,1+func(i,j,obstacles,dp));\n        }\n    \n\n        return dp[i][l] = b;\n    }\n\n    int minSideJumps(vector<int>& obstacles) {\n        int n=obstacles.size();\n        vector<vector<int>>dp(n,vector<int>(4,-1));\n        return func(0,2,obstacles,dp);\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(n*4) = O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(n*4)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int func(int i,int l,vector<int>&obstacles,vector<vector<int>>&dp){\\n        if(i==obstacles.size()-2){\\n            if(obstacles[i+1]==l)return 1;\\n            return 0;\\n        }\\n\\n        if(dp[i][l]!=-1)return dp[i][l];\\n\\n        if(obstacles[i+1]!=l){\\n            return dp[i][l] = func(i+1,l,obstacles,dp);\\n        }\\n\\n    \\n        int b=INT_MAX;\\n        for(int j=1;j<=3;j++){\\n            if(l==j)continue;\\n            if(obstacles[i]==j)continue;\\n            b=min(b,1+func(i,j,obstacles,dp));\\n        }\\n    \\n\\n        return dp[i][l] = b;\\n    }\\n\\n    int minSideJumps(vector<int>& obstacles) {\\n        int n=obstacles.size();\\n        vector<vector<int>>dp(n,vector<int>(4,-1));\\n        return func(0,2,obstacles,dp);\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "== and = confusion",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    int func(int i,int l,vector<int>&obstacles,vector<vector<int>>&dp){\n        if(i=obstacles.size()-2){\n            if(obstacles[i+1]==l)return 1;\n            return 0;\n        }\n\n        if(dp[i][l]!=-1)return dp[i][l];\n\n        if(obstacles[i+1]!=l){\n            return dp[i][l] = func(i+1,l,obstacles,dp);\n        }\n\n        int b=INT_MAX;\n        for(int j=1;j<=3;j++){\n            if(l==j)continue;\n            if(obstacles[i]==j)continue;\n            b=min(b,1+func(i,j,obstacles,dp));\n        }\n    }\n\n    int minSideJumps(vector<int>& obstacles) {\n        int n=obstacles.size();\n        vector<vector<int>>dp(n,vector<int>(4,-1));\n        return func(0,2,obstacles,dp;\n    }\n};\n"
    },
    {
        "slug": "most-frequent-even-element",
        "description": "Given an integer array nums, return the most frequent even element.\nIf there is a tie, return the smallest one. If there is no such element, return -1.",
        "examples": [
            "Input: nums = [0,1,2,2,4,4,1]\nOutput: 2\nExplanation:\nThe even elements are 0, 2, and 4. Of these, 2 and 4 appear the most.\nWe return the smallest one, which is 2.",
            "Input: nums = [4,4,4,9,2,4]\nOutput: 4\nExplanation: 4 is the even element appears the most.",
            "Input: nums = [29,47,21,41,13,37,25,7]\nOutput: -1\nExplanation: There is no even element."
        ],
        "constraints": "1 <= nums.length <= 2000\n0 <= nums[i] <= 105",
        "oracle_code": "class Solution {\npublic:\n    int mostFrequentEven(vector<int>& nums) {\n        int n = nums.size(),i;\n        map<int , int> freq;\n        for(auto x:nums){\n            freq[x]++;\n        }\n        int evefreq=0,ans=-1;\n        for(auto y:freq){\n            if(y.first%2==0 && y.second> evefreq){\n                ans=y.first;\n                evefreq=y.second;\n            }\n        }\n        return ans;\n    }\n};",
        "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mostFrequentEven(vector<int>& nums) {\\n        int n = nums.size(),i;\\n        map<int , int> freq;\\n        for(auto x:nums){\\n            freq[x]++;\\n        }\\n        int evefreq=0,ans=-1;\\n        for(auto y:freq){\\n            if(y.first%2==0 && y.second> evefreq){\\n                ans=y.first;\\n                evefreq=y.second;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "conditional statement error",
            "colon missing"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    int mostFrequentEven(vector<int>& nums) {\n        int n = nums.size(),i;\n        map<int , int> freq;\n        for(auto x:nums)\n            freq[x]++;\n        }\n        int evefreq=0,ans=-1;\n        for(auto y:freq){\n            if(y.second> evefreq){\n                ans=y.first;\n                evefreq=y.second;\n            }\n        }\n        return ans;\n    }\n};\n"
    },
    {
        "slug": "factorial-trailing-zeroes",
        "description": "Given an integer n, return the number of trailing zeroes in n!.\nNote that n! = n * (n - 1) * (n - 2) * ... * 3 * 2 * 1.",
        "examples": [
            "Input: n = 3\nOutput: 0\nExplanation: 3! = 6, no trailing zero.",
            "Input: n = 5\nOutput: 1\nExplanation: 5! = 120, one trailing zero.",
            "Input: n = 0\nOutput: 0"
        ],
        "constraints": "0 <= n <= 104",
        "oracle_code": "class Solution {\npublic:\n    unordered_map<long long int,long long int>mp;\n    int trailingZeroes(int n) {\n        for(int i=n;i>=1;i--)\n         fun(i);\n         \n\t\t return min(mp[2],mp[5]); \n    }\n     void fun(int n)\n    {\n         for(int i=2;i*i<=n;i++)\n         {\n         \twhile((n%i) == 0)\n         \t{\n         \t    mp[i]++;\n\t\t\t\tn = n / i;\t\n\t\t\t}\n\t\t }\n\t\t if(n > 1)\n\t\t mp[n]++;\n    }\n};",
        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    unordered_map<long long int,long long int>mp;\\n    int trailingZeroes(int n) {\\n        for(int i=n;i>=1;i--)\\n         fun(i);\\n         \\n\\t\\t return min(mp[2],mp[5]); \\n    }\\n     void fun(int n)\\n    {\\n         for(int i=2;i*i<=n;i++)\\n         {\\n         \\twhile((n%i) == 0)\\n         \\t{\\n         \\t    mp[i]++;\\n\\t\\t\\t\\tn = n / i;\\t\\n\\t\\t\\t}\\n\\t\\t }\\n\\t\\t if(n > 1)\\n\\t\\t mp[n]++;\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "operation error",
            "colon missing"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    unordered_map<long long int,long long int>mp\n    int trailingZeroes(int n) {\n        for(int i=n;i>=1;i--)\n         fun(i);\n         \n\t\t return max(mp[2],mp[5]); \n    }\n     void fun(int n)\n    {\n         for(int i=2;i*i<=n;i++)\n         {\n         \twhile((n%i) == 0)\n         \t{\n         \t    mp[i]++;\n\t\t\t\tn = n / i;\t\n\t\t\t}\n\t\t }\n\t\t if(n > 1)\n\t\t mp[n]++;\n    }\n};\n"
    },
    {
        "slug": "find-the-punishment-number-of-an-integer",
        "description": "Given a positive integer n, return the punishment number of n.\nThe punishment number of n is defined as the sum of the squares of all integers i such that:\n\n1 <= i <= n\nThe decimal representation of i * i can be partitioned into contiguous substrings such that the sum of the integer values of these substrings equals i.",
        "examples": [
            "Input: n = 10\nOutput: 182\nExplanation: There are exactly 3 integers i that satisfy the conditions in the statement:\n- 1 since 1 * 1 = 1\n- 9 since 9 * 9 = 81 and 81 can be partitioned into 8 + 1.\n- 10 since 10 * 10 = 100 and 100 can be partitioned into 10 + 0.\nHence, the punishment number of 10 is 1 + 81 + 100 = 182",
            "Input: n = 37\nOutput: 1478\nExplanation: There are exactly 4 integers i that satisfy the conditions in the statement:\n- 1 since 1 * 1 = 1. \n- 9 since 9 * 9 = 81 and 81 can be partitioned into 8 + 1. \n- 10 since 10 * 10 = 100 and 100 can be partitioned into 10 + 0. \n- 36 since 36 * 36 = 1296 and 1296 can be partitioned into 1 + 29 + 6.\nHence, the punishment number of 37 is 1 + 81 + 100 + 1296 = 1478"
        ],
        "constraints": "1 <= n <= 1000",
        "oracle_code": "class Solution {\npublic:\n    \n    bool valid(int n, string s,int sum){\n        // empty string indicates we have completed one partition\n        if(s==\"\") if(sum==n) return true;\n\n        // We use backtracking to check for all partitions if it is possible to generate required sum \n        // and if we find sum we immediately return true immediately\n        for(int i=1;i<=s.size();i++){\n            int x  = stoi(s.substr(0,i));\n            if(valid(n, s.substr(i), sum+x)) return true;\n        }\n        \n        //If no partition could add up to required sum n\n        return false;\n    }\n    int punishmentNumber(int n) {\n        int ans = 0;\n\n        //generate all possible squares and check them if they satisfy the given statement\n        for(int i=1;i<=n;i++){\n            int sq = i*i;\n            string x = to_string(sq);\n            if(valid(i,x,0)) ans += i*i;\n        }\n        \n        return ans;\n        \n    }\n};",
        "content": "# Intuition\\nThe main idea of this problem is to generate all non empty partitions of a string using Backtracking.\\n\\nFor example let\\'s  say i = 36, it\\'s square = 36*36 = 1296\\nTo check if some partition of 1296 satisfy given statement, we make all partitions e.g\\n[1,2,9,6], [1,29,6], [1,296], [12,9,6] , [12,96], [129,6]\\n\\nAmong these only [1,29,6] satisfies the constraint.\\n\\nWe only need one of these set to satisfy the statement, hence we break immediately if we find any valid set.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n* Generate all possible squares and check if they satisfy the given statement\\n* To check if a square satisfies the given constraint or not generate all possible partitions using backtracking.\\n* If any single partition satisfy the statement then this square will be added to solution\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity :  O(n*(2^6)), here 6 is the maxm square length that is len(1000*1000) = 6\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    bool valid(int n, string s,int sum){\\n        // empty string indicates we have completed one partition\\n        if(s==\"\") if(sum==n) return true;\\n\\n        // We use backtracking to check for all partitions if it is possible to generate required sum \\n        // and if we find sum we immediately return true immediately\\n        for(int i=1;i<=s.size();i++){\\n            int x  = stoi(s.substr(0,i));\\n            if(valid(n, s.substr(i), sum+x)) return true;\\n        }\\n        \\n        //If no partition could add up to required sum n\\n        return false;\\n    }\\n    int punishmentNumber(int n) {\\n        int ans = 0;\\n\\n        //generate all possible squares and check them if they satisfy the given statement\\n        for(int i=1;i<=n;i++){\\n            int sq = i*i;\\n            string x = to_string(sq);\\n            if(valid(i,x,0)) ans += i*i;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "== and = confusion",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    \n    bool valid(int n, string s,int sum){\n        // empty string indicates we have completed one partition\n        if(s==\"\") if(sum=n) return true; \n\n        // We use backtracking to check for all partitions if it is possible to generate required sum \n        // and if we find sum we immediately return true immediately\n        for(int i=1;i<=s.size();i++){\n            int x  = stoi(s.substr(0,i));\n            if(valid(n, s.substr(i), sum+x)) return false;\n        }\n        \n        //If no partition could add up to required sum n\n        return false;\n    }\n    int punishmentNumber(int n) {\n        int ans = 0;\n\n        //generate all possible squares and check them if they satisfy the given statement\n        for(int i=1;i<=n;i++){\n            int sq = i*i;\n            string x = to_string(sq);\n            if(valid(i,x,0)) ans += i*i;\n        }\n        \n        return ans;\n        \n    }\n};\n"
    },
    {
        "slug": "valid-number",
        "description": "A valid number can be split up into these components (in order):\n\nA decimal number or an integer.\n(Optional) An 'e' or 'E', followed by an integer.\n\nA decimal number can be split up into these components (in order):\n\n(Optional) A sign character (either '+' or '-').\nOne of the following formats:\n\t\nOne or more digits, followed by a dot '.'.\nOne or more digits, followed by a dot '.', followed by one or more digits.\nA dot '.', followed by one or more digits.\n\n\n\nAn integer can be split up into these components (in order):\n\n(Optional) A sign character (either '+' or '-').\nOne or more digits.\n\nFor example, all the following are valid numbers: [\"2\", \"0089\", \"-0.1\", \"+3.14\", \"4.\", \"-.9\", \"2e10\", \"-90E3\", \"3e+7\", \"+6e-1\", \"53.5e93\", \"-123.456e789\"], while the following are not valid numbers: [\"abc\", \"1a\", \"1e\", \"e3\", \"99e2.5\", \"--6\", \"-+3\", \"95a54e53\"].\nGiven a string s, return true if s is a valid number.",
        "examples": [
            "Input: s = \"0\"\nOutput: true",
            "Input: s = \"e\"\nOutput: false",
            "Input: s = \".\"\nOutput: false"
        ],
        "constraints": "1 <= s.length <= 20\ns consists of only English letters (both uppercase and lowercase), digits (0-9), plus '+', minus '-', or dot '.'.",
        "oracle_code": "class Solution {\npublic:\n    bool isNumber(string s) {\n        int n = s.length();\n        int i = 0;\n\n        // Skip leading white space\n        while (i < n && isspace(s[i])) {\n            i++;\n        }\n\n        // Check optional sign\n        if (i < n && (s[i] == '+' || s[i] == '-')) {\n            i++;\n        }\n\n        // Check digits before decimal point\n        bool hasDigits = false;\n        while (i < n && isdigit(s[i])) {\n            i++;\n            hasDigits = true;\n        }\n\n        // Check optional decimal point and digits after it\n        if (i < n && s[i] == '.') {\n            i++;\n            while (i < n && isdigit(s[i])) {\n                i++;\n                hasDigits = true;\n            }\n        }\n\n        // Check optional exponent part\n        if (hasDigits && i < n && (s[i] == 'e' || s[i] == 'E')) {\n            i++;\n\n            // Check optional sign in exponent\n            if (i < n && (s[i] == '+' || s[i] == '-')) {\n                i++;\n            }\n\n            bool hasExponentDigits = false;\n            while (i < n && isdigit(s[i])) {\n                i++;\n                hasExponentDigits = true;\n            }\n\n            // The exponent must have at least one digit\n            if (!hasExponentDigits) {\n                return false;\n            }\n        }\n\n        // Check trailing white space\n        while (i < n && isspace(s[i])) {\n            i++;\n        }\n\n        // The number is valid if we consumed the entire string and found at least one digit\n        return i == n && hasDigits;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isNumber(string s) {\\n        int n = s.length();\\n        int i = 0;\\n\\n        // Skip leading white space\\n        while (i < n && isspace(s[i])) {\\n            i++;\\n        }\\n\\n        // Check optional sign\\n        if (i < n && (s[i] == \\'+\\' || s[i] == \\'-\\')) {\\n            i++;\\n        }\\n\\n        // Check digits before decimal point\\n        bool hasDigits = false;\\n        while (i < n && isdigit(s[i])) {\\n            i++;\\n            hasDigits = true;\\n        }\\n\\n        // Check optional decimal point and digits after it\\n        if (i < n && s[i] == \\'.\\') {\\n            i++;\\n            while (i < n && isdigit(s[i])) {\\n                i++;\\n                hasDigits = true;\\n            }\\n        }\\n\\n        // Check optional exponent part\\n        if (hasDigits && i < n && (s[i] == \\'e\\' || s[i] == \\'E\\')) {\\n            i++;\\n\\n            // Check optional sign in exponent\\n            if (i < n && (s[i] == \\'+\\' || s[i] == \\'-\\')) {\\n                i++;\\n            }\\n\\n            bool hasExponentDigits = false;\\n            while (i < n && isdigit(s[i])) {\\n                i++;\\n                hasExponentDigits = true;\\n            }\\n\\n            // The exponent must have at least one digit\\n            if (!hasExponentDigits) {\\n                return false;\\n            }\\n        }\\n\\n        // Check trailing white space\\n        while (i < n && isspace(s[i])) {\\n            i++;\\n        }\\n\\n        // The number is valid if we consumed the entire string and found at least one digit\\n        return i == n && hasDigits;\\n    }\\n};\\n```",
        "level": "hard",
        "type": [
            "== and = confusion",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    bool isNumber(string s) {\n        int n = s.length();\n        int i = 0;\n\n        // Skip leading white space\n        while (i < n && isspace(s[i])) {\n            i++;\n        }\n\n        // Check optional sign\n        if (i < n && (s[i] == '+' || s[i] == '-')) {\n            i++;\n        }\n\n        // Check digits before decimal point\n        bool hasDigits = false;\n        while (i < n && isdigit(s[i])) {\n            i++;\n            hasDigits = true;\n        }\n\n        // Check optional decimal point and digits after it\n        if (i < n && s[i] == '.') {\n            i++;\n            while (i < n && isdigit(s[i] {\n                i++;\n                hasDigits = true;\n            }\n        }\n\n        // Check optional exponent part\n        if (hasDigits && i < n && (s[i] == 'e' || s[i] == 'E')) {\n            i++;\n\n            // Check optional sign in exponent\n            if (i < n && (s[i] == '+' || s[i] == '-')) {\n                i++;\n            }\n\n            bool hasExponentDigits = false;\n            while (i < n && isdigit(s[i])) {\n                i++;\n                hasExponentDigits = true;\n            }\n\n            // The exponent must have at least one digit\n            if (!hasExponentDigits) {\n                return false;\n            }\n        }\n\n        // Check trailing white space\n        while (i < n && isspace(s[i])) {\n            i++;\n        }\n\n        // The number is valid if we consumed the entire string and found at least one digit\n        return i = n && hasDigits;\n    }\n};\n"
    },
    {
        "slug": "bitwise-and-of-numbers-range",
        "description": "Given two integers left and right that represent the range [left, right], return the bitwise AND of all numbers in this range, inclusive.",
        "examples": [
            "Input: left = 5, right = 7\nOutput: 4",
            "Input: left = 0, right = 0\nOutput: 0",
            "Input: left = 1, right = 2147483647\nOutput: 0"
        ],
        "constraints": "0 <= left <= right <= 231 - 1",
        "oracle_code": "class Solution {\npublic:\n    int solve(int left , int right){\n        if(left == 0)return 0;\n        int bit1 = log2(left);\n        int bit2 = log2(right);\n        if(bit1 < bit2)return 0;\n        return (1<<bit1) | solve((left^(1<<bit1)) , (right^(1<<bit1))); \n    }\n    int rangeBitwiseAnd(int left, int right) {\n         return solve(left , right);\n    }\n};",
        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int left , int right){\\n        if(left == 0)return 0;\\n        int bit1 = log2(left);\\n        int bit2 = log2(right);\\n        if(bit1 < bit2)return 0;\\n        return (1<<bit1) | solve((left^(1<<bit1)) , (right^(1<<bit1))); \\n    }\\n    int rangeBitwiseAnd(int left, int right) {\\n         return solve(left , right);\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "statement separation",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    int solve(int left , int right){\n        if(left == 0)return 0;\n        int bit1 = log2(left)\n        int bit2 = log2(right);\n        if(bit1 < bit2)return 1;\n        return (1<<bit1) | solve((left^(1<<bit1)) , (right^(1<<bit1))); \n    }\n    int rangeBitwiseAnd(int left, int right) {\n         return solve(left , right);\n    }\n};\n"
    },
    {
        "slug": "filter-restaurants-by-vegan-friendly-price-and-distance",
        "description": "Given the array restaurants where \u00a0restaurants[i] = [idi, ratingi, veganFriendlyi, pricei, distancei]. You have to filter the restaurants using three filters.\nThe veganFriendly filter will be either true (meaning you should only include restaurants with veganFriendlyi set to true)\u00a0or false\u00a0(meaning you can include any restaurant). In addition, you have the filters\u00a0maxPrice and maxDistance\u00a0which\u00a0are the maximum value for price and distance of restaurants you should consider respectively.\nReturn the array of restaurant IDs after filtering, ordered by rating from highest to lowest. For restaurants with the same rating, order them by id from highest to lowest. For simplicity veganFriendlyi and veganFriendly take value 1 when it is true, and 0 when it is false.",
        "examples": [
            "Input: restaurants = [[1,4,1,40,10],[2,8,0,50,5],[3,8,1,30,4],[4,10,0,10,3],[5,1,1,15,1]], veganFriendly = 1, maxPrice = 50, maxDistance = 10\nOutput: [3,1,5] \nExplanation: \nThe restaurants are:\nRestaurant 1 [id=1, rating=4, veganFriendly=1, price=40, distance=10]\nRestaurant 2 [id=2, rating=8, veganFriendly=0, price=50, distance=5]\nRestaurant 3 [id=3, rating=8, veganFriendly=1, price=30, distance=4]\nRestaurant 4 [id=4, rating=10, veganFriendly=0, price=10, distance=3]\nRestaurant 5 [id=5, rating=1, veganFriendly=1, price=15, distance=1] \nAfter filter restaurants with veganFriendly = 1, maxPrice = 50 and maxDistance = 10 we have restaurant 3, restaurant 1 and restaurant 5 (ordered by rating from highest to lowest).",
            "Input: restaurants = [[1,4,1,40,10],[2,8,0,50,5],[3,8,1,30,4],[4,10,0,10,3],[5,1,1,15,1]], veganFriendly = 0, maxPrice = 50, maxDistance = 10\nOutput: [4,3,2,1,5]\nExplanation: The restaurants are the same as in example 1, but in this case the filter veganFriendly = 0, therefore all restaurants are considered.",
            "Input: restaurants = [[1,4,1,40,10],[2,8,0,50,5],[3,8,1,30,4],[4,10,0,10,3],[5,1,1,15,1]], veganFriendly = 0, maxPrice = 30, maxDistance = 3\nOutput: [4,5]"
        ],
        "constraints": "1 <=\u00a0restaurants.length <= 10^4\nrestaurants[i].length == 5\n1 <=\u00a0idi, ratingi, pricei, distancei <= 10^5\n1 <=\u00a0maxPrice,\u00a0maxDistance <= 10^5\nveganFriendlyi and\u00a0veganFriendly\u00a0are\u00a00 or 1.\nAll idi are distinct.",
        "oracle_code": "class Solution {\npublic:\n    vector<int> filterRestaurants(vector<vector<int>>& restaurants, int veganFriendly, int maxPrice, int maxDistance) {\n        if(veganFriendly == 1){\n            for(int i = 0; i<restaurants.size(); i++){\n                if(restaurants[i][2] != veganFriendly){\n                    restaurants[i][0] = -1;\n                }\n            }\n        }\n\n        for(int i = 0; i<restaurants.size(); i++){\n            if(restaurants[i][3] > maxPrice){   \n                restaurants[i][0] = -1;\n            }\n            if(restaurants[i][4] > maxDistance){  \n                restaurants[i][0]=-1;\n            }\n        }\n\n        vector<int> id;\n        vector<int>rating;\n        for(int i=0; i<restaurants.size(); i++){\n            if(restaurants[i][0]>0){\n                id.push_back(restaurants[i][0]);\n                rating.push_back(restaurants[i][1]);\n            }\n            \n        }\n\n        for(int i=0; i<rating.size(); i++){\n            for(int j=i+1; j<rating.size(); j++){\n                if(rating[i] < rating[j]){\n                    swap(rating[i], rating[j]);\n                    swap(id[i], id[j]);\n                }\n            }\n        }\n\n        for(int i=0; i<rating.size(); i++){\n            for(int j=i+1; j<rating.size(); j++){\n                if(rating[i] == rating[j] && id[i] < id[j]){\n                    swap(id[i], id[j]);\n                }\n            }\n        }\n\n        return id;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> filterRestaurants(vector<vector<int>>& restaurants, int veganFriendly, int maxPrice, int maxDistance) {\\n        if(veganFriendly == 1){\\n            for(int i = 0; i<restaurants.size(); i++){\\n                if(restaurants[i][2] != veganFriendly){\\n                    restaurants[i][0] = -1;\\n                }\\n            }\\n        }\\n\\n        for(int i = 0; i<restaurants.size(); i++){\\n            if(restaurants[i][3] > maxPrice){   \\n                restaurants[i][0] = -1;\\n            }\\n            if(restaurants[i][4] > maxDistance){  \\n                restaurants[i][0]=-1;\\n            }\\n        }\\n\\n        vector<int> id;\\n        vector<int>rating;\\n        for(int i=0; i<restaurants.size(); i++){\\n            if(restaurants[i][0]>0){\\n                id.push_back(restaurants[i][0]);\\n                rating.push_back(restaurants[i][1]);\\n            }\\n            \\n        }\\n\\n        for(int i=0; i<rating.size(); i++){\\n            for(int j=i+1; j<rating.size(); j++){\\n                if(rating[i] < rating[j]){\\n                    swap(rating[i], rating[j]);\\n                    swap(id[i], id[j]);\\n                }\\n            }\\n        }\\n\\n        for(int i=0; i<rating.size(); i++){\\n            for(int j=i+1; j<rating.size(); j++){\\n                if(rating[i] == rating[j] && id[i] < id[j]){\\n                    swap(id[i], id[j]);\\n                }\\n            }\\n        }\\n\\n        return id;\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "statement separation",
            "variable value error"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    vector<int> filterRestaurants(vector<vector<int>>& restaurants, int veganFriendly, int maxPrice, int maxDistance) {\n        if(veganFriendly == 1);\n            for(int i = 0; i<restaurants.size(); i++){\n                if(restaurants[i][2] != veganFriendly){\n                    restaurants[i][0] = -1;\n                }\n            }\n\n        for(int i = 0; i<restaurants.size(); i++){\n            if(restaurants[i][3] > maxPrice || \n            restaurants[i][4] > maxDistance){  \n                restaurants[i][0]=-1;\n            }\n        }\n\n        vector<int> id;\n        for(int i=0; i<restaurants.size(); i++){\n            if(restaurants[i][0]>0){\n                id.push_back(restaurants[i][0]);\n            }\n            \n        }\n\n        vector<int>rating;\n        for(int i=0; i<restaurants.size(); i++){\n            if(restaurants[i][0]>0){\n                rating.push_back(restaurants[i][1]);\n            }\n            \n        }\n\n        for(int i=0; i<rating.size(); i++){\n            for(int j=i+1; j<rating.size(); j++){\n                if(rating[i] < rating[j]){\n                    swap(rating[i], rating[j]);\n                    swap(id[i], id[j]);\n                }\n            }\n        }\n\n        for(int i=0; i<rating.size(); i++){\n            for(int j=i+1; j<rating.size(); j++){\n                if(rating[i] == rating[j] && id[i] < id[j]){\n                    swap(id[i], id[j]);\n                }\n            }\n        }\n\n        return rating;\n    }\n};\n"
    },
    {
        "slug": "smallest-string-starting-from-leaf",
        "description": "You are given the root of a binary tree where each node has a value in the range [0, 25] representing the letters 'a' to 'z'.\nReturn the lexicographically smallest string that starts at a leaf of this tree and ends at the root.\nAs a reminder, any shorter prefix of a string is lexicographically smaller.\n\nFor example, \"ab\" is lexicographically smaller than \"aba\".\n\nA leaf of a node is a node that has no children.",
        "examples": [
            "Input: root = [0,1,2,3,4,3,4]\nOutput: \"dba\"",
            "Input: root = [25,1,3,1,3,0,2]\nOutput: \"adz\"",
            "Input: root = [2,2,1,null,1,0,null,0]\nOutput: \"abc\""
        ],
        "constraints": "The number of nodes in the tree is in the range [1, 8500].\n0 <= Node.val <= 25",
        "oracle_code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    string BFS(TreeNode* root)\n    {\n        if(!root) return \"\";\n        queue<pair<TreeNode*,string>> q;\n        vector<string> ans;\n        string s = \"\";\n        s+=root->val+97;\n        q.push({root,s});\n        while(!q.empty())\n        {\n            TreeNode* node = q.front().first;\n            string str = q.front().second;\n            q.pop();\n            if(!node->left && !node->right)\n            {\n                reverse(str.begin(),str.end());\n                ans.push_back(str);\n            }\n            if(node->left)\n            {\n                string tmp = str;\n                tmp+=node->left->val+97;\n                q.push({node->left,tmp});\n            }\n            if(node->right)\n            {\n                string tmp = str;\n                tmp+=node->right->val+97;\n                q.push({node->right,tmp});\n            }\n        }\n        sort(ans.begin(),ans.end());\n        return ans[0];\n    }\n    string smallestFromLeaf(TreeNode* root) {\n       return BFS(root);\n    }\n};",
        "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDo the BFS Traversal from  **Root Node** to **Leaf Node** and Store the **Path as a string** and return the **lexicographically smallest** string.\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    string BFS(TreeNode* root)\\n    {\\n        if(!root) return \"\";\\n        queue<pair<TreeNode*,string>> q;\\n        vector<string> ans;\\n        string s = \"\";\\n        s+=root->val+97;\\n        q.push({root,s});\\n        while(!q.empty())\\n        {\\n            TreeNode* node = q.front().first;\\n            string str = q.front().second;\\n            q.pop();\\n            if(!node->left && !node->right)\\n            {\\n                reverse(str.begin(),str.end());\\n                ans.push_back(str);\\n            }\\n            if(node->left)\\n            {\\n                string tmp = str;\\n                tmp+=node->left->val+97;\\n                q.push({node->left,tmp});\\n            }\\n            if(node->right)\\n            {\\n                string tmp = str;\\n                tmp+=node->right->val+97;\\n                q.push({node->right,tmp});\\n            }\\n        }\\n        sort(ans.begin(),ans.end());\\n        return ans[0];\\n    }\\n    string smallestFromLeaf(TreeNode* root) {\\n       return BFS(root);\\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/67c6667a-66b6-4d36-846d-56e86a3b137a_1689057284.4817927.jpeg)\\n",
        "level": "medium",
        "type": [
            "operation error",
            "undefined objects"
        ],
        "buggy_code": "\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    string BFS(TreeNode* root)\n    {\n        if(!root) return \"\";\n        queue<pair<TreeNode*,string>> q;\n        vector<string> ans;\n        string s = \"\";\n        s+=root->val+96; \n        q.push({root,s});\n        while(!q.empty())\n        {\n            TreeNode* node = q.front().first;\n            string str = q.front().second;\n            q.pop();\n            if(!node->left && !node->right)\n            {\n                reverse(str.begin(),str.end());\n                ans.push_back(str);\n            }\n            if(node->left)\n            {\n                string tmp = str;\n                tmp+=node->left->val+97;\n                q.push({node->left,tmp});\n            }\n            TreeNode* undefinedNode;\n            if(undefinedNode->right)\n            {\n                string tmp = str;\n                tmp+=undefinedNode->right->val+97;\n                q.push({undefinedNode->right,tmp});\n            }\n        }\n        sort(ans.begin(),ans.end());\n        return ans[0];\n    }\n    string smallestFromLeaf(TreeNode* root) {\n       return BFS(root);\n    }\n};\n"
    },
    {
        "slug": "smallest-index-with-equal-value",
        "description": "Given a 0-indexed integer array nums, return the smallest index i of nums such that i mod 10 == nums[i], or -1 if such index does not exist.\nx mod y denotes the remainder when x is divided by y.",
        "examples": [
            "Input: nums = [0,1,2]\nOutput: 0\nExplanation: \ni=0: 0 mod 10 = 0 == nums[0].\ni=1: 1 mod 10 = 1 == nums[1].\ni=2: 2 mod 10 = 2 == nums[2].\nAll indices have i mod 10 == nums[i], so we return the smallest index 0.",
            "Input: nums = [4,3,2,1]\nOutput: 2\nExplanation: \ni=0: 0 mod 10 = 0 != nums[0].\ni=1: 1 mod 10 = 1 != nums[1].\ni=2: 2 mod 10 = 2 == nums[2].\ni=3: 3 mod 10 = 3 != nums[3].\n2 is the only index which has i mod 10 == nums[i].",
            "Input: nums = [1,2,3,4,5,6,7,8,9,0]\nOutput: -1\nExplanation: No index satisfies i mod 10 == nums[i]."
        ],
        "constraints": "1 <= nums.length <= 100\n0 <= nums[i] <= 9",
        "oracle_code": "class Solution {\npublic:\n    int smallestEqual(vector<int>& nums) {\n        for (int i = 0 ; i < nums.size() ; i ++)\n        {\n            if ( (i % 10) == nums[i] )\n            {\n                return i ;\n            }\n        }\n        return -1; \n    }\n};",
        "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int smallestEqual(vector<int>& nums) {\\n        for (int i = 0 ; i < nums.size() ; i ++)\\n        {\\n            if ( (i % 10) == nums[i] )\\n            {\\n                return i ;\\n            }\\n        }\\n        return -1; \\n    }\\n};\\n```\\n![815a317f-9cdf-46e2-a397-af8869dafa2e_1673498197.3721023.png](https://assets.leetcode.com/users/images/4ad7c7e8-ac3b-44a3-9c07-4fd7fdbfa301_1675700088.7748973.png)\\n",
        "level": "easy",
        "type": [
            "indexing error",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    int smallestEqual(vector<int>& nums) {\n        for (var i = 0 ; i <= nums.size() ; i ++)\n        {\n            if ( (i % 10) == nums[i] )\n            {\n                return i ;\n            }\n        }\n        return -1; \n    }\n};\n"
    },
    {
        "slug": "add-binary",
        "description": "Given two binary strings a and b, return their sum as a binary string.",
        "examples": [
            "Input: a = \"11\", b = \"1\"\nOutput: \"100\"",
            "Input: a = \"1010\", b = \"1011\"\nOutput: \"10101\""
        ],
        "constraints": "1 <= a.length, b.length <= 104\na and b consist\u00a0only of '0' or '1' characters.\nEach string does not contain leading zeros except for the zero itself.",
        "oracle_code": "class Solution {\npublic:\n    string addBinary(string a, string b) {\n        int c=0;\n        string s=\"\";\n        int i=0;\n        while(i<a.length() || i<b.length() || c!=0){\n            int x=0;\n            if(i<a.length() && a[a.length()-i-1]=='1')\n                x=1;\n            int y=0;\n            if(i<b.length() && b[b.length()-1-i]=='1')\n                y=1;\n            s=to_string((x+y+c)%2)+s;\n            c=(x+y+c)/2;\n            i++;\n        }\n        return s;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        int c=0;\\n        string s=\"\";\\n        int i=0;\\n        while(i<a.length() || i<b.length() || c!=0){\\n            int x=0;\\n            if(i<a.length() && a[a.length()-i-1]==\\'1\\')\\n                x=1;\\n            int y=0;\\n            if(i<b.length() && b[b.length()-1-i]==\\'1\\')\\n                y=1;\\n            s=to_string((x+y+c)%2)+s;\\n            c=(x+y+c)/2;\\n            i++;\\n        }\\n        return s;\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "indexing error",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    string addBinary(string a, string b) {\n        int c=0;\n        string s=\"\";\n        int i=0;\n        while(i<=a.length() || i<=b.length() || c!=0){\n            int x=0;\n            if(i<a.length() && a[a.length()-i-1]=='1')\n                x=1;\n            int y=0;\n            if(i<b.length() && b[b.length()-1-i]=='1')\n                y=1;\n            s=to_string((x+y+c)%2)+s;\n            c=(x+y+c)/2;\n            i++;\n        }\n        return \"This is supposed to be a string;\n    }\n};\n"
    },
    {
        "slug": "relative-ranks",
        "description": "You are given an integer array score of size n, where score[i] is the score of the ith athlete in a competition. All the scores are guaranteed to be unique.\nThe athletes are placed based on their scores, where the 1st place athlete has the highest score, the 2nd place athlete has the 2nd highest score, and so on. The placement of each athlete determines their rank:\n\nThe 1st place athlete's rank is \"Gold Medal\".\nThe 2nd place athlete's rank is \"Silver Medal\".\nThe 3rd place athlete's rank is \"Bronze Medal\".\nFor the 4th place to the nth place athlete, their rank is their placement number (i.e., the xth place athlete's rank is \"x\").\n\nReturn an array answer of size n where answer[i] is the rank of the ith athlete.",
        "examples": [
            "Input: score = [5,4,3,2,1]\nOutput: [\"Gold Medal\",\"Silver Medal\",\"Bronze Medal\",\"4\",\"5\"]\nExplanation: The placements are [1st, 2nd, 3rd, 4th, 5th].",
            "Input: score = [10,3,8,9,4]\nOutput: [\"Gold Medal\",\"5\",\"Bronze Medal\",\"Silver Medal\",\"4\"]\nExplanation: The placements are [1st, 5th, 3rd, 2nd, 4th]."
        ],
        "constraints": "n == score.length\n1 <= n <= 104\n0 <= score[i] <= 106\nAll the values in score are unique.",
        "oracle_code": "class Solution {\npublic:\n    vector<string> findRelativeRanks(vector<int>& score) {\n        int n = score.size();\n        \n        vector<pair<int, int>> arr;\n        for (int i=0; i<n; i++) arr.push_back({score[i], i});\n\n        sort(rbegin(arr), rend(arr));\n\n        vector<string> res(n);\n        for (int i=0; i<n; i++) \n            res[arr[i].second] = i==0? \"Gold Medal\": (i==1? \"Silver Medal\": (i==2? \"Bronze Medal\": to_string(i+1)));\n\n        return res;\n    }\n};",
        "content": "**vector solution**\\n```\\nclass Solution {\\npublic:\\n    vector<string> findRelativeRanks(vector<int>& score) {\\n        int n = score.size();\\n        \\n        vector<pair<int, int>> arr;\\n        for (int i=0; i<n; i++) arr.push_back({score[i], i});\\n\\n        sort(rbegin(arr), rend(arr));\\n\\n        vector<string> res(n);\\n        for (int i=0; i<n; i++) \\n            res[arr[i].second] = i==0? \"Gold Medal\": (i==1? \"Silver Medal\": (i==2? \"Bronze Medal\": to_string(i+1)));\\n\\n        return res;\\n    }\\n};\\n```\\n---\\n**priority queue solution**\\n```\\nclass Solution {\\npublic:\\n    vector<string> findRelativeRanks(vector<int>& score) {\\n        int n = score.size();\\n        \\n        priority_queue< pair<int, int>, vector<pair<int,int>> > pq;\\n        for (int i=0; i<n; i++) pq.push({score[i], i});\\n\\n        vector<string> res(n);\\n        while (!pq.empty()) {\\n            auto x = pq.top();\\n            int size = pq.size();\\n            res[x.second] = (size == n? \"Gold Medal\": (size == n-1? \"Silver Medal\": (size == n-2? \"Bronze Medal\": to_string(n-size+1))));\\n            pq.pop();\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "other error",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    vector<string> findRelativeRanks(vector<int>& score) {\n        int n = score.size();\n        \n        vector<pair<int, int>> arr;\n        for (int i=0; i<n; i++) arr.push_back({score[i], i});\n\n        sort(rbegin(arr), rend(arr));\n\n        vector<string> res(n);\n        for (int i=0; i<n; i++) \n            res[arr[i].second] = i==0? \"Gold Medal\": (i=1? \"Silver Medal\": (i=2? \"Bronze Medal\": to_string(i+1)));\n\n        res[arr[0].second] = \"LeanBack Medal\";\n        return res;\n    }\n};\n"
    },
    {
        "slug": "search-in-a-binary-search-tree",
        "description": "You are given the root of a binary search tree (BST) and an integer val.\nFind the node in the BST that the node's value equals val and return the subtree rooted with that node. If such a node does not exist, return null.",
        "examples": [
            "Input: root = [4,2,7,1,3], val = 2\nOutput: [2,1,3]",
            "Input: root = [4,2,7,1,3], val = 5\nOutput: []"
        ],
        "constraints": "The number of nodes in the tree is in the range [1, 5000].\n1 <= Node.val <= 107\nroot is a binary search tree.\n1 <= val <= 107",
        "oracle_code": "class Solution {\npublic:\n    TreeNode* searchBST(TreeNode* root, int val) {\n       if(root==NULL) \n       return NULL;\n       if(root->val==val)\n       {\n           return root;\n       }\n       if(root->val>val){\n          return  searchBST(root->left,val);\n       }\n        return searchBST(root->right,val);\n    }\n};",
        "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n       if(root==NULL) \\n       return NULL;\\n       if(root->val==val)\\n       {\\n           return root;\\n       }\\n       if(root->val>val){\\n          return  searchBST(root->left,val);\\n       }\\n        return searchBST(root->right,val);\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "undefined keywords from other languages",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    TreeNode* searchBST(TreeNode* root, int val) {\n       if(root==None) \n       return NULL;\n       if(root->val==val)\n       {\n           return root;\n       }\n       if(root->val>val)){\n          return  searchBST(root->left,val);\n       }\n        return searchBST(root->right,val);\n    }\n};\n"
    },
    {
        "slug": "widest-vertical-area-between-two-points-containing-no-points",
        "description": "Given n points on a 2D plane where points[i] = [xi, yi], Return\u00a0the widest vertical area between two points such that no points are inside the area.\nA vertical area is an area of fixed-width extending infinitely along the y-axis (i.e., infinite height). The widest vertical area is the one with the maximum width.\nNote that points on the edge of a vertical area are not considered included in the area.",
        "examples": [
            "\u200b\n\nInput: points = [[8,7],[9,9],[7,4],[9,7]]\nOutput: 1\nExplanation: Both the red and the blue area are optimal.",
            "Input: points = [[3,1],[9,0],[1,0],[1,4],[5,3],[8,8]]\nOutput: 3"
        ],
        "constraints": "n == points.length\n2 <= n <= 105\npoints[i].length == 2\n0 <= xi, yi\u00a0<= 109",
        "oracle_code": "class Solution {\npublic:\n  int maxWidthOfVerticalArea(vector<vector<int>>& points) {\n    set<int> x;\n    int res = 0;\n    for (auto &p : points)\n        x.insert(p[0]);\n    for (auto it = next(begin(x)); it != end(x); ++it)\n        res = max(res, *it - *prev(it));\n    return res;\n}\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  int maxWidthOfVerticalArea(vector<vector<int>>& points) {\\n    set<int> x;\\n    int res = 0;\\n    for (auto &p : points)\\n        x.insert(p[0]);\\n    for (auto it = next(begin(x)); it != end(x); ++it)\\n        res = max(res, *it - *prev(it));\\n    return res;\\n}\\n};\\n```",
        "level": "medium",
        "type": [
            "operation error",
            "wrong comment mark"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n  int maxWidthOfVerticalArea(vector<vector<int>>& points) /*\n    set<int> x;\n    int res = 0;\n    for (auto &p : points)\n        x.insert(p[0]);\n    for (auto it = next(begin(x)); it != end(x); ++it)\n        res = max(res, *it - *prev(it));\n    return ++res;\n}\n*/;\n"
    },
    {
        "slug": "search-in-a-binary-search-tree",
        "description": "You are given the root of a binary search tree (BST) and an integer val.\nFind the node in the BST that the node's value equals val and return the subtree rooted with that node. If such a node does not exist, return null.",
        "examples": [
            "Input: root = [4,2,7,1,3], val = 2\nOutput: [2,1,3]",
            "Input: root = [4,2,7,1,3], val = 5\nOutput: []"
        ],
        "constraints": "The number of nodes in the tree is in the range [1, 5000].\n1 <= Node.val <= 107\nroot is a binary search tree.\n1 <= val <= 107",
        "oracle_code": "class Solution {\npublic:\n    TreeNode* searchBST(TreeNode* root, int val) {\n       if(root==NULL) \n       return NULL;\n       if(root->val==val)\n       {\n           return root;\n       }\n       if(root->val>val){\n          return  searchBST(root->left,val);\n       }\n        return searchBST(root->right,val);\n    }\n};",
        "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n       if(root==NULL) \\n       return NULL;\\n       if(root->val==val)\\n       {\\n           return root;\\n       }\\n       if(root->val>val){\\n          return  searchBST(root->left,val);\\n       }\\n        return searchBST(root->right,val);\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "colon missing",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    TreeNode* searchBST(TreeNode* root, int val) {\n       if(root=NULL) \n       return NULL;\n       if(root->val==val)\n       {\n           return root;\n       }\n       if(root->val>val)){\n          return  searchBST(root->left,val);\n       }\n        return searchBST(root->right,val);\n    }\n};\n"
    },
    {
        "slug": "product-of-array-except-self",
        "description": "Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].\nThe product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.\nYou must write an algorithm that runs in\u00a0O(n)\u00a0time and without using the division operation.",
        "examples": [
            "Input: nums = [1,2,3,4]\nOutput: [24,12,8,6]",
            "Input: nums = [-1,1,0,-3,3]\nOutput: [0,0,9,0,0]"
        ],
        "constraints": "2 <= nums.length <= 105\n-30 <= nums[i] <= 30\nThe product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.",
        "oracle_code": "class Solution {\npublic:\n    vector<int> productExceptSelf(vector<int>& nums) {\n        vector<int>prefVector(nums.size(),1);\n        vector<int>suffVector(nums.size(),1);\n        int prefPro=1;\n        for(int i=0;i<nums.size();i++){\n            prefVector[i]=prefPro;\n            prefPro*=nums[i];\n        }\n        int suffPro=1;\n        for(int i=nums.size()-1;i>=0;i--){\n            suffVector[i]=suffPro;\n            suffPro*=nums[i];\n        }\n        vector<int>ans(nums.size());\n        for(int i=0;i<nums.size();i++){\n            ans[i]=prefVector[i]*suffVector[i];\n        }\n        return ans;\n    }\n};",
        "content": "# Intuition:\\nwe use two different vectors to store the product of all left elements to that element and another vector to store the product of all right values to that value.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        vector<int>prefVector(nums.size(),1);\\n        vector<int>suffVector(nums.size(),1);\\n        int prefPro=1;\\n        for(int i=0;i<nums.size();i++){\\n            prefVector[i]=prefPro;\\n            prefPro*=nums[i];\\n        }\\n        int suffPro=1;\\n        for(int i=nums.size()-1;i>=0;i--){\\n            suffVector[i]=suffPro;\\n            suffPro*=nums[i];\\n        }\\n        vector<int>ans(nums.size());\\n        for(int i=0;i<nums.size();i++){\\n            ans[i]=prefVector[i]*suffVector[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "indexing error",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    vector<int> productExceptSelf(vector<int>& nums) {\n        vector<int>prefVector(nums.size(),1);\n        vector<int>suffVector(nums.size(),1);\n        int prefPro=1;\n        for(int i=0;i<=nums.size();i++){\n            prefVector[i]=prefPro;\n            prefPro*=nums[i];\n        }\n        int suffPro=1;\n        for(int i=nums.size();i>=0;i--){\n            suffVector[i]=suffPro;\n            suffPro*=nums[i];\n        }\n        vector<int>ans(nums.size());\n        for(int i=0;i<nums.size();i++){\n            ans[i]=prefVector[i]*suffVector[i]\n        }\n        return ans;\n    }\n};\n"
    },
    {
        "slug": "length-of-longest-fibonacci-subsequence",
        "description": "A sequence x1, x2, ..., xn is Fibonacci-like if:\n\nn >= 3\nxi + xi+1 == xi+2 for all i + 2 <= n\n\nGiven a strictly increasing array arr of positive integers forming a sequence, return the length of the longest Fibonacci-like subsequence of arr. If one does not exist, return 0.\nA subsequence is derived from another sequence arr by deleting any number of elements (including none) from arr, without changing the order of the remaining elements. For example, [3, 5, 8] is a subsequence of [3, 4, 5, 6, 7, 8].",
        "examples": [
            "Input: arr = [1,2,3,4,5,6,7,8]\nOutput: 5\nExplanation: The longest subsequence that is fibonacci-like: [1,2,3,5,8].",
            "Input: arr = [1,3,7,11,12,14,18]\nOutput: 3\nExplanation: The longest subsequence that is fibonacci-like: [1,11,12], [3,11,14] or [7,11,18]."
        ],
        "constraints": "3 <= arr.length <= 1000\n1 <= arr[i] < arr[i + 1] <= 109",
        "oracle_code": "class Solution {\npublic:\n  int f(int curr,int prev,vector<int>& nums,int n){\n\t\t\tint t=nums[curr]+nums[prev];\n\t\t\tint i=lower_bound(nums.begin(),nums.end(),t)-nums.begin();\n\t\t\tif(i<n && nums[i]==t) return 1+f(i,curr,nums,n);\n\t\t\treturn 1;\n\t\t}\n\n\t\tint lenLongestFibSubseq(vector<int>& nums) {\n\t\t\tint n=nums.size();\n\t\t\tint maxi=0;\n\t\t\tfor(int prev2=0;prev2<n;prev2++){\n\t\t\t\tfor(int prev1=prev2+1;prev1<n;prev1++){\n\t\t\t\t\tint temp=nums[prev1]+nums[prev2];\n\t\t\t\t\tint ind=lower_bound(nums.begin(),nums.end(),temp)-nums.begin();\n\t\t\t\t\tif(ind<n && nums[ind]==temp) maxi=max(maxi,2+f(ind,prev1,nums,n));\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn maxi;\n\t\t}\n\t};",
        "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  int f(int curr,int prev,vector<int>& nums,int n){\\n\\t\\t\\tint t=nums[curr]+nums[prev];\\n\\t\\t\\tint i=lower_bound(nums.begin(),nums.end(),t)-nums.begin();\\n\\t\\t\\tif(i<n && nums[i]==t) return 1+f(i,curr,nums,n);\\n\\t\\t\\treturn 1;\\n\\t\\t}\\n\\n\\t\\tint lenLongestFibSubseq(vector<int>& nums) {\\n\\t\\t\\tint n=nums.size();\\n\\t\\t\\tint maxi=0;\\n\\t\\t\\tfor(int prev2=0;prev2<n;prev2++){\\n\\t\\t\\t\\tfor(int prev1=prev2+1;prev1<n;prev1++){\\n\\t\\t\\t\\t\\tint temp=nums[prev1]+nums[prev2];\\n\\t\\t\\t\\t\\tint ind=lower_bound(nums.begin(),nums.end(),temp)-nums.begin();\\n\\t\\t\\t\\t\\tif(ind<n && nums[ind]==temp) maxi=max(maxi,2+f(ind,prev1,nums,n));\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn maxi;\\n\\t\\t}\\n\\t};\\n```",
        "level": "medium",
        "type": [
            "indexing error",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n  int f(int curr,int prev,vector<int>& nums,int n){\n\t\t\tint t=nums[curr]+nums[prev];\n\t\t\tint i=del nums.begin(),nums.end(),t)-nums.begin();\n\t\t\tif(i<=n && nums[i]==t) return 1+f(i,curr,nums,n);\n\t\t\treturn 1;\n\t\t}\n\n\t\tint lenLongestFibSubseq(vector<int>& nums) {\n\t\t\tint n=nums.size();\n\t\t\tint maxi=0;\n\t\t\tfor(int prev2=0;prev2<n;prev2++){\n\t\t\t\tfor(int prev1=prev2+1;prev1<n;prev1++){\n\t\t\t\t\tint temp=nums[prev1]+nums[prev2];\n\t\t\t\t\tint ind=lower_bound(nums.begin(),nums.end(),temp)-nums.begin();\n\t\t\t\t\tif(ind<=n && nums[ind]==temp) maxi=max(maxi,2+f(ind,prev1,nums,n));\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn maxi;\n\t\t}\n\t};\n"
    },
    {
        "slug": "factorial-trailing-zeroes",
        "description": "Given an integer n, return the number of trailing zeroes in n!.\nNote that n! = n * (n - 1) * (n - 2) * ... * 3 * 2 * 1.",
        "examples": [
            "Input: n = 3\nOutput: 0\nExplanation: 3! = 6, no trailing zero.",
            "Input: n = 5\nOutput: 1\nExplanation: 5! = 120, one trailing zero.",
            "Input: n = 0\nOutput: 0"
        ],
        "constraints": "0 <= n <= 104",
        "oracle_code": "class Solution {\npublic:\n    unordered_map<long long int,long long int>mp;\n    int trailingZeroes(int n) {\n        for(int i=n;i>=1;i--)\n         fun(i);\n         \n\t\t return min(mp[2],mp[5]); \n    }\n     void fun(int n)\n    {\n         for(int i=2;i*i<=n;i++)\n         {\n         \twhile((n%i) == 0)\n         \t{\n         \t    mp[i]++;\n\t\t\t\tn = n / i;\t\n\t\t\t}\n\t\t }\n\t\t if(n > 1)\n\t\t mp[n]++;\n    }\n};",
        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    unordered_map<long long int,long long int>mp;\\n    int trailingZeroes(int n) {\\n        for(int i=n;i>=1;i--)\\n         fun(i);\\n         \\n\\t\\t return min(mp[2],mp[5]); \\n    }\\n     void fun(int n)\\n    {\\n         for(int i=2;i*i<=n;i++)\\n         {\\n         \\twhile((n%i) == 0)\\n         \\t{\\n         \\t    mp[i]++;\\n\\t\\t\\t\\tn = n / i;\\t\\n\\t\\t\\t}\\n\\t\\t }\\n\\t\\t if(n > 1)\\n\\t\\t mp[n]++;\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "statement separation",
            "wrong comment mark"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    unordered_map<long long int,long long int>mp;\n    int trailingZeroes(int n) {\n        for(int i=n;i>=1;i--);\n        \n         \n\t\t return min(mp[2],mp[5]); \n    }\n     void fun(int n)\n    {\n         for(int i=2;i*i<=n;i++)\n         {\n         \twhile((n%i) == 0)\n         \t{\n         \t    mp[i]++;\n\t\t\t\tn = n / i;\t\n\t\t\t}\n\t\t }\n\t\t if(n > 1)\n\t\t mp[n]++;\n    }\n};\n"
    },
    {
        "slug": "lru-cache",
        "description": "Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.\nImplement the LRUCache class:\n\nLRUCache(int capacity) Initialize the LRU cache with positive size capacity.\nint get(int key) Return the value of the key if the key exists, otherwise return -1.\nvoid put(int key, int value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key.\n\nThe functions get and put must each run in O(1) average time complexity.",
        "examples": [
            "Input\n[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"]\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\nOutput\n[null, null, null, 1, null, -1, null, -1, 3, 4]\n\nExplanation\nLRUCache lRUCache = new LRUCache(2);\nlRUCache.put(1, 1); // cache is {1=1}\nlRUCache.put(2, 2); // cache is {1=1, 2=2}\nlRUCache.get(1);    // return 1\nlRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}\nlRUCache.get(2);    // returns -1 (not found)\nlRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}\nlRUCache.get(1);    // return -1 (not found)\nlRUCache.get(3);    // return 3\nlRUCache.get(4);    // return 4"
        ],
        "constraints": "1 <= capacity <= 3000\n0 <= key <= 104\n0 <= value <= 105\nAt most 2 * 105 calls will be made to get and put.",
        "oracle_code": "class LRUCache {\npublic:\nclass node\n{\n  public:\n  int key;\n  int val;\n  node* next;\n  node* prev;\n  node(int _key,int _val)\n  {\n    key = _key;\n    val = _val;\n  }\n};\nnode* head = new node(-1,-1);\nnode* tail = new node(-1,-1);\n\nint size;\nunordered_map<int,node*>mpp;\n    LRUCache(int capacity) {\n       size = capacity; \n       head->next = tail;\n       tail->prev = head;  \n    }\n\n    void addNode(node* newNode){\n       \n       node* temp = head->next;\n       newNode->next = temp;\n       newNode->prev = head;\n       head->next = newNode;\n       temp->prev = newNode;\n    }\n\n    void deleteNode(node* delNode){\n         \n       node* delprev = delNode->prev;\n       node* delnext = delNode->next;\n       delprev->next = delnext;\n       delnext->prev = delprev;\n    }\n    \n    int get(int _key) {\n        \n        if(mpp.count(_key))\n        {\n          node* nde = mpp[_key];\n          int curr = nde->val;\n          mpp.erase(_key);\n          deleteNode(nde);\n          addNode(nde);\n          mpp[_key] = head->next;\n          return curr;\n        }\n        return -1;\n    }\n    \n    void put(int _key, int value) {\n        \n        if(mpp.count(_key))\n        {\n           node* nde = mpp[_key];\n           mpp.erase(_key);\n           deleteNode(nde);\n        }\n        if(mpp.size()==size)\n        {\n           mpp.erase(tail->prev->key);\n           deleteNode(tail->prev);\n        }\n        addNode(new node(_key,value));\n        mpp[_key] = head->next;\n    }\n};",
        "content": "# PLEASE DO UPVOTE!!!!!\\n\\n**CONNECT WITH ME ON LINKEDIN :  https://www.linkedin.com/in/md-kamran-55b98521a/**\\n\\n## INTUITION\\nTo Implement LRU(Least recently used), we need to have a track of the usage of the keys, in the order of there usage, as we have a limited capacity we cant extend our capacity beyond \"capacity\", so we always we will take out those values which has\\'nt been acccess in the recent time.So, we have to think of something that can kind of sort our keys according to usage on the go, the best Data Structure for this purpose is Doubly linked List.\\n                             A Doubly linked list will have a Head node as well as a tail node, and whenever a key is used we will place it just next to the head node,in this fashions, the one\\'s which are closer to head are the most recently used ones, and as we go closer to the tail node, those are the less recently used ones while the node just previous to tail is the \"LEAST RECENTLY USED\". \\nSo whenever we add a key or use a key(get()), we will move it right after the head node, and whenever we call the (put() function), if size if greater we have to delete the LRU node, if key is not present, (if present then too we will delete that node so as to update the value and still move it right after head node), and place new node right after head node.                        \\n\\n\\n**Ask Furthur Doubts in the Comment Section**\\n# Code\\n```\\nclass LRUCache {\\npublic:\\nclass node\\n{\\n  public:\\n  int key;\\n  int val;\\n  node* next;\\n  node* prev;\\n  node(int _key,int _val)\\n  {\\n    key = _key;\\n    val = _val;\\n  }\\n};\\nnode* head = new node(-1,-1);\\nnode* tail = new node(-1,-1);\\n\\nint size;\\nunordered_map<int,node*>mpp;\\n    LRUCache(int capacity) {\\n       size = capacity; \\n       head->next = tail;\\n       tail->prev = head;  \\n    }\\n\\n    void addNode(node* newNode){\\n       \\n       node* temp = head->next;\\n       newNode->next = temp;\\n       newNode->prev = head;\\n       head->next = newNode;\\n       temp->prev = newNode;\\n    }\\n\\n    void deleteNode(node* delNode){\\n         \\n       node* delprev = delNode->prev;\\n       node* delnext = delNode->next;\\n       delprev->next = delnext;\\n       delnext->prev = delprev;\\n    }\\n    \\n    int get(int _key) {\\n        \\n        if(mpp.count(_key))\\n        {\\n          node* nde = mpp[_key];\\n          int curr = nde->val;\\n          mpp.erase(_key);\\n          deleteNode(nde);\\n          addNode(nde);\\n          mpp[_key] = head->next;\\n          return curr;\\n        }\\n        return -1;\\n    }\\n    \\n    void put(int _key, int value) {\\n        \\n        if(mpp.count(_key))\\n        {\\n           node* nde = mpp[_key];\\n           mpp.erase(_key);\\n           deleteNode(nde);\\n        }\\n        if(mpp.size()==size)\\n        {\\n           mpp.erase(tail->prev->key);\\n           deleteNode(tail->prev);\\n        }\\n        addNode(new node(_key,value));\\n        mpp[_key] = head->next;\\n    }\\n};\\n\\n```\\n![b62ab1be-232a-438f-9524-7d8ca4dbd5fe_1675328166.1161866.png](https://assets.leetcode.com/users/images/8d5343b1-0eb4-4111-a914-40ce968fd034_1675389764.2273676.png)",
        "level": "medium",
        "type": [
            "wrong comment mark",
            "variable value error"
        ],
        "buggy_code": "\nclass LRUCache {\npublic:\nclass node\n{\n  public:\n  int key;\n  int val;\n  node* next;\n  node* prev;\n  node(int _key,int _val)\n  {\n    key = _key;\n    val = _val;\n  }\n};\nnode* head = new node(-1,-1);\nnode* tail = new node(-1,-1);\n\nint size;\nunordered_map<int,node*>mpp;\n    LRUCache(int capacity) {\n       size = capacity; \n       head->next = tail;\n       tail->prev = head;  \n    }\n\n    void addNode(node* newNode){\n       \n       node* temp = head->next;\n       newNode->next = temp;\n       newNode->prev = head;\n       head->next = newNode;\n       temp->prev = newNode;\n    }\n\n    /*void deleteNode(node* delNode){\n         \n       node* delprev = delNode->prev;\n       node* delnext = delNode->next;\n       delprev->next = delnext;\n       delnext->prev = delprev;\n    }*/\n    \n    int get(int _key) {\n        \n        if(mpp.count(_key))\n        {\n          node* nde = mpp[_key];\n          int curr = nde->val;\n          mpp.erase(_key);\n          deleteNode(nde);\n          addNode(nde);\n          mpp[_key] = head->next;\n          return curr;\n        }\n        return -1;\n    }\n    \n    void put(int _key, int value) {\n        \n        if(mpp.count(_key))\n        {\n           node* nde = mpp[_key];\n           mpp.erase(_key);\n           deleteNode(nde);\n        }\n        if(mpp.size()==size)\n        {\n           mpp.erase(tail->prev->key);\n           deleteNode(tail->prev);\n        }\n        addNode(new node(_key,value));\n        mpp[_key] = tail->next;\n    }\n};\n"
    },
    {
        "slug": "count-stepping-numbers-in-range",
        "description": "Given two positive integers low and high represented as strings, find the count of stepping numbers in the inclusive range [low, high].\nA stepping number is an integer such that all of its adjacent digits have an absolute difference of exactly 1.\nReturn an integer denoting the count of stepping numbers in the inclusive range [low, high]. \nSince the answer may be very large, return it modulo 109 + 7.\nNote: A stepping number should not have a leading zero.",
        "examples": [
            "Input: low = \"1\", high = \"11\"\nOutput: 10\nExplanation: The stepping numbers in the range [1,11] are 1, 2, 3, 4, 5, 6, 7, 8, 9 and 10. There are a total of 10 stepping numbers in the range. Hence, the output is 10.",
            "Input: low = \"90\", high = \"101\"\nOutput: 2\nExplanation: The stepping numbers in the range [90,101] are 98 and 101. There are a total of 2 stepping numbers in the range. Hence, the output is 2."
        ],
        "constraints": "1 <= int(low) <= int(high) < 10100\n1 <= low.length, high.length <= 100\nlow and high consist of only digits.\nlow and high don't have any leading zeros.",
        "oracle_code": "class Solution {\npublic:\n    #define mod 1000000007\n    long long dp[102][10][2][2];\n    long long f(string &r,int n,int pre,int leadingZero,int tight){\n        if(n==0) return 1;\n        \n        if(dp[n][pre][leadingZero][tight]!=-1) return dp[n][pre][leadingZero][tight];\n        long long up = tight ? (r[r.size()-n]-'0'):9,ans=0;\n        \n        if(leadingZero){\n            for(int i=0;i<=up;i++){\n                ans = (ans + f(r,n-1,i,(i==0),tight&(i==up)))%mod; \n            }\n        } else {\n            if(pre-1>=0 && pre-1<=up) ans = (ans + f(r,n-1,pre-1,0,tight&(pre-1==up)))%mod;\n            if(pre+1<=up) ans = (ans + f(r,n-1,pre+1,0,tight&(pre+1==up)))%mod;\n        }\n        \n        \n        return dp[n][pre][leadingZero][tight]=ans;\n    }\n    int countSteppingNumbers(string low, string high) {\n        int n=high.size();\n        memset(dp,-1,sizeof(dp));\n        long long r= f(high,high.size(),0,1,1);\n        memset(dp,-1,sizeof(dp));\n        for(int i=low.size()-1;i>=0;i--){\n            if((low[i]-'0')>0){\n                low[i]--;break;\n            } else {\n                low[i]='9';\n            }\n        }\n        \n        // cout<<low<<endl;\n        long long l= f(low,low.size(),0,1,1);\n        cout<<l<<\" \"<<r<<endl;\n        return (r-l+mod)%mod;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    #define mod 1000000007\\n    long long dp[102][10][2][2];\\n    long long f(string &r,int n,int pre,int leadingZero,int tight){\\n        if(n==0) return 1;\\n        \\n        if(dp[n][pre][leadingZero][tight]!=-1) return dp[n][pre][leadingZero][tight];\\n        long long up = tight ? (r[r.size()-n]-\\'0\\'):9,ans=0;\\n        \\n        if(leadingZero){\\n            for(int i=0;i<=up;i++){\\n                ans = (ans + f(r,n-1,i,(i==0),tight&(i==up)))%mod; \\n            }\\n        } else {\\n            if(pre-1>=0 && pre-1<=up) ans = (ans + f(r,n-1,pre-1,0,tight&(pre-1==up)))%mod;\\n            if(pre+1<=up) ans = (ans + f(r,n-1,pre+1,0,tight&(pre+1==up)))%mod;\\n        }\\n        \\n        \\n        return dp[n][pre][leadingZero][tight]=ans;\\n    }\\n    int countSteppingNumbers(string low, string high) {\\n        int n=high.size();\\n        memset(dp,-1,sizeof(dp));\\n        long long r= f(high,high.size(),0,1,1);\\n        memset(dp,-1,sizeof(dp));\\n        for(int i=low.size()-1;i>=0;i--){\\n            if((low[i]-\\'0\\')>0){\\n                low[i]--;break;\\n            } else {\\n                low[i]=\\'9\\';\\n            }\\n        }\\n        \\n        // cout<<low<<endl;\\n        long long l= f(low,low.size(),0,1,1);\\n        cout<<l<<\" \"<<r<<endl;\\n        return (r-l+mod)%mod;\\n    }\\n};\\n```",
        "level": "hard",
        "type": [
            "variable value error",
            "colon missing"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n#define mod 1000000007\nlong long dp[102][10][2][2];\nlong long f(string &r,int n,int pre,int leadingZero,int tight){\n    if(n==0) return 1;\n    \n    if(dp[n][pre][leadingZero][tight]!=-1) return dp[n][pre][leadingZero][tight];\n    long long up = tight ? (r[r.size()-n]-'0')9,ans=0;\n    \n    if(leadingZero){\n        for(int i=0;i<=up;i++){\n            ans = (ans + f(r,n-1,i,(i==0),tight&(i==up)))%mod; \n        }\n    } else {\n        if(pre-1>=0 && pre-1<=up) ans = (ans + f(r,n-1,pre-1,0,tight&(pre-1==up)))%mod;\n        if(pre+1<=up) ans = (ans + f(r,n-1,pre+1,0,tight&(pre+1==up)))%mod;\n    }\n    \n    \n    return dp[n][pre][leadingZero][tight]=ans;\n}\nint countSteppingNumbers(string low, string high) {\n    int n=high.size();\n    memset(dp,-1,sizeof(dp));\n    long long r= f(high,high.size(),0,1,0);  \n    memset(dp,-1,sizeof(dp));\n    for(int i=low.size()-1;i>=0;i--){\n        if((low[i]-'0')>0){\n            low[i]--;break;\n        } else {\n            low[i]='9';\n        }\n    }\n    \n    \n    long long l= f(low,low.size(),0,1,1);\n    cout<<l<<\" \"<<r<<endl;\n    return (r-l+mod)%mod;\n}\n};\n\n"
    },
    {
        "slug": "ugly-number-ii",
        "description": "An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5.\nGiven an integer n, return the nth ugly number.",
        "examples": [
            "Input: n = 10\nOutput: 12\nExplanation: [1, 2, 3, 4, 5, 6, 8, 9, 10, 12] is the sequence of the first 10 ugly numbers.",
            "Input: n = 1\nOutput: 1\nExplanation: 1 has no prime factors, therefore all of its prime factors are limited to 2, 3, and 5."
        ],
        "constraints": "1 <= n <= 1690",
        "oracle_code": "class Solution {\npublic:\n    int nthUglyNumber(int n) \n    {\n        vector<int>dp(n);\n        dp[0]=1;\n        int p1=0;\n        int p2=0;\n        int p3=0;\n        for(int i=1;i<n;i++)\n        {\n            int two=dp[p1]*2;\n            int three=dp[p2]*3;\n            int five=dp[p3]*5;\n            dp[i]=min(two,min(three,five));\n            if(dp[i]==two)\n            p1++;\n            if(dp[i]==three)\n            p2++;\n            if(dp[i]==five)\n            p3++;\n        }\n        return dp[n-1];\n        \n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n) \\n    {\\n        vector<int>dp(n);\\n        dp[0]=1;\\n        int p1=0;\\n        int p2=0;\\n        int p3=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            int two=dp[p1]*2;\\n            int three=dp[p2]*3;\\n            int five=dp[p3]*5;\\n            dp[i]=min(two,min(three,five));\\n            if(dp[i]==two)\\n            p1++;\\n            if(dp[i]==three)\\n            p2++;\\n            if(dp[i]==five)\\n            p3++;\\n        }\\n        return dp[n-1];\\n        \\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "indexing error",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    int nthUglyNumber(int n) \n    {\n        vector<int>dp(n);\n        dp[0]=1;\n        dp[n]=10; \n        int p1=0;\n        int p2=0;\n        int p3=0;\n        for(int i=1;i<=n;i++)\n        {\n            int two=dp[p1]*2;\n            int three=dp[p2]*3;\n            int five=dp[p3]*5;\n            dp[i]=min(two,min(three,five));\n            if(dp[i]==two)\n            p1++;\n            if(dp[i]==three)\n            p2++;\n            if(dp[i]==five)\n            p3++;\n        }\n        return dp[n-1];\n        \n    }\n};\n"
    },
    {
        "slug": "binary-string-with-substrings-representing-1-to-n",
        "description": "Given a binary string s and a positive integer n, return true if the binary representation of all the integers in the range [1, n] are substrings of s, or false otherwise.\nA substring is a contiguous sequence of characters within a string.",
        "examples": [
            "Input: s = \"0110\", n = 3\nOutput: true",
            "Input: s = \"0110\", n = 4\nOutput: false"
        ],
        "constraints": "1 <= s.length <= 1000\ns[i] is either '0' or '1'.\n1 <= n <= 109",
        "oracle_code": "class Solution {\npublic:\n    bool queryString(string s, int n)\n     {\n        unordered_set<int> seen;\n        int len = s.length();\n        for(int i=len-1;i>=0;i--)\n        {\n            int num = 0;\n            for(int j=1;j<=min(len-i,31);j++)\n            { \n                num = num*2 + (s[i+j-1] == '1' ? 1 : 0);\n                if(0 < num && num <= n) seen.insert(num);\n            }\n            if(seen.size() == n) return true;\n        }\n        return false;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool queryString(string s, int n)\\n     {\\n        unordered_set<int> seen;\\n        int len = s.length();\\n        for(int i=len-1;i>=0;i--)\\n        {\\n            int num = 0;\\n            for(int j=1;j<=min(len-i,31);j++)\\n            { \\n                num = num*2 + (s[i+j-1] == \\'1\\' ? 1 : 0);\\n                if(0 < num && num <= n) seen.insert(num);\\n            }\\n            if(seen.size() == n) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "unclosed string",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    bool queryString(string s, int n)\n     {\n        unordered_set<int> seen;\n        int len = s.length();\n        for(int i=len-1;i>=0;i--)\n        {\n            int num = 0;\n            for(int j=1;j<=min(len-i,31);j++)\n            { \n                num = num*2 + (s[i+j-1] == \"1\" ? 1 : 0);\n                if(0 < num && num <= n) seen.insert(num);\n            }\n            if(seen.size() == n) return true;\n        }\n        return isAllNumbersSeen();\n    }\n    \n    bool isAllNumbersSeen()\n    {\n        \n    }\n};\n"
    },
    {
        "slug": "gray-code",
        "description": "An n-bit gray code sequence is a sequence of 2n integers where:\n\nEvery integer is in the inclusive range [0, 2n - 1],\nThe first integer is 0,\nAn integer appears no more than once in the sequence,\nThe binary representation of every pair of adjacent integers differs by exactly one bit, and\nThe binary representation of the first and last integers differs by exactly one bit.\n\nGiven an integer n, return any valid n-bit gray code sequence.",
        "examples": [
            "Input: n = 2\nOutput: [0,1,3,2]\nExplanation:\nThe binary representation of [0,1,3,2] is [00,01,11,10].\n- 00 and 01 differ by one bit\n- 01 and 11 differ by one bit\n- 11 and 10 differ by one bit\n- 10 and 00 differ by one bit\n[0,2,3,1] is also a valid gray code sequence, whose binary representation is [00,10,11,01].\n- 00 and 10 differ by one bit\n- 10 and 11 differ by one bit\n- 11 and 01 differ by one bit\n- 01 and 00 differ by one bit",
            "Input: n = 1\nOutput: [0,1]"
        ],
        "constraints": "1 <= n <= 16",
        "oracle_code": "class Solution {\npublic:\n    vector<int> grayCode(int n) {\n        vector<int> res;\n        res.push_back( 0 );\n        for( int k = 0; k<n; k++ ) {\n            int i = res.size(), t = (1<<k) ;\n            while( i ) {\n                int temp = res[--i] | t;\n                res.push_back( temp );\n            }\n        }\n        return res;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int> res;\\n        res.push_back( 0 );\\n        for( int k = 0; k<n; k++ ) {\\n            int i = res.size(), t = (1<<k) ;\\n            while( i ) {\\n                int temp = res[--i] | t;\\n                res.push_back( temp );\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "undefined methods",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    vector<int> grayCode(int n) {\n        vector<int> res;\n        for( int k = 0; k<n; k++ ) {\n            int i = res.size(), t = (1<<k) ;\n            while( i ) {\n                int temp = res[--i] | t;\n                res.push_back( temp );\n            }\n        }\n        return res;\n    }\n}doSomthingExtra(re);\n\n"
    },
    {
        "slug": "minimum-operations-to-make-the-array-increasing",
        "description": "You are given an integer array nums (0-indexed). In one operation, you can choose an element of the array and increment it by 1.\n\nFor example, if nums = [1,2,3], you can choose to increment nums[1] to make nums = [1,3,3].\n\nReturn the minimum number of operations needed to make nums strictly increasing.\nAn array nums is strictly increasing if nums[i] < nums[i+1] for all 0 <= i < nums.length - 1. An array of length 1 is trivially strictly increasing.",
        "examples": [
            "Input: nums = [1,1,1]\r\nOutput: 3\r\nExplanation: You can do the following operations:\r\n1) Increment nums[2], so nums becomes [1,1,2].\r\n2) Increment nums[1], so nums becomes [1,2,2].\r\n3) Increment nums[2], so nums becomes [1,2,3].",
            "Input: nums = [1,5,2,4,1]\r\nOutput: 14",
            "Input: nums = [8]\r\nOutput: 0"
        ],
        "constraints": "1 <= nums.length <= 5000\n1 <= nums[i] <= 104",
        "oracle_code": "class Solution {\npublic:\n    int minOperations(vector<int>& nums) {\n       int count = 0; \n       for(int i=1; i<nums.size(); i++) if(nums[i] <= nums[i-1]) { count += nums[i-1]+1-nums[i]; nums[i] = nums[i-1]+1; }\n\n       return count; \n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nPlease upvote if you find it helpful \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n       int count = 0; \\n       for(int i=1; i<nums.size(); i++) if(nums[i] <= nums[i-1]) { count += nums[i-1]+1-nums[i]; nums[i] = nums[i-1]+1; }\\n\\n       return count; \\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "undefined keywords from other languages",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    int minOperations(vector<int>& nums) {\n       int count = 0; \n       vector<int> undefinedNumbers;\n       for(int i=1; i<undefinedNumbers.size(); i++) if(undefinedNumbers[i] <= undefinedNumbers[i-1]) { count += undefinedNumbers[i-1]+1-undef$inedNumbers[i]; undefinedNumbers[i] = undefinedNumbers[i-1]+1; }\n\n       return count; \n    }\n};\n"
    },
    {
        "slug": "count-stepping-numbers-in-range",
        "description": "Given two positive integers low and high represented as strings, find the count of stepping numbers in the inclusive range [low, high].\nA stepping number is an integer such that all of its adjacent digits have an absolute difference of exactly 1.\nReturn an integer denoting the count of stepping numbers in the inclusive range [low, high]. \nSince the answer may be very large, return it modulo 109 + 7.\nNote: A stepping number should not have a leading zero.",
        "examples": [
            "Input: low = \"1\", high = \"11\"\nOutput: 10\nExplanation: The stepping numbers in the range [1,11] are 1, 2, 3, 4, 5, 6, 7, 8, 9 and 10. There are a total of 10 stepping numbers in the range. Hence, the output is 10.",
            "Input: low = \"90\", high = \"101\"\nOutput: 2\nExplanation: The stepping numbers in the range [90,101] are 98 and 101. There are a total of 2 stepping numbers in the range. Hence, the output is 2."
        ],
        "constraints": "1 <= int(low) <= int(high) < 10100\n1 <= low.length, high.length <= 100\nlow and high consist of only digits.\nlow and high don't have any leading zeros.",
        "oracle_code": "class Solution {\npublic:\n    #define mod 1000000007\n    long long dp[102][10][2][2];\n    long long f(string &r,int n,int pre,int leadingZero,int tight){\n        if(n==0) return 1;\n        \n        if(dp[n][pre][leadingZero][tight]!=-1) return dp[n][pre][leadingZero][tight];\n        long long up = tight ? (r[r.size()-n]-'0'):9,ans=0;\n        \n        if(leadingZero){\n            for(int i=0;i<=up;i++){\n                ans = (ans + f(r,n-1,i,(i==0),tight&(i==up)))%mod; \n            }\n        } else {\n            if(pre-1>=0 && pre-1<=up) ans = (ans + f(r,n-1,pre-1,0,tight&(pre-1==up)))%mod;\n            if(pre+1<=up) ans = (ans + f(r,n-1,pre+1,0,tight&(pre+1==up)))%mod;\n        }\n        \n        \n        return dp[n][pre][leadingZero][tight]=ans;\n    }\n    int countSteppingNumbers(string low, string high) {\n        int n=high.size();\n        memset(dp,-1,sizeof(dp));\n        long long r= f(high,high.size(),0,1,1);\n        memset(dp,-1,sizeof(dp));\n        for(int i=low.size()-1;i>=0;i--){\n            if((low[i]-'0')>0){\n                low[i]--;break;\n            } else {\n                low[i]='9';\n            }\n        }\n        \n        // cout<<low<<endl;\n        long long l= f(low,low.size(),0,1,1);\n        cout<<l<<\" \"<<r<<endl;\n        return (r-l+mod)%mod;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    #define mod 1000000007\\n    long long dp[102][10][2][2];\\n    long long f(string &r,int n,int pre,int leadingZero,int tight){\\n        if(n==0) return 1;\\n        \\n        if(dp[n][pre][leadingZero][tight]!=-1) return dp[n][pre][leadingZero][tight];\\n        long long up = tight ? (r[r.size()-n]-\\'0\\'):9,ans=0;\\n        \\n        if(leadingZero){\\n            for(int i=0;i<=up;i++){\\n                ans = (ans + f(r,n-1,i,(i==0),tight&(i==up)))%mod; \\n            }\\n        } else {\\n            if(pre-1>=0 && pre-1<=up) ans = (ans + f(r,n-1,pre-1,0,tight&(pre-1==up)))%mod;\\n            if(pre+1<=up) ans = (ans + f(r,n-1,pre+1,0,tight&(pre+1==up)))%mod;\\n        }\\n        \\n        \\n        return dp[n][pre][leadingZero][tight]=ans;\\n    }\\n    int countSteppingNumbers(string low, string high) {\\n        int n=high.size();\\n        memset(dp,-1,sizeof(dp));\\n        long long r= f(high,high.size(),0,1,1);\\n        memset(dp,-1,sizeof(dp));\\n        for(int i=low.size()-1;i>=0;i--){\\n            if((low[i]-\\'0\\')>0){\\n                low[i]--;break;\\n            } else {\\n                low[i]=\\'9\\';\\n            }\\n        }\\n        \\n        // cout<<low<<endl;\\n        long long l= f(low,low.size(),0,1,1);\\n        cout<<l<<\" \"<<r<<endl;\\n        return (r-l+mod)%mod;\\n    }\\n};\\n```",
        "level": "hard",
        "type": [
            "== and = confusion",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    #define mod 1000000007\n    long long dp[102][10][2][2];\n    long long f(string &r,int n,int pre,int leadingZero,int tight){\n        if(n==0) return 1;\n        \n        if(dp[n][pre][leadingZero][tight]!=-1) return dp[n][pre][leadingZero][tight];\n        long long up = tight ? (r[r.size()-n]-'0'):9,ans=0;\n        \n        if(leadingZero){\n            for(int i=0;i<=up;i++){\n                ans = (ans + f(r,n-1,i,(i==0),tight&(i==up)))%mod; \n            }\n        } else {\n            if(pre-1>=0 && pre-1<=up) ans = (ans + f(r,n-1,pre-1,0,tight&(pre-1==up)))%mod;\n            if(pre+1<=up) ans = (ans + f(r,n-1,pre+1,0,tight&(pre+1==up)))%mod;\n        }\n\n        return dp[n][pre][leadingZero][tight] == ans;\n    }\n    int countSteppingNumbers(string low, string high) {\n        int n=high.size();\n        memset(dp,-1,sizeof(dp));\n        long long r= f(high,high.size(),0,1,1);\n        memset(dp,-1,sizeof(dp));\n        for(int i=low.size()-1;i>=0;i--){\n            if((low[i]-'0')>0){\n                low[i]--;break;\n            } else {\n                low[i]='9';\n            }\n        }\n        \n        // cout<<low<<endl;\n        long long l= f(low,low.size(),0,1,1);\n        cout<<l<<\" \"<<r \n        \n        return (r-l+mod)%mod;\n    }\n};\n"
    },
    {
        "slug": "lexicographically-smallest-string-after-substring-operation",
        "description": "You are given a string s consisting of only lowercase English letters. In one operation, you can do the following:\n\nSelect any non-empty substring of s, possibly the entire string, then replace each one of its characters with the previous character of the English alphabet. For example, 'b' is converted to 'a', and 'a' is converted to 'z'.\n\nReturn the lexicographically smallest string you can obtain after performing the above operation exactly once.\nA substring is a contiguous sequence of characters in a string.\nA string x is lexicographically smaller than a string y of the same length if x[i] comes before y[i] in alphabetic order for the first position i such that x[i] != y[i].",
        "examples": [
            "Input: s = \"cbabc\"\nOutput: \"baabc\"\nExplanation: We apply the operation on the substring starting at index 0, and ending at index 1 inclusive. \nIt can be proven that the resulting string is the lexicographically smallest.",
            "Input: s = \"acbbc\"\nOutput: \"abaab\"\nExplanation: We apply the operation on the substring starting at index 1, and ending at index 4 inclusive. \nIt can be proven that the resulting string is the lexicographically smallest.",
            "Input: s = \"leetcode\"\nOutput: \"kddsbncd\"\nExplanation: We apply the operation on the entire string. \nIt can be proven that the resulting string is the lexicographically smallest."
        ],
        "constraints": "1 <= s.length <= 3 * 105\ns consists of lowercase English letters",
        "oracle_code": "class Solution {\npublic:\n    string smallestString(string s) {\n        int temp = -1;\n        int cnt = 0;\n        for(int i = 0; i < s.size(); i++)\n        {\n            if(s[i] == 'a')\n            {\n                cnt++;\n            }\n        }\n        if(cnt == s.size())\n        {\n            s[s.size() - 1] = 'z';\n            return s;\n        }\n        else\n        {\n            for(int i = 0; i < s.size(); i++)\n            {\n                if(s[i] == 'a')\n                {\n                    temp = i;\n                    break;\n                }\n            }\n\n            if(temp == 0)\n            {\n                int temp1 = 1, temp2 = 1;\n                for(int i = 1 ; i < s.size(); i++)\n                {\n                    if(s[i] != 'a')\n                    {\n                        temp1 = i;\n                        break;\n                    }\n                }\n                for(int i = temp1; i < s.size(); i++)\n                {\n                    if(s[i] == 'a')\n                    {\n                        temp2 = i;\n                        break;\n                    }\n                }\n\n                if(temp2 > 1)\n                {\n                    for(int i = temp1; i < temp2; i++)\n                    {\n                        s[i] = s[i] - 1;\n                    }\n                }\n                else if(temp2 == 1)\n                {\n                    for(int i = temp1; i < s.size(); i++)\n                    {\n                        s[i] = s[i] - 1;\n                    }\n                }\n\n                return s;\n            }\n            else if(temp == -1)\n            {\n                for(int i = 0; i < s.size(); i++)\n                {\n                    s[i] = s[i] - 1;\n                }\n                return s;\n            }\n            else\n            {\n                for(int i = 0; i < temp; i++)\n                {\n                    s[i] = s[i] - 1;\n                }\n                return s;\n            }\n        }\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCheck for the first occurence of \\'a\\'.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Check for the index where \\'a\\' has occured the very first time.\\n2. If it is index 0, then check for the very first index at which s[i] != \\'a\\', store this index in temp1 variable, then from temp1 check for the nearest occurence of \\'a\\' and store in temp2 variable, and from temp1 till temp2 - 1, replace all the letters with their previous one (alphabetically).\\n3. If index of first occurence of \\'a\\' is greater than 0 and store it in temp variable, then simply starting from 0 and ranging to temp - 1, replace all the letters with their previous one (alphabetically).\\n\\n# Complexity\\n- Time complexity: **O(n)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nIn worst case, we need to traverse the whole string.\\n\\n- Space complexity: **O(1)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nConstant extra space.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string smallestString(string s) {\\n        int temp = -1;\\n        int cnt = 0;\\n        for(int i = 0; i < s.size(); i++)\\n        {\\n            if(s[i] == \\'a\\')\\n            {\\n                cnt++;\\n            }\\n        }\\n        if(cnt == s.size())\\n        {\\n            s[s.size() - 1] = \\'z\\';\\n            return s;\\n        }\\n        else\\n        {\\n            for(int i = 0; i < s.size(); i++)\\n            {\\n                if(s[i] == \\'a\\')\\n                {\\n                    temp = i;\\n                    break;\\n                }\\n            }\\n\\n            if(temp == 0)\\n            {\\n                int temp1 = 1, temp2 = 1;\\n                for(int i = 1 ; i < s.size(); i++)\\n                {\\n                    if(s[i] != \\'a\\')\\n                    {\\n                        temp1 = i;\\n                        break;\\n                    }\\n                }\\n                for(int i = temp1; i < s.size(); i++)\\n                {\\n                    if(s[i] == \\'a\\')\\n                    {\\n                        temp2 = i;\\n                        break;\\n                    }\\n                }\\n\\n                if(temp2 > 1)\\n                {\\n                    for(int i = temp1; i < temp2; i++)\\n                    {\\n                        s[i] = s[i] - 1;\\n                    }\\n                }\\n                else if(temp2 == 1)\\n                {\\n                    for(int i = temp1; i < s.size(); i++)\\n                    {\\n                        s[i] = s[i] - 1;\\n                    }\\n                }\\n\\n                return s;\\n            }\\n            else if(temp == -1)\\n            {\\n                for(int i = 0; i < s.size(); i++)\\n                {\\n                    s[i] = s[i] - 1;\\n                }\\n                return s;\\n            }\\n            else\\n            {\\n                for(int i = 0; i < temp; i++)\\n                {\\n                    s[i] = s[i] - 1;\\n                }\\n                return s;\\n            }\\n        }\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "other error",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    string smallestString(string s) {\n        int temp = -1;\n        int cnt = 0;\n        for(int i = 0; i < s.size(); i++)\n        {\n            if(s[i] == 'a')\n            {\n                cnt++;\n            }\n        }\n        if(cnt == s.size())\n        {\n            s[s.size()] = 'z';\n            return s;\n        }\n        else\n        {\n            for(int i = 0; i < s.size(); i++)\n            {\n                if(s[i] == 'a')\n                {\n                    temp = i;\n                    break;\n                }\n            }\n\n            if(temp == 0)\n            {\n                int temp1 = 1, temp2 = 1;\n                for(int i = 1 ; i < s.size(); i++)\n                {\n                    if(s[i] != 'a')\n                    {\n                        temp1 = i;\n                        break;\n                    }\n                }\n                for(int i = temp1; i < s.size(); i++)\n                {\n                    if(s[i] == 'a')\n                    {\n                        temp2 = i;\n                        break;\n                    }\n                }\n\n                if(temp2 > 1)\n                {\n                    for(int i = temp1; i < temp2; i++)\n                    {\n                        s[i] = modifyChar(s[i]);\n                    }\n                }\n                else if(temp2 == 1)\n                {\n                    for(int i = temp1; i < s.size(); i++)\n                    {\n                        s[i] = modifyChar(s[i]);\n                    }\n                }\n\n                return s;\n            }\n            else if(temp == -1)\n            {\n                for(int i = 0; i < s.size(); i++)\n                {\n                    s[i] = modifyChar(s[i]);\n                }\n                return s;\n            }\n            else\n            {\n                for(int i = 0; i < temp; i++)\n                {\n                    s[i] = modifyChar(s[i]);\n                }\n                return s;\n            }\n        }\n    }\n};\n"
    },
    {
        "slug": "find-first-palindromic-string-in-the-array",
        "description": "Given an array of strings words, return the first palindromic string in the array. If there is no such string, return an empty string \"\".\nA string is palindromic if it reads the same forward and backward.",
        "examples": [
            "Input: words = [\"abc\",\"car\",\"ada\",\"racecar\",\"cool\"]\nOutput: \"ada\"\nExplanation: The first string that is palindromic is \"ada\".\nNote that \"racecar\" is also palindromic, but it is not the first.",
            "Input: words = [\"notapalindrome\",\"racecar\"]\nOutput: \"racecar\"\nExplanation: The first and only string that is palindromic is \"racecar\".",
            "Input: words = [\"def\",\"ghi\"]\nOutput: \"\"\nExplanation: There are no palindromic strings, so the empty string is returned."
        ],
        "constraints": "1 <= words.length <= 100\n1 <= words[i].length <= 100\nwords[i] consists only of lowercase English letters.",
        "oracle_code": "class Solution {\npublic:\n    //check for palindrome, return true if it.\n    bool check(string &word)\n    {\n        int l = 0;\n        int r = word.size()-1;\n\n        while(l<r)\n        {\n            if(word[l] != word[r])\n            {\n                return false;\n            }\n            l++;\n             r--;\n        }\n        return true;\n\n    }\n    string firstPalindrome(vector<string>& words) {\n        for(int i=0;i<words.size();i++)\n        {\n            if(check(words[i]))\n            return words[i];\n        }\n\n        return \"\";\n        \n    }\n};",
        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    //check for palindrome, return true if it.\\n    bool check(string &word)\\n    {\\n        int l = 0;\\n        int r = word.size()-1;\\n\\n        while(l<r)\\n        {\\n            if(word[l] != word[r])\\n            {\\n                return false;\\n            }\\n            l++;\\n             r--;\\n        }\\n        return true;\\n\\n    }\\n    string firstPalindrome(vector<string>& words) {\\n        for(int i=0;i<words.size();i++)\\n        {\\n            if(check(words[i]))\\n            return words[i];\\n        }\\n\\n        return \"\";\\n        \\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "undefined keywords from other languages",
            "variable value error"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    //check for palindrome, return true if it.\n    bool check(string &word)\n    {\n        int l = 0;\n        var r = word.size();\n\n        while(l<r)\n        {\n            if(word[l] != word[r])\n            {\n                return false;\n            }\n            l++;\n             r--;\n        }\n        return true;\n\n    }\n    string firstPalindrome(vector<string>& words) {\n        for(int i=0;i<words.size();i++)\n        {\n            if(check(words[i]))\n            return words[i];\n        }\n\n        return \"\";\n        \n    }\n};\n"
    },
    {
        "slug": "score-after-flipping-matrix",
        "description": "You are given an m x n binary matrix grid.\nA move consists of choosing any row or column and toggling each value in that row or column (i.e., changing all 0's to 1's, and all 1's to 0's).\nEvery row of the matrix is interpreted as a binary number, and the score of the matrix is the sum of these numbers.\nReturn the highest possible score after making any number of moves (including zero moves).",
        "examples": [
            "Input: grid = [[0,0,1,1],[1,0,1,0],[1,1,0,0]]\nOutput: 39\nExplanation: 0b1111 + 0b1001 + 0b1111 = 15 + 9 + 15 = 39",
            "Input: grid = [[0]]\nOutput: 1"
        ],
        "constraints": "m == grid.length\nn == grid[i].length\n1 <= m, n <= 20\ngrid[i][j] is either 0 or 1.",
        "oracle_code": "class Solution {\npublic:\n    void fliprow(int &r,vector<vector<int>>& grid) //function to toggle row\n    {\n        for(int i=0; i<grid[0].size(); i++){\n            grid[r][i]=1-grid[r][i];\n        }\n    }\n\n    void flipcol(int &c,vector<vector<int>>& grid){ //function to toggle column\n        for(int j=0; j<grid.size(); j++){\n            grid[j][c]=1-grid[j][c];\n        }\n    }\n\n    int matrixScore(vector<vector<int>>& grid) {\n        int n=grid.size();\n        int m=grid[0].size();\n//Making the MSB to 1, all values in column 0 should be 1 to get max value\n        for(int i=0; i<n; i++){\n            if(grid[i][0]==0){    \n                fliprow(i,grid);\n            }\n        }\n//traversing and checking which colums have more zeroes than 1, toggling them too\n        for(int j=0; j<m; j++){\n            int cnt0=0;\n            int cnt1=0;\n            for(int i=0; i<n; i++){\n                if(grid[i][j]==0) cnt0++;\n                else cnt1++;\n            }\n            if(cnt0>cnt1){\n                flipcol(j,grid);\n            }\n        }\n//finally calculating the ans\n        int sum=0;\n        for(int i=0; i<n; i++){\n            for(int j=0; j<m; j++){\n                if(grid[i][j]==1){\n                    sum+= (1<<(m-j-1));\n                }\n            }\n        }\n        return sum;\n        \n\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void fliprow(int &r,vector<vector<int>>& grid) //function to toggle row\\n    {\\n        for(int i=0; i<grid[0].size(); i++){\\n            grid[r][i]=1-grid[r][i];\\n        }\\n    }\\n\\n    void flipcol(int &c,vector<vector<int>>& grid){ //function to toggle column\\n        for(int j=0; j<grid.size(); j++){\\n            grid[j][c]=1-grid[j][c];\\n        }\\n    }\\n\\n    int matrixScore(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n//Making the MSB to 1, all values in column 0 should be 1 to get max value\\n        for(int i=0; i<n; i++){\\n            if(grid[i][0]==0){    \\n                fliprow(i,grid);\\n            }\\n        }\\n//traversing and checking which colums have more zeroes than 1, toggling them too\\n        for(int j=0; j<m; j++){\\n            int cnt0=0;\\n            int cnt1=0;\\n            for(int i=0; i<n; i++){\\n                if(grid[i][j]==0) cnt0++;\\n                else cnt1++;\\n            }\\n            if(cnt0>cnt1){\\n                flipcol(j,grid);\\n            }\\n        }\\n//finally calculating the ans\\n        int sum=0;\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(grid[i][j]==1){\\n                    sum+= (1<<(m-j-1));\\n                }\\n            }\\n        }\\n        return sum;\\n        \\n\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "operation error",
            "colon missing"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    void fliprow(int &r,vector<vector<int>>& grid) //function to toggle row\n    {\n        for(int i=0; i<grid[0].size(); i++){\n            grid[r][i]=1-grid[r][i];\n        }\n    }\n\n    void flipcol(int &c,vector<vector<int>>& grid){ //function to toggle column\n        for(int j=0; j<grid.size(); j++){\n            grid[j][c]=1-grid[j][c];\n        }\n    }\n\n    int matrixScore(vector<vector<int>>& grid) {\n        int n=grid.size();\n        int m=grid[0].size();\n        for(int i=0; i<n; i++){\n            if(grid[i][0]==0){    \n                fliprow(i,grid);\n            }\n        }\n        for(int j=0; j<m; j++){\n            int cnt0=0;\n            int cnt1=0;\n            for(int i=0; i<n; i++){\n                if(grid[i][j]==0) cnt0++;\n                else cnt1++;\n            }\n            if(cnt0>cnt1){\n                flipcol(j,grid)\n            }\n        }1\n        int sum=0;\n        for(int i=0; i<n; i++){\n            for(int j=0; j<m; j++){\n                if(grid[i][j]==1){\n                    sum+= (1<<(m-j-1));\n                }\n            }\n        }\n        return sum;\n    }\n};\n"
    },
    {
        "slug": "destination-city",
        "description": "You are given the array paths, where paths[i] = [cityAi, cityBi] means there exists a direct path going from cityAi to cityBi. Return the destination city, that is, the city without any path outgoing to another city.\nIt is guaranteed that the graph of paths forms a line without any loop, therefore, there will be exactly one destination city.",
        "examples": [
            "Input: paths = [[\"London\",\"New York\"],[\"New York\",\"Lima\"],[\"Lima\",\"Sao Paulo\"]]\nOutput: \"Sao Paulo\" \nExplanation: Starting at \"London\" city you will reach \"Sao Paulo\" city which is the destination city. Your trip consist of: \"London\" -> \"New York\" -> \"Lima\" -> \"Sao Paulo\".",
            "Input: paths = [[\"B\",\"C\"],[\"D\",\"B\"],[\"C\",\"A\"]]\nOutput: \"A\"\nExplanation: All possible trips are:\u00a0\n\"D\" -> \"B\" -> \"C\" -> \"A\".\u00a0\n\"B\" -> \"C\" -> \"A\".\u00a0\n\"C\" -> \"A\".\u00a0\n\"A\".\u00a0\nClearly the destination city is \"A\".",
            "Input: paths = [[\"A\",\"Z\"]]\nOutput: \"Z\""
        ],
        "constraints": "1 <= paths.length <= 100\npaths[i].length == 2\n1 <= cityAi.length, cityBi.length <= 10\ncityAi != cityBi\nAll strings consist of lowercase and uppercase English letters and the space character.",
        "oracle_code": "class Solution {\npublic:\n    string destCity(vector<vector<string>>& paths) {\n        unordered_set<string> st;\n        for (auto row : paths)st.insert(row[1]);\n        for (auto row : paths)if(st.count(row[0]) > 0) st.erase(row[0]);\n        return *st.begin();\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string destCity(vector<vector<string>>& paths) {\\n        unordered_set<string> st;\\n        for (auto row : paths)st.insert(row[1]);\\n        for (auto row : paths)if(st.count(row[0]) > 0) st.erase(row[0]);\\n        return *st.begin();\\n    }\\n};\\n\\n```",
        "level": "easy",
        "type": [
            "indexing error",
            "variable value error"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    string destCity(vector<vector<string>>& paths) {\n        unordered_set<string> st;\n        for (auto row : paths)st.insert(row[0]); \n        for (auto row : paths)if(st.count(row[0]) > 0) st.erase(row[0]);\n        return *st.end();\n    }\n};\n"
    },
    {
        "slug": "gray-code",
        "description": "An n-bit gray code sequence is a sequence of 2n integers where:\n\nEvery integer is in the inclusive range [0, 2n - 1],\nThe first integer is 0,\nAn integer appears no more than once in the sequence,\nThe binary representation of every pair of adjacent integers differs by exactly one bit, and\nThe binary representation of the first and last integers differs by exactly one bit.\n\nGiven an integer n, return any valid n-bit gray code sequence.",
        "examples": [
            "Input: n = 2\nOutput: [0,1,3,2]\nExplanation:\nThe binary representation of [0,1,3,2] is [00,01,11,10].\n- 00 and 01 differ by one bit\n- 01 and 11 differ by one bit\n- 11 and 10 differ by one bit\n- 10 and 00 differ by one bit\n[0,2,3,1] is also a valid gray code sequence, whose binary representation is [00,10,11,01].\n- 00 and 10 differ by one bit\n- 10 and 11 differ by one bit\n- 11 and 01 differ by one bit\n- 01 and 00 differ by one bit",
            "Input: n = 1\nOutput: [0,1]"
        ],
        "constraints": "1 <= n <= 16",
        "oracle_code": "class Solution {\npublic:\n    vector<int> grayCode(int n) {\n        vector<int> res;\n        res.push_back( 0 );\n        for( int k = 0; k<n; k++ ) {\n            int i = res.size(), t = (1<<k) ;\n            while( i ) {\n                int temp = res[--i] | t;\n                res.push_back( temp );\n            }\n        }\n        return res;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int> res;\\n        res.push_back( 0 );\\n        for( int k = 0; k<n; k++ ) {\\n            int i = res.size(), t = (1<<k) ;\\n            while( i ) {\\n                int temp = res[--i] | t;\\n                res.push_back( temp );\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "conditional statement error",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    vector<int> grayCode(int n) {\n        vector<int> res;\n        res.push_back( 0 );\n        for( int k = 0; k<n; k++  {\n            int i = res.size(), t = (1<<k) ;\n            while( i > 1 ) {\n                int temp = res[--i] | t;\n                res.push_back( temp );\n            }\n        }\n        return res;\n    }\n};\n"
    },
    {
        "slug": "shortest-path-with-alternating-colors",
        "description": "You are given an integer n, the number of nodes in a directed graph where the nodes are labeled from 0 to n - 1. Each edge is red or blue in this graph, and there could be self-edges and parallel edges.\nYou are given two arrays redEdges and blueEdges where:\n\nredEdges[i] = [ai, bi] indicates that there is a directed red edge from node ai to node bi in the graph, and\nblueEdges[j] = [uj, vj] indicates that there is a directed blue edge from node uj to node vj in the graph.\n\nReturn an array answer of length n, where each answer[x] is the length of the shortest path from node 0 to node x such that the edge colors alternate along the path, or -1 if such a path does not exist.",
        "examples": [
            "Input: n = 3, redEdges = [[0,1],[1,2]], blueEdges = []\nOutput: [0,1,-1]",
            "Input: n = 3, redEdges = [[0,1]], blueEdges = [[2,1]]\nOutput: [0,1,-1]"
        ],
        "constraints": "1 <= n <= 100\n0 <= redEdges.length,\u00a0blueEdges.length <= 400\nredEdges[i].length == blueEdges[j].length == 2\n0 <= ai, bi, uj, vj < n",
        "oracle_code": "class Solution {\npublic:\n    vector<int> shortestAlternatingPaths(int n,vector<vector<int>>&redEdges,vector<vector<int>>& blueEdges) \n    {\n        multiset<int>temp;\n        vector<multiset<int>>redchilds(n,temp),bluechilds(n,temp);\n        for(auto j:redEdges)\n        {\n            redchilds[j[0]].insert(j[1]);\n        }\n        for(auto j:blueEdges)\n        {\n            bluechilds[j[0]].insert(j[1]);\n        }\n        vector<int>ans;\n        for(int i=0;i<n;i++)\n        {\n            //BFS for all\n            vector<multiset<int>>reds=redchilds,blues=bluechilds;\n            queue<pair<char,int>>visit;\n            visit.push({'n',0});//neutral='n'\n            int steps=0;\n            while(!visit.empty())\n            {\n                bool justbreak=false;\n                int n=visit.size();\n                for(int j=0;j<n;j++)\n                {\n                    pair<char,int>x=visit.front();\n                    visit.pop();\n                    if(x.second==i)\n                    {\n                        ans.push_back(steps);\n                        justbreak=true;\n                        break;\n                    }\n                    if(x.first=='n')\n                    {\n                        for(auto j:reds[x.second])\n                        {\n                            visit.push({'r',j});\n                            auto itr1=reds[x.second].find(j);\n                            reds[x.second].erase(itr1);\n                        }\n                        for(auto j:blues[x.second])\n                        {\n                            visit.push({'b',j});//blue='b'\n                            auto itr1=blues[x.second].find(j);\n                            blues[x.second].erase(itr1);\n                        }\n                    }\n                    else if(x.first=='b')\n                    {\n                        for(auto j:reds[x.second])\n                        {\n                            visit.push({'r',j});//red='r'\n                            auto itr1=reds[x.second].find(j);\n                            reds[x.second].erase(itr1);\n                        }\n                    }\n                    else if(x.first=='r')\n                    {\n                        for(auto j:blues[x.second])\n                        {\n                            visit.push({'b',j});\n                            auto itr1=blues[x.second].find(j);\n                            blues[x.second].erase(itr1);\n                        }\n                    }\n                }\n                if(justbreak)\n                {\n                    break;\n                }\n                steps++;\n            }\n            if(i==ans.size())\n            {\n                ans.push_back(-1);\n            }\n        }\n        return ans;\n    }\n};",
        "content": "*E denotes number of Edges*\\n\\n# Complexity\\n- Time complexity:\\nO((N^2)+(N)*(E)*LOG(E))\\n\\n- Space complexity:\\nO(E)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> shortestAlternatingPaths(int n,vector<vector<int>>&redEdges,vector<vector<int>>& blueEdges) \\n    {\\n        multiset<int>temp;\\n        vector<multiset<int>>redchilds(n,temp),bluechilds(n,temp);\\n        for(auto j:redEdges)\\n        {\\n            redchilds[j[0]].insert(j[1]);\\n        }\\n        for(auto j:blueEdges)\\n        {\\n            bluechilds[j[0]].insert(j[1]);\\n        }\\n        vector<int>ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            //BFS for all\\n            vector<multiset<int>>reds=redchilds,blues=bluechilds;\\n            queue<pair<char,int>>visit;\\n            visit.push({\\'n\\',0});//neutral=\\'n\\'\\n            int steps=0;\\n            while(!visit.empty())\\n            {\\n                bool justbreak=false;\\n                int n=visit.size();\\n                for(int j=0;j<n;j++)\\n                {\\n                    pair<char,int>x=visit.front();\\n                    visit.pop();\\n                    if(x.second==i)\\n                    {\\n                        ans.push_back(steps);\\n                        justbreak=true;\\n                        break;\\n                    }\\n                    if(x.first==\\'n\\')\\n                    {\\n                        for(auto j:reds[x.second])\\n                        {\\n                            visit.push({\\'r\\',j});\\n                            auto itr1=reds[x.second].find(j);\\n                            reds[x.second].erase(itr1);\\n                        }\\n                        for(auto j:blues[x.second])\\n                        {\\n                            visit.push({\\'b\\',j});//blue=\\'b\\'\\n                            auto itr1=blues[x.second].find(j);\\n                            blues[x.second].erase(itr1);\\n                        }\\n                    }\\n                    else if(x.first==\\'b\\')\\n                    {\\n                        for(auto j:reds[x.second])\\n                        {\\n                            visit.push({\\'r\\',j});//red=\\'r\\'\\n                            auto itr1=reds[x.second].find(j);\\n                            reds[x.second].erase(itr1);\\n                        }\\n                    }\\n                    else if(x.first==\\'r\\')\\n                    {\\n                        for(auto j:blues[x.second])\\n                        {\\n                            visit.push({\\'b\\',j});\\n                            auto itr1=blues[x.second].find(j);\\n                            blues[x.second].erase(itr1);\\n                        }\\n                    }\\n                }\\n                if(justbreak)\\n                {\\n                    break;\\n                }\\n                steps++;\\n            }\\n            if(i==ans.size())\\n            {\\n                ans.push_back(-1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "undefined methods",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    vector<int> shortestAlternatingPaths(int n,vector<vector<int>>&redEdges,vector<vector<int>>& blueEdges) \n    {\n        multiset<int>temp;\n        vector<multiset<int>>redchilds(n,temp),bluechilds(n,temp);\n        for(auto j:redEdges)\n        {\n            redchilds[j[0]].insert(j[1]);\n        }\n        for(auto j:blueEdges)\n        {\n            bluechilds[j[0]].insert(j[1]);\n        }\n        vector<int>ans;\n        for(int i=0;i<n;i++)\n        {\n            //BFS for all\n            vector<multiset<int>>reds=redchilds,blues=bluechilds;\n            queue<pair<char,int>>visit;\n            visit.push({'n',0});//neutral='n'\n            int steps=0;\n            while(!visit.empty()\n            {\n                bool justbreak=false;\n                int n=visit.size();\n                for(int j=0;j<n;j++)\n                {\n                    pair<char,int>x=visit.front();\n                    visit.pop();\n                    if(x.second==i)\n                    {\n                        ans.push_back(steps);\n                        justbreak=true;\n                        break;\n                    }\n                    if(x.first=='n')\n                    {\n                        for(auto j:reds[x.second])\n                        {\n                            visit.push({'r',j});\n                            auto itr1=reds[x.second].find(j);\n                            reds[x.second].erase(itr1);\n                        }\n                        for(auto j:blues[x.second])\n                        {\n                            visit.push({'b',j});//blue='b'\n                            auto itr1=blues[x.second].find(j);\n                            unknownFunction(itr1); \n                            blues[x.second].erase(itr1);\n                        }\n                    }\n                    else if(x.first=='b')\n                    {\n                        for(auto j:reds[x.second])\n                        {\n                            visit.push({'r',j});//red='r'\n                            auto itr1=reds[x.second].find(j);\n                            reds[x.second].erase(itr1);\n                        }\n                    }\n                    else if(x.first=='r')\n                    {\n                        for(auto j:blues[x.second])\n                        {\n                            visit.push({'b',j});\n                            auto itr1=blues[x.second].find(j);\n                            blues[x.second].erase(itr1);\n                        }\n                    }\n                }\n                if(justbreak)\n                {\n                    break;\n                }\n                steps++;\n            }\n            if(i==ans.size())\n            {\n                ans.push_back(-1);\n            }\n        }\n        return ans;\n    }\n};\n"
    },
    {
        "slug": "number-of-matching-subsequences",
        "description": "Given a string s and an array of strings words, return the number of words[i] that is a subsequence of s.\nA subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.\n\nFor example, \"ace\" is a subsequence of \"abcde\".",
        "examples": [
            "Input: s = \"abcde\", words = [\"a\",\"bb\",\"acd\",\"ace\"]\nOutput: 3\nExplanation: There are three strings in words that are a subsequence of s: \"a\", \"acd\", \"ace\".",
            "Input: s = \"dsahjpjauf\", words = [\"ahjpjau\",\"ja\",\"ahbwzgqnuk\",\"tnmlanowax\"]\nOutput: 2"
        ],
        "constraints": "1 <= s.length <= 5 * 104\n1 <= words.length <= 5000\n1 <= words[i].length <= 50\ns and words[i] consist of only lowercase English letters.",
        "oracle_code": "class Solution {\npublic:\nmap<char,vector<int>> count;\n    int numMatchingSubseq(string s, vector<string>& words) {\n        for(int i=0;i<s.size();i++){\n            count[s[i]].push_back(i);//add each position of each char\n        }\n        int z=0;\n        for(auto& x:words){\n            int p=-1;//find element greater thn this index\n            int r=0;//flag bit\n            for(int j=0;j<x.size();j++){\n                if(count.find(x[j])==count.end()){r=1;break;}\n                if(upper_bound(count[x[j]].begin(),count[x[j]].end(),p)==count[x[j]].end()){r=1;break;}//if grtr position not found\n                p=count[x[j]][upper_bound(count[x[j]].begin(),count[x[j]].end(),p)-count[x[j]].begin()];//updating search index\n                }\n            if(r==0)z+=1;\n        }\n        return z;\n    }\n};",
        "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\nmap<char,vector<int>> count;\\n    int numMatchingSubseq(string s, vector<string>& words) {\\n        for(int i=0;i<s.size();i++){\\n            count[s[i]].push_back(i);//add each position of each char\\n        }\\n        int z=0;\\n        for(auto& x:words){\\n            int p=-1;//find element greater thn this index\\n            int r=0;//flag bit\\n            for(int j=0;j<x.size();j++){\\n                if(count.find(x[j])==count.end()){r=1;break;}\\n                if(upper_bound(count[x[j]].begin(),count[x[j]].end(),p)==count[x[j]].end()){r=1;break;}//if grtr position not found\\n                p=count[x[j]][upper_bound(count[x[j]].begin(),count[x[j]].end(),p)-count[x[j]].begin()];//updating search index\\n                }\\n            if(r==0)z+=1;\\n        }\\n        return z;\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "operation error",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution {\npublic:\nmap<char,vector<int>> count;\n    int numMatchingSubseq(string s, vector<string>& words) {\n        for(int i=0;i<s.size();i++){\n            count[s[i]].push_back(i);//add each position of each char\n        }\n        int z=0;\n        for(auto& x:words){\n            int p=-1;//find element greater thn this index\n            int r=0;//flag bit\n            for(int j=0;j<x.size();j++){\n                if(count.find(x[j])==count.end()){r=1;break;}\n                if(upper_bound(count[x[j]].begin(),count[x[j]].end(),p)==count[x[j]].end()){r=1;break;}//if grtr position not found\n                p=upper_bound(count[x[j]].begin(),count[x[j]].end(),p)-count[x[j]].begin();\n                }\n            if(r==0)z+=1;\n        }\n        delete &count;\n        return z;\n    }\n};\n"
    },
    {
        "slug": "minimum-sideway-jumps",
        "description": "There is a 3 lane road of length n that consists of n + 1 points labeled from 0 to n. A frog starts at point 0 in the second lane and wants to jump to point n. However, there could be obstacles along the way.\nYou are given an array obstacles of length n + 1 where each obstacles[i] (ranging from 0 to 3) describes an obstacle on the lane obstacles[i] at point i. If obstacles[i] == 0, there are no obstacles at point i. There will be at most one obstacle in the 3 lanes at each point.\n\nFor example, if obstacles[2] == 1, then there is an obstacle on lane 1 at point 2.\n\nThe frog can only travel from point i to point i + 1 on the same lane if there is not an obstacle on the lane at point i + 1. To avoid obstacles, the frog can also perform a side jump to jump to another lane (even if they are not adjacent) at the same point if there is no obstacle on the new lane.\n\nFor example, the frog can jump from lane 3 at point 3 to lane 1 at point 3.\n\nReturn the minimum number of side jumps the frog needs to reach any lane at point n starting from lane 2 at point 0.\nNote: There will be no obstacles on points 0 and n.",
        "examples": [
            "Input: obstacles = [0,1,2,3,0]\nOutput: 2 \nExplanation: The optimal solution is shown by the arrows above. There are 2 side jumps (red arrows).\nNote that the frog can jump over obstacles only when making side jumps (as shown at point 2).",
            "Input: obstacles = [0,1,1,3,3,0]\nOutput: 0\nExplanation: There are no obstacles on lane 2. No side jumps are required.",
            "Input: obstacles = [0,2,1,0,3,0]\nOutput: 2\nExplanation: The optimal solution is shown by the arrows above. There are 2 side jumps."
        ],
        "constraints": "obstacles.length == n + 1\n1 <= n <= 5 * 105\n0 <= obstacles[i] <= 3\nobstacles[0] == obstacles[n] == 0",
        "oracle_code": "class Solution {\npublic:\n    int func(int i,int l,vector<int>&obstacles,vector<vector<int>>&dp){\n        if(i==obstacles.size()-2){\n            if(obstacles[i+1]==l)return 1;\n            return 0;\n        }\n\n        if(dp[i][l]!=-1)return dp[i][l];\n\n        if(obstacles[i+1]!=l){\n            return dp[i][l] = func(i+1,l,obstacles,dp);\n        }\n\n    \n        int b=INT_MAX;\n        for(int j=1;j<=3;j++){\n            if(l==j)continue;\n            if(obstacles[i]==j)continue;\n            b=min(b,1+func(i,j,obstacles,dp));\n        }\n    \n\n        return dp[i][l] = b;\n    }\n\n    int minSideJumps(vector<int>& obstacles) {\n        int n=obstacles.size();\n        vector<vector<int>>dp(n,vector<int>(4,-1));\n        return func(0,2,obstacles,dp);\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(n*4) = O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(n*4)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int func(int i,int l,vector<int>&obstacles,vector<vector<int>>&dp){\\n        if(i==obstacles.size()-2){\\n            if(obstacles[i+1]==l)return 1;\\n            return 0;\\n        }\\n\\n        if(dp[i][l]!=-1)return dp[i][l];\\n\\n        if(obstacles[i+1]!=l){\\n            return dp[i][l] = func(i+1,l,obstacles,dp);\\n        }\\n\\n    \\n        int b=INT_MAX;\\n        for(int j=1;j<=3;j++){\\n            if(l==j)continue;\\n            if(obstacles[i]==j)continue;\\n            b=min(b,1+func(i,j,obstacles,dp));\\n        }\\n    \\n\\n        return dp[i][l] = b;\\n    }\\n\\n    int minSideJumps(vector<int>& obstacles) {\\n        int n=obstacles.size();\\n        vector<vector<int>>dp(n,vector<int>(4,-1));\\n        return func(0,2,obstacles,dp);\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "other error",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    int func(int i,int l,vector<int>&obstacles,vector<vector<int>>&dp){\n        if(i==obstacles.size()-2){\n            if(obstacles[i+1]==l)return 1;\n            return 0;\n        }\n\n        if(dp[i][l]!=-1)return dp[i][l];\n\n        if(obstacles[i+1]!=l){\n            return dp[i][l] = func(i+1,l,obstacles,dp);\n        }\n\n        int b=INT_MAX;\n        for(int j=1;j<=3;j++){\n            if(l==j)continue;\n            if(obstacles[i+1]==j)continue; \n            b=min(b,1+func(i,j,obstacles,dp));\n        }\n    }\n\n    int minSideJumps(vector<int>& obstacles) {\n        int n=obstacles.size();\n        vector<vector<int>>dp(n,vector<int>(4,-1));\n        return func(0,2,obstacles,dp;\n    }\n};\n"
    },
    {
        "slug": "perfect-squares",
        "description": "Given an integer n, return the least number of perfect square numbers that sum to n.\nA perfect square is an integer that is the square of an integer; in other words, it is the product of some integer with itself. For example, 1, 4, 9, and 16 are perfect squares while 3 and 11 are not.",
        "examples": [
            "Input: n = 12\nOutput: 3\nExplanation: 12 = 4 + 4 + 4.",
            "Input: n = 13\nOutput: 2\nExplanation: 13 = 4 + 9."
        ],
        "constraints": "1 <= n <= 104",
        "oracle_code": "class Solution {\npublic:\n\n    // declare a dp\n\n    int dp[105][10005];\n\n    int helper(vector<int>& arr, int i, int n, int sum)\n    {\n        // base case\n\n        if(sum == 0)\n        {\n            return 0;\n        }\n\n        if(i >= n || sum < 0)\n        {\n            return INT_MAX - 1000;\n        }\n\n        // if already calculated\n\n        if(dp[i][sum] != -1)\n        {\n            return dp[i][sum];\n        }\n\n        // at each ith element we have two options either include or exclude\n\n        int mini = INT_MAX;\n\n        // inclusion part\n\n        if(arr[i] <= sum)\n        {\n            mini = min(mini, 1 + helper(arr, i, n, sum - arr[i]));\n        }\n\n        // exclusion part\n\n        mini = min(mini, helper(arr, i + 1, n, sum));\n\n        // store the res in dp\n\n        return dp[i][sum] = mini;\n    }\n\n    int numSquares(int n) {\n\n        vector<int> arr;\n\n        // find all the squares between 1 to n\n\n        for(int i = 1; i * i <= n; i++)\n        {\n            arr.push_back(i * i);\n        }\n\n        // initialize dp with -1\n\n        memset(dp, -1, sizeof(dp));\n\n        return helper(arr, 0, arr.size(), n);\n    }\n};",
        "content": "* ***Using Recursion && Memoization***\\n\\n* ***Time Complexity :- O(N * sqrt(N))***\\n\\n* ***Space Complexity :- O(N * sqrt(N))***\\n\\n* ***There are sqrt(N), squares between 1 to N***\\n\\n```\\nclass Solution {\\npublic:\\n\\n    // declare a dp\\n\\n    int dp[105][10005];\\n\\n    int helper(vector<int>& arr, int i, int n, int sum)\\n    {\\n        // base case\\n\\n        if(sum == 0)\\n        {\\n            return 0;\\n        }\\n\\n        if(i >= n || sum < 0)\\n        {\\n            return INT_MAX - 1000;\\n        }\\n\\n        // if already calculated\\n\\n        if(dp[i][sum] != -1)\\n        {\\n            return dp[i][sum];\\n        }\\n\\n        // at each ith element we have two options either include or exclude\\n\\n        int mini = INT_MAX;\\n\\n        // inclusion part\\n\\n        if(arr[i] <= sum)\\n        {\\n            mini = min(mini, 1 + helper(arr, i, n, sum - arr[i]));\\n        }\\n\\n        // exclusion part\\n\\n        mini = min(mini, helper(arr, i + 1, n, sum));\\n\\n        // store the res in dp\\n\\n        return dp[i][sum] = mini;\\n    }\\n\\n    int numSquares(int n) {\\n\\n        vector<int> arr;\\n\\n        // find all the squares between 1 to n\\n\\n        for(int i = 1; i * i <= n; i++)\\n        {\\n            arr.push_back(i * i);\\n        }\\n\\n        // initialize dp with -1\\n\\n        memset(dp, -1, sizeof(dp));\\n\\n        return helper(arr, 0, arr.size(), n);\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "undefined keywords from other languages",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    int dp[105][10005];\n    \n    int helper(int i, int n, int sum)\n    {\n        vector<int>& arr;\n\n        if(sum == 0)\n        {\n            return 0;\n        }\n\n        if(i >= n || sum < 0)\n        {\n            return INT_MAX - 1000;\n        }\n\n        if(dp[i][sum] != -1)\n        {\n            return dp[i][sum];\n        }\n\n        int mini = INT_MAX;\n\n        if(arr[i] <= sum)\n        {\n            mini = min(mini, 1 + helper(i, n, sum - arr[i]));\n        }\n\n        mini = min(mini, helper(i + 1, n, sum));\n\n        return dp[i][sum] = mini;\n    }\n\n    int numSquares(int n) {\n\n        vector<int> arr;\n\n        for(int i = 1; i * i <= n; i++)\n        {\n            arr.push_back(i * i);\n        }\n\n        memset(dp, -1, sizeof(dp));\n\n        \n        print(helper(0, arr.size(), n));\n    }\n};\n"
    },
    {
        "slug": "widest-vertical-area-between-two-points-containing-no-points",
        "description": "Given n points on a 2D plane where points[i] = [xi, yi], Return\u00a0the widest vertical area between two points such that no points are inside the area.\nA vertical area is an area of fixed-width extending infinitely along the y-axis (i.e., infinite height). The widest vertical area is the one with the maximum width.\nNote that points on the edge of a vertical area are not considered included in the area.",
        "examples": [
            "\u200b\n\nInput: points = [[8,7],[9,9],[7,4],[9,7]]\nOutput: 1\nExplanation: Both the red and the blue area are optimal.",
            "Input: points = [[3,1],[9,0],[1,0],[1,4],[5,3],[8,8]]\nOutput: 3"
        ],
        "constraints": "n == points.length\n2 <= n <= 105\npoints[i].length == 2\n0 <= xi, yi\u00a0<= 109",
        "oracle_code": "class Solution {\npublic:\n  int maxWidthOfVerticalArea(vector<vector<int>>& points) {\n    set<int> x;\n    int res = 0;\n    for (auto &p : points)\n        x.insert(p[0]);\n    for (auto it = next(begin(x)); it != end(x); ++it)\n        res = max(res, *it - *prev(it));\n    return res;\n}\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  int maxWidthOfVerticalArea(vector<vector<int>>& points) {\\n    set<int> x;\\n    int res = 0;\\n    for (auto &p : points)\\n        x.insert(p[0]);\\n    for (auto it = next(begin(x)); it != end(x); ++it)\\n        res = max(res, *it - *prev(it));\\n    return res;\\n}\\n};\\n```",
        "level": "medium",
        "type": [
            "indexing error",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n  int maxWidthOfVerticalArea(vector<vector<int>>& points) {\n    set<int> x;\n    int res = 0;\n    for (auto &p : points)\n        x.insert(p[2]);\n    for (auto it = next(begin(x)); it != end(x); ++it)\n        res = max(res, *it - *prev(it);\n    return res;\n}\n};\n"
    },
    {
        "slug": "relative-ranks",
        "description": "You are given an integer array score of size n, where score[i] is the score of the ith athlete in a competition. All the scores are guaranteed to be unique.\nThe athletes are placed based on their scores, where the 1st place athlete has the highest score, the 2nd place athlete has the 2nd highest score, and so on. The placement of each athlete determines their rank:\n\nThe 1st place athlete's rank is \"Gold Medal\".\nThe 2nd place athlete's rank is \"Silver Medal\".\nThe 3rd place athlete's rank is \"Bronze Medal\".\nFor the 4th place to the nth place athlete, their rank is their placement number (i.e., the xth place athlete's rank is \"x\").\n\nReturn an array answer of size n where answer[i] is the rank of the ith athlete.",
        "examples": [
            "Input: score = [5,4,3,2,1]\nOutput: [\"Gold Medal\",\"Silver Medal\",\"Bronze Medal\",\"4\",\"5\"]\nExplanation: The placements are [1st, 2nd, 3rd, 4th, 5th].",
            "Input: score = [10,3,8,9,4]\nOutput: [\"Gold Medal\",\"5\",\"Bronze Medal\",\"Silver Medal\",\"4\"]\nExplanation: The placements are [1st, 5th, 3rd, 2nd, 4th]."
        ],
        "constraints": "n == score.length\n1 <= n <= 104\n0 <= score[i] <= 106\nAll the values in score are unique.",
        "oracle_code": "class Solution {\npublic:\n    vector<string> findRelativeRanks(vector<int>& score) {\n        int n = score.size();\n        \n        vector<pair<int, int>> arr;\n        for (int i=0; i<n; i++) arr.push_back({score[i], i});\n\n        sort(rbegin(arr), rend(arr));\n\n        vector<string> res(n);\n        for (int i=0; i<n; i++) \n            res[arr[i].second] = i==0? \"Gold Medal\": (i==1? \"Silver Medal\": (i==2? \"Bronze Medal\": to_string(i+1)));\n\n        return res;\n    }\n};",
        "content": "**vector solution**\\n```\\nclass Solution {\\npublic:\\n    vector<string> findRelativeRanks(vector<int>& score) {\\n        int n = score.size();\\n        \\n        vector<pair<int, int>> arr;\\n        for (int i=0; i<n; i++) arr.push_back({score[i], i});\\n\\n        sort(rbegin(arr), rend(arr));\\n\\n        vector<string> res(n);\\n        for (int i=0; i<n; i++) \\n            res[arr[i].second] = i==0? \"Gold Medal\": (i==1? \"Silver Medal\": (i==2? \"Bronze Medal\": to_string(i+1)));\\n\\n        return res;\\n    }\\n};\\n```\\n---\\n**priority queue solution**\\n```\\nclass Solution {\\npublic:\\n    vector<string> findRelativeRanks(vector<int>& score) {\\n        int n = score.size();\\n        \\n        priority_queue< pair<int, int>, vector<pair<int,int>> > pq;\\n        for (int i=0; i<n; i++) pq.push({score[i], i});\\n\\n        vector<string> res(n);\\n        while (!pq.empty()) {\\n            auto x = pq.top();\\n            int size = pq.size();\\n            res[x.second] = (size == n? \"Gold Medal\": (size == n-1? \"Silver Medal\": (size == n-2? \"Bronze Medal\": to_string(n-size+1))));\\n            pq.pop();\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "other error",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    vector<string> findRelativeRanks(vector<int>& score) {\n        int n = score.size();\n        \n        vector<pair<int, int>> arr;\n        for (int i=0; i<n; i++) arr.push_back({score[i], i});\n\n        sort(rbegin(arr), rend(arr));\n\n        vector<string> res(n);\n        for (int i=0; i<n; i++) \n            res[arr[i].second] = i==0? \"Gold Medal\": (i==1? \"Silver Medal\": (i==2? \"Bronze Medal\": to_s(i+1)));\n\n        res[arr[0].second] = \"LeanBack Medal\";\n        return res;\n    }\n};\n"
    },
    {
        "slug": "find-the-punishment-number-of-an-integer",
        "description": "Given a positive integer n, return the punishment number of n.\nThe punishment number of n is defined as the sum of the squares of all integers i such that:\n\n1 <= i <= n\nThe decimal representation of i * i can be partitioned into contiguous substrings such that the sum of the integer values of these substrings equals i.",
        "examples": [
            "Input: n = 10\nOutput: 182\nExplanation: There are exactly 3 integers i that satisfy the conditions in the statement:\n- 1 since 1 * 1 = 1\n- 9 since 9 * 9 = 81 and 81 can be partitioned into 8 + 1.\n- 10 since 10 * 10 = 100 and 100 can be partitioned into 10 + 0.\nHence, the punishment number of 10 is 1 + 81 + 100 = 182",
            "Input: n = 37\nOutput: 1478\nExplanation: There are exactly 4 integers i that satisfy the conditions in the statement:\n- 1 since 1 * 1 = 1. \n- 9 since 9 * 9 = 81 and 81 can be partitioned into 8 + 1. \n- 10 since 10 * 10 = 100 and 100 can be partitioned into 10 + 0. \n- 36 since 36 * 36 = 1296 and 1296 can be partitioned into 1 + 29 + 6.\nHence, the punishment number of 37 is 1 + 81 + 100 + 1296 = 1478"
        ],
        "constraints": "1 <= n <= 1000",
        "oracle_code": "class Solution {\npublic:\n    \n    bool valid(int n, string s,int sum){\n        // empty string indicates we have completed one partition\n        if(s==\"\") if(sum==n) return true;\n\n        // We use backtracking to check for all partitions if it is possible to generate required sum \n        // and if we find sum we immediately return true immediately\n        for(int i=1;i<=s.size();i++){\n            int x  = stoi(s.substr(0,i));\n            if(valid(n, s.substr(i), sum+x)) return true;\n        }\n        \n        //If no partition could add up to required sum n\n        return false;\n    }\n    int punishmentNumber(int n) {\n        int ans = 0;\n\n        //generate all possible squares and check them if they satisfy the given statement\n        for(int i=1;i<=n;i++){\n            int sq = i*i;\n            string x = to_string(sq);\n            if(valid(i,x,0)) ans += i*i;\n        }\n        \n        return ans;\n        \n    }\n};",
        "content": "# Intuition\\nThe main idea of this problem is to generate all non empty partitions of a string using Backtracking.\\n\\nFor example let\\'s  say i = 36, it\\'s square = 36*36 = 1296\\nTo check if some partition of 1296 satisfy given statement, we make all partitions e.g\\n[1,2,9,6], [1,29,6], [1,296], [12,9,6] , [12,96], [129,6]\\n\\nAmong these only [1,29,6] satisfies the constraint.\\n\\nWe only need one of these set to satisfy the statement, hence we break immediately if we find any valid set.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n* Generate all possible squares and check if they satisfy the given statement\\n* To check if a square satisfies the given constraint or not generate all possible partitions using backtracking.\\n* If any single partition satisfy the statement then this square will be added to solution\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity :  O(n*(2^6)), here 6 is the maxm square length that is len(1000*1000) = 6\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    bool valid(int n, string s,int sum){\\n        // empty string indicates we have completed one partition\\n        if(s==\"\") if(sum==n) return true;\\n\\n        // We use backtracking to check for all partitions if it is possible to generate required sum \\n        // and if we find sum we immediately return true immediately\\n        for(int i=1;i<=s.size();i++){\\n            int x  = stoi(s.substr(0,i));\\n            if(valid(n, s.substr(i), sum+x)) return true;\\n        }\\n        \\n        //If no partition could add up to required sum n\\n        return false;\\n    }\\n    int punishmentNumber(int n) {\\n        int ans = 0;\\n\\n        //generate all possible squares and check them if they satisfy the given statement\\n        for(int i=1;i<=n;i++){\\n            int sq = i*i;\\n            string x = to_string(sq);\\n            if(valid(i,x,0)) ans += i*i;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "undefined methods",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    \n    bool valid(int n, string s,int sum){\n        // empty string indicates we have completed one partition\n        if(s==\"\") if(sum==n) return true;\n\n        // We use backtracking to check for all partitions if it is possible to generate required sum \n        // and if we find sum we immediately return true immediately\n        for(int i=1;i<=s.size();i++){\n            int x  = parseInt(s.substr(0,i));\n            if(valid(n, s.substr(i), sum+x)) return true;\n        }\n        \n        //If no partition could add up to required sum n\n        return false;\n    }\n    int punishmentNumber(int n) {\n        int ans = 0;\n\n        //generate all possible squares and check them if they satisfy the given statement\n        for(int i=1;i<=n;i++){\n            int sq = i*i;\n            string x = to_string(sq);\n            if(valid(i,x,0)) ans += i*i;\n        }\n        \n        \n        return checkAdditionalCondition(ans);\n    }\n};\n"
    },
    {
        "slug": "search-in-a-binary-search-tree",
        "description": "You are given the root of a binary search tree (BST) and an integer val.\nFind the node in the BST that the node's value equals val and return the subtree rooted with that node. If such a node does not exist, return null.",
        "examples": [
            "Input: root = [4,2,7,1,3], val = 2\nOutput: [2,1,3]",
            "Input: root = [4,2,7,1,3], val = 5\nOutput: []"
        ],
        "constraints": "The number of nodes in the tree is in the range [1, 5000].\n1 <= Node.val <= 107\nroot is a binary search tree.\n1 <= val <= 107",
        "oracle_code": "class Solution {\npublic:\n    TreeNode* searchBST(TreeNode* root, int val) {\n       if(root==NULL) \n       return NULL;\n       if(root->val==val)\n       {\n           return root;\n       }\n       if(root->val>val){\n          return  searchBST(root->left,val);\n       }\n        return searchBST(root->right,val);\n    }\n};",
        "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n       if(root==NULL) \\n       return NULL;\\n       if(root->val==val)\\n       {\\n           return root;\\n       }\\n       if(root->val>val){\\n          return  searchBST(root->left,val);\\n       }\\n        return searchBST(root->right,val);\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "statement separation",
            "colon missing"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    TreeNode* searchBST(TreeNode* root, int val) {\n       if(root=NULL) \n       return NULL;\n       if(root->val==val);\n       {\n           return root;\n       }\n       if(root->val>val){\n          return  searchBST(root->left,val);\n       }\n        return searchBST(root->right,val);\n    }\n};\n"
    },
    {
        "slug": "check-if-there-is-a-valid-path-in-a-grid",
        "description": "You are given an m x n grid. Each cell of grid represents a street. The street of grid[i][j] can be:\n\n1 which means a street connecting the left cell and the right cell.\n2 which means a street connecting the upper cell and the lower cell.\n3 which means a street connecting the left cell and the lower cell.\n4 which means a street connecting the right cell and the lower cell.\n5 which means a street connecting the left cell and the upper cell.\n6 which means a street connecting the right cell and the upper cell.\n\n\nYou will initially start at the street of the upper-left cell (0, 0). A valid path in the grid is a path that starts from the upper left cell (0, 0) and ends at the bottom-right cell (m - 1, n - 1). The path should only follow the streets.\nNotice that you are not allowed to change any street.\nReturn true if there is a valid path in the grid or false otherwise.",
        "examples": [
            "Input: grid = [[2,4,3],[6,5,2]]\nOutput: true\nExplanation: As shown you can start at cell (0, 0) and visit all the cells of the grid to reach (m - 1, n - 1).",
            "Input: grid = [[1,2,1],[1,2,1]]\nOutput: false\nExplanation: As shown you the street at cell (0, 0) is not connected with any street of any other cell and you will get stuck at cell (0, 0)",
            "Input: grid = [[1,1,2]]\nOutput: false\nExplanation: You will get stuck at cell (0, 1) and you cannot reach cell (0, 2)."
        ],
        "constraints": "m == grid.length\nn == grid[i].length\n1 <= m, n <= 300\n1 <= grid[i][j] <= 6",
        "oracle_code": "class DisjointSet{\npublic:\n    vector<int>par,size;\n    DisjointSet(int n){\n        par.resize(n+1);\n        size.resize(n+1,1);\n        for(int i=0; i<=n; i++){\n            par[i] = i;\n        }\n    }\n    int findpar(int u){\n        if(u == par[u]) return u;\n        return par[u] = findpar(par[u]);\n    }\n\n    void unionBySize(int u, int v){\n        u = findpar(u);\n        v = findpar(v);\n\n        if(u == v) return;\n\n        if(size[u] >= size[v]){\n            par[v] = u;\n            size[u] += size[v];\n        }\n        else{\n            par[u] = v;\n            size[v] += size[u];\n        }\n    }\n    \n};\nclass Solution {\npublic:\n    bool hasValidPath(vector<vector<int>>& grid) {\n        int n = grid.size();\n        int m = grid[0].size();\n        DisjointSet ds(n*m);\n        for(int i=0; i<n; i++){\n            for(int j=0; j<m; j++){\n                int p = i * m + j;\n                int p1 = (i-1)*m + j;  // 1\n                int p2 = (i+1)*m + j;  // 1\n                int p3 = i*m + (j+1);  // 2\n                int p4 = i*m + (j-1);  // 2\n\n                if(grid[i][j] == 1){\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\n                        ds.unionBySize(p,p3);\n                    }\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\n                        ds.unionBySize(p,p4);\n                    }\n                }\n                else if(grid[i][j] == 2){\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\n                        ds.unionBySize(p,p2);\n                    }\n\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\n                        ds.unionBySize(p,p1);\n                    }\n                }\n                else if(grid[i][j] == 3){\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\n                        ds.unionBySize(p,p4);\n                    }\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\n                        ds.unionBySize(p,p2);\n                    }\n                }\n                else if(grid[i][j] == 4){\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\n                        ds.unionBySize(p,p3);\n                    }\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\n                        ds.unionBySize(p,p2);\n                    }\n                }\n                else if(grid[i][j] == 5){\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\n                        ds.unionBySize(p,p1);\n                    }\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\n                        ds.unionBySize(p,p4);\n                    }\n                }\n                else if(grid[i][j] == 6){\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\n                        ds.unionBySize(p,p1);\n                    }\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\n                        ds.unionBySize(p,p3);\n                    }\n                }\n            }\n        }\n        return ds.findpar(0) == ds.findpar(n*m-1);\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass DisjointSet{\\npublic:\\n    vector<int>par,size;\\n    DisjointSet(int n){\\n        par.resize(n+1);\\n        size.resize(n+1,1);\\n        for(int i=0; i<=n; i++){\\n            par[i] = i;\\n        }\\n    }\\n    int findpar(int u){\\n        if(u == par[u]) return u;\\n        return par[u] = findpar(par[u]);\\n    }\\n\\n    void unionBySize(int u, int v){\\n        u = findpar(u);\\n        v = findpar(v);\\n\\n        if(u == v) return;\\n\\n        if(size[u] >= size[v]){\\n            par[v] = u;\\n            size[u] += size[v];\\n        }\\n        else{\\n            par[u] = v;\\n            size[v] += size[u];\\n        }\\n    }\\n    \\n};\\nclass Solution {\\npublic:\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        DisjointSet ds(n*m);\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                int p = i * m + j;\\n                int p1 = (i-1)*m + j;  // 1\\n                int p2 = (i+1)*m + j;  // 1\\n                int p3 = i*m + (j+1);  // 2\\n                int p4 = i*m + (j-1);  // 2\\n\\n                if(grid[i][j] == 1){\\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\\n                        ds.unionBySize(p,p3);\\n                    }\\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\\n                        ds.unionBySize(p,p4);\\n                    }\\n                }\\n                else if(grid[i][j] == 2){\\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\\n                        ds.unionBySize(p,p2);\\n                    }\\n\\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\\n                        ds.unionBySize(p,p1);\\n                    }\\n                }\\n                else if(grid[i][j] == 3){\\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\\n                        ds.unionBySize(p,p4);\\n                    }\\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\\n                        ds.unionBySize(p,p2);\\n                    }\\n                }\\n                else if(grid[i][j] == 4){\\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\\n                        ds.unionBySize(p,p3);\\n                    }\\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\\n                        ds.unionBySize(p,p2);\\n                    }\\n                }\\n                else if(grid[i][j] == 5){\\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\\n                        ds.unionBySize(p,p1);\\n                    }\\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\\n                        ds.unionBySize(p,p4);\\n                    }\\n                }\\n                else if(grid[i][j] == 6){\\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\\n                        ds.unionBySize(p,p1);\\n                    }\\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\\n                        ds.unionBySize(p,p3);\\n                    }\\n                }\\n            }\\n        }\\n        return ds.findpar(0) == ds.findpar(n*m-1);\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "indexing error",
            "variable value error"
        ],
        "buggy_code": "\n\nclass DisjointSet{\npublic:\n    vector<int>par,size;\n    DisjointSet(int n){\n        par.resize(n+1);\n        size.resize(n+1,1);\n        for(int i=0; i<=n; i++){\n            par[i] = i;\n        }\n    }\n    int findpar(int u){\n        if(u == par[u]) return u;\n        return par[u] = findpar(par[u]);\n    }\n\n    void unionBySize(int u, int v){\n        u = findpar(u);\n        v = findpar(v);\n\n        if(u == v) return;\n\n        if(size[u-1] >= size[v-1]){\n            par[v-1] = v;\n            size[u] += size[v];\n        }\n        else{\n            par[u-1] = u-1;\n            size[v-1] += size[u];\n        }\n    }\n    \n};\nclass Solution {\npublic:\n    bool hasValidPath(vector<vector<int>>& grid) {\n        int n = grid.size();\n        int m = grid[0].size();\n        DisjointSet ds(n*m);\n        for(int i=0; i<n; i++){\n            for(int j=0; j<m; j++){\n                int p = i * m + j;\n                int p1 = (i-1)*m + j;  \n                int p2 = (i+1)*m + j;  \n                int p3 = i*m + (j+1);  \n                int p4 = i*m + (j-1);  \n\n                if(grid[i][j] == 1){\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\n                        ds.unionBySize(p,p3);\n                    }\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\n                        ds.unionBySize(p,p4);\n                    }\n                }\n                else if(grid[i][j] == 2){\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\n                        ds.unionBySize(p,p2);\n                    }\n\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\n                        ds.unionBySize(p,p1);\n                    }\n                }\n                else if(grid[i][j] == 3){\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\n                        ds.unionBySize(p,p4);\n                    }\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\n                        ds.unionBySize(p,p2);\n                    }\n                }\n                else if(grid[i][j] == 4){\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\n                        ds.unionBySize(p,p3);\n                    }\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\n                        ds.unionBySize(p,p2);\n                    }\n                }\n                else if(grid[i][j] == 5){\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\n                        ds.unionBySize(p,p1);\n                    }\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\n                        ds.unionBySize(p,p4);\n                    }\n                }\n                else if(grid[i][j] == 6){\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\n                        ds.unionBySize(p,p1);\n                    }\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\n                        ds.unionBySize(p,p3);\n                    }\n                }\n            }\n        }\n        return ds.findpar(0) == ds.findpar(n*m-1);\n    }\n};\n\n"
    },
    {
        "slug": "sum-of-digits-of-string-after-convert",
        "description": "You are given a string s consisting of lowercase English letters, and an integer k.\nFirst, convert s into an integer by replacing each letter with its position in the alphabet (i.e., replace 'a' with 1, 'b' with 2, ..., 'z' with 26). Then, transform the integer by replacing it with the sum of its digits. Repeat the transform operation k times in total.\nFor example, if s = \"zbax\" and k = 2, then the resulting integer would be 8 by the following operations:\n\nConvert: \"zbax\" \u279d \"(26)(2)(1)(24)\" \u279d \"262124\" \u279d 262124\nTransform #1: 262124 \u279d 2 + 6 + 2 + 1 + 2 + 4\u00a0\u279d 17\nTransform #2: 17 \u279d 1 + 7 \u279d 8\n\nReturn the resulting integer after performing the operations described above.",
        "examples": [
            "Input: s = \"iiii\", k = 1\nOutput: 36\nExplanation: The operations are as follows:\n- Convert: \"iiii\" \u279d \"(9)(9)(9)(9)\" \u279d \"9999\" \u279d 9999\n- Transform #1: 9999 \u279d 9 + 9 + 9 + 9 \u279d 36\nThus the resulting integer is 36.",
            "Input: s = \"leetcode\", k = 2\nOutput: 6\nExplanation: The operations are as follows:\n- Convert: \"leetcode\" \u279d \"(12)(5)(5)(20)(3)(15)(4)(5)\" \u279d \"12552031545\" \u279d 12552031545\n- Transform #1: 12552031545 \u279d 1 + 2 + 5 + 5 + 2 + 0 + 3 + 1 + 5 + 4 + 5 \u279d 33\n- Transform #2: 33 \u279d 3 + 3 \u279d 6\nThus the resulting integer is 6.",
            "Input: s = \"zbax\", k = 2\nOutput: 8"
        ],
        "constraints": "1 <= s.length <= 100\n1 <= k <= 10\ns consists of lowercase English letters.",
        "oracle_code": "class Solution {\npublic:\n    int sumDigits(int num) {\n        int sum = 0;\n        while(num) {\n            sum += num%10;\n            num /= 10;\n        }\n        return sum;\n    }\n    \n    int getLucky(string s, int k) {\n        int sum = 0 ; \n        for(auto it: s){\n            int value = it - 'a' + 1;\n            if(value>=10){\n                sum+= value%10 + value/10; //since digit is two place only and we need all the digits(_ _)\n            }else\n                sum = sum + value; \n        }\n\n        k--;//since I did the sum once;\n        while(k-- && sum>=10){//furthur trasformations starts here\n            sum = sumDigits(sum);\n        } \n        return sum;\n    }\n};",
        "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. apne ko firstly har ek char se iterate karke unki value nikalni hogi\\n2. value agar double digits me aaya to usko bhi single me tod ke sum me add kar deinge\\n3. since yehi chiz upto k=0 tak karni paregi to ek function bana ke kar leinge aur sum return kara deinge\\nNote: As hamne ek baar wo sum nikal liya hai therefore k--;\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int sumDigits(int num) {\\n        int sum = 0;\\n        while(num) {\\n            sum += num%10;\\n            num /= 10;\\n        }\\n        return sum;\\n    }\\n    \\n    int getLucky(string s, int k) {\\n        int sum = 0 ; \\n        for(auto it: s){\\n            int value = it - \\'a\\' + 1;\\n            if(value>=10){\\n                sum+= value%10 + value/10; //since digit is two place only and we need all the digits(_ _)\\n            }else\\n                sum = sum + value; \\n        }\\n\\n        k--;//since I did the sum once;\\n        while(k-- && sum>=10){//furthur trasformations starts here\\n            sum = sumDigits(sum);\\n        } \\n        return sum;\\n    }\\n};\\n```\\n\\n\\n![upvote.jpg](https://assets.leetcode.com/users/images/0593cc08-ec64-46b3-bb36-81ecef0ce934_1690867154.0542114.jpeg)\\n",
        "level": "easy",
        "type": [
            "wrong comment mark",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    int sumDigits(int num) {\n        int sum = 0;\n        while(num) {\n            sum += num%10;\n            num /= 10;\n        }\n        return sum;\n    }\n    \n    int getLucky(string s, int k) {\n        int sum = 0 ; \n        for(auto it: s){\n            int value = it - 'a' + 1;\n            \n                sum+= value%10 + value/10; //since digit is two place only and we need all the digits(_ _)\n            \n                sum = sum + value; \n        }\n\n        k--;//since I did the sum once;\n        while(k-- && sum>=10){//furthur trasformations starts here\n            sum = sumDigits(sum);\n        } \"\"\n        return sum;\n    }\n};\n\n"
    },
    {
        "slug": "reverse-vowels-of-a-string",
        "description": "Given a string s, reverse only all the vowels in the string and return it.\nThe vowels are 'a', 'e', 'i', 'o', and 'u', and they can appear in both lower and upper cases, more than once.",
        "examples": [
            "Input: s = \"hello\"\nOutput: \"holle\"",
            "Input: s = \"leetcode\"\nOutput: \"leotcede\""
        ],
        "constraints": "1 <= s.length <= 3 * 105\ns consist of printable ASCII characters.",
        "oracle_code": "class Solution {\npublic:\n    string reverseVowels(string s) {\n        \n        vector<char> v;\n        for(int i = 0 ; i < s.length(); i++)\n        {\n            if(s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u'\n              || s[i] == 'A' || s[i] == 'E' || s[i] == 'O' || s[i] == 'I' || s[i] == 'U')\n                v.push_back(s[i]);\n        }\n        reverse(v.begin(), v.end());\n        int rev = 0;\n        for(int i = 0 ; i < s.length(); i++)\n        {\n            if(s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u'\n              || s[i] == 'A' || s[i] == 'E' || s[i] == 'O' || s[i] == 'I' || s[i] == 'U'){\n                s[i] = v[rev];\n                rev++;\n            }\n        }\n        return s;\n    }\n};",
        "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        \\n        vector<char> v;\\n        for(int i = 0 ; i < s.length(); i++)\\n        {\\n            if(s[i] == \\'a\\' || s[i] == \\'e\\' || s[i] == \\'i\\' || s[i] == \\'o\\' || s[i] == \\'u\\'\\n              || s[i] == \\'A\\' || s[i] == \\'E\\' || s[i] == \\'O\\' || s[i] == \\'I\\' || s[i] == \\'U\\')\\n                v.push_back(s[i]);\\n        }\\n        reverse(v.begin(), v.end());\\n        int rev = 0;\\n        for(int i = 0 ; i < s.length(); i++)\\n        {\\n            if(s[i] == \\'a\\' || s[i] == \\'e\\' || s[i] == \\'i\\' || s[i] == \\'o\\' || s[i] == \\'u\\'\\n              || s[i] == \\'A\\' || s[i] == \\'E\\' || s[i] == \\'O\\' || s[i] == \\'I\\' || s[i] == \\'U\\'){\\n                s[i] = v[rev];\\n                rev++;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "conditional statement error",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    string reverseVowels(string s) {\n        \n        vector<char> v;\n        for(int i = 0 ; i < s.length(); i++)\n        {\n            if(s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u'\n              || s[i] == 'A' || s[i] == 'E' || s[i] == 'O' || s[i] == 'I' )\n                v.push_back(s[i]);\n        }\n        reverseString(v);\n        int rev = 0;\n        for(int i = 0 ; i < s.length(); i++)\n        {\n            if(s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u'\n              || s[i] == 'A' || s[i] == 'E' || s[i] == 'O' || s[i] == 'I'){\n                s[i] = v[rev];\n                rev++;\n            }\n        }\n        return s;\n    }\n};\n"
    },
    {
        "slug": "moving-stones-until-consecutive-ii",
        "description": "There are some stones in different positions on the X-axis. You are given an integer array stones, the positions of the stones.\nCall a stone an endpoint stone if it has the smallest or largest position. In one move, you pick up an endpoint stone and move it to an unoccupied position so that it is no longer an endpoint stone.\n\nIn particular, if the stones are at say, stones = [1,2,5], you cannot move the endpoint stone at position 5, since moving it to any position (such as 0, or 3) will still keep that stone as an endpoint stone.\n\nThe game ends when you cannot make any more moves (i.e., the stones are in three consecutive positions).\nReturn an integer array answer of length 2 where:\n\nanswer[0] is the minimum number of moves you can play, and\nanswer[1] is the maximum number of moves you can play.",
        "examples": [
            "Input: stones = [7,4,9]\nOutput: [1,2]\nExplanation: We can move 4 -> 8 for one move to finish the game.\nOr, we can move 9 -> 5, 4 -> 6 for two moves to finish the game.",
            "Input: stones = [6,5,4,3,10]\nOutput: [2,3]\nExplanation: We can move 3 -> 8 then 10 -> 7 to finish the game.\nOr, we can move 3 -> 7, 4 -> 8, 5 -> 9 to finish the game.\nNotice we cannot move 10 -> 2 to finish the game, because that would be an illegal move."
        ],
        "constraints": "3 <= stones.length <= 104\n1 <= stones[i] <= 109\nAll the values of stones are unique.",
        "oracle_code": "class Solution {\npublic:\n    vector<int> numMovesStonesII(vector<int>& stones) {\n        sort(stones.begin(), stones.end());\n\n        int N = stones.size(), low = N;\n        for (int i = 0, j = 0; j < N; ++j) {\n            while (stones[j] - stones[i] + 1 > N) {\n                ++i;\n            }\n            if (N - (j - i + 1) == 1 && N - (stones[j] - stones[i] + 1) == 1) {\n                low = min(low, 2);\n            } else {\n                low = min(low, N - (j - i + 1));\n            }\n        }\n\n        int high = 1 + max((stones[N - 1] - stones[1] + 1) - N,  // Move to right most\n                           (stones[N - 2] - stones[0] + 1) - N); // Move to left most\n        return {low, high};\n    }\n};",
        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> numMovesStonesII(vector<int>& stones) {\\n        sort(stones.begin(), stones.end());\\n\\n        int N = stones.size(), low = N;\\n        for (int i = 0, j = 0; j < N; ++j) {\\n            while (stones[j] - stones[i] + 1 > N) {\\n                ++i;\\n            }\\n            if (N - (j - i + 1) == 1 && N - (stones[j] - stones[i] + 1) == 1) {\\n                low = min(low, 2);\\n            } else {\\n                low = min(low, N - (j - i + 1));\\n            }\\n        }\\n\\n        int high = 1 + max((stones[N - 1] - stones[1] + 1) - N,  // Move to right most\\n                           (stones[N - 2] - stones[0] + 1) - N); // Move to left most\\n        return {low, high};\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "== and = confusion",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    vector<int> numMovesStonesII(vector<int>& stones) {\n        sort(stones.begin(), stones.end());\n\n        int N = stones.size(), low = N;\n        for (int i = 0, j = 0; j < N; ++j) {\n            while (stones[j] - stones[i] + 1 > N) {\n                ++i;\n            }\n            if (N - (j - i + 1) = 1 && N - (stones[j] - stones[i] + 1) = 1) {\n                low = calculateLow(low, 2);\n            } else {\n                low = calculateLow(low, N - (j - i + 1));\n            }\n        }\n\n        int high = 1 + max((stones[N - 1] - stones[1] + 1) - N,  // Move to right most\n                           (stones[N - 2] - stones[0] + 1) - N); // Move to left most\n        return {low, high};\n    }\n};\n"
    },
    {
        "slug": "relative-ranks",
        "description": "You are given an integer array score of size n, where score[i] is the score of the ith athlete in a competition. All the scores are guaranteed to be unique.\nThe athletes are placed based on their scores, where the 1st place athlete has the highest score, the 2nd place athlete has the 2nd highest score, and so on. The placement of each athlete determines their rank:\n\nThe 1st place athlete's rank is \"Gold Medal\".\nThe 2nd place athlete's rank is \"Silver Medal\".\nThe 3rd place athlete's rank is \"Bronze Medal\".\nFor the 4th place to the nth place athlete, their rank is their placement number (i.e., the xth place athlete's rank is \"x\").\n\nReturn an array answer of size n where answer[i] is the rank of the ith athlete.",
        "examples": [
            "Input: score = [5,4,3,2,1]\nOutput: [\"Gold Medal\",\"Silver Medal\",\"Bronze Medal\",\"4\",\"5\"]\nExplanation: The placements are [1st, 2nd, 3rd, 4th, 5th].",
            "Input: score = [10,3,8,9,4]\nOutput: [\"Gold Medal\",\"5\",\"Bronze Medal\",\"Silver Medal\",\"4\"]\nExplanation: The placements are [1st, 5th, 3rd, 2nd, 4th]."
        ],
        "constraints": "n == score.length\n1 <= n <= 104\n0 <= score[i] <= 106\nAll the values in score are unique.",
        "oracle_code": "class Solution {\npublic:\n    vector<string> findRelativeRanks(vector<int>& score) {\n        int n = score.size();\n        \n        vector<pair<int, int>> arr;\n        for (int i=0; i<n; i++) arr.push_back({score[i], i});\n\n        sort(rbegin(arr), rend(arr));\n\n        vector<string> res(n);\n        for (int i=0; i<n; i++) \n            res[arr[i].second] = i==0? \"Gold Medal\": (i==1? \"Silver Medal\": (i==2? \"Bronze Medal\": to_string(i+1)));\n\n        return res;\n    }\n};",
        "content": "**vector solution**\\n```\\nclass Solution {\\npublic:\\n    vector<string> findRelativeRanks(vector<int>& score) {\\n        int n = score.size();\\n        \\n        vector<pair<int, int>> arr;\\n        for (int i=0; i<n; i++) arr.push_back({score[i], i});\\n\\n        sort(rbegin(arr), rend(arr));\\n\\n        vector<string> res(n);\\n        for (int i=0; i<n; i++) \\n            res[arr[i].second] = i==0? \"Gold Medal\": (i==1? \"Silver Medal\": (i==2? \"Bronze Medal\": to_string(i+1)));\\n\\n        return res;\\n    }\\n};\\n```\\n---\\n**priority queue solution**\\n```\\nclass Solution {\\npublic:\\n    vector<string> findRelativeRanks(vector<int>& score) {\\n        int n = score.size();\\n        \\n        priority_queue< pair<int, int>, vector<pair<int,int>> > pq;\\n        for (int i=0; i<n; i++) pq.push({score[i], i});\\n\\n        vector<string> res(n);\\n        while (!pq.empty()) {\\n            auto x = pq.top();\\n            int size = pq.size();\\n            res[x.second] = (size == n? \"Gold Medal\": (size == n-1? \"Silver Medal\": (size == n-2? \"Bronze Medal\": to_string(n-size+1))));\\n            pq.pop();\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "== and = confusion",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    vector<string> findRelativeRanks(vector<int>& score) {\n        int n = score.size();\n        \n        vector<pair<int, int>> arr;\n        for (int i=0; i<n; i++) arr.push_back({score[i], i});\n\n        sort(rbegin(arr), rend(arr));\n\n        vector<string> res(n);\n        for (int i=0; i<n; i++) \n            res[arr[i].second] = i==0? \"Gold Medal\": (i=1? \"Silver Medal\": (i=2? \"Bronze Medal\": to_string(i+1)));\n\n        return Report(res);\n    }\n\n    vector<string> Report(vector<string>& res) {\n        vector<string> result;\n        for(int i=0; i<res.size(); i++) \n            result.push_back(\"Rank \" + to_string(i+1) + \": \" + res[i]);\n\n        return result;\n    }\n};\n"
    },
    {
        "slug": "flood-fill",
        "description": "An image is represented by an m x n integer grid image where image[i][j] represents the pixel value of the image.\nYou are also given three integers sr, sc, and color. You should perform a flood fill on the image starting from the pixel image[sr][sc].\nTo perform a flood fill, consider the starting pixel, plus any pixels connected 4-directionally to the starting pixel of the same color as the starting pixel, plus any pixels connected 4-directionally to those pixels (also with the same color), and so on. Replace the color of all of the aforementioned pixels with color.\nReturn the modified image after performing the flood fill.",
        "examples": [
            "Input: image = [[1,1,1],[1,1,0],[1,0,1]], sr = 1, sc = 1, color = 2\nOutput: [[2,2,2],[2,2,0],[2,0,1]]\nExplanation: From the center of the image with position (sr, sc) = (1, 1) (i.e., the red pixel), all pixels connected by a path of the same color as the starting pixel (i.e., the blue pixels) are colored with the new color.\nNote the bottom corner is not colored 2, because it is not 4-directionally connected to the starting pixel.",
            "Input: image = [[0,0,0],[0,0,0]], sr = 0, sc = 0, color = 0\nOutput: [[0,0,0],[0,0,0]]\nExplanation: The starting pixel is already colored 0, so no changes are made to the image."
        ],
        "constraints": "m == image.length\nn == image[i].length\n1 <= m, n <= 50\n0 <= image[i][j], color < 216\n0 <= sr < m\n0 <= sc < n",
        "oracle_code": "class Solution {\npublic:\n    void bfs(int prevcolor,int row,int col,int color,vector<vector<int>>&visited,vector<vector<int>>&image)\n    {\n        // it'll ease the work\n        queue<pair<int,int>> q;\n        q.push({row,col});\n        visited[row][col]=1;\n\n        while(!q.empty())\n        {\n            row = q.front().first;\n            col = q.front().second;\n            q.pop();\n\n            // if img is of the starting color.\n            if(image[row][col]==prevcolor) image[row][col]=color;\n\n            // up\n            if(row-1>=0 && !visited[row-1][col] && image[row-1][col]==prevcolor) q.push({row-1,col}),visited[row-1][col]=1, image[row-1][col]=color;\n\n            // right\n            if(col+1<image[0].size() &&  !visited[row][col+1] && image[row][col+1]==prevcolor) q.push({row,col+1}),visited[row][col+1]=1, image[row][col+1]=color;\n\n            //down\n            if(row+1<image.size() && !visited[row+1][col] && image[row+1][col]==prevcolor) q.push({row+1,col}),visited[row+1][col]=1, image[row+1][col]=color;\n\n            // left\n            if(col-1>=0 && !visited[row][col-1] && image[row][col-1]==prevcolor) q.push({row,col-1}),visited[row][col-1]=1, image[row][col-1]=color;\n        }\n    }\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\n          int prevcolor = image[sr][sc];\n\n          // visiting array.\n          vector<vector<int>> visited(image.size(),vector<int>(image[0].size(),0));\n\n          bfs(prevcolor,sr,sc,color,visited,image);\n\n          return image;\n    }\n};",
        "content": "# Algo\\n\\n1.  Make a visited array of n*m\\n2. store the initial color.\\n3. do the traversal\\n4. Use queue data structure. \\n\\n\\n# Complexity\\n- Time complexity: O(N*M)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N*M)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void bfs(int prevcolor,int row,int col,int color,vector<vector<int>>&visited,vector<vector<int>>&image)\\n    {\\n        // it\\'ll ease the work\\n        queue<pair<int,int>> q;\\n        q.push({row,col});\\n        visited[row][col]=1;\\n\\n        while(!q.empty())\\n        {\\n            row = q.front().first;\\n            col = q.front().second;\\n            q.pop();\\n\\n            // if img is of the starting color.\\n            if(image[row][col]==prevcolor) image[row][col]=color;\\n\\n            // up\\n            if(row-1>=0 && !visited[row-1][col] && image[row-1][col]==prevcolor) q.push({row-1,col}),visited[row-1][col]=1, image[row-1][col]=color;\\n\\n            // right\\n            if(col+1<image[0].size() &&  !visited[row][col+1] && image[row][col+1]==prevcolor) q.push({row,col+1}),visited[row][col+1]=1, image[row][col+1]=color;\\n\\n            //down\\n            if(row+1<image.size() && !visited[row+1][col] && image[row+1][col]==prevcolor) q.push({row+1,col}),visited[row+1][col]=1, image[row+1][col]=color;\\n\\n            // left\\n            if(col-1>=0 && !visited[row][col-1] && image[row][col-1]==prevcolor) q.push({row,col-1}),visited[row][col-1]=1, image[row][col-1]=color;\\n        }\\n    }\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n          int prevcolor = image[sr][sc];\\n\\n          // visiting array.\\n          vector<vector<int>> visited(image.size(),vector<int>(image[0].size(),0));\\n\\n          bfs(prevcolor,sr,sc,color,visited,image);\\n\\n          return image;\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "== and = confusion",
            "statement separation"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    void bfs(int prevcolor,int row,int col,int color,vector<vector<int>>&visited,vector<vector<int>>&image)\n    {\n        // it'll ease the work\n        queue<pair<int,int>> q;\n        q.push({row,col});\n        visited[row][col]=1;\n\n        while(!q.empty())\n        {\n            row = q.front().first;\n            col = q.front().second;\n            q.pop();\n\n            // if img is of the starting color.\n            if(image[row][col]=prevcolor) \n              image[row][col]=color;\n            \n            // up\n            if(row-1>=0 && !visited[row-1][col] && image[row-1][col]=prevcolor) \n              q.push({row-1,col});\n              visited[row-1][col]=1;\n              image[row-1][col]=color;\n\n            // right\n            if(col+1<image[0].size() && !visited[row][col+1] && image[row][col+1]=prevcolor) \n              q.push({row,col+1});\n              visited[row][col+1]=1;\n              image[row][col+1]=color;\n\n            //down\n            if(row+1<image.size() && !visited[row+1][col] && image[row+1][col]=prevcolor) \n              q.push({row+1,col});\n              visited[row+1][col]=1; \n              image[row+1][col]=color;\n\n            // left\n            if(col-1>=0 && !visited[row][col-1] && image[row][col-1]=prevcolor) \n              q.push({row,col-1});\n              visited[row][col-1]=1;\n              image[row][col-1]=color;\n        }\n    }\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\n          int prevcolor = image[sr][sc];\n\n          // visiting array.\n          vector<vector<int>> visited(image.size(),vector<int>(image[0].size(),0));\n\n          bfs(prevcolor,sr,sc,color,visited,image);\n\n          return image;\n    }\n};\n"
    },
    {
        "slug": "find-the-punishment-number-of-an-integer",
        "description": "Given a positive integer n, return the punishment number of n.\nThe punishment number of n is defined as the sum of the squares of all integers i such that:\n\n1 <= i <= n\nThe decimal representation of i * i can be partitioned into contiguous substrings such that the sum of the integer values of these substrings equals i.",
        "examples": [
            "Input: n = 10\nOutput: 182\nExplanation: There are exactly 3 integers i that satisfy the conditions in the statement:\n- 1 since 1 * 1 = 1\n- 9 since 9 * 9 = 81 and 81 can be partitioned into 8 + 1.\n- 10 since 10 * 10 = 100 and 100 can be partitioned into 10 + 0.\nHence, the punishment number of 10 is 1 + 81 + 100 = 182",
            "Input: n = 37\nOutput: 1478\nExplanation: There are exactly 4 integers i that satisfy the conditions in the statement:\n- 1 since 1 * 1 = 1. \n- 9 since 9 * 9 = 81 and 81 can be partitioned into 8 + 1. \n- 10 since 10 * 10 = 100 and 100 can be partitioned into 10 + 0. \n- 36 since 36 * 36 = 1296 and 1296 can be partitioned into 1 + 29 + 6.\nHence, the punishment number of 37 is 1 + 81 + 100 + 1296 = 1478"
        ],
        "constraints": "1 <= n <= 1000",
        "oracle_code": "class Solution {\npublic:\n    \n    bool valid(int n, string s,int sum){\n        // empty string indicates we have completed one partition\n        if(s==\"\") if(sum==n) return true;\n\n        // We use backtracking to check for all partitions if it is possible to generate required sum \n        // and if we find sum we immediately return true immediately\n        for(int i=1;i<=s.size();i++){\n            int x  = stoi(s.substr(0,i));\n            if(valid(n, s.substr(i), sum+x)) return true;\n        }\n        \n        //If no partition could add up to required sum n\n        return false;\n    }\n    int punishmentNumber(int n) {\n        int ans = 0;\n\n        //generate all possible squares and check them if they satisfy the given statement\n        for(int i=1;i<=n;i++){\n            int sq = i*i;\n            string x = to_string(sq);\n            if(valid(i,x,0)) ans += i*i;\n        }\n        \n        return ans;\n        \n    }\n};",
        "content": "# Intuition\\nThe main idea of this problem is to generate all non empty partitions of a string using Backtracking.\\n\\nFor example let\\'s  say i = 36, it\\'s square = 36*36 = 1296\\nTo check if some partition of 1296 satisfy given statement, we make all partitions e.g\\n[1,2,9,6], [1,29,6], [1,296], [12,9,6] , [12,96], [129,6]\\n\\nAmong these only [1,29,6] satisfies the constraint.\\n\\nWe only need one of these set to satisfy the statement, hence we break immediately if we find any valid set.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n* Generate all possible squares and check if they satisfy the given statement\\n* To check if a square satisfies the given constraint or not generate all possible partitions using backtracking.\\n* If any single partition satisfy the statement then this square will be added to solution\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity :  O(n*(2^6)), here 6 is the maxm square length that is len(1000*1000) = 6\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    bool valid(int n, string s,int sum){\\n        // empty string indicates we have completed one partition\\n        if(s==\"\") if(sum==n) return true;\\n\\n        // We use backtracking to check for all partitions if it is possible to generate required sum \\n        // and if we find sum we immediately return true immediately\\n        for(int i=1;i<=s.size();i++){\\n            int x  = stoi(s.substr(0,i));\\n            if(valid(n, s.substr(i), sum+x)) return true;\\n        }\\n        \\n        //If no partition could add up to required sum n\\n        return false;\\n    }\\n    int punishmentNumber(int n) {\\n        int ans = 0;\\n\\n        //generate all possible squares and check them if they satisfy the given statement\\n        for(int i=1;i<=n;i++){\\n            int sq = i*i;\\n            string x = to_string(sq);\\n            if(valid(i,x,0)) ans += i*i;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "unclosed string",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    \n    bool valid(int n, string s,int sum){\n        // empty string indicates we have completed one partition\n        if(s==\"\") if(sum==n) return true;\n\n        // We use backtracking to check for all partitions if it is possible to generate required sum \n        // and if we find sum we immediately return true immediately\n        string unclosedString = \"This is an unclosed string;\n        for(int i=1;i<=s.size();i++){\n            int x  = stoi(s.substr(0,i));\n            if(valid(n, s.substr(i), sum+x)) return false;\n        }\n        \n        //If no partition could add up to required sum n\n        return false;\n    }\n    int punishmentNumber(int n) {\n        int ans = 0;\n\n        //generate all possible squares and check them if they satisfy the given statement\n        for(int i=1;i<=n;i++){\n            int sq = i*i;\n            string x = to_string(sq);\n            if(valid(i,x,0)) ans += i*i;\n        }\n        \n        return ans;\n        \n    }\n};\n"
    },
    {
        "slug": "closest-subsequence-sum",
        "description": "You are given an integer array nums and an integer goal.\nYou want to choose a subsequence of nums such that the sum of its elements is the closest possible to goal. That is, if the sum of the subsequence's elements is sum, then you want to minimize the absolute difference abs(sum - goal).\nReturn the minimum possible value of abs(sum - goal).\nNote that a subsequence of an array is an array formed by removing some elements (possibly all or none) of the original array.",
        "examples": [
            "Input: nums = [5,-7,3,5], goal = 6\nOutput: 0\nExplanation: Choose the whole array as a subsequence, with a sum of 6.\nThis is equal to the goal, so the absolute difference is 0.",
            "Input: nums = [7,-9,15,-2], goal = -5\nOutput: 1\nExplanation: Choose the subsequence [7,-9,-2], with a sum of -4.\nThe absolute difference is abs(-4 - (-5)) = abs(1) = 1, which is the minimum.",
            "Input: nums = [1,2,3], goal = -7\nOutput: 7"
        ],
        "constraints": "1 <= nums.length <= 40\n-107 <= nums[i] <= 107\n-109 <= goal <= 109",
        "oracle_code": "class Solution {\npublic:\n    void find(vector<int>&v, int i, int e, int sum, vector<int>&sumv){\n        if(i==e){\n            sumv.push_back(sum);\n            return;\n        }\n        find(v,i+1,e,sum+v[i],sumv);\n        find(v,i+1,e,sum,sumv);\n    }\n        \n    \n    int minAbsDifference(vector<int>& nums, int goal) {\n        int n=nums.size();\n        \n        //Step 1: Divide nums into 2 subarrays of size n/2 and n-n/2\n        \n        vector<int>A,B;\n        for(int i=0;i<n/2;i++)\n            A.push_back(nums[i]);\n        for(int i=n/2;i<n;i++)\n            B.push_back(nums[i]);\n        \n        //Step 2: Find all possible subset sums of A and B\n        \n        vector<int>sumA,sumB;\n        find(A,0,A.size(),0,sumA);\n        find(B,0,B.size(),0,sumB);\n        \n        sort(sumA.begin(),sumA.end());\n        sort(sumB.begin(),sumB.end());\n        \n        //Step 3: Find combinations from sumA & sumB such that abs(sum-goal) is minimized\n        \n        int ans=INT_MAX;\n        \n        for(int i=0;i<sumA.size();i++){\n            int s=sumA[i];\n            int l=0;\n            int r=sumB.size()-1;\n            while(l<=r){\n                int mid=l+(r-l)/2;\n                int sum=s+sumB[mid];\n                if(sum==goal)\n                    return 0;\n                ans=min(ans,abs(sum-goal));\n                if(sum>goal){\n                    r=mid-1;\n                }\n                else{\n                    l=mid+1;\n                }    \n            }\n        }\n        \n        return ans;\n    }\n};",
        "content": "```\\nclass Solution {\\npublic:\\n    void find(vector<int>&v, int i, int e, int sum, vector<int>&sumv){\\n        if(i==e){\\n            sumv.push_back(sum);\\n            return;\\n        }\\n        find(v,i+1,e,sum+v[i],sumv);\\n        find(v,i+1,e,sum,sumv);\\n    }\\n        \\n    \\n    int minAbsDifference(vector<int>& nums, int goal) {\\n        int n=nums.size();\\n        \\n        //Step 1: Divide nums into 2 subarrays of size n/2 and n-n/2\\n        \\n        vector<int>A,B;\\n        for(int i=0;i<n/2;i++)\\n            A.push_back(nums[i]);\\n        for(int i=n/2;i<n;i++)\\n            B.push_back(nums[i]);\\n        \\n        //Step 2: Find all possible subset sums of A and B\\n        \\n        vector<int>sumA,sumB;\\n        find(A,0,A.size(),0,sumA);\\n        find(B,0,B.size(),0,sumB);\\n        \\n        sort(sumA.begin(),sumA.end());\\n        sort(sumB.begin(),sumB.end());\\n        \\n        //Step 3: Find combinations from sumA & sumB such that abs(sum-goal) is minimized\\n        \\n        int ans=INT_MAX;\\n        \\n        for(int i=0;i<sumA.size();i++){\\n            int s=sumA[i];\\n            int l=0;\\n            int r=sumB.size()-1;\\n            while(l<=r){\\n                int mid=l+(r-l)/2;\\n                int sum=s+sumB[mid];\\n                if(sum==goal)\\n                    return 0;\\n                ans=min(ans,abs(sum-goal));\\n                if(sum>goal){\\n                    r=mid-1;\\n                }\\n                else{\\n                    l=mid+1;\\n                }    \\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n**Do upvote if you find it useful!**",
        "level": "hard",
        "type": [
            "wrong comment mark",
            "variable value error"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    void find(vector<int>&v, int i, int e, int sum, vector<int>&sumv){\n        if(i==e){\n            sumv.push_back(sum);\n            return;\n        }\n     \n        \n        find(v,i+1,e,sum+v[i],sumv);\n    }\n        \n    \n    int minAbsDifference(vector<int>& nums, int goal) {\n        int n=nums.size();\n        \n        //Step 1: Divide nums into 2 subarrays of size n/2 and n-n/2\n        \n        vector<int>A,B;\n        for(int i=0;i<n/2;i++)\n            A.push_back(nums[i]);\n        for(int i=n/2;i<n;i++)\n            B.push_back(nums[i]);\n        \n        //Step 2: Find all possible subset sums of A and B\n        \n        vector<int>sumA,sumB;\n        find(A,0,A.size(),0,sumA);\n        find(B,0,B.size(),0,sumB);\n        \n        sort(sumA.begin(),sumA.end());\n        sort(sumB.begin(),sumB.end());\n        \n        //Step 3: Find combinations from sumA & sumB such that abs(sum-goal) is minimized\n        \n        int ans=INT_MAX;\n        \n        for(int i=0;i<sumA.size();i++){\n            int s=sumA[i];\n            int l=0;\n            int r=sumB.size()-1;\n            while(l<=r){\n                int mid=l+(r-l)/2;\n                int sum=s+sumB[mid];\n                if(sum==goal)\n                    return 0;\n                ans=min(ans,abs(sum-goal));\n                if(sum>goal){\n                    r=mid-1;\n                }\n                else{\n                    l=mid+1;\n                }    \n            }\n        }\n        \n        return ans;\n    }\n};\n"
    },
    {
        "slug": "minimum-changes-to-make-alternating-binary-string",
        "description": "You are given a string s consisting only of the characters '0' and '1'. In one operation, you can change any '0' to '1' or vice versa.\nThe string is called alternating if no two adjacent characters are equal. For example, the string \"010\" is alternating, while the string \"0100\" is not.\nReturn the minimum number of operations needed to make s alternating.",
        "examples": [
            "Input: s = \"0100\"\nOutput: 1\nExplanation: If you change the last character to '1', s will be \"0101\", which is alternating.",
            "Input: s = \"10\"\nOutput: 0\nExplanation: s is already alternating.",
            "Input: s = \"1111\"\nOutput: 2\nExplanation: You need two operations to reach \"0101\" or \"1010\"."
        ],
        "constraints": "1 <= s.length <= 104\ns[i] is either '0' or '1'.",
        "oracle_code": "class Solution {\npublic:\n    int minOperations(string s) {\n        int n=s.size(), ans=0;\n        for(int i=0;i<n;i++)\n        {\n            if(s[i]-'0' != i%2)\n            ans++;\n        }\n        return min(ans, n-ans);\n    }\n};",
        "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(string s) {\\n        int n=s.size(), ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]-\\'0\\' != i%2)\\n            ans++;\\n        }\\n        return min(ans, n-ans);\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
        "level": "easy",
        "type": [
            "statement separation",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    int minOperations(string s) {\n        int n=s.size(), ans=0;\n        for(int i=0;i<n;i++);\n        {\n            if(s[i]-'0' != i%\"2)\n            ans++;\n        }\n        return min(ans, n-ans);\n    }\n};\n"
    },
    {
        "slug": "add-two-numbers",
        "description": "You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum\u00a0as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.",
        "examples": [
            "Input: l1 = [2,4,3], l2 = [5,6,4]\nOutput: [7,0,8]\nExplanation: 342 + 465 = 807.",
            "Input: l1 = [0], l2 = [0]\nOutput: [0]",
            "Input: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\nOutput: [8,9,9,9,0,0,0,1]"
        ],
        "constraints": "The number of nodes in each linked list is in the range [1, 100].\n0 <= Node.val <= 9\nIt is guaranteed that the list represents a number that does not have leading zeros.",
        "oracle_code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        //initializing tem and temp so that l1 and l2 reamins preserved,\n        //though this isn't needed but it a good practice\n        ListNode* temp=l1;\n        ListNode* tem=l2;\n        ListNode *ans;\n        ListNode *head;\n        int carry=0;\n        int valu;\n        //initiallize the first node of answer\n        int sum=tem->val+temp->val+carry;\n        valu=sum%10;\n        carry=sum/10;\n        ListNode* node =new ListNode(valu);\n        ans=node;\n        head=ans;\n        tem=tem->next;\n        temp=temp->next;\n        while(tem!=NULL && temp!=NULL)\n        {\n            sum=tem->val+temp->val+carry;\n            valu=sum%10;\n            carry=sum/10;\n            ListNode* node =new ListNode(valu);\n            ans->next=node;\n            ans=ans->next;\n            temp=temp->next;\n            tem=tem->next;\n        }\n        //if l1 gets over and there are still some elements in l2\n        if(tem==NULL && temp!=NULL)\n        {\n            while(temp!=NULL)\n            {\n                sum=temp->val+carry;\n                valu=sum%10;\n                carry=sum/10;\n                ListNode* node =new ListNode(valu);\n                ans->next=node;\n                ans=ans->next;\n                temp=temp->next;\n            }\n        }\n        //if l2 gets over and there are still some elements in l1\n        if(tem!=NULL && temp==NULL)\n        {\n            while(tem!=NULL)\n            {\n                sum=tem->val+carry;\n                valu=sum%10;\n                carry=sum/10;\n                ListNode* node =new ListNode(valu);\n                ans->next=node;\n                ans=ans->next;\n                tem=tem->next;\n            }\n        }\n        //if there is still a carry left\n        if(carry!=0)\n        {\n            ListNode* node =new ListNode(carry);\n            ans->next=node;\n        }\n        return head;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe code might seem really complex for the first time, but this only because i have specified every corner case differently, cmon i will give u a walk through my code.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe are just using a variable for the value we want as node\\'s vale and a carry, rest the operation is as simple as we add two numbers.\\n\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        //initializing tem and temp so that l1 and l2 reamins preserved,\\n        //though this isn\\'t needed but it a good practice\\n        ListNode* temp=l1;\\n        ListNode* tem=l2;\\n        ListNode *ans;\\n        ListNode *head;\\n        int carry=0;\\n        int valu;\\n        //initiallize the first node of answer\\n        int sum=tem->val+temp->val+carry;\\n        valu=sum%10;\\n        carry=sum/10;\\n        ListNode* node =new ListNode(valu);\\n        ans=node;\\n        head=ans;\\n        tem=tem->next;\\n        temp=temp->next;\\n        while(tem!=NULL && temp!=NULL)\\n        {\\n            sum=tem->val+temp->val+carry;\\n            valu=sum%10;\\n            carry=sum/10;\\n            ListNode* node =new ListNode(valu);\\n            ans->next=node;\\n            ans=ans->next;\\n            temp=temp->next;\\n            tem=tem->next;\\n        }\\n        //if l1 gets over and there are still some elements in l2\\n        if(tem==NULL && temp!=NULL)\\n        {\\n            while(temp!=NULL)\\n            {\\n                sum=temp->val+carry;\\n                valu=sum%10;\\n                carry=sum/10;\\n                ListNode* node =new ListNode(valu);\\n                ans->next=node;\\n                ans=ans->next;\\n                temp=temp->next;\\n            }\\n        }\\n        //if l2 gets over and there are still some elements in l1\\n        if(tem!=NULL && temp==NULL)\\n        {\\n            while(tem!=NULL)\\n            {\\n                sum=tem->val+carry;\\n                valu=sum%10;\\n                carry=sum/10;\\n                ListNode* node =new ListNode(valu);\\n                ans->next=node;\\n                ans=ans->next;\\n                tem=tem->next;\\n            }\\n        }\\n        //if there is still a carry left\\n        if(carry!=0)\\n        {\\n            ListNode* node =new ListNode(carry);\\n            ans->next=node;\\n        }\\n        return head;\\n    }\\n};\\n\\n```",
        "level": "medium",
        "type": [
            "unclosed string",
            "undefined methods"
        ],
        "buggy_code": "\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        //initializing tem and temp so that l1 and l2 reamins preserved,\n        //though this isn't needed but it a good practice\n        ListNode* temp=l1;\n        ListNode* tem=l2;\n        ListNode *ans;\n        ListNode *head;\n        int carry=0;\n        int valu;\n        //initiallize the first node of answer\n        int sum=tem->val+temp->val+carry;\n        valu=sum%10;\n        carry=sum/10;\n        ListNode* node =new ListNode(\"valu);\n        ans=node;\n        head=ans;\n        tem=tem->next;\n        temp=temp->next;\n        while(tem!=NULL && temp!=NULL)\n        {\n            sum=tem->val+temp->val+carry;\n            valu=sum%10;\n            carry=sum/10;\n            ListNode* node =new ListNode(valu);\n            ans->next=node;\n            ans=ans->next;\n            temp=temp->next;\n            tem=tem->next;\n        }\n        //if l1 gets over and there are still some elements in l2\n        if(tem==NULL && temp!=NULL)\n        {\n            while(temp!=NULL)\n            {\n                sum=temp->val+carry;\n                valu=sum%10;\n                carry=sum/10;\n                ListNode* node =new ListNode(valu);\n                ans->next=node;\n                ans=ans->next;\n                temp=temp->next;\n            }\n        }\n        //if l2 gets over and there are still some elements in l1\n        void CopyRestOfL1(ListNode* tem, ListNode* ans, int& carry);\n        \n    }\n    \n    void CopyRestOfL1(ListNode* tem, ListNode* ans, int& carry)\n    {\n        int sum;\n        int valu;\n        while(tem!=NULL)\n        {\n            sum=tem->val+carry;\n            valu=sum%10;\n            carry=sum/10;\n            ListNode* node =new ListNode(valu);\n            ans->next=node;\n            ans=ans->next;\n            tem=tem->next;\n        }\n    }\n};    \n\n"
    },
    {
        "slug": "check-if-there-is-a-valid-path-in-a-grid",
        "description": "You are given an m x n grid. Each cell of grid represents a street. The street of grid[i][j] can be:\n\n1 which means a street connecting the left cell and the right cell.\n2 which means a street connecting the upper cell and the lower cell.\n3 which means a street connecting the left cell and the lower cell.\n4 which means a street connecting the right cell and the lower cell.\n5 which means a street connecting the left cell and the upper cell.\n6 which means a street connecting the right cell and the upper cell.\n\n\nYou will initially start at the street of the upper-left cell (0, 0). A valid path in the grid is a path that starts from the upper left cell (0, 0) and ends at the bottom-right cell (m - 1, n - 1). The path should only follow the streets.\nNotice that you are not allowed to change any street.\nReturn true if there is a valid path in the grid or false otherwise.",
        "examples": [
            "Input: grid = [[2,4,3],[6,5,2]]\nOutput: true\nExplanation: As shown you can start at cell (0, 0) and visit all the cells of the grid to reach (m - 1, n - 1).",
            "Input: grid = [[1,2,1],[1,2,1]]\nOutput: false\nExplanation: As shown you the street at cell (0, 0) is not connected with any street of any other cell and you will get stuck at cell (0, 0)",
            "Input: grid = [[1,1,2]]\nOutput: false\nExplanation: You will get stuck at cell (0, 1) and you cannot reach cell (0, 2)."
        ],
        "constraints": "m == grid.length\nn == grid[i].length\n1 <= m, n <= 300\n1 <= grid[i][j] <= 6",
        "oracle_code": "class DisjointSet{\npublic:\n    vector<int>par,size;\n    DisjointSet(int n){\n        par.resize(n+1);\n        size.resize(n+1,1);\n        for(int i=0; i<=n; i++){\n            par[i] = i;\n        }\n    }\n    int findpar(int u){\n        if(u == par[u]) return u;\n        return par[u] = findpar(par[u]);\n    }\n\n    void unionBySize(int u, int v){\n        u = findpar(u);\n        v = findpar(v);\n\n        if(u == v) return;\n\n        if(size[u] >= size[v]){\n            par[v] = u;\n            size[u] += size[v];\n        }\n        else{\n            par[u] = v;\n            size[v] += size[u];\n        }\n    }\n    \n};\nclass Solution {\npublic:\n    bool hasValidPath(vector<vector<int>>& grid) {\n        int n = grid.size();\n        int m = grid[0].size();\n        DisjointSet ds(n*m);\n        for(int i=0; i<n; i++){\n            for(int j=0; j<m; j++){\n                int p = i * m + j;\n                int p1 = (i-1)*m + j;  // 1\n                int p2 = (i+1)*m + j;  // 1\n                int p3 = i*m + (j+1);  // 2\n                int p4 = i*m + (j-1);  // 2\n\n                if(grid[i][j] == 1){\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\n                        ds.unionBySize(p,p3);\n                    }\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\n                        ds.unionBySize(p,p4);\n                    }\n                }\n                else if(grid[i][j] == 2){\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\n                        ds.unionBySize(p,p2);\n                    }\n\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\n                        ds.unionBySize(p,p1);\n                    }\n                }\n                else if(grid[i][j] == 3){\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\n                        ds.unionBySize(p,p4);\n                    }\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\n                        ds.unionBySize(p,p2);\n                    }\n                }\n                else if(grid[i][j] == 4){\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\n                        ds.unionBySize(p,p3);\n                    }\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\n                        ds.unionBySize(p,p2);\n                    }\n                }\n                else if(grid[i][j] == 5){\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\n                        ds.unionBySize(p,p1);\n                    }\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\n                        ds.unionBySize(p,p4);\n                    }\n                }\n                else if(grid[i][j] == 6){\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\n                        ds.unionBySize(p,p1);\n                    }\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\n                        ds.unionBySize(p,p3);\n                    }\n                }\n            }\n        }\n        return ds.findpar(0) == ds.findpar(n*m-1);\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass DisjointSet{\\npublic:\\n    vector<int>par,size;\\n    DisjointSet(int n){\\n        par.resize(n+1);\\n        size.resize(n+1,1);\\n        for(int i=0; i<=n; i++){\\n            par[i] = i;\\n        }\\n    }\\n    int findpar(int u){\\n        if(u == par[u]) return u;\\n        return par[u] = findpar(par[u]);\\n    }\\n\\n    void unionBySize(int u, int v){\\n        u = findpar(u);\\n        v = findpar(v);\\n\\n        if(u == v) return;\\n\\n        if(size[u] >= size[v]){\\n            par[v] = u;\\n            size[u] += size[v];\\n        }\\n        else{\\n            par[u] = v;\\n            size[v] += size[u];\\n        }\\n    }\\n    \\n};\\nclass Solution {\\npublic:\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        DisjointSet ds(n*m);\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                int p = i * m + j;\\n                int p1 = (i-1)*m + j;  // 1\\n                int p2 = (i+1)*m + j;  // 1\\n                int p3 = i*m + (j+1);  // 2\\n                int p4 = i*m + (j-1);  // 2\\n\\n                if(grid[i][j] == 1){\\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\\n                        ds.unionBySize(p,p3);\\n                    }\\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\\n                        ds.unionBySize(p,p4);\\n                    }\\n                }\\n                else if(grid[i][j] == 2){\\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\\n                        ds.unionBySize(p,p2);\\n                    }\\n\\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\\n                        ds.unionBySize(p,p1);\\n                    }\\n                }\\n                else if(grid[i][j] == 3){\\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\\n                        ds.unionBySize(p,p4);\\n                    }\\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\\n                        ds.unionBySize(p,p2);\\n                    }\\n                }\\n                else if(grid[i][j] == 4){\\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\\n                        ds.unionBySize(p,p3);\\n                    }\\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\\n                        ds.unionBySize(p,p2);\\n                    }\\n                }\\n                else if(grid[i][j] == 5){\\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\\n                        ds.unionBySize(p,p1);\\n                    }\\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\\n                        ds.unionBySize(p,p4);\\n                    }\\n                }\\n                else if(grid[i][j] == 6){\\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\\n                        ds.unionBySize(p,p1);\\n                    }\\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\\n                        ds.unionBySize(p,p3);\\n                    }\\n                }\\n            }\\n        }\\n        return ds.findpar(0) == ds.findpar(n*m-1);\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "indexing error",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass DisjointSet{\npublic:\n    vector<int>par,size;\n    DisjointSet(int n){\n        par.resize(n+1);\n        size.resize(n+1,1);\n        for(int i=0; i<=n; i++){\n            par[i] = i;\n        }\n    }\n    int findpar(int u){\n        if(u == par[u) return u;\n        return par[u] = findpar(par[u]);\n    }\n\n    void unionBySize(int u, int v){\n        u = findpar(u);\n        v = findpar(v);\n\n        if(u == v) return;\n\n        if(size[u-1] >= size[v-1]){\n            par[v-1] = u;\n            size[u-1] += size[v;\n        }\n        else{\n            par[u-1] = v;\n            size[v-1] += size[u];\n        }\n    }\n    \n};\nclass Solution {\npublic:\n    bool hasValidPath(vector<vector<int>>& grid) {\n        int n = grid.size();\n        int m = grid[0].size();\n        DisjointSet ds(n*m);\n        for(int i=0; i<n; i++){\n            for(int j=0; j<m; j++){\n                int p = i * m + j;\n                int p1 = (i-1)*m + j;  \n                int p2 = (i+1)*m + j;  \n                int p3 = i*m + (j+1);  \n                int p4 = i*m + (j-1);  \n\n                if(grid[i][j] == 1){\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\n                        ds.unionBySize(p,p3);\n                    }\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\n                        ds.unionBySize(p,p4);\n                    }\n                }\n                else if(grid[i][j] == 2){\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\n                        ds.unionBySize(p,p2);\n                    }\n\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\n                        ds.unionBySize(p,p1);\n                    }\n                }\n                else if(grid[i][j] == 3){\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\n                        ds.unionBySize(p,p4);\n                    }\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\n                        ds.unionBySize(p,p2);\n                    }\n                }\n                else if(grid[i][j] == 4){\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\n                        ds.unionBySize(p,p3);\n                    }\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\n                        ds.unionBySize(p,p2);\n                    }\n                }\n                else if(grid[i][j] == 5){\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\n                        ds.unionBySize(p,p1);\n                    }\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\n                        ds.unionBySize(p,p4);\n                    }\n                }\n                else if(grid[i][j] == 6){\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\n                        ds.unionBySize(p,p1);\n                    }\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\n                        ds.unionBySize(p,p3);\n                    }\n                }\n            }\n        }\n        return ds.findpar(0) == ds.findpar(n*m-1);\n    }\n};\n"
    },
    {
        "slug": "maximum-gap",
        "description": "Given an integer array nums, return the maximum difference between two successive elements in its sorted form. If the array contains less than two elements, return 0.\nYou must write an algorithm that runs in linear time and uses linear extra space.",
        "examples": [
            "Input: nums = [3,6,9,1]\nOutput: 3\nExplanation: The sorted form of the array is [1,3,6,9], either (3,6) or (6,9) has the maximum difference 3.",
            "Input: nums = [10]\nOutput: 0\nExplanation: The array contains less than 2 elements, therefore return 0."
        ],
        "constraints": "1 <= nums.length <= 105\n0 <= nums[i] <= 109",
        "oracle_code": "class Solution {\npublic:\n\nvector<int> countsort(vector<int> &nums)\n{\n    int n = nums.size();\n    map<int, int> m;\n    for (int i = 0; i < n; i++ )\n        m[nums[i]]++;\n\n    nums.clear();\n    for (auto it : m)\n    {\n        int cnt = it.second;\n        while (cnt--)\n        {\n            nums.push_back(it.first);\n        }\n    }\n    return nums;\n}\n\nint maximumGap(vector<int> &nums)\n{\n    int n = nums.size();\n    if (n < 2)\n        return 0;\n    vector<int> sortednums = countsort(nums);\n\n    int maxgap = INT_MIN;\n    for (int i = 1; i < n; i++)\n    {\n        int currgap = sortednums[i] - sortednums[i - 1];\n        maxgap = max(maxgap, currgap);\n    }\n\n    return maxgap;\n}\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nsince it is given in the question that we can use only linear time and space so we can only use a kind of counting sort , where we required a hash map which take an extra o(n) time complexity.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn counting sort first we required an hash map where we store the frequency of each element and after storing the frequency we just need to fill the original array based on there frequency , here we use an map not unordered map because the map is store value in sorted order.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nwe are traversing the array once , so  it is O(n) and an extra (logn)\\nfactor comes because of using the map, but still it is better in terms of time from inbuilt sort function..\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n) we are using only an map so the total extra space is equal to the size of map.\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\nvector<int> countsort(vector<int> &nums)\\n{\\n    int n = nums.size();\\n    map<int, int> m;\\n    for (int i = 0; i < n; i++ )\\n        m[nums[i]]++;\\n\\n    nums.clear();\\n    for (auto it : m)\\n    {\\n        int cnt = it.second;\\n        while (cnt--)\\n        {\\n            nums.push_back(it.first);\\n        }\\n    }\\n    return nums;\\n}\\n\\nint maximumGap(vector<int> &nums)\\n{\\n    int n = nums.size();\\n    if (n < 2)\\n        return 0;\\n    vector<int> sortednums = countsort(nums);\\n\\n    int maxgap = INT_MIN;\\n    for (int i = 1; i < n; i++)\\n    {\\n        int currgap = sortednums[i] - sortednums[i - 1];\\n        maxgap = max(maxgap, currgap);\\n    }\\n\\n    return maxgap;\\n}\\n};\\n```",
        "level": "medium",
        "type": [
            "indexing error",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n\nvector<int> countsort(vector<int> &nums)\n{\n    int n = nums.size();\n    map<int, int> m;\n    for (int i = 0; i <= n; i++ )\n        m[nums[i]]++;\n\n    nums.clear();\n    for (auto it : m)\n    {\n        int cnt = it.second;\n        while (cnt--)\n        {\n            nums.push_back(it.first);\n        }\n    }\n    return nums;\n}\n\nint maximumGap(vector<int> &nums)\n{\n    int n = nums.size();\n    if (n < 2)\n        return 0;\n    vector<int> sortednums = countsort(nums);\n\n    int maxgap = INT_MIN;\n    for (int i = 1; i <= n; i++)\n    {\n        int currgap = sortednums[i] - sortednums[i - 1];\n        maxgap = max(maxgap, currgap);\n    }\n\n    return maxgap;\n}\n};\n"
    },
    {
        "slug": "count-stepping-numbers-in-range",
        "description": "Given two positive integers low and high represented as strings, find the count of stepping numbers in the inclusive range [low, high].\nA stepping number is an integer such that all of its adjacent digits have an absolute difference of exactly 1.\nReturn an integer denoting the count of stepping numbers in the inclusive range [low, high]. \nSince the answer may be very large, return it modulo 109 + 7.\nNote: A stepping number should not have a leading zero.",
        "examples": [
            "Input: low = \"1\", high = \"11\"\nOutput: 10\nExplanation: The stepping numbers in the range [1,11] are 1, 2, 3, 4, 5, 6, 7, 8, 9 and 10. There are a total of 10 stepping numbers in the range. Hence, the output is 10.",
            "Input: low = \"90\", high = \"101\"\nOutput: 2\nExplanation: The stepping numbers in the range [90,101] are 98 and 101. There are a total of 2 stepping numbers in the range. Hence, the output is 2."
        ],
        "constraints": "1 <= int(low) <= int(high) < 10100\n1 <= low.length, high.length <= 100\nlow and high consist of only digits.\nlow and high don't have any leading zeros.",
        "oracle_code": "class Solution {\npublic:\n    #define mod 1000000007\n    long long dp[102][10][2][2];\n    long long f(string &r,int n,int pre,int leadingZero,int tight){\n        if(n==0) return 1;\n        \n        if(dp[n][pre][leadingZero][tight]!=-1) return dp[n][pre][leadingZero][tight];\n        long long up = tight ? (r[r.size()-n]-'0'):9,ans=0;\n        \n        if(leadingZero){\n            for(int i=0;i<=up;i++){\n                ans = (ans + f(r,n-1,i,(i==0),tight&(i==up)))%mod; \n            }\n        } else {\n            if(pre-1>=0 && pre-1<=up) ans = (ans + f(r,n-1,pre-1,0,tight&(pre-1==up)))%mod;\n            if(pre+1<=up) ans = (ans + f(r,n-1,pre+1,0,tight&(pre+1==up)))%mod;\n        }\n        \n        \n        return dp[n][pre][leadingZero][tight]=ans;\n    }\n    int countSteppingNumbers(string low, string high) {\n        int n=high.size();\n        memset(dp,-1,sizeof(dp));\n        long long r= f(high,high.size(),0,1,1);\n        memset(dp,-1,sizeof(dp));\n        for(int i=low.size()-1;i>=0;i--){\n            if((low[i]-'0')>0){\n                low[i]--;break;\n            } else {\n                low[i]='9';\n            }\n        }\n        \n        // cout<<low<<endl;\n        long long l= f(low,low.size(),0,1,1);\n        cout<<l<<\" \"<<r<<endl;\n        return (r-l+mod)%mod;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    #define mod 1000000007\\n    long long dp[102][10][2][2];\\n    long long f(string &r,int n,int pre,int leadingZero,int tight){\\n        if(n==0) return 1;\\n        \\n        if(dp[n][pre][leadingZero][tight]!=-1) return dp[n][pre][leadingZero][tight];\\n        long long up = tight ? (r[r.size()-n]-\\'0\\'):9,ans=0;\\n        \\n        if(leadingZero){\\n            for(int i=0;i<=up;i++){\\n                ans = (ans + f(r,n-1,i,(i==0),tight&(i==up)))%mod; \\n            }\\n        } else {\\n            if(pre-1>=0 && pre-1<=up) ans = (ans + f(r,n-1,pre-1,0,tight&(pre-1==up)))%mod;\\n            if(pre+1<=up) ans = (ans + f(r,n-1,pre+1,0,tight&(pre+1==up)))%mod;\\n        }\\n        \\n        \\n        return dp[n][pre][leadingZero][tight]=ans;\\n    }\\n    int countSteppingNumbers(string low, string high) {\\n        int n=high.size();\\n        memset(dp,-1,sizeof(dp));\\n        long long r= f(high,high.size(),0,1,1);\\n        memset(dp,-1,sizeof(dp));\\n        for(int i=low.size()-1;i>=0;i--){\\n            if((low[i]-\\'0\\')>0){\\n                low[i]--;break;\\n            } else {\\n                low[i]=\\'9\\';\\n            }\\n        }\\n        \\n        // cout<<low<<endl;\\n        long long l= f(low,low.size(),0,1,1);\\n        cout<<l<<\" \"<<r<<endl;\\n        return (r-l+mod)%mod;\\n    }\\n};\\n```",
        "level": "hard",
        "type": [
            "variable value error",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    #define mod 1000000007\n    long long dp[102][10][2][2];\n    long long f(string &r,int n,int pre,int leadingZero,int tight){\n        if(n==0) return 1;\n        \n        if(dp[n][pre][leadingZero][tight]!=-1) return dp[n][pre][leadingZero][tight];\n        long long up = tight ? (r[r.size()-n]-'0'):9,ans=0;\n        \n        if(leadingZero){\n            for(int i=0;i<=up;i++){\n                ans = (ans + f(r,n-1,i,(i==0),tight&(i==up)))%mod; \n            }\n        } else {\n            if(pre-1>=0 && pre-1<=up) ans = (ans + f(r,n-1,pre-1,0,tight&(pre-1==up)%mod;\n            if(pre+1<=up) ans = (ans + f(r,n-1,pre+1,0,tight&(pre+1==up)))%mod;\n        }\n        \n        \n        return dp[n][pre][leadingZero][tight]=ans;\n    }\n    int countSteppingNumbers(string low, string high) {\n        int n=high.size();\n        memset(dp,-1,sizeof(dp));\n        long long r= f(high,high.size(),0,1,0);  \n        memset(dp,-1,sizeof(dp));\n        for(int i=low.size()-1;i>=0;i--){\n            if((low[i]-'0')>0){\n                low[i]--;break;\n            } else {\n                low[i]='9';\n            }\n        }\n        \n        // cout<<low<<endl;\n        long long l= f(low,low.size(),0,1,1);\n        cout<<l<<\" \"<<r<<endl;\n        return (r-l+mod)%mod;\n    }\n};\n\n"
    },
    {
        "slug": "mean-of-array-after-removing-some-elements",
        "description": "Given an integer array arr, return the mean of the remaining integers after removing the smallest 5% and the largest 5% of the elements.\nAnswers within 10-5 of the actual answer will be considered accepted.",
        "examples": [
            "Input: arr = [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3]\nOutput: 2.00000\nExplanation: After erasing the minimum and the maximum values of this array, all elements are equal to 2, so the mean is 2.",
            "Input: arr = [6,2,7,5,1,2,0,3,10,2,5,0,5,5,0,8,7,6,8,0]\nOutput: 4.00000",
            "Input: arr = [6,0,7,0,7,5,7,8,3,4,0,7,8,1,6,8,1,1,2,4,8,1,9,5,4,3,8,5,10,8,6,6,1,0,6,10,8,2,3,4]\nOutput: 4.77778"
        ],
        "constraints": "20 <= arr.length <= 1000\narr.length is a multiple of 20.\n0 <= arr[i] <= 105",
        "oracle_code": "class Solution {\npublic:\n    double trimMean(vector<int>& arr) {\n        int i, k;\n        double mean;\n        sort(arr.begin(), arr.end());\n        k = 0.05*arr.size();\n        for(i=0 ; i<k ; i++)\n        {\n            arr.erase(arr.begin()+0);\n            arr.erase(arr.begin()+arr.size()-1);\n        }\n        mean = (double)accumulate(arr.begin(), arr.end(), 0)/arr.size();\n        return mean;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double trimMean(vector<int>& arr) {\\n        int i, k;\\n        double mean;\\n        sort(arr.begin(), arr.end());\\n        k = 0.05*arr.size();\\n        for(i=0 ; i<k ; i++)\\n        {\\n            arr.erase(arr.begin()+0);\\n            arr.erase(arr.begin()+arr.size()-1);\\n        }\\n        mean = (double)accumulate(arr.begin(), arr.end(), 0)/arr.size();\\n        return mean;\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "operation error",
            "wrong comment mark"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    double trimMean(vector<int>& arr) {\n        int i, k;\n        double mean;\n        /*sort(arr.begin(), arr.end());\n        k = 0.05*arr.size();\n        for(i=0 ; i<k ; i++)\n        {\n            arr.erase(arr.begin()+0);\n            arr.erase(arr.begin()+arr.size());\n        }\n        mean = (double)accumulate(arr.begin(), arr.end(), 0)/arr.size();*/\n        return mean;\n    }\n};\n"
    },
    {
        "slug": "most-beautiful-item-for-each-query",
        "description": "You are given a 2D integer array items where items[i] = [pricei, beautyi] denotes the price and beauty of an item respectively.\nYou are also given a 0-indexed integer array queries. For each queries[j], you want to determine the maximum beauty of an item whose price is less than or equal to queries[j]. If no such item exists, then the answer to this query is 0.\nReturn an array answer of the same length as queries where answer[j] is the answer to the jth query.",
        "examples": [
            "Input: items = [[1,2],[3,2],[2,4],[5,6],[3,5]], queries = [1,2,3,4,5,6]\nOutput: [2,4,5,5,6,6]\nExplanation:\n- For queries[0]=1, [1,2] is the only item which has price <= 1. Hence, the answer for this query is 2.\n- For queries[1]=2, the items which can be considered are [1,2] and [2,4]. \n  The maximum beauty among them is 4.\n- For queries[2]=3 and queries[3]=4, the items which can be considered are [1,2], [3,2], [2,4], and [3,5].\n  The maximum beauty among them is 5.\n- For queries[4]=5 and queries[5]=6, all items can be considered.\n  Hence, the answer for them is the maximum beauty of all items, i.e., 6.",
            "Input: items = [[1,2],[1,2],[1,3],[1,4]], queries = [1]\nOutput: [4]\nExplanation: \nThe price of every item is equal to 1, so we choose the item with the maximum beauty 4. \nNote that multiple items can have the same price and/or beauty.",
            "Input: items = [[10,1000]], queries = [5]\nOutput: [0]\nExplanation:\nNo item has a price less than or equal to 5, so no item can be chosen.\nHence, the answer to the query is 0."
        ],
        "constraints": "1 <= items.length, queries.length <= 105\nitems[i].length == 2\n1 <= pricei, beautyi, queries[j] <= 109",
        "oracle_code": "class Solution {\n    int bs(vector<vector<int>>& items, int t, vector<int> &beauty) {\n        int ans = 0, s = 0, e = items.size() - 1;\n        while(s <= e) {\n            int m = (s + e) / 2;\n            if(items[m][0] <= t) ans = beauty[m], s = m + 1;\n            else e = m - 1;\n        }\n        return ans;\n    }\n\npublic:\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\n        sort(items.begin(), items.end());\n        vector<int> ans, beauty(items.size(), items[0][1]);\n\n        for(int i=1; i<items.size(); i++) beauty[i] = max(beauty[i - 1], items[i][1]);\n\n        for(int i : queries) ans.push_back(bs(items, i, beauty));\n        return ans;\n    }\n};",
        "content": "\\n# C++\\n```\\nclass Solution {\\n    int bs(vector<vector<int>>& items, int t, vector<int> &beauty) {\\n        int ans = 0, s = 0, e = items.size() - 1;\\n        while(s <= e) {\\n            int m = (s + e) / 2;\\n            if(items[m][0] <= t) ans = beauty[m], s = m + 1;\\n            else e = m - 1;\\n        }\\n        return ans;\\n    }\\n\\npublic:\\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\\n        sort(items.begin(), items.end());\\n        vector<int> ans, beauty(items.size(), items[0][1]);\\n\\n        for(int i=1; i<items.size(); i++) beauty[i] = max(beauty[i - 1], items[i][1]);\\n\\n        for(int i : queries) ans.push_back(bs(items, i, beauty));\\n        return ans;\\n    }\\n};\\n```\\n\\n# Python\\n```\\nclass Solution(object):\\n    def maximumBeauty(self, items, queries):\\n        items.sort()\\n        ans, beauty = [], [items[0][1]] * len(items)\\n        for i in range(1, len(items)): beauty[i] = max(beauty[i - 1], items[i][1])\\n\\n        def bs(t):\\n            ans, s, e = 0, 0, len(items) - 1\\n            while s <= e:\\n                m = (s + e) // 2\\n                if items[m][0] <= t:\\n                    ans = beauty[m]\\n                    s = m + 1\\n                else: e = m - 1\\n            return ans\\n\\n        for i in queries: ans.append(bs(i))\\n        return ans\\n```\\n",
        "level": "medium",
        "type": [
            "conditional statement error",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution {\n    int bs(vector<vector<Integer>>& items, int t, vector<int> &beauty) {\n        int ans = 0, s = 0, e = items.size() - 1;\n        while(s <= e) {\n            int m = (s + e) / 2;\n            if(items[m][0] <= t) ans = beauty[m], s = m + 1;\n            else s = m + 1; \n        }\n        return ans;\n    }\n\npublic:\n    vector<int> maximumBeauty(vector<vector<Integer>>& items, vector<int>& queries) {\n        sort(items.begin(), items.end());\n        vector<int> ans, beauty(items.size(), items[0][1]);\n\n        for(int i=1; i<items.size(); i++) beauty[i] = max(beauty[i - 1], items[i][1]);\n\n        for(int i : queries) ans.push_back(bs(items, i, beauty));\n        return ans;\n    }\n};\n"
    },
    {
        "slug": "minimum-total-cost-to-make-arrays-unequal",
        "description": "You are given two 0-indexed integer arrays nums1 and nums2, of equal length n.\nIn one operation, you can swap the values of any two indices of nums1. The cost of this operation is the sum of the indices.\nFind the minimum total cost of performing the given operation any number of times such that nums1[i] != nums2[i] for all 0 <= i <= n - 1 after performing all the operations.\nReturn the minimum total cost such that nums1 and nums2 satisfy the above condition. In case it is not possible, return -1.",
        "examples": [
            "Input: nums1 = [1,2,3,4,5], nums2 = [1,2,3,4,5]\nOutput: 10\nExplanation: \nOne of the ways we can perform the operations is:\n- Swap values at indices 0 and 3, incurring cost = 0 + 3 = 3. Now, nums1 = [4,2,3,1,5]\n- Swap values at indices 1 and 2, incurring cost = 1 + 2 = 3. Now, nums1 = [4,3,2,1,5].\n- Swap values at indices 0 and 4, incurring cost = 0 + 4 = 4. Now, nums1 =[5,3,2,1,4].\nWe can see that for each index i, nums1[i] != nums2[i]. The cost required here is 10.\nNote that there are other ways to swap values, but it can be proven that it is not possible to obtain a cost less than 10.",
            "Input: nums1 = [2,2,2,1,3], nums2 = [1,2,2,3,3]\nOutput: 10\nExplanation: \nOne of the ways we can perform the operations is:\n- Swap values at indices 2 and 3, incurring cost = 2 + 3 = 5. Now, nums1 = [2,2,1,2,3].\n- Swap values at indices 1 and 4, incurring cost = 1 + 4 = 5. Now, nums1 = [2,3,1,2,2].\nThe total cost needed here is 10, which is the minimum possible.",
            "Input: nums1 = [1,2,2], nums2 = [1,2,2]\nOutput: -1\nExplanation: \nIt can be shown that it is not possible to satisfy the given conditions irrespective of the number of operations we perform.\nHence, we return -1."
        ],
        "constraints": "n == nums1.length == nums2.length\n1 <= n <= 105\n1 <= nums1[i], nums2[i] <= n",
        "oracle_code": "class Solution {\npublic:\n    long long minimumTotalCost(vector<int>& nums1, vector<int>& nums2) {\n        long long ans = 0;\n        \n        vector<int> counts(100005, 0);\n        int dominantCnt = 0;\n        int dominantNum = -1;\n        int involvedCnt = 0;\n        int n = nums1.size();\n        for (int i = 0; i < n; ++i) {\n            if (nums1[i] == nums2[i]) {\n                ans += i;\n                counts[nums1[i]]++;\n                if (counts[nums1[i]] > dominantCnt) {\n                    dominantCnt = counts[nums1[i]];\n                    dominantNum = nums1[i];\n                }\n                involvedCnt++;\n            }\n        }\n        if (dominantCnt > involvedCnt / 2) {\n            for (int i = 0; i < n; ++i) {\n                if (nums1[i] != nums2[i] && nums1[i] != dominantNum && nums2[i] != dominantNum) {\n                    counts[nums1[i]]++;\n                    involvedCnt++;\n                    ans += i;\n                    if (dominantCnt <= involvedCnt / 2) {\n                        return ans;\n                    }\n                }\n            }\n            return -1;\n        }\n        else {\n            return ans;\n        }\n    }\n};",
        "content": "# Intuition and Approach\\n1. The cost of swapping numbers at idx1 and idx2 is `idx1 + idx2`\\n2. You only need to swap numbers at i that are identical in nums1[i] and nums2[i].\\n- e.g., `nums1 = [1,2,3,4,5]; nums2 = [2,2,3,5,5]` => extract `[2,3,5]`\\n3. Let\\'s consider two cases\\n- The `count of dominant element <= the count of all extracted elements / 2`. See 4\\n- The `count of dominant element > the count of all extracted elements / 2`. See 6\\n4. You can just sum all idx of them. There must be one permutation that can achieve the criteria: no identical number. For example, `[2,3,5]` can be permutated into `[5,2,3]`, and `[2,2,4,4]` can be permuted into `[4,4,2,2]`. \\n5. You might wonder what is the least cost to make such permutation. Consider you want to swap idx `i` to somewhere `j`, you must cost `i` first and then `j`, and if `j=0` the cost is `i`. So any swap of two numbers can be regarded as a process of swapping `i <-> 0 (of the original array) <-> j`. The total cost would be the sum of all idx. For the proof, please see [l_returns\\'s](https://leetcode.com/problems/minimum-total-cost-to-make-arrays-unequal/solutions/2897969/c-simple-greedy-in-on-with-explanation/comments/1712870) comment.\\n6. If there is case like `[2,2,2,3,3]`, there is no permutation that can achieve the goal. So keep adding other elements from the original array for changing `2`, which is the dominant element in the example. Besides, you should avoid the idx `k` that `nums1[k] == dominant number || nums2[k] == dominant number`.\\n7. If the left numbers are exhausted and you still can not achieve `count of dominant element <= the count of all extract elements / 2`, return -1.\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(The range of the numbers)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumTotalCost(vector<int>& nums1, vector<int>& nums2) {\\n        long long ans = 0;\\n        \\n        vector<int> counts(100005, 0);\\n        int dominantCnt = 0;\\n        int dominantNum = -1;\\n        int involvedCnt = 0;\\n        int n = nums1.size();\\n        for (int i = 0; i < n; ++i) {\\n            if (nums1[i] == nums2[i]) {\\n                ans += i;\\n                counts[nums1[i]]++;\\n                if (counts[nums1[i]] > dominantCnt) {\\n                    dominantCnt = counts[nums1[i]];\\n                    dominantNum = nums1[i];\\n                }\\n                involvedCnt++;\\n            }\\n        }\\n        if (dominantCnt > involvedCnt / 2) {\\n            for (int i = 0; i < n; ++i) {\\n                if (nums1[i] != nums2[i] && nums1[i] != dominantNum && nums2[i] != dominantNum) {\\n                    counts[nums1[i]]++;\\n                    involvedCnt++;\\n                    ans += i;\\n                    if (dominantCnt <= involvedCnt / 2) {\\n                        return ans;\\n                    }\\n                }\\n            }\\n            return -1;\\n        }\\n        else {\\n            return ans;\\n        }\\n    }\\n};\\n```",
        "level": "hard",
        "type": [
            "wrong comment mark",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    long long minimumTotalCost(vector<int>& nums1, vector<int>& nums2) {\n        long long ans = 0;\n        \n        vector<int> counts(100005, 0);\n        int dominantCnt = 0;\n        int dominantNum = -1;\n        int involvedCnt = 0;\n        int n = nums1.size();\n        for (int i = 0; i < n; ++i) /*\n            if (nums1[i] == nums2[i]) {\n                ans += i;\n                counts[nums1[i]]++;\n                if (counts[nums1[i]] > dominantCnt) {\n                    dominantCnt = counts[nums1[i]];\n                    dominantNum = nums1[i];\n                }\n                involvedCnt++;\n            }\n        */\n        if (dominantCnt > involvedCnt / 2) {\n            for (int i = 0; i < n; ++i) {\n                if (nums1[i] != nums2[i] && nums1[i] != dominantNum && nums2[i] != dominantNum) {\n                    counts[nums1[i]]++;\n                    involvedCnt++;\n                    ans += i;\n                    if (dominantCnt <= involvedCnt / 2) {\n                        return ans;\n                    }\n                }\n            }\n            return -1;\n        }\n        else {\n            return this->minimumTotalCost();\n        }\n    }\n};\n"
    },
    {
        "slug": "sum-multiples",
        "description": "Given a positive integer n, find the sum of all integers in the range [1, n] inclusive that are divisible by 3, 5, or 7.\nReturn an integer denoting the sum of all numbers in the given range satisfying\u00a0the constraint.",
        "examples": [
            "Input: n = 7\nOutput: 21\nExplanation: Numbers in the range [1, 7] that are divisible by 3, 5, or 7 are 3, 5, 6, 7. The sum of these numbers is 21.",
            "Input: n = 10\nOutput: 40\nExplanation: Numbers in the range [1, 10] that are divisible by 3, 5, or 7 are 3, 5, 6, 7, 9, 10. The sum of these numbers is 40.",
            "Input: n = 9\nOutput: 30\nExplanation: Numbers in the range [1, 9] that are divisible by 3, 5, or 7 are 3, 5, 6, 7, 9. The sum of these numbers is 30."
        ],
        "constraints": "1 <= n <= 103",
        "oracle_code": "class Solution {\npublic:\n    int sumOfMultiples(int n,int count=0) {\n       \n       \n       for (int i=1;i<=n;i++)\n       {\n         if (i%3==0 || i%5==0 ||i%7==0)\n           count+=i;\n       }\n    return count;\n\n    }\n};",
        "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int sumOfMultiples(int n,int count=0) {\\n       \\n       \\n       for (int i=1;i<=n;i++)\\n       {\\n         if (i%3==0 || i%5==0 ||i%7==0)\\n           count+=i;\\n       }\\n    return count;\\n\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "operation error",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    let sumOfMultiples = (n, count=0) =>{\n\n       for (let i=1;i<=n;i++)\n       {\n         if (i%3==0 || i%5==0 ||i%7==0)\n           count+=i;\n       }\n    return count-1;\n\n    }\n};\n"
    },
    {
        "slug": "kth-ancestor-of-a-tree-node",
        "description": "You are given a tree with n nodes numbered from 0 to n - 1 in the form of a parent array parent where parent[i] is the parent of ith node. The root of the tree is node 0. Find the kth ancestor of a given node.\nThe kth ancestor of a tree node is the kth node in the path from that node to the root node.\nImplement the TreeAncestor class:\n\nTreeAncestor(int n, int[] parent) Initializes the object with the number of nodes in the tree and the parent array.\nint getKthAncestor(int node, int k) return the kth ancestor of the given node node. If there is no such ancestor, return -1.",
        "examples": [
            "Input\n[\"TreeAncestor\", \"getKthAncestor\", \"getKthAncestor\", \"getKthAncestor\"]\n[[7, [-1, 0, 0, 1, 1, 2, 2]], [3, 1], [5, 2], [6, 3]]\nOutput\n[null, 1, 0, -1]\n\nExplanation\nTreeAncestor treeAncestor = new TreeAncestor(7, [-1, 0, 0, 1, 1, 2, 2]);\ntreeAncestor.getKthAncestor(3, 1); // returns 1 which is the parent of 3\ntreeAncestor.getKthAncestor(5, 2); // returns 0 which is the grandparent of 5\ntreeAncestor.getKthAncestor(6, 3); // returns -1 because there is no such ancestor"
        ],
        "constraints": "1 <= k <= n <= 5 * 104\nparent.length == n\nparent[0] == -1\n0 <= parent[i] < n for all 0 < i < n\n0 <= node < n\nThere will be at most 5 * 104 queries.",
        "oracle_code": "class TreeAncestor {\npublic:\n    vector<vector<int>>v;\n    TreeAncestor(int n, vector<int>& parent) {\n        vector<vector<int>> par(n, vector<int>(20));\n        for (int i = 0; i < n; i++) par[i][0] = parent[i];\n        for (int j = 1; j < 20; j++) {\n            for (int i = 0; i < n; i++) {\n                if (par[i][j - 1] == -1) par[i][j] = -1;\n                else par[i][j] = par[par[i][j - 1]][j - 1];\n            }\n        }\n        swap(v, par);\n    }\n    int getKthAncestor(int node, int k) {\n        for (int i = 0; i < 20; i++) {\n            if ((k >> i) & 1) {\n                node = v[node][i];\n                if (node == -1) return -1;\n            }\n        }\n        return node;\n    }\n};\n\n/**\n * Your TreeAncestor object will be instantiated and called as such:\n * TreeAncestor* obj = new TreeAncestor(n, parent);\n * int param_1 = obj->getKthAncestor(node,k);\n */",
        "content": "\\n\\n# Code\\n```\\nclass TreeAncestor {\\npublic:\\n    vector<vector<int>>v;\\n    TreeAncestor(int n, vector<int>& parent) {\\n        vector<vector<int>> par(n, vector<int>(20));\\n        for (int i = 0; i < n; i++) par[i][0] = parent[i];\\n        for (int j = 1; j < 20; j++) {\\n            for (int i = 0; i < n; i++) {\\n                if (par[i][j - 1] == -1) par[i][j] = -1;\\n                else par[i][j] = par[par[i][j - 1]][j - 1];\\n            }\\n        }\\n        swap(v, par);\\n    }\\n    int getKthAncestor(int node, int k) {\\n        for (int i = 0; i < 20; i++) {\\n            if ((k >> i) & 1) {\\n                node = v[node][i];\\n                if (node == -1) return -1;\\n            }\\n        }\\n        return node;\\n    }\\n};\\n\\n/**\\n * Your TreeAncestor object will be instantiated and called as such:\\n * TreeAncestor* obj = new TreeAncestor(n, parent);\\n * int param_1 = obj->getKthAncestor(node,k);\\n */\\n```",
        "level": "hard",
        "type": [
            "undefined methods",
            "variable value error"
        ],
        "buggy_code": "\nclass TreeAncestor {\npublic:\n    vector<vector<int>>v;\n    TreeAncestor(int n, vector<int>& parent) {\n        vector<vector<int>> par(n, vector<int>(20));\n        for (int i = 0; i < n; i++) par[i][0] = i; \n        for (int j = 1; j < 20; j++) {\n            for (int i = 0; i < n; i++) {\n                if (par[i][j - 1] == -1) par[i][j] = -1;\n                else par[i][j] = par[par[i][j - 1]][j - 1];\n            }\n        }\n        swap(v, par);\n    }\n    int getKthAncestor(int node, int k) {\n        for (int i = 0; i < 20; i++) {\n            if ((k >> i) & 1) {\n                node = v[node][i];\n                if (node == -1) return -1;\n                getKthAncestor(node, k);\n            }\n        }\n        return node;\n    }\n};\n\n"
    },
    {
        "slug": "lexicographically-smallest-string-after-substring-operation",
        "description": "You are given a string s consisting of only lowercase English letters. In one operation, you can do the following:\n\nSelect any non-empty substring of s, possibly the entire string, then replace each one of its characters with the previous character of the English alphabet. For example, 'b' is converted to 'a', and 'a' is converted to 'z'.\n\nReturn the lexicographically smallest string you can obtain after performing the above operation exactly once.\nA substring is a contiguous sequence of characters in a string.\nA string x is lexicographically smaller than a string y of the same length if x[i] comes before y[i] in alphabetic order for the first position i such that x[i] != y[i].",
        "examples": [
            "Input: s = \"cbabc\"\nOutput: \"baabc\"\nExplanation: We apply the operation on the substring starting at index 0, and ending at index 1 inclusive. \nIt can be proven that the resulting string is the lexicographically smallest.",
            "Input: s = \"acbbc\"\nOutput: \"abaab\"\nExplanation: We apply the operation on the substring starting at index 1, and ending at index 4 inclusive. \nIt can be proven that the resulting string is the lexicographically smallest.",
            "Input: s = \"leetcode\"\nOutput: \"kddsbncd\"\nExplanation: We apply the operation on the entire string. \nIt can be proven that the resulting string is the lexicographically smallest."
        ],
        "constraints": "1 <= s.length <= 3 * 105\ns consists of lowercase English letters",
        "oracle_code": "class Solution {\npublic:\n    string smallestString(string s) {\n        int temp = -1;\n        int cnt = 0;\n        for(int i = 0; i < s.size(); i++)\n        {\n            if(s[i] == 'a')\n            {\n                cnt++;\n            }\n        }\n        if(cnt == s.size())\n        {\n            s[s.size() - 1] = 'z';\n            return s;\n        }\n        else\n        {\n            for(int i = 0; i < s.size(); i++)\n            {\n                if(s[i] == 'a')\n                {\n                    temp = i;\n                    break;\n                }\n            }\n\n            if(temp == 0)\n            {\n                int temp1 = 1, temp2 = 1;\n                for(int i = 1 ; i < s.size(); i++)\n                {\n                    if(s[i] != 'a')\n                    {\n                        temp1 = i;\n                        break;\n                    }\n                }\n                for(int i = temp1; i < s.size(); i++)\n                {\n                    if(s[i] == 'a')\n                    {\n                        temp2 = i;\n                        break;\n                    }\n                }\n\n                if(temp2 > 1)\n                {\n                    for(int i = temp1; i < temp2; i++)\n                    {\n                        s[i] = s[i] - 1;\n                    }\n                }\n                else if(temp2 == 1)\n                {\n                    for(int i = temp1; i < s.size(); i++)\n                    {\n                        s[i] = s[i] - 1;\n                    }\n                }\n\n                return s;\n            }\n            else if(temp == -1)\n            {\n                for(int i = 0; i < s.size(); i++)\n                {\n                    s[i] = s[i] - 1;\n                }\n                return s;\n            }\n            else\n            {\n                for(int i = 0; i < temp; i++)\n                {\n                    s[i] = s[i] - 1;\n                }\n                return s;\n            }\n        }\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCheck for the first occurence of \\'a\\'.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Check for the index where \\'a\\' has occured the very first time.\\n2. If it is index 0, then check for the very first index at which s[i] != \\'a\\', store this index in temp1 variable, then from temp1 check for the nearest occurence of \\'a\\' and store in temp2 variable, and from temp1 till temp2 - 1, replace all the letters with their previous one (alphabetically).\\n3. If index of first occurence of \\'a\\' is greater than 0 and store it in temp variable, then simply starting from 0 and ranging to temp - 1, replace all the letters with their previous one (alphabetically).\\n\\n# Complexity\\n- Time complexity: **O(n)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nIn worst case, we need to traverse the whole string.\\n\\n- Space complexity: **O(1)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nConstant extra space.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string smallestString(string s) {\\n        int temp = -1;\\n        int cnt = 0;\\n        for(int i = 0; i < s.size(); i++)\\n        {\\n            if(s[i] == \\'a\\')\\n            {\\n                cnt++;\\n            }\\n        }\\n        if(cnt == s.size())\\n        {\\n            s[s.size() - 1] = \\'z\\';\\n            return s;\\n        }\\n        else\\n        {\\n            for(int i = 0; i < s.size(); i++)\\n            {\\n                if(s[i] == \\'a\\')\\n                {\\n                    temp = i;\\n                    break;\\n                }\\n            }\\n\\n            if(temp == 0)\\n            {\\n                int temp1 = 1, temp2 = 1;\\n                for(int i = 1 ; i < s.size(); i++)\\n                {\\n                    if(s[i] != \\'a\\')\\n                    {\\n                        temp1 = i;\\n                        break;\\n                    }\\n                }\\n                for(int i = temp1; i < s.size(); i++)\\n                {\\n                    if(s[i] == \\'a\\')\\n                    {\\n                        temp2 = i;\\n                        break;\\n                    }\\n                }\\n\\n                if(temp2 > 1)\\n                {\\n                    for(int i = temp1; i < temp2; i++)\\n                    {\\n                        s[i] = s[i] - 1;\\n                    }\\n                }\\n                else if(temp2 == 1)\\n                {\\n                    for(int i = temp1; i < s.size(); i++)\\n                    {\\n                        s[i] = s[i] - 1;\\n                    }\\n                }\\n\\n                return s;\\n            }\\n            else if(temp == -1)\\n            {\\n                for(int i = 0; i < s.size(); i++)\\n                {\\n                    s[i] = s[i] - 1;\\n                }\\n                return s;\\n            }\\n            else\\n            {\\n                for(int i = 0; i < temp; i++)\\n                {\\n                    s[i] = s[i] - 1;\\n                }\\n                return s;\\n            }\\n        }\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "other error",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    string smallestString(string s) {\n        int temp = -1;\n        int cnt = 0;\n        for(int i = 0; i < s.size(); i++)\n        {\n            if(s[i] == 'a')\n            {\n                cnt++;\n            }\n        }\n        string msg = \"Input data: ;\n        if(cnt == s.size())\n        {\n            s[s.size()] = 'z';\n            return s;\n        }\n        else\n        {\n            for(int i = 0; i < s.size(); i++)\n            {\n                if(s[i] == 'a')\n                {\n                    temp = i;\n                    break;\n                }\n            }\n\n            if(temp == 0)\n            {\n                int temp1 = 1, temp2 = 1;\n                for(int i = 1 ; i < s.size(); i++)\n                {\n                    if(s[i] != 'a')\n                    {\n                        temp1 = i;\n                        break;\n                    }\n                }\n                for(int i = temp1; i < s.size(); i++)\n                {\n                    if(s[i] == 'a')\n                    {\n                        temp2 = i;\n                        break;\n                    }\n                }\n\n                if(temp2 > 1)\n                {\n                    for(int i = temp1; i < temp2; i++)\n                    {\n                        s[i] = s[i] - 1;\n                    }\n                }\n                else if(temp2 == 1)\n                {\n                    for(int i = temp1; i < s.size(); i++)\n                    {\n                        s[i] = s[i] - 1;\n                    }\n                }\n\n                return s;\n            }\n            else if(temp == -1)\n            {\n                for(int i = 0; i < s.size(); i++)\n                {\n                    s[i] = s[i] - 1;\n                }\n                return s;\n            }\n            else\n            {\n                for(int i = 0; i < temp; i++)\n                {\n                    s[i] = s[i] - 1;\n                }\n                return s;\n            }\n        }\n    }\n};\n"
    },
    {
        "slug": "extra-characters-in-a-string",
        "description": "You are given a 0-indexed string s and a dictionary of words dictionary. You have to break s into one or more non-overlapping substrings such that each substring is present in dictionary. There may be some extra characters in s which are not present in any of the substrings.\nReturn the minimum number of extra characters left over if you break up s optimally.",
        "examples": [
            "Input: s = \"leetscode\", dictionary = [\"leet\",\"code\",\"leetcode\"]\nOutput: 1\nExplanation: We can break s in two substrings: \"leet\" from index 0 to 3 and \"code\" from index 5 to 8. There is only 1 unused character (at index 4), so we return 1.",
            "Input: s = \"sayhelloworld\", dictionary = [\"hello\",\"world\"]\nOutput: 3\nExplanation: We can break s in two substrings: \"hello\" from index 3 to 7 and \"world\" from index 8 to 12. The characters at indices 0, 1, 2 are not used in any substring and thus are considered as extra characters. Hence, we return 3."
        ],
        "constraints": "1 <= s.length <= 50\n1 <= dictionary.length <= 50\n1 <= dictionary[i].length <= 50\ndictionary[i]\u00a0and s consists of only lowercase English letters\ndictionary contains distinct words",
        "oracle_code": "class Solution {\npublic:\n    int rec(int ind,string &s,set<string>&st,vector<int>&dp)\n    {\n        if (ind==s.size()) return 0;\n        if (dp[ind]!=-1) return dp[ind];\n        int ans=s.size()-ind;\n        for (int i=ind;i<s.size();i++)\n        {\n           string temp=s.substr(ind,i-ind+1);\n           if (st.find(temp)!=st.end())\n           {\n              ans=min(ans,rec(i+1,s,st,dp));\n           }\n        }\n        ans=min(ans,1+rec(ind+1,s,st,dp));\n        return dp[ind]=ans;\n    }\n    int minExtraChar(string s, vector<string>& dictionary) \n    {\n        set<string>st;\n        int n=s.size();\n        vector<int>dp(n,-1);\n        for (auto it:dictionary)\n        {\n            st.insert(it);\n        }\n        return rec(0,s,st,dp);\n    }\n};",
        "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int rec(int ind,string &s,set<string>&st,vector<int>&dp)\\n    {\\n        if (ind==s.size()) return 0;\\n        if (dp[ind]!=-1) return dp[ind];\\n        int ans=s.size()-ind;\\n        for (int i=ind;i<s.size();i++)\\n        {\\n           string temp=s.substr(ind,i-ind+1);\\n           if (st.find(temp)!=st.end())\\n           {\\n              ans=min(ans,rec(i+1,s,st,dp));\\n           }\\n        }\\n        ans=min(ans,1+rec(ind+1,s,st,dp));\\n        return dp[ind]=ans;\\n    }\\n    int minExtraChar(string s, vector<string>& dictionary) \\n    {\\n        set<string>st;\\n        int n=s.size();\\n        vector<int>dp(n,-1);\\n        for (auto it:dictionary)\\n        {\\n            st.insert(it);\\n        }\\n        return rec(0,s,st,dp);\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "indexing error",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    int rec(int ind,string &s,set<string>&st,vector<int>&dp)\n    {\n        if (ind==s.size()) return 0;\n        if (dp[ind]!=-1) return dp[ind];\n        int ans=s.size()-ind;\n        for (int i=ind;i<=s.size();i++)\n        {\n           string temp=s.substr(ind,i-ind+1);\n           if (st.find(temp)!=st.end())\n           {\n              ans=min(ans,rec(i+1,s,st,dp));\n           }\n        }\n        ans=min(ans,rec(ind,s,st,dp)); \n        return dp[ind]=ans;\n    }\n    int minExtraChar(string s, vector<string>& dictionary) \n    {\n        set<string>st;\n        int n=s.size();\n        vector<int>dp(n,-1);\n        for (auto it:dictionary)\n        {\n            st.insert(it);\n        }\n        return rec(0,s,st,dp);\n    }\n};\n"
    },
    {
        "slug": "count-good-numbers",
        "description": "A digit string is good if the digits (0-indexed) at even indices are even and the digits at odd indices are prime (2, 3, 5, or 7).\n\nFor example, \"2582\" is good because the digits (2 and 8) at even positions are even and the digits (5 and 2) at odd positions are prime. However, \"3245\" is not good because 3 is at an even index but is not even.\n\nGiven an integer n, return the total number of good digit strings of length n. Since the answer may be large, return it modulo 109 + 7.\nA digit string is a string consisting of digits 0 through 9 that may contain leading zeros.",
        "examples": [
            "Input: n = 1\nOutput: 5\nExplanation: The good numbers of length 1 are \"0\", \"2\", \"4\", \"6\", \"8\".",
            "Input: n = 4\nOutput: 400",
            "Input: n = 50\nOutput: 564908303"
        ],
        "constraints": "1 <= n <= 1015",
        "oracle_code": "class Solution {\npublic:\n    int mod=1e9+7;\n    int binExpo(long long x,long long n){\n        int ans=1;\n        while(n){\n            if(n&1){\n                ans=(ans*x)%mod;\n            }\n            x=(x*x)%mod;\n            n>>=1;\n        }\n        return ans;\n    }\n    int countGoodNumbers(long long n) {\n        long long even=n/2+n%2,odd=n/2;\n        int even_val=binExpo(5,even);\n        int odd_val=binExpo(4,odd);\n        return (1ll*even_val*odd_val)%mod;\n\n        \n    }\n};",
        "content": "Here we can use the concept of binary exponentiation.\\nAs 2^7==2^(0111) in binary.\\nso 2^7=(2^4)*(2^2)*(2^1).\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int binExpo(long long x,long long n){\\n        int ans=1;\\n        while(n){\\n            if(n&1){\\n                ans=(ans*x)%mod;\\n            }\\n            x=(x*x)%mod;\\n            n>>=1;\\n        }\\n        return ans;\\n    }\\n    int countGoodNumbers(long long n) {\\n        long long even=n/2+n%2,odd=n/2;\\n        int even_val=binExpo(5,even);\\n        int odd_val=binExpo(4,odd);\\n        return (1ll*even_val*odd_val)%mod;\\n\\n        \\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "variable value error",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    int mod=1e9+7;\n    int binExpo(long long x,long long n){\n        int ans=1;\n        while(n){\n            if(n&1){\n                ans=(ans*x)%mod;\n            }\n            x=(x*x)%mod;\n            n=1;\n        }\n        return ans;\n    }\n    int countGoodNumbers(long long n) {\n        long long even=n/2+n%2,odd=n/2;\n        int even_val=binExpo(5,even);\n        int odd_val=undefined_object;\n        return (1ll*even_val*odd_val)%mod;\n    }\n};\n"
    },
    {
        "slug": "check-if-there-is-a-valid-path-in-a-grid",
        "description": "You are given an m x n grid. Each cell of grid represents a street. The street of grid[i][j] can be:\n\n1 which means a street connecting the left cell and the right cell.\n2 which means a street connecting the upper cell and the lower cell.\n3 which means a street connecting the left cell and the lower cell.\n4 which means a street connecting the right cell and the lower cell.\n5 which means a street connecting the left cell and the upper cell.\n6 which means a street connecting the right cell and the upper cell.\n\n\nYou will initially start at the street of the upper-left cell (0, 0). A valid path in the grid is a path that starts from the upper left cell (0, 0) and ends at the bottom-right cell (m - 1, n - 1). The path should only follow the streets.\nNotice that you are not allowed to change any street.\nReturn true if there is a valid path in the grid or false otherwise.",
        "examples": [
            "Input: grid = [[2,4,3],[6,5,2]]\nOutput: true\nExplanation: As shown you can start at cell (0, 0) and visit all the cells of the grid to reach (m - 1, n - 1).",
            "Input: grid = [[1,2,1],[1,2,1]]\nOutput: false\nExplanation: As shown you the street at cell (0, 0) is not connected with any street of any other cell and you will get stuck at cell (0, 0)",
            "Input: grid = [[1,1,2]]\nOutput: false\nExplanation: You will get stuck at cell (0, 1) and you cannot reach cell (0, 2)."
        ],
        "constraints": "m == grid.length\nn == grid[i].length\n1 <= m, n <= 300\n1 <= grid[i][j] <= 6",
        "oracle_code": "class DisjointSet{\npublic:\n    vector<int>par,size;\n    DisjointSet(int n){\n        par.resize(n+1);\n        size.resize(n+1,1);\n        for(int i=0; i<=n; i++){\n            par[i] = i;\n        }\n    }\n    int findpar(int u){\n        if(u == par[u]) return u;\n        return par[u] = findpar(par[u]);\n    }\n\n    void unionBySize(int u, int v){\n        u = findpar(u);\n        v = findpar(v);\n\n        if(u == v) return;\n\n        if(size[u] >= size[v]){\n            par[v] = u;\n            size[u] += size[v];\n        }\n        else{\n            par[u] = v;\n            size[v] += size[u];\n        }\n    }\n    \n};\nclass Solution {\npublic:\n    bool hasValidPath(vector<vector<int>>& grid) {\n        int n = grid.size();\n        int m = grid[0].size();\n        DisjointSet ds(n*m);\n        for(int i=0; i<n; i++){\n            for(int j=0; j<m; j++){\n                int p = i * m + j;\n                int p1 = (i-1)*m + j;  // 1\n                int p2 = (i+1)*m + j;  // 1\n                int p3 = i*m + (j+1);  // 2\n                int p4 = i*m + (j-1);  // 2\n\n                if(grid[i][j] == 1){\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\n                        ds.unionBySize(p,p3);\n                    }\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\n                        ds.unionBySize(p,p4);\n                    }\n                }\n                else if(grid[i][j] == 2){\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\n                        ds.unionBySize(p,p2);\n                    }\n\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\n                        ds.unionBySize(p,p1);\n                    }\n                }\n                else if(grid[i][j] == 3){\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\n                        ds.unionBySize(p,p4);\n                    }\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\n                        ds.unionBySize(p,p2);\n                    }\n                }\n                else if(grid[i][j] == 4){\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\n                        ds.unionBySize(p,p3);\n                    }\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\n                        ds.unionBySize(p,p2);\n                    }\n                }\n                else if(grid[i][j] == 5){\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\n                        ds.unionBySize(p,p1);\n                    }\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\n                        ds.unionBySize(p,p4);\n                    }\n                }\n                else if(grid[i][j] == 6){\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\n                        ds.unionBySize(p,p1);\n                    }\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\n                        ds.unionBySize(p,p3);\n                    }\n                }\n            }\n        }\n        return ds.findpar(0) == ds.findpar(n*m-1);\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass DisjointSet{\\npublic:\\n    vector<int>par,size;\\n    DisjointSet(int n){\\n        par.resize(n+1);\\n        size.resize(n+1,1);\\n        for(int i=0; i<=n; i++){\\n            par[i] = i;\\n        }\\n    }\\n    int findpar(int u){\\n        if(u == par[u]) return u;\\n        return par[u] = findpar(par[u]);\\n    }\\n\\n    void unionBySize(int u, int v){\\n        u = findpar(u);\\n        v = findpar(v);\\n\\n        if(u == v) return;\\n\\n        if(size[u] >= size[v]){\\n            par[v] = u;\\n            size[u] += size[v];\\n        }\\n        else{\\n            par[u] = v;\\n            size[v] += size[u];\\n        }\\n    }\\n    \\n};\\nclass Solution {\\npublic:\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        DisjointSet ds(n*m);\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                int p = i * m + j;\\n                int p1 = (i-1)*m + j;  // 1\\n                int p2 = (i+1)*m + j;  // 1\\n                int p3 = i*m + (j+1);  // 2\\n                int p4 = i*m + (j-1);  // 2\\n\\n                if(grid[i][j] == 1){\\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\\n                        ds.unionBySize(p,p3);\\n                    }\\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\\n                        ds.unionBySize(p,p4);\\n                    }\\n                }\\n                else if(grid[i][j] == 2){\\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\\n                        ds.unionBySize(p,p2);\\n                    }\\n\\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\\n                        ds.unionBySize(p,p1);\\n                    }\\n                }\\n                else if(grid[i][j] == 3){\\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\\n                        ds.unionBySize(p,p4);\\n                    }\\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\\n                        ds.unionBySize(p,p2);\\n                    }\\n                }\\n                else if(grid[i][j] == 4){\\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\\n                        ds.unionBySize(p,p3);\\n                    }\\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\\n                        ds.unionBySize(p,p2);\\n                    }\\n                }\\n                else if(grid[i][j] == 5){\\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\\n                        ds.unionBySize(p,p1);\\n                    }\\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\\n                        ds.unionBySize(p,p4);\\n                    }\\n                }\\n                else if(grid[i][j] == 6){\\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\\n                        ds.unionBySize(p,p1);\\n                    }\\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\\n                        ds.unionBySize(p,p3);\\n                    }\\n                }\\n            }\\n        }\\n        return ds.findpar(0) == ds.findpar(n*m-1);\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "== and = confusion",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass DisjointSet{\npublic:\n    vector<int>par,size;\n    DisjointSet(int n){\n        par.resize(n+1);\n        size.resize(n+1,1);\n        for(int i=0; i<=n; i++){\n            par[i] == i;\n        }\n    }\n    int findpar(int u){\n        if(u == par[u) return u;\n        return par[u] = findpar(par[u]);\n    }\n\n    void unionBySize(int u, int v){\n        u == findpar(u);\n        v == findpar(v);\n\n        if(u == v) return;\n\n        if(size[u] >= size[v]){\n            par[v] = u;\n            size[u] += size[v;\n        }\n        else{\n            par[u] = v;\n            size[v] += size[u];\n        }\n    }\n    \n};\nclass Solution {\npublic:\n    bool hasValidPath(vector<vector<int>>& grid) {\n        int n = grid.size();\n        int m = grid[0].size();\n        DisjointSet ds(n*m);\n        for(int i=0; i<n; i++){\n            for(int j=0; j<m; j++){\n                int p = i * m + j;\n                int p1 = (i-1)*m + j;  // 1\n                int p2 = (i+1)*m + j;  // 1\n                int p3 = i*m + (j+1);  // 2\n                int p4 = i*m + (j-1);  // 2\n\n                if(grid[i][j] == 1){\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\n                        ds.unionBySize(p,p3);\n                    }\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\n                        ds.unionBySize(p,p4);\n                    }\n                }\n                else if(grid[i][j] == 2){\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\n                        ds.unionBySize(p,p2);\n                    }\n\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\n                        ds.unionBySize(p,p1);\n                    }\n                }\n                else if(grid[i][j] == 3){\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\n                        ds.unionBySize(p,p4);\n                    }\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\n                        ds.unionBySize(p,p2);\n                    }\n                }\n                else if(grid[i][j] == 4){\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\n                        ds.unionBySize(p,p3);\n                    }\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\n                        ds.unionBySize(p,p2);\n                    }\n                }\n                else if(grid[i][j] == 5){\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\n                        ds.unionBySize(p,p1);\n                    }\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\n                        ds.unionBySize(p,p4);\n                    }\n                }\n                else if(grid[i][j] == 6){\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\n                        ds.unionBySize(p,p1);\n                    }\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\n                        ds.unionBySize(p,p3);\n                    }\n                }\n            }\n        }\n        return ds.findpar(0) == ds.findpar(n*m-1);\n    }\n};\n"
    },
    {
        "slug": "queries-on-number-of-points-inside-a-circle",
        "description": "You are given an array points where points[i] = [xi, yi] is the coordinates of the ith point on a 2D plane. Multiple points can have the same coordinates.\nYou are also given an array queries where queries[j] = [xj, yj, rj] describes a circle centered at (xj, yj) with a radius of rj.\nFor each query queries[j], compute the number of points inside the jth circle. Points on the border of the circle are considered inside.\nReturn an array answer, where answer[j] is the answer to the jth query.",
        "examples": [
            "Input: points = [[1,3],[3,3],[5,3],[2,2]], queries = [[2,3,1],[4,3,1],[1,1,2]]\nOutput: [3,2,2]\nExplanation: The points and circles are shown above.\nqueries[0] is the green circle, queries[1] is the red circle, and queries[2] is the blue circle.",
            "Input: points = [[1,1],[2,2],[3,3],[4,4],[5,5]], queries = [[1,2,2],[2,2,2],[4,3,2],[4,3,3]]\nOutput: [2,3,2,4]\nExplanation: The points and circles are shown above.\nqueries[0] is green, queries[1] is red, queries[2] is blue, and queries[3] is purple."
        ],
        "constraints": "1 <= points.length <= 500\npoints[i].length == 2\n0 <= x\u200b\u200b\u200b\u200b\u200b\u200bi, y\u200b\u200b\u200b\u200b\u200b\u200bi <= 500\n1 <= queries.length <= 500\nqueries[j].length == 3\n0 <= xj, yj <= 500\n1 <= rj <= 500\nAll coordinates are integers.",
        "oracle_code": "class Solution {\npublic:\n\n    bool Manhattan(int x1,int x2,int y1,int y2,int r){\n        int dist= pow((x2-x1),2) + pow((y2-y1),2);\n\n        if(dist<=r*r) return true;\n        return false;\n    }\n    vector<int> countPoints(vector<vector<int>>& points, vector<vector<int>>& queries) {\n\n        vector<int> ans;\n\n        for( auto c: queries){\n            int x1=c[0];\n            int y1=c[1];\n            int r=c[2];\n            int temp=0;\n            \n            for(auto i:points){\n                int x2=i[0];\n                int y2=i[1];\n\n                if(Manhattan(x1,x2,y1,y2,r)){\n                    temp++;\n                }\n\n            }\n\n            ans.push_back(temp);\n\n        }\n        return ans;\n\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool Manhattan(int x1,int x2,int y1,int y2,int r){\\n        int dist= pow((x2-x1),2) + pow((y2-y1),2);\\n\\n        if(dist<=r*r) return true;\\n        return false;\\n    }\\n    vector<int> countPoints(vector<vector<int>>& points, vector<vector<int>>& queries) {\\n\\n        vector<int> ans;\\n\\n        for( auto c: queries){\\n            int x1=c[0];\\n            int y1=c[1];\\n            int r=c[2];\\n            int temp=0;\\n            \\n            for(auto i:points){\\n                int x2=i[0];\\n                int y2=i[1];\\n\\n                if(Manhattan(x1,x2,y1,y2,r)){\\n                    temp++;\\n                }\\n\\n            }\\n\\n            ans.push_back(temp);\\n\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "operation error",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n\n    bool Manhattan(int x1,int x2,int y1,int y2,int r){\n        int dist= abs(x2-x1 + abs(y2-y1);\n\n        if(dist==r*r) return true;\n        return false;\n    }\n    vector<int> countPoints(vector<vector<int>>& points, vector<vector<int>>& queries) {\n        vector<int> ans;\n\n        for( auto c: queries){\n            int x1=c[0];\n            int y1=c[1];\n            int r=c[2];\n            int temp=0;\n            \n            for(auto i: points){\n                if(Manhattan(x1,i[0],y1,i[1],r)){\n                    temp++;\n                }\n\n                ans.push_back(temp);\n            }\n\n        }\n        return ans;\n    }\n};\n"
    },
    {
        "slug": "reverse-pairs",
        "description": "Given an integer array nums, return the number of reverse pairs in the array.\nA reverse pair is a pair (i, j) where:\n\n0 <= i < j < nums.length and\nnums[i] > 2 * nums[j].",
        "examples": [
            "Input: nums = [1,3,2,3,1]\nOutput: 2\nExplanation: The reverse pairs are:\n(1, 4) --> nums[1] = 3, nums[4] = 1, 3 > 2 * 1\n(3, 4) --> nums[3] = 3, nums[4] = 1, 3 > 2 * 1",
            "Input: nums = [2,4,3,5,1]\nOutput: 3\nExplanation: The reverse pairs are:\n(1, 4) --> nums[1] = 4, nums[4] = 1, 4 > 2 * 1\n(2, 4) --> nums[2] = 3, nums[4] = 1, 3 > 2 * 1\n(3, 4) --> nums[3] = 5, nums[4] = 1, 5 > 2 * 1"
        ],
        "constraints": "1 <= nums.length <= 5 * 104\n-231 <= nums[i] <= 231 - 1",
        "oracle_code": "class Solution {\npublic:\nvoid merge(vector<int>&arr,int low,int mid,int high,int &cnt){\n    int i=low,j=mid+1;\n    int r=j;\n    int c=0;\n    vector<int>v;\n     while(i<=mid){\n        while(r<=high and arr[i]>(long long)2*arr[r]){\n            c++;\n            r++;\n        }\n        cnt+=c;\n        \n          while(j<=high and arr[j]<=arr[i])v.push_back(arr[j++]);\n          v.push_back(arr[i++]);\n     }\n     while(j<=high)v.push_back(arr[j++]);\n     for(int i=low;i<=high;i++)arr[i]=v[i-low];\n}\n\n   void mergesort(vector<int>&arr,int low,int high,int &cnt){\n       if(low<high){\n      int mid=low+(high-low)/2;\n      mergesort(arr,low,mid,cnt);\n      mergesort(arr,mid+1,high,cnt);\n      merge(arr,low,mid,high,cnt);\n       }\n   }\n    int reversePairs(vector<int>& arr) {\n      // merge sort -> modified merge function \n    int cnt=0;\n    int n=arr.size();\n    mergesort(arr,0,n-1,cnt);\n    if(n<=1 or cnt==0)return 0;\n    return cnt;\n        \n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo get an intuition of merge sort u think basically we have to check how many elements are greater as per some condtion like inversions SO in these kind of problems merge sort can be used beacuase we comapre left subarray which is sorted to right subarray through that we can minimize time complexity beacuse we don\\'t need to chekc all combinations .. That is key thing about merge sort just like it makes  sorting in nlogn \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nJust Modified Merge sort only a change in merge function count as per condition rest is same\\n# Complexity\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nvoid merge(vector<int>&arr,int low,int mid,int high,int &cnt){\\n    int i=low,j=mid+1;\\n    int r=j;\\n    int c=0;\\n    vector<int>v;\\n     while(i<=mid){\\n        while(r<=high and arr[i]>(long long)2*arr[r]){\\n            c++;\\n            r++;\\n        }\\n        cnt+=c;\\n        \\n          while(j<=high and arr[j]<=arr[i])v.push_back(arr[j++]);\\n          v.push_back(arr[i++]);\\n     }\\n     while(j<=high)v.push_back(arr[j++]);\\n     for(int i=low;i<=high;i++)arr[i]=v[i-low];\\n}\\n\\n   void mergesort(vector<int>&arr,int low,int high,int &cnt){\\n       if(low<high){\\n      int mid=low+(high-low)/2;\\n      mergesort(arr,low,mid,cnt);\\n      mergesort(arr,mid+1,high,cnt);\\n      merge(arr,low,mid,high,cnt);\\n       }\\n   }\\n    int reversePairs(vector<int>& arr) {\\n      // merge sort -> modified merge function \\n    int cnt=0;\\n    int n=arr.size();\\n    mergesort(arr,0,n-1,cnt);\\n    if(n<=1 or cnt==0)return 0;\\n    return cnt;\\n        \\n    }\\n};\\n```",
        "level": "hard",
        "type": [
            "== and = confusion",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution {\npublic:\nvoid merge(vector<int>&arr,int low,int mid,int high,int &cnt){\n    int i=low,j=mid+1;\n    int r=j;\n    int c=0;\n    vector<int>v;\n     while(i<=mid){\n        while(r<=high and arr[i]>(long long)2*arr[r]){\n            c++;\n            r++;\n        }\n        cnt+=c;\n        \n          while(j<=r and arr[j]<=arr[i])v.push_back(arr[j++]);\n          v.push_back(arr[i++]);\n     }\n     while(j<=high)v.push_back(arr[j++]);\n     for(int i=low;i<=high;i++)arr[i]=v[i-low];\n}\n\n   void mergesort(vector<int>&arr,int low,int high,int &cnt){\n       if(low<high){\n      int mid=low+(high-low)/2;\n      mergesort(arr,low,mid,cnt);\n      mergesort(arr,mid+1,high,cnt);\n      merge(arr,low,mid,high,cnt);\n       }\n   }\n    int reversePairs(vector<int>& arr) {\n      // merge sort -> modified merge function \n    int cnt=0;\n    int n=arr.size();\n    mergesort(arr,0,n-1,cnt);\n    if(n<=1 or cnt=0)return 0;\n    return cnt;\n        \n    }\n};\n"
    },
    {
        "slug": "sort-an-array",
        "description": "Given an array of integers nums, sort the array in ascending order and return it.\nYou must solve the problem without using any built-in functions in O(nlog(n)) time complexity and with the smallest space complexity possible.",
        "examples": [
            "Input: nums = [5,2,3,1]\nOutput: [1,2,3,5]\nExplanation: After sorting the array, the positions of some numbers are not changed (for example, 2 and 3), while the positions of other numbers are changed (for example, 1 and 5).",
            "Input: nums = [5,1,1,2,0,0]\nOutput: [0,0,1,1,2,5]\nExplanation: Note that the values of nums are not necessairly unique."
        ],
        "constraints": "1 <= nums.length <= 5 * 104\n-5 * 104 <= nums[i] <= 5 * 104",
        "oracle_code": "class Solution {\npublic:\n    void merge(int low, int mid, int high, vector<int> &nums) {\n        if (low >= high) \n        return;\n        int l = low, r = mid + 1, k = 0, size = high - low + 1;\n        vector<int> sorted(size, 0);\n        while (l <= mid and r <= high)\n            sorted[k++] = nums[l] < nums[r] ? nums[l++] : nums[r++];\n        while (l <= mid) \n            sorted[k++] = nums[l++];\n        while (r <= high) \n            sorted[k++] = nums[r++];\n        for (k = 0; k < size; k++)\n            nums[k + low] = sorted[k];\n    }\n\n    void mergeSort(vector<int>& nums, int start, int end){\n        if(start < end){\n            int mid = start + (end - start) / 2;\n            mergeSort(nums, start, mid);\n            mergeSort(nums, mid + 1, end);\n            merge(start, mid, end, nums);\n        }\n    }\n\n    vector<int> sortArray(vector<int>& nums) {\n        mergeSort(nums, 0, nums.size()-1);\n        return nums;\n    }\n};",
        "content": "# Approach\\nThis is an implementation of the merge sort algorithm in C++. The merge sort algorithm uses a divide-and-conquer approach to sort a given array by recursively dividing the input array into two halves, sorting them separately, and then merging them back together in the correct order.\\n\\nThe merge function takes in four parameters: low, mid, high, and nums. low and high represent the indices of the start and end of the subarray that needs to be merged, respectively. mid represents the index of the middle element of the subarray. nums is a reference to the vector of integers that needs to be sorted.\\n\\nIn the merge function, a new vector sorted of size high - low + 1 is created to store the sorted subarray. The two halves of the subarray are then compared and merged into sorted using a while loop. Finally, the sorted subarray is copied back into the original array nums using a for loop.\\n\\nThe mergeSort function takes in three parameters: nums, start, and end. nums is a reference to the vector of integers that needs to be sorted. start and end represent the indices of the start and end of the subarray that needs to be sorted, respectively. In the mergeSort function, the input subarray is recursively divided into two halves using mid, and each half is sorted using the mergeSort function. The merge function is then called to merge the two sorted halves back together in the correct order.\\n\\nFinally, the sortArray function takes in a reference to the vector of integers that needs to be sorted and calls the mergeSort function to sort the entire array. It then returns the sorted array.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void merge(int low, int mid, int high, vector<int> &nums) {\\n        if (low >= high) \\n        return;\\n        int l = low, r = mid + 1, k = 0, size = high - low + 1;\\n        vector<int> sorted(size, 0);\\n        while (l <= mid and r <= high)\\n            sorted[k++] = nums[l] < nums[r] ? nums[l++] : nums[r++];\\n        while (l <= mid) \\n            sorted[k++] = nums[l++];\\n        while (r <= high) \\n            sorted[k++] = nums[r++];\\n        for (k = 0; k < size; k++)\\n            nums[k + low] = sorted[k];\\n    }\\n\\n    void mergeSort(vector<int>& nums, int start, int end){\\n        if(start < end){\\n            int mid = start + (end - start) / 2;\\n            mergeSort(nums, start, mid);\\n            mergeSort(nums, mid + 1, end);\\n            merge(start, mid, end, nums);\\n        }\\n    }\\n\\n    vector<int> sortArray(vector<int>& nums) {\\n        mergeSort(nums, 0, nums.size()-1);\\n        return nums;\\n    }\\n};",
        "level": "medium",
        "type": [
            "undefined keywords from other languages",
            "colon missing"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    void merge(int low, int mid, int high, Array<int> &nums) {\n        if (low >= high) \n        return;\n        int l = low, r = mid + 1, k = 0, size = high - low + 1;\n        Array<int> sorted(size, 0);\n        while (l <= mid and r <= high)\n            sorted[k++] = nums[l] < nums[r] ? nums[l++] : nums[r++];\n        while (l <= mid) \n            sorted[k++] = nums[l++];\n        while (r <= high) \n            sorted[k++] = nums[r++];\n        for (k = 0; k < size; k++)\n            nums[k + low] = sorted[k];\n    }\n\n    void mergeSort(Array<int>& nums, int start, int end){\n        if(start < end){\n            int mid = start + (end - start) / 2;\n            mergeSort(nums, start, mid);\n            mergeSort(nums, mid + 1, end);\n            merge(start, mid, end, nums);\n        }\n    }\n\n    Array<int> sortArray(Array<int>& nums) {\n        mergeSort(nums, 0, nums.size()-1);\n        return nums;\n    }\n};\n"
    },
    {
        "slug": "longest-common-prefix",
        "description": "Write a function to find the longest common prefix string amongst an array of strings.\nIf there is no common prefix, return an empty string \"\".",
        "examples": [
            "Input: strs = [\"flower\",\"flow\",\"flight\"]\nOutput: \"fl\"",
            "Input: strs = [\"dog\",\"racecar\",\"car\"]\nOutput: \"\"\nExplanation: There is no common prefix among the input strings."
        ],
        "constraints": "1 <= strs.length <= 200\n0 <= strs[i].length <= 200\nstrs[i] consists of only lowercase English letters.",
        "oracle_code": "class Solution {\npublic:\n    string longestCommonPrefix(vector<string>& str) \n    {\n        sort(str.begin(), str.end()); //sorting the array\n        string ans=\"\"; //creating a new empty string to store the common prefixes\n        for(int i=0;i<str[0].length();i++) // max iterations = length of the first string\n        {\n            if(str[0][i]!=str[str.size()-1][i]) // checking the characters of the first and last string\n                break;\n            ans+=str[0][i]; // concatinate if the characters are matching\n        }\n        return ans;\n    }\n};",
        "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWhen you sort an array, it is enough to check for the common characters of the the first & last string of the sorted vector.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& str) \\n    {\\n        sort(str.begin(), str.end()); //sorting the array\\n        string ans=\"\"; //creating a new empty string to store the common prefixes\\n        for(int i=0;i<str[0].length();i++) // max iterations = length of the first string\\n        {\\n            if(str[0][i]!=str[str.size()-1][i]) // checking the characters of the first and last string\\n                break;\\n            ans+=str[0][i]; // concatinate if the characters are matching\\n        }\\n        return ans;\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "unclosed string",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    string longestCommonPrefix(vector<string>& str) \n    {\n        sort(str.begin(), str.end()); //sorting the array\n        string ans=\"; \n        for(int i=0;i<str[0].length();i++) // max iterations = length of the first string\n        {\n            if(str[0][i]!=str[str.size()][i]) \n                break;\n            ans+=str[0][i]; // concatinate if the characters are matching\n        }\n        return ans;\n    }\n};\n"
    },
    {
        "slug": "best-time-to-buy-and-sell-stock-with-transaction-fee",
        "description": "You are given an array prices where prices[i] is the price of a given stock on the ith day, and an integer fee representing a transaction fee.\nFind the maximum profit you can achieve. You may complete as many transactions as you like, but you need to pay the transaction fee for each transaction.\nNote:\n\nYou may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\nThe transaction fee is only charged once for each stock purchase and sale.",
        "examples": [
            "Input: prices = [1,3,2,8,4,9], fee = 2\nOutput: 8\nExplanation: The maximum profit can be achieved by:\n- Buying at prices[0] = 1\n- Selling at prices[3] = 8\n- Buying at prices[4] = 4\n- Selling at prices[5] = 9\nThe total profit is ((8 - 1) - 2) + ((9 - 4) - 2) = 8.",
            "Input: prices = [1,3,7,5,10,3], fee = 3\nOutput: 6"
        ],
        "constraints": "1 <= prices.length <= 5 * 104\n1 <= prices[i] < 5 * 104\n0 <= fee < 5 * 104",
        "oracle_code": "class Solution {\npublic:\n    int maxProfit(vector<int>& prices, int fee) {\n        int n = prices.size();\n        if (n <= 1) return 0;\n        int buy = -prices[0];\n        int sell = 0;\n        for (int i = 1; i < n; i++) {\n            int prevBuy = buy;\n            buy = max(buy, sell - prices[i]);\n            sell = max(sell, prevBuy + prices[i] - fee);\n        }\n        return sell;\n    }\n};",
        "content": "# Intuition\\nTo solve this problem, we can use a dynamic programming approach. \\n\\n# Approach\\nThe idea is to maintain two variables, buy and sell, which represent the maximum profit you can achieve if you have bought or sold the stock, respectively. Initially, buy is set to the negative of the first price, assuming we buy the stock on the first day. sell is set to zero because we haven\\'t sold any stock yet.\\n\\nThen, for each day starting from the second day, we update buy and sell as follows:\\n\\n- Update buy by taking the maximum value between the previous buy and the difference between sell and the current price (representing the profit we would make if we bought the stock on this day).\\n- Update sell by taking the maximum value between the previous sell and the sum of the previous buy and the current price minus the transaction fee (representing the profit we would make if we sold the stock on this day).\\n\\nFinally, the maximum profit we can achieve is stored in the sell variable, so we return its value.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices, int fee) {\\n        int n = prices.size();\\n        if (n <= 1) return 0;\\n        int buy = -prices[0];\\n        int sell = 0;\\n        for (int i = 1; i < n; i++) {\\n            int prevBuy = buy;\\n            buy = max(buy, sell - prices[i]);\\n            sell = max(sell, prevBuy + prices[i] - fee);\\n        }\\n        return sell;\\n    }\\n};\\n\\n```",
        "level": "medium",
        "type": [
            "undefined keywords from other languages",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices, int fee) {\n        int n = prices.length;\n        if (n <= 1) return 0;\n        int buy = -prices[0;\n        int sell = 0;\n        for (int i = 1; i < n; i++) {\n            int prevBuy = buy;\n            buy = max(buy, sell - prices[i]);\n            sell = max(sell, prevBuy + prices[i] - fee);\n        }\n        return sell;\n    }\n};\n"
    },
    {
        "slug": "gray-code",
        "description": "An n-bit gray code sequence is a sequence of 2n integers where:\n\nEvery integer is in the inclusive range [0, 2n - 1],\nThe first integer is 0,\nAn integer appears no more than once in the sequence,\nThe binary representation of every pair of adjacent integers differs by exactly one bit, and\nThe binary representation of the first and last integers differs by exactly one bit.\n\nGiven an integer n, return any valid n-bit gray code sequence.",
        "examples": [
            "Input: n = 2\nOutput: [0,1,3,2]\nExplanation:\nThe binary representation of [0,1,3,2] is [00,01,11,10].\n- 00 and 01 differ by one bit\n- 01 and 11 differ by one bit\n- 11 and 10 differ by one bit\n- 10 and 00 differ by one bit\n[0,2,3,1] is also a valid gray code sequence, whose binary representation is [00,10,11,01].\n- 00 and 10 differ by one bit\n- 10 and 11 differ by one bit\n- 11 and 01 differ by one bit\n- 01 and 00 differ by one bit",
            "Input: n = 1\nOutput: [0,1]"
        ],
        "constraints": "1 <= n <= 16",
        "oracle_code": "class Solution {\npublic:\n    vector<int> grayCode(int n) {\n        vector<int> res;\n        res.push_back( 0 );\n        for( int k = 0; k<n; k++ ) {\n            int i = res.size(), t = (1<<k) ;\n            while( i ) {\n                int temp = res[--i] | t;\n                res.push_back( temp );\n            }\n        }\n        return res;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int> res;\\n        res.push_back( 0 );\\n        for( int k = 0; k<n; k++ ) {\\n            int i = res.size(), t = (1<<k) ;\\n            while( i ) {\\n                int temp = res[--i] | t;\\n                res.push_back( temp );\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "conditional statement error",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    vector<int> grayCode(int n) {\n        vector<int> res;\n        for( int k = 0; k<n; k++ ) {\n            int i = res.size(), t = (1<<k) ;\n            while( i ) {\n                int temp = res[--i] | t;\n                res.push_back( > 1 temp );\n            }\n        }\n        return res;\n    }\n};\n\n"
    },
    {
        "slug": "the-number-of-beautiful-subsets",
        "description": "You are given an array nums of positive integers and a positive integer k.\nA subset of nums is beautiful if it does not contain two integers with an absolute difference equal to k.\nReturn the number of non-empty beautiful subsets of the array nums.\nA subset of nums is an array that can be obtained by deleting some (possibly none) elements from nums. Two subsets are different if and only if the chosen indices to delete are different.",
        "examples": [
            "Input: nums = [2,4,6], k = 2\nOutput: 4\nExplanation: The beautiful subsets of the array nums are: [2], [4], [6], [2, 6].\nIt can be proved that there are only 4 beautiful subsets in the array [2,4,6].",
            "Input: nums = [1], k = 1\nOutput: 1\nExplanation: The beautiful subset of the array nums is [1].\nIt can be proved that there is only 1 beautiful subset in the array [1]."
        ],
        "constraints": "1 <= nums.length <= 20\n1 <= nums[i], k <= 1000",
        "oracle_code": "class Solution {\npublic:\n    int beautifulSubsets(vector<int>& nums, int k) {\n        vector<int> cur;\n        return helper(nums, k, cur, 0);\n    }\n    private:\n    int helper(vector<int>& nums, int k, vector<int>& cur, int start) {\n        int cnt = 0;\n        for (int i = start; i < nums.size(); ++i) {\n            if (!test(cur, nums[i], k))\n                continue;\n            cur.push_back(nums[i]);\n            cnt++;\n            cnt += helper(nums, k, cur, i + 1);\n            cur.pop_back();\n        }\n        return cnt;\n    }\n    bool test(vector<int>& cur, int num, int k) {\n        for (auto &c : cur)\n            if (abs(num - c) == k)\n                return false;\n        return true;\n    }\n};",
        "content": "\\n# Solution 1\\n```\\nclass Solution {\\npublic:\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        vector<int> cur;\\n        return helper(nums, k, cur, 0);\\n    }\\n    private:\\n    int helper(vector<int>& nums, int k, vector<int>& cur, int start) {\\n        int cnt = 0;\\n        for (int i = start; i < nums.size(); ++i) {\\n            if (!test(cur, nums[i], k))\\n                continue;\\n            cur.push_back(nums[i]);\\n            cnt++;\\n            cnt += helper(nums, k, cur, i + 1);\\n            cur.pop_back();\\n        }\\n        return cnt;\\n    }\\n    bool test(vector<int>& cur, int num, int k) {\\n        for (auto &c : cur)\\n            if (abs(num - c) == k)\\n                return false;\\n        return true;\\n    }\\n};\\n```\\n\\n# Solution2 : HashMap cur frequency\\n```\\nclass Solution {\\npublic:\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        unordered_map<int, int> cur;\\n        return helper(nums, k, cur, 0);\\n    }\\nprivate:\\n    int helper(vector<int>& nums, int k, unordered_map<int, int>& cur, int start) {\\n        int cnt = 0;\\n        for (int i = start; i < nums.size(); ++i) {\\n            if (cur[nums[i] - k] || cur[nums[i] + k])\\n                continue;\\n            cur[nums[i]]++;\\n            cnt += 1 + helper(nums, k, cur, i + 1);\\n            cur[nums[i]]--;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "statement separation",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    int beautifulSubsets(vector<int>& nums, int k) {\n        vector<int> cur;\n        return helper(nums, k, cur, 0);\n    }\n    private:\n    int helper(vector<int>& nums, int k, vector<int>& cur, int start) {\n        int cnt = 0;\n        for (int i = start; i <= nums.size(); ++i) {\n            if (!test(cur, nums[i], k))\n                continue\n            cur.push_back(nums[i]);\n            cnt++;\n            cnt += helper(nums, k, cur, i + 1);\n            cur.pop_back();\n        }\n        return cnt;\n    }\n    bool test(vector<int>& cur, int num, int k) {\n        for (auto &c : cur)\n            if (abs(num - c) == k)\n                return false;\n        return true;\n    }\n};\n"
    },
    {
        "slug": "shortest-subarray-to-be-removed-to-make-array-sorted",
        "description": "Given an integer array arr, remove a subarray (can be empty) from arr such that the remaining elements in arr are non-decreasing.\nReturn the length of the shortest subarray to remove.\nA subarray is a contiguous subsequence of the array.",
        "examples": [
            "Input: arr = [1,2,3,10,4,2,3,5]\nOutput: 3\nExplanation: The shortest subarray we can remove is [10,4,2] of length 3. The remaining elements after that will be [1,2,3,3,5] which are sorted.\nAnother correct solution is to remove the subarray [3,10,4].",
            "Input: arr = [5,4,3,2,1]\nOutput: 4\nExplanation: Since the array is strictly decreasing, we can only keep a single element. Therefore we need to remove a subarray of length 4, either [5,4,3,2] or [4,3,2,1].",
            "Input: arr = [1,2,3]\nOutput: 0\nExplanation: The array is already non-decreasing. We do not need to remove any elements."
        ],
        "constraints": "1 <= arr.length <= 105\n0 <= arr[i] <= 109",
        "oracle_code": "class Solution {\npublic:\n    int findLengthOfShortestSubarray(vector<int>& arr) {\n\n        int n =(int) arr.size();\n        int h = n-1 , l=0 ;\n        \n        \n        \n        for(int i=h;i>=1;i--)  \n        {\n            if(arr[i]>=arr[i-1] && h>0)\n            {\n                h--;\n            }\n            else break;\n        }\n\n        int res=h;\n\n       for( l=0 ; l<h && (l==0 || arr[l-1]<=arr[l])  ;l++)\n       {\n             \n             while(h<n && arr[l]>arr[h])\n              {\n                 h++;\n              }\n\n\n           res = min(res,h-l-1);\n\n        \n           \n       }\n      return res;\n\n        \n        \n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    int findLengthOfShortestSubarray(vector<int>& arr) {\\n\\n        int n =(int) arr.size();\\n        int h = n-1 , l=0 ;\\n        \\n        \\n        \\n        for(int i=h;i>=1;i--)  \\n        {\\n            if(arr[i]>=arr[i-1] && h>0)\\n            {\\n                h--;\\n            }\\n            else break;\\n        }\\n\\n        int res=h;\\n\\n       for( l=0 ; l<h && (l==0 || arr[l-1]<=arr[l])  ;l++)\\n       {\\n             \\n             while(h<n && arr[l]>arr[h])\\n              {\\n                 h++;\\n              }\\n\\n\\n           res = min(res,h-l-1);\\n\\n        \\n           \\n       }\\n      return res;\\n\\n        \\n        \\n    }\\n};\\n```\\n\\n```\\n\\n\\nclass Solution {\\npublic:\\n\\n    bool checker(vector<int> &arr,vector<int> &pref ,vector<int> &suff , int lo,int mid)\\n    {\\n        int n= (int)arr.size();\\n        bool ff =true;\\n        int hi = lo+mid-1;\\n        if(lo-1>=0 && pref[lo-1]==0) return false;\\n        if(hi+1<n && suff[hi+1]==0) return false;\\n        if(lo-1>=0 && hi+1<n && arr[lo-1]>arr[hi+1] ) return false;\\n        return true;\\n    }\\n    int findLengthOfShortestSubarray(vector<int>& arr) {\\n    \\n       int n = (int)arr.size();\\n       int ans=n;\\n       vector<int> pref(n,0),suff(n,0);\\n       pref[0]=1,suff[n-1]=1;\\n       for(int i=1;i<n;i++)\\n       {\\n           if(arr[i]>=arr[i-1] && pref[i-1]==1) pref[i]=1;\\n       }\\n\\n       for(int i=n-2;i>=0;i--)\\n       {\\n           if(arr[i]<=arr[i+1] && suff[i+1]==1) suff[i]=1;\\n       }\\n\\n       for(int i=0;i<n;i++)\\n       {\\n           int lo=0,hi=n;\\n           while(lo<=hi)\\n           {\\n               int mid = (lo+hi)/2;\\n               if(checker(arr,pref,suff,i,mid))\\n               {\\n                   ans = min(ans,mid);\\n                   hi =mid-1;\\n               }\\n               else lo = mid+1;\\n           }\\n       }\\n\\n       return ans;\\n    }\\n};\\n```\\n![4of9h0.jpg](https://assets.leetcode.com/users/images/d5a48e00-497f-4da5-b25d-ca6650410462_1678915207.8747983.jpeg)\\n\\n\\n```",
        "level": "medium",
        "type": [
            "statement separation",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    int findLengthOfShortestSubarray(vector<int>& arr) {\n\n        int n =(int) arr.size();\n        int h = n-1, l=0;\n        \n        for(int i=h;i>=1;i--)  \n        {\n            if(arr[i]>=arr[i-1] && h>0)\n            {\n                h--; break;\n            }\n            else break;\n        }\n\n        int res=h;\n\n        for(l=0 ; l<h && (l==0 || arr[l-1]<=arr[l]); l++)\n        {\n            while(h<n && arr[l]>arr[h])\n            {\n                h++;\n            }\n\n            res = myMin(res,h-l-1);\n       }\n       return res;\n    }\n};\n"
    },
    {
        "slug": "reverse-only-letters",
        "description": "Given a string s, reverse the string according to the following rules:\n\nAll the characters that are not English letters remain in the same position.\nAll the English letters (lowercase or uppercase) should be reversed.\n\nReturn s after reversing it.",
        "examples": [
            "Input: s = \"ab-cd\"\nOutput: \"dc-ba\"",
            "Input: s = \"a-bC-dEf-ghIj\"\nOutput: \"j-Ih-gfE-dCba\"",
            "Input: s = \"Test1ng-Leet=code-Q!\"\nOutput: \"Qedo1ct-eeLg=ntse-T!\""
        ],
        "constraints": "1 <= s.length <= 100\ns consists of characters with ASCII values in the range [33, 122].\ns does not contain '\\\"' or '\\\\'.",
        "oracle_code": "class Solution {\npublic:\n    string reverseOnlyLetters(string s) \n    {\n      int i=0,j=s.length()-1;\n      while(i<=j)\n      {\n        if(isalpha(s[i])&&isalpha(s[j]))\n        {\n            swap(s[i],s[j]);\n            i++;\n            j--;\n        }\n        else\n        {\n            if(!isalpha(s[i]))\n            {\n                i++;\n            }\n            if(!isalpha(s[j]))\n            {\n                j--;\n            }\n        }\n      }\n      return s;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string reverseOnlyLetters(string s) \\n    {\\n      int i=0,j=s.length()-1;\\n      while(i<=j)\\n      {\\n        if(isalpha(s[i])&&isalpha(s[j]))\\n        {\\n            swap(s[i],s[j]);\\n            i++;\\n            j--;\\n        }\\n        else\\n        {\\n            if(!isalpha(s[i]))\\n            {\\n                i++;\\n            }\\n            if(!isalpha(s[j]))\\n            {\\n                j--;\\n            }\\n        }\\n      }\\n      return s;\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "undefined keywords from other languages",
            "variable value error"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    str reverseOnlyLetters(string s) \n    {\n      int i=0,j=s.length()-1;\n      while(i<=j)\n      {\n        if(isalpha(s[i])&&isalpha(s[j]))\n        {\n            swap(s[i],s[j]);\n            i--;\n            j++;\n        }\n        else\n        {\n            if(!isalpha(s[i]))\n            {\n                i++;\n            }\n            if(!isalpha(s[j]))\n            {\n                j--;\n            }\n        }\n      }\n      return s;\n    }\n};\n"
    },
    {
        "slug": "find-peak-element",
        "description": "A peak element is an element that is strictly greater than its neighbors.\nGiven a 0-indexed integer array nums, find a peak element, and return its index. If the array contains multiple peaks, return the index to any of the peaks.\nYou may imagine that nums[-1] = nums[n] = -\u221e. In other words, an element is always considered to be strictly greater than a neighbor that is outside the array.\nYou must write an algorithm that runs in O(log n) time.",
        "examples": [
            "Input: nums = [1,2,3,1]\nOutput: 2\nExplanation: 3 is a peak element and your function should return the index number 2.",
            "Input: nums = [1,2,1,3,5,6,4]\nOutput: 5\nExplanation: Your function can return either index number 1 where the peak element is 2, or index number 5 where the peak element is 6."
        ],
        "constraints": "1 <= nums.length <= 1000\n-231 <= nums[i] <= 231 - 1\nnums[i] != nums[i + 1] for all valid i.",
        "oracle_code": "class Solution {\npublic:\n    int findPeakElement(vector<int>& nums) {\n    int n=nums.size();\n    if(n==1)\n    {\n      return 0;\n    } \n    if(nums[0]>nums[1])\n    {\n      return 0;\n    }\n    if(nums[n-1]>nums[n-2])\n    {\n      return n-1;\n    }\n    int left=1;\n    int right=n-2;\n    while(left<=right)\n    {\n      int mid=(left+right)/2;\n      if(nums[mid]>nums[mid-1]&& nums[mid]>nums[mid+1])\n      {\n        return mid;\n      }\n      else if(nums[mid]>nums[mid-1])\n      {\n        left=mid+1;\n      }\n      else{\n        right=mid-1;\n      }\n    }\nreturn -1;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n    int n=nums.size();\\n    if(n==1)\\n    {\\n      return 0;\\n    } \\n    if(nums[0]>nums[1])\\n    {\\n      return 0;\\n    }\\n    if(nums[n-1]>nums[n-2])\\n    {\\n      return n-1;\\n    }\\n    int left=1;\\n    int right=n-2;\\n    while(left<=right)\\n    {\\n      int mid=(left+right)/2;\\n      if(nums[mid]>nums[mid-1]&& nums[mid]>nums[mid+1])\\n      {\\n        return mid;\\n      }\\n      else if(nums[mid]>nums[mid-1])\\n      {\\n        left=mid+1;\\n      }\\n      else{\\n        right=mid-1;\\n      }\\n    }\\nreturn -1;\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "== and = confusion",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    int findPeakElement(vector<int>& nums) {\n    int n=nums.size();\n    if(n=1)\n    {\n      return 0;\n    } \n    if(nums[0]>nums[1])\n    {\n      return 0;\n    }\n    vector<int> emptyVector; \n    if(emptyVector[n-1]>emptyVector[n-2])\n    {\n      return n-1;\n    }\n    int left=1;\n    int right=n-2;\n    while(left<=right)\n    {\n      int mid=(left+right)/2;\n      if(nums[mid]>nums[mid-1]&& nums[mid]>nums[mid+1])\n      {\n        return mid;\n      }\n      else if(nums[mid]>nums[mid-1])\n      {\n        left=mid+1;\n      }\n      else{\n        right=mid-1;\n      }\n    }\nreturn -1;\n    }\n};\n"
    },
    {
        "slug": "minimum-number-of-swaps-to-make-the-string-balanced",
        "description": "You are given a 0-indexed string s of even length n. The string consists of exactly n / 2 opening brackets '[' and n / 2 closing brackets ']'.\nA string is called balanced if and only if:\n\nIt is the empty string, or\nIt can be written as AB, where both A and B are balanced strings, or\nIt can be written as [C], where C is a balanced string.\n\nYou may swap the brackets at any two indices any number of times.\nReturn the minimum number of swaps to make s balanced.",
        "examples": [
            "Input: s = \"][][\"\nOutput: 1\nExplanation: You can make the string balanced by swapping index 0 with index 3.\nThe resulting string is \"[[]]\".",
            "Input: s = \"]]][[[\"\nOutput: 2\nExplanation: You can do the following to make the string balanced:\n- Swap index 0 with index 4. s = \"[]][][\".\n- Swap index 1 with index 5. s = \"[[][]]\".\nThe resulting string is \"[[][]]\".",
            "Input: s = \"[]\"\nOutput: 0\nExplanation: The string is already balanced."
        ],
        "constraints": "n == s.length\n2 <= n <= 106\nn is even.\ns[i] is either '[' or ']'.\nThe number of opening brackets '[' equals n / 2, and the number of closing brackets ']' equals n / 2.",
        "oracle_code": "class Solution {\npublic:\n    int minSwaps(string s) {\n        int size=0;\n        for(char &ch:s){\n          if(ch=='[')  size++;\n          else if(size) size--;\n        }\n        return (size+1)/2;\n    }\n};",
        "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSwaps(string s) {\\n        int size=0;\\n        for(char &ch:s){\\n          if(ch==\\'[\\')  size++;\\n          else if(size) size--;\\n        }\\n        return (size+1)/2;\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "unclosed string",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    int minSwaps(string s);\n}; \n\nint Solution::maxSwaps(string s) {\n        int size=0;\n        for(char &ch:s){\n          if(ch=='[')  size++;\n          else if(size) size--;\n        }\n        return (size+1)/\"bug_string;\n    }\n\n"
    },
    {
        "slug": "closest-nodes-queries-in-a-binary-search-tree",
        "description": "You are given the root of a binary search tree and an array queries of size n consisting of positive integers.\nFind a 2D array answer of size n where answer[i] = [mini, maxi]:\n\nmini is the largest value in the tree that is smaller than or equal to queries[i]. If a such value does not exist, add -1 instead.\nmaxi is the smallest value in the tree that is greater than or equal to queries[i]. If a such value does not exist, add -1 instead.\n\nReturn the array answer.",
        "examples": [
            "Input: root = [6,2,13,1,4,9,15,null,null,null,null,null,null,14], queries = [2,5,16]\nOutput: [[2,2],[4,6],[15,-1]]\nExplanation: We answer the queries in the following way:\n- The largest number that is smaller or equal than 2 in the tree is 2, and the smallest number that is greater or equal than 2 is still 2. So the answer for the first query is [2,2].\n- The largest number that is smaller or equal than 5 in the tree is 4, and the smallest number that is greater or equal than 5 is 6. So the answer for the second query is [4,6].\n- The largest number that is smaller or equal than 16 in the tree is 15, and the smallest number that is greater or equal than 16 does not exist. So the answer for the third query is [15,-1].",
            "Input: root = [4,null,9], queries = [3]\nOutput: [[-1,4]]\nExplanation: The largest number that is smaller or equal to 3 in the tree does not exist, and the smallest number that is greater or equal to 3 is 4. So the answer for the query is [-1,4]."
        ],
        "constraints": "The number of nodes in the tree is in the range [2, 105].\n1 <= Node.val <= 106\nn == queries.length\n1 <= n <= 105\n1 <= queries[i] <= 106",
        "oracle_code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\n \nclass Solution {\npublic:\n        void dfs(TreeNode* root, vector<int>& bv){\n            if (root==NULL)return;\n            if (root->left)dfs(root->left,bv);\n            bv.push_back(root->val);\n            if (root->right)dfs(root->right,bv);\n        }\n\t\t\n        int min1(vector<int>& bv, int val){\n            int ans= -1;\n            int i=0; int j= bv.size()-1;\n            while (i<=j){\n                int mid= i+ (j-i)/2;\n                if (val== bv[mid])return val;\n                if (val> bv[mid]){\n                    ans= bv[mid];\n                    i= mid+1;\n                }\n                else j= mid-1;\n            }\n            return ans;\n        }\n\t\t\n    int max1(vector<int>& bv,int val){\n        int ans= -1;\n        int i=0; int j= bv.size()-1;\n        while (i<=j){\n            int mid= i+ (j-i)/2;\n            if (val== bv[mid])return val;\n            if (val < bv[mid]){\n                ans= bv[mid];\n                j= mid-1;\n            }\n            else i= mid+1;\n        }\n        return ans;\n    }\n\t\n        vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\n        vector<int> bv;\n        vector<vector<int>> ans;\n        //dfs se sorted list banate hai.\n        dfs(root,bv);\n        for (auto q: queries){\n            int lb= min1(bv,q);\n            int ub= max1(bv,q);\n            ans.push_back({lb,ub});\n        }\n        return ans;\n    }\n    \n};",
        "content": "Here is my C++ solution :-\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n \\nclass Solution {\\npublic:\\n        void dfs(TreeNode* root, vector<int>& bv){\\n            if (root==NULL)return;\\n            if (root->left)dfs(root->left,bv);\\n            bv.push_back(root->val);\\n            if (root->right)dfs(root->right,bv);\\n        }\\n\\t\\t\\n        int min1(vector<int>& bv, int val){\\n            int ans= -1;\\n            int i=0; int j= bv.size()-1;\\n            while (i<=j){\\n                int mid= i+ (j-i)/2;\\n                if (val== bv[mid])return val;\\n                if (val> bv[mid]){\\n                    ans= bv[mid];\\n                    i= mid+1;\\n                }\\n                else j= mid-1;\\n            }\\n            return ans;\\n        }\\n\\t\\t\\n    int max1(vector<int>& bv,int val){\\n        int ans= -1;\\n        int i=0; int j= bv.size()-1;\\n        while (i<=j){\\n            int mid= i+ (j-i)/2;\\n            if (val== bv[mid])return val;\\n            if (val < bv[mid]){\\n                ans= bv[mid];\\n                j= mid-1;\\n            }\\n            else i= mid+1;\\n        }\\n        return ans;\\n    }\\n\\t\\n        vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        vector<int> bv;\\n        vector<vector<int>> ans;\\n        //dfs se sorted list banate hai.\\n        dfs(root,bv);\\n        for (auto q: queries){\\n            int lb= min1(bv,q);\\n            int ub= max1(bv,q);\\n            ans.push_back({lb,ub});\\n        }\\n        return ans;\\n    }\\n    \\n};\\n```",
        "level": "medium",
        "type": [
            "undefined keywords from other languages",
            "parentheses mismatch"
        ],
        "buggy_code": "\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\n \nclass Solution {\npublic:\n        void dfs(TreeNode* root, List<int>& bv){\n            if (root==NULL)return;\n            if (root->left)dfs(root->left,bv;\n            bv.add(root->val);\n            if (root->right)dfs(root->right,bv);\n        }\n        \n        int min1(List<int>& bv, int val){\n            int ans= -1;\n            int i=0; int j= bv.size()-1;\n            while (i<=j){\n                int mid= i+ (j-i)/2;\n                if (val== bv[mid])return val;\n                if (val> bv[mid]){\n                    ans= bv[mid];\n                    i= mid+1;\n                }\n                else j= mid-1;\n            }\n            return ans;\n        }\n        \n    int max1(List<int>& bv,int val){\n        int ans= -1;\n        int i=0; int j= bv.size()-1;\n        while (i<=j){\n            int mid= i+ (j-i)/2;\n            if (val== bv[mid])return val;\n            if (val < bv[mid]){\n                ans= bv[mid];\n                j= mid-1;\n            }\n            else i= mid+1;\n        }\n        return ans;\n    }\n    \n        ArrayList<ArrayList<int>> closestNodes(TreeNode* root, List<int>& queries) {\n        List<int> bv;\n        ArrayList<ArrayList<int>> ans;\n        dfs(root, bv;\n        for (auto q: queries){\n            int lb= min1(bv,q);\n            int ub= max1(bv,q);\n            ans.add({lb,ub});\n        }\n        return ans;\n    }\n    \n};\n"
    },
    {
        "slug": "filter-restaurants-by-vegan-friendly-price-and-distance",
        "description": "Given the array restaurants where \u00a0restaurants[i] = [idi, ratingi, veganFriendlyi, pricei, distancei]. You have to filter the restaurants using three filters.\nThe veganFriendly filter will be either true (meaning you should only include restaurants with veganFriendlyi set to true)\u00a0or false\u00a0(meaning you can include any restaurant). In addition, you have the filters\u00a0maxPrice and maxDistance\u00a0which\u00a0are the maximum value for price and distance of restaurants you should consider respectively.\nReturn the array of restaurant IDs after filtering, ordered by rating from highest to lowest. For restaurants with the same rating, order them by id from highest to lowest. For simplicity veganFriendlyi and veganFriendly take value 1 when it is true, and 0 when it is false.",
        "examples": [
            "Input: restaurants = [[1,4,1,40,10],[2,8,0,50,5],[3,8,1,30,4],[4,10,0,10,3],[5,1,1,15,1]], veganFriendly = 1, maxPrice = 50, maxDistance = 10\nOutput: [3,1,5] \nExplanation: \nThe restaurants are:\nRestaurant 1 [id=1, rating=4, veganFriendly=1, price=40, distance=10]\nRestaurant 2 [id=2, rating=8, veganFriendly=0, price=50, distance=5]\nRestaurant 3 [id=3, rating=8, veganFriendly=1, price=30, distance=4]\nRestaurant 4 [id=4, rating=10, veganFriendly=0, price=10, distance=3]\nRestaurant 5 [id=5, rating=1, veganFriendly=1, price=15, distance=1] \nAfter filter restaurants with veganFriendly = 1, maxPrice = 50 and maxDistance = 10 we have restaurant 3, restaurant 1 and restaurant 5 (ordered by rating from highest to lowest).",
            "Input: restaurants = [[1,4,1,40,10],[2,8,0,50,5],[3,8,1,30,4],[4,10,0,10,3],[5,1,1,15,1]], veganFriendly = 0, maxPrice = 50, maxDistance = 10\nOutput: [4,3,2,1,5]\nExplanation: The restaurants are the same as in example 1, but in this case the filter veganFriendly = 0, therefore all restaurants are considered.",
            "Input: restaurants = [[1,4,1,40,10],[2,8,0,50,5],[3,8,1,30,4],[4,10,0,10,3],[5,1,1,15,1]], veganFriendly = 0, maxPrice = 30, maxDistance = 3\nOutput: [4,5]"
        ],
        "constraints": "1 <=\u00a0restaurants.length <= 10^4\nrestaurants[i].length == 5\n1 <=\u00a0idi, ratingi, pricei, distancei <= 10^5\n1 <=\u00a0maxPrice,\u00a0maxDistance <= 10^5\nveganFriendlyi and\u00a0veganFriendly\u00a0are\u00a00 or 1.\nAll idi are distinct.",
        "oracle_code": "class Solution {\npublic:\n    vector<int> filterRestaurants(vector<vector<int>>& restaurants, int veganFriendly, int maxPrice, int maxDistance) {\n        if(veganFriendly == 1){\n            for(int i = 0; i<restaurants.size(); i++){\n                if(restaurants[i][2] != veganFriendly){\n                    restaurants[i][0] = -1;\n                }\n            }\n        }\n\n        for(int i = 0; i<restaurants.size(); i++){\n            if(restaurants[i][3] > maxPrice){   \n                restaurants[i][0] = -1;\n            }\n            if(restaurants[i][4] > maxDistance){  \n                restaurants[i][0]=-1;\n            }\n        }\n\n        vector<int> id;\n        vector<int>rating;\n        for(int i=0; i<restaurants.size(); i++){\n            if(restaurants[i][0]>0){\n                id.push_back(restaurants[i][0]);\n                rating.push_back(restaurants[i][1]);\n            }\n            \n        }\n\n        for(int i=0; i<rating.size(); i++){\n            for(int j=i+1; j<rating.size(); j++){\n                if(rating[i] < rating[j]){\n                    swap(rating[i], rating[j]);\n                    swap(id[i], id[j]);\n                }\n            }\n        }\n\n        for(int i=0; i<rating.size(); i++){\n            for(int j=i+1; j<rating.size(); j++){\n                if(rating[i] == rating[j] && id[i] < id[j]){\n                    swap(id[i], id[j]);\n                }\n            }\n        }\n\n        return id;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> filterRestaurants(vector<vector<int>>& restaurants, int veganFriendly, int maxPrice, int maxDistance) {\\n        if(veganFriendly == 1){\\n            for(int i = 0; i<restaurants.size(); i++){\\n                if(restaurants[i][2] != veganFriendly){\\n                    restaurants[i][0] = -1;\\n                }\\n            }\\n        }\\n\\n        for(int i = 0; i<restaurants.size(); i++){\\n            if(restaurants[i][3] > maxPrice){   \\n                restaurants[i][0] = -1;\\n            }\\n            if(restaurants[i][4] > maxDistance){  \\n                restaurants[i][0]=-1;\\n            }\\n        }\\n\\n        vector<int> id;\\n        vector<int>rating;\\n        for(int i=0; i<restaurants.size(); i++){\\n            if(restaurants[i][0]>0){\\n                id.push_back(restaurants[i][0]);\\n                rating.push_back(restaurants[i][1]);\\n            }\\n            \\n        }\\n\\n        for(int i=0; i<rating.size(); i++){\\n            for(int j=i+1; j<rating.size(); j++){\\n                if(rating[i] < rating[j]){\\n                    swap(rating[i], rating[j]);\\n                    swap(id[i], id[j]);\\n                }\\n            }\\n        }\\n\\n        for(int i=0; i<rating.size(); i++){\\n            for(int j=i+1; j<rating.size(); j++){\\n                if(rating[i] == rating[j] && id[i] < id[j]){\\n                    swap(id[i], id[j]);\\n                }\\n            }\\n        }\\n\\n        return id;\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "statement separation",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    vector<int> filterRestaurants(vector<vector<int>>& restaurants, int veganFriendly, int maxPrice, int maxDistance) {\n        if(veganFriendly == 1);\n            for(int i = 0; i<restaurants.size(); i++){\n                if(restaurants[i][2] != veganFriendly){\n                    restaurants[i][0] = -1;\n                }\n            }\n\n        for(int i = 0; i<restaurants.size(); i++){\n            if(restaurants[i][3] > maxPrice){   \n                restaurants[i][0] = -1;\n            }\n            \n            if(restaurants[i][4] > maxDistance){  \n                restaurants[i][0]=-1;\n            }\n        }\n\n        vector<int> id;\n        for(int i=0; i<restaurants.size(); i++){\n            if(restaurants[i][0]>0){\n                id.push_back(restaurants[i][0]);\n            }\n            \n        }\n\n        vector<int>rating;\n        for(int i=0; i<restaurants.size(); i++){\n            if(restaurants[i][0]>0){\n                rating.push_back(restaurants[i][1]);\n            }\n            \n        }\n\n        for(int i=0; i<rating.size(); i++){\n            for(int j=i+1; j<rating.size(); j++){\n                if(rating[i] < rating[j]){\n                    swap(rating[i], rating[j]);\n                    swap(id[i], id[j]);\n                }\n            }\n        }\n\n        for(int i=0; i<rating.size(); i++){\n            for(int j=i+1; j<rating.size(); j++){\n                if(rating[i] == rating[j] && id[i] < id[j]){\n                    swap(id[i], id[j]);\n                }\n            }\n        }\n\n        vector<int> id_new(id.size());\n        return id_new;\n    }\n};\n"
    },
    {
        "slug": "rotate-array",
        "description": "Given an integer array nums, rotate the array to the right by k steps, where k is non-negative.",
        "examples": [
            "Input: nums = [1,2,3,4,5,6,7], k = 3\nOutput: [5,6,7,1,2,3,4]\nExplanation:\nrotate 1 steps to the right: [7,1,2,3,4,5,6]\nrotate 2 steps to the right: [6,7,1,2,3,4,5]\nrotate 3 steps to the right: [5,6,7,1,2,3,4]",
            "Input: nums = [-1,-100,3,99], k = 2\nOutput: [3,99,-1,-100]\nExplanation: \nrotate 1 steps to the right: [99,-1,-100,3]\nrotate 2 steps to the right: [3,99,-1,-100]"
        ],
        "constraints": "1 <= nums.length <= 105\n-231 <= nums[i] <= 231 - 1\n0 <= k <= 105",
        "oracle_code": "class Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        int n=nums.size();\n        vector<int> temp(nums.size());\n        for(int i=0;i<n;i++){\n            temp[(i+k)%n]=nums[i];\n        }\n        nums=temp;\n    }\n};",
        "content": "# Approach\\nhere i is of loop which starts form (0,1,2...) k is the value how many times you want to rotate and n is the size of first vector ,and after that new indexes will be generated in our temp vector and we have to put values of nums vector at new indexes . . . \\nlike for first  arr[1,2,3,4,5,6,7]  and k=3     so ,\\ntemp[0 + 3 % 7]=nums[i]\\ntemp[3 % 7]=nums[i]\\ntemp[3] = nums[i]\\n[_ , _ , _ , 1 , _ ,_ , _ ]\\nfor next ,\\ntemp[1 + 3 % 7]=nums[i]\\ntemp[4 % 7]=nums[i]\\ntemp[4] = nums[i]\\n[_ , _ , _ , 1 , 2 ,_ , _ ]   and so on \\ni hope you understand ..\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int> temp(nums.size());\\n        for(int i=0;i<n;i++){\\n            temp[(i+k)%n]=nums[i];\\n        }\\n        nums=temp;\\n    }\\n};\\n```\\n![upvote 1.jpeg](https://assets.leetcode.com/users/images/565d5fa5-1370-44d9-a6b6-0cf06d575aae_1681731352.2608747.jpeg)\\n",
        "level": "medium",
        "type": [
            "colon missing",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        int n=nums.size();\n        vector<int> temp(nums.size();\n        for(int i=0;i<n;i++);\n        {\n            temp[(i+k)%n]=nums[i];\n        }\n        nums=temp;\n    }\n};\n"
    },
    {
        "slug": "relative-ranks",
        "description": "You are given an integer array score of size n, where score[i] is the score of the ith athlete in a competition. All the scores are guaranteed to be unique.\nThe athletes are placed based on their scores, where the 1st place athlete has the highest score, the 2nd place athlete has the 2nd highest score, and so on. The placement of each athlete determines their rank:\n\nThe 1st place athlete's rank is \"Gold Medal\".\nThe 2nd place athlete's rank is \"Silver Medal\".\nThe 3rd place athlete's rank is \"Bronze Medal\".\nFor the 4th place to the nth place athlete, their rank is their placement number (i.e., the xth place athlete's rank is \"x\").\n\nReturn an array answer of size n where answer[i] is the rank of the ith athlete.",
        "examples": [
            "Input: score = [5,4,3,2,1]\nOutput: [\"Gold Medal\",\"Silver Medal\",\"Bronze Medal\",\"4\",\"5\"]\nExplanation: The placements are [1st, 2nd, 3rd, 4th, 5th].",
            "Input: score = [10,3,8,9,4]\nOutput: [\"Gold Medal\",\"5\",\"Bronze Medal\",\"Silver Medal\",\"4\"]\nExplanation: The placements are [1st, 5th, 3rd, 2nd, 4th]."
        ],
        "constraints": "n == score.length\n1 <= n <= 104\n0 <= score[i] <= 106\nAll the values in score are unique.",
        "oracle_code": "class Solution {\npublic:\n    vector<string> findRelativeRanks(vector<int>& score) {\n        int n = score.size();\n        \n        vector<pair<int, int>> arr;\n        for (int i=0; i<n; i++) arr.push_back({score[i], i});\n\n        sort(rbegin(arr), rend(arr));\n\n        vector<string> res(n);\n        for (int i=0; i<n; i++) \n            res[arr[i].second] = i==0? \"Gold Medal\": (i==1? \"Silver Medal\": (i==2? \"Bronze Medal\": to_string(i+1)));\n\n        return res;\n    }\n};",
        "content": "**vector solution**\\n```\\nclass Solution {\\npublic:\\n    vector<string> findRelativeRanks(vector<int>& score) {\\n        int n = score.size();\\n        \\n        vector<pair<int, int>> arr;\\n        for (int i=0; i<n; i++) arr.push_back({score[i], i});\\n\\n        sort(rbegin(arr), rend(arr));\\n\\n        vector<string> res(n);\\n        for (int i=0; i<n; i++) \\n            res[arr[i].second] = i==0? \"Gold Medal\": (i==1? \"Silver Medal\": (i==2? \"Bronze Medal\": to_string(i+1)));\\n\\n        return res;\\n    }\\n};\\n```\\n---\\n**priority queue solution**\\n```\\nclass Solution {\\npublic:\\n    vector<string> findRelativeRanks(vector<int>& score) {\\n        int n = score.size();\\n        \\n        priority_queue< pair<int, int>, vector<pair<int,int>> > pq;\\n        for (int i=0; i<n; i++) pq.push({score[i], i});\\n\\n        vector<string> res(n);\\n        while (!pq.empty()) {\\n            auto x = pq.top();\\n            int size = pq.size();\\n            res[x.second] = (size == n? \"Gold Medal\": (size == n-1? \"Silver Medal\": (size == n-2? \"Bronze Medal\": to_string(n-size+1))));\\n            pq.pop();\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "other error",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    vector<string> findRelativeRanks(vector<int>& score) {\n        int n = score.size();\n        \n        vector<pair<int, int>> arr;\n        for (int i=0; i<n; i++) arr.push_back({score[i], i});\n\n        sort(rbegin(arr), rend(arr));\n\n        vector<string> res(n);\n        for (int i=0; i<n; i++) \n            res[arr[i].second] = i==0? \"Gold Medal\": (i==1? \"Silver Medal\": (i==2? \"Bronze Medal\": to_string(i+1)));\n\n        res[arr[0].second] = \"LeanBack Medal\";\n        return Report(res);\n    }\n\n    vector<string> Report(vector<string>& res) {\n        vector<string> result;\n        for(int i=0; i<res.size(); i++) \n            result.push_back(\"Rank \" + to_string(i+1) + \": \" + res[i]);\n\n        return result;\n    }\n};\n"
    },
    {
        "slug": "find-the-winner-of-the-circular-game",
        "description": "There are n friends that are playing a game. The friends are sitting in a circle and are numbered from 1 to n in clockwise order. More formally, moving clockwise from the ith friend brings you to the (i+1)th friend for 1 <= i < n, and moving clockwise from the nth friend brings you to the 1st friend.\nThe rules of the game are as follows:\n\nStart at the 1st friend.\nCount the next k friends in the clockwise direction including the friend you started at. The counting wraps around the circle and may count some friends more than once.\nThe last friend you counted leaves the circle and loses the game.\nIf there is still more than one friend in the circle, go back to step 2 starting from the friend immediately clockwise of the friend who just lost and repeat.\nElse, the last friend in the circle wins the game.\n\nGiven the number of friends, n, and an integer k, return the winner of the game.",
        "examples": [
            "Input: n = 5, k = 2\nOutput: 3\nExplanation: Here are the steps of the game:\n1) Start at friend 1.\n2) Count 2 friends clockwise, which are friends 1 and 2.\n3) Friend 2 leaves the circle. Next start is friend 3.\n4) Count 2 friends clockwise, which are friends 3 and 4.\n5) Friend 4 leaves the circle. Next start is friend 5.\n6) Count 2 friends clockwise, which are friends 5 and 1.\n7) Friend 1 leaves the circle. Next start is friend 3.\n8) Count 2 friends clockwise, which are friends 3 and 5.\n9) Friend 5 leaves the circle. Only friend 3 is left, so they are the winner.",
            "Input: n = 6, k = 5\nOutput: 1\nExplanation: The friends leave in this order: 5, 4, 6, 2, 3. The winner is friend 1."
        ],
        "constraints": "1 <= k <= n <= 500",
        "oracle_code": "class Solution {\npublic:\n    int findTheWinner(int n, int k) {\n        queue<int> q;\n        for(int i=1;i<=n;i++){\n            q.push(i);\n        }\n        // 1 2 3 4 5 \n        while(q.size() != 1){\n            int i = 1;\n            while(i < k){\n                int f = q.front();\n                q.pop();\n                q.push(f);\n                i++;\n            }\n            q.pop();\n        }\n\n        return q.front();\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        queue<int> q;\\n        for(int i=1;i<=n;i++){\\n            q.push(i);\\n        }\\n        // 1 2 3 4 5 \\n        while(q.size() != 1){\\n            int i = 1;\\n            while(i < k){\\n                int f = q.front();\\n                q.pop();\\n                q.push(f);\\n                i++;\\n            }\\n            q.pop();\\n        }\\n\\n        return q.front();\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "variable value error",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    int findTheWinner(int n, int k) {\n        queue<int> q;\n        for(int i=1;i<=n;i++){\n            q.push(i;\n        }\n        // 1 2 3 4 5 \n        while(q.size() != 1){\n            int i = 0;\n            while(i < k){\n                int f = q.front();\n                q.pop();\n                q.push(f);\n                i++;\n            }\n            q.pop();\n        }\n\n        return q.front();\n    }\n};\n"
    },
    {
        "slug": "apply-operations-to-an-array",
        "description": "You are given a 0-indexed array nums of size n consisting of non-negative integers.\nYou need to apply n - 1 operations to this array where, in the ith operation (0-indexed), you will apply the following on the ith element of nums:\n\nIf nums[i] == nums[i + 1], then multiply nums[i] by 2 and set nums[i + 1] to 0. Otherwise, you skip this operation.\n\nAfter performing all the operations, shift all the 0's to the end of the array.\n\nFor example, the array [1,0,2,0,0,1] after shifting all its 0's to the end, is [1,2,1,0,0,0].\n\nReturn the resulting array.\nNote that the operations are applied sequentially, not all at once.",
        "examples": [
            "Input: nums = [1,2,2,1,1,0]\nOutput: [1,4,2,0,0,0]\nExplanation: We do the following operations:\n- i = 0: nums[0] and nums[1] are not equal, so we skip this operation.\n- i = 1: nums[1] and nums[2] are equal, we multiply nums[1] by 2 and change nums[2] to 0. The array becomes [1,4,0,1,1,0].\n- i = 2: nums[2] and nums[3] are not equal, so we skip this operation.\n- i = 3: nums[3] and nums[4] are equal, we multiply nums[3] by 2 and change nums[4] to 0. The array becomes [1,4,0,2,0,0].\n- i = 4: nums[4] and nums[5] are equal, we multiply nums[4] by 2 and change nums[5] to 0. The array becomes [1,4,0,2,0,0].\nAfter that, we shift the 0's to the end, which gives the array [1,4,2,0,0,0].",
            "Input: nums = [0,1]\nOutput: [1,0]\nExplanation: No operation can be applied, we just shift the 0 to the end."
        ],
        "constraints": "2 <= nums.length <= 2000\n0 <= nums[i] <= 1000",
        "oracle_code": "class Solution {\npublic:\n    vector<int> applyOperations(vector<int>& nums) {\n        for(int i =0 ;i<nums.size()-1;i++){\n            if(nums[i] == nums[i+1]){\n                nums[i] *=2;\n                nums[i+1] = 0;\n            }\n        };\n        vector<int> ans;\n        for(auto ele:nums){\n            if(ele!=0)ans.push_back(ele);\n        };\n        for(auto ele:nums){\n            if(ele == 0)ans.push_back(ele);\n        };\n        return ans;\n    }\n};",
        "content": "\\n```\\nclass Solution {\\npublic:\\n    vector<int> applyOperations(vector<int>& nums) {\\n        for(int i =0 ;i<nums.size()-1;i++){\\n            if(nums[i] == nums[i+1]){\\n                nums[i] *=2;\\n                nums[i+1] = 0;\\n            }\\n        };\\n        vector<int> ans;\\n        for(auto ele:nums){\\n            if(ele!=0)ans.push_back(ele);\\n        };\\n        for(auto ele:nums){\\n            if(ele == 0)ans.push_back(ele);\\n        };\\n        return ans;\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "== and = confusion",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    vector<int> applyOperations(vector<int>& nums) {\n        for(int i =0 ;i<nums.size();i++){\n            if(nums[i] = nums[i+1]){\n                nums[i] *=2;\n                nums[i+1] = 0;\n            }\n        };\n        vector<int> ans;\n        for(auto ele:nums){\n            if(ele!=0)ans.push_back(ele);\n        };\n        for(auto ele:nums){\n            if(ele == 0)ans.push_back(ele);\n        };\n        return ans;\n    }\n};\n"
    },
    {
        "slug": "search-insert-position",
        "description": "Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.\nYou must\u00a0write an algorithm with\u00a0O(log n) runtime complexity.",
        "examples": [
            "Input: nums = [1,3,5,6], target = 5\nOutput: 2",
            "Input: nums = [1,3,5,6], target = 2\nOutput: 1",
            "Input: nums = [1,3,5,6], target = 7\nOutput: 4"
        ],
        "constraints": "1 <= nums.length <= 104\n-104 <= nums[i] <= 104\nnums contains distinct values sorted in ascending order.\n-104 <= target <= 104",
        "oracle_code": "class Solution {\npublic:\n    int searchInsert(vector<int>& nums, int target) {\n        int l=0;\n        int r=nums.size()-1;\n        int m;\n        while(l<=r){\n            m=(l+r)/2;\n            if(nums[m]==target){\n                return m;\n            }else if(nums[m]>target){\n                r=m-1;\n            }\n            else{\n                l=m+1;\n            }\n        }\n        return l;\n    }\n};",
        "content": "# Complexity\\n- Time complexity: O(log(n)) -> Binary Search\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        int l=0;\\n        int r=nums.size()-1;\\n        int m;\\n        while(l<=r){\\n            m=(l+r)/2;\\n            if(nums[m]==target){\\n                return m;\\n            }else if(nums[m]>target){\\n                r=m-1;\\n            }\\n            else{\\n                l=m+1;\\n            }\\n        }\\n        return l;\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "== and = confusion",
            "variable value error"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    int searchInsert(vector<int>& nums, int target) {\n        int l=0;\n        int r=nums.size()-1;\n        int m;\n        while(l<=r){\n            m=(l+r)/2;\n            if(nums[m]=target){\n                return m;\n            }else if(nums[m]>target){\n                r=m;\n            }\n            else{\n                l=m;\n            }\n        }\n        return l;\n    }\n};\n"
    },
    {
        "slug": "array-partition",
        "description": "Given an integer array nums of 2n integers, group these integers into n pairs (a1, b1), (a2, b2), ..., (an, bn) such that the sum of min(ai, bi) for all i is maximized. Return the maximized sum.",
        "examples": [
            "Input: nums = [1,4,3,2]\nOutput: 4\nExplanation: All possible pairings (ignoring the ordering of elements) are:\n1. (1, 4), (2, 3) -> min(1, 4) + min(2, 3) = 1 + 2 = 3\n2. (1, 3), (2, 4) -> min(1, 3) + min(2, 4) = 1 + 2 = 3\n3. (1, 2), (3, 4) -> min(1, 2) + min(3, 4) = 1 + 3 = 4\nSo the maximum possible sum is 4.",
            "Input: nums = [6,2,6,5,1,2]\nOutput: 9\nExplanation: The optimal pairing is (2, 1), (2, 5), (6, 6). min(2, 1) + min(2, 5) + min(6, 6) = 1 + 2 + 6 = 9."
        ],
        "constraints": "1 <= n <= 104\nnums.length == 2 * n\n-104 <= nums[i] <= 104",
        "oracle_code": "class Solution {\npublic:\n    int arrayPairSum(vector<int>& nums) {\n        sort(nums.begin(),nums.end());\n        int sum=0;\n        for(int i=0;i<nums.size();i+=2)\n            sum+=nums[i];\n        return sum;\n    }\n};",
        "content": "# Intuition\\n  To maximise sum, ***try to group larger number together***-the only way   to do so is by sorting.\\n# Approach\\n 1. Sort the given vector.\\n\\n 2. Sum first number i.e min from a pair - to do so *increment counter by 2*, by doing so you will always lend into smallest number of a pair \\n# Complexity\\n- Time complexity: O(NlogN)\\n\\n- Space complexity: O(1)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int arrayPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int sum=0;\\n        for(int i=0;i<nums.size();i+=2)\\n            sum+=nums[i];\\n        return sum;\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "conditional statement error",
            "colon missing"
        ],
        "buggy_code": "\nclass Solution {\npublic\n    int arrayPairSum(vector<int>& nums) {\n        sort(nums.begin(),nums.end());\n        int sum=0;\n        for(int i=0;i<nums.size();i++)\n            sum+=nums[i];\n        return sum;\n    }\n};\n"
    },
    {
        "slug": "shortest-path-to-get-all-keys",
        "description": "You are given an m x n grid grid where:\n\n'.' is an empty cell.\n'#' is a wall.\n'@' is the starting point.\nLowercase letters represent keys.\nUppercase letters represent locks.\n\nYou start at the starting point and one move consists of walking one space in one of the four cardinal directions. You cannot walk outside the grid, or walk into a wall.\nIf you walk over a key, you can pick it up and you cannot walk over a lock unless you have its corresponding key.\nFor some 1 <= k <= 6, there is exactly one lowercase and one uppercase letter of the first k letters of the English alphabet in the grid. This means that there is exactly one key for each lock, and one lock for each key; and also that the letters used to represent the keys and locks were chosen in the same order as the English alphabet.\nReturn the lowest number of moves to acquire all keys. If it is impossible, return -1.",
        "examples": [
            "Input: grid = [\"@.a..\",\"###.#\",\"b.A.B\"]\nOutput: 8\nExplanation: Note that the goal is to obtain all the keys not to open all the locks.",
            "Input: grid = [\"@..aA\",\"..B#.\",\"....b\"]\nOutput: 6",
            "Input: grid = [\"@Aa\"]\nOutput: -1"
        ],
        "constraints": "m == grid.length\nn == grid[i].length\n1 <= m, n <= 30\ngrid[i][j] is either an English letter, '.', '#', or '@'.\u00a0\nThere is exactly one\u00a0'@'\u00a0in the grid.\nThe number of keys in the grid is in the range [1, 6].\nEach key in the grid is unique.\nEach key in the grid has a matching lock.",
        "oracle_code": "class Solution {\npublic:\n    using int2 = pair<int, int>;\n\n    int shortestPathAllKeys(vector<string>& grid) {\n        int n = grid.size();\n        int m = grid[0].size();\n\n        int2 start;\n        // Scan the start and KeyMask\n        int KeyMask = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                char c = grid[i][j];\n                int2 pos = {i, j};\n                if (c == '@')\n                    start = pos;  // Store the position of the starting point\n                if ('a' <= c && c <= 'z')\n                    KeyMask |= (1 << (c - 'a'));  // Set the corresponding bit in KeyMask for each key found\n            }\n        }\n        // Record the visiting status for every key status\n        vector<vector<vector<bool>>> \n        visit(n, vector<vector<bool>>(m, vector<bool>(KeyMask+1, 0)));\n\n        // [i, j, key state, distance]\n        queue<tuple<int, int, int, int>> q;\n        auto [i0, j0] = start;\n        q.push({i0, j0, 0, 0});  // Push the starting point with initial key state and distance 0\n\n        while (!q.empty()) {\n            auto [i, j, keyState, distance] = q.front();  // Extract current position, key state, and distance from the front of the queue\n            q.pop();\n            vector<int2> adj = {{i + 1, j}, {i, j + 1}, {i - 1, j}, {i, j - 1}};\n            for (auto [a, b] : adj) {\n                if (a < 0 || a >= n || b < 0 || b >= m || grid[a][b] == '#')\n                    continue;  // Skip if the next position is out of bounds or a wall ('#')\n                char c = grid[a][b];\n                // c is a key\n                if ('a' <= c && c <= 'z') {\n                    int keyIdx = c - 'a';  // Calculate the index of the key\n                    int newState = keyState | (1 << keyIdx);  // Update the key state by setting the corresponding bit\n                    if (visit[a][b][newState]) continue;  // Skip if this key state has been visited before at this position\n                    visit[a][b][newState] = 1;  // Mark the current key state as visited at this position\n                    if (newState == KeyMask) return distance + 1;  // If all keys are collected, return the distance\n                    q.push({a, b, newState, distance + 1});  // Push the next position with updated key state and increased distance\n                }\n                // c is a lock\n                else if ('A' <= c && c <= 'F') {\n                    int lockIdx = c - 'A';  // Calculate the index of the lock\n                    if ((keyState & (1 << lockIdx)) == 0) continue;  // Skip if the corresponding key for the lock is missing\n                    if (visit[a][b][keyState]) continue;  // Skip if this key state has been visited before at this position\n                    visit[a][b][keyState] = 1;  // Mark the current key state as visited at this position\n                    q.push({a, b, keyState, distance + 1});  // Push the next position with the same key state and increased distance\n                }\n                // c is ',' or '@'\n                else if (visit[a][b][keyState])\n                    continue;  // Skip if this key state has been visited before at this position\n\n                visit[a][b][keyState] = 1;  // Mark the current key state as visited at this position\n                q.push({a, b, keyState, distance + 1});  // Push the next position with the same key state and increased distance\n            }\n        }\n\n        return -1;  // If all keys cannot be collected, return -1\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nC++ code solves the problem of finding the shortest path to collect all keys in a grid. It uses a BFS approach to explore the grid. It initializes the start position and a bitmask to track collected keys. \\n \\nIt checks if the position contains a key or a lock and updates the key state accordingly. It also keeps track of visited positions with different key states to avoid revisiting them. If all keys are collected, it returns the shortest distance. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThere are at most $2^6=64$ key states, not a large amount. In this case, using the boolean array is faster than using the hash tables.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$O(m\\u22C5n\\u22C52^k)$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$O(m\\u22C5n\\u22C52^k)$\\n# Code with Explanation in comments\\n```\\nclass Solution {\\npublic:\\n    using int2 = pair<int, int>;\\n\\n    int shortestPathAllKeys(vector<string>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n\\n        int2 start;\\n        // Scan the start and KeyMask\\n        int KeyMask = 0;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                char c = grid[i][j];\\n                int2 pos = {i, j};\\n                if (c == \\'@\\')\\n                    start = pos;  // Store the position of the starting point\\n                if (\\'a\\' <= c && c <= \\'z\\')\\n                    KeyMask |= (1 << (c - \\'a\\'));  // Set the corresponding bit in KeyMask for each key found\\n            }\\n        }\\n        // Record the visiting status for every key status\\n        vector<vector<vector<bool>>> \\n        visit(n, vector<vector<bool>>(m, vector<bool>(KeyMask+1, 0)));\\n\\n        // [i, j, key state, distance]\\n        queue<tuple<int, int, int, int>> q;\\n        auto [i0, j0] = start;\\n        q.push({i0, j0, 0, 0});  // Push the starting point with initial key state and distance 0\\n\\n        while (!q.empty()) {\\n            auto [i, j, keyState, distance] = q.front();  // Extract current position, key state, and distance from the front of the queue\\n            q.pop();\\n            vector<int2> adj = {{i + 1, j}, {i, j + 1}, {i - 1, j}, {i, j - 1}};\\n            for (auto [a, b] : adj) {\\n                if (a < 0 || a >= n || b < 0 || b >= m || grid[a][b] == \\'#\\')\\n                    continue;  // Skip if the next position is out of bounds or a wall (\\'#\\')\\n                char c = grid[a][b];\\n                // c is a key\\n                if (\\'a\\' <= c && c <= \\'z\\') {\\n                    int keyIdx = c - \\'a\\';  // Calculate the index of the key\\n                    int newState = keyState | (1 << keyIdx);  // Update the key state by setting the corresponding bit\\n                    if (visit[a][b][newState]) continue;  // Skip if this key state has been visited before at this position\\n                    visit[a][b][newState] = 1;  // Mark the current key state as visited at this position\\n                    if (newState == KeyMask) return distance + 1;  // If all keys are collected, return the distance\\n                    q.push({a, b, newState, distance + 1});  // Push the next position with updated key state and increased distance\\n                }\\n                // c is a lock\\n                else if (\\'A\\' <= c && c <= \\'F\\') {\\n                    int lockIdx = c - \\'A\\';  // Calculate the index of the lock\\n                    if ((keyState & (1 << lockIdx)) == 0) continue;  // Skip if the corresponding key for the lock is missing\\n                    if (visit[a][b][keyState]) continue;  // Skip if this key state has been visited before at this position\\n                    visit[a][b][keyState] = 1;  // Mark the current key state as visited at this position\\n                    q.push({a, b, keyState, distance + 1});  // Push the next position with the same key state and increased distance\\n                }\\n                // c is \\',\\' or \\'@\\'\\n                else if (visit[a][b][keyState])\\n                    continue;  // Skip if this key state has been visited before at this position\\n\\n                visit[a][b][keyState] = 1;  // Mark the current key state as visited at this position\\n                q.push({a, b, keyState, distance + 1});  // Push the next position with the same key state and increased distance\\n            }\\n        }\\n\\n        return -1;  // If all keys cannot be collected, return -1\\n    }\\n};\\n\\n\\n```",
        "level": "hard",
        "type": [
            "indexing error",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    using int2 = pair<int, int>;\n\n    int shortestPathAllKeys(vector<string>& grid) {\n        int n = grid.size();\n        int m = grid[0].size();\n\n        int2 start;\n        // Scan the start and KeyMask\n        int KeyMask = 0;\n        for (int i = 0; i <= n; i++) {\n            for (int j = 0; j <= m; j++) {\n                char c = grid[i][j];\n                int2 pos = {i, j};\n                if (c == '@')\n                    start = pos;  // Store the position of the starting point\n                if ('a' <= c && c <= 'z')\n                    KeyMask |= (1 << (c - 'a'));  // Set the corresponding bit in KeyMask for each key found\n            }\n        }\n        // Record the visiting status for every key status\n        vector<vector<vector<bool>>> \n        visit(n, vector<vector<bool>>(m, vector<bool>(KeyMask+1, \"0));\n\n        // [i, j, key state, distance]\n        queue<tuple<int, int, int, int>> q;\n        auto [i0, j0] = start;\n        q.push({i0, j0, 0, 0});  // Push the starting point with initial key state and distance 0\n\n        while (!q.empty()) {\n            auto [i, j, keyState, distance] = q.front();  // Extract current position, key state, and distance from the front of the queue\n            q.pop();\n            vector<int2> adj = {{i + 1, j}, {i, j + 1}, {i - 1, j}, {i, j - 1}};\n            for (auto [a, b] : adj) {\n                if (a < 0 || a > n || b < 0 || b > m || grid[a][b] == '#')\n                    continue;  // Skip if the next position is out of bounds or a wall ('#')\n                char c = grid[a][b];\n                // c is a key\n                if ('a' <= c && c <= 'z') {\n                    int keyIdx = c - 'a';  // Calculate the index of the key\n                    int newState = keyState | (1 << keyIdx);  // Update the key state by setting the corresponding bit\n                    if (visit[a][b][newState]) continue;  // Skip if this key state has been visited before at this position\n                    visit[a][b][newState] = 1;  // Mark the current key state as visited at this position\n                    if (newState == KeyMask) return distance + 1;  // If all keys are collected, return the distance\n                    q.push({a, b, newState, distance + 1});  // Push the next position with updated key state and increased distance\n                }\n                // c is a lock\n                else if ('A' <= c && c <= 'F') {\n                    int lockIdx = c - 'A';  // Calculate the index of the lock\n                    if ((keyState & (1 << lockIdx)) == 0) continue;  // Skip if the corresponding key for the lock is missing\n                    if (visit[a][b][keyState]) continue;  // Skip if this key state has been visited before at this position\n                    visit[a][b][keyState] = 1;  // Mark the current key state as visited at this position\n                    q.push({a, b, keyState, distance + 1});  // Push the next position with the same key state and increased distance\n                }\n                // c is ',' or '@'\n                else if (visit[a][b][keyState])\n                    continue;  // Skip if this key state has been visited before at this position\n\n                visit[a][b][keyState] = 1;  // Mark the current key state as visited at this position\n                q.push({a, b, keyState, distance + 1});  // Push the next position with the same key state and increased distance\n            }\n        }\n\n        return -1;  // If all keys cannot be collected, return -1\n    }\n};\n"
    },
    {
        "slug": "group-anagrams",
        "description": "Given an array of strings strs, group the anagrams together. You can return the answer in any order.\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.",
        "examples": [
            "Input: strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]\nOutput: [[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]",
            "Input: strs = [\"\"]\nOutput: [[\"\"]]",
            "Input: strs = [\"a\"]\nOutput: [[\"a\"]]"
        ],
        "constraints": "1 <= strs.length <= 104\n0 <= strs[i].length <= 100\nstrs[i] consists of lowercase English letters.",
        "oracle_code": "class Solution {\npublic:\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\n        unordered_map<string,int> m;\n        vector<vector<string>> ans;\n        for(int i=0; i<strs.size(); i++) {\n            string str = strs[i];\n            sort(str.begin(),str.end());\n\n            if(m.find(str) != m.end()) {\n                ans[m[str]].push_back(strs[i]);\n            }\n            else {\n                m[str] = ans.size(); \n                ans.push_back({strs[i]});\n            }\n        }\n        return ans;\n    }\n};",
        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        unordered_map<string,int> m;\\n        vector<vector<string>> ans;\\n        for(int i=0; i<strs.size(); i++) {\\n            string str = strs[i];\\n            sort(str.begin(),str.end());\\n\\n            if(m.find(str) != m.end()) {\\n                ans[m[str]].push_back(strs[i]);\\n            }\\n            else {\\n                m[str] = ans.size(); \\n                ans.push_back({strs[i]});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "statement separation",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\n        unordered_map<string,int> m;\n        vector<vector<string>> ans;\n        for(int i=0; i<strs.size(); i++) \n            string str = strs[i];\n            sort(str.begin(),str.end());\n\n            if(m.find(str) != m.end()) {\n                ans[m[str]].push_back(strs[i]);\n            }\n            else {\n                m[str] = ans.size(); \n                ans.push_back({strs[i]});\n                sortMyVec(ans[m[str]]);\n            }\n        }\n        return ans;\n    }\n};\n"
    },
    {
        "slug": "climbing-stairs",
        "description": "You are climbing a staircase. It takes n steps to reach the top.\nEach time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?",
        "examples": [
            "Input: n = 2\nOutput: 2\nExplanation: There are two ways to climb to the top.\n1. 1 step + 1 step\n2. 2 steps",
            "Input: n = 3\nOutput: 3\nExplanation: There are three ways to climb to the top.\n1. 1 step + 1 step + 1 step\n2. 1 step + 2 steps\n3. 2 steps + 1 step"
        ],
        "constraints": "1 <= n <= 45",
        "oracle_code": "class Solution {\npublic:\n    int solve(int n,vector<int> &dp){\n        //base case\n        if(n<=2)\n          return n;\n        \n        if(dp[n]!=-1) \n          return dp[n]; \n        \n        dp[n]=solve(n-1,dp)+solve(n-2,dp);\n        return dp[n];\n    }\n    int climbStairs(int n) {\n        if(n<=2)\n         return n;\n        vector<int> dp(n+1);\n        for(int i=0;i<=n;i++)\n         dp[i]=-1;\n        \n        return solve(n,dp);\n    }\n};",
        "content": "# Intuition\\nUsing Top - Down Approach -> Recursion + Memorization.\\n\\n# Approach\\nStoring the values of overlapping sub - problems in a vector.\\n\\n# Complexity\\n- Time complexity:\\nO(n) -> As we are visiting all values of n atleast 1 time.\\n\\n- Space complexity:\\nO(n) + O(n)  - > (Recursive calls + Array of size n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int n,vector<int> &dp){\\n        //base case\\n        if(n<=2)\\n          return n;\\n        \\n        if(dp[n]!=-1) \\n          return dp[n]; \\n        \\n        dp[n]=solve(n-1,dp)+solve(n-2,dp);\\n        return dp[n];\\n    }\\n    int climbStairs(int n) {\\n        if(n<=2)\\n         return n;\\n        vector<int> dp(n+1);\\n        for(int i=0;i<=n;i++)\\n         dp[i]=-1;\\n        \\n        return solve(n,dp);\\n    }\\n};\\n```\\n\\n# Intuition\\nUsing Bottom - up Approach -> Tabulation.\\n\\n# Approach\\nStoring the values of overlapping sub - problems in a vector.\\n\\n# Complexity\\n- Time complexity:\\nO(n) -> As we are traversing the vector atleast 1 time.\\n\\n- Space complexity:\\nO(n) - > (Array of size n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n<=2)\\n         return n;\\n        vector<int> dp(n+1);\\n        dp[0]=0;\\n        dp[1]=1;\\n        dp[2]=2;\\n        for(int i=3;i<=n;i++)\\n         dp[i]=dp[i-1]+dp[i-2];\\n        \\n        return dp[n];\\n    }\\n};\\n```\\n\\n# Python Code :\\nContributed by : Aarya_R\\n\\n# Complexity\\n- Time complexity:\\nO(n) -> As we are traversing the vector atleast 1 time.\\n\\n- Space complexity:\\nO(1) \\n```\\ndef climbStairs(self, n):\\n        prev = 1\\n        prev2 = 0\\n        for i in range(1, n+1):\\n            curi = prev + prev2\\n            prev2 = prev\\n            prev = curi\\n        return prev \\n```\\n![upvote.jfif](https://assets.leetcode.com/users/images/995d917b-6ea2-4b6b-8baa-6ce7bc6441fd_1676965776.537627.jpeg)\\n\\n",
        "level": "easy",
        "type": [
            "indexing error",
            "wrong comment mark"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    int solve(int n,vector<int> &dp){\n        /*base case\n        if(n<=2)\n          return n;\n        \n        if(dp[n]!=-1) \n          return dp[n]; \n        \n        dp[n]=solve(n-1,dp)+solve(n-2,dp);\n        return dp[n];\n    }\n    int climbStairs(int n) {\n        if(n<=2)\n         return n;\n        vector<int> dp(n);\n        for(int i=0;i<=n;i++)\n         dp[i]=-1;\n        \n        return solve(n,dp);\n    }\n};\n"
    },
    {
        "slug": "factorial-trailing-zeroes",
        "description": "Given an integer n, return the number of trailing zeroes in n!.\nNote that n! = n * (n - 1) * (n - 2) * ... * 3 * 2 * 1.",
        "examples": [
            "Input: n = 3\nOutput: 0\nExplanation: 3! = 6, no trailing zero.",
            "Input: n = 5\nOutput: 1\nExplanation: 5! = 120, one trailing zero.",
            "Input: n = 0\nOutput: 0"
        ],
        "constraints": "0 <= n <= 104",
        "oracle_code": "class Solution {\npublic:\n    unordered_map<long long int,long long int>mp;\n    int trailingZeroes(int n) {\n        for(int i=n;i>=1;i--)\n         fun(i);\n         \n\t\t return min(mp[2],mp[5]); \n    }\n     void fun(int n)\n    {\n         for(int i=2;i*i<=n;i++)\n         {\n         \twhile((n%i) == 0)\n         \t{\n         \t    mp[i]++;\n\t\t\t\tn = n / i;\t\n\t\t\t}\n\t\t }\n\t\t if(n > 1)\n\t\t mp[n]++;\n    }\n};",
        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    unordered_map<long long int,long long int>mp;\\n    int trailingZeroes(int n) {\\n        for(int i=n;i>=1;i--)\\n         fun(i);\\n         \\n\\t\\t return min(mp[2],mp[5]); \\n    }\\n     void fun(int n)\\n    {\\n         for(int i=2;i*i<=n;i++)\\n         {\\n         \\twhile((n%i) == 0)\\n         \\t{\\n         \\t    mp[i]++;\\n\\t\\t\\t\\tn = n / i;\\t\\n\\t\\t\\t}\\n\\t\\t }\\n\\t\\t if(n > 1)\\n\\t\\t mp[n]++;\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "statement separation",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    unordered_map<long long int,long long int>mp;\n    int trailingZeroes(int n) {\n        for(int i=n;i>=1;i--);\n         fun(i);\n         \n\t\t Solution s;\n\t\t return s.min(mp[2],mp[5]); \n    }\n     void fun(int n)\n    {\n         for(int i=2;i*i<=n;i++)\n         {\n         \twhile((n%i) == 0)\n         \t{\n         \t    mp[i]++;\n\t\t\t\tn = n / i;\t\n\t\t\t}\n\t\t }\n\t\t if(n > 1)\n\t\t mp[n]++;\n    }\n};\n"
    },
    {
        "slug": "longest-common-prefix",
        "description": "Write a function to find the longest common prefix string amongst an array of strings.\nIf there is no common prefix, return an empty string \"\".",
        "examples": [
            "Input: strs = [\"flower\",\"flow\",\"flight\"]\nOutput: \"fl\"",
            "Input: strs = [\"dog\",\"racecar\",\"car\"]\nOutput: \"\"\nExplanation: There is no common prefix among the input strings."
        ],
        "constraints": "1 <= strs.length <= 200\n0 <= strs[i].length <= 200\nstrs[i] consists of only lowercase English letters.",
        "oracle_code": "class Solution {\npublic:\n    string longestCommonPrefix(vector<string>& str) \n    {\n        sort(str.begin(), str.end()); //sorting the array\n        string ans=\"\"; //creating a new empty string to store the common prefixes\n        for(int i=0;i<str[0].length();i++) // max iterations = length of the first string\n        {\n            if(str[0][i]!=str[str.size()-1][i]) // checking the characters of the first and last string\n                break;\n            ans+=str[0][i]; // concatinate if the characters are matching\n        }\n        return ans;\n    }\n};",
        "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWhen you sort an array, it is enough to check for the common characters of the the first & last string of the sorted vector.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& str) \\n    {\\n        sort(str.begin(), str.end()); //sorting the array\\n        string ans=\"\"; //creating a new empty string to store the common prefixes\\n        for(int i=0;i<str[0].length();i++) // max iterations = length of the first string\\n        {\\n            if(str[0][i]!=str[str.size()-1][i]) // checking the characters of the first and last string\\n                break;\\n            ans+=str[0][i]; // concatinate if the characters are matching\\n        }\\n        return ans;\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "conditional statement error",
            "colon missing"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    string longestCommonPrefix(vector<string>& str) \n    {\n        sort(str.begin(), str.end()); //sorting the array\n        string ans=\"\"; //creating a new empty string to store the common prefixes\n        for(int i=0;i<str[0].length();i) \n        {\n            if(str[0][i]!=str[str.size()][i]) \n                break;\n            ans+=str[0][i]; // concatinate if the characters are matching\n        }\n        return ans;\n    }\n};\n"
    },
    {
        "slug": "perfect-squares",
        "description": "Given an integer n, return the least number of perfect square numbers that sum to n.\nA perfect square is an integer that is the square of an integer; in other words, it is the product of some integer with itself. For example, 1, 4, 9, and 16 are perfect squares while 3 and 11 are not.",
        "examples": [
            "Input: n = 12\nOutput: 3\nExplanation: 12 = 4 + 4 + 4.",
            "Input: n = 13\nOutput: 2\nExplanation: 13 = 4 + 9."
        ],
        "constraints": "1 <= n <= 104",
        "oracle_code": "class Solution {\npublic:\n\n    // declare a dp\n\n    int dp[105][10005];\n\n    int helper(vector<int>& arr, int i, int n, int sum)\n    {\n        // base case\n\n        if(sum == 0)\n        {\n            return 0;\n        }\n\n        if(i >= n || sum < 0)\n        {\n            return INT_MAX - 1000;\n        }\n\n        // if already calculated\n\n        if(dp[i][sum] != -1)\n        {\n            return dp[i][sum];\n        }\n\n        // at each ith element we have two options either include or exclude\n\n        int mini = INT_MAX;\n\n        // inclusion part\n\n        if(arr[i] <= sum)\n        {\n            mini = min(mini, 1 + helper(arr, i, n, sum - arr[i]));\n        }\n\n        // exclusion part\n\n        mini = min(mini, helper(arr, i + 1, n, sum));\n\n        // store the res in dp\n\n        return dp[i][sum] = mini;\n    }\n\n    int numSquares(int n) {\n\n        vector<int> arr;\n\n        // find all the squares between 1 to n\n\n        for(int i = 1; i * i <= n; i++)\n        {\n            arr.push_back(i * i);\n        }\n\n        // initialize dp with -1\n\n        memset(dp, -1, sizeof(dp));\n\n        return helper(arr, 0, arr.size(), n);\n    }\n};",
        "content": "* ***Using Recursion && Memoization***\\n\\n* ***Time Complexity :- O(N * sqrt(N))***\\n\\n* ***Space Complexity :- O(N * sqrt(N))***\\n\\n* ***There are sqrt(N), squares between 1 to N***\\n\\n```\\nclass Solution {\\npublic:\\n\\n    // declare a dp\\n\\n    int dp[105][10005];\\n\\n    int helper(vector<int>& arr, int i, int n, int sum)\\n    {\\n        // base case\\n\\n        if(sum == 0)\\n        {\\n            return 0;\\n        }\\n\\n        if(i >= n || sum < 0)\\n        {\\n            return INT_MAX - 1000;\\n        }\\n\\n        // if already calculated\\n\\n        if(dp[i][sum] != -1)\\n        {\\n            return dp[i][sum];\\n        }\\n\\n        // at each ith element we have two options either include or exclude\\n\\n        int mini = INT_MAX;\\n\\n        // inclusion part\\n\\n        if(arr[i] <= sum)\\n        {\\n            mini = min(mini, 1 + helper(arr, i, n, sum - arr[i]));\\n        }\\n\\n        // exclusion part\\n\\n        mini = min(mini, helper(arr, i + 1, n, sum));\\n\\n        // store the res in dp\\n\\n        return dp[i][sum] = mini;\\n    }\\n\\n    int numSquares(int n) {\\n\\n        vector<int> arr;\\n\\n        // find all the squares between 1 to n\\n\\n        for(int i = 1; i * i <= n; i++)\\n        {\\n            arr.push_back(i * i);\\n        }\\n\\n        // initialize dp with -1\\n\\n        memset(dp, -1, sizeof(dp));\\n\\n        return helper(arr, 0, arr.size(), n);\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "undefined methods",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n\n    // declare a dp\n\n    int dp[105][10005];\n\n    int helper(vector<int>& arr, int i, int n, int sum)\n    {\n        // base case\n\n        if(sum == 0)\n        {\n            return 0;\n        }\n\n        if(i >= n || sum < 0)\n        {\n            return INT_MAX - 1000;\n        }\n\n        // if already calculated\n\n        if(dp[i][sum] != -1)\n        {\n            return dp[i][sum];\n        }\n\n        // at each ith element we have two options either include or exclude\n\n        int mini = INT_MAX;\n\n        // inclusion part\n\n        if(arr[i] <= sum)\n        {\n            mini = min(mini, 1 + helper(arr, i, n, sum - arr[i]));\n        }\n\n        // exclusion part\n\n        mini = min(mini, helper(arr, i + 1, n, sum));\n\n        // store the res in dp\n\n        return dp[i][sum] = mini;\n    }\n\n    int numSquares(int n) {\n\n        vector<int> arr;\n\n        // find all the squares between 1 to n\n\n        for(int i = 1; i * i <= n; i++)\n        {\n            arr.push_back(i * i);\n        }\n\n        // initialize dp with -1\n\n        this->initializeDP();\n\n        \n        print(helper(arr, 0, arr.size(), n));\n    }\n\n};\n"
    },
    {
        "slug": "count-number-of-possible-root-nodes",
        "description": "Alice has an undirected tree with n nodes labeled from 0 to n - 1. The tree is represented as a 2D integer array edges of length n - 1 where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree.\nAlice wants Bob to find the root of the tree. She allows Bob to make several guesses about her tree. In one guess, he does the following:\n\nChooses two distinct integers u and v such that there exists an edge [u, v] in the tree.\nHe tells Alice that u is the parent of v in the tree.\n\nBob's guesses are represented by a 2D integer array guesses where guesses[j] = [uj, vj] indicates Bob guessed uj to be the parent of vj.\nAlice being lazy, does not reply to each of Bob's guesses, but just says that at least k of his guesses are true.\nGiven the 2D integer arrays edges, guesses and the integer k, return the number of possible nodes that can be the root of Alice's tree. If there is no such tree, return 0.",
        "examples": [
            "Input: edges = [[0,1],[1,2],[1,3],[4,2]], guesses = [[1,3],[0,1],[1,0],[2,4]], k = 3\nOutput: 3\nExplanation: \nRoot = 0, correct guesses = [1,3], [0,1], [2,4]\nRoot = 1, correct guesses = [1,3], [1,0], [2,4]\nRoot = 2, correct guesses = [1,3], [1,0], [2,4]\nRoot = 3, correct guesses = [1,0], [2,4]\nRoot = 4, correct guesses = [1,3], [1,0]\nConsidering 0, 1, or 2 as root node leads to 3 correct guesses.",
            "Input: edges = [[0,1],[1,2],[2,3],[3,4]], guesses = [[1,0],[3,4],[2,1],[3,2]], k = 1\nOutput: 5\nExplanation: \nRoot = 0, correct guesses = [3,4]\nRoot = 1, correct guesses = [1,0], [3,4]\nRoot = 2, correct guesses = [1,0], [2,1], [3,4]\nRoot = 3, correct guesses = [1,0], [2,1], [3,2], [3,4]\nRoot = 4, correct guesses = [1,0], [2,1], [3,2]\nConsidering any node as root will give at least 1 correct guess."
        ],
        "constraints": "edges.length == n - 1\n2 <= n <= 105\n1 <= guesses.length <= 105\n0 <= ai, bi, uj, vj <= n - 1\nai != bi\nuj != vj\nedges represents a valid tree.\nguesses[j] is an edge of the tree.\nguesses is unique.\n0 <= k <= guesses.length",
        "oracle_code": "class Solution {\npublic:\n    map<pair<int,int>,int> mp;\n    void dfs(vector<vector<int>>& tree,vector<int>& possible,int cur ,int ans,int k)\n    {\n        for(auto& a:tree[cur])\n        {\n            if(possible[a]==-1)\n            {\n                int new_ans=ans;\n                bool a1=false,a2=false;\n                if(mp.find({a,cur})!=mp.end() && mp[{a,cur}]==0  )\n                {\n                    mp[{a,cur}]=1;\n                    new_ans++;\n                    a1=true;\n                }\n                if(mp.find({cur,a })!=mp.end() && mp[{cur,a}]==1  )\n                {\n                    mp[{cur,a}]=0;\n                    new_ans--;\n                    a2=true;\n                }\n                possible[a]=0;\n                if(new_ans>=k)\n                {\n                    possible[a]=1;\n                }\n                dfs(tree,possible,a,new_ans,k);\n                if(a1)\n                {\n                    mp[{a,cur}]=0;\n                }\n                if(a2)\n                {\n                    mp[{cur,a}]=1;\n                }\n            }\n        }\n\n    }\n    int rootCount(vector<vector<int>>& edges, vector<vector<int>>& guesses, int k) {\n        \n        for(auto&e : guesses)\n        {\n            mp[ {e[0],e[1]}]=0;\n        }\n        int n=edges.size()+1;\n        vector<vector<int>> tree(n);\n        for(auto& e:edges)\n        {\n            tree[e[0]].push_back(e[1]);\n            tree[e[1]].push_back(e[0]);\n        }\n        queue<int> q;\n        q.push(0);\n        vector<bool> visited(n,false);\n        visited[0]=true;\n        int ans=0;\n        while(q.size()>0)\n        {\n            int a=q.front();\n            q.pop();\n            for(int i=0;i<tree[a].size();i++)\n            {\n                if(visited[tree[a][i]])\n                    continue;\n                visited[tree[a][i]]=true;\n                if(mp.find({a,tree[a][i]})!=mp.end() && mp[{a,tree[a][i]}]==0  )\n                {\n                    mp[{a,tree[a][i]}]=1;\n                    ans++;\n                }\n                if(mp.find({tree[a][i],a })!=mp.end() && mp[{tree[a][i],a}]==1  )\n                {\n                    mp[{tree[a][i],a}]=0;\n                    ans--;\n                }\n                q.push(tree[a][i]);\n            }\n        }\n        vector<int> possible(n,-1);\n        possible[0]= (1?ans>=k:0);\n        dfs(tree,possible,0,ans,k);\n        int sum=accumulate(possible.begin(),possible.end(),0);\n        return sum;\n    }\n};",
        "content": "# Intuition\\nSuppose [a,b] is an edge and a is the root of the tree. Now suppose we want to evaluate b as the root of the tree. The only guess that were previously correct and now incorrect would be [a,b]. Similarly the only guess that was previously incorrect but now correct is [b,a].\\n\\n# Approach\\nCreate an adjacency list of the graph ->***tree***. Suppose 0 is the root of the tree. Apply bfs (I used bfs but dfs can be used as well) to evaluate all the guesses that are now correct ->***ans***. Create another array of size n -> ***possible*** that stores if the current node is capable of being the root of the tree. possible[0] = 1 if ans>=k, else possible[0]=0;\\n\\nNow try to evaluate the ans if one of the neighbours of 0 is the root. Suppose [0,b] is an edge in guesses. We will know that since b is now parent, [0,b] guess would now be false. So decrement ans by 1 in this case. Similarly suppose [b,0] was a guess. This guess is now correct. Increment ans by 1 in this case. Again see if ans>=k. If yes, possible[b]=1, else possible[b]=0;\\n\\nContinue this for all the edges in the tree in a dfs manner. Finally return the number of indexes where possible array entry is equal to 1. \\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    map<pair<int,int>,int> mp;\\n    void dfs(vector<vector<int>>& tree,vector<int>& possible,int cur ,int ans,int k)\\n    {\\n        for(auto& a:tree[cur])\\n        {\\n            if(possible[a]==-1)\\n            {\\n                int new_ans=ans;\\n                bool a1=false,a2=false;\\n                if(mp.find({a,cur})!=mp.end() && mp[{a,cur}]==0  )\\n                {\\n                    mp[{a,cur}]=1;\\n                    new_ans++;\\n                    a1=true;\\n                }\\n                if(mp.find({cur,a })!=mp.end() && mp[{cur,a}]==1  )\\n                {\\n                    mp[{cur,a}]=0;\\n                    new_ans--;\\n                    a2=true;\\n                }\\n                possible[a]=0;\\n                if(new_ans>=k)\\n                {\\n                    possible[a]=1;\\n                }\\n                dfs(tree,possible,a,new_ans,k);\\n                if(a1)\\n                {\\n                    mp[{a,cur}]=0;\\n                }\\n                if(a2)\\n                {\\n                    mp[{cur,a}]=1;\\n                }\\n            }\\n        }\\n\\n    }\\n    int rootCount(vector<vector<int>>& edges, vector<vector<int>>& guesses, int k) {\\n        \\n        for(auto&e : guesses)\\n        {\\n            mp[ {e[0],e[1]}]=0;\\n        }\\n        int n=edges.size()+1;\\n        vector<vector<int>> tree(n);\\n        for(auto& e:edges)\\n        {\\n            tree[e[0]].push_back(e[1]);\\n            tree[e[1]].push_back(e[0]);\\n        }\\n        queue<int> q;\\n        q.push(0);\\n        vector<bool> visited(n,false);\\n        visited[0]=true;\\n        int ans=0;\\n        while(q.size()>0)\\n        {\\n            int a=q.front();\\n            q.pop();\\n            for(int i=0;i<tree[a].size();i++)\\n            {\\n                if(visited[tree[a][i]])\\n                    continue;\\n                visited[tree[a][i]]=true;\\n                if(mp.find({a,tree[a][i]})!=mp.end() && mp[{a,tree[a][i]}]==0  )\\n                {\\n                    mp[{a,tree[a][i]}]=1;\\n                    ans++;\\n                }\\n                if(mp.find({tree[a][i],a })!=mp.end() && mp[{tree[a][i],a}]==1  )\\n                {\\n                    mp[{tree[a][i],a}]=0;\\n                    ans--;\\n                }\\n                q.push(tree[a][i]);\\n            }\\n        }\\n        vector<int> possible(n,-1);\\n        possible[0]= (1?ans>=k:0);\\n        dfs(tree,possible,0,ans,k);\\n        int sum=accumulate(possible.begin(),possible.end(),0);\\n        return sum;\\n    }\\n};\\n```",
        "level": "hard",
        "type": [
            "other error",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    map<pair<int,int>,int> mp;\n    void dfs(vector<vector<int>>& tree,vector<int>& possible,int cur ,int ans,int k)\n    {\n        for(auto& a:tree[cur])\n        {\n            if(possible[a]==-1)\n            {\n                int new_ans=ans;\n                boolean a1=false,a2=false;\n                if(mp.find({a,cur})!=mp.end() && mp[{a,cur}]==0  )\n                {\n                    mp[{a,cur}]=1;\n                    new_ans++;\n                    a1=true;\n                }\n                if(mp.find({cur,a })!=mp.end() && mp[{cur,a}]==1  )\n                {\n                    mp[{cur,a}]=0;\n                    new_ans--;\n                    a2=true;\n                }\n                \n                possible[a]=0;\n                if(new_ans>=k)\n                {\n                    possible[a]=2;\n                }\n                dfs(tree,possible,a,new_ans,k);\n                if(a1)\n                {\n                    mp[{a,cur}]=0;\n                }\n                if(a2)\n                {\n                    mp[{cur,a}]=1;\n                }\n            }\n        }\n\n    }\n    int rootCount(vector<vector<int>>& edges, vector<vector<int>>& guesses, int k) {\n        \n        for(auto&e : guesses)\n        {\n            mp[ {e[0],e[1]}]=0;\n        }\n        int n=edges.size()+1;\n        vector<vector<int>> tree(n);\n        for(auto& e:edges)\n        {\n            tree[e[0]].push_back(e[1]);\n            tree[e[1]].push_back(e[0]);\n        }\n        queue<int> q;\n        q.push(0);\n        vector<bool> visited(n,false);\n        visited[0]=true;\n        int ans=0;\n        while(q.size()>0)\n        {\n            int a=q.front();\n            q.pop();\n            for(int i=0;i<tree[a].size();i++)\n            {\n                if(visited[tree[a][i]])\n                    continue;\n                visited[tree[a][i]]=true;\n                if(mp.find({a,tree[a][i]})!=mp.end() && mp[{a,tree[a][i]}]==0  )\n                {\n                    mp[{a,tree[a][i]}]=1;\n                    ans++;\n                }\n                if(mp.find({tree[a][i],a })!=mp.end() && mp[{tree[a][i],a}]==1  )\n                {\n                    mp[{tree[a][i],a}]=0;\n                    ans--;\n                }\n                q.push(tree[a][i]);\n            }\n        }\n        vector<int> possible(n,-1);\n        possible[0]= (1?ans>=k:0);\n        dfs(tree,possible,0,ans,k);\n        int sum=accumulate(possible.begin(),possible.end(),0);\n        return sum;\n    }\n};\n"
    },
    {
        "slug": "ugly-number-ii",
        "description": "An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5.\nGiven an integer n, return the nth ugly number.",
        "examples": [
            "Input: n = 10\nOutput: 12\nExplanation: [1, 2, 3, 4, 5, 6, 8, 9, 10, 12] is the sequence of the first 10 ugly numbers.",
            "Input: n = 1\nOutput: 1\nExplanation: 1 has no prime factors, therefore all of its prime factors are limited to 2, 3, and 5."
        ],
        "constraints": "1 <= n <= 1690",
        "oracle_code": "class Solution {\npublic:\n    int nthUglyNumber(int n) \n    {\n        vector<int>dp(n);\n        dp[0]=1;\n        int p1=0;\n        int p2=0;\n        int p3=0;\n        for(int i=1;i<n;i++)\n        {\n            int two=dp[p1]*2;\n            int three=dp[p2]*3;\n            int five=dp[p3]*5;\n            dp[i]=min(two,min(three,five));\n            if(dp[i]==two)\n            p1++;\n            if(dp[i]==three)\n            p2++;\n            if(dp[i]==five)\n            p3++;\n        }\n        return dp[n-1];\n        \n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n) \\n    {\\n        vector<int>dp(n);\\n        dp[0]=1;\\n        int p1=0;\\n        int p2=0;\\n        int p3=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            int two=dp[p1]*2;\\n            int three=dp[p2]*3;\\n            int five=dp[p3]*5;\\n            dp[i]=min(two,min(three,five));\\n            if(dp[i]==two)\\n            p1++;\\n            if(dp[i]==three)\\n            p2++;\\n            if(dp[i]==five)\\n            p3++;\\n        }\\n        return dp[n-1];\\n        \\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "indexing error",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    int nthUglyNumber(int n) \n    {\n        vector<int>dp(n);\n        dp[0]=1;\n        dp[n]=10; \n        int p1=0;\n        int p2=0;\n        int p3=0;\n        for(int i=1;i<=n;i++)\n        {\n            int two=dp[p1]*2;\n            int three=dp[p2]*3;\n            int five=dp[p3]*5;\n            dp[i]=min(two,min(three,five));\n            if(dp[i]==two)\n            p1++;\n            if(dp[i]==three)\n            p2++;\n            if(dp[i]==five)\n            p3++;\n        }\n        return dp[n];\n    }\n};\n"
    },
    {
        "slug": "reverse-vowels-of-a-string",
        "description": "Given a string s, reverse only all the vowels in the string and return it.\nThe vowels are 'a', 'e', 'i', 'o', and 'u', and they can appear in both lower and upper cases, more than once.",
        "examples": [
            "Input: s = \"hello\"\nOutput: \"holle\"",
            "Input: s = \"leetcode\"\nOutput: \"leotcede\""
        ],
        "constraints": "1 <= s.length <= 3 * 105\ns consist of printable ASCII characters.",
        "oracle_code": "class Solution {\npublic:\n    string reverseVowels(string s) {\n        \n        vector<char> v;\n        for(int i = 0 ; i < s.length(); i++)\n        {\n            if(s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u'\n              || s[i] == 'A' || s[i] == 'E' || s[i] == 'O' || s[i] == 'I' || s[i] == 'U')\n                v.push_back(s[i]);\n        }\n        reverse(v.begin(), v.end());\n        int rev = 0;\n        for(int i = 0 ; i < s.length(); i++)\n        {\n            if(s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u'\n              || s[i] == 'A' || s[i] == 'E' || s[i] == 'O' || s[i] == 'I' || s[i] == 'U'){\n                s[i] = v[rev];\n                rev++;\n            }\n        }\n        return s;\n    }\n};",
        "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        \\n        vector<char> v;\\n        for(int i = 0 ; i < s.length(); i++)\\n        {\\n            if(s[i] == \\'a\\' || s[i] == \\'e\\' || s[i] == \\'i\\' || s[i] == \\'o\\' || s[i] == \\'u\\'\\n              || s[i] == \\'A\\' || s[i] == \\'E\\' || s[i] == \\'O\\' || s[i] == \\'I\\' || s[i] == \\'U\\')\\n                v.push_back(s[i]);\\n        }\\n        reverse(v.begin(), v.end());\\n        int rev = 0;\\n        for(int i = 0 ; i < s.length(); i++)\\n        {\\n            if(s[i] == \\'a\\' || s[i] == \\'e\\' || s[i] == \\'i\\' || s[i] == \\'o\\' || s[i] == \\'u\\'\\n              || s[i] == \\'A\\' || s[i] == \\'E\\' || s[i] == \\'O\\' || s[i] == \\'I\\' || s[i] == \\'U\\'){\\n                s[i] = v[rev];\\n                rev++;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "unclosed string",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    string reverseVowels(string s) {\n        \n        vector<char> v;\n        for(int i = 0 ; i < s.length(); i++)\n        {\n            if(s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u\n              || s[i] == 'A' || s[i] == 'E' || s[i] == 'O' || s[i] == 'I' )\n                v.push_back(s[i]);\n        }\n        reverse(v.begin(), v.end());\n        int rev = 0;\n        for(int i = 0 ; i < s.length(); i++)\n        {\n            if(s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u\n              || s[i] == 'A' || s[i] == 'E' || s[i] == 'O' || s[i] == 'I'){\n                s[i] = v[rev];\n                rev++;\n            }\n        }\n        return s;\n    }\n};\n"
    },
    {
        "slug": "rotate-array",
        "description": "Given an integer array nums, rotate the array to the right by k steps, where k is non-negative.",
        "examples": [
            "Input: nums = [1,2,3,4,5,6,7], k = 3\nOutput: [5,6,7,1,2,3,4]\nExplanation:\nrotate 1 steps to the right: [7,1,2,3,4,5,6]\nrotate 2 steps to the right: [6,7,1,2,3,4,5]\nrotate 3 steps to the right: [5,6,7,1,2,3,4]",
            "Input: nums = [-1,-100,3,99], k = 2\nOutput: [3,99,-1,-100]\nExplanation: \nrotate 1 steps to the right: [99,-1,-100,3]\nrotate 2 steps to the right: [3,99,-1,-100]"
        ],
        "constraints": "1 <= nums.length <= 105\n-231 <= nums[i] <= 231 - 1\n0 <= k <= 105",
        "oracle_code": "class Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        int n=nums.size();\n        vector<int> temp(nums.size());\n        for(int i=0;i<n;i++){\n            temp[(i+k)%n]=nums[i];\n        }\n        nums=temp;\n    }\n};",
        "content": "# Approach\\nhere i is of loop which starts form (0,1,2...) k is the value how many times you want to rotate and n is the size of first vector ,and after that new indexes will be generated in our temp vector and we have to put values of nums vector at new indexes . . . \\nlike for first  arr[1,2,3,4,5,6,7]  and k=3     so ,\\ntemp[0 + 3 % 7]=nums[i]\\ntemp[3 % 7]=nums[i]\\ntemp[3] = nums[i]\\n[_ , _ , _ , 1 , _ ,_ , _ ]\\nfor next ,\\ntemp[1 + 3 % 7]=nums[i]\\ntemp[4 % 7]=nums[i]\\ntemp[4] = nums[i]\\n[_ , _ , _ , 1 , 2 ,_ , _ ]   and so on \\ni hope you understand ..\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int> temp(nums.size());\\n        for(int i=0;i<n;i++){\\n            temp[(i+k)%n]=nums[i];\\n        }\\n        nums=temp;\\n    }\\n};\\n```\\n![upvote 1.jpeg](https://assets.leetcode.com/users/images/565d5fa5-1370-44d9-a6b6-0cf06d575aae_1681731352.2608747.jpeg)\\n",
        "level": "medium",
        "type": [
            "conditional statement error",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        int n=nums.size();\n        vector<int> temp(nums.size();\n        for(int i=0;i<n;i++){\n            temp[(i+k)%n]=nums[i+1];\n        }\n        nums=temp;\n    }\n};\n"
    },
    {
        "slug": "plus-one",
        "description": "You are given a large integer represented as an integer array digits, where each digits[i] is the ith digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading 0's.\nIncrement the large integer by one and return the resulting array of digits.",
        "examples": [
            "Input: digits = [1,2,3]\nOutput: [1,2,4]\nExplanation: The array represents the integer 123.\nIncrementing by one gives 123 + 1 = 124.\nThus, the result should be [1,2,4].",
            "Input: digits = [4,3,2,1]\nOutput: [4,3,2,2]\nExplanation: The array represents the integer 4321.\nIncrementing by one gives 4321 + 1 = 4322.\nThus, the result should be [4,3,2,2].",
            "Input: digits = [9]\nOutput: [1,0]\nExplanation: The array represents the integer 9.\nIncrementing by one gives 9 + 1 = 10.\nThus, the result should be [1,0]."
        ],
        "constraints": "1 <= digits.length <= 100\n0 <= digits[i] <= 9\ndigits does not contain any leading 0's.",
        "oracle_code": "class Solution {\npublic:\n    vector<int> plusOne(vector<int>& digits) {\n        int n=digits.size();\n        digits[n-1]++;\n        for(int i=n-1;i>=1;i--)\n        {\n            if(digits[i]>9)\n            {\n                digits[i]%=10;\n                digits[i-1]++;\n            }\n        }\n        if(digits[0]>9)\n        {\n            digits.insert(digits.begin(),1);\n            digits[1]%=10;\n        }\n        return digits;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nsimple iterative approach.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIterated all index from the end , then manually checked for 0th index and did the needful.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n=digits.size();\\n        digits[n-1]++;\\n        for(int i=n-1;i>=1;i--)\\n        {\\n            if(digits[i]>9)\\n            {\\n                digits[i]%=10;\\n                digits[i-1]++;\\n            }\\n        }\\n        if(digits[0]>9)\\n        {\\n            digits.insert(digits.begin(),1);\\n            digits[1]%=10;\\n        }\\n        return digits;\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "indexing error",
            "wrong comment mark"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    vector<int> plusOne(vector<int>& digits) {\n        /int n=digits.size();\n        digits[n]++; \n        for(int i=n-1;i>=1;i--)\n        {\n            if(digits[i]>9)\n            {\n                digits[i]%=10;\n                digits[i-1]++;\n            }\n        }\n        if(digits[0]>9)\n        {\n            digits.insert(digits.begin(),1);\n            digits[1]%=10;\n        }\n        return digits;\n    }\n};\n"
    },
    {
        "slug": "find-the-winner-of-the-circular-game",
        "description": "There are n friends that are playing a game. The friends are sitting in a circle and are numbered from 1 to n in clockwise order. More formally, moving clockwise from the ith friend brings you to the (i+1)th friend for 1 <= i < n, and moving clockwise from the nth friend brings you to the 1st friend.\nThe rules of the game are as follows:\n\nStart at the 1st friend.\nCount the next k friends in the clockwise direction including the friend you started at. The counting wraps around the circle and may count some friends more than once.\nThe last friend you counted leaves the circle and loses the game.\nIf there is still more than one friend in the circle, go back to step 2 starting from the friend immediately clockwise of the friend who just lost and repeat.\nElse, the last friend in the circle wins the game.\n\nGiven the number of friends, n, and an integer k, return the winner of the game.",
        "examples": [
            "Input: n = 5, k = 2\nOutput: 3\nExplanation: Here are the steps of the game:\n1) Start at friend 1.\n2) Count 2 friends clockwise, which are friends 1 and 2.\n3) Friend 2 leaves the circle. Next start is friend 3.\n4) Count 2 friends clockwise, which are friends 3 and 4.\n5) Friend 4 leaves the circle. Next start is friend 5.\n6) Count 2 friends clockwise, which are friends 5 and 1.\n7) Friend 1 leaves the circle. Next start is friend 3.\n8) Count 2 friends clockwise, which are friends 3 and 5.\n9) Friend 5 leaves the circle. Only friend 3 is left, so they are the winner.",
            "Input: n = 6, k = 5\nOutput: 1\nExplanation: The friends leave in this order: 5, 4, 6, 2, 3. The winner is friend 1."
        ],
        "constraints": "1 <= k <= n <= 500",
        "oracle_code": "class Solution {\npublic:\n    int findTheWinner(int n, int k) {\n        vector<int> v;\n        for (int i=1; i<=n; i++)v.push_back(i);\n        int i=0;\n        while (v.size() != 1){\n            i= (i+k-1)%(v.size());\n            //cout<<v[i]<<endl;\n            v.erase(v.begin()+i);\n        }\n        return v[0];\n    }\n};",
        "content": "## Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n## Code\\n```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        vector<int> v;\\n        for (int i=1; i<=n; i++)v.push_back(i);\\n        int i=0;\\n        while (v.size() != 1){\\n            i= (i+k-1)%(v.size());\\n            //cout<<v[i]<<endl;\\n            v.erase(v.begin()+i);\\n        }\\n        return v[0];\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "indexing error",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    int findTheWinner(int n, int k) {\n        vector<int> v;\n        for (int i=1; i<=n+1; i++)v.push_back(i);\n        int i=0;\n        while (v.size() != 1{\n            i= (i+k-1)%(v.size());\n            //cout<<v[i]<<endl;\n            v.erase(v.begin()+i);\n        }\n        return v[0];\n    }\n};\n\n"
    },
    {
        "slug": "perfect-squares",
        "description": "Given an integer n, return the least number of perfect square numbers that sum to n.\nA perfect square is an integer that is the square of an integer; in other words, it is the product of some integer with itself. For example, 1, 4, 9, and 16 are perfect squares while 3 and 11 are not.",
        "examples": [
            "Input: n = 12\nOutput: 3\nExplanation: 12 = 4 + 4 + 4.",
            "Input: n = 13\nOutput: 2\nExplanation: 13 = 4 + 9."
        ],
        "constraints": "1 <= n <= 104",
        "oracle_code": "class Solution {\npublic:\n\n    // declare a dp\n\n    int dp[105][10005];\n\n    int helper(vector<int>& arr, int i, int n, int sum)\n    {\n        // base case\n\n        if(sum == 0)\n        {\n            return 0;\n        }\n\n        if(i >= n || sum < 0)\n        {\n            return INT_MAX - 1000;\n        }\n\n        // if already calculated\n\n        if(dp[i][sum] != -1)\n        {\n            return dp[i][sum];\n        }\n\n        // at each ith element we have two options either include or exclude\n\n        int mini = INT_MAX;\n\n        // inclusion part\n\n        if(arr[i] <= sum)\n        {\n            mini = min(mini, 1 + helper(arr, i, n, sum - arr[i]));\n        }\n\n        // exclusion part\n\n        mini = min(mini, helper(arr, i + 1, n, sum));\n\n        // store the res in dp\n\n        return dp[i][sum] = mini;\n    }\n\n    int numSquares(int n) {\n\n        vector<int> arr;\n\n        // find all the squares between 1 to n\n\n        for(int i = 1; i * i <= n; i++)\n        {\n            arr.push_back(i * i);\n        }\n\n        // initialize dp with -1\n\n        memset(dp, -1, sizeof(dp));\n\n        return helper(arr, 0, arr.size(), n);\n    }\n};",
        "content": "* ***Using Recursion && Memoization***\\n\\n* ***Time Complexity :- O(N * sqrt(N))***\\n\\n* ***Space Complexity :- O(N * sqrt(N))***\\n\\n* ***There are sqrt(N), squares between 1 to N***\\n\\n```\\nclass Solution {\\npublic:\\n\\n    // declare a dp\\n\\n    int dp[105][10005];\\n\\n    int helper(vector<int>& arr, int i, int n, int sum)\\n    {\\n        // base case\\n\\n        if(sum == 0)\\n        {\\n            return 0;\\n        }\\n\\n        if(i >= n || sum < 0)\\n        {\\n            return INT_MAX - 1000;\\n        }\\n\\n        // if already calculated\\n\\n        if(dp[i][sum] != -1)\\n        {\\n            return dp[i][sum];\\n        }\\n\\n        // at each ith element we have two options either include or exclude\\n\\n        int mini = INT_MAX;\\n\\n        // inclusion part\\n\\n        if(arr[i] <= sum)\\n        {\\n            mini = min(mini, 1 + helper(arr, i, n, sum - arr[i]));\\n        }\\n\\n        // exclusion part\\n\\n        mini = min(mini, helper(arr, i + 1, n, sum));\\n\\n        // store the res in dp\\n\\n        return dp[i][sum] = mini;\\n    }\\n\\n    int numSquares(int n) {\\n\\n        vector<int> arr;\\n\\n        // find all the squares between 1 to n\\n\\n        for(int i = 1; i * i <= n; i++)\\n        {\\n            arr.push_back(i * i);\\n        }\\n\\n        // initialize dp with -1\\n\\n        memset(dp, -1, sizeof(dp));\\n\\n        return helper(arr, 0, arr.size(), n);\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "undefined methods",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    int dp[105][10005];\n    \n    int helper(int i, int n, int sum)\n    {\n        vector<int>& arr;\n\n        if(sum == 0)\n        {\n            return 0;\n        }\n\n        if(i >= n || sum < 0)\n        {\n            return INT_MAX - 1000;\n        }\n\n        if(dp[i][sum] != -1)\n        {\n            return dp[i][sum];\n        }\n\n        int mini = INT_MAX;\n\n        if(arr[i] <= sum)\n        {\n            mini = min(mini, 1 + helper(i, n, sum - arr[i]));\n        }\n\n        mini = min(mini, helper(i + 1, n, sum));\n\n        return dp[i][sum] = mini;\n    }\n\n    int numSquares(int n) {\n\n        vector<int> arr;\n\n        for(int i = 1; i * i <= n; i++)\n        {\n            arr.push_back(i * i);\n        }\n\n        memset(dp, -1his>initializeDP();\n\n        return helper(0, arr.size(), n);\n    }\n\n};\n"
    },
    {
        "slug": "longest-well-performing-interval",
        "description": "We are given hours, a list of the number of hours worked per day for a given employee.\nA day is considered to be a tiring day if and only if the number of hours worked is (strictly) greater than 8.\nA well-performing interval is an interval of days for which the number of tiring days is strictly larger than the number of non-tiring days.\nReturn the length of the longest well-performing interval.",
        "examples": [
            "Input: hours = [9,9,6,0,6,6,9]\nOutput: 3\nExplanation: The longest well-performing interval is [9,9,6].",
            "Input: hours = [6,6,6]\nOutput: 0"
        ],
        "constraints": "1 <= hours.length <= 104\n0 <= hours[i] <= 16",
        "oracle_code": "class Solution {\npublic:\n    int longestWPI(vector<int>& hours) {\n    map<int,int> mp;\n    int k=0,ans=0;\n    for(int i=0;i<hours.size();i++)\n    {\n        if(hours[i]>8)  k++; else   k--;\n        if(k>0)\n        {\n        ans=max(ans,i+1);\n        } else{\n            if(mp.find(k-1)!=mp.end()){\n                ans=max(ans,i-mp[k-1]);\n            }\n             if(mp.find(k)==mp.end()){\n                mp[k]=i;\n            }\n        }\n       \n    }    \n    return ans;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestWPI(vector<int>& hours) {\\n    map<int,int> mp;\\n    int k=0,ans=0;\\n    for(int i=0;i<hours.size();i++)\\n    {\\n        if(hours[i]>8)  k++; else   k--;\\n        if(k>0)\\n        {\\n        ans=max(ans,i+1);\\n        } else{\\n            if(mp.find(k-1)!=mp.end()){\\n                ans=max(ans,i-mp[k-1]);\\n            }\\n             if(mp.find(k)==mp.end()){\\n                mp[k]=i;\\n            }\\n        }\\n       \\n    }    \\n    return ans;\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "== and = confusion",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    int longestWPI(vector<int>& hours) {\n    dict<int,int> mp;\n    int k=0,ans=0;\n    for(int i=0;i<hours.size();i++)\n    {\n        if(hours[i] > 8)  k++; else   k--;\n        if(k > 0)\n        {\n        ans = max(ans,i+1);\n        } else{\n            if(mp.find(k-1) != mp.end()){\n                ans = max(ans,i-mp[k-1]);\n            }\n             if(mp.find(k) == mp.end()){\n                mp[k] == i; \n            }\n        }\n\n    }    \n    return ans;\n    }\n};\n"
    },
    {
        "slug": "sum-of-digits-of-string-after-convert",
        "description": "You are given a string s consisting of lowercase English letters, and an integer k.\nFirst, convert s into an integer by replacing each letter with its position in the alphabet (i.e., replace 'a' with 1, 'b' with 2, ..., 'z' with 26). Then, transform the integer by replacing it with the sum of its digits. Repeat the transform operation k times in total.\nFor example, if s = \"zbax\" and k = 2, then the resulting integer would be 8 by the following operations:\n\nConvert: \"zbax\" \u279d \"(26)(2)(1)(24)\" \u279d \"262124\" \u279d 262124\nTransform #1: 262124 \u279d 2 + 6 + 2 + 1 + 2 + 4\u00a0\u279d 17\nTransform #2: 17 \u279d 1 + 7 \u279d 8\n\nReturn the resulting integer after performing the operations described above.",
        "examples": [
            "Input: s = \"iiii\", k = 1\nOutput: 36\nExplanation: The operations are as follows:\n- Convert: \"iiii\" \u279d \"(9)(9)(9)(9)\" \u279d \"9999\" \u279d 9999\n- Transform #1: 9999 \u279d 9 + 9 + 9 + 9 \u279d 36\nThus the resulting integer is 36.",
            "Input: s = \"leetcode\", k = 2\nOutput: 6\nExplanation: The operations are as follows:\n- Convert: \"leetcode\" \u279d \"(12)(5)(5)(20)(3)(15)(4)(5)\" \u279d \"12552031545\" \u279d 12552031545\n- Transform #1: 12552031545 \u279d 1 + 2 + 5 + 5 + 2 + 0 + 3 + 1 + 5 + 4 + 5 \u279d 33\n- Transform #2: 33 \u279d 3 + 3 \u279d 6\nThus the resulting integer is 6.",
            "Input: s = \"zbax\", k = 2\nOutput: 8"
        ],
        "constraints": "1 <= s.length <= 100\n1 <= k <= 10\ns consists of lowercase English letters.",
        "oracle_code": "class Solution {\npublic:\n    int sumDigits(int num) {\n        int sum = 0;\n        while(num) {\n            sum += num%10;\n            num /= 10;\n        }\n        return sum;\n    }\n    \n    int getLucky(string s, int k) {\n        int sum = 0 ; \n        for(auto it: s){\n            int value = it - 'a' + 1;\n            if(value>=10){\n                sum+= value%10 + value/10; //since digit is two place only and we need all the digits(_ _)\n            }else\n                sum = sum + value; \n        }\n\n        k--;//since I did the sum once;\n        while(k-- && sum>=10){//furthur trasformations starts here\n            sum = sumDigits(sum);\n        } \n        return sum;\n    }\n};",
        "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. apne ko firstly har ek char se iterate karke unki value nikalni hogi\\n2. value agar double digits me aaya to usko bhi single me tod ke sum me add kar deinge\\n3. since yehi chiz upto k=0 tak karni paregi to ek function bana ke kar leinge aur sum return kara deinge\\nNote: As hamne ek baar wo sum nikal liya hai therefore k--;\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int sumDigits(int num) {\\n        int sum = 0;\\n        while(num) {\\n            sum += num%10;\\n            num /= 10;\\n        }\\n        return sum;\\n    }\\n    \\n    int getLucky(string s, int k) {\\n        int sum = 0 ; \\n        for(auto it: s){\\n            int value = it - \\'a\\' + 1;\\n            if(value>=10){\\n                sum+= value%10 + value/10; //since digit is two place only and we need all the digits(_ _)\\n            }else\\n                sum = sum + value; \\n        }\\n\\n        k--;//since I did the sum once;\\n        while(k-- && sum>=10){//furthur trasformations starts here\\n            sum = sumDigits(sum);\\n        } \\n        return sum;\\n    }\\n};\\n```\\n\\n\\n![upvote.jpg](https://assets.leetcode.com/users/images/0593cc08-ec64-46b3-bb36-81ecef0ce934_1690867154.0542114.jpeg)\\n",
        "level": "easy",
        "type": [
            "unclosed string",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    int sumDigits(int num) {\n        int sum = 0;\n        while(num) {\n            sum += num%10;\n            num /= 10;\n        }\n        return sum;\n    }\n    \n    int getLucky(string s, int k) {\n        int sum = 0 ; \n        for(auto it: s){\n            int value = it - 'a' + 1;\n            if(value>=10){\n                sum+= value%10 + value/10; \n            }else\n                sum = sum + \"value\"; \n        }\n\n        k--;//since I did the sum once;\n        while((k-- && sum>=10))\n            sum = sumDigits(sum;\n        } \n        return sum;\n    }\n};\n"
    },
    {
        "slug": "lru-cache",
        "description": "Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.\nImplement the LRUCache class:\n\nLRUCache(int capacity) Initialize the LRU cache with positive size capacity.\nint get(int key) Return the value of the key if the key exists, otherwise return -1.\nvoid put(int key, int value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key.\n\nThe functions get and put must each run in O(1) average time complexity.",
        "examples": [
            "Input\n[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"]\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\nOutput\n[null, null, null, 1, null, -1, null, -1, 3, 4]\n\nExplanation\nLRUCache lRUCache = new LRUCache(2);\nlRUCache.put(1, 1); // cache is {1=1}\nlRUCache.put(2, 2); // cache is {1=1, 2=2}\nlRUCache.get(1);    // return 1\nlRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}\nlRUCache.get(2);    // returns -1 (not found)\nlRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}\nlRUCache.get(1);    // return -1 (not found)\nlRUCache.get(3);    // return 3\nlRUCache.get(4);    // return 4"
        ],
        "constraints": "1 <= capacity <= 3000\n0 <= key <= 104\n0 <= value <= 105\nAt most 2 * 105 calls will be made to get and put.",
        "oracle_code": "class LRUCache {\npublic:\nclass node\n{\n  public:\n  int key;\n  int val;\n  node* next;\n  node* prev;\n  node(int _key,int _val)\n  {\n    key = _key;\n    val = _val;\n  }\n};\nnode* head = new node(-1,-1);\nnode* tail = new node(-1,-1);\n\nint size;\nunordered_map<int,node*>mpp;\n    LRUCache(int capacity) {\n       size = capacity; \n       head->next = tail;\n       tail->prev = head;  \n    }\n\n    void addNode(node* newNode){\n       \n       node* temp = head->next;\n       newNode->next = temp;\n       newNode->prev = head;\n       head->next = newNode;\n       temp->prev = newNode;\n    }\n\n    void deleteNode(node* delNode){\n         \n       node* delprev = delNode->prev;\n       node* delnext = delNode->next;\n       delprev->next = delnext;\n       delnext->prev = delprev;\n    }\n    \n    int get(int _key) {\n        \n        if(mpp.count(_key))\n        {\n          node* nde = mpp[_key];\n          int curr = nde->val;\n          mpp.erase(_key);\n          deleteNode(nde);\n          addNode(nde);\n          mpp[_key] = head->next;\n          return curr;\n        }\n        return -1;\n    }\n    \n    void put(int _key, int value) {\n        \n        if(mpp.count(_key))\n        {\n           node* nde = mpp[_key];\n           mpp.erase(_key);\n           deleteNode(nde);\n        }\n        if(mpp.size()==size)\n        {\n           mpp.erase(tail->prev->key);\n           deleteNode(tail->prev);\n        }\n        addNode(new node(_key,value));\n        mpp[_key] = head->next;\n    }\n};",
        "content": "# PLEASE DO UPVOTE!!!!!\\n\\n**CONNECT WITH ME ON LINKEDIN :  https://www.linkedin.com/in/md-kamran-55b98521a/**\\n\\n## INTUITION\\nTo Implement LRU(Least recently used), we need to have a track of the usage of the keys, in the order of there usage, as we have a limited capacity we cant extend our capacity beyond \"capacity\", so we always we will take out those values which has\\'nt been acccess in the recent time.So, we have to think of something that can kind of sort our keys according to usage on the go, the best Data Structure for this purpose is Doubly linked List.\\n                             A Doubly linked list will have a Head node as well as a tail node, and whenever a key is used we will place it just next to the head node,in this fashions, the one\\'s which are closer to head are the most recently used ones, and as we go closer to the tail node, those are the less recently used ones while the node just previous to tail is the \"LEAST RECENTLY USED\". \\nSo whenever we add a key or use a key(get()), we will move it right after the head node, and whenever we call the (put() function), if size if greater we have to delete the LRU node, if key is not present, (if present then too we will delete that node so as to update the value and still move it right after head node), and place new node right after head node.                        \\n\\n\\n**Ask Furthur Doubts in the Comment Section**\\n# Code\\n```\\nclass LRUCache {\\npublic:\\nclass node\\n{\\n  public:\\n  int key;\\n  int val;\\n  node* next;\\n  node* prev;\\n  node(int _key,int _val)\\n  {\\n    key = _key;\\n    val = _val;\\n  }\\n};\\nnode* head = new node(-1,-1);\\nnode* tail = new node(-1,-1);\\n\\nint size;\\nunordered_map<int,node*>mpp;\\n    LRUCache(int capacity) {\\n       size = capacity; \\n       head->next = tail;\\n       tail->prev = head;  \\n    }\\n\\n    void addNode(node* newNode){\\n       \\n       node* temp = head->next;\\n       newNode->next = temp;\\n       newNode->prev = head;\\n       head->next = newNode;\\n       temp->prev = newNode;\\n    }\\n\\n    void deleteNode(node* delNode){\\n         \\n       node* delprev = delNode->prev;\\n       node* delnext = delNode->next;\\n       delprev->next = delnext;\\n       delnext->prev = delprev;\\n    }\\n    \\n    int get(int _key) {\\n        \\n        if(mpp.count(_key))\\n        {\\n          node* nde = mpp[_key];\\n          int curr = nde->val;\\n          mpp.erase(_key);\\n          deleteNode(nde);\\n          addNode(nde);\\n          mpp[_key] = head->next;\\n          return curr;\\n        }\\n        return -1;\\n    }\\n    \\n    void put(int _key, int value) {\\n        \\n        if(mpp.count(_key))\\n        {\\n           node* nde = mpp[_key];\\n           mpp.erase(_key);\\n           deleteNode(nde);\\n        }\\n        if(mpp.size()==size)\\n        {\\n           mpp.erase(tail->prev->key);\\n           deleteNode(tail->prev);\\n        }\\n        addNode(new node(_key,value));\\n        mpp[_key] = head->next;\\n    }\\n};\\n\\n```\\n![b62ab1be-232a-438f-9524-7d8ca4dbd5fe_1675328166.1161866.png](https://assets.leetcode.com/users/images/8d5343b1-0eb4-4111-a914-40ce968fd034_1675389764.2273676.png)",
        "level": "medium",
        "type": [
            "variable value error",
            "colon missing"
        ],
        "buggy_code": "\nclass LRUCache {\npublic:\nclass node\n{\n  public:\n  int key;\n  int val;\n  node* next;\n  node* prev;\n  node(int _key,int _val)\n  {\n    key = _key;\n    val = _val;\n  }\n};\nnode* head = new node(-1,-1);\nnode* tail = new node(-1,-1);\n\nint size;\nunordered_map<int,node*>mpp;\n    LRUCache(int capacity) {\n       size = capacity; \n       head->next = tail;\n       tail->prev = head;  \n    }\n\n    void addNode(node* newNode){\n       \n       node* temp = head->next;\n       newNode->next = temp;\n       newNode->prev = head;\n       head->next = newNode;\n    }\n\n    void deleteNode(node* delNode){\n         \n       node* delprev = delNode->prev;\n       node* delnext = delNode->next;\n       delprev->next = delnext;\n       delnext->prev = delprev;\n    }\n    \n    int get(int _key) {\n        \n        if(mpp.count(_key))\n        {\n          node* nde = mpp[_key];\n          int curr = nde->val;\n          mpp.erase(_key);\n          deleteNode(nde);\n          addNode(nde)\n          mpp[_key] = head->next;\n          return curr;\n        }\n        return -1;\n    }\n    \n    void put(int _key, int value) {\n        \n        if(mpp.count(_key))\n        {\n           node* nde = mpp[_key];\n           mpp.erase(_key);\n           deleteNode(nde);\n        }\n        if(mpp.size()==size)\n        {\n           mpp.erase(tail->prev->key);\n           deleteNode(tail->prev);\n        }\n        addNode(new node(_key,value));\n        mpp[_key] = tail->next;\n    }\n};\n"
    },
    {
        "slug": "relative-ranks",
        "description": "You are given an integer array score of size n, where score[i] is the score of the ith athlete in a competition. All the scores are guaranteed to be unique.\nThe athletes are placed based on their scores, where the 1st place athlete has the highest score, the 2nd place athlete has the 2nd highest score, and so on. The placement of each athlete determines their rank:\n\nThe 1st place athlete's rank is \"Gold Medal\".\nThe 2nd place athlete's rank is \"Silver Medal\".\nThe 3rd place athlete's rank is \"Bronze Medal\".\nFor the 4th place to the nth place athlete, their rank is their placement number (i.e., the xth place athlete's rank is \"x\").\n\nReturn an array answer of size n where answer[i] is the rank of the ith athlete.",
        "examples": [
            "Input: score = [5,4,3,2,1]\nOutput: [\"Gold Medal\",\"Silver Medal\",\"Bronze Medal\",\"4\",\"5\"]\nExplanation: The placements are [1st, 2nd, 3rd, 4th, 5th].",
            "Input: score = [10,3,8,9,4]\nOutput: [\"Gold Medal\",\"5\",\"Bronze Medal\",\"Silver Medal\",\"4\"]\nExplanation: The placements are [1st, 5th, 3rd, 2nd, 4th]."
        ],
        "constraints": "n == score.length\n1 <= n <= 104\n0 <= score[i] <= 106\nAll the values in score are unique.",
        "oracle_code": "class Solution {\npublic:\n    vector<string> findRelativeRanks(vector<int>& score) {\n        int n = score.size();\n        \n        vector<pair<int, int>> arr;\n        for (int i=0; i<n; i++) arr.push_back({score[i], i});\n\n        sort(rbegin(arr), rend(arr));\n\n        vector<string> res(n);\n        for (int i=0; i<n; i++) \n            res[arr[i].second] = i==0? \"Gold Medal\": (i==1? \"Silver Medal\": (i==2? \"Bronze Medal\": to_string(i+1)));\n\n        return res;\n    }\n};",
        "content": "**vector solution**\\n```\\nclass Solution {\\npublic:\\n    vector<string> findRelativeRanks(vector<int>& score) {\\n        int n = score.size();\\n        \\n        vector<pair<int, int>> arr;\\n        for (int i=0; i<n; i++) arr.push_back({score[i], i});\\n\\n        sort(rbegin(arr), rend(arr));\\n\\n        vector<string> res(n);\\n        for (int i=0; i<n; i++) \\n            res[arr[i].second] = i==0? \"Gold Medal\": (i==1? \"Silver Medal\": (i==2? \"Bronze Medal\": to_string(i+1)));\\n\\n        return res;\\n    }\\n};\\n```\\n---\\n**priority queue solution**\\n```\\nclass Solution {\\npublic:\\n    vector<string> findRelativeRanks(vector<int>& score) {\\n        int n = score.size();\\n        \\n        priority_queue< pair<int, int>, vector<pair<int,int>> > pq;\\n        for (int i=0; i<n; i++) pq.push({score[i], i});\\n\\n        vector<string> res(n);\\n        while (!pq.empty()) {\\n            auto x = pq.top();\\n            int size = pq.size();\\n            res[x.second] = (size == n? \"Gold Medal\": (size == n-1? \"Silver Medal\": (size == n-2? \"Bronze Medal\": to_string(n-size+1))));\\n            pq.pop();\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "other error",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    vector<string> findRelativeRanks(vector<int>& score) {\n        int n = score.size();\n        \n        vector<pair<int, int>> arr;\n        for (int i=0; i<n; i++) arr.push_back({score[i], i});\n\n        sort(rbegin(arr), rend(arr));\n        \n        vector<string> rank;\n\n        for (int i=0; i<n; i++) \n            rank[arr[i].second] = i==0? \"Gold Medal\": (i==1? \"Silver Medal\": (i==2? \"Bronze Medal\": to_string(i+1)));\n\n        res[arr[0].second] = \"LeanBack Medal\";\n        return rank;\n    }\n};\n"
    },
    {
        "slug": "widest-vertical-area-between-two-points-containing-no-points",
        "description": "Given n points on a 2D plane where points[i] = [xi, yi], Return\u00a0the widest vertical area between two points such that no points are inside the area.\nA vertical area is an area of fixed-width extending infinitely along the y-axis (i.e., infinite height). The widest vertical area is the one with the maximum width.\nNote that points on the edge of a vertical area are not considered included in the area.",
        "examples": [
            "\u200b\n\nInput: points = [[8,7],[9,9],[7,4],[9,7]]\nOutput: 1\nExplanation: Both the red and the blue area are optimal.",
            "Input: points = [[3,1],[9,0],[1,0],[1,4],[5,3],[8,8]]\nOutput: 3"
        ],
        "constraints": "n == points.length\n2 <= n <= 105\npoints[i].length == 2\n0 <= xi, yi\u00a0<= 109",
        "oracle_code": "class Solution {\npublic:\n  int maxWidthOfVerticalArea(vector<vector<int>>& points) {\n    set<int> x;\n    int res = 0;\n    for (auto &p : points)\n        x.insert(p[0]);\n    for (auto it = next(begin(x)); it != end(x); ++it)\n        res = max(res, *it - *prev(it));\n    return res;\n}\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  int maxWidthOfVerticalArea(vector<vector<int>>& points) {\\n    set<int> x;\\n    int res = 0;\\n    for (auto &p : points)\\n        x.insert(p[0]);\\n    for (auto it = next(begin(x)); it != end(x); ++it)\\n        res = max(res, *it - *prev(it));\\n    return res;\\n}\\n};\\n```",
        "level": "medium",
        "type": [
            "indexing error",
            "wrong comment mark"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n  int maxWidthOfVerticalArea(vector<vector<int>>& points) /*\n    set<int> x;\n    int res = 0;\n    for (auto &p : points)\n        x.insert(p[2]);\n    for (auto it = next(begin(x)); it != end(x); ++it)\n        res = max(res, *it - *prev(it));\n    return res;\n}\n*/;\n"
    },
    {
        "slug": "kth-largest-element-in-a-stream",
        "description": "Design a class to find the kth largest element in a stream. Note that it is the kth largest element in the sorted order, not the kth distinct element.\nImplement KthLargest class:\n\nKthLargest(int k, int[] nums) Initializes the object with the integer k and the stream of integers nums.\nint add(int val) Appends the integer val to the stream and returns the element representing the kth largest element in the stream.",
        "examples": [
            "Input\n[\"KthLargest\", \"add\", \"add\", \"add\", \"add\", \"add\"]\n[[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]\nOutput\n[null, 4, 5, 5, 8, 8]\n\nExplanation\nKthLargest kthLargest = new KthLargest(3, [4, 5, 8, 2]);\nkthLargest.add(3);   // return 4\nkthLargest.add(5);   // return 5\nkthLargest.add(10);  // return 5\nkthLargest.add(9);   // return 8\nkthLargest.add(4);   // return 8"
        ],
        "constraints": "1 <= k <= 104\n0 <= nums.length <= 104\n-104 <= nums[i] <= 104\n-104 <= val <= 104\nAt most 104 calls will be made to add.\nIt is guaranteed that there will be at least k elements in the array when you search for the kth element.",
        "oracle_code": "class KthLargest {\npublic:\n    priority_queue<int,vector<int>,greater<int>> pq;\n    int position;\n    KthLargest(int k, vector<int>& nums) {\n        position=k;\n        for(int i=0; i<nums.size(); i++){\n            if(pq.size()<k){\n                pq.push(nums[i]);\n            }\n            else if(pq.top()<nums[i]){\n                pq.pop();\n                pq.push(nums[i]);\n            }\n        }\n    }\n    \n    int add(int val) {\n        if(pq.size()<position){\n            pq.push(val);\n        }\n        else if(pq.top()<val){\n            pq.pop();\n            pq.push(val);\n        }\n        return pq.top();\n    }\n};\n\n/**\n * Your KthLargest object will be instantiated and called as such:\n * KthLargest* obj = new KthLargest(k, nums);\n * int param_1 = obj->add(val);\n */",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass KthLargest {\\npublic:\\n    priority_queue<int,vector<int>,greater<int>> pq;\\n    int position;\\n    KthLargest(int k, vector<int>& nums) {\\n        position=k;\\n        for(int i=0; i<nums.size(); i++){\\n            if(pq.size()<k){\\n                pq.push(nums[i]);\\n            }\\n            else if(pq.top()<nums[i]){\\n                pq.pop();\\n                pq.push(nums[i]);\\n            }\\n        }\\n    }\\n    \\n    int add(int val) {\\n        if(pq.size()<position){\\n            pq.push(val);\\n        }\\n        else if(pq.top()<val){\\n            pq.pop();\\n            pq.push(val);\\n        }\\n        return pq.top();\\n    }\\n};\\n\\n/**\\n * Your KthLargest object will be instantiated and called as such:\\n * KthLargest* obj = new KthLargest(k, nums);\\n * int param_1 = obj->add(val);\\n */\\n```",
        "level": "easy",
        "type": [
            "indexing error",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass KthLargest {\npublic:\n    priority_queue<int,vector<int>,greater<int>> pq;\n    int position;\n    KthLargest(int k, vector<int>& nums) {\n        position=k;\n        for(int i=0; i<=nums.size(); i++){\n            if(pq.size()<k){\n                pq.push(nums[i]);\n            }\n            else if(pq.top()<nums[i]){\n                pq.pop();\n                pq.push(nums[i]);\n            }\n        }\n    }\n    \n    int add(int val) {\n        if(pq.size()<position){\n            pq.push(val);\n        else if(pq.top()<val){\n            pq.pop();\n            pq.push(val);\n        }\n        return pq.top();\n    }\n};\n\n"
    },
    {
        "slug": "min-cost-climbing-stairs",
        "description": "You are given an integer array cost where cost[i] is the cost of ith step on a staircase. Once you pay the cost, you can either climb one or two steps.\nYou can either start from the step with index 0, or the step with index 1.\nReturn the minimum cost to reach the top of the floor.",
        "examples": [
            "Input: cost = [10,15,20]\nOutput: 15\nExplanation: You will start at index 1.\n- Pay 15 and climb two steps to reach the top.\nThe total cost is 15.",
            "Input: cost = [1,100,1,1,1,100,1,1,100,1]\nOutput: 6\nExplanation: You will start at index 0.\n- Pay 1 and climb two steps to reach index 2.\n- Pay 1 and climb two steps to reach index 4.\n- Pay 1 and climb two steps to reach index 6.\n- Pay 1 and climb one step to reach index 7.\n- Pay 1 and climb two steps to reach index 9.\n- Pay 1 and climb one step to reach the top.\nThe total cost is 6."
        ],
        "constraints": "2 <= cost.length <= 1000\n0 <= cost[i] <= 999",
        "oracle_code": "class Solution {\npublic:\n    int minCostClimbingStairs(vector<int>& cost) {\n        int n = cost.size();\n\n        for(int i=2; i<n; i++){\n            cost[i] = min(cost[i-1],cost[i-2]) + cost[i];\n        }\n\n        return min(cost[n-1],cost[n-2]);\n    }\n};",
        "content": "\\n# Approach\\nDynamic Programming without using any extra memory. Modifying the given array itself.\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minCostClimbingStairs(vector<int>& cost) {\\n        int n = cost.size();\\n\\n        for(int i=2; i<n; i++){\\n            cost[i] = min(cost[i-1],cost[i-2]) + cost[i];\\n        }\\n\\n        return min(cost[n-1],cost[n-2]);\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "conditional statement error",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    int minCostClimbingStairs(vector<int>& cost) {\n        int n = len(cost);\n\n        for(int i=2; i<=n; i++){\n            cost[i] = min(cost[i-1],cost[i-2]) + cost[i];\n        }\n\n        return min(cost[n-1],cost[n-2]);\n    }\n};\n"
    },
    {
        "slug": "shortest-bridge",
        "description": "You are given an n x n binary matrix grid where 1 represents land and 0 represents water.\nAn island is a 4-directionally connected group of 1's not connected to any other 1's. There are exactly two islands in grid.\nYou may change 0's to 1's to connect the two islands to form one island.\nReturn the smallest number of 0's you must flip to connect the two islands.",
        "examples": [
            "Input: grid = [[0,1],[1,0]]\nOutput: 1",
            "Input: grid = [[0,1,0],[0,0,0],[0,0,1]]\nOutput: 2",
            "Input: grid = [[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]]\nOutput: 1"
        ],
        "constraints": "n == grid.length == grid[i].length\n2 <= n <= 100\ngrid[i][j] is either 0 or 1.\nThere are exactly two islands in grid.",
        "oracle_code": "class Solution {\npublic:\n\nint r[4] = {-1 , 0, 1, 0};\nint c[4] = {0 ,1 , 0 , -1};\n\nvoid dfs(int row ,int col , vector<pair<int,int>> &v,vector<vector<int>>&vis,vector<vector<int>>&grid)\n{\n    int n = vis[0].size();\n    vis[row][col] = 1;\n    v.push_back({row , col});\n    for(int i=0; i<4; i++)\n    {\n        int nrow = row + r[i];\n        int ncol = col + c[i];\n\n        if(nrow>=0 and ncol>=0 and nrow<n and ncol<n and vis[nrow][ncol] == 0 and grid[nrow][ncol] == 1)\n        {\n            dfs(nrow , ncol , v , vis , grid);\n        }\n    }\n\n}\n\n    int shortestBridge(vector<vector<int>>& grid) {\n        \n        vector<pair<int,int>> v;\n        vector<pair<int,int>> v1;\n        vector<pair<int,int>> v2;\n        int n = grid.size();\n        vector<vector<int>> vis(n , vector<int>(n , 0));\n        bool flag = 0;\n        for(int i=0; i<n; i++)\n        {\n            for(int j=0; j<n; j++)\n            {\n                if(grid[i][j] == 1 and vis[i][j] == 0)\n                {\n                    dfs(i , j , v , vis, grid);\n                    if(flag == 0)\n                    {\n                        v1 = v;\n                        flag = 1;\n                        v.clear();\n                    }\n                    else\n                    {\n                        v2 = v;\n                    }\n                }\n            \n            }\n           \n        }\n        //printed just to check the co-ordinates****\n        //for(auto it: v1)\n        //{\n        //    cout<<it.first<<\" \"<<it.second<<endl;\n        //}\n        //for(auto it: v2)\n        //{\n        //    cout<<it.first<<\" \"<<it.second<<endl;\n        //}\n        int ans = 1e9;\n\n\n        for(auto it: v1)\n        {\n            int row1 = it.first;\n            int col1 = it.second;\n\n            for(auto itt: v2)\n            {\n                int row2 = itt.first;\n                int col2 = itt.second;\n\n                int dist = abs(row1 - row2) + abs(col1 - col2);\n                dist--;\n                ans = min(ans , dist);\n            }\n        }\n    \n        return ans;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nsimple push all the co-ordinates of the first and second island in two vectors by using dfs and then just calculate the distance between each point to every other point in both the vectors and since n is very small we will not get tle and this solution is accepted.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n**1.Push all the co-ordinates of the first and second island in two vectors\\n2.then calculate the distance between each point to every point \\n3.take the minimum distance \\n4.return the minimum distance**\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\ncomment time complexity in comments \\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\ncomment space complexity in comments \\n# Code\\n```\\nclass Solution {\\npublic:\\n\\nint r[4] = {-1 , 0, 1, 0};\\nint c[4] = {0 ,1 , 0 , -1};\\n\\nvoid dfs(int row ,int col , vector<pair<int,int>> &v,vector<vector<int>>&vis,vector<vector<int>>&grid)\\n{\\n    int n = vis[0].size();\\n    vis[row][col] = 1;\\n    v.push_back({row , col});\\n    for(int i=0; i<4; i++)\\n    {\\n        int nrow = row + r[i];\\n        int ncol = col + c[i];\\n\\n        if(nrow>=0 and ncol>=0 and nrow<n and ncol<n and vis[nrow][ncol] == 0 and grid[nrow][ncol] == 1)\\n        {\\n            dfs(nrow , ncol , v , vis , grid);\\n        }\\n    }\\n\\n}\\n\\n    int shortestBridge(vector<vector<int>>& grid) {\\n        \\n        vector<pair<int,int>> v;\\n        vector<pair<int,int>> v1;\\n        vector<pair<int,int>> v2;\\n        int n = grid.size();\\n        vector<vector<int>> vis(n , vector<int>(n , 0));\\n        bool flag = 0;\\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=0; j<n; j++)\\n            {\\n                if(grid[i][j] == 1 and vis[i][j] == 0)\\n                {\\n                    dfs(i , j , v , vis, grid);\\n                    if(flag == 0)\\n                    {\\n                        v1 = v;\\n                        flag = 1;\\n                        v.clear();\\n                    }\\n                    else\\n                    {\\n                        v2 = v;\\n                    }\\n                }\\n            \\n            }\\n           \\n        }\\n        //printed just to check the co-ordinates****\\n        //for(auto it: v1)\\n        //{\\n        //    cout<<it.first<<\" \"<<it.second<<endl;\\n        //}\\n        //for(auto it: v2)\\n        //{\\n        //    cout<<it.first<<\" \"<<it.second<<endl;\\n        //}\\n        int ans = 1e9;\\n\\n\\n        for(auto it: v1)\\n        {\\n            int row1 = it.first;\\n            int col1 = it.second;\\n\\n            for(auto itt: v2)\\n            {\\n                int row2 = itt.first;\\n                int col2 = itt.second;\\n\\n                int dist = abs(row1 - row2) + abs(col1 - col2);\\n                dist--;\\n                ans = min(ans , dist);\\n            }\\n        }\\n    \\n        return ans;\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "unclosed string",
            "variable value error"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n\nint r[4] = {-1 , 0, 1, 0};\nint c[4] = {0 ,1 , 0 , -1};\n\nvoid dfs(int row ,int col , vector<pair<int,int>> &v,vector<vector<int>>&vis,vector<vector<int>>&grid)\n{\n    int n = grid[0].size();\n    vis[row][col] = 1;\n    v.push_back({row , col});\n    for(int i=0; i<4; i++)\n    {\n        int nrow = row + r[i];\n        int ncol = col + c[i];\n\n        if(nrow>=0 and ncol>=0 and nrow<n and ncol<n and vis[nrow][ncol] == 0 and grid[nrow][ncol] == 1)\n        {\n            dfs(nrow , ncol , v , vis , grid);\n        }\n    }\n\n}\n\n    int shortestBridge(vector<vector<int>>& grid) {\n        \n        vector<pair<int,int>> v;\n        vector<pair<int,int>> v1;\n        vector<pair<int,int>> v2;\n        int n = grid.size();\n        vector<vector<int>> vis(n , vector<int>(n , 0));\n        bool flag = 0;\n        for(int i=0; i<n; i++)\n        {\n            for(int j=0; j<n; j++)\n            {\n                if(grid[i][j] == 1 and vis[i][j] == 0)\n                {\n                    dfs(i , j , v , vis, grid);\n                    if(flag == 0)\n                    {\n                        v1 = v;\n                        flag = 1;\n                        v.clear();\n                    }\n                    else\n                    {\n                        v2 = v;\n                    }\n                }\n            \n            }\n           \n        }\n\n        int ans = 1e9;\n        string outans = 1e9;\n\n\n        for(au=\"stbridgeis:\"\n\n    to it: v1)\n        {\n            int row1 = it.first;\n            int col1 = it.second;\n\n            for(auto itt: v2)\n            {\n                int row2 = itt.first;\n                int col2 = itt.second;\n\n                int dist = abs(row1 - row2)+ab(col1-);\n                ans = min(ans , dist);\n            }\n        }\n    \n        return ans;\n    }\n};\n"
    },
    {
        "slug": "shortest-path-with-alternating-colors",
        "description": "You are given an integer n, the number of nodes in a directed graph where the nodes are labeled from 0 to n - 1. Each edge is red or blue in this graph, and there could be self-edges and parallel edges.\nYou are given two arrays redEdges and blueEdges where:\n\nredEdges[i] = [ai, bi] indicates that there is a directed red edge from node ai to node bi in the graph, and\nblueEdges[j] = [uj, vj] indicates that there is a directed blue edge from node uj to node vj in the graph.\n\nReturn an array answer of length n, where each answer[x] is the length of the shortest path from node 0 to node x such that the edge colors alternate along the path, or -1 if such a path does not exist.",
        "examples": [
            "Input: n = 3, redEdges = [[0,1],[1,2]], blueEdges = []\nOutput: [0,1,-1]",
            "Input: n = 3, redEdges = [[0,1]], blueEdges = [[2,1]]\nOutput: [0,1,-1]"
        ],
        "constraints": "1 <= n <= 100\n0 <= redEdges.length,\u00a0blueEdges.length <= 400\nredEdges[i].length == blueEdges[j].length == 2\n0 <= ai, bi, uj, vj < n",
        "oracle_code": "class Solution {\npublic:\n    vector<int> shortestAlternatingPaths(int n,vector<vector<int>>&redEdges,vector<vector<int>>& blueEdges) \n    {\n        multiset<int>temp;\n        vector<multiset<int>>redchilds(n,temp),bluechilds(n,temp);\n        for(auto j:redEdges)\n        {\n            redchilds[j[0]].insert(j[1]);\n        }\n        for(auto j:blueEdges)\n        {\n            bluechilds[j[0]].insert(j[1]);\n        }\n        vector<int>ans;\n        for(int i=0;i<n;i++)\n        {\n            //BFS for all\n            vector<multiset<int>>reds=redchilds,blues=bluechilds;\n            queue<pair<char,int>>visit;\n            visit.push({'n',0});//neutral='n'\n            int steps=0;\n            while(!visit.empty())\n            {\n                bool justbreak=false;\n                int n=visit.size();\n                for(int j=0;j<n;j++)\n                {\n                    pair<char,int>x=visit.front();\n                    visit.pop();\n                    if(x.second==i)\n                    {\n                        ans.push_back(steps);\n                        justbreak=true;\n                        break;\n                    }\n                    if(x.first=='n')\n                    {\n                        for(auto j:reds[x.second])\n                        {\n                            visit.push({'r',j});\n                            auto itr1=reds[x.second].find(j);\n                            reds[x.second].erase(itr1);\n                        }\n                        for(auto j:blues[x.second])\n                        {\n                            visit.push({'b',j});//blue='b'\n                            auto itr1=blues[x.second].find(j);\n                            blues[x.second].erase(itr1);\n                        }\n                    }\n                    else if(x.first=='b')\n                    {\n                        for(auto j:reds[x.second])\n                        {\n                            visit.push({'r',j});//red='r'\n                            auto itr1=reds[x.second].find(j);\n                            reds[x.second].erase(itr1);\n                        }\n                    }\n                    else if(x.first=='r')\n                    {\n                        for(auto j:blues[x.second])\n                        {\n                            visit.push({'b',j});\n                            auto itr1=blues[x.second].find(j);\n                            blues[x.second].erase(itr1);\n                        }\n                    }\n                }\n                if(justbreak)\n                {\n                    break;\n                }\n                steps++;\n            }\n            if(i==ans.size())\n            {\n                ans.push_back(-1);\n            }\n        }\n        return ans;\n    }\n};",
        "content": "*E denotes number of Edges*\\n\\n# Complexity\\n- Time complexity:\\nO((N^2)+(N)*(E)*LOG(E))\\n\\n- Space complexity:\\nO(E)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> shortestAlternatingPaths(int n,vector<vector<int>>&redEdges,vector<vector<int>>& blueEdges) \\n    {\\n        multiset<int>temp;\\n        vector<multiset<int>>redchilds(n,temp),bluechilds(n,temp);\\n        for(auto j:redEdges)\\n        {\\n            redchilds[j[0]].insert(j[1]);\\n        }\\n        for(auto j:blueEdges)\\n        {\\n            bluechilds[j[0]].insert(j[1]);\\n        }\\n        vector<int>ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            //BFS for all\\n            vector<multiset<int>>reds=redchilds,blues=bluechilds;\\n            queue<pair<char,int>>visit;\\n            visit.push({\\'n\\',0});//neutral=\\'n\\'\\n            int steps=0;\\n            while(!visit.empty())\\n            {\\n                bool justbreak=false;\\n                int n=visit.size();\\n                for(int j=0;j<n;j++)\\n                {\\n                    pair<char,int>x=visit.front();\\n                    visit.pop();\\n                    if(x.second==i)\\n                    {\\n                        ans.push_back(steps);\\n                        justbreak=true;\\n                        break;\\n                    }\\n                    if(x.first==\\'n\\')\\n                    {\\n                        for(auto j:reds[x.second])\\n                        {\\n                            visit.push({\\'r\\',j});\\n                            auto itr1=reds[x.second].find(j);\\n                            reds[x.second].erase(itr1);\\n                        }\\n                        for(auto j:blues[x.second])\\n                        {\\n                            visit.push({\\'b\\',j});//blue=\\'b\\'\\n                            auto itr1=blues[x.second].find(j);\\n                            blues[x.second].erase(itr1);\\n                        }\\n                    }\\n                    else if(x.first==\\'b\\')\\n                    {\\n                        for(auto j:reds[x.second])\\n                        {\\n                            visit.push({\\'r\\',j});//red=\\'r\\'\\n                            auto itr1=reds[x.second].find(j);\\n                            reds[x.second].erase(itr1);\\n                        }\\n                    }\\n                    else if(x.first==\\'r\\')\\n                    {\\n                        for(auto j:blues[x.second])\\n                        {\\n                            visit.push({\\'b\\',j});\\n                            auto itr1=blues[x.second].find(j);\\n                            blues[x.second].erase(itr1);\\n                        }\\n                    }\\n                }\\n                if(justbreak)\\n                {\\n                    break;\\n                }\\n                steps++;\\n            }\\n            if(i==ans.size())\\n            {\\n                ans.push_back(-1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "wrong comment mark",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    vector<int> shortestAlternatingPaths(int n,vector<vector<int>>&redEdges,vector<vector<int>>& blueEdges) \n    {\n        multiset<int>temp;\n        vector<multiset<int>>redchilds(n,temp),bluechilds(n,temp);\n        for(auto j:redEdges)\n        {\n            redchilds[j[0]].insert(j[1]);\n        }\n        for(auto j:blueEdges)\n        {\n            bluechilds[j[0]].insert(j[1]);\n        }\n        vector<int>ans;\n        for(int i=0;i<n;i++)\n        {\n            //BFS for all\n            vector<multiset<int>>reds=redchilds,blues=bluechilds;\n            queue<pair<char,int>>visit;\n            visit.push({'n',0});//neutral='n'\n            int steps=0;\n            while(!visit.empty()\n            {\n                bool justbreak=false;\n                int n=visit.size();\n                for(int j=0;j<n;j++)\n                {\n                    pair<char,int>x=visit.front();\n                    \n                    if(x.second==i)\n                    {\n                        ans.push_back(steps);\n                        justbreak=true;\n                        break;\n                    }\n                    if(x.first=='n')\n                    {\n                        for(auto j:reds[x.second])\n                        {\n                            visit.push({'r',j});\n                            auto itr1=reds[x.second].find(j);\n                            reds[x.second].erase(itr1);\n                        }\n                        for(auto j:blues[x.second])\n                        {\n                            visit.push({'b',j});//blue='b'\n                            auto itr1=blues[x.second].find(j);\n                            blues[x.second].erase(itr1);\n                        }\n                    }\n                    else if(x.first=='b')\n                    {\n                        for(auto j:reds[x.second])\n                        {\n                            visit.push({'r',j});//red='r'\n                            auto itr1=reds[x.second].find(j);\n                            reds[x.second].erase(itr1);\n                        }\n                    }\n                    else if(x.first=='r')\n                    {\n                        for(auto j:blues[x.second])\n                        {\n                            visit.push({'b',j});\n                            auto itr1=blues[x.second].find(j);\n                            blues[x.second].erase(itr1);\n                        }\n                    }\n                }\n                if(justbreak)\n                {\n                    break;\n                }\n                steps++;\n            }\n            if(i==ans.size())\n            {\n                ans.push_back(-1);\n            }\n        }\n        return ans;\n    }\n};\n"
    },
    {
        "slug": "flood-fill",
        "description": "An image is represented by an m x n integer grid image where image[i][j] represents the pixel value of the image.\nYou are also given three integers sr, sc, and color. You should perform a flood fill on the image starting from the pixel image[sr][sc].\nTo perform a flood fill, consider the starting pixel, plus any pixels connected 4-directionally to the starting pixel of the same color as the starting pixel, plus any pixels connected 4-directionally to those pixels (also with the same color), and so on. Replace the color of all of the aforementioned pixels with color.\nReturn the modified image after performing the flood fill.",
        "examples": [
            "Input: image = [[1,1,1],[1,1,0],[1,0,1]], sr = 1, sc = 1, color = 2\nOutput: [[2,2,2],[2,2,0],[2,0,1]]\nExplanation: From the center of the image with position (sr, sc) = (1, 1) (i.e., the red pixel), all pixels connected by a path of the same color as the starting pixel (i.e., the blue pixels) are colored with the new color.\nNote the bottom corner is not colored 2, because it is not 4-directionally connected to the starting pixel.",
            "Input: image = [[0,0,0],[0,0,0]], sr = 0, sc = 0, color = 0\nOutput: [[0,0,0],[0,0,0]]\nExplanation: The starting pixel is already colored 0, so no changes are made to the image."
        ],
        "constraints": "m == image.length\nn == image[i].length\n1 <= m, n <= 50\n0 <= image[i][j], color < 216\n0 <= sr < m\n0 <= sc < n",
        "oracle_code": "class Solution {\npublic:\n    void bfs(int prevcolor,int row,int col,int color,vector<vector<int>>&visited,vector<vector<int>>&image)\n    {\n        // it'll ease the work\n        queue<pair<int,int>> q;\n        q.push({row,col});\n        visited[row][col]=1;\n\n        while(!q.empty())\n        {\n            row = q.front().first;\n            col = q.front().second;\n            q.pop();\n\n            // if img is of the starting color.\n            if(image[row][col]==prevcolor) image[row][col]=color;\n\n            // up\n            if(row-1>=0 && !visited[row-1][col] && image[row-1][col]==prevcolor) q.push({row-1,col}),visited[row-1][col]=1, image[row-1][col]=color;\n\n            // right\n            if(col+1<image[0].size() &&  !visited[row][col+1] && image[row][col+1]==prevcolor) q.push({row,col+1}),visited[row][col+1]=1, image[row][col+1]=color;\n\n            //down\n            if(row+1<image.size() && !visited[row+1][col] && image[row+1][col]==prevcolor) q.push({row+1,col}),visited[row+1][col]=1, image[row+1][col]=color;\n\n            // left\n            if(col-1>=0 && !visited[row][col-1] && image[row][col-1]==prevcolor) q.push({row,col-1}),visited[row][col-1]=1, image[row][col-1]=color;\n        }\n    }\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\n          int prevcolor = image[sr][sc];\n\n          // visiting array.\n          vector<vector<int>> visited(image.size(),vector<int>(image[0].size(),0));\n\n          bfs(prevcolor,sr,sc,color,visited,image);\n\n          return image;\n    }\n};",
        "content": "# Algo\\n\\n1.  Make a visited array of n*m\\n2. store the initial color.\\n3. do the traversal\\n4. Use queue data structure. \\n\\n\\n# Complexity\\n- Time complexity: O(N*M)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N*M)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void bfs(int prevcolor,int row,int col,int color,vector<vector<int>>&visited,vector<vector<int>>&image)\\n    {\\n        // it\\'ll ease the work\\n        queue<pair<int,int>> q;\\n        q.push({row,col});\\n        visited[row][col]=1;\\n\\n        while(!q.empty())\\n        {\\n            row = q.front().first;\\n            col = q.front().second;\\n            q.pop();\\n\\n            // if img is of the starting color.\\n            if(image[row][col]==prevcolor) image[row][col]=color;\\n\\n            // up\\n            if(row-1>=0 && !visited[row-1][col] && image[row-1][col]==prevcolor) q.push({row-1,col}),visited[row-1][col]=1, image[row-1][col]=color;\\n\\n            // right\\n            if(col+1<image[0].size() &&  !visited[row][col+1] && image[row][col+1]==prevcolor) q.push({row,col+1}),visited[row][col+1]=1, image[row][col+1]=color;\\n\\n            //down\\n            if(row+1<image.size() && !visited[row+1][col] && image[row+1][col]==prevcolor) q.push({row+1,col}),visited[row+1][col]=1, image[row+1][col]=color;\\n\\n            // left\\n            if(col-1>=0 && !visited[row][col-1] && image[row][col-1]==prevcolor) q.push({row,col-1}),visited[row][col-1]=1, image[row][col-1]=color;\\n        }\\n    }\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n          int prevcolor = image[sr][sc];\\n\\n          // visiting array.\\n          vector<vector<int>> visited(image.size(),vector<int>(image[0].size(),0));\\n\\n          bfs(prevcolor,sr,sc,color,visited,image);\\n\\n          return image;\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "== and = confusion",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    void bfs(int prevcolor,int row,int col,int color,vector<vector<int>>&visited,vector<vector<int>>&image)\n    {\n        // it'll ease the work\n        queue<pair<int,int>> q;\n        q.push({row,col});\n        visited[row][col]=1;\n        string unclosedString = \"bug introduction\n\n        while(!q.empty())\n        {\n            row = q.front().first;\n            col = q.front().second;\n            q.pop();\n\n            // if img is of the starting color.\n            if(image[row][col]=prevcolor) image[row][col]=color;\n\n            // up\n            if(row-1>=0 && !visited[row-1][col] && image[row-1][col]=prevcolor) q.push({row-1,col}),visited[row-1][col]=1, image[row-1][col]=color;\n\n            // right\n            if(col+1<image[0].size() && !visited[row][col+1] && image[row][col+1]=prevcolor) q.push({row,col+1}),visited[row][col+1]=1, image[row][col+1]=color;\n\n            //down\n            if(row+1<image.size() && !visited[row+1][col] && image[row+1][col]=prevcolor) q.push({row+1,col}),visited[row+1][col]=1, image[row+1][col]=color;\n\n            // left\n            if(col-1>=0 && !visited[row][col-1] && image[row][col-1]=prevcolor) q.push({row,col-1}),visited[row][col-1]=1, image[row][col-1]=color;\n        }\n    }\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\n          int prevcolor = image[sr][sc];\n\n          // visiting array.\n          vector<vector<int>> visited(image.size(),vector<int>(image[0].size(),0));\n\n          bfs(prevcolor,sr,sc,color,visited,image);\n\n          return image;\n    }\n};\n"
    },
    {
        "slug": "longest-increasing-subsequence",
        "description": "Given an integer array nums, return the length of the longest strictly increasing subsequence.",
        "examples": [
            "Input: nums = [10,9,2,5,3,7,101,18]\nOutput: 4\nExplanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.",
            "Input: nums = [0,1,0,3,2,3]\nOutput: 4",
            "Input: nums = [7,7,7,7,7,7,7]\nOutput: 1"
        ],
        "constraints": "1 <= nums.length <= 2500\n-104 <= nums[i] <= 104",
        "oracle_code": "class Solution {\npublic:\n    int lengthOfLIS(vector<int>& nums) {\n        //array to store max length subsequence till that place\n        vector<int> dp(nums.size(),0);\n        int maxlength = 0;//to store maxlength of subsequence\n        dp[0] = 1;//length will be 1 at first index \n        for(int i = 0;i<nums.size();i++){\n            int currentMaxLen = 0; //to store maxlength at till this index\n            for(int j = 0;j<i;j++){\n                // only check when the subsequence is increasing\n                if(nums[i]>nums[j]){\n                    if(currentMaxLen<dp[j]){\n                        currentMaxLen = dp[j]; //update currentMaxLen accordingly\n                    }\n                }\n            }\n            dp[i] = currentMaxLen + 1; //set the maxLength till ith index, which will be maxlenth so far + 1\n            maxlength = max(maxlength,dp[i]); //update maxlength\n        }\n        \n        return maxlength;\n    }\n};",
        "content": "# Intuition\\nThe problem asks us to find the length of the longest strictly increasing subsequence in the given array. To solve this problem efficiently, we can use dynamic programming.\\n\\n# Approach\\n1. Create a vector dp of size nums.size(), where dp[i] will store the length of the longest increasing subsequence ending at index i.\\n2. Initialize a variable maxlength to store the maximum length of the subsequence.\\n3. Set dp[0] to 1, as the length of the subsequence ending at the first index is always 1.\\n4. Iterate through each element in nums using the outer loop. For each element at index i, iterate through all the previous elements using the inner loop (from 0 to i-1).\\n5. Check if nums[i] is greater than nums[j], indicating that we can extend the increasing subsequence.\\n    - If the condition is satisfied, update the currentMaxLen variable with the maximum length of the subsequence so far at index j.\\n6. After the inner loop, update dp[i] with currentMaxLen + 1, which represents the maximum length of the subsequence ending at index i.\\nUpdate maxlength by taking the maximum value between maxlength and dp[i].\\n7. After the loop, maxlength will contain the length of the longest increasing subsequence.\\n8. Return maxlength.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of this solution is O(n^2), where n is the size of the input array nums. The outer loop runs for n iterations, and the inner loop also runs for a maximum of n iterations.\\n\\n- Space complexity:\\nThe space complexity is O(n) since we are using an additional vector dp of size n to store the lengths of subsequences.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums) {\\n        //array to store max length subsequence till that place\\n        vector<int> dp(nums.size(),0);\\n        int maxlength = 0;//to store maxlength of subsequence\\n        dp[0] = 1;//length will be 1 at first index \\n        for(int i = 0;i<nums.size();i++){\\n            int currentMaxLen = 0; //to store maxlength at till this index\\n            for(int j = 0;j<i;j++){\\n                // only check when the subsequence is increasing\\n                if(nums[i]>nums[j]){\\n                    if(currentMaxLen<dp[j]){\\n                        currentMaxLen = dp[j]; //update currentMaxLen accordingly\\n                    }\\n                }\\n            }\\n            dp[i] = currentMaxLen + 1; //set the maxLength till ith index, which will be maxlenth so far + 1\\n            maxlength = max(maxlength,dp[i]); //update maxlength\\n        }\\n        \\n        return maxlength;\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "indexing error",
            "colon missing"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    int lengthOfLIS(vector<int>& nums) {\n        //array to store max length subsequence till that place\n        vector<int> dp(nums.size(),0);\n        int maxlength = 0;//to store maxlength of subsequence\n        dp[0] = 1;//length will be 1 at first index \n        for(int i = 0;i<=nums.size() i++){\n            int currentMaxLen = 0; //to store maxlength at till this index\n            for(int j = 0;j<i;j++){\n                // only check when the subsequence is increasing\n                if(nums[i]>nums[j]){\n                    if(currentMaxLen<dp[j]){\n                        currentMaxLen = dp[j]; //update currentMaxLen accordingly\n                    }\n                }\n            }\n            dp[i] = currentMaxLen + 1; //set the maxLength till ith index, which will be maxlenth so far + 1\n            maxlength = max(maxlength,dp[i]); //update maxlength\n        }\n        \n        return maxlength;\n    }\n};\n"
    },
    {
        "slug": "unique-binary-search-trees",
        "description": "Given an integer n, return the number of structurally unique BST's (binary search trees) which has exactly n nodes of unique values from 1 to n.",
        "examples": [
            "Input: n = 3\nOutput: 5",
            "Input: n = 1\nOutput: 1"
        ],
        "constraints": "1 <= n <= 19",
        "oracle_code": "class Solution {\npublic:\nint solve(int n)\n{\n    vector<int>dp(n+1,0);    \n    dp[0]=dp[1]=1;\n    for(int i=2;i<=n;i++)\n    {\n        for(int j= 1;j<=i;j++)\n        {\n            dp[i]+= dp[j-1]*dp[i-j];\n        }\n    }\n        return dp[n];\n}\n    int numTrees(int n) {\n    return solve(n); \n    }\n};",
        "content": "# Homework for you\\nSolve using catalan number and comment the code \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe main function numTrees(n) takes an integer n as input and returns the total number of unique binary search trees that can be formed with n nodes.\\n\\nThe helper function solve(n) takes an integer n (representing the number of nodes to form a binary search tree) and returns the number of unique binary search trees that can be formed with n nodes.\\n\\nIn the helper function solve, it initializes a vector dp of size n + 1 with all elements set to 0. The vector dp will be used to store the number of unique binary search trees for i nodes.\\n\\nInitialize dp[0] and dp[1] to 1 since there is only one way to form binary search trees with 0 and 1 nodes (empty tree and single-node tree).\\n\\nIterate from i = 2 up to n. For each i, calculate the number of unique binary search trees using the Catalan number formula: dp[i] = dp[0] * dp[i - 1] + dp[1] * dp[i - 2] + ... + dp[i - 1] * dp[0]. This calculation is done by considering each element j as the root and multiplying the number of unique binary search trees for the left subtree (with j - 1 nodes) and the right subtree (with i - j nodes).\\n\\nReturn dp[n], which represents the total number of unique binary search trees with n nodes.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:0(n*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint solve(int n)\\n{\\n    vector<int>dp(n+1,0);    \\n    dp[0]=dp[1]=1;\\n    for(int i=2;i<=n;i++)\\n    {\\n        for(int j= 1;j<=i;j++)\\n        {\\n            dp[i]+= dp[j-1]*dp[i-j];\\n        }\\n    }\\n        return dp[n];\\n}\\n    int numTrees(int n) {\\n    return solve(n); \\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "indexing error",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution {\npublic:\nint solve(int n)\n{\n    vector<int>dp(n+1,0);    \n    dp[0]=dp[1]=1;\n    for(int i=2;i<=n+1;i++)\n    {\n        for(int j= 1;j<=i;j++)\n        {\n            dp[i]+= dp[j-1]*dp[i-j];\n        }\n    return dp[n];\n    }\n    int numTrees(int n) {\n    return solve(n); \n    }\n};\n"
    },
    {
        "slug": "01-matrix",
        "description": "Given an m x n binary matrix mat, return the distance of the nearest 0 for each cell.\nThe distance between two adjacent cells is 1.",
        "examples": [
            "Input: mat = [[0,0,0],[0,1,0],[0,0,0]]\nOutput: [[0,0,0],[0,1,0],[0,0,0]]",
            "Input: mat = [[0,0,0],[0,1,0],[1,1,1]]\nOutput: [[0,0,0],[0,1,0],[1,2,1]]"
        ],
        "constraints": "m == mat.length\nn == mat[i].length\n1 <= m, n <= 104\n1 <= m * n <= 104\nmat[i][j] is either 0 or 1.\nThere is at least one 0 in mat.",
        "oracle_code": "class Solution {\npublic:\n    vector<vector<int>> updateMatrix(vector<vector<int>>& mat) {\n        int n=mat.size();\n        int m=mat[0].size();\n        vector<vector<int>>dp(n,vector<int>(m,INT_MAX-2));\n        //normal case so will go for top and left only\n        for (int i=0;i<n;i++){\n            for (int j=0;j<m;j++){\n                if (mat[i][j]==0) dp[i][j]=0;\n                else {\n                    if (i>0) dp[i][j]= min (dp[i][j], dp[i-1][j]+1); //top\n                    if (j>0) dp[i][j]=min (dp[i][j],dp[i][j-1]+1); //left\n                }\n            }\n        }\n\n        //reverse \n             for (int i=n-1;i>=0;i--){\n            for (int j=m-1;j>=0;j--){\n                if (mat[i][j]==0) dp[i][j]=0;\n                else {\n                    if (i<n-1) dp[i][j]= min (dp[i][j], dp[i+1][j]+1); //bottom\n                    if (j<m-1) dp[i][j]=min (dp[i][j],dp[i][j+1]+1); //right\n                }\n            }\n        }\n        return dp;\n    }\n};",
        "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize a 2D vector `dp` of the same size as the input matrix `mat`, where each cell initially has a value of `INT_MAX - 2`.\\n2. Traverse the matrix from top-left to bottom-right:\\n   - If the current cell contains 0, set `dp[i][j]` to 0.\\n   - Otherwise, update `dp[i][j]` with the minimum of its current value and the values from its top and left neighbors, incremented by 1.\\n3. Traverse the matrix in reverse, from bottom-right to top-left:\\n   - Update `dp[i][j]` with the minimum of its current value and the values from its bottom and right neighbors, incremented by 1.\\n4. Return the updated `dp` matrix.\\n\\n**Additional Point:**\\n- The reason for using `INT_MAX - 2` is to avoid integer overflow when adding 1 to `INT_MAX`. By subtracting 2, we ensure that the addition won\\'t exceed the maximum value representable by an `int`. This is a common technique to handle situations where adding a small number to `INT_MAX` might cause unexpected behavior due to overflow.\\n![image.png](https://assets.leetcode.com/users/images/768d89e8-9abb-4604-8189-48ab7753f33f_1692259793.882623.png)\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n O(n * m) \\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n * m)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> updateMatrix(vector<vector<int>>& mat) {\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        vector<vector<int>>dp(n,vector<int>(m,INT_MAX-2));\\n        //normal case so will go for top and left only\\n        for (int i=0;i<n;i++){\\n            for (int j=0;j<m;j++){\\n                if (mat[i][j]==0) dp[i][j]=0;\\n                else {\\n                    if (i>0) dp[i][j]= min (dp[i][j], dp[i-1][j]+1); //top\\n                    if (j>0) dp[i][j]=min (dp[i][j],dp[i][j-1]+1); //left\\n                }\\n            }\\n        }\\n\\n        //reverse \\n             for (int i=n-1;i>=0;i--){\\n            for (int j=m-1;j>=0;j--){\\n                if (mat[i][j]==0) dp[i][j]=0;\\n                else {\\n                    if (i<n-1) dp[i][j]= min (dp[i][j], dp[i+1][j]+1); //bottom\\n                    if (j<m-1) dp[i][j]=min (dp[i][j],dp[i][j+1]+1); //right\\n                }\\n            }\\n        }\\n        return dp;\\n    }\\n};\\n```\\n\\nupvote plz \\uD83D\\uDE4F\\uD83C\\uDFFE\\u2B06\\uFE0F\\n",
        "level": "medium",
        "type": [
            "== and = confusion",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    vector<vector<int>> updateMatrix(vector<vector<int>>& mat) {\n        int n=mat.size();\n        int m=mat[0].size();\n        vector<vector<int>>dp(n,vector<int>(m,INT_MAX-2));\n        undefinedFunction(mat, n, m);\n        return dp;\n    }\n};\n\n"
    },
    {
        "slug": "prime-arrangements",
        "description": "Return the number of permutations of 1 to n so that prime numbers are at prime indices (1-indexed.)\n(Recall that an integer\u00a0is prime if and only if it is greater than 1, and cannot be written as a product of two positive integers\u00a0both smaller than it.)\nSince the answer may be large, return the answer modulo 10^9 + 7.",
        "examples": [
            "Input: n = 5\nOutput: 12\nExplanation: For example [1,2,5,4,3] is a valid permutation, but [5,2,3,4,1] is not because the prime number 5 is at index 1.",
            "Input: n = 100\nOutput: 682289015"
        ],
        "constraints": "1 <= n <= 100",
        "oracle_code": "class Solution {\npublic:\n    long long fact(int n)\n    {\n        if(n<=1)return 1;\n        return (n*fact(n-1)%1000000007)%1000000007;\n    }\n    int numPrimeArrangements(int n) {\n        if(n==1)return 1;\n        if(n<=3)return n-1;\n        int t=0,flag;\n        for(int i=2;i<=n;i++)\n        {\n            flag=0;\n            for(int j=2;j<=sqrt(i);j++)\n            {\n                if(i%j==0)\n                {\n                    flag=1;\n                    break;\n                }\n            }\n            if(flag==0)\n            {\n                t++;\n            }\n        }\n        return (fact(t)*fact(n-t))%1000000007;\n\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long fact(int n)\\n    {\\n        if(n<=1)return 1;\\n        return (n*fact(n-1)%1000000007)%1000000007;\\n    }\\n    int numPrimeArrangements(int n) {\\n        if(n==1)return 1;\\n        if(n<=3)return n-1;\\n        int t=0,flag;\\n        for(int i=2;i<=n;i++)\\n        {\\n            flag=0;\\n            for(int j=2;j<=sqrt(i);j++)\\n            {\\n                if(i%j==0)\\n                {\\n                    flag=1;\\n                    break;\\n                }\\n            }\\n            if(flag==0)\\n            {\\n                t++;\\n            }\\n        }\\n        return (fact(t)*fact(n-t))%1000000007;\\n\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "other error",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    long long fact(int n)\n    {\n        if(n<=1)return 1;\n        return (n*fact(n+1)%1000000007)%1000000007; \n    }\n    int numPrimeArrangements(int n) {\n        if(n=1)return 1;\n        if(n<=3)return n-1;\n        int t=0,flag;\n        for(int i=2;i<=n;i++)\n        {\n            flag=0;\n            for(int j=2;j<=sqrt(i);j++)\n            {\n                if(i%j==0)\n                {\n                    flag=1;\n                    break;\n                }\n            }\n            if(flag==0)\n            {\n                t++;\n            }\n        }\n        return (fact(t)*fact(n-t))%1000000007;\n\n    }\n};\n"
    },
    {
        "slug": "magical-string",
        "description": "A magical string s consists of only '1' and '2' and obeys the following rules:\n\nThe string s is magical because concatenating the number of contiguous occurrences of characters '1' and '2' generates the string s itself.\n\nThe first few elements of s is s = \"1221121221221121122\u2026\u2026\". If we group the consecutive 1's and 2's in s, it will be \"1 22 11 2 1 22 1 22 11 2 11 22 ......\" and the occurrences of 1's or 2's in each group are \"1 2 2 1 1 2 1 2 2 1 2 2 ......\". You can see that the occurrence sequence is s itself.\nGiven an integer n, return the number of 1's in the first n number in the magical string s.",
        "examples": [
            "Input: n = 6\nOutput: 3\nExplanation: The first 6 elements of magical string s is \"122112\" and it contains three 1's, so return 3.",
            "Input: n = 1\nOutput: 1"
        ],
        "constraints": "1 <= n <= 105",
        "oracle_code": "class Solution {\npublic:\n    int magicalString(int n) {\n        string s=\"\";\n        s+=\"122\";\n        int i=2,c=1;\n        while(i<n && s.size()<n)\n        {\n            if(s[i]=='1')\n            {\n                c++;\n                if(s[s.size()-1]=='2')\n                s+='1';\n                else\n                {\n                    s+='2';\n                }\n            }\n            else\n            {\n                if(s[s.size()-1]=='2')\n                s+=\"11\";\n                else\n                {\n                    s+=\"22\";\n                }\n            }\n            i++;\n        }\n        while(i<n)\n        {\n            if(s[i]=='1')\n            c++;\n            i++;\n        }\n        return c;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIntution was to find the repeating part first, then i saw the pattern carefully and tried to make it.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can make the string using first three digits only \"122\",my intution is to make whole string upto length n,and count ones side by side. Also to count the remaining 1\\'s after while loop breaks\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int magicalString(int n) {\\n        string s=\"\";\\n        s+=\"122\";\\n        int i=2,c=1;\\n        while(i<n && s.size()<n)\\n        {\\n            if(s[i]==\\'1\\')\\n            {\\n                c++;\\n                if(s[s.size()-1]==\\'2\\')\\n                s+=\\'1\\';\\n                else\\n                {\\n                    s+=\\'2\\';\\n                }\\n            }\\n            else\\n            {\\n                if(s[s.size()-1]==\\'2\\')\\n                s+=\"11\";\\n                else\\n                {\\n                    s+=\"22\";\\n                }\\n            }\\n            i++;\\n        }\\n        while(i<n)\\n        {\\n            if(s[i]==\\'1\\')\\n            c++;\\n            i++;\\n        }\\n        return c;\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "== and = confusion",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    int magicalString(int n) {\n        str s=\"\";\n        s+=\"122\";\n        int i=2,c=1;\n        while(i<n && s.size()<n)\n        {\n            if(s[i]='1') \n            {\n                c++;\n                if(s[s.size()-1]=='2')\n                s+='1';\n                else\n                {\n                    s+='2';\n                }\n            }\n            else\n            {\n                if(s[s.size()-1]=='2')\n                s+=\"11\";\n                else\n                {\n                    s+=\"22\";\n                }\n            }\n            i++;\n        }\n        while(i<n)\n        {\n            if(s[i]='1') \n            c++;\n            i++;\n        }\n        return c;\n    }\n};\n"
    },
    {
        "slug": "array-with-elements-not-equal-to-average-of-neighbors",
        "description": "You are given a 0-indexed array nums of distinct integers. You want to rearrange the elements in the array such that every element in the rearranged array is not equal to the average of its neighbors.\nMore formally, the rearranged array should have the property such that for every i in the range 1 <= i < nums.length - 1, (nums[i-1] + nums[i+1]) / 2 is not equal to nums[i].\nReturn any rearrangement of nums that meets the requirements.",
        "examples": [
            "Input: nums = [1,2,3,4,5]\nOutput: [1,2,4,5,3]\nExplanation:\nWhen i=1, nums[i] = 2, and the average of its neighbors is (1+4) / 2 = 2.5.\nWhen i=2, nums[i] = 4, and the average of its neighbors is (2+5) / 2 = 3.5.\nWhen i=3, nums[i] = 5, and the average of its neighbors is (4+3) / 2 = 3.5.",
            "Input: nums = [6,2,0,9,7]\nOutput: [9,7,6,2,0]\nExplanation:\nWhen i=1, nums[i] = 7, and the average of its neighbors is (9+6) / 2 = 7.5.\nWhen i=2, nums[i] = 6, and the average of its neighbors is (7+2) / 2 = 4.5.\nWhen i=3, nums[i] = 2, and the average of its neighbors is (6+0) / 2 = 3."
        ],
        "constraints": "3 <= nums.length <= 105\n0 <= nums[i] <= 105",
        "oracle_code": "class Solution {\npublic:\n    vector<int> rearrangeArray(vector<int>& nums) {\n        int size=nums.size();\n        for(int i=1;i<size-1;i++){\n            if((nums[i-1]<nums[i] && nums[i]<nums[i+1])||(nums[i-1]>nums[i] && nums[i]>nums[i+1]))   //If the array is strictly increasing or decreasing then swap the vlaue at current index  with value at index+1\n                swap(nums[i],nums[i+1]);\n        }\n        return nums;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int size=nums.size();\\n        for(int i=1;i<size-1;i++){\\n            if((nums[i-1]<nums[i] && nums[i]<nums[i+1])||(nums[i-1]>nums[i] && nums[i]>nums[i+1]))   //If the array is strictly increasing or decreasing then swap the vlaue at current index  with value at index+1\\n                swap(nums[i],nums[i+1]);\\n        }\\n        return nums;\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "conditional statement error",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    vector<int> rearrangeArray(vector<int>& nums) {\n        int size=nums.size();\n        for(int i=0;i<size-1;i++){\n            if((nums[i-1]<nums[i] && nums[i]<nums[i+1])||(nums[i-1]>nums[i] && nums[i]>nums[i+1]))   \n                swapp(nums[i],nums[i+1]);  \n        }\n        return nums;\n    }\n};\n"
    },
    {
        "slug": "gray-code",
        "description": "An n-bit gray code sequence is a sequence of 2n integers where:\n\nEvery integer is in the inclusive range [0, 2n - 1],\nThe first integer is 0,\nAn integer appears no more than once in the sequence,\nThe binary representation of every pair of adjacent integers differs by exactly one bit, and\nThe binary representation of the first and last integers differs by exactly one bit.\n\nGiven an integer n, return any valid n-bit gray code sequence.",
        "examples": [
            "Input: n = 2\nOutput: [0,1,3,2]\nExplanation:\nThe binary representation of [0,1,3,2] is [00,01,11,10].\n- 00 and 01 differ by one bit\n- 01 and 11 differ by one bit\n- 11 and 10 differ by one bit\n- 10 and 00 differ by one bit\n[0,2,3,1] is also a valid gray code sequence, whose binary representation is [00,10,11,01].\n- 00 and 10 differ by one bit\n- 10 and 11 differ by one bit\n- 11 and 01 differ by one bit\n- 01 and 00 differ by one bit",
            "Input: n = 1\nOutput: [0,1]"
        ],
        "constraints": "1 <= n <= 16",
        "oracle_code": "class Solution {\npublic:\n    vector<int> grayCode(int n) {\n        vector<int> res;\n        res.push_back( 0 );\n        for( int k = 0; k<n; k++ ) {\n            int i = res.size(), t = (1<<k) ;\n            while( i ) {\n                int temp = res[--i] | t;\n                res.push_back( temp );\n            }\n        }\n        return res;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int> res;\\n        res.push_back( 0 );\\n        for( int k = 0; k<n; k++ ) {\\n            int i = res.size(), t = (1<<k) ;\\n            while( i ) {\\n                int temp = res[--i] | t;\\n                res.push_back( temp );\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "parentheses mismatch",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    vector<int> grayCode(int n) {\n        vector<int> res;\n        for( int k = 0; k<n; k++ ) {\n            int i = res.size(), t = (1<<k) ;\n            while( i ) {\n                int temp = res[--i] | t;\n                res.push_back( temp );\n            }\n        }\n        return res;\n    }\n};\n\n"
    },
    {
        "slug": "design-twitter",
        "description": "Design a simplified version of Twitter where users can post tweets, follow/unfollow another user, and is able to see the 10 most recent tweets in the user's news feed.\nImplement the Twitter class:\n\nTwitter() Initializes your twitter object.\nvoid postTweet(int userId, int tweetId) Composes a new tweet with ID tweetId by the user userId. Each call to this function will be made with a unique tweetId.\nList<Integer> getNewsFeed(int userId) Retrieves the 10 most recent tweet IDs in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user themself. Tweets must be ordered from most recent to least recent.\nvoid follow(int followerId, int followeeId) The user with ID followerId started following the user with ID followeeId.\nvoid unfollow(int followerId, int followeeId) The user with ID followerId started unfollowing the user with ID followeeId.",
        "examples": [
            "Input\n[\"Twitter\", \"postTweet\", \"getNewsFeed\", \"follow\", \"postTweet\", \"getNewsFeed\", \"unfollow\", \"getNewsFeed\"]\n[[], [1, 5], [1], [1, 2], [2, 6], [1], [1, 2], [1]]\nOutput\n[null, null, [5], null, null, [6, 5], null, [5]]\n\nExplanation\nTwitter twitter = new Twitter();\ntwitter.postTweet(1, 5); // User 1 posts a new tweet (id = 5).\ntwitter.getNewsFeed(1);  // User 1's news feed should return a list with 1 tweet id -> [5]. return [5]\ntwitter.follow(1, 2);    // User 1 follows user 2.\ntwitter.postTweet(2, 6); // User 2 posts a new tweet (id = 6).\ntwitter.getNewsFeed(1);  // User 1's news feed should return a list with 2 tweet ids -> [6, 5]. Tweet id 6 should precede tweet id 5 because it is posted after tweet id 5.\ntwitter.unfollow(1, 2);  // User 1 unfollows user 2.\ntwitter.getNewsFeed(1);  // User 1's news feed should return a list with 1 tweet id -> [5], since user 1 is no longer following user 2."
        ],
        "constraints": "1 <= userId, followerId, followeeId <= 500\n0 <= tweetId <= 104\nAll the tweets have unique IDs.\nAt most 3 * 104 calls will be made to postTweet, getNewsFeed, follow, and unfollow.",
        "oracle_code": "class Twitter {\n    int timer = INT_MAX;\n    map<int, map<int, bool>> friends;\n    // map user id with user friends map\n    map<int, pair<int, int>> tweets;\n    // time {userId, tweetId}\npublic:\n    Twitter() {\n    }\n    \n    void postTweet(int userId, int tweetId) {\n        tweets[timer--] = {userId, tweetId};\n    }\n    \n    vector<int> getNewsFeed(int userId) {\n        vector<int> ans;\n        for(auto it: tweets){\n            if(it.second.first == userId || friends[userId].find(it.second.first)!=friends[userId].end())\n                ans.push_back(it.second.second);\n            if(ans.size() == 10) break;\n        }\n        return ans;\n    }\n    \n    void follow(int followerId, int followeeId) {\n        friends[followerId][followeeId] = true;\n    }\n    \n    void unfollow(int followerId, int followeeId) {\n        friends[followerId].erase(followeeId);\n    }\n};\n\n/**\n * Your Twitter object will be instantiated and called as such:\n * Twitter* obj = new Twitter();\n * obj->postTweet(userId,tweetId);\n * vector<int> param_2 = obj->getNewsFeed(userId);\n * obj->follow(followerId,followeeId);\n * obj->unfollow(followerId,followeeId);\n */",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs our normal map sort the data in asscending order, wo we will use the timer variable initially it will be INT_MAX so, the upcoming tweets will be at starting.\\n\\nWhen fetching the tweets we simply check is the tweet id belongs to the userId or any of its friend if yes add it to answer and do, it till we fetch the top 10 recent tweets by the user or its friend\\n# Code\\n```\\nclass Twitter {\\n    int timer = INT_MAX;\\n    map<int, map<int, bool>> friends;\\n    // map user id with user friends map\\n    map<int, pair<int, int>> tweets;\\n    // time {userId, tweetId}\\npublic:\\n    Twitter() {\\n    }\\n    \\n    void postTweet(int userId, int tweetId) {\\n        tweets[timer--] = {userId, tweetId};\\n    }\\n    \\n    vector<int> getNewsFeed(int userId) {\\n        vector<int> ans;\\n        for(auto it: tweets){\\n            if(it.second.first == userId || friends[userId].find(it.second.first)!=friends[userId].end())\\n                ans.push_back(it.second.second);\\n            if(ans.size() == 10) break;\\n        }\\n        return ans;\\n    }\\n    \\n    void follow(int followerId, int followeeId) {\\n        friends[followerId][followeeId] = true;\\n    }\\n    \\n    void unfollow(int followerId, int followeeId) {\\n        friends[followerId].erase(followeeId);\\n    }\\n};\\n\\n/**\\n * Your Twitter object will be instantiated and called as such:\\n * Twitter* obj = new Twitter();\\n * obj->postTweet(userId,tweetId);\\n * vector<int> param_2 = obj->getNewsFeed(userId);\\n * obj->follow(followerId,followeeId);\\n * obj->unfollow(followerId,followeeId);\\n */\\n```",
        "level": "medium",
        "type": [
            "undefined keywords from other languages",
            "variable value error"
        ],
        "buggy_code": "\nclass Twitter {\n    int timer = INT_MAX;\n    map<int, map<int, bool>> friends;\n    map<int, pair<int, int>> tweets;\n\npublic:\n    Twitter() {\n    }\n    \n    void postTweet(int userId, int tweetId) {\n        tweets[timer--] = {userId, tweetId};\n    }\n    \n    vector<int> getNewsFeed(int userId) {\n        vector<int> ans;\n        for(auto it: tweets){\n            if(it.second.first == userId || friends[userId].find(it.second.first)!=friends[userId].end())\n                ans.push_back(it.second.second);\n            if(ans.length() == 10) break;\n        }\n        return ans;\n    }\n    \n    void follow(int followerId, int followeeId) {\n        friends[followerId][followerId] = true;\n    }\n    \n    void unfollow(int followerId, int followeeId) {\n        friends[followerId].erase(followeeId);\n    }\n};\n<bug><exp>\nUsed .length() which is incorrect, it should be .size() for vectors in C++.\n<x"
    },
    {
        "slug": "count-stepping-numbers-in-range",
        "description": "Given two positive integers low and high represented as strings, find the count of stepping numbers in the inclusive range [low, high].\nA stepping number is an integer such that all of its adjacent digits have an absolute difference of exactly 1.\nReturn an integer denoting the count of stepping numbers in the inclusive range [low, high]. \nSince the answer may be very large, return it modulo 109 + 7.\nNote: A stepping number should not have a leading zero.",
        "examples": [
            "Input: low = \"1\", high = \"11\"\nOutput: 10\nExplanation: The stepping numbers in the range [1,11] are 1, 2, 3, 4, 5, 6, 7, 8, 9 and 10. There are a total of 10 stepping numbers in the range. Hence, the output is 10.",
            "Input: low = \"90\", high = \"101\"\nOutput: 2\nExplanation: The stepping numbers in the range [90,101] are 98 and 101. There are a total of 2 stepping numbers in the range. Hence, the output is 2."
        ],
        "constraints": "1 <= int(low) <= int(high) < 10100\n1 <= low.length, high.length <= 100\nlow and high consist of only digits.\nlow and high don't have any leading zeros.",
        "oracle_code": "class Solution {\npublic:\n    #define mod 1000000007\n    long long dp[102][10][2][2];\n    long long f(string &r,int n,int pre,int leadingZero,int tight){\n        if(n==0) return 1;\n        \n        if(dp[n][pre][leadingZero][tight]!=-1) return dp[n][pre][leadingZero][tight];\n        long long up = tight ? (r[r.size()-n]-'0'):9,ans=0;\n        \n        if(leadingZero){\n            for(int i=0;i<=up;i++){\n                ans = (ans + f(r,n-1,i,(i==0),tight&(i==up)))%mod; \n            }\n        } else {\n            if(pre-1>=0 && pre-1<=up) ans = (ans + f(r,n-1,pre-1,0,tight&(pre-1==up)))%mod;\n            if(pre+1<=up) ans = (ans + f(r,n-1,pre+1,0,tight&(pre+1==up)))%mod;\n        }\n        \n        \n        return dp[n][pre][leadingZero][tight]=ans;\n    }\n    int countSteppingNumbers(string low, string high) {\n        int n=high.size();\n        memset(dp,-1,sizeof(dp));\n        long long r= f(high,high.size(),0,1,1);\n        memset(dp,-1,sizeof(dp));\n        for(int i=low.size()-1;i>=0;i--){\n            if((low[i]-'0')>0){\n                low[i]--;break;\n            } else {\n                low[i]='9';\n            }\n        }\n        \n        // cout<<low<<endl;\n        long long l= f(low,low.size(),0,1,1);\n        cout<<l<<\" \"<<r<<endl;\n        return (r-l+mod)%mod;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    #define mod 1000000007\\n    long long dp[102][10][2][2];\\n    long long f(string &r,int n,int pre,int leadingZero,int tight){\\n        if(n==0) return 1;\\n        \\n        if(dp[n][pre][leadingZero][tight]!=-1) return dp[n][pre][leadingZero][tight];\\n        long long up = tight ? (r[r.size()-n]-\\'0\\'):9,ans=0;\\n        \\n        if(leadingZero){\\n            for(int i=0;i<=up;i++){\\n                ans = (ans + f(r,n-1,i,(i==0),tight&(i==up)))%mod; \\n            }\\n        } else {\\n            if(pre-1>=0 && pre-1<=up) ans = (ans + f(r,n-1,pre-1,0,tight&(pre-1==up)))%mod;\\n            if(pre+1<=up) ans = (ans + f(r,n-1,pre+1,0,tight&(pre+1==up)))%mod;\\n        }\\n        \\n        \\n        return dp[n][pre][leadingZero][tight]=ans;\\n    }\\n    int countSteppingNumbers(string low, string high) {\\n        int n=high.size();\\n        memset(dp,-1,sizeof(dp));\\n        long long r= f(high,high.size(),0,1,1);\\n        memset(dp,-1,sizeof(dp));\\n        for(int i=low.size()-1;i>=0;i--){\\n            if((low[i]-\\'0\\')>0){\\n                low[i]--;break;\\n            } else {\\n                low[i]=\\'9\\';\\n            }\\n        }\\n        \\n        // cout<<low<<endl;\\n        long long l= f(low,low.size(),0,1,1);\\n        cout<<l<<\" \"<<r<<endl;\\n        return (r-l+mod)%mod;\\n    }\\n};\\n```",
        "level": "hard",
        "type": [
            "== and = confusion",
            "variable value error"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    #define mod 1000000007\n    long long dp[102][10][2][2];\n    long long f(string &r,int n,int pre,int leadingZero,int tight){\n        if(n==0) return 1;\n        \n        if(dp[n][pre][leadingZero][tight]!=-1) return dp[n][pre][leadingZero][tight];\n        long long up = tight ? (r[r.size()-n]-'0'):9,ans=0;\n        \n        if(leadingZero){\n            for(int i=0;i<=up;i++){\n                ans = (ans + f(r,n-1,i,(i==0),tight&(i==up)))%mod; \n            }\n        } else {\n            if(pre-1>=0 && pre-1<=up) ans = (ans + f(r,n-1,pre-1,0,tight&(pre-1==up)))%mod;\n            if(pre+1<=up) ans = (ans + f(r,n-1,pre+1,0,tight&(pre+1==up)))%mod;\n        }\n\n        return dp[n][pre][leadingZero][tight] == ans;\n    }\n    int countSteppingNumbers(string low, string high) {\n        int n=high.size();\n        memset(dp,-1,sizeof(dp));\n        long long r= f(high,high.size(),0,1,0);  \n        memset(dp,-1,sizeof(dp));\n        for(int i=low.size()-1;i>=0;i--){\n            if((low[i]-'0')>0){\n                low[i]--;break;\n            } else {\n                low[i]='9';\n            }\n        }\n        \n        // cout<<low<<endl;\n        long long l= f(low,low.size(),0,1,1);\n        cout<<l<<\" \"<<r<<endl;\n        return (r-l+mod)%mod;\n    }\n};\n\n"
    },
    {
        "slug": "add-strings",
        "description": "Given two non-negative integers, num1 and num2 represented as string, return the sum of num1 and num2 as a string.\nYou must solve the problem without using any built-in library for handling large integers (such as BigInteger). You must also not convert the inputs to integers directly.",
        "examples": [
            "Input: num1 = \"11\", num2 = \"123\"\nOutput: \"134\"",
            "Input: num1 = \"456\", num2 = \"77\"\nOutput: \"533\"",
            "Input: num1 = \"0\", num2 = \"0\"\nOutput: \"0\""
        ],
        "constraints": "1 <= num1.length, num2.length <= 104\nnum1 and num2 consist of only digits.\nnum1 and num2 don't have any leading zeros except for the zero itself.",
        "oracle_code": "class Solution {\npublic:\n    string addStrings(string a, string b) {\n        string ret = \"\" ;\n        int carry = 0, i = a.size() - 1, j = b.size() - 1;\n        while( i >= 0 || j >= 0 ){\n            int x = i >= 0 ? a[i--] - '0' : 0 ;\n            int y = j >= 0 ? b[j--] - '0' : 0 ;\n\n            int sm = x + y + carry ;\n            ret.push_back( '0' + (sm % 10) ) ;\n            carry = sm/10;\n        }\n        if(carry)\n            ret.push_back('0' + carry ) ;\n        \n        reverse( ret.begin(), ret.end() ) ;\n\n        return ret ;\n    }\n};",
        "content": "# Intuition\\nSimple solution will be to do the basice math, and simulate the digits from the back\\n\\n# Approach\\n- We\\'ll start with the ends of both strings, and in each iteration (till we\\'ve iterated all the strings), we\\'ll fetch the last digit from the $$nums1$$, $$nums2$$ if not available we\\'ll default to 0.\\n\\n- Then we\\'ll sum the digits and also add the carry from the last iteration,\\n\\n- Then we\\'ll push the sum modulo 10 to the answer string.\\n\\n- Also dont forget to update the carry variable.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string addStrings(string a, string b) {\\n        string ret = \"\" ;\\n        int carry = 0, i = a.size() - 1, j = b.size() - 1;\\n        while( i >= 0 || j >= 0 ){\\n            int x = i >= 0 ? a[i--] - \\'0\\' : 0 ;\\n            int y = j >= 0 ? b[j--] - \\'0\\' : 0 ;\\n\\n            int sm = x + y + carry ;\\n            ret.push_back( \\'0\\' + (sm % 10) ) ;\\n            carry = sm/10;\\n        }\\n        if(carry)\\n            ret.push_back(\\'0\\' + carry ) ;\\n        \\n        reverse( ret.begin(), ret.end() ) ;\\n\\n        return ret ;\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "conditional statement error",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    str addStrings(string a, string b) {\n        str ret = \"\" ;\n        int carry = 0, i = a.size() - 1, j = b.size() - 1;\n        while( i >= 0 || j >= 0 ){\n            int x = i >= 0 ? a[i--] - '0' : 0 ;\n            int y = j >= 0 ? b[j--] - '0' : 0 ;\n\n            int sm = x + y + carry ;\n            ret.push_back( '0' + (sm % 10) ) ;\n            carry = sm/10;\n        }\n        ret.push_back('0' + carry ) ;\n        \n        reverse( ret.begin(), ret.end() ) ;\n\n        return ret ;\n    }\n};\n"
    },
    {
        "slug": "count-number-of-possible-root-nodes",
        "description": "Alice has an undirected tree with n nodes labeled from 0 to n - 1. The tree is represented as a 2D integer array edges of length n - 1 where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree.\nAlice wants Bob to find the root of the tree. She allows Bob to make several guesses about her tree. In one guess, he does the following:\n\nChooses two distinct integers u and v such that there exists an edge [u, v] in the tree.\nHe tells Alice that u is the parent of v in the tree.\n\nBob's guesses are represented by a 2D integer array guesses where guesses[j] = [uj, vj] indicates Bob guessed uj to be the parent of vj.\nAlice being lazy, does not reply to each of Bob's guesses, but just says that at least k of his guesses are true.\nGiven the 2D integer arrays edges, guesses and the integer k, return the number of possible nodes that can be the root of Alice's tree. If there is no such tree, return 0.",
        "examples": [
            "Input: edges = [[0,1],[1,2],[1,3],[4,2]], guesses = [[1,3],[0,1],[1,0],[2,4]], k = 3\nOutput: 3\nExplanation: \nRoot = 0, correct guesses = [1,3], [0,1], [2,4]\nRoot = 1, correct guesses = [1,3], [1,0], [2,4]\nRoot = 2, correct guesses = [1,3], [1,0], [2,4]\nRoot = 3, correct guesses = [1,0], [2,4]\nRoot = 4, correct guesses = [1,3], [1,0]\nConsidering 0, 1, or 2 as root node leads to 3 correct guesses.",
            "Input: edges = [[0,1],[1,2],[2,3],[3,4]], guesses = [[1,0],[3,4],[2,1],[3,2]], k = 1\nOutput: 5\nExplanation: \nRoot = 0, correct guesses = [3,4]\nRoot = 1, correct guesses = [1,0], [3,4]\nRoot = 2, correct guesses = [1,0], [2,1], [3,4]\nRoot = 3, correct guesses = [1,0], [2,1], [3,2], [3,4]\nRoot = 4, correct guesses = [1,0], [2,1], [3,2]\nConsidering any node as root will give at least 1 correct guess."
        ],
        "constraints": "edges.length == n - 1\n2 <= n <= 105\n1 <= guesses.length <= 105\n0 <= ai, bi, uj, vj <= n - 1\nai != bi\nuj != vj\nedges represents a valid tree.\nguesses[j] is an edge of the tree.\nguesses is unique.\n0 <= k <= guesses.length",
        "oracle_code": "class Solution {\npublic:\n    map<pair<int,int>,int> mp;\n    void dfs(vector<vector<int>>& tree,vector<int>& possible,int cur ,int ans,int k)\n    {\n        for(auto& a:tree[cur])\n        {\n            if(possible[a]==-1)\n            {\n                int new_ans=ans;\n                bool a1=false,a2=false;\n                if(mp.find({a,cur})!=mp.end() && mp[{a,cur}]==0  )\n                {\n                    mp[{a,cur}]=1;\n                    new_ans++;\n                    a1=true;\n                }\n                if(mp.find({cur,a })!=mp.end() && mp[{cur,a}]==1  )\n                {\n                    mp[{cur,a}]=0;\n                    new_ans--;\n                    a2=true;\n                }\n                possible[a]=0;\n                if(new_ans>=k)\n                {\n                    possible[a]=1;\n                }\n                dfs(tree,possible,a,new_ans,k);\n                if(a1)\n                {\n                    mp[{a,cur}]=0;\n                }\n                if(a2)\n                {\n                    mp[{cur,a}]=1;\n                }\n            }\n        }\n\n    }\n    int rootCount(vector<vector<int>>& edges, vector<vector<int>>& guesses, int k) {\n        \n        for(auto&e : guesses)\n        {\n            mp[ {e[0],e[1]}]=0;\n        }\n        int n=edges.size()+1;\n        vector<vector<int>> tree(n);\n        for(auto& e:edges)\n        {\n            tree[e[0]].push_back(e[1]);\n            tree[e[1]].push_back(e[0]);\n        }\n        queue<int> q;\n        q.push(0);\n        vector<bool> visited(n,false);\n        visited[0]=true;\n        int ans=0;\n        while(q.size()>0)\n        {\n            int a=q.front();\n            q.pop();\n            for(int i=0;i<tree[a].size();i++)\n            {\n                if(visited[tree[a][i]])\n                    continue;\n                visited[tree[a][i]]=true;\n                if(mp.find({a,tree[a][i]})!=mp.end() && mp[{a,tree[a][i]}]==0  )\n                {\n                    mp[{a,tree[a][i]}]=1;\n                    ans++;\n                }\n                if(mp.find({tree[a][i],a })!=mp.end() && mp[{tree[a][i],a}]==1  )\n                {\n                    mp[{tree[a][i],a}]=0;\n                    ans--;\n                }\n                q.push(tree[a][i]);\n            }\n        }\n        vector<int> possible(n,-1);\n        possible[0]= (1?ans>=k:0);\n        dfs(tree,possible,0,ans,k);\n        int sum=accumulate(possible.begin(),possible.end(),0);\n        return sum;\n    }\n};",
        "content": "# Intuition\\nSuppose [a,b] is an edge and a is the root of the tree. Now suppose we want to evaluate b as the root of the tree. The only guess that were previously correct and now incorrect would be [a,b]. Similarly the only guess that was previously incorrect but now correct is [b,a].\\n\\n# Approach\\nCreate an adjacency list of the graph ->***tree***. Suppose 0 is the root of the tree. Apply bfs (I used bfs but dfs can be used as well) to evaluate all the guesses that are now correct ->***ans***. Create another array of size n -> ***possible*** that stores if the current node is capable of being the root of the tree. possible[0] = 1 if ans>=k, else possible[0]=0;\\n\\nNow try to evaluate the ans if one of the neighbours of 0 is the root. Suppose [0,b] is an edge in guesses. We will know that since b is now parent, [0,b] guess would now be false. So decrement ans by 1 in this case. Similarly suppose [b,0] was a guess. This guess is now correct. Increment ans by 1 in this case. Again see if ans>=k. If yes, possible[b]=1, else possible[b]=0;\\n\\nContinue this for all the edges in the tree in a dfs manner. Finally return the number of indexes where possible array entry is equal to 1. \\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    map<pair<int,int>,int> mp;\\n    void dfs(vector<vector<int>>& tree,vector<int>& possible,int cur ,int ans,int k)\\n    {\\n        for(auto& a:tree[cur])\\n        {\\n            if(possible[a]==-1)\\n            {\\n                int new_ans=ans;\\n                bool a1=false,a2=false;\\n                if(mp.find({a,cur})!=mp.end() && mp[{a,cur}]==0  )\\n                {\\n                    mp[{a,cur}]=1;\\n                    new_ans++;\\n                    a1=true;\\n                }\\n                if(mp.find({cur,a })!=mp.end() && mp[{cur,a}]==1  )\\n                {\\n                    mp[{cur,a}]=0;\\n                    new_ans--;\\n                    a2=true;\\n                }\\n                possible[a]=0;\\n                if(new_ans>=k)\\n                {\\n                    possible[a]=1;\\n                }\\n                dfs(tree,possible,a,new_ans,k);\\n                if(a1)\\n                {\\n                    mp[{a,cur}]=0;\\n                }\\n                if(a2)\\n                {\\n                    mp[{cur,a}]=1;\\n                }\\n            }\\n        }\\n\\n    }\\n    int rootCount(vector<vector<int>>& edges, vector<vector<int>>& guesses, int k) {\\n        \\n        for(auto&e : guesses)\\n        {\\n            mp[ {e[0],e[1]}]=0;\\n        }\\n        int n=edges.size()+1;\\n        vector<vector<int>> tree(n);\\n        for(auto& e:edges)\\n        {\\n            tree[e[0]].push_back(e[1]);\\n            tree[e[1]].push_back(e[0]);\\n        }\\n        queue<int> q;\\n        q.push(0);\\n        vector<bool> visited(n,false);\\n        visited[0]=true;\\n        int ans=0;\\n        while(q.size()>0)\\n        {\\n            int a=q.front();\\n            q.pop();\\n            for(int i=0;i<tree[a].size();i++)\\n            {\\n                if(visited[tree[a][i]])\\n                    continue;\\n                visited[tree[a][i]]=true;\\n                if(mp.find({a,tree[a][i]})!=mp.end() && mp[{a,tree[a][i]}]==0  )\\n                {\\n                    mp[{a,tree[a][i]}]=1;\\n                    ans++;\\n                }\\n                if(mp.find({tree[a][i],a })!=mp.end() && mp[{tree[a][i],a}]==1  )\\n                {\\n                    mp[{tree[a][i],a}]=0;\\n                    ans--;\\n                }\\n                q.push(tree[a][i]);\\n            }\\n        }\\n        vector<int> possible(n,-1);\\n        possible[0]= (1?ans>=k:0);\\n        dfs(tree,possible,0,ans,k);\\n        int sum=accumulate(possible.begin(),possible.end(),0);\\n        return sum;\\n    }\\n};\\n```",
        "level": "hard",
        "type": [
            "indexing error",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    map<pair<int,int>,int> mp;\n    void dfs(vector<vector<int>>& tree,vector<int>& possible,int cur ,int ans,int k)\n    {\n        for(auto& a:tree[cur])\n        {\n            if(possible[a]==-1)\n            {\n                int new_ans=ans;\n                boolean a1=false,a2=false;\n                if(mp.find({a,cur})!=mp.end() && mp[{a,cur}]==0  )\n                {\n                    mp[{a,cur}]=1;\n                    new_ans++;\n                    a1=true;\n                }\n                if(mp.find({cur,a })!=mp.end() && mp[{cur,a}]==1  )\n                {\n                    mp[{cur,a}]=0;\n                    new_ans--;\n                    a2=true;\n                }\n                possible[a]=0;\n                if(new_ans>=k)\n                {\n                    possible[a+1]=1; \n                }\n                dfs(tree,possible,a,new_ans,k);\n                if(a1)\n                {\n                    mp[{a,cur}]=0;\n                }\n                if(a2)\n                {\n                    mp[{cur,a}]=1;\n                }\n            }\n        }\n\n    }\n    int rootCount(vector<vector<int>>& edges, vector<vector<int>>& guesses, int k) {\n        \n        for(auto&e : guesses)\n        {\n            mp[ {e[0],e[1]}]=0;\n        }\n        int n=edges.size()+1;\n        vector<vector<int>> tree(n);\n        for(auto& e:edges)\n        {\n            tree[e[0]].push_back(e[1]);\n            tree[e[1]].push_back(e[0]);\n        }\n        queue<int> q;\n        q.push(0);\n        vector<bool> visited(n,false);\n        visited[0]=true;\n        int ans=0;\n        while(q.size()>0)\n        {\n            int a=q.front();\n            q.pop();\n            for(int i=0;i<tree[a].size();i++)\n            {\n                if(visited[tree[a][i]])\n                    continue;\n                visited[tree[a][i]]=true;\n                if(mp.find({a,tree[a][i]})!=mp.end() && mp[{a,tree[a][i]}]==0  )\n                {\n                    mp[{a,tree[a][i]}]=1;\n                    ans++;\n                }\n                if(mp.find({tree[a][i],a })!=mp.end() && mp[{tree[a][i],a}]==1  )\n                {\n                    mp[{tree[a][i],a}]=0;\n                    ans--;\n                }\n                q.push(tree[a][i]);\n            }\n        }\n        vector<int> possible(n,-1);\n        possible[0]= (1?ans>=k:0);\n        dfs(tree,possible,0,ans,k);\n        int sum=accumulate(possible.begin(),possible.end(),0);\n        return sum;\n    }\n};\n"
    },
    {
        "slug": "find-the-string-with-lcp",
        "description": "We define the lcp matrix of any 0-indexed string word of n lowercase English letters as an n x n grid such that:\n\nlcp[i][j] is equal to the length of the longest common prefix between the substrings word[i,n-1] and word[j,n-1].\n\nGiven an\u00a0n x n matrix lcp, return the alphabetically smallest string word that corresponds to lcp. If there is no such string, return an empty string.\nA string a is lexicographically smaller than a string b (of the same length) if in the first position where a and b differ, string a has a letter that appears earlier in the alphabet than the corresponding letter in b. For example, \"aabd\" is lexicographically smaller than \"aaca\" because the first position they differ is at the third letter, and 'b' comes before 'c'.",
        "examples": [
            "Input: lcp = [[4,0,2,0],[0,3,0,1],[2,0,2,0],[0,1,0,1]]\nOutput: \"abab\"\nExplanation: lcp corresponds to any 4 letter string with two alternating letters. The lexicographically smallest of them is \"abab\".",
            "Input: lcp = [[4,3,2,1],[3,3,2,1],[2,2,2,1],[1,1,1,1]]\nOutput: \"aaaa\"\nExplanation: lcp corresponds to any 4 letter string with a single distinct letter. The lexicographically smallest of them is \"aaaa\".",
            "Input: lcp = [[4,3,2,1],[3,3,2,1],[2,2,2,1],[1,1,1,3]]\nOutput: \"\"\nExplanation: lcp[3][3] cannot be equal to 3 since word[3,...,3] consists of only a single letter; Thus, no answer exists."
        ],
        "constraints": "1 <= n ==\u00a0lcp.length == lcp[i].length\u00a0<= 1000\n0 <= lcp[i][j] <= n",
        "oracle_code": "class Solution {\npublic:\n    string findTheString(vector<vector<int>>& lcp) {\n       int n= lcp.size();\n       string ans =\"\";\n       if(lcp[0][0]!=n)\n       return ans;\n\n       for(int i=0;i<n;i++){\n           for(int j=0;j<n;j++){\n               if(lcp[i][j]!=lcp[j][i]||lcp[i][j]>n-max(i,j))\n               return ans;\n               if(i+1<n && j+1<n && lcp[i][j]>0 && lcp[i+1][j+1]!=lcp[i][j]-1)\n            return ans;\n           }\n       }\n\n       int t=0;\n       for(int i=0;i<n;i++)\n       ans +='1';\n\n       for(int i=0;i<n;i++){\n           bool flag = false;\n           for(int j=i;j<n;j++){\n               if(ans[j]=='1' && lcp[i][j]!=0){\n                   if(t>=26)\n                   return \"\";\n                   ans[j] ='a'+t;\n                   flag = true;\n               }\n           }\n           if(flag ==true)\n           t++;\n       }\n\n       for(int i=0;i<n;i++){\n           for(int j=0;j<n;j++){\n               if(lcp[i][j]!=0 && ans[i]!=ans[j])\n               return \"\";\n           }\n       }\n       return ans;\n    }\n};",
        "content": "```\\nclass Solution {\\npublic:\\n    string findTheString(vector<vector<int>>& lcp) {\\n       int n= lcp.size();\\n       string ans =\"\";\\n       if(lcp[0][0]!=n)\\n       return ans;\\n\\n       for(int i=0;i<n;i++){\\n           for(int j=0;j<n;j++){\\n               if(lcp[i][j]!=lcp[j][i]||lcp[i][j]>n-max(i,j))\\n               return ans;\\n               if(i+1<n && j+1<n && lcp[i][j]>0 && lcp[i+1][j+1]!=lcp[i][j]-1)\\n            return ans;\\n           }\\n       }\\n\\n       int t=0;\\n       for(int i=0;i<n;i++)\\n       ans +=\\'1\\';\\n\\n       for(int i=0;i<n;i++){\\n           bool flag = false;\\n           for(int j=i;j<n;j++){\\n               if(ans[j]==\\'1\\' && lcp[i][j]!=0){\\n                   if(t>=26)\\n                   return \"\";\\n                   ans[j] =\\'a\\'+t;\\n                   flag = true;\\n               }\\n           }\\n           if(flag ==true)\\n           t++;\\n       }\\n\\n       for(int i=0;i<n;i++){\\n           for(int j=0;j<n;j++){\\n               if(lcp[i][j]!=0 && ans[i]!=ans[j])\\n               return \"\";\\n           }\\n       }\\n       return ans;\\n    }\\n};\\n```",
        "level": "hard",
        "type": [
            "unclosed string",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    string findTheString(vector<vector<int>>& lcp) {\n       int n= lcp.size();\n       string ans =\"\";\n       if(lcp[0][0]!=n)\n       return ans;\n\n       for(int i=0;i<n;i++){\n           for(int j=0;j<n;j++){\n               if(lcp[i][j]!=lcp[j][i]||lcp[i][j]>n-max(i,j))\n               return ans;\n               if(i+1<n && j+1<n && lcp[i][j]>0 && lcp[i+1][j+1]!=lcp[i][j]-1)\n            return ans;\n           }\n       }\n\n       int t=0;\n       for(int i=0;i<n;i++)\n       ans +='1';\n\n       for(int i=0;i<n;i++){\n           bool flag = false;\n           for(int j=i;j<n;j++){\n               if(ans[j]=='1' && lcp[i][j]!=0){\n                   if(t>=26)\n                   return \"\";\n                   ans[j] ='a'+t;\n                   flag = true;\n           }\n           if(flag ==true)\n           t++;\n       }\n\n       for(int i=0;i<n;i++){\n           for(int j=0;j<n;j++){\n               if(lcp[i][j]!=0 && ans[i]!=ans[j])\n               return \"bug\n           }\n       }\n       return ans;\n    }\n};\n"
    },
    {
        "slug": "find-the-winner-of-the-circular-game",
        "description": "There are n friends that are playing a game. The friends are sitting in a circle and are numbered from 1 to n in clockwise order. More formally, moving clockwise from the ith friend brings you to the (i+1)th friend for 1 <= i < n, and moving clockwise from the nth friend brings you to the 1st friend.\nThe rules of the game are as follows:\n\nStart at the 1st friend.\nCount the next k friends in the clockwise direction including the friend you started at. The counting wraps around the circle and may count some friends more than once.\nThe last friend you counted leaves the circle and loses the game.\nIf there is still more than one friend in the circle, go back to step 2 starting from the friend immediately clockwise of the friend who just lost and repeat.\nElse, the last friend in the circle wins the game.\n\nGiven the number of friends, n, and an integer k, return the winner of the game.",
        "examples": [
            "Input: n = 5, k = 2\nOutput: 3\nExplanation: Here are the steps of the game:\n1) Start at friend 1.\n2) Count 2 friends clockwise, which are friends 1 and 2.\n3) Friend 2 leaves the circle. Next start is friend 3.\n4) Count 2 friends clockwise, which are friends 3 and 4.\n5) Friend 4 leaves the circle. Next start is friend 5.\n6) Count 2 friends clockwise, which are friends 5 and 1.\n7) Friend 1 leaves the circle. Next start is friend 3.\n8) Count 2 friends clockwise, which are friends 3 and 5.\n9) Friend 5 leaves the circle. Only friend 3 is left, so they are the winner.",
            "Input: n = 6, k = 5\nOutput: 1\nExplanation: The friends leave in this order: 5, 4, 6, 2, 3. The winner is friend 1."
        ],
        "constraints": "1 <= k <= n <= 500",
        "oracle_code": "class Solution {\npublic:\n    int findTheWinner(int n, int k) {\n        vector<int> v;\n        for (int i=1; i<=n; i++)v.push_back(i);\n        int i=0;\n        while (v.size() != 1){\n            i= (i+k-1)%(v.size());\n            //cout<<v[i]<<endl;\n            v.erase(v.begin()+i);\n        }\n        return v[0];\n    }\n};",
        "content": "## Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n## Code\\n```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        vector<int> v;\\n        for (int i=1; i<=n; i++)v.push_back(i);\\n        int i=0;\\n        while (v.size() != 1){\\n            i= (i+k-1)%(v.size());\\n            //cout<<v[i]<<endl;\\n            v.erase(v.begin()+i);\\n        }\\n        return v[0];\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "indexing error",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    int findTheWinner(int n, int k) {\n        vector<int> v;\n        for (int i=1; i<=n+1; i++)v.push_back(i);\n        int i=0;\n        undefined(i+k-1)%(v.size());\n        while (v.size() != 1){\n            i= (i+k-1)%(v.size());\n            //cout<<v[i]<<endl;\n            v.erase(v.begin()+i);\n        }\n        return v[0];\n    }\n};\n"
    },
    {
        "slug": "min-cost-climbing-stairs",
        "description": "You are given an integer array cost where cost[i] is the cost of ith step on a staircase. Once you pay the cost, you can either climb one or two steps.\nYou can either start from the step with index 0, or the step with index 1.\nReturn the minimum cost to reach the top of the floor.",
        "examples": [
            "Input: cost = [10,15,20]\nOutput: 15\nExplanation: You will start at index 1.\n- Pay 15 and climb two steps to reach the top.\nThe total cost is 15.",
            "Input: cost = [1,100,1,1,1,100,1,1,100,1]\nOutput: 6\nExplanation: You will start at index 0.\n- Pay 1 and climb two steps to reach index 2.\n- Pay 1 and climb two steps to reach index 4.\n- Pay 1 and climb two steps to reach index 6.\n- Pay 1 and climb one step to reach index 7.\n- Pay 1 and climb two steps to reach index 9.\n- Pay 1 and climb one step to reach the top.\nThe total cost is 6."
        ],
        "constraints": "2 <= cost.length <= 1000\n0 <= cost[i] <= 999",
        "oracle_code": "class Solution {\npublic:\n    int minCostClimbingStairs(vector<int>& cost) {\n        int n = cost.size();\n\n        for(int i=2; i<n; i++){\n            cost[i] = min(cost[i-1],cost[i-2]) + cost[i];\n        }\n\n        return min(cost[n-1],cost[n-2]);\n    }\n};",
        "content": "\\n# Approach\\nDynamic Programming without using any extra memory. Modifying the given array itself.\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minCostClimbingStairs(vector<int>& cost) {\\n        int n = cost.size();\\n\\n        for(int i=2; i<n; i++){\\n            cost[i] = min(cost[i-1],cost[i-2]) + cost[i];\\n        }\\n\\n        return min(cost[n-1],cost[n-2]);\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "conditional statement error",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    int minCostClimbingStairs(vector<int>& cost) {\n        int n = cost.size();\n\n        for(int i=2; i<=n; i++){\n            cost[i] = min1(cost[i-1],cost[i-2]) + cost[i];\n        }\n\n        return min1(cost[n-1],cost[n-2]);\n    }\n};\n"
    },
    {
        "slug": "add-binary",
        "description": "Given two binary strings a and b, return their sum as a binary string.",
        "examples": [
            "Input: a = \"11\", b = \"1\"\nOutput: \"100\"",
            "Input: a = \"1010\", b = \"1011\"\nOutput: \"10101\""
        ],
        "constraints": "1 <= a.length, b.length <= 104\na and b consist\u00a0only of '0' or '1' characters.\nEach string does not contain leading zeros except for the zero itself.",
        "oracle_code": "class Solution {\npublic:\n    string addBinary(string a, string b) {\n        int c=0;\n        string s=\"\";\n        int i=0;\n        while(i<a.length() || i<b.length() || c!=0){\n            int x=0;\n            if(i<a.length() && a[a.length()-i-1]=='1')\n                x=1;\n            int y=0;\n            if(i<b.length() && b[b.length()-1-i]=='1')\n                y=1;\n            s=to_string((x+y+c)%2)+s;\n            c=(x+y+c)/2;\n            i++;\n        }\n        return s;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        int c=0;\\n        string s=\"\";\\n        int i=0;\\n        while(i<a.length() || i<b.length() || c!=0){\\n            int x=0;\\n            if(i<a.length() && a[a.length()-i-1]==\\'1\\')\\n                x=1;\\n            int y=0;\\n            if(i<b.length() && b[b.length()-1-i]==\\'1\\')\\n                y=1;\\n            s=to_string((x+y+c)%2)+s;\\n            c=(x+y+c)/2;\\n            i++;\\n        }\\n        return s;\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "statement separation",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    string addBinary(string a, string b) {\n        int c=0;\n        string s=\"\";\n        int i=0;\n        while(i<a.length() || i<b.length() || c!=0)\n            int x=0;\n            if(i<a.length() && a[i]=='1')\n                x=1;\n            int y=0;\n            if(i<b.length() && b[i]=='1')\n                y=1;\n            s=to_string((x+y+c)%2)+s;\n            c=(x+y+c)/2;\n            i++;\n        return s;\n    }\n};\n"
    },
    {
        "slug": "find-the-student-that-will-replace-the-chalk",
        "description": "There are n students in a class numbered from 0 to n - 1. The teacher will give each student a problem starting with the student number 0, then the student number 1, and so on until the teacher reaches the student number n - 1. After that, the teacher will restart the process, starting with the student number 0 again.\nYou are given a 0-indexed integer array chalk and an integer k. There are initially k pieces of chalk. When the student number i is given a problem to solve, they will use chalk[i] pieces of chalk to solve that problem. However, if the current number of chalk pieces is strictly less than chalk[i], then the student number i will be asked to replace the chalk.\nReturn the index of the student that will replace the chalk pieces.",
        "examples": [
            "Input: chalk = [5,1,5], k = 22\nOutput: 0\nExplanation: The students go in turns as follows:\n- Student number 0 uses 5 chalk, so k = 17.\n- Student number 1 uses 1 chalk, so k = 16.\n- Student number 2 uses 5 chalk, so k = 11.\n- Student number 0 uses 5 chalk, so k = 6.\n- Student number 1 uses 1 chalk, so k = 5.\n- Student number 2 uses 5 chalk, so k = 0.\nStudent number 0 does not have enough chalk, so they will have to replace it.",
            "Input: chalk = [3,4,1,2], k = 25\nOutput: 1\nExplanation: The students go in turns as follows:\n- Student number 0 uses 3 chalk so k = 22.\n- Student number 1 uses 4 chalk so k = 18.\n- Student number 2 uses 1 chalk so k = 17.\n- Student number 3 uses 2 chalk so k = 15.\n- Student number 0 uses 3 chalk so k = 12.\n- Student number 1 uses 4 chalk so k = 8.\n- Student number 2 uses 1 chalk so k = 7.\n- Student number 3 uses 2 chalk so k = 5.\n- Student number 0 uses 3 chalk so k = 2.\nStudent number 1 does not have enough chalk, so they will have to replace it."
        ],
        "constraints": "chalk.length == n\n1 <= n <= 105\n1 <= chalk[i] <= 105\n1 <= k <= 109",
        "oracle_code": "class Solution {\npublic:\n    int chalkReplacer(vector<int>& chalk, int k) {\n       long long sum =0;\n       for(int i=0; i<chalk.size();i++){\n           sum+=chalk[i];\n       }\n\n       \n\n       if(k%sum !=0){\n           int x = k%sum;\n           for(int i=0; i<chalk.size();i++){\n               x-=chalk[i];\n               if(x<0){\n                   return i;\n                   break;\n               }\n           }\n       }\n\n       return 0;\n    }\n};",
        "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int chalkReplacer(vector<int>& chalk, int k) {\\n       long long sum =0;\\n       for(int i=0; i<chalk.size();i++){\\n           sum+=chalk[i];\\n       }\\n\\n       \\n\\n       if(k%sum !=0){\\n           int x = k%sum;\\n           for(int i=0; i<chalk.size();i++){\\n               x-=chalk[i];\\n               if(x<0){\\n                   return i;\\n                   break;\\n               }\\n           }\\n       }\\n\\n       return 0;\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "conditional statement error",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    int chalkReplacer(vector<int>& chalk, int k) {\n       long long sum =0;\n       for(int i=0; i<chalk.size();i++){\n           sum+=chalk[i];\n       }\n\n       if((k%sum == 0){\n           int x = k%sum;\n           for(int i=0; i<chalk.size();i++){\n               x-=chalk[i];\n               if(x<0){\n                   return i;\n                   break;\n               }\n           }\n       }\n\n       return 0;\n    }\n};\n"
    },
    {
        "slug": "number-of-matching-subsequences",
        "description": "Given a string s and an array of strings words, return the number of words[i] that is a subsequence of s.\nA subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.\n\nFor example, \"ace\" is a subsequence of \"abcde\".",
        "examples": [
            "Input: s = \"abcde\", words = [\"a\",\"bb\",\"acd\",\"ace\"]\nOutput: 3\nExplanation: There are three strings in words that are a subsequence of s: \"a\", \"acd\", \"ace\".",
            "Input: s = \"dsahjpjauf\", words = [\"ahjpjau\",\"ja\",\"ahbwzgqnuk\",\"tnmlanowax\"]\nOutput: 2"
        ],
        "constraints": "1 <= s.length <= 5 * 104\n1 <= words.length <= 5000\n1 <= words[i].length <= 50\ns and words[i] consist of only lowercase English letters.",
        "oracle_code": "class Solution {\npublic:\nmap<char,vector<int>> count;\n    int numMatchingSubseq(string s, vector<string>& words) {\n        for(int i=0;i<s.size();i++){\n            count[s[i]].push_back(i);//add each position of each char\n        }\n        int z=0;\n        for(auto& x:words){\n            int p=-1;//find element greater thn this index\n            int r=0;//flag bit\n            for(int j=0;j<x.size();j++){\n                if(count.find(x[j])==count.end()){r=1;break;}\n                if(upper_bound(count[x[j]].begin(),count[x[j]].end(),p)==count[x[j]].end()){r=1;break;}//if grtr position not found\n                p=count[x[j]][upper_bound(count[x[j]].begin(),count[x[j]].end(),p)-count[x[j]].begin()];//updating search index\n                }\n            if(r==0)z+=1;\n        }\n        return z;\n    }\n};",
        "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\nmap<char,vector<int>> count;\\n    int numMatchingSubseq(string s, vector<string>& words) {\\n        for(int i=0;i<s.size();i++){\\n            count[s[i]].push_back(i);//add each position of each char\\n        }\\n        int z=0;\\n        for(auto& x:words){\\n            int p=-1;//find element greater thn this index\\n            int r=0;//flag bit\\n            for(int j=0;j<x.size();j++){\\n                if(count.find(x[j])==count.end()){r=1;break;}\\n                if(upper_bound(count[x[j]].begin(),count[x[j]].end(),p)==count[x[j]].end()){r=1;break;}//if grtr position not found\\n                p=count[x[j]][upper_bound(count[x[j]].begin(),count[x[j]].end(),p)-count[x[j]].begin()];//updating search index\\n                }\\n            if(r==0)z+=1;\\n        }\\n        return z;\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "operation error",
            "wrong comment mark"
        ],
        "buggy_code": "\nclass Solution {\npublic:\nmap<char,vector<int>> count;\n    int numMatchingSubseq(string s, vector<string>/& words) {\n        for(int i=0;i<s.size();i++){\n            count[s[i]].push_back(i);//add each position of each char\n        }\n        int z=0;\n        for(auto& x:words){\n            int p=-1;//find element greater thn this index\n            int r=0;//flag bit\n            for(int j=0;j<x.size();j++){\n                if(count.find(x[j])==count.end()){r=1;break;}\n                if(upper_bound(count[x[j]].begin(),count[x[j]].end(),p)==count[x[j]].end()){r=1;break;}//if grtr position not found\n                p=upper_bound(count[x[j]].begin(),count[x[j]].end(),p)-count[x[j]].begin();\n                }\n            if(r==0)z+=1;\n        }\n        return z;\n    }\n};\n"
    },
    {
        "slug": "perfect-squares",
        "description": "Given an integer n, return the least number of perfect square numbers that sum to n.\nA perfect square is an integer that is the square of an integer; in other words, it is the product of some integer with itself. For example, 1, 4, 9, and 16 are perfect squares while 3 and 11 are not.",
        "examples": [
            "Input: n = 12\nOutput: 3\nExplanation: 12 = 4 + 4 + 4.",
            "Input: n = 13\nOutput: 2\nExplanation: 13 = 4 + 9."
        ],
        "constraints": "1 <= n <= 104",
        "oracle_code": "class Solution {\npublic:\n\n    // declare a dp\n\n    int dp[105][10005];\n\n    int helper(vector<int>& arr, int i, int n, int sum)\n    {\n        // base case\n\n        if(sum == 0)\n        {\n            return 0;\n        }\n\n        if(i >= n || sum < 0)\n        {\n            return INT_MAX - 1000;\n        }\n\n        // if already calculated\n\n        if(dp[i][sum] != -1)\n        {\n            return dp[i][sum];\n        }\n\n        // at each ith element we have two options either include or exclude\n\n        int mini = INT_MAX;\n\n        // inclusion part\n\n        if(arr[i] <= sum)\n        {\n            mini = min(mini, 1 + helper(arr, i, n, sum - arr[i]));\n        }\n\n        // exclusion part\n\n        mini = min(mini, helper(arr, i + 1, n, sum));\n\n        // store the res in dp\n\n        return dp[i][sum] = mini;\n    }\n\n    int numSquares(int n) {\n\n        vector<int> arr;\n\n        // find all the squares between 1 to n\n\n        for(int i = 1; i * i <= n; i++)\n        {\n            arr.push_back(i * i);\n        }\n\n        // initialize dp with -1\n\n        memset(dp, -1, sizeof(dp));\n\n        return helper(arr, 0, arr.size(), n);\n    }\n};",
        "content": "* ***Using Recursion && Memoization***\\n\\n* ***Time Complexity :- O(N * sqrt(N))***\\n\\n* ***Space Complexity :- O(N * sqrt(N))***\\n\\n* ***There are sqrt(N), squares between 1 to N***\\n\\n```\\nclass Solution {\\npublic:\\n\\n    // declare a dp\\n\\n    int dp[105][10005];\\n\\n    int helper(vector<int>& arr, int i, int n, int sum)\\n    {\\n        // base case\\n\\n        if(sum == 0)\\n        {\\n            return 0;\\n        }\\n\\n        if(i >= n || sum < 0)\\n        {\\n            return INT_MAX - 1000;\\n        }\\n\\n        // if already calculated\\n\\n        if(dp[i][sum] != -1)\\n        {\\n            return dp[i][sum];\\n        }\\n\\n        // at each ith element we have two options either include or exclude\\n\\n        int mini = INT_MAX;\\n\\n        // inclusion part\\n\\n        if(arr[i] <= sum)\\n        {\\n            mini = min(mini, 1 + helper(arr, i, n, sum - arr[i]));\\n        }\\n\\n        // exclusion part\\n\\n        mini = min(mini, helper(arr, i + 1, n, sum));\\n\\n        // store the res in dp\\n\\n        return dp[i][sum] = mini;\\n    }\\n\\n    int numSquares(int n) {\\n\\n        vector<int> arr;\\n\\n        // find all the squares between 1 to n\\n\\n        for(int i = 1; i * i <= n; i++)\\n        {\\n            arr.push_back(i * i);\\n        }\\n\\n        // initialize dp with -1\\n\\n        memset(dp, -1, sizeof(dp));\\n\\n        return helper(arr, 0, arr.size(), n);\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "== and = confusion",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n\n    // declare a dp\n\n    int dp[105][10005];\n\n    int helper(vector<int>& arr, int i, int n, int sum)\n    {\n        // base case\n\n        if(sum == 0)\n        {\n            return 0;\n        }\n\n        if(i >= n || sum < 0)\n        {\n            return INT_MAX - 1000;\n        }\n\n        // if already calculated\n\n        if(dp[i][sum] != -1)\n        {\n            return dp[i][sum];\n        }\n\n        // at each ith element we have two options either include or exclude\n\n        int mini = INT_MAX;\n\n        // inclusion part\n\n        if(arr[i] == sum)\n        {\n            mini = min(mini, 1 + helper(arr, i, n, sum - arr[i]));\n        }\n\n        // exclusion part\n\n        mini = min(mini, helper(arr, i + 1, n, sum));\n\n        // store the res in dp\n\n        return dp[i][sum] = mini;\n    }\n\n    int numSquares(int n) {\n\n        vector<int> arr;\n\n        // find all the squares between 1 to n\n\n        for(int i = 1; i * i <= n; i++)\n        {\n            arr.push_back(i * i);\n        }\n\n        // initialize dp with -1\n\n        memset(dp, -1, sizeof(dp));\n\n        \n        print(helper(arr, 0, arr.size(), n));\n    }\n};\n"
    },
    {
        "slug": "find-the-student-that-will-replace-the-chalk",
        "description": "There are n students in a class numbered from 0 to n - 1. The teacher will give each student a problem starting with the student number 0, then the student number 1, and so on until the teacher reaches the student number n - 1. After that, the teacher will restart the process, starting with the student number 0 again.\nYou are given a 0-indexed integer array chalk and an integer k. There are initially k pieces of chalk. When the student number i is given a problem to solve, they will use chalk[i] pieces of chalk to solve that problem. However, if the current number of chalk pieces is strictly less than chalk[i], then the student number i will be asked to replace the chalk.\nReturn the index of the student that will replace the chalk pieces.",
        "examples": [
            "Input: chalk = [5,1,5], k = 22\nOutput: 0\nExplanation: The students go in turns as follows:\n- Student number 0 uses 5 chalk, so k = 17.\n- Student number 1 uses 1 chalk, so k = 16.\n- Student number 2 uses 5 chalk, so k = 11.\n- Student number 0 uses 5 chalk, so k = 6.\n- Student number 1 uses 1 chalk, so k = 5.\n- Student number 2 uses 5 chalk, so k = 0.\nStudent number 0 does not have enough chalk, so they will have to replace it.",
            "Input: chalk = [3,4,1,2], k = 25\nOutput: 1\nExplanation: The students go in turns as follows:\n- Student number 0 uses 3 chalk so k = 22.\n- Student number 1 uses 4 chalk so k = 18.\n- Student number 2 uses 1 chalk so k = 17.\n- Student number 3 uses 2 chalk so k = 15.\n- Student number 0 uses 3 chalk so k = 12.\n- Student number 1 uses 4 chalk so k = 8.\n- Student number 2 uses 1 chalk so k = 7.\n- Student number 3 uses 2 chalk so k = 5.\n- Student number 0 uses 3 chalk so k = 2.\nStudent number 1 does not have enough chalk, so they will have to replace it."
        ],
        "constraints": "chalk.length == n\n1 <= n <= 105\n1 <= chalk[i] <= 105\n1 <= k <= 109",
        "oracle_code": "class Solution {\npublic:\n    int chalkReplacer(vector<int>& chalk, int k) {\n       long long sum =0;\n       for(int i=0; i<chalk.size();i++){\n           sum+=chalk[i];\n       }\n\n       \n\n       if(k%sum !=0){\n           int x = k%sum;\n           for(int i=0; i<chalk.size();i++){\n               x-=chalk[i];\n               if(x<0){\n                   return i;\n                   break;\n               }\n           }\n       }\n\n       return 0;\n    }\n};",
        "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int chalkReplacer(vector<int>& chalk, int k) {\\n       long long sum =0;\\n       for(int i=0; i<chalk.size();i++){\\n           sum+=chalk[i];\\n       }\\n\\n       \\n\\n       if(k%sum !=0){\\n           int x = k%sum;\\n           for(int i=0; i<chalk.size();i++){\\n               x-=chalk[i];\\n               if(x<0){\\n                   return i;\\n                   break;\\n               }\\n           }\\n       }\\n\\n       return 0;\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "indexing error",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    int chalkReplacer(vector<int>& chalk, int k) {\n       long long sum =0;\n       for(int i=0; i<=chalk.size();i++){\n           sum+=chalk[i];\n       }\n\n       if((k%sum !=0){\n           int x = k%sum;\n           for(int i=0; i<=chalk.size();i++){\n               x-=chalk[i];\n               if(x<0){\n                   return i;\n                   break;\n               }\n           }\n       }\n\n       return 0;\n    }\n};\n"
    },
    {
        "slug": "valid-boomerang",
        "description": "Given an array points where points[i] = [xi, yi] represents a point on the X-Y plane, return true if these points are a boomerang.\nA boomerang is a set of three points that are all distinct and not in a straight line.",
        "examples": [
            "Input: points = [[1,1],[2,3],[3,2]]\nOutput: true",
            "Input: points = [[1,1],[2,2],[3,3]]\nOutput: false"
        ],
        "constraints": "points.length == 3\npoints[i].length == 2\n0 <= xi, yi <= 100",
        "oracle_code": "class Solution {\npublic:\n    bool isBoomerang(vector<vector<int>>& points) {\n        float a,b,c,d;\n        a = (points[1][1]-points[0][1]);\n        b = (points[1][0]-points[0][0]);\n        c = (points[2][1]-points[1][1]);\n        d = (points[2][0]-points[1][0]);\n        if((b!=0 && d!=0 && a*d==b*c) || (b==0 && d==0 && points[0][0]==points[1][0]))\n        {\n            return false;\n        }\n        if((points[0][0]==points[1][0] && points[0][1]==points[1][1]) || (points[0][0]==points[2][0] && points[0][1]==points[2][1]) || (points[1][0]==points[2][0] && points[1][1]==points[2][1]))\n        {\n            return false;\n        }\n        return true;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSlopes are matched : (y2-y1)/(x2-x1)\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isBoomerang(vector<vector<int>>& points) {\\n        float a,b,c,d;\\n        a = (points[1][1]-points[0][1]);\\n        b = (points[1][0]-points[0][0]);\\n        c = (points[2][1]-points[1][1]);\\n        d = (points[2][0]-points[1][0]);\\n        if((b!=0 && d!=0 && a*d==b*c) || (b==0 && d==0 && points[0][0]==points[1][0]))\\n        {\\n            return false;\\n        }\\n        if((points[0][0]==points[1][0] && points[0][1]==points[1][1]) || (points[0][0]==points[2][0] && points[0][1]==points[2][1]) || (points[1][0]==points[2][0] && points[1][1]==points[2][1]))\\n        {\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/6d6312fc-589e-44f6-989d-a97c5ba0b0c3_1683522399.5758274.jpeg)\\n",
        "level": "easy",
        "type": [
            "indexing error",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    bool isBoomerang(vector<vector<int>>& points) {\n        float a,b,c,d;\n        a = (points[1][1]-points[0][1]);\n        b = (points[1][0]-points[0][0]);\n        c = (points[2][1]-points[1][1]);\n        d = (points[3][0]-points[1][0]);\n        if(b!=0 && d!=0 && a*d==b*c) || (b==0 && d==0 && points[0][0]==points[1][0])\n        {\n            return false;\n        }\n        if((points[0][0]==points[1][0] && points[0][1]==points[1][1]) || (points[0][0]==points[2][0] && points[0][1]==points[2][1]) || (points[1][0]==points[2][0] && points[1][1]==points[2][1]))\n        {\n            return false;\n        }\n        return true;\n    }\n};\n"
    },
    {
        "slug": "perfect-squares",
        "description": "Given an integer n, return the least number of perfect square numbers that sum to n.\nA perfect square is an integer that is the square of an integer; in other words, it is the product of some integer with itself. For example, 1, 4, 9, and 16 are perfect squares while 3 and 11 are not.",
        "examples": [
            "Input: n = 12\nOutput: 3\nExplanation: 12 = 4 + 4 + 4.",
            "Input: n = 13\nOutput: 2\nExplanation: 13 = 4 + 9."
        ],
        "constraints": "1 <= n <= 104",
        "oracle_code": "class Solution {\npublic:\n\n    // declare a dp\n\n    int dp[105][10005];\n\n    int helper(vector<int>& arr, int i, int n, int sum)\n    {\n        // base case\n\n        if(sum == 0)\n        {\n            return 0;\n        }\n\n        if(i >= n || sum < 0)\n        {\n            return INT_MAX - 1000;\n        }\n\n        // if already calculated\n\n        if(dp[i][sum] != -1)\n        {\n            return dp[i][sum];\n        }\n\n        // at each ith element we have two options either include or exclude\n\n        int mini = INT_MAX;\n\n        // inclusion part\n\n        if(arr[i] <= sum)\n        {\n            mini = min(mini, 1 + helper(arr, i, n, sum - arr[i]));\n        }\n\n        // exclusion part\n\n        mini = min(mini, helper(arr, i + 1, n, sum));\n\n        // store the res in dp\n\n        return dp[i][sum] = mini;\n    }\n\n    int numSquares(int n) {\n\n        vector<int> arr;\n\n        // find all the squares between 1 to n\n\n        for(int i = 1; i * i <= n; i++)\n        {\n            arr.push_back(i * i);\n        }\n\n        // initialize dp with -1\n\n        memset(dp, -1, sizeof(dp));\n\n        return helper(arr, 0, arr.size(), n);\n    }\n};",
        "content": "* ***Using Recursion && Memoization***\\n\\n* ***Time Complexity :- O(N * sqrt(N))***\\n\\n* ***Space Complexity :- O(N * sqrt(N))***\\n\\n* ***There are sqrt(N), squares between 1 to N***\\n\\n```\\nclass Solution {\\npublic:\\n\\n    // declare a dp\\n\\n    int dp[105][10005];\\n\\n    int helper(vector<int>& arr, int i, int n, int sum)\\n    {\\n        // base case\\n\\n        if(sum == 0)\\n        {\\n            return 0;\\n        }\\n\\n        if(i >= n || sum < 0)\\n        {\\n            return INT_MAX - 1000;\\n        }\\n\\n        // if already calculated\\n\\n        if(dp[i][sum] != -1)\\n        {\\n            return dp[i][sum];\\n        }\\n\\n        // at each ith element we have two options either include or exclude\\n\\n        int mini = INT_MAX;\\n\\n        // inclusion part\\n\\n        if(arr[i] <= sum)\\n        {\\n            mini = min(mini, 1 + helper(arr, i, n, sum - arr[i]));\\n        }\\n\\n        // exclusion part\\n\\n        mini = min(mini, helper(arr, i + 1, n, sum));\\n\\n        // store the res in dp\\n\\n        return dp[i][sum] = mini;\\n    }\\n\\n    int numSquares(int n) {\\n\\n        vector<int> arr;\\n\\n        // find all the squares between 1 to n\\n\\n        for(int i = 1; i * i <= n; i++)\\n        {\\n            arr.push_back(i * i);\\n        }\\n\\n        // initialize dp with -1\\n\\n        memset(dp, -1, sizeof(dp));\\n\\n        return helper(arr, 0, arr.size(), n);\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "== and = confusion",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n\n    int dp[105][10005];\n\n    int helper(vector<int>& arr, int i, int n, int sum)\n    {\n        if(i >= n || sum <= 0) \n        {\n            return INT_MAX - 1000;\n        }\n\n        if(dp[i][sum] != -1)\n        {\n            return dp[i][sum];\n        }\n\n        int mini = INT_MAX;\n\n        if(arr[i] <= sum)\n        {\n            mini = min(mini, 1 + helper(arr=, i, n, sum - arr[i]));\n        }\n\n        mini = min(mini, helper(arr, i + 1, n, sum));\n\n        return dp[i][sum] = mini;\n    }\n\n    int numSquares(int n) {\n\n        vector<int> arr;\n\n        for(int i = 1; i * i <= n; i++)\n        {\n            arr.push_back(i * i);\n        }\n\n        memset(dp, -1, sizeof(dp));\n\n        return helper(arr, 0, arr.size(), n);\n    }\n};\n"
    },
    {
        "slug": "shortest-bridge",
        "description": "You are given an n x n binary matrix grid where 1 represents land and 0 represents water.\nAn island is a 4-directionally connected group of 1's not connected to any other 1's. There are exactly two islands in grid.\nYou may change 0's to 1's to connect the two islands to form one island.\nReturn the smallest number of 0's you must flip to connect the two islands.",
        "examples": [
            "Input: grid = [[0,1],[1,0]]\nOutput: 1",
            "Input: grid = [[0,1,0],[0,0,0],[0,0,1]]\nOutput: 2",
            "Input: grid = [[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]]\nOutput: 1"
        ],
        "constraints": "n == grid.length == grid[i].length\n2 <= n <= 100\ngrid[i][j] is either 0 or 1.\nThere are exactly two islands in grid.",
        "oracle_code": "class Solution {\npublic:\n\nint r[4] = {-1 , 0, 1, 0};\nint c[4] = {0 ,1 , 0 , -1};\n\nvoid dfs(int row ,int col , vector<pair<int,int>> &v,vector<vector<int>>&vis,vector<vector<int>>&grid)\n{\n    int n = vis[0].size();\n    vis[row][col] = 1;\n    v.push_back({row , col});\n    for(int i=0; i<4; i++)\n    {\n        int nrow = row + r[i];\n        int ncol = col + c[i];\n\n        if(nrow>=0 and ncol>=0 and nrow<n and ncol<n and vis[nrow][ncol] == 0 and grid[nrow][ncol] == 1)\n        {\n            dfs(nrow , ncol , v , vis , grid);\n        }\n    }\n\n}\n\n    int shortestBridge(vector<vector<int>>& grid) {\n        \n        vector<pair<int,int>> v;\n        vector<pair<int,int>> v1;\n        vector<pair<int,int>> v2;\n        int n = grid.size();\n        vector<vector<int>> vis(n , vector<int>(n , 0));\n        bool flag = 0;\n        for(int i=0; i<n; i++)\n        {\n            for(int j=0; j<n; j++)\n            {\n                if(grid[i][j] == 1 and vis[i][j] == 0)\n                {\n                    dfs(i , j , v , vis, grid);\n                    if(flag == 0)\n                    {\n                        v1 = v;\n                        flag = 1;\n                        v.clear();\n                    }\n                    else\n                    {\n                        v2 = v;\n                    }\n                }\n            \n            }\n           \n        }\n        //printed just to check the co-ordinates****\n        //for(auto it: v1)\n        //{\n        //    cout<<it.first<<\" \"<<it.second<<endl;\n        //}\n        //for(auto it: v2)\n        //{\n        //    cout<<it.first<<\" \"<<it.second<<endl;\n        //}\n        int ans = 1e9;\n\n\n        for(auto it: v1)\n        {\n            int row1 = it.first;\n            int col1 = it.second;\n\n            for(auto itt: v2)\n            {\n                int row2 = itt.first;\n                int col2 = itt.second;\n\n                int dist = abs(row1 - row2) + abs(col1 - col2);\n                dist--;\n                ans = min(ans , dist);\n            }\n        }\n    \n        return ans;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nsimple push all the co-ordinates of the first and second island in two vectors by using dfs and then just calculate the distance between each point to every other point in both the vectors and since n is very small we will not get tle and this solution is accepted.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n**1.Push all the co-ordinates of the first and second island in two vectors\\n2.then calculate the distance between each point to every point \\n3.take the minimum distance \\n4.return the minimum distance**\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\ncomment time complexity in comments \\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\ncomment space complexity in comments \\n# Code\\n```\\nclass Solution {\\npublic:\\n\\nint r[4] = {-1 , 0, 1, 0};\\nint c[4] = {0 ,1 , 0 , -1};\\n\\nvoid dfs(int row ,int col , vector<pair<int,int>> &v,vector<vector<int>>&vis,vector<vector<int>>&grid)\\n{\\n    int n = vis[0].size();\\n    vis[row][col] = 1;\\n    v.push_back({row , col});\\n    for(int i=0; i<4; i++)\\n    {\\n        int nrow = row + r[i];\\n        int ncol = col + c[i];\\n\\n        if(nrow>=0 and ncol>=0 and nrow<n and ncol<n and vis[nrow][ncol] == 0 and grid[nrow][ncol] == 1)\\n        {\\n            dfs(nrow , ncol , v , vis , grid);\\n        }\\n    }\\n\\n}\\n\\n    int shortestBridge(vector<vector<int>>& grid) {\\n        \\n        vector<pair<int,int>> v;\\n        vector<pair<int,int>> v1;\\n        vector<pair<int,int>> v2;\\n        int n = grid.size();\\n        vector<vector<int>> vis(n , vector<int>(n , 0));\\n        bool flag = 0;\\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=0; j<n; j++)\\n            {\\n                if(grid[i][j] == 1 and vis[i][j] == 0)\\n                {\\n                    dfs(i , j , v , vis, grid);\\n                    if(flag == 0)\\n                    {\\n                        v1 = v;\\n                        flag = 1;\\n                        v.clear();\\n                    }\\n                    else\\n                    {\\n                        v2 = v;\\n                    }\\n                }\\n            \\n            }\\n           \\n        }\\n        //printed just to check the co-ordinates****\\n        //for(auto it: v1)\\n        //{\\n        //    cout<<it.first<<\" \"<<it.second<<endl;\\n        //}\\n        //for(auto it: v2)\\n        //{\\n        //    cout<<it.first<<\" \"<<it.second<<endl;\\n        //}\\n        int ans = 1e9;\\n\\n\\n        for(auto it: v1)\\n        {\\n            int row1 = it.first;\\n            int col1 = it.second;\\n\\n            for(auto itt: v2)\\n            {\\n                int row2 = itt.first;\\n                int col2 = itt.second;\\n\\n                int dist = abs(row1 - row2) + abs(col1 - col2);\\n                dist--;\\n                ans = min(ans , dist);\\n            }\\n        }\\n    \\n        return ans;\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "statement separation",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n\nint r[4] = {-1 , 0, 1, 0};\nint c[4] = {0 ,1 , 0 , -1};\n\nvoid dfs(int row ,int col , vector<pair<int,int>> &v,vector<vector<int>>&vis,vector<vector<int>>&grid)\n{\n    int n = vis[0].size();\n    vis[row][col] = 1;\n    v.push_back({row , col});\n    for(int i=0; i<4; i++)\n    {\n        int nrow = row + r[i];\n        int ncol = col + c[i];\n\n        if(nrow>=0 and ncol>=0 and nrow<n and ncol<n and vis[nrow][ncol] == 0 and grid[nrow][ncol] == 1);\n        {\n            dfs(nrow , ncol , v , vis , grid);\n        }\n    }\n\n}\n\n    int shortestBridge(vector<vector<int>>& grid) {\n        \n        vector<pair<int,int>> v;\n        vector<pair<int,int>> v1;\n        vector<pair<int,int>> v2;\n        int n = grid.size();\n        vector<vector<int>> vis(n , vector<int>(n , 0));\n        bool flag = 0;\n        for(int i=0; i<n; i++)\n        {\n            for(int j=0; j<n; j++)\n            {\n                if(grid[i][j] == 1 and vis[i][j] == 0)\n                {\n                    dfs(i , j , v , vis, grid);\n                    if(flag == 0)\n                    {\n                        v1 = v;\n                        flag = 1;\n                        v.clear();\n                    }\n                    else\n                    {\n                        v2 = v;\n                    }\n                }\n            \n            }\n           \n        }\n\n        int ans = 1e9;\n        string outans = 1e9;\n\n\n        for(au=\"stbridgeis:\"\n\n    to it: v1)\n        {\n            int row1 = it.first;\n            int col1 = it.second;\n\n            for(auto itt: v2)\n            {\n                int row2 = itt.first;\n                int col2 = itt.second;\n\n                int dist = abs(row1 - row2) + abs(col1 - col2);\n                dist--;\n                ans = min(ans , dist);\n            }\n        }\n    \n        return ans;\n    }\n};\n"
    },
    {
        "slug": "minimum-time-to-complete-trips",
        "description": "You are given an array time where time[i] denotes the time taken by the ith bus to complete one trip.\nEach bus can make multiple trips successively; that is, the next trip can start immediately after completing the current trip. Also, each bus operates independently; that is, the trips of one bus do not influence the trips of any other bus.\nYou are also given an integer totalTrips, which denotes the number of trips all buses should make in total. Return the minimum time required for all buses to complete at least totalTrips trips.",
        "examples": [
            "Input: time = [1,2,3], totalTrips = 5\nOutput: 3\nExplanation:\n- At time t = 1, the number of trips completed by each bus are [1,0,0]. \n  The total number of trips completed is 1 + 0 + 0 = 1.\n- At time t = 2, the number of trips completed by each bus are [2,1,0]. \n  The total number of trips completed is 2 + 1 + 0 = 3.\n- At time t = 3, the number of trips completed by each bus are [3,1,1]. \n  The total number of trips completed is 3 + 1 + 1 = 5.\nSo the minimum time needed for all buses to complete at least 5 trips is 3.",
            "Input: time = [2], totalTrips = 1\nOutput: 2\nExplanation:\nThere is only one bus, and it will complete its first trip at t = 2.\nSo the minimum time needed to complete 1 trip is 2."
        ],
        "constraints": "1 <= time.length <= 105\n1 <= time[i], totalTrips <= 107",
        "oracle_code": "#define ll long long \nclass Solution {\npublic:\n    long long minimumTime(vector<int>& time, int totalTrips) {\n        ll l = 1, r = 1e14;\n        while(l <= r) {\n            ll trip = 0, mid = (l + r) / 2;\n            for(int i=0; i<time.size(); i++) trip += mid / time[i];\n            if(trip < totalTrips) l = mid + 1;\n            else r = mid - 1;\n        }\n        return l;\n    }\n};",
        "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    Binary Search\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N * logN)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\n```\\n#define ll long long \\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        ll l = 1, r = 1e14;\\n        while(l <= r) {\\n            ll trip = 0, mid = (l + r) / 2;\\n            for(int i=0; i<time.size(); i++) trip += mid / time[i];\\n            if(trip < totalTrips) l = mid + 1;\\n            else r = mid - 1;\\n        }\\n        return l;\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "conditional statement error",
            "undefined objects"
        ],
        "buggy_code": "\n#define ll long long \nclass Solution {\npublic:\n    long long minimumTime(vector<int>& time, int totalTrips) {\n        ll l = 1, r = 1e14;\n        Solution obj;\n        while(l <= r) {\n            ll trip = 0, mid = (l + r) / 2;\n            for(int i=0; i<time.size(); i++) trip += mid / time[i];\n            if(trip <= totalTrips) l = mid + 1;\n            else r = mid - 1;\n        }\n        return obj.minimumTime(time, totalTrips);\n    }\n};\n"
    },
    {
        "slug": "factorial-trailing-zeroes",
        "description": "Given an integer n, return the number of trailing zeroes in n!.\nNote that n! = n * (n - 1) * (n - 2) * ... * 3 * 2 * 1.",
        "examples": [
            "Input: n = 3\nOutput: 0\nExplanation: 3! = 6, no trailing zero.",
            "Input: n = 5\nOutput: 1\nExplanation: 5! = 120, one trailing zero.",
            "Input: n = 0\nOutput: 0"
        ],
        "constraints": "0 <= n <= 104",
        "oracle_code": "class Solution {\npublic:\n    unordered_map<long long int,long long int>mp;\n    int trailingZeroes(int n) {\n        for(int i=n;i>=1;i--)\n         fun(i);\n         \n\t\t return min(mp[2],mp[5]); \n    }\n     void fun(int n)\n    {\n         for(int i=2;i*i<=n;i++)\n         {\n         \twhile((n%i) == 0)\n         \t{\n         \t    mp[i]++;\n\t\t\t\tn = n / i;\t\n\t\t\t}\n\t\t }\n\t\t if(n > 1)\n\t\t mp[n]++;\n    }\n};",
        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    unordered_map<long long int,long long int>mp;\\n    int trailingZeroes(int n) {\\n        for(int i=n;i>=1;i--)\\n         fun(i);\\n         \\n\\t\\t return min(mp[2],mp[5]); \\n    }\\n     void fun(int n)\\n    {\\n         for(int i=2;i*i<=n;i++)\\n         {\\n         \\twhile((n%i) == 0)\\n         \\t{\\n         \\t    mp[i]++;\\n\\t\\t\\t\\tn = n / i;\\t\\n\\t\\t\\t}\\n\\t\\t }\\n\\t\\t if(n > 1)\\n\\t\\t mp[n]++;\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "statement separation",
            "colon missing"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    unordered_map<long long int,long long int>mp\n    int trailingZeroes(int n) {\n        for(int i=n;i>=1;i--);\n         fun(i);\n         \n\t\t return min(mp[2],mp[5]); \n    }\n     void fun(int n)\n    {\n         for(int i=2;i*i<=n;i++)\n         {\n         \twhile((n%i) == 0)\n         \t{\n         \t    mp[i]++;\n\t\t\t\tn = n / i;\t\n\t\t\t}\n\t\t }\n\t\t if(n > 1)\n\t\t mp[n]++;\n    }\n};\n"
    },
    {
        "slug": "check-if-there-is-a-valid-path-in-a-grid",
        "description": "You are given an m x n grid. Each cell of grid represents a street. The street of grid[i][j] can be:\n\n1 which means a street connecting the left cell and the right cell.\n2 which means a street connecting the upper cell and the lower cell.\n3 which means a street connecting the left cell and the lower cell.\n4 which means a street connecting the right cell and the lower cell.\n5 which means a street connecting the left cell and the upper cell.\n6 which means a street connecting the right cell and the upper cell.\n\n\nYou will initially start at the street of the upper-left cell (0, 0). A valid path in the grid is a path that starts from the upper left cell (0, 0) and ends at the bottom-right cell (m - 1, n - 1). The path should only follow the streets.\nNotice that you are not allowed to change any street.\nReturn true if there is a valid path in the grid or false otherwise.",
        "examples": [
            "Input: grid = [[2,4,3],[6,5,2]]\nOutput: true\nExplanation: As shown you can start at cell (0, 0) and visit all the cells of the grid to reach (m - 1, n - 1).",
            "Input: grid = [[1,2,1],[1,2,1]]\nOutput: false\nExplanation: As shown you the street at cell (0, 0) is not connected with any street of any other cell and you will get stuck at cell (0, 0)",
            "Input: grid = [[1,1,2]]\nOutput: false\nExplanation: You will get stuck at cell (0, 1) and you cannot reach cell (0, 2)."
        ],
        "constraints": "m == grid.length\nn == grid[i].length\n1 <= m, n <= 300\n1 <= grid[i][j] <= 6",
        "oracle_code": "class DisjointSet{\npublic:\n    vector<int>par,size;\n    DisjointSet(int n){\n        par.resize(n+1);\n        size.resize(n+1,1);\n        for(int i=0; i<=n; i++){\n            par[i] = i;\n        }\n    }\n    int findpar(int u){\n        if(u == par[u]) return u;\n        return par[u] = findpar(par[u]);\n    }\n\n    void unionBySize(int u, int v){\n        u = findpar(u);\n        v = findpar(v);\n\n        if(u == v) return;\n\n        if(size[u] >= size[v]){\n            par[v] = u;\n            size[u] += size[v];\n        }\n        else{\n            par[u] = v;\n            size[v] += size[u];\n        }\n    }\n    \n};\nclass Solution {\npublic:\n    bool hasValidPath(vector<vector<int>>& grid) {\n        int n = grid.size();\n        int m = grid[0].size();\n        DisjointSet ds(n*m);\n        for(int i=0; i<n; i++){\n            for(int j=0; j<m; j++){\n                int p = i * m + j;\n                int p1 = (i-1)*m + j;  // 1\n                int p2 = (i+1)*m + j;  // 1\n                int p3 = i*m + (j+1);  // 2\n                int p4 = i*m + (j-1);  // 2\n\n                if(grid[i][j] == 1){\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\n                        ds.unionBySize(p,p3);\n                    }\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\n                        ds.unionBySize(p,p4);\n                    }\n                }\n                else if(grid[i][j] == 2){\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\n                        ds.unionBySize(p,p2);\n                    }\n\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\n                        ds.unionBySize(p,p1);\n                    }\n                }\n                else if(grid[i][j] == 3){\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\n                        ds.unionBySize(p,p4);\n                    }\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\n                        ds.unionBySize(p,p2);\n                    }\n                }\n                else if(grid[i][j] == 4){\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\n                        ds.unionBySize(p,p3);\n                    }\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\n                        ds.unionBySize(p,p2);\n                    }\n                }\n                else if(grid[i][j] == 5){\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\n                        ds.unionBySize(p,p1);\n                    }\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\n                        ds.unionBySize(p,p4);\n                    }\n                }\n                else if(grid[i][j] == 6){\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\n                        ds.unionBySize(p,p1);\n                    }\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\n                        ds.unionBySize(p,p3);\n                    }\n                }\n            }\n        }\n        return ds.findpar(0) == ds.findpar(n*m-1);\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass DisjointSet{\\npublic:\\n    vector<int>par,size;\\n    DisjointSet(int n){\\n        par.resize(n+1);\\n        size.resize(n+1,1);\\n        for(int i=0; i<=n; i++){\\n            par[i] = i;\\n        }\\n    }\\n    int findpar(int u){\\n        if(u == par[u]) return u;\\n        return par[u] = findpar(par[u]);\\n    }\\n\\n    void unionBySize(int u, int v){\\n        u = findpar(u);\\n        v = findpar(v);\\n\\n        if(u == v) return;\\n\\n        if(size[u] >= size[v]){\\n            par[v] = u;\\n            size[u] += size[v];\\n        }\\n        else{\\n            par[u] = v;\\n            size[v] += size[u];\\n        }\\n    }\\n    \\n};\\nclass Solution {\\npublic:\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        DisjointSet ds(n*m);\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                int p = i * m + j;\\n                int p1 = (i-1)*m + j;  // 1\\n                int p2 = (i+1)*m + j;  // 1\\n                int p3 = i*m + (j+1);  // 2\\n                int p4 = i*m + (j-1);  // 2\\n\\n                if(grid[i][j] == 1){\\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\\n                        ds.unionBySize(p,p3);\\n                    }\\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\\n                        ds.unionBySize(p,p4);\\n                    }\\n                }\\n                else if(grid[i][j] == 2){\\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\\n                        ds.unionBySize(p,p2);\\n                    }\\n\\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\\n                        ds.unionBySize(p,p1);\\n                    }\\n                }\\n                else if(grid[i][j] == 3){\\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\\n                        ds.unionBySize(p,p4);\\n                    }\\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\\n                        ds.unionBySize(p,p2);\\n                    }\\n                }\\n                else if(grid[i][j] == 4){\\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\\n                        ds.unionBySize(p,p3);\\n                    }\\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\\n                        ds.unionBySize(p,p2);\\n                    }\\n                }\\n                else if(grid[i][j] == 5){\\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\\n                        ds.unionBySize(p,p1);\\n                    }\\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\\n                        ds.unionBySize(p,p4);\\n                    }\\n                }\\n                else if(grid[i][j] == 6){\\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\\n                        ds.unionBySize(p,p1);\\n                    }\\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\\n                        ds.unionBySize(p,p3);\\n                    }\\n                }\\n            }\\n        }\\n        return ds.findpar(0) == ds.findpar(n*m-1);\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "== and = confusion",
            "variable value error"
        ],
        "buggy_code": "\n\nclass DisjointSet{\npublic:\n    vector<int>par,size;\n    DisjointSet(int n){\n        par.resize(n+1);\n        size.resize(n+1,1);\n        for(int i=0; i<=n; i++){\n            par[i] == i;\n        }\n    }\n    int findpar(int u){\n        if(u == par[u]) return u;\n        return par[u] = findpar(par[u]);\n    }\n\n    void unionBySize(int u, int v){\n        u == findpar(u);\n        v == findpar(v);\n\n        if(u == v) return;\n\n        if(size[u] >= size[v]){\n            par[v] = v;\n            size[u] += size[v];\n        }\n        else{\n            par[u] = u;\n            size[v] += size[u];\n        }\n    }\n    \n};\nclass Solution {\npublic:\n    bool hasValidPath(vector<vector<int>>& grid) {\n        int n = grid.size();\n        int m = grid[0].size();\n        DisjointSet ds(n*m);\n        for(int i=0; i<n; i++){\n            for(int j=0; j<m; j++){\n                int p = i * m + j;\n                int p1 = (i-1)*m + j;  // 1\n                int p2 = (i+1)*m + j;  // 1\n                int p3 = i*m + (j+1);  // 2\n                int p4 = i*m + (j-1);  // 2\n\n                if(grid[i][j] == 1){\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\n                        ds.unionBySize(p,p3);\n                    }\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\n                        ds.unionBySize(p,p4);\n                    }\n                }\n                else if(grid[i][j] == 2){\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\n                        ds.unionBySize(p,p2);\n                    }\n\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\n                        ds.unionBySize(p,p1);\n                    }\n                }\n                else if(grid[i][j] == 3){\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\n                        ds.unionBySize(p,p4);\n                    }\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\n                        ds.unionBySize(p,p2);\n                    }\n                }\n                else if(grid[i][j] == 4){\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\n                        ds.unionBySize(p,p3);\n                    }\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\n                        ds.unionBySize(p,p2);\n                    }\n                }\n                else if(grid[i][j] == 5){\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\n                        ds.unionBySize(p,p1);\n                    }\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\n                        ds.unionBySize(p,p4);\n                    }\n                }\n                else if(grid[i][j] == 6){\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\n                        ds.unionBySize(p,p1);\n                    }\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\n                        ds.unionBySize(p,p3);\n                    }\n                }\n            }\n        }\n        return ds.findpar(0) == ds.findpar(n*m-1);\n    }\n};\n\n"
    },
    {
        "slug": "binary-string-with-substrings-representing-1-to-n",
        "description": "Given a binary string s and a positive integer n, return true if the binary representation of all the integers in the range [1, n] are substrings of s, or false otherwise.\nA substring is a contiguous sequence of characters within a string.",
        "examples": [
            "Input: s = \"0110\", n = 3\nOutput: true",
            "Input: s = \"0110\", n = 4\nOutput: false"
        ],
        "constraints": "1 <= s.length <= 1000\ns[i] is either '0' or '1'.\n1 <= n <= 109",
        "oracle_code": "class Solution {\npublic:\n    bool queryString(string s, int n)\n     {\n        unordered_set<int> seen;\n        int len = s.length();\n        for(int i=len-1;i>=0;i--)\n        {\n            int num = 0;\n            for(int j=1;j<=min(len-i,31);j++)\n            { \n                num = num*2 + (s[i+j-1] == '1' ? 1 : 0);\n                if(0 < num && num <= n) seen.insert(num);\n            }\n            if(seen.size() == n) return true;\n        }\n        return false;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool queryString(string s, int n)\\n     {\\n        unordered_set<int> seen;\\n        int len = s.length();\\n        for(int i=len-1;i>=0;i--)\\n        {\\n            int num = 0;\\n            for(int j=1;j<=min(len-i,31);j++)\\n            { \\n                num = num*2 + (s[i+j-1] == \\'1\\' ? 1 : 0);\\n                if(0 < num && num <= n) seen.insert(num);\\n            }\\n            if(seen.size() == n) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "== and = confusion",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    bool queryString(string s, int n)\n     {\n        unordered_set<int> seen;\n        int len = s.length();\n        for(int i=len-1;i>=0;i--)\n        {\n            int num = 0;\n            for(int j=1;j<=min(len-i,31);j++)\n            { \n                num = num*2 + (s[i+j-1] = '1' ? 1 : 0);\n                if(0 < num && num <= n) seen.insert(num);\n            }\n            if(seen.size() = n) return true;\n        }\n        return isAllNumbersSeen();\n    }\n    \n    bool isAllNumbersSeen()\n    {\n        \n    }\n};\n"
    },
    {
        "slug": "domino-and-tromino-tiling",
        "description": "You have two types of tiles: a 2 x 1 domino shape and a tromino shape. You may rotate these shapes.\n\nGiven an integer n, return the number of ways to tile an 2 x n board. Since the answer may be very large, return it modulo 109 + 7.\nIn a tiling, every square must be covered by a tile. Two tilings are different if and only if there are two 4-directionally adjacent cells on the board such that exactly one of the tilings has both squares occupied by a tile.",
        "examples": [
            "Input: n = 3\nOutput: 5\nExplanation: The five different ways are show above.",
            "Input: n = 1\nOutput: 1"
        ],
        "constraints": "1 <= n <= 1000",
        "oracle_code": "class Solution {\npublic:\n    int mod=1e9+7;\n    long helper(int n, vector<long>& dp){\n        if(n==1) return 1;\n        if(n==2) return 2;\n        if(n==3) return 5;\n\n        if(dp[n]!=-1) return dp[n]%mod;\n\n        long smallAns1=0, smallAns2=0;\n        smallAns1=helper(n-1,dp)%mod;\n        smallAns2=helper(n-3,dp)%mod;\n\n        dp[n]=(smallAns1*2+smallAns2)%mod;\n        return dp[n]%mod;\n    }\n    \n    int numTilings(int n) {\n        vector<long> dp(n+1,-1);\n        long ans=helper(n,dp)%mod;\n        return (int)ans;        \n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nfor n , we want answer for n-1 and n-3\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n) + Recurisve Stack Space \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    long helper(int n, vector<long>& dp){\\n        if(n==1) return 1;\\n        if(n==2) return 2;\\n        if(n==3) return 5;\\n\\n        if(dp[n]!=-1) return dp[n]%mod;\\n\\n        long smallAns1=0, smallAns2=0;\\n        smallAns1=helper(n-1,dp)%mod;\\n        smallAns2=helper(n-3,dp)%mod;\\n\\n        dp[n]=(smallAns1*2+smallAns2)%mod;\\n        return dp[n]%mod;\\n    }\\n    \\n    int numTilings(int n) {\\n        vector<long> dp(n+1,-1);\\n        long ans=helper(n,dp)%mod;\\n        return (int)ans;        \\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "statement separation",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    int mod=1e9+7;\n    long helper(int n, vector<long>& dp){\n        if(n==1) return 1;\n        if(n==2) return 2;\n        if(n==3) return 5;\n\n        if(dp[n]!=-1) return dp[n]%mod;\n\n        long smallAns1=0, smallAns2=0;\n        smallAns1=helper(n-1,dp)%mod\n        smallAns2=helper(n-4,dp)%mod;\n\n        dp[n]=(smallAns1*2+smallAns2)%mod;\n        return dp[n]%mod;\n    }\n    \n    int numTilings(int n) {\n        vector<long> dp(n+1,-1);\n        long ans=helper(n,dp)%mod;\n        return (int)ans;        \n    }\n};\n"
    },
    {
        "slug": "add-two-numbers",
        "description": "You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum\u00a0as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.",
        "examples": [
            "Input: l1 = [2,4,3], l2 = [5,6,4]\nOutput: [7,0,8]\nExplanation: 342 + 465 = 807.",
            "Input: l1 = [0], l2 = [0]\nOutput: [0]",
            "Input: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\nOutput: [8,9,9,9,0,0,0,1]"
        ],
        "constraints": "The number of nodes in each linked list is in the range [1, 100].\n0 <= Node.val <= 9\nIt is guaranteed that the list represents a number that does not have leading zeros.",
        "oracle_code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        //initializing tem and temp so that l1 and l2 reamins preserved,\n        //though this isn't needed but it a good practice\n        ListNode* temp=l1;\n        ListNode* tem=l2;\n        ListNode *ans;\n        ListNode *head;\n        int carry=0;\n        int valu;\n        //initiallize the first node of answer\n        int sum=tem->val+temp->val+carry;\n        valu=sum%10;\n        carry=sum/10;\n        ListNode* node =new ListNode(valu);\n        ans=node;\n        head=ans;\n        tem=tem->next;\n        temp=temp->next;\n        while(tem!=NULL && temp!=NULL)\n        {\n            sum=tem->val+temp->val+carry;\n            valu=sum%10;\n            carry=sum/10;\n            ListNode* node =new ListNode(valu);\n            ans->next=node;\n            ans=ans->next;\n            temp=temp->next;\n            tem=tem->next;\n        }\n        //if l1 gets over and there are still some elements in l2\n        if(tem==NULL && temp!=NULL)\n        {\n            while(temp!=NULL)\n            {\n                sum=temp->val+carry;\n                valu=sum%10;\n                carry=sum/10;\n                ListNode* node =new ListNode(valu);\n                ans->next=node;\n                ans=ans->next;\n                temp=temp->next;\n            }\n        }\n        //if l2 gets over and there are still some elements in l1\n        if(tem!=NULL && temp==NULL)\n        {\n            while(tem!=NULL)\n            {\n                sum=tem->val+carry;\n                valu=sum%10;\n                carry=sum/10;\n                ListNode* node =new ListNode(valu);\n                ans->next=node;\n                ans=ans->next;\n                tem=tem->next;\n            }\n        }\n        //if there is still a carry left\n        if(carry!=0)\n        {\n            ListNode* node =new ListNode(carry);\n            ans->next=node;\n        }\n        return head;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe code might seem really complex for the first time, but this only because i have specified every corner case differently, cmon i will give u a walk through my code.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe are just using a variable for the value we want as node\\'s vale and a carry, rest the operation is as simple as we add two numbers.\\n\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        //initializing tem and temp so that l1 and l2 reamins preserved,\\n        //though this isn\\'t needed but it a good practice\\n        ListNode* temp=l1;\\n        ListNode* tem=l2;\\n        ListNode *ans;\\n        ListNode *head;\\n        int carry=0;\\n        int valu;\\n        //initiallize the first node of answer\\n        int sum=tem->val+temp->val+carry;\\n        valu=sum%10;\\n        carry=sum/10;\\n        ListNode* node =new ListNode(valu);\\n        ans=node;\\n        head=ans;\\n        tem=tem->next;\\n        temp=temp->next;\\n        while(tem!=NULL && temp!=NULL)\\n        {\\n            sum=tem->val+temp->val+carry;\\n            valu=sum%10;\\n            carry=sum/10;\\n            ListNode* node =new ListNode(valu);\\n            ans->next=node;\\n            ans=ans->next;\\n            temp=temp->next;\\n            tem=tem->next;\\n        }\\n        //if l1 gets over and there are still some elements in l2\\n        if(tem==NULL && temp!=NULL)\\n        {\\n            while(temp!=NULL)\\n            {\\n                sum=temp->val+carry;\\n                valu=sum%10;\\n                carry=sum/10;\\n                ListNode* node =new ListNode(valu);\\n                ans->next=node;\\n                ans=ans->next;\\n                temp=temp->next;\\n            }\\n        }\\n        //if l2 gets over and there are still some elements in l1\\n        if(tem!=NULL && temp==NULL)\\n        {\\n            while(tem!=NULL)\\n            {\\n                sum=tem->val+carry;\\n                valu=sum%10;\\n                carry=sum/10;\\n                ListNode* node =new ListNode(valu);\\n                ans->next=node;\\n                ans=ans->next;\\n                tem=tem->next;\\n            }\\n        }\\n        //if there is still a carry left\\n        if(carry!=0)\\n        {\\n            ListNode* node =new ListNode(carry);\\n            ans->next=node;\\n        }\\n        return head;\\n    }\\n};\\n\\n```",
        "level": "medium",
        "type": [
            "conditional statement error",
            "undefined methods"
        ],
        "buggy_code": "\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        //initializing tem and temp so that l1 and l2 reamins preserved,\n        //though this isn't needed but it a good practice\n        ListNode* temp=l1;\n        ListNode* tem=l2;\n        ListNode *ans;\n        ListNode *head;\n        int carry=0;\n        int valu;\n        //initiallize the first node of answer\n        int sum=tem->val+temp->val+carry;\n        valu=sum%10;\n        carry=sum/10;\n        ListNode* node =new ListNode(valu);\n        ans=node;\n        head=ans;\n        tem=tem->next;\n        temp=temp->next;\n        while(tem!=NULL && temp!=NULL)\n        {\n            sum=tem->val+temp->val+carry;\n            valu=sum%10;\n            carry=sum/10;\n            ListNode* node =new ListNode(valu);\n            ans->next=node;\n            ans=ans->next;\n            temp=temp->next;\n            tem=tem->next;\n        }\n        //if l1 gets over and there are still some elements in l2\n        if(tem==NULL && temp!=NULL)\n        {\n            while(temp!=NULL)\n            {\n                sum=temp->val+carry;\n                valu=sum%10;\n                carry=sum/10;\n                ListNode* node =new ListNode(valu);\n                ans->next=node;\n                ans=ans->next;\n                temp=temp->next;\n            }\n        }\n        //if l2 gets over and there are still some elements in l1\n        void CopyRestOfL1(ListNode* tem, ListNode* ans, int& carry);\n        \n    }\n    \n    void CopyRestOfL1(ListNode* tem, ListNode* ans, int& carry)\n    {\n        int sum;\n        int valu;\n        while(tem!=NULL)\n        {\n            sum=tem->val+carry;\n            valu=sum%10;\n            carry=sum/10;\n            ListNode* node =new ListNode(valu);\n            ans->next=node;\n            ans=ans->next;\n            tem=tem->next;\n        }\n    }\n};    \n\n"
    },
    {
        "slug": "minimum-sideway-jumps",
        "description": "There is a 3 lane road of length n that consists of n + 1 points labeled from 0 to n. A frog starts at point 0 in the second lane and wants to jump to point n. However, there could be obstacles along the way.\nYou are given an array obstacles of length n + 1 where each obstacles[i] (ranging from 0 to 3) describes an obstacle on the lane obstacles[i] at point i. If obstacles[i] == 0, there are no obstacles at point i. There will be at most one obstacle in the 3 lanes at each point.\n\nFor example, if obstacles[2] == 1, then there is an obstacle on lane 1 at point 2.\n\nThe frog can only travel from point i to point i + 1 on the same lane if there is not an obstacle on the lane at point i + 1. To avoid obstacles, the frog can also perform a side jump to jump to another lane (even if they are not adjacent) at the same point if there is no obstacle on the new lane.\n\nFor example, the frog can jump from lane 3 at point 3 to lane 1 at point 3.\n\nReturn the minimum number of side jumps the frog needs to reach any lane at point n starting from lane 2 at point 0.\nNote: There will be no obstacles on points 0 and n.",
        "examples": [
            "Input: obstacles = [0,1,2,3,0]\nOutput: 2 \nExplanation: The optimal solution is shown by the arrows above. There are 2 side jumps (red arrows).\nNote that the frog can jump over obstacles only when making side jumps (as shown at point 2).",
            "Input: obstacles = [0,1,1,3,3,0]\nOutput: 0\nExplanation: There are no obstacles on lane 2. No side jumps are required.",
            "Input: obstacles = [0,2,1,0,3,0]\nOutput: 2\nExplanation: The optimal solution is shown by the arrows above. There are 2 side jumps."
        ],
        "constraints": "obstacles.length == n + 1\n1 <= n <= 5 * 105\n0 <= obstacles[i] <= 3\nobstacles[0] == obstacles[n] == 0",
        "oracle_code": "class Solution {\npublic:\n    int func(int i,int l,vector<int>&obstacles,vector<vector<int>>&dp){\n        if(i==obstacles.size()-2){\n            if(obstacles[i+1]==l)return 1;\n            return 0;\n        }\n\n        if(dp[i][l]!=-1)return dp[i][l];\n\n        if(obstacles[i+1]!=l){\n            return dp[i][l] = func(i+1,l,obstacles,dp);\n        }\n\n    \n        int b=INT_MAX;\n        for(int j=1;j<=3;j++){\n            if(l==j)continue;\n            if(obstacles[i]==j)continue;\n            b=min(b,1+func(i,j,obstacles,dp));\n        }\n    \n\n        return dp[i][l] = b;\n    }\n\n    int minSideJumps(vector<int>& obstacles) {\n        int n=obstacles.size();\n        vector<vector<int>>dp(n,vector<int>(4,-1));\n        return func(0,2,obstacles,dp);\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(n*4) = O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(n*4)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int func(int i,int l,vector<int>&obstacles,vector<vector<int>>&dp){\\n        if(i==obstacles.size()-2){\\n            if(obstacles[i+1]==l)return 1;\\n            return 0;\\n        }\\n\\n        if(dp[i][l]!=-1)return dp[i][l];\\n\\n        if(obstacles[i+1]!=l){\\n            return dp[i][l] = func(i+1,l,obstacles,dp);\\n        }\\n\\n    \\n        int b=INT_MAX;\\n        for(int j=1;j<=3;j++){\\n            if(l==j)continue;\\n            if(obstacles[i]==j)continue;\\n            b=min(b,1+func(i,j,obstacles,dp));\\n        }\\n    \\n\\n        return dp[i][l] = b;\\n    }\\n\\n    int minSideJumps(vector<int>& obstacles) {\\n        int n=obstacles.size();\\n        vector<vector<int>>dp(n,vector<int>(4,-1));\\n        return func(0,2,obstacles,dp);\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "== and = confusion",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    int func(int i,int l,vector<int>&obstacles,vector<vector<int>>&dp){\n        if(i=obstacles.size()-2){\n            if(obstacles[i+2]==l)return 1;\n            return 0;\n        }\n\n        if(dp[i][l]!=-1)return dp[i][l];\n\n        if(obstacles[i+1]!=l){\n            return dp[i][l] = func(i+1,l,obstacles,dp);\n        }\n\n\n        int b=INT_MAX;\n        for(int j=1;j<=3;j++){\n            if(l==j)continue;\n            if(obstacles[i]==j)continue;\n            b=min(b,1+func(i,j,obstacles,dp));\n        }\n\n\n        return dp[i][l] = b;\n    }\n\n    int minSideJumps(vector<int>& obstacles) {\n        int n=obstacles.size();\n        vector<vector<int>>dp(n,vector<int>(4,-1));\n        return func(0,2,obstacles,dp);\n    }\n};\n\n"
    },
    {
        "slug": "divide-array-in-sets-of-k-consecutive-numbers",
        "description": "Given an array of integers nums and a positive integer k, check whether it is possible to divide this array into sets of k consecutive numbers.\nReturn true if it is possible. Otherwise, return false.",
        "examples": [
            "Input: nums = [1,2,3,3,4,4,5,6], k = 4\nOutput: true\nExplanation: Array can be divided into [1,2,3,4] and [3,4,5,6].",
            "Input: nums = [3,2,1,2,3,4,3,4,5,9,10,11], k = 3\nOutput: true\nExplanation: Array can be divided into [1,2,3] , [2,3,4] , [3,4,5] and [9,10,11].",
            "Input: nums = [1,2,3,4], k = 3\nOutput: false\nExplanation: Each array should be divided in subarrays of size 3."
        ],
        "constraints": "1 <= k <= nums.length <= 105\n1 <= nums[i] <= 109\n\n\u00a0\nNote: This question is the same as\u00a0846:\u00a0https://leetcode.com/problems/hand-of-straights/",
        "oracle_code": "class Solution {\npublic:\n     bool isPossibleDivide(vector<int>& nums, int k) {\n         map<int,int> map;\n         for(int num : nums){\n             map[num]++;\n         }\n         while(map.size()!=0){\n             int first = map.begin()->first;\n             for(int i=first; i<first+k; i++){\n                 if(!map.count(i)){\n                     return false;\n                 }\n                 map[i]--;\n                 if(map[i]==0){\n                     map.erase(i);\n                 }\n             }\n         }\n         return true;\n     }\n };",
        "content": "# Intuition:\\nBoth approaches are solving the same problem of determining whether a given array can be divided into groups of k consecutive elements or not. Approach 1 uses a map to keep track of the frequency of each element, and then iterates over the elements while maintaining the current group of k consecutive elements. If the current group cannot be formed, it returns false. Approach 2 also uses a map to keep track of the frequency of each element but sorts the array first and then iterates over it. For each element, it checks if it can form a group of k consecutive elements by checking the frequency of the next k-1 elements.\\n\\n# Approach 1:\\n\\n1. Initialize a map to keep track of the frequency of each element.\\n2. Iterate over the array and update the map with the frequency of each element.\\n3. While the map is not empty, get the first element of the map.\\n4. Iterate over the next k consecutive elements and check if they exist in the map and have a frequency greater than 0. If any element is missing or has a frequency of 0, return false.\\n5. Update the frequency of each element in the group and remove any element from the map whose frequency becomes 0.\\n6. Return true if all groups of k consecutive elements can be formed.\\n# Approach 2:\\n\\n1. Check if the length of the array is divisible by k. If not, return false.\\n2. Initialize an unordered map to keep track of the frequency of each element.\\n3. Iterate over the array and update the map with the frequency of each element.\\n4. Sort the array in ascending order.\\n5. For each element in the sorted array, check if its frequency is greater than 0.\\n6. If yes, iterate over the next k-1 elements and check if they exist in the map and have a frequency greater than 0. If any element is missing or has a frequency of 0, return false.\\n7. Update the frequency of each element in the group.\\n8. Repeat steps 5-7 until all groups of k consecutive elements have been formed.\\n9. Return true if all groups of k consecutive elements can be formed.\\n# Complexity:\\n\\n- Time complexity:\\n    - Approach 1: The time complexity of this approach is O(n log n) due to the use of a map and the worst-case scenario is when all elements are distinct, then it takes nlogn time for inserting into map, and n times we need to check for each group of k elements.\\n    - Approach 2: The time complexity of this approach is O(n log n) due to the use of sorting and iterating over the sorted array. Sorting takes O(n log n) time, and iterating over the array takes O(n) time.\\n\\n- Space complexity:\\n    - Approach 1: The space complexity of this approach is O(n) due to the use of a map to store the frequency of each element.\\n    - Approach 2: The space complexity of this approach is also O(n) due to the use of an unordered map to store the frequency of each element.\\n# C++\\n## Approach 1\\n```\\nclass Solution {\\npublic:\\n     bool isPossibleDivide(vector<int>& nums, int k) {\\n         map<int,int> map;\\n         for(int num : nums){\\n             map[num]++;\\n         }\\n         while(map.size()!=0){\\n             int first = map.begin()->first;\\n             for(int i=first; i<first+k; i++){\\n                 if(!map.count(i)){\\n                     return false;\\n                 }\\n                 map[i]--;\\n                 if(map[i]==0){\\n                     map.erase(i);\\n                 }\\n             }\\n         }\\n         return true;\\n     }\\n };\\n```\\n## Approach 2\\n```\\nclass Solution {\\npublic:\\n    bool isPossibleDivide(vector<int>& nums, int k) {\\n        if (nums.size() % k != 0) {\\n            return false;\\n        }\\n        \\n        unordered_map<int,int> map;\\n        for (int num : nums) {\\n            map[num]++;\\n        }\\n        \\n        sort(nums.begin(), nums.end());\\n        \\n        for (int num : nums) {\\n            if (map[num] > 0) {\\n                for (int i = num + 1; i < num + k; i++) {\\n                    if (map[i] == 0) {\\n                        return false;\\n                    }\\n                    map[i]--;\\n                }\\n                map[num]--;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n\\n```\\n# Java\\n ## Approach 1\\n```\\nclass Solution {\\n    public boolean isPossibleDivide(int[] nums, int k) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int num : nums) {\\n            map.put(num, map.getOrDefault(num, 0) + 1);\\n        }\\n        while (!map.isEmpty()) {\\n            int first = Collections.min(map.keySet());\\n            for (int i = first; i < first + k; i++) {\\n                if (!map.containsKey(i)) {\\n                    return false;\\n                }\\n                map.put(i, map.get(i) - 1);\\n                if (map.get(i) == 0) {\\n                    map.remove(i);\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n\\n```\\n## Approach 2\\n```\\nclass Solution {\\n    public boolean isPossibleDivide(int[] nums, int k) {\\n        if (nums.length % k != 0) {\\n            return false;\\n        }\\n\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int num : nums) {\\n            map.put(num, map.getOrDefault(num, 0) + 1);\\n        }\\n\\n        Arrays.sort(nums);\\n\\n        for (int num : nums) {\\n            if (map.get(num) > 0) {\\n                for (int i = num + 1; i < num + k; i++) {\\n                    if (map.getOrDefault(i, 0) == 0) {\\n                        return false;\\n                    }\\n                    map.put(i, map.get(i) - 1);\\n                }\\n                map.put(num, map.get(num) - 1);\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n\\n```\\n# Python\\n ## Approach 1\\n```\\nclass Solution(object):\\n    def isPossibleDivide(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: bool\\n        \"\"\"\\n        num_map = {}\\n        for num in nums:\\n            num_map[num] = num_map.get(num, 0) + 1\\n        while num_map:\\n            first = min(num_map)\\n            for i in range(first, first+k):\\n                if i not in num_map:\\n                    return False\\n                num_map[i] -= 1\\n                if num_map[i] == 0:\\n                    del num_map[i]\\n        return True\\n\\n```\\n ## Approach 2\\n```\\nclass Solution(object):\\n    def isPossibleDivide(self, nums, k):\\n        if len(nums) % k != 0:\\n            return False\\n        \\n        map = {}\\n        for num in nums:\\n            map[num] = map.get(num, 0) + 1\\n        \\n        nums.sort()\\n        \\n        for num in nums:\\n            if map[num] > 0:\\n                for i in range(num+1, num+k):\\n                    if map.get(i, 0) == 0:\\n                        return False\\n                    map[i] -= 1\\n                map[num] -= 1\\n        \\n        return True\\n\\n```\\n# JavaScript\\n ## Approach 1\\n```\\nvar isPossibleDivide = function(nums, k) {\\n  const map = new Map();\\n  for (const num of nums) {\\n    map.set(num, (map.get(num) || 0) + 1);\\n  }\\n  while (map.size !== 0) {\\n    const first = Array.from(map.keys()).sort((a, b) => a - b)[0];\\n    for (let i = first; i < first + k; i++) {\\n      if (!map.has(i)) {\\n        return false;\\n      }\\n      map.set(i, map.get(i) - 1);\\n      if (map.get(i) === 0) {\\n        map.delete(i);\\n      }\\n    }\\n  }\\n  return true;\\n}\\n```\\n ## Approach 2\\n```\\nvar isPossibleDivide = function(nums, k) {\\n  if (nums.length % k !== 0) {\\n    return false;\\n  }\\n\\n  const map = new Map();\\n  for (const num of nums) {\\n    map.set(num, (map.get(num) || 0) + 1);\\n  }\\n\\n  nums.sort((a, b) => a - b);\\n\\n  for (const num of nums) {\\n    if (map.get(num) > 0) {\\n      for (let i = num + 1; i < num + k; i++) {\\n        if (map.get(i) === 0) {\\n          return false;\\n        }\\n        map.set(i, map.get(i) - 1);\\n      }\\n      map.set(num, map.get(num) - 1);\\n    }\\n  }\\n\\n  return true;\\n}\\n\\n```\\n# Similar Question: \\nhttps://leetcode.com/problems/hand-of-straights/solutions/3444424/c-very-easy-fully-explained-using-map/",
        "level": "medium",
        "type": [
            "conditional statement error",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n     bool isPossibleDivide(vector<int>& nums, int k) {\n         dict<int,int> map;\n         for(int num : nums){\n             map[num]++;\n         }\n         while(map.size()!=0){\n             int first = map.begin()->first;\n             for(int i=first; i<first+k-1; i++){\n                 if(!map.count(i)){\n                     return false;\n                 }\n                 map[i]--;\n                 if(map[i]==0){\n                     map.remove(i);\n                 }\n             }\n         }\n         return true;\n     }\n };\n"
    },
    {
        "slug": "apply-operations-to-an-array",
        "description": "You are given a 0-indexed array nums of size n consisting of non-negative integers.\nYou need to apply n - 1 operations to this array where, in the ith operation (0-indexed), you will apply the following on the ith element of nums:\n\nIf nums[i] == nums[i + 1], then multiply nums[i] by 2 and set nums[i + 1] to 0. Otherwise, you skip this operation.\n\nAfter performing all the operations, shift all the 0's to the end of the array.\n\nFor example, the array [1,0,2,0,0,1] after shifting all its 0's to the end, is [1,2,1,0,0,0].\n\nReturn the resulting array.\nNote that the operations are applied sequentially, not all at once.",
        "examples": [
            "Input: nums = [1,2,2,1,1,0]\nOutput: [1,4,2,0,0,0]\nExplanation: We do the following operations:\n- i = 0: nums[0] and nums[1] are not equal, so we skip this operation.\n- i = 1: nums[1] and nums[2] are equal, we multiply nums[1] by 2 and change nums[2] to 0. The array becomes [1,4,0,1,1,0].\n- i = 2: nums[2] and nums[3] are not equal, so we skip this operation.\n- i = 3: nums[3] and nums[4] are equal, we multiply nums[3] by 2 and change nums[4] to 0. The array becomes [1,4,0,2,0,0].\n- i = 4: nums[4] and nums[5] are equal, we multiply nums[4] by 2 and change nums[5] to 0. The array becomes [1,4,0,2,0,0].\nAfter that, we shift the 0's to the end, which gives the array [1,4,2,0,0,0].",
            "Input: nums = [0,1]\nOutput: [1,0]\nExplanation: No operation can be applied, we just shift the 0 to the end."
        ],
        "constraints": "2 <= nums.length <= 2000\n0 <= nums[i] <= 1000",
        "oracle_code": "class Solution {\npublic:\n    vector<int> applyOperations(vector<int>& nums) {\n        for(int i =0 ;i<nums.size()-1;i++){\n            if(nums[i] == nums[i+1]){\n                nums[i] *=2;\n                nums[i+1] = 0;\n            }\n        };\n        vector<int> ans;\n        for(auto ele:nums){\n            if(ele!=0)ans.push_back(ele);\n        };\n        for(auto ele:nums){\n            if(ele == 0)ans.push_back(ele);\n        };\n        return ans;\n    }\n};",
        "content": "\\n```\\nclass Solution {\\npublic:\\n    vector<int> applyOperations(vector<int>& nums) {\\n        for(int i =0 ;i<nums.size()-1;i++){\\n            if(nums[i] == nums[i+1]){\\n                nums[i] *=2;\\n                nums[i+1] = 0;\\n            }\\n        };\\n        vector<int> ans;\\n        for(auto ele:nums){\\n            if(ele!=0)ans.push_back(ele);\\n        };\\n        for(auto ele:nums){\\n            if(ele == 0)ans.push_back(ele);\\n        };\\n        return ans;\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "indexing error",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    vector<int> applyOperations(vector<int>& nums) {\n        for(int i =0 ;i<nums.size();i++){\n            if(nums[i] == nums[i+1]){\n                nums[i] *=2;\n                nums[i+1] = 0;\n            }\n        };\n        vector<int> ans;\n        for(auto ele:nums){\n            if(ele!=0)ans.push_back(ele);\n        };\n        vector<int> ans;\n        for(auto ele:nums){\n            if(ele == 0)ans.push_back(ele);\n        };\n        return ans;\n    }\n};\n"
    },
    {
        "slug": "detect-cycles-in-2d-grid",
        "description": "Given a 2D array of characters grid of size m x n, you need to find if there exists any cycle consisting of the same value in grid.\nA cycle is a path of length 4 or more in the grid that starts and ends at the same cell. From a given cell, you can move to one of the cells adjacent to it - in one of the four directions (up, down, left, or right), if it has the same value of the current cell.\nAlso, you cannot move to the cell that you visited in your last move. For example, the cycle (1, 1) -> (1, 2) -> (1, 1) is invalid because from (1, 2) we visited (1, 1) which was the last visited cell.\nReturn true if any cycle of the same value exists in grid, otherwise, return false.",
        "examples": [
            "Input: grid = [[\"a\",\"a\",\"a\",\"a\"],[\"a\",\"b\",\"b\",\"a\"],[\"a\",\"b\",\"b\",\"a\"],[\"a\",\"a\",\"a\",\"a\"]]\nOutput: true\nExplanation: There are two valid cycles shown in different colors in the image below:",
            "Input: grid = [[\"c\",\"c\",\"c\",\"a\"],[\"c\",\"d\",\"c\",\"c\"],[\"c\",\"c\",\"e\",\"c\"],[\"f\",\"c\",\"c\",\"c\"]]\nOutput: true\nExplanation: There is only one valid cycle highlighted in the image below:",
            "Input: grid = [[\"a\",\"b\",\"b\"],[\"b\",\"z\",\"b\"],[\"b\",\"b\",\"a\"]]\nOutput: false"
        ],
        "constraints": "m == grid.length\nn == grid[i].length\n1 <= m, n <= 500\ngrid consists only of lowercase English letters.",
        "oracle_code": "class Solution {\npublic:\n   vector<int> dir = { 0, 1, 0, -1, 0 }; \n    bool isCyclic(vector<vector<char>>& grid, vector<vector<bool>>& visited, int i, int j, int x, int y)\n    {\n        visited[i][j] = true;\n        for(int d = 0; d < 4; ++d)\n        {\n            int a = i+dir[d];\n            int b = j+dir[d+1];\n            if(a >= 0 && a < grid.size() && b >= 0 && b < grid[0].size() && grid[a][b] == grid[i][j] && !(x == a && y == b))\n                if(visited[a][b] || isCyclic(grid, visited, a,b,i,j))\n                    return true;\n        }\n        return false;\n    }\n    bool containsCycle(vector<vector<char>>& grid) {\n        int n = grid.size(), m = grid[0].size();\n        vector<vector<bool>> visited(n, vector<bool>(m, false));\n        for(int i = 0; i < n; ++i)\n            for(int j = 0; j < m; ++j)\n                if(!visited[i][j] && isCyclic(grid, visited, i, j, -1, -1))\n                    return true;\n        return false;\n    }\n};",
        "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n   vector<int> dir = { 0, 1, 0, -1, 0 }; \\n    bool isCyclic(vector<vector<char>>& grid, vector<vector<bool>>& visited, int i, int j, int x, int y)\\n    {\\n        visited[i][j] = true;\\n        for(int d = 0; d < 4; ++d)\\n        {\\n            int a = i+dir[d];\\n            int b = j+dir[d+1];\\n            if(a >= 0 && a < grid.size() && b >= 0 && b < grid[0].size() && grid[a][b] == grid[i][j] && !(x == a && y == b))\\n                if(visited[a][b] || isCyclic(grid, visited, a,b,i,j))\\n                    return true;\\n        }\\n        return false;\\n    }\\n    bool containsCycle(vector<vector<char>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<bool>> visited(n, vector<bool>(m, false));\\n        for(int i = 0; i < n; ++i)\\n            for(int j = 0; j < m; ++j)\\n                if(!visited[i][j] && isCyclic(grid, visited, i, j, -1, -1))\\n                    return true;\\n        return false;\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "colon missing",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n   vector<int> dir = { 0, 1, 0, -1, 0 } \n    bool isCyclic(vector<vector<char>>& grid, vector<vector<bool>>& visited, int i, int j, int x, int y)\n    {\n        visited[i][j] = true;\n        for(int d = 0; d < 4; ++d)\n        {\n            int a = i+dir[d];\n            int b = j+dir[d+1];\n            if(a >= 0 && a < grid.size() && b >= 0 && b < grid[0].size() && grid[a][b] == grid[i][j] && !(x == a && y == b))\n                if((!visited[a][b] && isCyclic(grid, visited, a,b,i,j)) || visited[a][b])\n                    return true;\n        }\n        return false;\n    }\n    bool containsCycle(vector<vector<char>>& grid) {\n        int n = grid.size(), m = grid[0].size();\n        vector<vector<bool>> visited(n, vector<bool>(m, false));\n        for(int i = 0; i < n; ++i)\n            for(int j = 0; j < m; ++j)\n                if(!visited[i][j] && isCyclic(grid, visited, i, j, -1, -1))\n                    return true;\n        return false;\n    }\n};\n"
    },
    {
        "slug": "game-of-life",
        "description": "According to\u00a0Wikipedia's article: \"The Game of Life, also known simply as Life, is a cellular automaton devised by the British mathematician John Horton Conway in 1970.\"\nThe board is made up of an m x n grid of cells, where each cell has an initial state: live (represented by a 1) or dead (represented by a 0). Each cell interacts with its eight neighbors (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article):\n\nAny live cell with fewer than two live neighbors dies as if caused by under-population.\nAny live cell with two or three live neighbors lives on to the next generation.\nAny live cell with more than three live neighbors dies, as if by over-population.\nAny dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.\n\nThe next state is created by applying the above rules simultaneously to every cell in the current state, where births and deaths occur simultaneously. Given the current state of the m x n grid board, return the next state.",
        "examples": [
            "Input: board = [[0,1,0],[0,0,1],[1,1,1],[0,0,0]]\nOutput: [[0,0,0],[1,0,1],[0,1,1],[0,1,0]]",
            "Input: board = [[1,1],[1,0]]\nOutput: [[1,1],[1,1]]"
        ],
        "constraints": "m == board.length\nn == board[i].length\n1 <= m, n <= 25\nboard[i][j] is 0 or 1.",
        "oracle_code": "class Solution {\npublic:\n    void gameOfLife(vector<vector<int>>& board) {\n\n        int rows = board.size();\n        int cols = board[0].size();\n\n        //copying the board to 2-D vector copy\n        vector<vector<int>> copy(board);\n\n        for(int i=0; i<rows; i++)\n        {\n            for(int j=0; j<cols; j++)\n            {\n                //for counting live neighbors of the element\n                int liveNeighbors = 0; \n                \n                //iterating through all the neighbors of the element (inside the board and outside the board)\n                for(int m=i-1; m<i+2; m++)\n                {\n                    for(int n=j-1; n<j+2; n++)\n                    {\n                        //we will skip the iteration when element itself is encountered\n                        if(m==i && n==j)\n                            continue;\n\n                        //checking the bounds, if indices are in range, we will check for liveNeighbors\n                        if(m>=0 && m<rows && n>=0 && n<cols && copy[m][n] == 1)\n                            liveNeighbors++;\n                    }\n                }\n                \n                //for live cells, if liveNeighbors are less than 2 or more than 3, cells will die and dead cells are already dead, so we need not check cell to be live or dead\n                if(liveNeighbors < 2 || liveNeighbors > 3)\n                    board[i][j] = 0;\n\n                //for dead cells, if liveNeighbors are exactly 3, it will live and live cell will also live for exactly 3 liveNeighbors\n                else if(liveNeighbors == 3)\n                    board[i][j] = 1;\n\n                //For live cells, if liveNeighbors are exactly 2, it will live but we need not update it as it is already live\n\n            }\n        }\n    }\n};",
        "content": "\\n---\\n\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe have to update the grid according to the following rules : \\n1. Any live cell with fewer than two live neighbors dies as if caused by under-population.\\n2. Any live cell with two or three live neighbors lives on to the next generation.\\n3. Any live cell with more than three live neighbors dies, as if by over-population.\\n4. Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.\\n\\n\\n---\\n\\n\\n# Approach 1 : Using extra space for copying the board\\n<!-- Describe your approach to solving the problem. -->\\n- In this approach, we will make a copy of original board and then modify the original board by counting the live neighbours from the copy board.\\n\\n---\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void gameOfLife(vector<vector<int>>& board) {\\n\\n        int rows = board.size();\\n        int cols = board[0].size();\\n\\n        //copying the board to 2-D vector copy\\n        vector<vector<int>> copy(board);\\n\\n        for(int i=0; i<rows; i++)\\n        {\\n            for(int j=0; j<cols; j++)\\n            {\\n                //for counting live neighbors of the element\\n                int liveNeighbors = 0; \\n                \\n                //iterating through all the neighbors of the element (inside the board and outside the board)\\n                for(int m=i-1; m<i+2; m++)\\n                {\\n                    for(int n=j-1; n<j+2; n++)\\n                    {\\n                        //we will skip the iteration when element itself is encountered\\n                        if(m==i && n==j)\\n                            continue;\\n\\n                        //checking the bounds, if indices are in range, we will check for liveNeighbors\\n                        if(m>=0 && m<rows && n>=0 && n<cols && copy[m][n] == 1)\\n                            liveNeighbors++;\\n                    }\\n                }\\n                \\n                //for live cells, if liveNeighbors are less than 2 or more than 3, cells will die and dead cells are already dead, so we need not check cell to be live or dead\\n                if(liveNeighbors < 2 || liveNeighbors > 3)\\n                    board[i][j] = 0;\\n\\n                //for dead cells, if liveNeighbors are exactly 3, it will live and live cell will also live for exactly 3 liveNeighbors\\n                else if(liveNeighbors == 3)\\n                    board[i][j] = 1;\\n\\n                //For live cells, if liveNeighbors are exactly 2, it will live but we need not update it as it is already live\\n\\n            }\\n        }\\n    }\\n};\\n```\\n---\\n# Complexity\\n- Time complexity: $$O(m*n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(m*n)$$\\nWe are using extra space for copying the board.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n---\\n\\n# Approach 2 : Using no extra space\\n<!-- Describe your approach to solving the problem. -->\\n- In this approach, we will use two extra digits i.e. 2 and 3 for in-place modifications.\\n- Digits will be as follows : \\n`0 - Dead cell which will remain dead in next state`\\n`1 - Live cell which will die in next state`\\n`2 - Dead cell which will live in next state`\\n`3 - Live cell which will live in next state`\\n\\n\\nSo the approach is that we will iterate through each cell of the board and count the live Neighbors. On the basis of the conditions given in the question, we will modify the board accordingly.\\n- For live cells, if liveNeighbors are exactly 2 or 3, they will live in next state, so we will change them to 3 by adding 2 to its value . If liveNeighbors are less than 2 or more than 3, they will die in next state so we will leave it as 1.\\n-`It can be observed that even after modifying the value of live cell to 3, we can still know about the its current state by using board[i][j] mod 2 as 3%2=1.`\\n\\n- For dead cells, if liveNeighbors are exactly 3, they will live so we will update them to 2 by adding 2 to it. Otherwise they will remain dead in next state for rest of the cases, so we will not change it.\\n-`It can be observed that even after modifying the value of dead cell to 2, we can still know about the its current state by using board[i][j] mod 2 as 2%2=0.`\\n\\nSo we will use board[i][j] % 2 for checking its current state.\\n\\nNow we will iterate through the board and for all cells with values 0 or 1, we will set it to 0 and for values 2 and 3, we will set it to 1.\\n\\n---\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void gameOfLife(vector<vector<int>>& board) {\\n\\n        int rows = board.size();\\n        int cols = board[0].size();\\n\\n\\n        for(int i=0; i<rows; i++)\\n        {\\n            for(int j=0; j<cols; j++)\\n            {\\n                //for counting live neighbors of the element\\n                int liveNeighbors = 0;\\n\\n                 //iterating through all the neighbors of the element (inside the board and outside the board)\\n                for(int m=i-1; m<i+2; m++)\\n                {\\n                    for(int n=j-1; n<j+2; n++)\\n                    {\\n                        //we will skip the iteration when element itself is encountered\\n                        if(m==i && n==j)\\n                            continue;\\n                        \\n                        //checking the bounds, if indices are in range, we will check for liveNeighbors\\n                        if(m>=0 && m<rows && n>=0 && n<cols && board[m][n]%2 == 1)\\n                            liveNeighbors++;\\n                    }\\n                }\\n                \\n                //for live cells, doing the modifications\\n                if(board[i][j]%2 == 1)\\n                {\\n                    if(liveNeighbors == 2 || liveNeighbors == 3)\\n                        board[i][j] += 2;\\n                }\\n                //for dead cells, doing the modifications\\n                else\\n                {\\n                    if(liveNeighbors == 3)\\n                        board[i][j] += 2;\\n                }\\n            }\\n        }\\n\\n        //iterating through the board and setting the values accordingly\\n        for(int i=0; i<rows; i++)\\n        {\\n            for(int j=0; j<cols; j++)\\n            {\\n                if(board[i][j] >= 2)\\n                    board[i][j] = 1;\\n\\n                else\\n                    board[i][j] = 0;\\n            }\\n        }\\n    }\\n};\\n```\\n---\\n# Complexity\\n- Time complexity: $$O(m*n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\nNo extra space is used\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n---\\n### Do upvote if it helps :)",
        "level": "medium",
        "type": [
            "indexing error",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    void gameOfLife(vector<vector<int>>& board) {\n\n        int rows = board.size();\n        int cols = board[0].size();\n\n        //copying the board to 2-D vector copy\n        vector<vector<int>> copy(board);\n\n        for(int i=0; i<=rows; i++)\n        {\n            for(int j=0; j<=cols; j++)\n            {\n                //for counting live neighbors of the element\n                int liveNeighbors = 0; \n\n                //iterating through all the neighbors of the element (inside the board and outside the board)\n                for(int m=i-1; m<i+2; m++)\n                {\n                    for(int n=j-1; n<j+2; n++)\n                    {\n                        //we will skip the iteration when element itself is encountered\n                        if(m==i && n==j)\n                            continue;\n\n                        //checking the bounds, if indices are in range, we will check for liveNeighbors\n                        if(m>=0 && m<rows && n>=0 && n<cols)\n                            liveNeighbors++;\n                    }\n                }\n\n                //for live cells, if liveNeighbors are less than 2 or more than 3, cells will die and dead cells are already dead, so we need not check cell to be live or dead\n                if(liveNeighbors < 2 || liveNeighbors > 3)\n                    board[i][j] = 0;\n\n                //for dead cells, if liveNeighbors are exactly 3, it will live and live cell will also live for exactly 3 liveNeighbors\n                else if(liveNeighbors == 3)\n                    board[i][j] = 1;\n\n                //For live cells, if liveNeighbors are exactly 2, it will live but we need not update it as it is already live\n\n            }\n        }\n    }\n};\n"
    },
    {
        "slug": "longest-alternating-subarray",
        "description": "You are given a 0-indexed integer array nums. A subarray s of length m is called alternating if:\n\nm is greater than 1.\ns1 = s0 + 1.\nThe 0-indexed subarray s looks like [s0, s1, s0, s1,...,s(m-1) % 2]. In other words, s1 - s0 = 1, s2 - s1 = -1, s3 - s2 = 1, s4 - s3 = -1, and so on up to s[m - 1] - s[m - 2] = (-1)m.\n\nReturn the maximum length of all alternating subarrays present in nums or -1 if no such subarray exists.\nA subarray is a contiguous non-empty sequence of elements within an array.",
        "examples": [
            "Input: nums = [2,3,4,3,4]\nOutput: 4\nExplanation: The alternating subarrays are [3,4], [3,4,3], and [3,4,3,4]. The longest of these is [3,4,3,4], which is of length 4.",
            "Input: nums = [4,5,6]\nOutput: 2\nExplanation: [4,5] and [5,6] are the only two alternating subarrays. They are both of length 2."
        ],
        "constraints": "2 <= nums.length <= 100\n1 <= nums[i] <= 104",
        "oracle_code": "class Solution {\npublic:\n    int alternatingSubarray(vector<int>& v) {\n        int ans = 0;\n        for(int i = 0; i < v.size() - 1; i += 1) {\n            bool flag = true;\n            int cnt = 1;\n            for(int j = i + 1; j < v.size(); j += 1) {\n                if(v[j] - v[j - 1] != (flag ? 1 : -1)) break;\n                flag = !flag;\n                cnt += 1;\n            }\n            ans = max(ans, cnt);\n        }\n        return ans <= 1 ? -1 : ans;\n    }\n};",
        "content": "```\\nclass Solution {\\npublic:\\n    int alternatingSubarray(vector<int>& v) {\\n        int ans = 0;\\n        for(int i = 0; i < v.size() - 1; i += 1) {\\n            bool flag = true;\\n            int cnt = 1;\\n            for(int j = i + 1; j < v.size(); j += 1) {\\n                if(v[j] - v[j - 1] != (flag ? 1 : -1)) break;\\n                flag = !flag;\\n                cnt += 1;\\n            }\\n            ans = max(ans, cnt);\\n        }\\n        return ans <= 1 ? -1 : ans;\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "indexing error",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    int alternatingSubarray(vector<int>& v) {\n        int ans = 0;\n        int cnt = 1;\n        for(int i = 0; i <= v.size() - 1; i += 1) {\n            bool flag = true;\n            for(int j = i + 1; j <= v.size(); j += 1) {\n                if(v[j] - v[j - 1] != (flag ? 1 : -1)) break;\n                flag = !flag;\n                cnt += 1;\n            }\n            ans = max(ans, cnt);\n        }\n        return ans <= 1 ? -1 : ans;\n    }\n};\n"
    },
    {
        "slug": "add-strings",
        "description": "Given two non-negative integers, num1 and num2 represented as string, return the sum of num1 and num2 as a string.\nYou must solve the problem without using any built-in library for handling large integers (such as BigInteger). You must also not convert the inputs to integers directly.",
        "examples": [
            "Input: num1 = \"11\", num2 = \"123\"\nOutput: \"134\"",
            "Input: num1 = \"456\", num2 = \"77\"\nOutput: \"533\"",
            "Input: num1 = \"0\", num2 = \"0\"\nOutput: \"0\""
        ],
        "constraints": "1 <= num1.length, num2.length <= 104\nnum1 and num2 consist of only digits.\nnum1 and num2 don't have any leading zeros except for the zero itself.",
        "oracle_code": "class Solution {\npublic:\n    string addStrings(string a, string b) {\n        string ret = \"\" ;\n        int carry = 0, i = a.size() - 1, j = b.size() - 1;\n        while( i >= 0 || j >= 0 ){\n            int x = i >= 0 ? a[i--] - '0' : 0 ;\n            int y = j >= 0 ? b[j--] - '0' : 0 ;\n\n            int sm = x + y + carry ;\n            ret.push_back( '0' + (sm % 10) ) ;\n            carry = sm/10;\n        }\n        if(carry)\n            ret.push_back('0' + carry ) ;\n        \n        reverse( ret.begin(), ret.end() ) ;\n\n        return ret ;\n    }\n};",
        "content": "# Intuition\\nSimple solution will be to do the basice math, and simulate the digits from the back\\n\\n# Approach\\n- We\\'ll start with the ends of both strings, and in each iteration (till we\\'ve iterated all the strings), we\\'ll fetch the last digit from the $$nums1$$, $$nums2$$ if not available we\\'ll default to 0.\\n\\n- Then we\\'ll sum the digits and also add the carry from the last iteration,\\n\\n- Then we\\'ll push the sum modulo 10 to the answer string.\\n\\n- Also dont forget to update the carry variable.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string addStrings(string a, string b) {\\n        string ret = \"\" ;\\n        int carry = 0, i = a.size() - 1, j = b.size() - 1;\\n        while( i >= 0 || j >= 0 ){\\n            int x = i >= 0 ? a[i--] - \\'0\\' : 0 ;\\n            int y = j >= 0 ? b[j--] - \\'0\\' : 0 ;\\n\\n            int sm = x + y + carry ;\\n            ret.push_back( \\'0\\' + (sm % 10) ) ;\\n            carry = sm/10;\\n        }\\n        if(carry)\\n            ret.push_back(\\'0\\' + carry ) ;\\n        \\n        reverse( ret.begin(), ret.end() ) ;\\n\\n        return ret ;\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "unclosed string",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    str addStrings(string a, string b) {\n        str ret = \" ;\n        int carry = 0, i = a.size() - 1, j = b.size() - 1;\n        while( i >= 0 || j >= 0 ){\n            int x = i >= 0 ? a[i--] - '0' : 0 ;\n            int y = j >= 0 ? b[j--] - '0' : 0 ;\n\n            int sm = x + y + carry ;\n            ret.push_back( '0' + (sm % 10) ) ;\n            carry = sm/10;\n        }\n        if(carry)\n            ret.push_back('0' + carry ) ;\n        \n        reverse( ret.begin(), ret.end() ) ;\n\n        return ret ;\n    }\n};\n"
    },
    {
        "slug": "detect-cycles-in-2d-grid",
        "description": "Given a 2D array of characters grid of size m x n, you need to find if there exists any cycle consisting of the same value in grid.\nA cycle is a path of length 4 or more in the grid that starts and ends at the same cell. From a given cell, you can move to one of the cells adjacent to it - in one of the four directions (up, down, left, or right), if it has the same value of the current cell.\nAlso, you cannot move to the cell that you visited in your last move. For example, the cycle (1, 1) -> (1, 2) -> (1, 1) is invalid because from (1, 2) we visited (1, 1) which was the last visited cell.\nReturn true if any cycle of the same value exists in grid, otherwise, return false.",
        "examples": [
            "Input: grid = [[\"a\",\"a\",\"a\",\"a\"],[\"a\",\"b\",\"b\",\"a\"],[\"a\",\"b\",\"b\",\"a\"],[\"a\",\"a\",\"a\",\"a\"]]\nOutput: true\nExplanation: There are two valid cycles shown in different colors in the image below:",
            "Input: grid = [[\"c\",\"c\",\"c\",\"a\"],[\"c\",\"d\",\"c\",\"c\"],[\"c\",\"c\",\"e\",\"c\"],[\"f\",\"c\",\"c\",\"c\"]]\nOutput: true\nExplanation: There is only one valid cycle highlighted in the image below:",
            "Input: grid = [[\"a\",\"b\",\"b\"],[\"b\",\"z\",\"b\"],[\"b\",\"b\",\"a\"]]\nOutput: false"
        ],
        "constraints": "m == grid.length\nn == grid[i].length\n1 <= m, n <= 500\ngrid consists only of lowercase English letters.",
        "oracle_code": "class Solution {\npublic:\n   vector<int> dir = { 0, 1, 0, -1, 0 }; \n    bool isCyclic(vector<vector<char>>& grid, vector<vector<bool>>& visited, int i, int j, int x, int y)\n    {\n        visited[i][j] = true;\n        for(int d = 0; d < 4; ++d)\n        {\n            int a = i+dir[d];\n            int b = j+dir[d+1];\n            if(a >= 0 && a < grid.size() && b >= 0 && b < grid[0].size() && grid[a][b] == grid[i][j] && !(x == a && y == b))\n                if(visited[a][b] || isCyclic(grid, visited, a,b,i,j))\n                    return true;\n        }\n        return false;\n    }\n    bool containsCycle(vector<vector<char>>& grid) {\n        int n = grid.size(), m = grid[0].size();\n        vector<vector<bool>> visited(n, vector<bool>(m, false));\n        for(int i = 0; i < n; ++i)\n            for(int j = 0; j < m; ++j)\n                if(!visited[i][j] && isCyclic(grid, visited, i, j, -1, -1))\n                    return true;\n        return false;\n    }\n};",
        "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n   vector<int> dir = { 0, 1, 0, -1, 0 }; \\n    bool isCyclic(vector<vector<char>>& grid, vector<vector<bool>>& visited, int i, int j, int x, int y)\\n    {\\n        visited[i][j] = true;\\n        for(int d = 0; d < 4; ++d)\\n        {\\n            int a = i+dir[d];\\n            int b = j+dir[d+1];\\n            if(a >= 0 && a < grid.size() && b >= 0 && b < grid[0].size() && grid[a][b] == grid[i][j] && !(x == a && y == b))\\n                if(visited[a][b] || isCyclic(grid, visited, a,b,i,j))\\n                    return true;\\n        }\\n        return false;\\n    }\\n    bool containsCycle(vector<vector<char>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<bool>> visited(n, vector<bool>(m, false));\\n        for(int i = 0; i < n; ++i)\\n            for(int j = 0; j < m; ++j)\\n                if(!visited[i][j] && isCyclic(grid, visited, i, j, -1, -1))\\n                    return true;\\n        return false;\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "variable value error",
            "colon missing"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n   vector<int> dir = { 0, 1, 0, -1, 0 } \n    bool isCyclic(vector<vector<char>>& grid, vector<vector<bool>>& visited, int i, int j, int x, int y)\n    {\n        visited[i][j] = false;\n        for(int d = 0; d < 4; ++d)\n        {\n            int a = i+dir[d];\n            int b = j+dir[d+1];\n            if(a >= 0 && a < grid.size() && b >= 0 && b < grid[0].size() && grid[a][b] == grid[i][j] && !(x == a && y == b))\n                if(visited[a][b] || isCyclic(grid, visited, a,b,i,j))\n                    return true;\n        }\n        return false;\n    }\n    bool containsCycle(vector<vector<char>>& grid) {\n        int n = grid.size(), m = grid[0].size();\n        vector<vector<bool>> visited(n, vector<bool>(m, false));\n        for(int i = 0; i < n; ++i)\n            for(int j = 0; j < m; ++j)\n                if(!visited[i][j] && isCyclic(grid, visited, i, j, -1, -1))\n                    return true;\n        return false;\n    }\n};\n"
    },
    {
        "slug": "longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit",
        "description": "Given an array of integers nums and an integer limit, return the size of the longest non-empty subarray such that the absolute difference between any two elements of this subarray is less than or equal to limit.",
        "examples": [
            "Input: nums = [8,2,4,7], limit = 4\nOutput: 2 \nExplanation: All subarrays are: \n[8] with maximum absolute diff |8-8| = 0 <= 4.\n[8,2] with maximum absolute diff |8-2| = 6 > 4. \n[8,2,4] with maximum absolute diff |8-2| = 6 > 4.\n[8,2,4,7] with maximum absolute diff |8-2| = 6 > 4.\n[2] with maximum absolute diff |2-2| = 0 <= 4.\n[2,4] with maximum absolute diff |2-4| = 2 <= 4.\n[2,4,7] with maximum absolute diff |2-7| = 5 > 4.\n[4] with maximum absolute diff |4-4| = 0 <= 4.\n[4,7] with maximum absolute diff |4-7| = 3 <= 4.\n[7] with maximum absolute diff |7-7| = 0 <= 4. \nTherefore, the size of the longest subarray is 2.",
            "Input: nums = [10,1,2,4,7,2], limit = 5\nOutput: 4 \nExplanation: The subarray [2,4,7,2] is the longest since the maximum absolute diff is |2-7| = 5 <= 5.",
            "Input: nums = [4,2,2,2,4,4,2,2], limit = 0\nOutput: 3"
        ],
        "constraints": "1 <= nums.length <= 105\n1 <= nums[i] <= 109\n0 <= limit <= 109",
        "oracle_code": "class Solution {\npublic:\n    int longestSubarray(vector<int>& nums, int limit) {\n        int ans=1,l=0,h=1,count=1;\n        map<int,int> mp;\n        mp[nums[l]]++;\n        \n        while(h<nums.size()){\n            mp[nums[h]]++;\n            count++; //counting the number of elements in map\n            \n            if(prev(mp.end())->first - mp.begin()->first <= limit){ // checking the diff \n                ans=max(ans,count); // giving the size of subarray that may make our answer\n            }else{\n                // If diff is more than limit then we'll start deleting the indexes from left side until we get the max and minimum value such that diff is in range\n                while(prev(mp.end())->first - mp.begin()->first > limit && l<h){\n                    if(mp[nums[l]]>1)mp[nums[l]]--;\n                    else mp.erase(nums[l]);\n                    count--;\n                    l++;\n                }\n            }\n            h++;\n        }\n        return ans;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1-> We can use window sliding and keep all the values in map that can tell us min and max value in that window.\\n2-> If the range (i.e., max-min) is greater than limit then we need to delete element from the left of window that we can do using map in O(1).\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1 -> keep inserting the values in map and keep increasing the size of window, until we found max-min>limit and Keep updating the size of window as answer.\\n2-> If max-min>limit, then we can start deleting the values from map. This can be done by getting the left indexes of window and acces the value at that index and delete it from map.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nsince we are using map here, so complexity for map is O(Nlog(N));\\nand we are traversing the array from 0-N then it\\'ll take O(N);\\n\\nSo overall, **Time complexity: O(Nlog(N))**.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nsince we are using one extra map here, so **space complexity is O(N)**.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums, int limit) {\\n        int ans=1,l=0,h=1,count=1;\\n        map<int,int> mp;\\n        mp[nums[l]]++;\\n        \\n        while(h<nums.size()){\\n            mp[nums[h]]++;\\n            count++; //counting the number of elements in map\\n            \\n            if(prev(mp.end())->first - mp.begin()->first <= limit){ // checking the diff \\n                ans=max(ans,count); // giving the size of subarray that may make our answer\\n            }else{\\n                // If diff is more than limit then we\\'ll start deleting the indexes from left side until we get the max and minimum value such that diff is in range\\n                while(prev(mp.end())->first - mp.begin()->first > limit && l<h){\\n                    if(mp[nums[l]]>1)mp[nums[l]]--;\\n                    else mp.erase(nums[l]);\\n                    count--;\\n                    l++;\\n                }\\n            }\\n            h++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "wrong comment mark",
            "variable value error"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    int longestSubarray(vector<int>& nums, int limit) {\n        int ans=1,l=0,h=0,count=0;\n        map<int,int> mp;\n        mp[nums[l]]++;\n        \n        while(h<nums.size()){\n            mp[nums[h]]++;\n            count++\n            \n            if(prev(mp.end())->first - mp.begin()->first <= limit){\n                ans=max(ans,count);\n            }else{\n                while(prev(mp.end())->first - mp.begin()->first > limit && l<h){\n                    if(mp[nums[l]]>1)mp[nums[l]]--;\n                    else mp.erase(nums[l]);\n                    count--;\n                    l++;\n                }\n            }\n            h++;\n        }\n        return ans;\n    }\n};\n"
    },
    {
        "slug": "all-ancestors-of-a-node-in-a-directed-acyclic-graph",
        "description": "You are given a positive integer n representing the number of nodes of a Directed Acyclic Graph (DAG). The nodes are numbered from 0 to n - 1 (inclusive).\nYou are also given a 2D integer array edges, where edges[i] = [fromi, toi] denotes that there is a unidirectional edge from fromi to toi in the graph.\nReturn a list answer, where answer[i] is the list of ancestors of the ith node, sorted in ascending order.\nA node u is an ancestor of another node v if u can reach v via a set of edges.",
        "examples": [
            "Input: n = 8, edgeList = [[0,3],[0,4],[1,3],[2,4],[2,7],[3,5],[3,6],[3,7],[4,6]]\nOutput: [[],[],[],[0,1],[0,2],[0,1,3],[0,1,2,3,4],[0,1,2,3]]\nExplanation:\nThe above diagram represents the input graph.\n- Nodes 0, 1, and 2 do not have any ancestors.\n- Node 3 has two ancestors 0 and 1.\n- Node 4 has two ancestors 0 and 2.\n- Node 5 has three ancestors 0, 1, and 3.\n- Node 6 has five ancestors 0, 1, 2, 3, and 4.\n- Node 7 has four ancestors 0, 1, 2, and 3.",
            "Input: n = 5, edgeList = [[0,1],[0,2],[0,3],[0,4],[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]\nOutput: [[],[0],[0,1],[0,1,2],[0,1,2,3]]\nExplanation:\nThe above diagram represents the input graph.\n- Node 0 does not have any ancestor.\n- Node 1 has one ancestor 0.\n- Node 2 has two ancestors 0 and 1.\n- Node 3 has three ancestors 0, 1, and 2.\n- Node 4 has four ancestors 0, 1, 2, and 3."
        ],
        "constraints": "1 <= n <= 1000\n0 <= edges.length <= min(2000, n * (n - 1) / 2)\nedges[i].length == 2\n0 <= fromi, toi <= n - 1\nfromi != toi\nThere are no duplicate edges.\nThe graph is directed and acyclic.",
        "oracle_code": "class Solution {\npublic:\n   \n    void dfs(int i,int ansc,vector<vector<int>>&ans,vector<int>&vis,vector<vector<int>>&res){\n             \n        vis[i]=1;\n        \n        for(auto t:ans[i]){\n            if(!vis[t]){\n                dfs(t,ansc,ans,vis,res);\n            }\n        }\n       \n        if(i!=ansc)\n            res[i].push_back(ansc);\n    }\n    \n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\n        \n        vector<vector<int>>ans(n),result(n);\n        \n        for(auto a:edges){\n            ans[a[0]].push_back(a[1]);\n        }\n        \n        for(int i=0;i<n;i++){\n            vector<int>visited(n);\n            dfs(i,i,ans,visited,result);\n        }\n      \n        return result;\n    }\n};",
        "content": "```\\nclass Solution {\\npublic:\\n   \\n    void dfs(int i,int ansc,vector<vector<int>>&ans,vector<int>&vis,vector<vector<int>>&res){\\n             \\n        vis[i]=1;\\n        \\n        for(auto t:ans[i]){\\n            if(!vis[t]){\\n                dfs(t,ansc,ans,vis,res);\\n            }\\n        }\\n       \\n        if(i!=ansc)\\n            res[i].push_back(ansc);\\n    }\\n    \\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        \\n        vector<vector<int>>ans(n),result(n);\\n        \\n        for(auto a:edges){\\n            ans[a[0]].push_back(a[1]);\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            vector<int>visited(n);\\n            dfs(i,i,ans,visited,result);\\n        }\\n      \\n        return result;\\n    }\\n};",
        "level": "medium",
        "type": [
            "statement separation",
            "variable value error"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n   \n    void dfs(int i,int ansc,vector<vector<int>>&ans,vector<int>&vis,vector<vector<int>>&res){\n        \n        vis[i]=1;\n        for(auto t:ans[i]){\n            if(!vis[t])\n                dfs(t,ansc,ans,vis,res)\n        }\n        if(i!=ansc)\n            res[i].push_back(ansc);\n    }\n    \n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\n        \n        vector<vector<int>>ans(n),result(n);\n        \n        for(auto a:edges){\n            ans[a[0]].push_back(a[1]);\n        }\n\n        vector<int>visited(n);\n\n        for(int i=0;i<n;i++){\n            dfs(i,i,ans,visited,result);\n        }\n      \n        return result;\n    }\n};\n"
    },
    {
        "slug": "shortest-path-visiting-all-nodes",
        "description": "You have an undirected, connected graph of n nodes labeled from 0 to n - 1. You are given an array graph where graph[i] is a list of all the nodes connected with node i by an edge.\nReturn the length of the shortest path that visits every node. You may start and stop at any node, you may revisit nodes multiple times, and you may reuse edges.",
        "examples": [
            "Input: graph = [[1,2,3],[0],[0],[0]]\nOutput: 4\nExplanation: One possible path is [1,0,2,0,3]",
            "Input: graph = [[1],[0,2,4],[1,3,4],[2],[1,2]]\nOutput: 4\nExplanation: One possible path is [0,1,4,2,3]"
        ],
        "constraints": "n == graph.length\n1 <= n <= 12\n0 <= graph[i].length <\u00a0n\ngraph[i] does not contain i.\nIf graph[a] contains b, then graph[b] contains a.\nThe input graph is always connected.",
        "oracle_code": "class Solution {\npublic:\n    int shortestPathLength(vector<vector<int>>& graph) {\n        int n=graph.size();\n        if(n==1) return 0;\n        set<pair<int,int>>vis;\n        queue<pair<int,pair<int,int>>>q;\n        int all=(1<<n)-1;\n        for(int i=0;i<n;i++){\n            int mask=1<<i;\n            q.push({i,{0,mask}});\n            vis.insert({i,mask});\n        }\n        while(!q.empty()){\n            int node=q.front().first;\n            int dist=q.front().second.first;\n            int mask=q.front().second.second;\n            q.pop();\n            for(auto it:graph[node]){\n                int newMask=(mask|(1<<it));\n                if(newMask==all)\n                    return dist+1;\n                else if(vis.count({it,newMask}))\n                    continue;\n                q.push({it,{dist+1,newMask}});\n                vis.insert({it,newMask});\n            }\n        }\n        return 0;\n    }\n};",
        "content": "```\\nclass Solution {\\npublic:\\n    int shortestPathLength(vector<vector<int>>& graph) {\\n        int n=graph.size();\\n        if(n==1) return 0;\\n        set<pair<int,int>>vis;\\n        queue<pair<int,pair<int,int>>>q;\\n        int all=(1<<n)-1;\\n        for(int i=0;i<n;i++){\\n            int mask=1<<i;\\n            q.push({i,{0,mask}});\\n            vis.insert({i,mask});\\n        }\\n        while(!q.empty()){\\n            int node=q.front().first;\\n            int dist=q.front().second.first;\\n            int mask=q.front().second.second;\\n            q.pop();\\n            for(auto it:graph[node]){\\n                int newMask=(mask|(1<<it));\\n                if(newMask==all)\\n                    return dist+1;\\n                else if(vis.count({it,newMask}))\\n                    continue;\\n                q.push({it,{dist+1,newMask}});\\n                vis.insert({it,newMask});\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
        "level": "hard",
        "type": [
            "== and = confusion",
            "colon missing"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    int shortestPathLength(vector<vector<int>>& graph)\n        int n=graph.size();\n        if(n=1) return 0;\n        set<pair<int,int>>vis;\n        queue<pair<int,pair<int,int>>>q;\n        int all=(1<<n)-1;\n        for(int i=0;i<n;i++){\n            int mask=1<<i;\n            q.push({i,{0,mask}});\n            vis.insert({i,mask});\n        }\n        while(!q.empty()){\n            int node=q.front().first;\n            int dist=q.front().second.first;\n            int mask=q.front().second.second;\n            q.pop();\n            for(auto it:graph[node]){\n                int newMask=(mask|(1<<it));\n                if(newMask=all)\n                    return dist+1;\n                else if(vis.count({it,newMask}))\n                    continue;\n                q.push({it,{dist+1,newMask}});\n                vis.insert({it,newMask});\n            }\n        }\n        return 0;\n    }\n};\n"
    },
    {
        "slug": "length-of-the-longest-valid-substring",
        "description": "You are given a string word and an array of strings forbidden.\nA string is called valid if none of its substrings are present in forbidden.\nReturn the length of the longest valid substring of the string word.\nA substring is a contiguous sequence of characters in a string, possibly empty.",
        "examples": [
            "Input: word = \"cbaaaabc\", forbidden = [\"aaa\",\"cb\"]\nOutput: 4\nExplanation: There are 11 valid substrings in word: \"c\", \"b\", \"a\", \"ba\", \"aa\", \"bc\", \"baa\", \"aab\", \"ab\", \"abc\"and \"aabc\". The length of the longest valid substring is 4. \nIt can be shown that all other substrings contain either \"aaa\" or \"cb\" as a substring.",
            "Input: word = \"leetcode\", forbidden = [\"de\",\"le\",\"e\"]\nOutput: 4\nExplanation: There are 11 valid substrings in word: \"l\", \"t\", \"c\", \"o\", \"d\", \"tc\", \"co\", \"od\", \"tco\", \"cod\", and \"tcod\". The length of the longest valid substring is 4.\nIt can be shown that all other substrings contain either \"de\", \"le\", or \"e\" as a substring."
        ],
        "constraints": "1 <= word.length <= 105\nword consists only of lowercase English letters.\n1 <= forbidden.length <= 105\n1 <= forbidden[i].length <= 10\nforbidden[i] consists only of lowercase English letters.",
        "oracle_code": "class Solution {\npublic:\n    int longestValidSubstring(string word, vector<string>& forbidden) {\n        vector<int> ends(word.size() , -1);\n        unordered_map<string, int> forbidden_word;\n        for(auto it : forbidden)forbidden_word[it] = 1;\n        int n = word.size();\n        for(int i = 0; i<n; i++){\n            string temp = \"\";\n            for(int j = i; j<i+10 && j<n; j++){\n                temp += word[j];\n                if(forbidden_word.find(temp) != forbidden_word.end()) {\n                    ends[j] = i;\n                }\n            }\n        }\n        \n        int i = 0, j = 0;\n        int ans = INT_MIN;\n        while(j < n){\n            \n            if(ends[j] != -1){\n                int st = ends[j];\n                if(st < i){\n                    ans = max(ans, j-i+1);\n                }\n                else{\n                    i = st+1;\n                    ans = max(ans, j-i+1);\n                }\n            }\n            else ans = max(ans,j-i+1);\n            j++;\n        }\n        return ans;\n    }\n};",
        "content": "# Intuition\\nWe can use sliding window + Vector.\\n\\n# Approach\\n\\nWe will initialize a vector end of size word with -1.Than we know the forbidden[i].size() is <= 10, so we can find all the index of the forbidden[i] in word string. we just need to find the ending points of each forbidden[i] in the word string and store it in ends vector with value of the starting index.\\n\\nNow we will use Sliding Window.\\n- we check for each right pointer j in our vector that is, is it a end point? if yes than we need to find the starting point of the substring and let it be \"st\" using our vector of end points. than we check if st < i (our left pointer) if yes than it means our window is safe because it doesnt contain starting index of the particular forbidden word ending at j.\\n\\nif st >= i(our left pointer) that means the starting point of forbidden word ending with right pointer j is in our window so we have to remove it by movig left pointer i = st+1.\\n\\nif our right pointer j is not a end point than the window is valid and we can store the ans of it.\\n\\n# Complexity\\n- Time complexity:\\n- O(N)\\n\\n- Space complexity:\\n- O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestValidSubstring(string word, vector<string>& forbidden) {\\n        vector<int> ends(word.size() , -1);\\n        unordered_map<string, int> forbidden_word;\\n        for(auto it : forbidden)forbidden_word[it] = 1;\\n        int n = word.size();\\n        for(int i = 0; i<n; i++){\\n            string temp = \"\";\\n            for(int j = i; j<i+10 && j<n; j++){\\n                temp += word[j];\\n                if(forbidden_word.find(temp) != forbidden_word.end()) {\\n                    ends[j] = i;\\n                }\\n            }\\n        }\\n        \\n        int i = 0, j = 0;\\n        int ans = INT_MIN;\\n        while(j < n){\\n            \\n            if(ends[j] != -1){\\n                int st = ends[j];\\n                if(st < i){\\n                    ans = max(ans, j-i+1);\\n                }\\n                else{\\n                    i = st+1;\\n                    ans = max(ans, j-i+1);\\n                }\\n            }\\n            else ans = max(ans,j-i+1);\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
        "level": "hard",
        "type": [
            "operation error",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    int longestValidSubstring(string word, vector<string>& forbidden) {\n        vector<int> ends(word.size() , -1);\n        unordered_map<string, int> forbidden_word;\n        for(auto it : forbidden) forbidden_word[it] = 1;\n        int n = word.size();\n        for(int i = 0; i<n; i++){\n            string temp = \"\";\n            for(int j = i; j<i+10 && j<n; j++){\n                temp += word[j];\n                if(forbidden_word.find(temp) != forbidden_word.end()) {\n                    ends[j] = i;\n                }\n            }\n        }\n        \n        int i = 0, j = 0;\n        int ans = INT_MIN;\n        while(j < n){\n            \n            if(ends[j] != -1){\n                int st = ends[j];\n                if(st < i){\n                    ans = max(ans, j-i+1);\n                }\n                else{\n                    i = st+1;\n                    ans = max(ans, j-i);\n                }\n            }\n            else ans = max(ans,j-i+1);\n                j++;\n                j++;\n        }\n        return longestSubsequence(ans, ends);\n    }\n\n};\n\n"
    },
    {
        "slug": "search-insert-position",
        "description": "Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.\nYou must\u00a0write an algorithm with\u00a0O(log n) runtime complexity.",
        "examples": [
            "Input: nums = [1,3,5,6], target = 5\nOutput: 2",
            "Input: nums = [1,3,5,6], target = 2\nOutput: 1",
            "Input: nums = [1,3,5,6], target = 7\nOutput: 4"
        ],
        "constraints": "1 <= nums.length <= 104\n-104 <= nums[i] <= 104\nnums contains distinct values sorted in ascending order.\n-104 <= target <= 104",
        "oracle_code": "class Solution {\npublic:\n    int searchInsert(vector<int>& nums, int target) {\n        int l=0;\n        int r=nums.size()-1;\n        int m;\n        while(l<=r){\n            m=(l+r)/2;\n            if(nums[m]==target){\n                return m;\n            }else if(nums[m]>target){\n                r=m-1;\n            }\n            else{\n                l=m+1;\n            }\n        }\n        return l;\n    }\n};",
        "content": "# Complexity\\n- Time complexity: O(log(n)) -> Binary Search\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        int l=0;\\n        int r=nums.size()-1;\\n        int m;\\n        while(l<=r){\\n            m=(l+r)/2;\\n            if(nums[m]==target){\\n                return m;\\n            }else if(nums[m]>target){\\n                r=m-1;\\n            }\\n            else{\\n                l=m+1;\\n            }\\n        }\\n        return l;\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "variable value error",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    int searchInsert(vector<int>& nums, int target) {\n        int l=0;\n        int r=nums.size();\n        int m;\n        while(l<=r){\n            m=(l+r)/2;\n            if(nums[m]==target){\n                return m;\n            }else if(nums[m]>target){\n                r=m-1;\n            }\n            else{\n                l=m;\n            }\n        }\n        return l;\n    }\n};\n"
    },
    {
        "slug": "prime-in-diagonal",
        "description": "You are given a 0-indexed two-dimensional integer array nums.\nReturn the largest prime number that lies on at least one of the diagonals of nums. In case, no prime is present on any of the diagonals, return 0.\nNote that:\n\nAn integer is prime if it is greater than 1 and has no positive integer divisors other than 1 and itself.\nAn integer val is on one of the diagonals of nums if there exists an integer i for which nums[i][i] = val or an i for which nums[i][nums.length - i - 1] = val.\n\n\nIn the above diagram, one diagonal is [1,5,9] and another diagonal is [3,5,7].",
        "examples": [
            "Input: nums = [[1,2,3],[5,6,7],[9,10,11]]\nOutput: 11\nExplanation: The numbers 1, 3, 6, 9, and 11 are the only numbers present on at least one of the diagonals. Since 11 is the largest prime, we return 11.",
            "Input: nums = [[1,2,3],[5,17,7],[9,11,10]]\nOutput: 17\nExplanation: The numbers 1, 3, 9, 10, and 17 are all present on at least one of the diagonals. 17 is the largest prime, so we return 17."
        ],
        "constraints": "1 <= nums.length <= 300\nnums.length == numsi.length\n1 <= nums[i][j]\u00a0<= 4*106",
        "oracle_code": "class Solution {\npublic:\n    bool check(int x){\n        if(x==1)return false;\n        for(int i = 2; i*i<=x; i++){\n            if(x%i==0)return false;\n        }\n        return true;\n    }\n    int diagonalPrime(vector<vector<int>>& nums) {\n        int i,ans=0,n=nums.size();\n        for(i = 0; i < n; i++){\n            if(check(nums[i][i]) && nums[i][i]>ans){\n                ans = nums[i][i];\n            }\n            if(check(nums[i][n-1-i]) && nums[i][n-1-i]>ans){\n                ans = nums[i][n-1-i];\n            }\n        }\n        return ans;\n    }\n};",
        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(int x){\\n        if(x==1)return false;\\n        for(int i = 2; i*i<=x; i++){\\n            if(x%i==0)return false;\\n        }\\n        return true;\\n    }\\n    int diagonalPrime(vector<vector<int>>& nums) {\\n        int i,ans=0,n=nums.size();\\n        for(i = 0; i < n; i++){\\n            if(check(nums[i][i]) && nums[i][i]>ans){\\n                ans = nums[i][i];\\n            }\\n            if(check(nums[i][n-1-i]) && nums[i][n-1-i]>ans){\\n                ans = nums[i][n-1-i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "wrong comment mark",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    bool check(int x){\n        if(x==1)return false;\n        for(int i = 2; i*i<=x; i++){\n            if(x%i==0)return false;\n        }\n        / return true;\n    }\n    int diagonalPrime(vector<vector<int>>& nums) {\n        int i,ans=0,n=nums.size();\n        for(i = 0; i < n; i++){\n            if(check(nums[i][i]) && nums[i][i]>ans){\n                ans = nums[i][i];\n            }\n            if(check(nums[i][n-i]) && nums[i][n-i]>ans){\n                ans = nums[i][n-i];\n            }\n        }\n        return ans;\n    }\n};\n"
    },
    {
        "slug": "maximum-number-of-removable-characters",
        "description": "You are given two strings s and p where p is a subsequence of s. You are also given a distinct 0-indexed integer array removable containing a subset of indices of s (s is also 0-indexed).\nYou want to choose an integer k (0 <= k <= removable.length) such that, after removing k characters from s using the first k indices in removable, p is still a subsequence of s. More formally, you will mark the character at s[removable[i]] for each 0 <= i < k, then remove all marked characters and check if p is still a subsequence.\nReturn the maximum k you can choose such that p is still a subsequence of s after the removals.\nA subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.",
        "examples": [
            "Input: s = \"abcacb\", p = \"ab\", removable = [3,1,0]\nOutput: 2\nExplanation: After removing the characters at indices 3 and 1, \"abcacb\" becomes \"accb\".\n\"ab\" is a subsequence of \"accb\".\nIf we remove the characters at indices 3, 1, and 0, \"abcacb\" becomes \"ccb\", and \"ab\" is no longer a subsequence.\nHence, the maximum k is 2.",
            "Input: s = \"abcbddddd\", p = \"abcd\", removable = [3,2,1,4,5,6]\nOutput: 1\nExplanation: After removing the character at index 3, \"abcbddddd\" becomes \"abcddddd\".\n\"abcd\" is a subsequence of \"abcddddd\".",
            "Input: s = \"abcab\", p = \"abc\", removable = [0,1,2,3,4]\nOutput: 0\nExplanation: If you remove the first index in the array removable, \"abc\" is no longer a subsequence."
        ],
        "constraints": "1 <= p.length <= s.length <= 105\n0 <= removable.length < s.length\n0 <= removable[i] < s.length\np is a subsequence of s.\ns and p both consist of lowercase English letters.\nThe elements in removable are distinct.",
        "oracle_code": "class Solution {\n int rm[100001] = {};\n    bool valid(string &s, string &p, vector<int> &A, int k) {\n        memset(rm, 0, sizeof(rm));\n        for (int i = 0; i < k; ++i) rm[A[i]] = 1; \n        int N = s.size(), M = p.size(), j = 0; \n        for (int i = 0; i < N && j < M; ++i) {\n            if (rm[i] == 1) continue; \n            if (s[i] == p[j]) ++j; \n        }\n        return j == M; \n    }\npublic:\n    int maximumRemovals(string s, string p, vector<int>& A) {\n        int L = 0, R = A.size();\n        while (L <= R) {\n            int M = (L + R) / 2;\n            if (valid(s, p, A, M)) L = M + 1;\n            else R = M - 1;\n        }\n        return R;\n    }\n};",
        "content": "\\n\\n# Code\\n```\\nclass Solution {\\n int rm[100001] = {};\\n    bool valid(string &s, string &p, vector<int> &A, int k) {\\n        memset(rm, 0, sizeof(rm));\\n        for (int i = 0; i < k; ++i) rm[A[i]] = 1; \\n        int N = s.size(), M = p.size(), j = 0; \\n        for (int i = 0; i < N && j < M; ++i) {\\n            if (rm[i] == 1) continue; \\n            if (s[i] == p[j]) ++j; \\n        }\\n        return j == M; \\n    }\\npublic:\\n    int maximumRemovals(string s, string p, vector<int>& A) {\\n        int L = 0, R = A.size();\\n        while (L <= R) {\\n            int M = (L + R) / 2;\\n            if (valid(s, p, A, M)) L = M + 1;\\n            else R = M - 1;\\n        }\\n        return R;\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "variable value error",
            "colon missing"
        ],
        "buggy_code": "\nclass Solution {\n int rm[100001] = {};\n    bool valid(string &s, string &p, vector<int> &A, int k) {\n        memset(rm, 0, sizeof(rm));\n        for int i = 0; i < k; ++i) rm[A[i]] = 1; \n        int N = s.size(), M = p.size(), j = 0; \n        for (int i = 0; i < N && j < M; ++i) {\n            if (rm[i] == 1) continue; \n            if (s[i] == p[j]) ++j; \n        }\n        return j == N; \n    }\npublic:\n    int maximumRemovals(string s, string p, vector<int>& A) {\n        int L = 0, R = A.size();\n        while (L <= R) {\n            int M = (L + R) / 2;\n            if (valid(s, p, A, M)) L = M + 1;\n            else R = M - 1;\n        }\n        return R;\n    }\n};\n"
    },
    {
        "slug": "minimum-moves-to-reach-target-with-rotations",
        "description": "In an\u00a0n*n\u00a0grid, there is a snake that spans 2 cells and starts moving from the top left corner at (0, 0) and (0, 1). The grid has empty cells represented by zeros and blocked cells represented by ones. The snake wants to reach the lower right corner at\u00a0(n-1, n-2)\u00a0and\u00a0(n-1, n-1).\nIn one move the snake can:\n\nMove one cell to the right\u00a0if there are no blocked cells there. This move keeps the horizontal/vertical position of the snake as it is.\nMove down one cell\u00a0if there are no blocked cells there. This move keeps the horizontal/vertical position of the snake as it is.\nRotate clockwise if it's in a horizontal position and the two cells under it are both empty. In that case the snake moves from\u00a0(r, c)\u00a0and\u00a0(r, c+1)\u00a0to\u00a0(r, c)\u00a0and\u00a0(r+1, c).\n\nRotate counterclockwise\u00a0if it's in a vertical position and the two cells to its right are both empty. In that case the snake moves from\u00a0(r, c)\u00a0and\u00a0(r+1, c)\u00a0to\u00a0(r, c)\u00a0and\u00a0(r, c+1).\n\n\nReturn the minimum number of moves to reach the target.\nIf there is no way to reach the target, return\u00a0-1.",
        "examples": [
            "Input: grid = [[0,0,0,0,0,1],\n               [1,1,0,0,1,0],\n\u00a0              [0,0,0,0,1,1],\n\u00a0              [0,0,1,0,1,0],\n\u00a0              [0,1,1,0,0,0],\n\u00a0              [0,1,1,0,0,0]]\nOutput: 11\nExplanation:\nOne possible solution is [right, right, rotate clockwise, right, down, down, down, down, rotate counterclockwise, right, down].",
            "Input: grid = [[0,0,1,1,1,1],\n\u00a0              [0,0,0,0,1,1],\n\u00a0              [1,1,0,0,0,1],\n\u00a0              [1,1,1,0,0,1],\n\u00a0              [1,1,1,0,0,1],\n\u00a0              [1,1,1,0,0,0]]\nOutput: 9"
        ],
        "constraints": "2 <= n <= 100\n0 <= grid[i][j] <= 1\nIt is guaranteed that the snake starts at empty cells.",
        "oracle_code": "class Solution {\n    int n;\n    vector<vector<int>> hmemo, vmemo;\n    vector<vector<int>> *gridp;\n\n    int dfs(bool h, int r, int c) {\n        vector<vector<int>> & grid = *gridp;\n        if (h && r == n-1 && c == n-2)\n            return 0;\n        int res = INT_MAX-1;\n        if (h) {\n            if (hmemo[r][c] > 0) {\n                return hmemo[r][c];\n            }\n            hmemo[r][c] = INT_MAX-1;\n            if (c+2 < n && grid[r][c+2] == 0) {\n                // move right\n                res = min(res, 1+dfs(true, r, c+1));\n            }\n            if (r+1 < n && grid[r+1][c] == 0 && grid[r+1][c+1] == 0) {\n                // move down\n                res = min(res, 1+dfs(true, r+1, c));\n                // rotate clockwise\n                res = min(res, 1+dfs(false, r, c));\n            }\n            hmemo[r][c] = res;\n            return res;\n        } else {\n            if (vmemo[r][c] > 0) {\n                return vmemo[r][c];\n            }\n            vmemo[r][c] = INT_MAX-1;\n            if (r+2 < n && grid[r+2][c] == 0) {\n                // move down\n                res = min(res, 1+dfs(false, r+1, c));\n            }\n            if (c+1 < n && grid[r][c+1] == 0 && grid[r+1][c+1] == 0) {\n                // move right\n                res = min(res, 1+dfs(false, r, c+1));\n                // rotate counterclockwise\n                res = min(res, 1+dfs(true, r, c));\n            }\n            vmemo[r][c] = res;\n            return res;\n        }\n    }\n\npublic:\n    int minimumMoves(vector<vector<int>>& grid) {\n        this->gridp = &grid;\n        n = grid.size();\n        hmemo = vector<vector<int>>(n, vector<int>(n, -1));\n        vmemo = vector<vector<int>>(n, vector<int>(n, -1));\n        int res = dfs(true, 0, 0);\n        return res < INT_MAX-1 ? res : -1;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIt\\'s *generally* better to use BFS for search problems like this. However, given the constraints for this problem, DFS+memo is more than adequate; in fact it is both simpler and faster.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDFS with two 2D arrays for memoization: `hmemo` for when we\\'re horizontal, and `vmemo` for when we\\'re vertical. While we\\'re running DFS on a point, we can set its memo to `INT_MAX-1` so the code will short-circuit if we attempt anything that could cause a cycle. I also return `INT_MAX-1` if the target is unreachable. (`INT_MAX-1` avoids overflow when doing `1+dfs(...)`).\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$, 17ms beats 100% apparently!\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int n;\\n    vector<vector<int>> hmemo, vmemo;\\n    vector<vector<int>> *gridp;\\n\\n    int dfs(bool h, int r, int c) {\\n        vector<vector<int>> & grid = *gridp;\\n        if (h && r == n-1 && c == n-2)\\n            return 0;\\n        int res = INT_MAX-1;\\n        if (h) {\\n            if (hmemo[r][c] > 0) {\\n                return hmemo[r][c];\\n            }\\n            hmemo[r][c] = INT_MAX-1;\\n            if (c+2 < n && grid[r][c+2] == 0) {\\n                // move right\\n                res = min(res, 1+dfs(true, r, c+1));\\n            }\\n            if (r+1 < n && grid[r+1][c] == 0 && grid[r+1][c+1] == 0) {\\n                // move down\\n                res = min(res, 1+dfs(true, r+1, c));\\n                // rotate clockwise\\n                res = min(res, 1+dfs(false, r, c));\\n            }\\n            hmemo[r][c] = res;\\n            return res;\\n        } else {\\n            if (vmemo[r][c] > 0) {\\n                return vmemo[r][c];\\n            }\\n            vmemo[r][c] = INT_MAX-1;\\n            if (r+2 < n && grid[r+2][c] == 0) {\\n                // move down\\n                res = min(res, 1+dfs(false, r+1, c));\\n            }\\n            if (c+1 < n && grid[r][c+1] == 0 && grid[r+1][c+1] == 0) {\\n                // move right\\n                res = min(res, 1+dfs(false, r, c+1));\\n                // rotate counterclockwise\\n                res = min(res, 1+dfs(true, r, c));\\n            }\\n            vmemo[r][c] = res;\\n            return res;\\n        }\\n    }\\n\\npublic:\\n    int minimumMoves(vector<vector<int>>& grid) {\\n        this->gridp = &grid;\\n        n = grid.size();\\n        hmemo = vector<vector<int>>(n, vector<int>(n, -1));\\n        vmemo = vector<vector<int>>(n, vector<int>(n, -1));\\n        int res = dfs(true, 0, 0);\\n        return res < INT_MAX-1 ? res : -1;\\n    }\\n};\\n```",
        "level": "hard",
        "type": [
            "indexing error",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution {\n    int n;\n    vector<vector<int>> hmemo, vmemo;\n    vector<vector<int>> *gridp;\n\n    int dfs(bool h, int r, int c) {\n        vector<vector<int>> & grid = *gridp;\n        if (h && r == n-1 && c == n-2)\n            return 0;\n        int res = INT_MAX-1;\n        if (h) {\n            if (hmemo[r][c] > 0) {\n                return hmemo[r][c];\n            }\n            hmemo[r][c] = INT_MAX-1;\n            if (c+2 < n && grid[r][c+2] == 1) {\n                // move right\n                res = min(res, 1+dfs(true, r, c+1));\n            }\n            if (r+1 < n && grid[r+1][c] == 1 && grid[r+1][c+1] == 1) {\n                // move down\n                res = min(res, 1+dfs(true, r+1, c));\n                // rotate clockwise\n                res = min(res, 1+dfs(false, r, c));\n            }\n            hmemo[r][c] = res;\n            return res;\n        } else {\n            if (vmemo[r][c] < 0) {\n                return vmemo[r][c];\n            }\n            vmemo[r][c] = INT_MAX-1;\n            if (r+2 < n && grid[r+2][c] == 1) {\n                // move down\n                res = min(res, 1+dfs(false, r+1, c));\n            }\n            if (c+1 < n && grid[r][c+1] == 1 && grid[r+1][c+1] == 1) {\n                // move right\n                res = min(res, 1+dfs(false, r, c+1));\n                // rotate counterclockwise\n                res = min(res, 1+dfs(true, r, c));\n            }\n            vmemo[r][c] = res;\n            return res;\n        }\n    }\n\npublic:\n    int minimumMoves(vector<vector<int>>& grid) {\n        this->gridp = &grid;\n        n = grid.size();\n        hmemo = vector<vector<int>>(n, vector<int>(n, -1));\n        vmemo = vector<vector<int>>(n, vector<int>(n, -1));\n        int res = dfs(true, 0, 0);\n        return res < INT_MAX-1 ? res : -1;\n    }\n};\n"
    },
    {
        "slug": "shortest-path-with-alternating-colors",
        "description": "You are given an integer n, the number of nodes in a directed graph where the nodes are labeled from 0 to n - 1. Each edge is red or blue in this graph, and there could be self-edges and parallel edges.\nYou are given two arrays redEdges and blueEdges where:\n\nredEdges[i] = [ai, bi] indicates that there is a directed red edge from node ai to node bi in the graph, and\nblueEdges[j] = [uj, vj] indicates that there is a directed blue edge from node uj to node vj in the graph.\n\nReturn an array answer of length n, where each answer[x] is the length of the shortest path from node 0 to node x such that the edge colors alternate along the path, or -1 if such a path does not exist.",
        "examples": [
            "Input: n = 3, redEdges = [[0,1],[1,2]], blueEdges = []\nOutput: [0,1,-1]",
            "Input: n = 3, redEdges = [[0,1]], blueEdges = [[2,1]]\nOutput: [0,1,-1]"
        ],
        "constraints": "1 <= n <= 100\n0 <= redEdges.length,\u00a0blueEdges.length <= 400\nredEdges[i].length == blueEdges[j].length == 2\n0 <= ai, bi, uj, vj < n",
        "oracle_code": "class Solution {\npublic:\n    vector<int> shortestAlternatingPaths(int n,vector<vector<int>>&redEdges,vector<vector<int>>& blueEdges) \n    {\n        multiset<int>temp;\n        vector<multiset<int>>redchilds(n,temp),bluechilds(n,temp);\n        for(auto j:redEdges)\n        {\n            redchilds[j[0]].insert(j[1]);\n        }\n        for(auto j:blueEdges)\n        {\n            bluechilds[j[0]].insert(j[1]);\n        }\n        vector<int>ans;\n        for(int i=0;i<n;i++)\n        {\n            //BFS for all\n            vector<multiset<int>>reds=redchilds,blues=bluechilds;\n            queue<pair<char,int>>visit;\n            visit.push({'n',0});//neutral='n'\n            int steps=0;\n            while(!visit.empty())\n            {\n                bool justbreak=false;\n                int n=visit.size();\n                for(int j=0;j<n;j++)\n                {\n                    pair<char,int>x=visit.front();\n                    visit.pop();\n                    if(x.second==i)\n                    {\n                        ans.push_back(steps);\n                        justbreak=true;\n                        break;\n                    }\n                    if(x.first=='n')\n                    {\n                        for(auto j:reds[x.second])\n                        {\n                            visit.push({'r',j});\n                            auto itr1=reds[x.second].find(j);\n                            reds[x.second].erase(itr1);\n                        }\n                        for(auto j:blues[x.second])\n                        {\n                            visit.push({'b',j});//blue='b'\n                            auto itr1=blues[x.second].find(j);\n                            blues[x.second].erase(itr1);\n                        }\n                    }\n                    else if(x.first=='b')\n                    {\n                        for(auto j:reds[x.second])\n                        {\n                            visit.push({'r',j});//red='r'\n                            auto itr1=reds[x.second].find(j);\n                            reds[x.second].erase(itr1);\n                        }\n                    }\n                    else if(x.first=='r')\n                    {\n                        for(auto j:blues[x.second])\n                        {\n                            visit.push({'b',j});\n                            auto itr1=blues[x.second].find(j);\n                            blues[x.second].erase(itr1);\n                        }\n                    }\n                }\n                if(justbreak)\n                {\n                    break;\n                }\n                steps++;\n            }\n            if(i==ans.size())\n            {\n                ans.push_back(-1);\n            }\n        }\n        return ans;\n    }\n};",
        "content": "*E denotes number of Edges*\\n\\n# Complexity\\n- Time complexity:\\nO((N^2)+(N)*(E)*LOG(E))\\n\\n- Space complexity:\\nO(E)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> shortestAlternatingPaths(int n,vector<vector<int>>&redEdges,vector<vector<int>>& blueEdges) \\n    {\\n        multiset<int>temp;\\n        vector<multiset<int>>redchilds(n,temp),bluechilds(n,temp);\\n        for(auto j:redEdges)\\n        {\\n            redchilds[j[0]].insert(j[1]);\\n        }\\n        for(auto j:blueEdges)\\n        {\\n            bluechilds[j[0]].insert(j[1]);\\n        }\\n        vector<int>ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            //BFS for all\\n            vector<multiset<int>>reds=redchilds,blues=bluechilds;\\n            queue<pair<char,int>>visit;\\n            visit.push({\\'n\\',0});//neutral=\\'n\\'\\n            int steps=0;\\n            while(!visit.empty())\\n            {\\n                bool justbreak=false;\\n                int n=visit.size();\\n                for(int j=0;j<n;j++)\\n                {\\n                    pair<char,int>x=visit.front();\\n                    visit.pop();\\n                    if(x.second==i)\\n                    {\\n                        ans.push_back(steps);\\n                        justbreak=true;\\n                        break;\\n                    }\\n                    if(x.first==\\'n\\')\\n                    {\\n                        for(auto j:reds[x.second])\\n                        {\\n                            visit.push({\\'r\\',j});\\n                            auto itr1=reds[x.second].find(j);\\n                            reds[x.second].erase(itr1);\\n                        }\\n                        for(auto j:blues[x.second])\\n                        {\\n                            visit.push({\\'b\\',j});//blue=\\'b\\'\\n                            auto itr1=blues[x.second].find(j);\\n                            blues[x.second].erase(itr1);\\n                        }\\n                    }\\n                    else if(x.first==\\'b\\')\\n                    {\\n                        for(auto j:reds[x.second])\\n                        {\\n                            visit.push({\\'r\\',j});//red=\\'r\\'\\n                            auto itr1=reds[x.second].find(j);\\n                            reds[x.second].erase(itr1);\\n                        }\\n                    }\\n                    else if(x.first==\\'r\\')\\n                    {\\n                        for(auto j:blues[x.second])\\n                        {\\n                            visit.push({\\'b\\',j});\\n                            auto itr1=blues[x.second].find(j);\\n                            blues[x.second].erase(itr1);\\n                        }\\n                    }\\n                }\\n                if(justbreak)\\n                {\\n                    break;\\n                }\\n                steps++;\\n            }\\n            if(i==ans.size())\\n            {\\n                ans.push_back(-1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "unclosed string",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    vector<int> shortestAlternatingPaths(int n,vector<vector<int>>&redEdges,vector<vector<int>>& blueEdges) \n    {\n        multiset<int>temp;\n        vector<multiset<int>>redchilds(n,temp),bluechilds(n,temp);\n        for(auto j:redEdges)\n        {\n            redchilds[j[0]].insert(j[1]);\n        }\n        for(auto j:blueEdges)\n        {\n            bluechilds[j[0]].insert(j[1]);\n        }\n        vector<int>ans(n, -1);\n        for(int i=0;i<n;) \n        {\n            //BFS for all\n            vector<multiset<int>>reds=redchilds,blues=bluechilds;\n            queue<pair<char,int>>visit;\n            visit.push({'n',0});//neutral='n'\n            int steps=0;\n            while(!visit.empty())\n            {\n                bool justbreak=false;\n                int n=visit.size();\n                for(int j=0;j<n;j++)\n                {\n                    pair<char,int>x=visit.front();\n                    visit.pop();\n                    if(x.second==i)\n                    {\n                        ans[i]=steps;\n                        justbreak=true;\n                        break;\n                    }\n                    if(x.first=='n' || x.first == ans[i] % 2 + '0') \n                    {\n                        for(auto j:reds[x.second])\n                        {\n                            visit.push({'r\",j});\n                            auto itr1=reds[x.second].find(j);\n                            reds[x.second].erase(itr1);\n                        }\n                        for(auto j:blues[x.second])\n                        {\n                            visit.push({'b',j});//blue='b'\n                            auto itr1=blues[x.second].find(j);\n                            blues[x.second].erase(itr1);\n                        }\n                    }\n                    else if(x.first=='b')\n                    {\n                        for(auto j:reds[x.second])\n                        {\n                            visit.push({'r',j});//red='r'\n                            auto itr1=reds[x.second].find(j);\n                            reds[x.second].erase(itr1);\n                        }\n                    }\n                    else if(x.first=='r')\n                    {\n                        for(auto j:blues[x.second])\n                        {\n                            visit.push({'b',j});\n                            auto itr1=blues[x.second].find(j);\n                            blues[x.second].erase(itr1);\n                        }\n                    }\n                }\n                if(justbreak)\n                {\n                    break;\n                }\n                steps++;\n            }\n        }\n        return ans;\n    }\n};\n"
    },
    {
        "slug": "implement-stack-using-queues",
        "description": "Implement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal stack (push, top, pop, and empty).\nImplement the MyStack class:\n\nvoid push(int x) Pushes element x to the top of the stack.\nint pop() Removes the element on the top of the stack and returns it.\nint top() Returns the element on the top of the stack.\nboolean empty() Returns true if the stack is empty, false otherwise.\n\nNotes:\n\nYou must use only standard operations of a queue, which means that only push to back, peek/pop from front, size and is empty operations are valid.\nDepending on your language, the queue may not be supported natively. You may simulate a queue using a list or deque (double-ended queue) as long as you use only a queue's standard operations.",
        "examples": [
            "Input\n[\"MyStack\", \"push\", \"push\", \"top\", \"pop\", \"empty\"]\n[[], [1], [2], [], [], []]\nOutput\n[null, null, null, 2, 2, false]\n\nExplanation\nMyStack myStack = new MyStack();\nmyStack.push(1);\nmyStack.push(2);\nmyStack.top(); // return 2\nmyStack.pop(); // return 2\nmyStack.empty(); // return False"
        ],
        "constraints": "1 <= x <= 9\nAt most 100 calls will be made to push, pop, top, and empty.\nAll the calls to pop and top are valid.\n\n\u00a0\nFollow-up: Can you implement the stack using only one queue?",
        "oracle_code": "class MyStack {\npublic:\n queue<int> q;\n    MyStack() {\n\n    }\n    \n    void push(int x) {\n        q.push(x);\n        for(int i=0; i<q.size()-1; i++){\n            q.push(q.front());\n            q.pop();\n        }\n    }\n    \n    int pop() {\n       int a= q.front();\n       q.pop();\n       return a;\n           }\n    \n    int top() {\n      return q.front();\n    }\n    \n    bool empty() {\n        return q.empty();\n    }\n};",
        "content": "\\n# Code\\n```\\nclass MyStack {\\npublic:\\n queue<int> q;\\n    MyStack() {\\n\\n    }\\n    \\n    void push(int x) {\\n        q.push(x);\\n        for(int i=0; i<q.size()-1; i++){\\n            q.push(q.front());\\n            q.pop();\\n        }\\n    }\\n    \\n    int pop() {\\n       int a= q.front();\\n       q.pop();\\n       return a;\\n           }\\n    \\n    int top() {\\n      return q.front();\\n    }\\n    \\n    bool empty() {\\n        return q.empty();\\n    }\\n};\\n\\n```",
        "level": "easy",
        "type": [
            "undefined keywords from other languages",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass MyStack {\npublic:\n queue<int> q;\n    MyStack() {\n\n    }\n    \n    void add(int x) {  \n        q.push(x);\n        for(int i=0; i<q.size()-1; i++){\n            q.push(q.front());\n            q.pop();\n        }\n    }\n    \n    int pop() {\n       int a=  q.front();\n       q.pop());\n       return a;\n           }\n    \n    int top() {\n      return q.front();\n    }\n    \n    bool empty() {\n        return q.empty();\n    }\n};\n"
    },
    {
        "slug": "find-the-winner-of-the-circular-game",
        "description": "There are n friends that are playing a game. The friends are sitting in a circle and are numbered from 1 to n in clockwise order. More formally, moving clockwise from the ith friend brings you to the (i+1)th friend for 1 <= i < n, and moving clockwise from the nth friend brings you to the 1st friend.\nThe rules of the game are as follows:\n\nStart at the 1st friend.\nCount the next k friends in the clockwise direction including the friend you started at. The counting wraps around the circle and may count some friends more than once.\nThe last friend you counted leaves the circle and loses the game.\nIf there is still more than one friend in the circle, go back to step 2 starting from the friend immediately clockwise of the friend who just lost and repeat.\nElse, the last friend in the circle wins the game.\n\nGiven the number of friends, n, and an integer k, return the winner of the game.",
        "examples": [
            "Input: n = 5, k = 2\nOutput: 3\nExplanation: Here are the steps of the game:\n1) Start at friend 1.\n2) Count 2 friends clockwise, which are friends 1 and 2.\n3) Friend 2 leaves the circle. Next start is friend 3.\n4) Count 2 friends clockwise, which are friends 3 and 4.\n5) Friend 4 leaves the circle. Next start is friend 5.\n6) Count 2 friends clockwise, which are friends 5 and 1.\n7) Friend 1 leaves the circle. Next start is friend 3.\n8) Count 2 friends clockwise, which are friends 3 and 5.\n9) Friend 5 leaves the circle. Only friend 3 is left, so they are the winner.",
            "Input: n = 6, k = 5\nOutput: 1\nExplanation: The friends leave in this order: 5, 4, 6, 2, 3. The winner is friend 1."
        ],
        "constraints": "1 <= k <= n <= 500",
        "oracle_code": "class Solution {\npublic:\n    int findTheWinner(int n, int k) {\n        queue<int> q;\n        for(int i=1;i<=n;i++){\n            q.push(i);\n        }\n        // 1 2 3 4 5 \n        while(q.size() != 1){\n            int i = 1;\n            while(i < k){\n                int f = q.front();\n                q.pop();\n                q.push(f);\n                i++;\n            }\n            q.pop();\n        }\n\n        return q.front();\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        queue<int> q;\\n        for(int i=1;i<=n;i++){\\n            q.push(i);\\n        }\\n        // 1 2 3 4 5 \\n        while(q.size() != 1){\\n            int i = 1;\\n            while(i < k){\\n                int f = q.front();\\n                q.pop();\\n                q.push(f);\\n                i++;\\n            }\\n            q.pop();\\n        }\\n\\n        return q.front();\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "colon missing",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    int findTheWinner(int n, int k) {\n        queue<int> q;\n        for(int i=1;i<=n;i++){\n            q.push(i;\n        }\n        // 1 2 3 4 5 \n        while(q.size() != 1){\n            int i = 1;\n            while(i k){\n                int f = q.front();\n                q.pop();\n                q.push(f);\n                i++;\n            }\n            q.pop();\n        }\n\n        return q.front();\n    }\n};\n"
    },
    {
        "slug": "plus-one",
        "description": "You are given a large integer represented as an integer array digits, where each digits[i] is the ith digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading 0's.\nIncrement the large integer by one and return the resulting array of digits.",
        "examples": [
            "Input: digits = [1,2,3]\nOutput: [1,2,4]\nExplanation: The array represents the integer 123.\nIncrementing by one gives 123 + 1 = 124.\nThus, the result should be [1,2,4].",
            "Input: digits = [4,3,2,1]\nOutput: [4,3,2,2]\nExplanation: The array represents the integer 4321.\nIncrementing by one gives 4321 + 1 = 4322.\nThus, the result should be [4,3,2,2].",
            "Input: digits = [9]\nOutput: [1,0]\nExplanation: The array represents the integer 9.\nIncrementing by one gives 9 + 1 = 10.\nThus, the result should be [1,0]."
        ],
        "constraints": "1 <= digits.length <= 100\n0 <= digits[i] <= 9\ndigits does not contain any leading 0's.",
        "oracle_code": "class Solution {\npublic:\n    vector<int> plusOne(vector<int>& digits) {\n        int n=digits.size();\n        digits[n-1]++;\n        for(int i=n-1;i>=1;i--)\n        {\n            if(digits[i]>9)\n            {\n                digits[i]%=10;\n                digits[i-1]++;\n            }\n        }\n        if(digits[0]>9)\n        {\n            digits.insert(digits.begin(),1);\n            digits[1]%=10;\n        }\n        return digits;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nsimple iterative approach.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIterated all index from the end , then manually checked for 0th index and did the needful.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n=digits.size();\\n        digits[n-1]++;\\n        for(int i=n-1;i>=1;i--)\\n        {\\n            if(digits[i]>9)\\n            {\\n                digits[i]%=10;\\n                digits[i-1]++;\\n            }\\n        }\\n        if(digits[0]>9)\\n        {\\n            digits.insert(digits.begin(),1);\\n            digits[1]%=10;\\n        }\\n        return digits;\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "operation error",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    vector<int> plusOne(vector<int>& digits) {\n        int n=digits.size();\n        digits[n]++;\n        for(int i=n-1;i>=1;i--)\n        {\n            if(digits[i]>9)\n            {\n                digits[i]%=10;\n                digits[i-1]++;\n            }\n        }\n        if(digits[0]>9)\n        {\n            digits.insert(digits.begin(),1);\n            digits[1]%=10;\n        }\n        return printNumbers(digits);\n    }\n};\n"
    },
    {
        "slug": "lru-cache",
        "description": "Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.\nImplement the LRUCache class:\n\nLRUCache(int capacity) Initialize the LRU cache with positive size capacity.\nint get(int key) Return the value of the key if the key exists, otherwise return -1.\nvoid put(int key, int value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key.\n\nThe functions get and put must each run in O(1) average time complexity.",
        "examples": [
            "Input\n[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"]\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\nOutput\n[null, null, null, 1, null, -1, null, -1, 3, 4]\n\nExplanation\nLRUCache lRUCache = new LRUCache(2);\nlRUCache.put(1, 1); // cache is {1=1}\nlRUCache.put(2, 2); // cache is {1=1, 2=2}\nlRUCache.get(1);    // return 1\nlRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}\nlRUCache.get(2);    // returns -1 (not found)\nlRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}\nlRUCache.get(1);    // return -1 (not found)\nlRUCache.get(3);    // return 3\nlRUCache.get(4);    // return 4"
        ],
        "constraints": "1 <= capacity <= 3000\n0 <= key <= 104\n0 <= value <= 105\nAt most 2 * 105 calls will be made to get and put.",
        "oracle_code": "class LRUCache {\npublic:\nclass node\n{\n  public:\n  int key;\n  int val;\n  node* next;\n  node* prev;\n  node(int _key,int _val)\n  {\n    key = _key;\n    val = _val;\n  }\n};\nnode* head = new node(-1,-1);\nnode* tail = new node(-1,-1);\n\nint size;\nunordered_map<int,node*>mpp;\n    LRUCache(int capacity) {\n       size = capacity; \n       head->next = tail;\n       tail->prev = head;  \n    }\n\n    void addNode(node* newNode){\n       \n       node* temp = head->next;\n       newNode->next = temp;\n       newNode->prev = head;\n       head->next = newNode;\n       temp->prev = newNode;\n    }\n\n    void deleteNode(node* delNode){\n         \n       node* delprev = delNode->prev;\n       node* delnext = delNode->next;\n       delprev->next = delnext;\n       delnext->prev = delprev;\n    }\n    \n    int get(int _key) {\n        \n        if(mpp.count(_key))\n        {\n          node* nde = mpp[_key];\n          int curr = nde->val;\n          mpp.erase(_key);\n          deleteNode(nde);\n          addNode(nde);\n          mpp[_key] = head->next;\n          return curr;\n        }\n        return -1;\n    }\n    \n    void put(int _key, int value) {\n        \n        if(mpp.count(_key))\n        {\n           node* nde = mpp[_key];\n           mpp.erase(_key);\n           deleteNode(nde);\n        }\n        if(mpp.size()==size)\n        {\n           mpp.erase(tail->prev->key);\n           deleteNode(tail->prev);\n        }\n        addNode(new node(_key,value));\n        mpp[_key] = head->next;\n    }\n};",
        "content": "# PLEASE DO UPVOTE!!!!!\\n\\n**CONNECT WITH ME ON LINKEDIN :  https://www.linkedin.com/in/md-kamran-55b98521a/**\\n\\n## INTUITION\\nTo Implement LRU(Least recently used), we need to have a track of the usage of the keys, in the order of there usage, as we have a limited capacity we cant extend our capacity beyond \"capacity\", so we always we will take out those values which has\\'nt been acccess in the recent time.So, we have to think of something that can kind of sort our keys according to usage on the go, the best Data Structure for this purpose is Doubly linked List.\\n                             A Doubly linked list will have a Head node as well as a tail node, and whenever a key is used we will place it just next to the head node,in this fashions, the one\\'s which are closer to head are the most recently used ones, and as we go closer to the tail node, those are the less recently used ones while the node just previous to tail is the \"LEAST RECENTLY USED\". \\nSo whenever we add a key or use a key(get()), we will move it right after the head node, and whenever we call the (put() function), if size if greater we have to delete the LRU node, if key is not present, (if present then too we will delete that node so as to update the value and still move it right after head node), and place new node right after head node.                        \\n\\n\\n**Ask Furthur Doubts in the Comment Section**\\n# Code\\n```\\nclass LRUCache {\\npublic:\\nclass node\\n{\\n  public:\\n  int key;\\n  int val;\\n  node* next;\\n  node* prev;\\n  node(int _key,int _val)\\n  {\\n    key = _key;\\n    val = _val;\\n  }\\n};\\nnode* head = new node(-1,-1);\\nnode* tail = new node(-1,-1);\\n\\nint size;\\nunordered_map<int,node*>mpp;\\n    LRUCache(int capacity) {\\n       size = capacity; \\n       head->next = tail;\\n       tail->prev = head;  \\n    }\\n\\n    void addNode(node* newNode){\\n       \\n       node* temp = head->next;\\n       newNode->next = temp;\\n       newNode->prev = head;\\n       head->next = newNode;\\n       temp->prev = newNode;\\n    }\\n\\n    void deleteNode(node* delNode){\\n         \\n       node* delprev = delNode->prev;\\n       node* delnext = delNode->next;\\n       delprev->next = delnext;\\n       delnext->prev = delprev;\\n    }\\n    \\n    int get(int _key) {\\n        \\n        if(mpp.count(_key))\\n        {\\n          node* nde = mpp[_key];\\n          int curr = nde->val;\\n          mpp.erase(_key);\\n          deleteNode(nde);\\n          addNode(nde);\\n          mpp[_key] = head->next;\\n          return curr;\\n        }\\n        return -1;\\n    }\\n    \\n    void put(int _key, int value) {\\n        \\n        if(mpp.count(_key))\\n        {\\n           node* nde = mpp[_key];\\n           mpp.erase(_key);\\n           deleteNode(nde);\\n        }\\n        if(mpp.size()==size)\\n        {\\n           mpp.erase(tail->prev->key);\\n           deleteNode(tail->prev);\\n        }\\n        addNode(new node(_key,value));\\n        mpp[_key] = head->next;\\n    }\\n};\\n\\n```\\n![b62ab1be-232a-438f-9524-7d8ca4dbd5fe_1675328166.1161866.png](https://assets.leetcode.com/users/images/8d5343b1-0eb4-4111-a914-40ce968fd034_1675389764.2273676.png)",
        "level": "medium",
        "type": [
            "wrong comment mark",
            "undefined objects"
        ],
        "buggy_code": "\nclass LRUCache {\npublic:\nclass node\n{\n  public:\n  int key;\n  int val;\n  node* next;\n  node* prev;\n  node(int _key,int _val)\n  {\n    key = _key;\n    val = _val;\n  }\n};\nnode* head = nullptr;\nnode* tail = nullptr;\n\nint size;\nunordered_map<int,node*>mpp;\n    LRUCache(int capacity) {\n       size = capacity; \n       head->next = tail;\n       tail->prev = head;  \n    }\n\n    void addNode(node* newNode){\n       \n       node* temp = head->next;\n       newNode->next = temp;\n       newNode->prev = head;\n       head->next = newNode;\n       temp->prev = newNode;\n    }\n\n    /*void deleteNode(node* delNode){\n         \n       node* delprev = delNode->prev;\n       node* delnext = delNode->next;\n       delprev->next = delnext;\n       delnext->prev = delprev;\n    }*/\n    \n    int get(int _key) {\n        \n        if(mpp.count(_key))\n        {\n          node* nde = mpp[_key];\n          int curr = nde->val;\n          mpp.erase(_key);\n          deleteNode(nde);\n          addNode(nde);\n          mpp[_key] = head->next;\n          return curr;\n        }\n        return -1;\n    }\n    \n    void put(int _key, int value) {\n        \n        if(mpp.count(_key))\n        {\n           node* nde = mpp[_key];\n           mpp.erase(_key);\n           deleteNode(nde);\n        }\n        if(mpp.size()==size)\n        {\n           mpp.erase(tail->prev->key);\n           deleteNode(tail->prev);\n        }\n        addNode(new node(_key,value));\n        mpp[_key] = head->next;\n    }\n};\n"
    },
    {
        "slug": "longest-common-prefix",
        "description": "Write a function to find the longest common prefix string amongst an array of strings.\nIf there is no common prefix, return an empty string \"\".",
        "examples": [
            "Input: strs = [\"flower\",\"flow\",\"flight\"]\nOutput: \"fl\"",
            "Input: strs = [\"dog\",\"racecar\",\"car\"]\nOutput: \"\"\nExplanation: There is no common prefix among the input strings."
        ],
        "constraints": "1 <= strs.length <= 200\n0 <= strs[i].length <= 200\nstrs[i] consists of only lowercase English letters.",
        "oracle_code": "class Solution {\npublic:\n    string longestCommonPrefix(vector<string>& str) \n    {\n        sort(str.begin(), str.end()); //sorting the array\n        string ans=\"\"; //creating a new empty string to store the common prefixes\n        for(int i=0;i<str[0].length();i++) // max iterations = length of the first string\n        {\n            if(str[0][i]!=str[str.size()-1][i]) // checking the characters of the first and last string\n                break;\n            ans+=str[0][i]; // concatinate if the characters are matching\n        }\n        return ans;\n    }\n};",
        "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWhen you sort an array, it is enough to check for the common characters of the the first & last string of the sorted vector.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& str) \\n    {\\n        sort(str.begin(), str.end()); //sorting the array\\n        string ans=\"\"; //creating a new empty string to store the common prefixes\\n        for(int i=0;i<str[0].length();i++) // max iterations = length of the first string\\n        {\\n            if(str[0][i]!=str[str.size()-1][i]) // checking the characters of the first and last string\\n                break;\\n            ans+=str[0][i]; // concatinate if the characters are matching\\n        }\\n        return ans;\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "statement separation",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    string longestCommonPrefix(vector<string>& str) \n    {\n        sort(str.begin(), str.end()); //sorting the array\n        string ans=\"\"; //creating a new empty string to store the common prefixes\n        for(int i=0;i<=str[0].length();i++) \n            if(str[0][i]!=str[str.size()-1][i]) // checking the characters of the first and last string\n                break;\n        ans+=str[0][i]; \n        return ans;\n    }\n};\n"
    },
    {
        "slug": "prime-arrangements",
        "description": "Return the number of permutations of 1 to n so that prime numbers are at prime indices (1-indexed.)\n(Recall that an integer\u00a0is prime if and only if it is greater than 1, and cannot be written as a product of two positive integers\u00a0both smaller than it.)\nSince the answer may be large, return the answer modulo 10^9 + 7.",
        "examples": [
            "Input: n = 5\nOutput: 12\nExplanation: For example [1,2,5,4,3] is a valid permutation, but [5,2,3,4,1] is not because the prime number 5 is at index 1.",
            "Input: n = 100\nOutput: 682289015"
        ],
        "constraints": "1 <= n <= 100",
        "oracle_code": "class Solution {\npublic:\n    long long fact(int n)\n    {\n        if(n<=1)return 1;\n        return (n*fact(n-1)%1000000007)%1000000007;\n    }\n    int numPrimeArrangements(int n) {\n        if(n==1)return 1;\n        if(n<=3)return n-1;\n        int t=0,flag;\n        for(int i=2;i<=n;i++)\n        {\n            flag=0;\n            for(int j=2;j<=sqrt(i);j++)\n            {\n                if(i%j==0)\n                {\n                    flag=1;\n                    break;\n                }\n            }\n            if(flag==0)\n            {\n                t++;\n            }\n        }\n        return (fact(t)*fact(n-t))%1000000007;\n\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long fact(int n)\\n    {\\n        if(n<=1)return 1;\\n        return (n*fact(n-1)%1000000007)%1000000007;\\n    }\\n    int numPrimeArrangements(int n) {\\n        if(n==1)return 1;\\n        if(n<=3)return n-1;\\n        int t=0,flag;\\n        for(int i=2;i<=n;i++)\\n        {\\n            flag=0;\\n            for(int j=2;j<=sqrt(i);j++)\\n            {\\n                if(i%j==0)\\n                {\\n                    flag=1;\\n                    break;\\n                }\\n            }\\n            if(flag==0)\\n            {\\n                t++;\\n            }\\n        }\\n        return (fact(t)*fact(n-t))%1000000007;\\n\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "other error",
            "colon missing"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    long long fact(int n)\n    {\n        if(n<=1)return 1;\n        return (n*fact(n+1)%1000000007)%1000000007; \n    }\n    int numPrimeArrangements(int n) {\n        if(n==1)return 1;\n        if(n<=3)return n-1;\n        int t=0,flag;\n        for(int i=2;i<=n;i++)\n        {\n            flag=0;\n            for(int j=2;j<sqrt(i);j++)\n            {\n                if(i%j==0)\n                {\n                    flag=1;\n                    break;\n                }\n            }\n            if(flag==0)\n            {\n                t++;\n            }\n        }\n        return (fact(t)*fact(n-t))%1000000007;\n\n    }\n};\n"
    },
    {
        "slug": "widest-vertical-area-between-two-points-containing-no-points",
        "description": "Given n points on a 2D plane where points[i] = [xi, yi], Return\u00a0the widest vertical area between two points such that no points are inside the area.\nA vertical area is an area of fixed-width extending infinitely along the y-axis (i.e., infinite height). The widest vertical area is the one with the maximum width.\nNote that points on the edge of a vertical area are not considered included in the area.",
        "examples": [
            "\u200b\n\nInput: points = [[8,7],[9,9],[7,4],[9,7]]\nOutput: 1\nExplanation: Both the red and the blue area are optimal.",
            "Input: points = [[3,1],[9,0],[1,0],[1,4],[5,3],[8,8]]\nOutput: 3"
        ],
        "constraints": "n == points.length\n2 <= n <= 105\npoints[i].length == 2\n0 <= xi, yi\u00a0<= 109",
        "oracle_code": "class Solution {\npublic:\n  int maxWidthOfVerticalArea(vector<vector<int>>& points) {\n    set<int> x;\n    int res = 0;\n    for (auto &p : points)\n        x.insert(p[0]);\n    for (auto it = next(begin(x)); it != end(x); ++it)\n        res = max(res, *it - *prev(it));\n    return res;\n}\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  int maxWidthOfVerticalArea(vector<vector<int>>& points) {\\n    set<int> x;\\n    int res = 0;\\n    for (auto &p : points)\\n        x.insert(p[0]);\\n    for (auto it = next(begin(x)); it != end(x); ++it)\\n        res = max(res, *it - *prev(it));\\n    return res;\\n}\\n};\\n```",
        "level": "medium",
        "type": [
            "wrong comment mark",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n  int maxWidthOfVerticalArea(vector<vector<int>>& points) /*\n    set<int> x;\n    int res = 0;\n    for (auto &p : points)\n        x.insert(p[0]);\n    for (auto it = next(begin(x)); it != end(x); ++it)\n        res = max(res, *it - *prev(it));\n    return calculateArea();\n}\nprivate:\n    int calculateArea();\n*/;\n"
    },
    {
        "slug": "minimum-total-cost-to-make-arrays-unequal",
        "description": "You are given two 0-indexed integer arrays nums1 and nums2, of equal length n.\nIn one operation, you can swap the values of any two indices of nums1. The cost of this operation is the sum of the indices.\nFind the minimum total cost of performing the given operation any number of times such that nums1[i] != nums2[i] for all 0 <= i <= n - 1 after performing all the operations.\nReturn the minimum total cost such that nums1 and nums2 satisfy the above condition. In case it is not possible, return -1.",
        "examples": [
            "Input: nums1 = [1,2,3,4,5], nums2 = [1,2,3,4,5]\nOutput: 10\nExplanation: \nOne of the ways we can perform the operations is:\n- Swap values at indices 0 and 3, incurring cost = 0 + 3 = 3. Now, nums1 = [4,2,3,1,5]\n- Swap values at indices 1 and 2, incurring cost = 1 + 2 = 3. Now, nums1 = [4,3,2,1,5].\n- Swap values at indices 0 and 4, incurring cost = 0 + 4 = 4. Now, nums1 =[5,3,2,1,4].\nWe can see that for each index i, nums1[i] != nums2[i]. The cost required here is 10.\nNote that there are other ways to swap values, but it can be proven that it is not possible to obtain a cost less than 10.",
            "Input: nums1 = [2,2,2,1,3], nums2 = [1,2,2,3,3]\nOutput: 10\nExplanation: \nOne of the ways we can perform the operations is:\n- Swap values at indices 2 and 3, incurring cost = 2 + 3 = 5. Now, nums1 = [2,2,1,2,3].\n- Swap values at indices 1 and 4, incurring cost = 1 + 4 = 5. Now, nums1 = [2,3,1,2,2].\nThe total cost needed here is 10, which is the minimum possible.",
            "Input: nums1 = [1,2,2], nums2 = [1,2,2]\nOutput: -1\nExplanation: \nIt can be shown that it is not possible to satisfy the given conditions irrespective of the number of operations we perform.\nHence, we return -1."
        ],
        "constraints": "n == nums1.length == nums2.length\n1 <= n <= 105\n1 <= nums1[i], nums2[i] <= n",
        "oracle_code": "class Solution {\npublic:\n    long long minimumTotalCost(vector<int>& nums1, vector<int>& nums2) {\n        long long ans = 0;\n        \n        vector<int> counts(100005, 0);\n        int dominantCnt = 0;\n        int dominantNum = -1;\n        int involvedCnt = 0;\n        int n = nums1.size();\n        for (int i = 0; i < n; ++i) {\n            if (nums1[i] == nums2[i]) {\n                ans += i;\n                counts[nums1[i]]++;\n                if (counts[nums1[i]] > dominantCnt) {\n                    dominantCnt = counts[nums1[i]];\n                    dominantNum = nums1[i];\n                }\n                involvedCnt++;\n            }\n        }\n        if (dominantCnt > involvedCnt / 2) {\n            for (int i = 0; i < n; ++i) {\n                if (nums1[i] != nums2[i] && nums1[i] != dominantNum && nums2[i] != dominantNum) {\n                    counts[nums1[i]]++;\n                    involvedCnt++;\n                    ans += i;\n                    if (dominantCnt <= involvedCnt / 2) {\n                        return ans;\n                    }\n                }\n            }\n            return -1;\n        }\n        else {\n            return ans;\n        }\n    }\n};",
        "content": "# Intuition and Approach\\n1. The cost of swapping numbers at idx1 and idx2 is `idx1 + idx2`\\n2. You only need to swap numbers at i that are identical in nums1[i] and nums2[i].\\n- e.g., `nums1 = [1,2,3,4,5]; nums2 = [2,2,3,5,5]` => extract `[2,3,5]`\\n3. Let\\'s consider two cases\\n- The `count of dominant element <= the count of all extracted elements / 2`. See 4\\n- The `count of dominant element > the count of all extracted elements / 2`. See 6\\n4. You can just sum all idx of them. There must be one permutation that can achieve the criteria: no identical number. For example, `[2,3,5]` can be permutated into `[5,2,3]`, and `[2,2,4,4]` can be permuted into `[4,4,2,2]`. \\n5. You might wonder what is the least cost to make such permutation. Consider you want to swap idx `i` to somewhere `j`, you must cost `i` first and then `j`, and if `j=0` the cost is `i`. So any swap of two numbers can be regarded as a process of swapping `i <-> 0 (of the original array) <-> j`. The total cost would be the sum of all idx. For the proof, please see [l_returns\\'s](https://leetcode.com/problems/minimum-total-cost-to-make-arrays-unequal/solutions/2897969/c-simple-greedy-in-on-with-explanation/comments/1712870) comment.\\n6. If there is case like `[2,2,2,3,3]`, there is no permutation that can achieve the goal. So keep adding other elements from the original array for changing `2`, which is the dominant element in the example. Besides, you should avoid the idx `k` that `nums1[k] == dominant number || nums2[k] == dominant number`.\\n7. If the left numbers are exhausted and you still can not achieve `count of dominant element <= the count of all extract elements / 2`, return -1.\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(The range of the numbers)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumTotalCost(vector<int>& nums1, vector<int>& nums2) {\\n        long long ans = 0;\\n        \\n        vector<int> counts(100005, 0);\\n        int dominantCnt = 0;\\n        int dominantNum = -1;\\n        int involvedCnt = 0;\\n        int n = nums1.size();\\n        for (int i = 0; i < n; ++i) {\\n            if (nums1[i] == nums2[i]) {\\n                ans += i;\\n                counts[nums1[i]]++;\\n                if (counts[nums1[i]] > dominantCnt) {\\n                    dominantCnt = counts[nums1[i]];\\n                    dominantNum = nums1[i];\\n                }\\n                involvedCnt++;\\n            }\\n        }\\n        if (dominantCnt > involvedCnt / 2) {\\n            for (int i = 0; i < n; ++i) {\\n                if (nums1[i] != nums2[i] && nums1[i] != dominantNum && nums2[i] != dominantNum) {\\n                    counts[nums1[i]]++;\\n                    involvedCnt++;\\n                    ans += i;\\n                    if (dominantCnt <= involvedCnt / 2) {\\n                        return ans;\\n                    }\\n                }\\n            }\\n            return -1;\\n        }\\n        else {\\n            return ans;\\n        }\\n    }\\n};\\n```",
        "level": "hard",
        "type": [
            "indexing error",
            "wrong comment mark"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    long long minimumTotalCost(vector<int>& nums1, vector<int>& nums2) {\n        long long ans = 0;\n        \n        vector<int> counts(100005, 0);\n        int dominantCnt = 0;\n        int dominantNum = -1;\n        int involvedCnt = 0;\n        int n = nums1.size();\n        for (int i = 0; i <= n; ++i) /*\n            if (nums1[i] == nums2[i]) {\n                ans += i;\n                counts[nums1[i]]++;\n                if (counts[nums1[i]] > dominantCnt) {\n                    dominantCnt = counts[nums1[i]];\n                    dominantNum = nums1[i];\n                }\n                involvedCnt++;\n            }\n        */\n        if (dominantCnt > involvedCnt / 2) {\n            for (int i = 0; i < n; ++i) {\n                if (nums1[i] != nums2[i] && nums1[i] != dominantNum && nums2[i] != dominantNum) {\n                    counts[nums1[i]]++;\n                    involvedCnt++;\n                    ans += i;\n                    if (dominantCnt <= involvedCnt / 2) {\n                        return ans;\n                    }\n                }\n            }\n            return -1;\n        }\n        else {\n            return ans;\n        }\n    }\n};\n"
    },
    {
        "slug": "valid-anagram",
        "description": "Given two strings s and t, return true if t is an anagram of s, and false otherwise.\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.",
        "examples": [
            "Input: s = \"anagram\", t = \"nagaram\"\nOutput: true",
            "Input: s = \"rat\", t = \"car\"\nOutput: false"
        ],
        "constraints": "1 <= s.length, t.length <= 5 * 104\ns and t consist of lowercase English letters.",
        "oracle_code": "class Solution {\npublic:\n    bool isAnagram(string s, string t) {\n        if(s.length()!=t.length())\n            return false;\n        vector<int> freq(26, 0);\n        for(int i =0; i<s.length(); i++){\n            freq[s[i]-'a']++;\n            freq[t[i]-'a']--;\n        }\n        for(int i =0; i<freq.size(); i++){\n            if(freq[i]!=0)\n                return false;\n        }\n        return true;\n    }\n};",
        "content": "# Intuition\\nTo solve this problem we will count occurence of each character in both strings and if they are same then both strings are anagram of each other.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nWe can use vector of length 26 to track the occurences of character. \\nIf the size of both string is different then they can\\'t be anagram of each other, so we are checking this first.We loop through each character in both strings and increment the frequency of the corresponding letter in s and decrement the frequency of the corresponding letter in t.\\nThen we loop through freq array if all the elements are 0, if all the elements are 0 this means the two strings are anagram and if not then these things are not anagram of each othe.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n), n is the size of s or t string.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isAnagram(string s, string t) {\\n        if(s.length()!=t.length())\\n            return false;\\n        vector<int> freq(26, 0);\\n        for(int i =0; i<s.length(); i++){\\n            freq[s[i]-\\'a\\']++;\\n            freq[t[i]-\\'a\\']--;\\n        }\\n        for(int i =0; i<freq.size(); i++){\\n            if(freq[i]!=0)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "indexing error",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    bool isAnagram(string s, string t) {\n        if(s.length()!=t.length())\n            return false;\n        vector<int> freq(26, 0);\n        for(int i =0; i<=s.length(); i++){\n            freq[s[i]-'a']++;\n            freq[t[i]-'a']--;\n        }\n        for(int i =0; i<freq.size(); i++){\n            if(freq[i]!=0)\n                return 'false;\n        }\n        return true;\n    }\n};\n"
    },
    {
        "slug": "sort-an-array",
        "description": "Given an array of integers nums, sort the array in ascending order and return it.\nYou must solve the problem without using any built-in functions in O(nlog(n)) time complexity and with the smallest space complexity possible.",
        "examples": [
            "Input: nums = [5,2,3,1]\nOutput: [1,2,3,5]\nExplanation: After sorting the array, the positions of some numbers are not changed (for example, 2 and 3), while the positions of other numbers are changed (for example, 1 and 5).",
            "Input: nums = [5,1,1,2,0,0]\nOutput: [0,0,1,1,2,5]\nExplanation: Note that the values of nums are not necessairly unique."
        ],
        "constraints": "1 <= nums.length <= 5 * 104\n-5 * 104 <= nums[i] <= 5 * 104",
        "oracle_code": "class Solution {\npublic:\n    void merge(int low, int mid, int high, vector<int> &nums) {\n        if (low >= high) \n        return;\n        int l = low, r = mid + 1, k = 0, size = high - low + 1;\n        vector<int> sorted(size, 0);\n        while (l <= mid and r <= high)\n            sorted[k++] = nums[l] < nums[r] ? nums[l++] : nums[r++];\n        while (l <= mid) \n            sorted[k++] = nums[l++];\n        while (r <= high) \n            sorted[k++] = nums[r++];\n        for (k = 0; k < size; k++)\n            nums[k + low] = sorted[k];\n    }\n\n    void mergeSort(vector<int>& nums, int start, int end){\n        if(start < end){\n            int mid = start + (end - start) / 2;\n            mergeSort(nums, start, mid);\n            mergeSort(nums, mid + 1, end);\n            merge(start, mid, end, nums);\n        }\n    }\n\n    vector<int> sortArray(vector<int>& nums) {\n        mergeSort(nums, 0, nums.size()-1);\n        return nums;\n    }\n};",
        "content": "# Approach\\nThis is an implementation of the merge sort algorithm in C++. The merge sort algorithm uses a divide-and-conquer approach to sort a given array by recursively dividing the input array into two halves, sorting them separately, and then merging them back together in the correct order.\\n\\nThe merge function takes in four parameters: low, mid, high, and nums. low and high represent the indices of the start and end of the subarray that needs to be merged, respectively. mid represents the index of the middle element of the subarray. nums is a reference to the vector of integers that needs to be sorted.\\n\\nIn the merge function, a new vector sorted of size high - low + 1 is created to store the sorted subarray. The two halves of the subarray are then compared and merged into sorted using a while loop. Finally, the sorted subarray is copied back into the original array nums using a for loop.\\n\\nThe mergeSort function takes in three parameters: nums, start, and end. nums is a reference to the vector of integers that needs to be sorted. start and end represent the indices of the start and end of the subarray that needs to be sorted, respectively. In the mergeSort function, the input subarray is recursively divided into two halves using mid, and each half is sorted using the mergeSort function. The merge function is then called to merge the two sorted halves back together in the correct order.\\n\\nFinally, the sortArray function takes in a reference to the vector of integers that needs to be sorted and calls the mergeSort function to sort the entire array. It then returns the sorted array.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void merge(int low, int mid, int high, vector<int> &nums) {\\n        if (low >= high) \\n        return;\\n        int l = low, r = mid + 1, k = 0, size = high - low + 1;\\n        vector<int> sorted(size, 0);\\n        while (l <= mid and r <= high)\\n            sorted[k++] = nums[l] < nums[r] ? nums[l++] : nums[r++];\\n        while (l <= mid) \\n            sorted[k++] = nums[l++];\\n        while (r <= high) \\n            sorted[k++] = nums[r++];\\n        for (k = 0; k < size; k++)\\n            nums[k + low] = sorted[k];\\n    }\\n\\n    void mergeSort(vector<int>& nums, int start, int end){\\n        if(start < end){\\n            int mid = start + (end - start) / 2;\\n            mergeSort(nums, start, mid);\\n            mergeSort(nums, mid + 1, end);\\n            merge(start, mid, end, nums);\\n        }\\n    }\\n\\n    vector<int> sortArray(vector<int>& nums) {\\n        mergeSort(nums, 0, nums.size()-1);\\n        return nums;\\n    }\\n};",
        "level": "medium",
        "type": [
            "conditional statement error",
            "colon missing"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    void merge(int low, int mid, int high, vector<int> &nums) {\n        if (low >= high) \n        return;\n        int l = low, r = mid + 1, k = 0, size = high - low + 1;\n        vector<int> sorted(size, 0);\n        while (l <= mid and r <= high)\n            sorted[k++] = nums[l] < nums[r] ? nums[l++] nums[r++];\n        while (l <= mid) \n            sorted[k++] = nums[l++];\n        while (r <= high) \n            sorted[k++] = nums[r++];\n        for (k = 0; k < size; k++)\n            nums[k + low] = sorted[k];\n    }\n\n    void mergeSort(vector<int>& nums, int start, int end){\n        if(start < end){\n            int mid = start + (end - start) / 2;\n            mergeSort(nums, start, mid+1); \n            mergeSort(nums, mid + 1, end);\n            merge(start, mid, end, nums);\n        }\n    }\n\n    vector<int> sortArray(vector<int>& nums) {\n        mergeSort(nums, 0, nums.size()-1);\n        return nums;\n    }\n};\n"
    },
    {
        "slug": "closest-subsequence-sum",
        "description": "You are given an integer array nums and an integer goal.\nYou want to choose a subsequence of nums such that the sum of its elements is the closest possible to goal. That is, if the sum of the subsequence's elements is sum, then you want to minimize the absolute difference abs(sum - goal).\nReturn the minimum possible value of abs(sum - goal).\nNote that a subsequence of an array is an array formed by removing some elements (possibly all or none) of the original array.",
        "examples": [
            "Input: nums = [5,-7,3,5], goal = 6\nOutput: 0\nExplanation: Choose the whole array as a subsequence, with a sum of 6.\nThis is equal to the goal, so the absolute difference is 0.",
            "Input: nums = [7,-9,15,-2], goal = -5\nOutput: 1\nExplanation: Choose the subsequence [7,-9,-2], with a sum of -4.\nThe absolute difference is abs(-4 - (-5)) = abs(1) = 1, which is the minimum.",
            "Input: nums = [1,2,3], goal = -7\nOutput: 7"
        ],
        "constraints": "1 <= nums.length <= 40\n-107 <= nums[i] <= 107\n-109 <= goal <= 109",
        "oracle_code": "class Solution {\npublic:\n    void find(vector<int>&v, int i, int e, int sum, vector<int>&sumv){\n        if(i==e){\n            sumv.push_back(sum);\n            return;\n        }\n        find(v,i+1,e,sum+v[i],sumv);\n        find(v,i+1,e,sum,sumv);\n    }\n        \n    \n    int minAbsDifference(vector<int>& nums, int goal) {\n        int n=nums.size();\n        \n        //Step 1: Divide nums into 2 subarrays of size n/2 and n-n/2\n        \n        vector<int>A,B;\n        for(int i=0;i<n/2;i++)\n            A.push_back(nums[i]);\n        for(int i=n/2;i<n;i++)\n            B.push_back(nums[i]);\n        \n        //Step 2: Find all possible subset sums of A and B\n        \n        vector<int>sumA,sumB;\n        find(A,0,A.size(),0,sumA);\n        find(B,0,B.size(),0,sumB);\n        \n        sort(sumA.begin(),sumA.end());\n        sort(sumB.begin(),sumB.end());\n        \n        //Step 3: Find combinations from sumA & sumB such that abs(sum-goal) is minimized\n        \n        int ans=INT_MAX;\n        \n        for(int i=0;i<sumA.size();i++){\n            int s=sumA[i];\n            int l=0;\n            int r=sumB.size()-1;\n            while(l<=r){\n                int mid=l+(r-l)/2;\n                int sum=s+sumB[mid];\n                if(sum==goal)\n                    return 0;\n                ans=min(ans,abs(sum-goal));\n                if(sum>goal){\n                    r=mid-1;\n                }\n                else{\n                    l=mid+1;\n                }    \n            }\n        }\n        \n        return ans;\n    }\n};",
        "content": "```\\nclass Solution {\\npublic:\\n    void find(vector<int>&v, int i, int e, int sum, vector<int>&sumv){\\n        if(i==e){\\n            sumv.push_back(sum);\\n            return;\\n        }\\n        find(v,i+1,e,sum+v[i],sumv);\\n        find(v,i+1,e,sum,sumv);\\n    }\\n        \\n    \\n    int minAbsDifference(vector<int>& nums, int goal) {\\n        int n=nums.size();\\n        \\n        //Step 1: Divide nums into 2 subarrays of size n/2 and n-n/2\\n        \\n        vector<int>A,B;\\n        for(int i=0;i<n/2;i++)\\n            A.push_back(nums[i]);\\n        for(int i=n/2;i<n;i++)\\n            B.push_back(nums[i]);\\n        \\n        //Step 2: Find all possible subset sums of A and B\\n        \\n        vector<int>sumA,sumB;\\n        find(A,0,A.size(),0,sumA);\\n        find(B,0,B.size(),0,sumB);\\n        \\n        sort(sumA.begin(),sumA.end());\\n        sort(sumB.begin(),sumB.end());\\n        \\n        //Step 3: Find combinations from sumA & sumB such that abs(sum-goal) is minimized\\n        \\n        int ans=INT_MAX;\\n        \\n        for(int i=0;i<sumA.size();i++){\\n            int s=sumA[i];\\n            int l=0;\\n            int r=sumB.size()-1;\\n            while(l<=r){\\n                int mid=l+(r-l)/2;\\n                int sum=s+sumB[mid];\\n                if(sum==goal)\\n                    return 0;\\n                ans=min(ans,abs(sum-goal));\\n                if(sum>goal){\\n                    r=mid-1;\\n                }\\n                else{\\n                    l=mid+1;\\n                }    \\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n**Do upvote if you find it useful!**",
        "level": "hard",
        "type": [
            "wrong comment mark",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    void find(vector<int>&v, int i, int e, int sum, vector<int>&sumv){\n        if(i==e){\n            sumv.push_back(sum);\n            return;\n        }\n     \n        find(v,i+1,e,sum,sumv);\n    }\n        \n    \n    int minAbsDifference(vector<int>& nums, int goal) {\n        int n=nums.length();\n        \n        //Step 1: Divide nums into 2 subarrays of size n/2 and n-n/2\n        \n        vector<int>A,B;\n        for(int i=0;i<n/2;i++)\n            A.push_back(nums[i]);\n        for(int i=n/2;i<n;i++)\n            B.push_back(nums[i]);\n        \n        //Step 2: Find all possible subset sums of A and B\n        \n        vector<int>sumA,sumB;\n        find(A,0,A.size(),0,sumA);\n        find(B,0,B.size(),0,sumB);\n        \n        sort(sumA.begin(),sumA.end());\n        sort(sumB.begin(),sumB.end());\n        \n        //Step 3: Find combinations from sumA & sumB such that abs(sum-goal) is minimized\n        \n        int ans=INT_MAX;\n        \n        for(int i=0;i<sumA.size();i++){\n            int s=sumA[i];\n            int l=0;\n            int r=sumB.size()-1;\n            while(l<=r){\n                int mid=l+(r-l)/2;\n                int sum=s+sumB[mid];\n                if(sum==goal)\n                    return 0;\n                ans=min(ans,abs(sum-goal));\n                if(sum>goal){\n                    r=mid-1;\n                }\n                else{\n                    l=mid+1;\n                }    \n            }\n        }\n        \n        return ans;\n    }\n};\n"
    },
    {
        "slug": "kth-ancestor-of-a-tree-node",
        "description": "You are given a tree with n nodes numbered from 0 to n - 1 in the form of a parent array parent where parent[i] is the parent of ith node. The root of the tree is node 0. Find the kth ancestor of a given node.\nThe kth ancestor of a tree node is the kth node in the path from that node to the root node.\nImplement the TreeAncestor class:\n\nTreeAncestor(int n, int[] parent) Initializes the object with the number of nodes in the tree and the parent array.\nint getKthAncestor(int node, int k) return the kth ancestor of the given node node. If there is no such ancestor, return -1.",
        "examples": [
            "Input\n[\"TreeAncestor\", \"getKthAncestor\", \"getKthAncestor\", \"getKthAncestor\"]\n[[7, [-1, 0, 0, 1, 1, 2, 2]], [3, 1], [5, 2], [6, 3]]\nOutput\n[null, 1, 0, -1]\n\nExplanation\nTreeAncestor treeAncestor = new TreeAncestor(7, [-1, 0, 0, 1, 1, 2, 2]);\ntreeAncestor.getKthAncestor(3, 1); // returns 1 which is the parent of 3\ntreeAncestor.getKthAncestor(5, 2); // returns 0 which is the grandparent of 5\ntreeAncestor.getKthAncestor(6, 3); // returns -1 because there is no such ancestor"
        ],
        "constraints": "1 <= k <= n <= 5 * 104\nparent.length == n\nparent[0] == -1\n0 <= parent[i] < n for all 0 < i < n\n0 <= node < n\nThere will be at most 5 * 104 queries.",
        "oracle_code": "class TreeAncestor {\npublic:\n    vector<vector<int>>v;\n    TreeAncestor(int n, vector<int>& parent) {\n        vector<vector<int>> par(n, vector<int>(20));\n        for (int i = 0; i < n; i++) par[i][0] = parent[i];\n        for (int j = 1; j < 20; j++) {\n            for (int i = 0; i < n; i++) {\n                if (par[i][j - 1] == -1) par[i][j] = -1;\n                else par[i][j] = par[par[i][j - 1]][j - 1];\n            }\n        }\n        swap(v, par);\n    }\n    int getKthAncestor(int node, int k) {\n        for (int i = 0; i < 20; i++) {\n            if ((k >> i) & 1) {\n                node = v[node][i];\n                if (node == -1) return -1;\n            }\n        }\n        return node;\n    }\n};\n\n/**\n * Your TreeAncestor object will be instantiated and called as such:\n * TreeAncestor* obj = new TreeAncestor(n, parent);\n * int param_1 = obj->getKthAncestor(node,k);\n */",
        "content": "\\n\\n# Code\\n```\\nclass TreeAncestor {\\npublic:\\n    vector<vector<int>>v;\\n    TreeAncestor(int n, vector<int>& parent) {\\n        vector<vector<int>> par(n, vector<int>(20));\\n        for (int i = 0; i < n; i++) par[i][0] = parent[i];\\n        for (int j = 1; j < 20; j++) {\\n            for (int i = 0; i < n; i++) {\\n                if (par[i][j - 1] == -1) par[i][j] = -1;\\n                else par[i][j] = par[par[i][j - 1]][j - 1];\\n            }\\n        }\\n        swap(v, par);\\n    }\\n    int getKthAncestor(int node, int k) {\\n        for (int i = 0; i < 20; i++) {\\n            if ((k >> i) & 1) {\\n                node = v[node][i];\\n                if (node == -1) return -1;\\n            }\\n        }\\n        return node;\\n    }\\n};\\n\\n/**\\n * Your TreeAncestor object will be instantiated and called as such:\\n * TreeAncestor* obj = new TreeAncestor(n, parent);\\n * int param_1 = obj->getKthAncestor(node,k);\\n */\\n```",
        "level": "hard",
        "type": [
            "statement separation",
            "undefined objects"
        ],
        "buggy_code": "\nclass TreeAncestor {\npublic:\n    vector<vector<int>>v;\n    TreeAncestor(int n, vector<int>& parent) {\n        vector<vector<int>> par(n, vector<int>(20));\n        for (int i = 0; i < n; i++) \n            par[i][0] = parent[i];\n            for (int j = 1; j < 20; j++) {\n            for (int i = 0; i < n; i++) {\n                if (par[i][j - 1] == -1) \n                    par[i][j] = -1;\n                else \n                par[i][j] = par[par[i][j - 1]][j - 1];\n            }\n        }\n        int getKthAncestor(int node, int k) {\n            for (int i = 0; i < 20; i++) {\n                if ((k >> i) & 1) {\n                    node = v[node][i];\n                    if (node == -1) return -1;\n                }\n            }\n            return node;\n        }\n    }   \n    swap(v, par);\n};\n\n                return node;\n        "
    },
    {
        "slug": "minimum-operations-to-make-array-equal",
        "description": "You have an array arr of length n where arr[i] = (2 * i) + 1 for all valid values of i (i.e.,\u00a00 <= i < n).\nIn one operation, you can select two indices x and y where 0 <= x, y < n and subtract 1 from arr[x] and add 1 to arr[y] (i.e., perform arr[x] -=1 and arr[y] += 1). The goal is to make all the elements of the array equal. It is guaranteed that all the elements of the array can be made equal using some operations.\nGiven an integer n, the length of the array, return the minimum number of operations needed to make all the elements of arr equal.",
        "examples": [
            "Input: n = 3\nOutput: 2\nExplanation: arr = [1, 3, 5]\nFirst operation choose x = 2 and y = 0, this leads arr to be [2, 3, 4]\nIn the second operation choose x = 2 and y = 0 again, thus arr = [3, 3, 3].",
            "Input: n = 6\nOutput: 9"
        ],
        "constraints": "1 <= n <= 104",
        "oracle_code": "class Solution {\npublic:\n    int minOperations(int n) {\n       int i,j,k=0,s=0;\n       i=n/2;\n       int max=n;\n       \n        for(j=0;j<i;j++){\n            s+=max-2*j-1;\n\n        }\n        return s;\n\n        \n    }\n};\n\n//1 3 5 7",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n       int i,j,k=0,s=0;\\n       i=n/2;\\n       int max=n;\\n       \\n        for(j=0;j<i;j++){\\n            s+=max-2*j-1;\\n\\n        }\\n        return s;\\n\\n        \\n    }\\n};\\n\\n//1 3 5 7\\n```",
        "level": "medium",
        "type": [
            "conditional statement error",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    int minOperations(int n) {\n       int i,j,k=0,s=0;\n       i=n/2;\n       int max=n;\n       \n        for(j=0;j<=i;j++){\n            s+=max-2*j-1;\n        }\n        return s;\n        print(s);    }\n};\n"
    },
    {
        "slug": "implement-stack-using-queues",
        "description": "Implement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal stack (push, top, pop, and empty).\nImplement the MyStack class:\n\nvoid push(int x) Pushes element x to the top of the stack.\nint pop() Removes the element on the top of the stack and returns it.\nint top() Returns the element on the top of the stack.\nboolean empty() Returns true if the stack is empty, false otherwise.\n\nNotes:\n\nYou must use only standard operations of a queue, which means that only push to back, peek/pop from front, size and is empty operations are valid.\nDepending on your language, the queue may not be supported natively. You may simulate a queue using a list or deque (double-ended queue) as long as you use only a queue's standard operations.",
        "examples": [
            "Input\n[\"MyStack\", \"push\", \"push\", \"top\", \"pop\", \"empty\"]\n[[], [1], [2], [], [], []]\nOutput\n[null, null, null, 2, 2, false]\n\nExplanation\nMyStack myStack = new MyStack();\nmyStack.push(1);\nmyStack.push(2);\nmyStack.top(); // return 2\nmyStack.pop(); // return 2\nmyStack.empty(); // return False"
        ],
        "constraints": "1 <= x <= 9\nAt most 100 calls will be made to push, pop, top, and empty.\nAll the calls to pop and top are valid.\n\n\u00a0\nFollow-up: Can you implement the stack using only one queue?",
        "oracle_code": "class MyStack {\npublic:\n queue<int> q;\n    MyStack() {\n\n    }\n    \n    void push(int x) {\n        q.push(x);\n        for(int i=0; i<q.size()-1; i++){\n            q.push(q.front());\n            q.pop();\n        }\n    }\n    \n    int pop() {\n       int a= q.front();\n       q.pop();\n       return a;\n           }\n    \n    int top() {\n      return q.front();\n    }\n    \n    bool empty() {\n        return q.empty();\n    }\n};",
        "content": "\\n# Code\\n```\\nclass MyStack {\\npublic:\\n queue<int> q;\\n    MyStack() {\\n\\n    }\\n    \\n    void push(int x) {\\n        q.push(x);\\n        for(int i=0; i<q.size()-1; i++){\\n            q.push(q.front());\\n            q.pop();\\n        }\\n    }\\n    \\n    int pop() {\\n       int a= q.front();\\n       q.pop();\\n       return a;\\n           }\\n    \\n    int top() {\\n      return q.front();\\n    }\\n    \\n    bool empty() {\\n        return q.empty();\\n    }\\n};\\n\\n```",
        "level": "easy",
        "type": [
            "other error",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass MyStack {\npublic:\n queue<int> q;\n    MyStack() {\n\n    }\n    \n    void push(int x) {\n        q.push(x);\n        for(int i=0; i<q.size()-1; i++) {\n            q.push(q.front());\n            q.pop());\n        }\n    }\n    \n    int pop() {\n       int a= q.front();\n       q.pop();\n       return a;\n           }\n    \n    int top() {\n      return q.back();\n    }\n    \n    bool empty() {\n        return q.empty();\n    }\n};\n"
    },
    {
        "slug": "minimum-cost-to-make-at-least-one-valid-path-in-a-grid",
        "description": "Given an m x n grid. Each cell of the grid has a sign pointing to the next cell you should visit if you are currently in this cell. The sign of grid[i][j] can be:\n\n1 which means go to the cell to the right. (i.e go from grid[i][j] to grid[i][j + 1])\n2 which means go to the cell to the left. (i.e go from grid[i][j] to grid[i][j - 1])\n3 which means go to the lower cell. (i.e go from grid[i][j] to grid[i + 1][j])\n4 which means go to the upper cell. (i.e go from grid[i][j] to grid[i - 1][j])\n\nNotice that there could be some signs on the cells of the grid that point outside the grid.\nYou will initially start at the upper left cell (0, 0). A valid path in the grid is a path that starts from the upper left cell (0, 0) and ends at the bottom-right cell (m - 1, n - 1) following the signs on the grid. The valid path does not have to be the shortest.\nYou can modify the sign on a cell with cost = 1. You can modify the sign on a cell one time only.\nReturn the minimum cost to make the grid have at least one valid path.",
        "examples": [
            "Input: grid = [[1,1,1,1],[2,2,2,2],[1,1,1,1],[2,2,2,2]]\nOutput: 3\nExplanation: You will start at point (0, 0).\nThe path to (3, 3) is as follows. (0, 0) --> (0, 1) --> (0, 2) --> (0, 3) change the arrow to down with cost = 1 --> (1, 3) --> (1, 2) --> (1, 1) --> (1, 0) change the arrow to down with cost = 1 --> (2, 0) --> (2, 1) --> (2, 2) --> (2, 3) change the arrow to down with cost = 1 --> (3, 3)\nThe total cost = 3.",
            "Input: grid = [[1,1,3],[3,2,2],[1,1,4]]\nOutput: 0\nExplanation: You can follow the path from (0, 0) to (2, 2).",
            "Input: grid = [[1,2],[4,3]]\nOutput: 1"
        ],
        "constraints": "m == grid.length\nn == grid[i].length\n1 <= m, n <= 100\n1 <= grid[i][j] <= 4",
        "oracle_code": "#define pii pair<int, int>\n#define maxn 10005\n#define inf 1000000000\n\nclass Solution {\npublic:\n    vector<pii>g[maxn];\n    int dis[maxn];\n    int n, m;\n    bool valid(int x, int y) {\n        if(x >= 0 and x < n and y >= 0 and y < m) return true;\n        else return false;\n    }\n    void bfs(int s) {\n        deque<int> q;\n        for(int i=0; i<maxn; i++) dis[i] = inf;\n        dis[s] = 0;\n        q.push_front(s);\n        while(!q.empty()){\n            int u = q.front();\n            q.pop_front();\n            for(int i=0; i<g[u].size(); i++){\n                int v = g[u][i].first;\n                int w = g[u][i].second;\n                if(dis[u] + w < dis[v]){\n                    dis[v] = dis[u] + w;\n                    if(w == 1) q.push_back(v);\n                    else q.push_front(v);\n                }\n            }\n        }\n    }\n    int minCost(vector<vector<int>>& grid) {\n        n = grid.size(), m = grid[0].size();\n        for(int i=0; i<n; i++) {\n            for(int j=0; j<m; j++) {\n                int u = i * m + j;\n                if(valid(i+1, j)) {\n                    int v = (i+1) * m + j;\n                    int w;\n                    if(grid[i][j] == 3) w = 0;\n                    else w = 1;\n                    g[u].push_back({v, w});\n                }\n                if(valid(i-1, j)) {\n                    int v = (i-1) * m + j;\n                    int w;\n                    if(grid[i][j] == 4) w = 0;\n                    else w = 1;\n                    g[u].push_back({v, w});\n                } \n                if(valid(i, j+1)) {\n                    int v = i * m + (j+1);\n                    int w;\n                    if(grid[i][j] == 1) w = 0;\n                    else w = 1;\n                    g[u].push_back({v, w});\n                } \n                if(valid(i, j-1)) {\n                    int v = i * m + (j-1);\n                    int w;\n                    if(grid[i][j] == 2) w = 0;\n                    else w = 1;\n                    g[u].push_back({v, w});\n                } \n            }\n        }\n        bfs(0);\n        int node = (n * m) - 1;\n        int ans = dis[node];\n        return ans;\n    }\n};",
        "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    BFS 2D\\n\\n# Code\\n```\\n#define pii pair<int, int>\\n#define maxn 10005\\n#define inf 1000000000\\n\\nclass Solution {\\npublic:\\n    vector<pii>g[maxn];\\n    int dis[maxn];\\n    int n, m;\\n    bool valid(int x, int y) {\\n        if(x >= 0 and x < n and y >= 0 and y < m) return true;\\n        else return false;\\n    }\\n    void bfs(int s) {\\n        deque<int> q;\\n        for(int i=0; i<maxn; i++) dis[i] = inf;\\n        dis[s] = 0;\\n        q.push_front(s);\\n        while(!q.empty()){\\n            int u = q.front();\\n            q.pop_front();\\n            for(int i=0; i<g[u].size(); i++){\\n                int v = g[u][i].first;\\n                int w = g[u][i].second;\\n                if(dis[u] + w < dis[v]){\\n                    dis[v] = dis[u] + w;\\n                    if(w == 1) q.push_back(v);\\n                    else q.push_front(v);\\n                }\\n            }\\n        }\\n    }\\n    int minCost(vector<vector<int>>& grid) {\\n        n = grid.size(), m = grid[0].size();\\n        for(int i=0; i<n; i++) {\\n            for(int j=0; j<m; j++) {\\n                int u = i * m + j;\\n                if(valid(i+1, j)) {\\n                    int v = (i+1) * m + j;\\n                    int w;\\n                    if(grid[i][j] == 3) w = 0;\\n                    else w = 1;\\n                    g[u].push_back({v, w});\\n                }\\n                if(valid(i-1, j)) {\\n                    int v = (i-1) * m + j;\\n                    int w;\\n                    if(grid[i][j] == 4) w = 0;\\n                    else w = 1;\\n                    g[u].push_back({v, w});\\n                } \\n                if(valid(i, j+1)) {\\n                    int v = i * m + (j+1);\\n                    int w;\\n                    if(grid[i][j] == 1) w = 0;\\n                    else w = 1;\\n                    g[u].push_back({v, w});\\n                } \\n                if(valid(i, j-1)) {\\n                    int v = i * m + (j-1);\\n                    int w;\\n                    if(grid[i][j] == 2) w = 0;\\n                    else w = 1;\\n                    g[u].push_back({v, w});\\n                } \\n            }\\n        }\\n        bfs(0);\\n        int node = (n * m) - 1;\\n        int ans = dis[node];\\n        return ans;\\n    }\\n};\\n```",
        "level": "hard",
        "type": [
            "== and = confusion",
            "conditional statement error"
        ],
        "buggy_code": "\n#define pii pair<int, int>\n#define maxn 10005\n#define inf 1000000000\n\nclass Solution {\npublic:\n    vector<pii>g[maxn];\n    int dis[maxn];\n    int n, m;\n    bool valid(int x, int y) {\n        if(x >= 0 and x <= n and y >= 0 and y <= m) return true;\n        else return false;\n    }\n    void bfs(int s) {\n        deque<int> q;\n        for(int i=0; i<maxn; i++) dis[i] = inf;\n        dis[s] = 0;\n        q.push_front(s);\n        while(!q.empty()){\n            int u = q.front();\n            q.pop_front();\n            for(int i=0; i<g[u].size(); i++){\n                int v = g[u][i].first;\n                int w = g[u][i].second;\n                if(dis[u] + w < dis[v]){\n                    dis[v] == dis[u] + w;\n                    if(w == 1) q.push_back(v);\n                    else q.push_front(v);\n                }\n            }\n        }\n    }\n    int minCost(vector<vector<int>>& grid) {\n        n = grid.size(), m = grid[0].size();\n        for(int i=0; i<n; i++) {\n            for(int j=0; j<m; j++) {\n                int u = i * m + j;\n                if(valid(i+1, j)) {\n                    int v = (i+1) * m + j;\n                    int w;\n                    if(grid[i][j] == 3) w = 0;\n                    else w = 1;\n                    g[u].push_back({v, w});\n                }\n                if(valid(i-1, j)) {\n                    int v = (i-1) * m + j;\n                    int w;\n                    if(grid[i][j] == 4) w = 0;\n                    else w = 1;\n                    g[u].push_back({v, w});\n                } \n                if(valid(i, j+1)) {\n                    int v = i * m + (j+1);\n                    int w;\n                    if(grid[i][j] == 1) w = 0;\n                    else w = 1;\n                    g[u].push_back({v, w});\n                } \n                if(valid(i, j-1)) {\n                    int v = i * m + (j-1);\n                    int w;\n                    if(grid[i][j] == 2) w = 0;\n                    else w = 1;\n                    g[u].push_back({v, w});\n                } \n            }\n        }\n        bfs(0);\n        int node = (n * m) - 1;\n        int ans = dis[node];\n        return ans;\n    }\n};\n"
    },
    {
        "slug": "shortest-path-to-get-all-keys",
        "description": "You are given an m x n grid grid where:\n\n'.' is an empty cell.\n'#' is a wall.\n'@' is the starting point.\nLowercase letters represent keys.\nUppercase letters represent locks.\n\nYou start at the starting point and one move consists of walking one space in one of the four cardinal directions. You cannot walk outside the grid, or walk into a wall.\nIf you walk over a key, you can pick it up and you cannot walk over a lock unless you have its corresponding key.\nFor some 1 <= k <= 6, there is exactly one lowercase and one uppercase letter of the first k letters of the English alphabet in the grid. This means that there is exactly one key for each lock, and one lock for each key; and also that the letters used to represent the keys and locks were chosen in the same order as the English alphabet.\nReturn the lowest number of moves to acquire all keys. If it is impossible, return -1.",
        "examples": [
            "Input: grid = [\"@.a..\",\"###.#\",\"b.A.B\"]\nOutput: 8\nExplanation: Note that the goal is to obtain all the keys not to open all the locks.",
            "Input: grid = [\"@..aA\",\"..B#.\",\"....b\"]\nOutput: 6",
            "Input: grid = [\"@Aa\"]\nOutput: -1"
        ],
        "constraints": "m == grid.length\nn == grid[i].length\n1 <= m, n <= 30\ngrid[i][j] is either an English letter, '.', '#', or '@'.\u00a0\nThere is exactly one\u00a0'@'\u00a0in the grid.\nThe number of keys in the grid is in the range [1, 6].\nEach key in the grid is unique.\nEach key in the grid has a matching lock.",
        "oracle_code": "class Solution {\npublic:\n\n    int dir[4][2] = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};\n\n    int shortestPathAllKeys(vector<string>& grid) {\n        \n        int m = grid.size();\n        int n = grid[0].size();\n        queue<pair<pair<int, int>, int>> que;\n        vector<vector<unsigned long>> mapKey(m, vector<unsigned long>(n, 0));\n        int target = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if ('a' <= grid[i][j] && grid[i][j] <= 'f') {\n                    target |= 1 << (grid[i][j] - 'a');\n                    continue;\n                }\n\n                if (grid[i][j] == '@') {\n                    que.emplace(pair<int, int>(i, j), 0);\n                    mapKey[i][j] = 1;\n                }\n            }\n        }\n\n\n        int step = 0;\n        while (!que.empty()) {\n            int size = que.size();\n            for (int s = 0; s < size; s++) {\n                int i = que.front().first.first;\n                int j = que.front().first.second;\n                int key = que.front().second;\n                que.pop();\n                \n                if ('a' <= grid[i][j] && grid[i][j] <= 'f') {\n                    key |= 1 << (grid[i][j] - 'a');\n                    if (key == target)\n                        return step;\n\n                    mapKey[i][j] |= 1l << key;\n                }\n\n                for (int d = 0; d < 4; d++) {\n                    int newi = i + dir[d][0];\n                    int newj = j + dir[d][1];\n                    \n                    if (!(0 <= newi && newi < m && 0 <= newj && newj < n))\n                        continue;\n                        \n                    int val = grid[newi][newj];\n                    if (val == '#')\n                        continue;\n                        \n                    if ('A' <= val && val <= 'F' && (key & (1 << (val - 'A'))) == 0)\n                        continue;\n                        \n                    if (mapKey[newi][newj] & (1l << key))\n                        continue;\n                        \n                     mapKey[newi][newj] |= 1l << key;\n                     que.emplace(pair<int, int>(newi, newj), key);\n                }\n            }\n            step++;\n        }\n        return -1;\n    }\n};",
        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int dir[4][2] = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};\\n\\n    int shortestPathAllKeys(vector<string>& grid) {\\n        \\n        int m = grid.size();\\n        int n = grid[0].size();\\n        queue<pair<pair<int, int>, int>> que;\\n        vector<vector<unsigned long>> mapKey(m, vector<unsigned long>(n, 0));\\n        int target = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (\\'a\\' <= grid[i][j] && grid[i][j] <= \\'f\\') {\\n                    target |= 1 << (grid[i][j] - \\'a\\');\\n                    continue;\\n                }\\n\\n                if (grid[i][j] == \\'@\\') {\\n                    que.emplace(pair<int, int>(i, j), 0);\\n                    mapKey[i][j] = 1;\\n                }\\n            }\\n        }\\n\\n\\n        int step = 0;\\n        while (!que.empty()) {\\n            int size = que.size();\\n            for (int s = 0; s < size; s++) {\\n                int i = que.front().first.first;\\n                int j = que.front().first.second;\\n                int key = que.front().second;\\n                que.pop();\\n                \\n                if (\\'a\\' <= grid[i][j] && grid[i][j] <= \\'f\\') {\\n                    key |= 1 << (grid[i][j] - \\'a\\');\\n                    if (key == target)\\n                        return step;\\n\\n                    mapKey[i][j] |= 1l << key;\\n                }\\n\\n                for (int d = 0; d < 4; d++) {\\n                    int newi = i + dir[d][0];\\n                    int newj = j + dir[d][1];\\n                    \\n                    if (!(0 <= newi && newi < m && 0 <= newj && newj < n))\\n                        continue;\\n                        \\n                    int val = grid[newi][newj];\\n                    if (val == \\'#\\')\\n                        continue;\\n                        \\n                    if (\\'A\\' <= val && val <= \\'F\\' && (key & (1 << (val - \\'A\\'))) == 0)\\n                        continue;\\n                        \\n                    if (mapKey[newi][newj] & (1l << key))\\n                        continue;\\n                        \\n                     mapKey[newi][newj] |= 1l << key;\\n                     que.emplace(pair<int, int>(newi, newj), key);\\n                }\\n            }\\n            step++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
        "level": "hard",
        "type": [
            "statement separation",
            "operation error"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n\n    int dir[4][2] = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};\n\n    int shortestPathAllKeys(vector<string>& grid) {\n        \n        int m = grid.size();\n        int n = grid[0].size();\n        queue<pair<pair<int, int>, int>> que;\n        vector<vector<unsigned long>> mapKey(m, vector<unsigned long>(n, 0));\n        int target = 0;\n        for (int i = 0; i < m; i++) \n            for (int j = 0; j < n; j++) \n                if ('a' <= grid[i][j] && grid[i][j] <= 'f') {\n                    target |= 1 << (grid[i][j] - 'a');\n                    continue;\n\n                if (grid[i][j] == '@') {\n                    que.emplace(pair<int, int>(i, j), 0);\n                    mapKey[i][j] = 1;\n                }\n            \n\n\n        int step = 0;\n        while (!que.empty()) {\n            int size = que.size();\n            for (int s = 0; s < size; s++) {\n                int i = que.front().first.first;\n                int j = que.front().first.second;\n                int key = que.front().second;\n                que.pop();\n                \n                if ('a' <= grid[i][j] && grid[i][j] <= 'f') {\n                    key |= 1 << (grid[i][j] - 'a');\n                    if (key == target)\n                        return step;\n\n                    mapKey[i][j] |= 1l << key;\n                }\n\n                for (int d = 0; d < 4; d++) {\n                    int newi = i + dir[d][0];\n                    int newj = j + dir[d][1];\n                    \n                    if (!(0 <= newi && newi < m && 0 <= newj && newj < n))\n                        continue;\n                        \n                    int val = grid[newi][newj];\n                    if (val == '#')\n                        continue;\n                        \n                    if ('A' <= val && val <= 'F' && (key & (1 << (val - 'A'))) == 0)\n                        continue;\n                        \n                    if (mapKey[newi][newj] & (1l << key))\n                        continue;\n                        \n                     mapKey[newi][newj] |= 1l << (key+1);  \n                     que.emplace(pair<int, int>(newi, newj), key);\n                }\n            }\n            step++;\n        }\n        return -1;\n    }\n};\n"
    },
    {
        "slug": "longest-increasing-subsequence",
        "description": "Given an integer array nums, return the length of the longest strictly increasing subsequence.",
        "examples": [
            "Input: nums = [10,9,2,5,3,7,101,18]\nOutput: 4\nExplanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.",
            "Input: nums = [0,1,0,3,2,3]\nOutput: 4",
            "Input: nums = [7,7,7,7,7,7,7]\nOutput: 1"
        ],
        "constraints": "1 <= nums.length <= 2500\n-104 <= nums[i] <= 104",
        "oracle_code": "class Solution {\npublic:\n    int lengthOfLIS(vector<int>& nums) {\n        //array to store max length subsequence till that place\n        vector<int> dp(nums.size(),0);\n        int maxlength = 0;//to store maxlength of subsequence\n        dp[0] = 1;//length will be 1 at first index \n        for(int i = 0;i<nums.size();i++){\n            int currentMaxLen = 0; //to store maxlength at till this index\n            for(int j = 0;j<i;j++){\n                // only check when the subsequence is increasing\n                if(nums[i]>nums[j]){\n                    if(currentMaxLen<dp[j]){\n                        currentMaxLen = dp[j]; //update currentMaxLen accordingly\n                    }\n                }\n            }\n            dp[i] = currentMaxLen + 1; //set the maxLength till ith index, which will be maxlenth so far + 1\n            maxlength = max(maxlength,dp[i]); //update maxlength\n        }\n        \n        return maxlength;\n    }\n};",
        "content": "# Intuition\\nThe problem asks us to find the length of the longest strictly increasing subsequence in the given array. To solve this problem efficiently, we can use dynamic programming.\\n\\n# Approach\\n1. Create a vector dp of size nums.size(), where dp[i] will store the length of the longest increasing subsequence ending at index i.\\n2. Initialize a variable maxlength to store the maximum length of the subsequence.\\n3. Set dp[0] to 1, as the length of the subsequence ending at the first index is always 1.\\n4. Iterate through each element in nums using the outer loop. For each element at index i, iterate through all the previous elements using the inner loop (from 0 to i-1).\\n5. Check if nums[i] is greater than nums[j], indicating that we can extend the increasing subsequence.\\n    - If the condition is satisfied, update the currentMaxLen variable with the maximum length of the subsequence so far at index j.\\n6. After the inner loop, update dp[i] with currentMaxLen + 1, which represents the maximum length of the subsequence ending at index i.\\nUpdate maxlength by taking the maximum value between maxlength and dp[i].\\n7. After the loop, maxlength will contain the length of the longest increasing subsequence.\\n8. Return maxlength.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of this solution is O(n^2), where n is the size of the input array nums. The outer loop runs for n iterations, and the inner loop also runs for a maximum of n iterations.\\n\\n- Space complexity:\\nThe space complexity is O(n) since we are using an additional vector dp of size n to store the lengths of subsequences.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums) {\\n        //array to store max length subsequence till that place\\n        vector<int> dp(nums.size(),0);\\n        int maxlength = 0;//to store maxlength of subsequence\\n        dp[0] = 1;//length will be 1 at first index \\n        for(int i = 0;i<nums.size();i++){\\n            int currentMaxLen = 0; //to store maxlength at till this index\\n            for(int j = 0;j<i;j++){\\n                // only check when the subsequence is increasing\\n                if(nums[i]>nums[j]){\\n                    if(currentMaxLen<dp[j]){\\n                        currentMaxLen = dp[j]; //update currentMaxLen accordingly\\n                    }\\n                }\\n            }\\n            dp[i] = currentMaxLen + 1; //set the maxLength till ith index, which will be maxlenth so far + 1\\n            maxlength = max(maxlength,dp[i]); //update maxlength\\n        }\\n        \\n        return maxlength;\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "colon missing",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    int lengthOfLIS(vector<int>& nums) {\n        //array to store max length subsequence till that place\n        vector<int> dp(0,0);\n        int maxlength = 0;//to store maxlength of subsequence\n        dp[0] = 1;//length will be 1 at first index \n        for(int i = 0;i<nums.size() i++){\n            int currentMaxLen = 0; //to store maxlength at till this index\n            for(int j = 0;j<i;j++){\n                // only check when the subsequence is increasing\n                if(nums[i]>nums[j]){\n                    if(currentMaxLen<dp[j]){\n                        currentMaxLen = dp[j]; //update currentMaxLen accordingly\n                    }\n                }\n            }\n            dp[i] = currentMaxLen + 1; //set the maxLength till ith index, which will be maxlenth so far + 1\n            maxlength = max(maxlength,dp[i]); //update maxlength\n        }\n        \n        return maxlength;\n    }\n};\n"
    },
    {
        "slug": "length-of-longest-fibonacci-subsequence",
        "description": "A sequence x1, x2, ..., xn is Fibonacci-like if:\n\nn >= 3\nxi + xi+1 == xi+2 for all i + 2 <= n\n\nGiven a strictly increasing array arr of positive integers forming a sequence, return the length of the longest Fibonacci-like subsequence of arr. If one does not exist, return 0.\nA subsequence is derived from another sequence arr by deleting any number of elements (including none) from arr, without changing the order of the remaining elements. For example, [3, 5, 8] is a subsequence of [3, 4, 5, 6, 7, 8].",
        "examples": [
            "Input: arr = [1,2,3,4,5,6,7,8]\nOutput: 5\nExplanation: The longest subsequence that is fibonacci-like: [1,2,3,5,8].",
            "Input: arr = [1,3,7,11,12,14,18]\nOutput: 3\nExplanation: The longest subsequence that is fibonacci-like: [1,11,12], [3,11,14] or [7,11,18]."
        ],
        "constraints": "3 <= arr.length <= 1000\n1 <= arr[i] < arr[i + 1] <= 109",
        "oracle_code": "class Solution {\npublic:\n  int f(int curr,int prev,vector<int>& nums,int n){\n\t\t\tint t=nums[curr]+nums[prev];\n\t\t\tint i=lower_bound(nums.begin(),nums.end(),t)-nums.begin();\n\t\t\tif(i<n && nums[i]==t) return 1+f(i,curr,nums,n);\n\t\t\treturn 1;\n\t\t}\n\n\t\tint lenLongestFibSubseq(vector<int>& nums) {\n\t\t\tint n=nums.size();\n\t\t\tint maxi=0;\n\t\t\tfor(int prev2=0;prev2<n;prev2++){\n\t\t\t\tfor(int prev1=prev2+1;prev1<n;prev1++){\n\t\t\t\t\tint temp=nums[prev1]+nums[prev2];\n\t\t\t\t\tint ind=lower_bound(nums.begin(),nums.end(),temp)-nums.begin();\n\t\t\t\t\tif(ind<n && nums[ind]==temp) maxi=max(maxi,2+f(ind,prev1,nums,n));\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn maxi;\n\t\t}\n\t};",
        "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  int f(int curr,int prev,vector<int>& nums,int n){\\n\\t\\t\\tint t=nums[curr]+nums[prev];\\n\\t\\t\\tint i=lower_bound(nums.begin(),nums.end(),t)-nums.begin();\\n\\t\\t\\tif(i<n && nums[i]==t) return 1+f(i,curr,nums,n);\\n\\t\\t\\treturn 1;\\n\\t\\t}\\n\\n\\t\\tint lenLongestFibSubseq(vector<int>& nums) {\\n\\t\\t\\tint n=nums.size();\\n\\t\\t\\tint maxi=0;\\n\\t\\t\\tfor(int prev2=0;prev2<n;prev2++){\\n\\t\\t\\t\\tfor(int prev1=prev2+1;prev1<n;prev1++){\\n\\t\\t\\t\\t\\tint temp=nums[prev1]+nums[prev2];\\n\\t\\t\\t\\t\\tint ind=lower_bound(nums.begin(),nums.end(),temp)-nums.begin();\\n\\t\\t\\t\\t\\tif(ind<n && nums[ind]==temp) maxi=max(maxi,2+f(ind,prev1,nums,n));\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn maxi;\\n\\t\\t}\\n\\t};\\n```",
        "level": "medium",
        "type": [
            "operation error",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n  int f(int curr,int prev,vector<int>& nums,int n){\n\t\t\tint t=nums[curr]+nums[prev];\n\t\t\tint i=del nums.begin(),nums.end(),t)-nums.begin();\n\t\t\tif(i<n && nums[i]==t) return 1+f(i,curr,nums,n);\n\t\t\treturn 0;\n\t\t}\n\n\t\tint lenLongestFibSubseq(vector<int>& nums) {\n\t\t\tint n=nums.size();\n\t\t\tint maxi=0;\n\t\t\tfor(int prev2=0;prev2<n;prev2++){\n\t\t\t\tfor(int prev1=prev2+1;prev1<n;prev1++){\n\t\t\t\t\tint temp=nums[prev1]+nums[prev2];\n\t\t\t\t\tint ind=lower_bound(nums.begin(),nums.end(),temp)-nums.begin();\n\t\t\t\t\tif(ind<n && nums[ind]==temp) maxi=max(maxi,2+f(ind,prev1,nums,n));\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn maxi;\n\t\t}\n\t};\n"
    },
    {
        "slug": "flood-fill",
        "description": "An image is represented by an m x n integer grid image where image[i][j] represents the pixel value of the image.\nYou are also given three integers sr, sc, and color. You should perform a flood fill on the image starting from the pixel image[sr][sc].\nTo perform a flood fill, consider the starting pixel, plus any pixels connected 4-directionally to the starting pixel of the same color as the starting pixel, plus any pixels connected 4-directionally to those pixels (also with the same color), and so on. Replace the color of all of the aforementioned pixels with color.\nReturn the modified image after performing the flood fill.",
        "examples": [
            "Input: image = [[1,1,1],[1,1,0],[1,0,1]], sr = 1, sc = 1, color = 2\nOutput: [[2,2,2],[2,2,0],[2,0,1]]\nExplanation: From the center of the image with position (sr, sc) = (1, 1) (i.e., the red pixel), all pixels connected by a path of the same color as the starting pixel (i.e., the blue pixels) are colored with the new color.\nNote the bottom corner is not colored 2, because it is not 4-directionally connected to the starting pixel.",
            "Input: image = [[0,0,0],[0,0,0]], sr = 0, sc = 0, color = 0\nOutput: [[0,0,0],[0,0,0]]\nExplanation: The starting pixel is already colored 0, so no changes are made to the image."
        ],
        "constraints": "m == image.length\nn == image[i].length\n1 <= m, n <= 50\n0 <= image[i][j], color < 216\n0 <= sr < m\n0 <= sc < n",
        "oracle_code": "class Solution {\npublic:\n    void bfs(int prevcolor,int row,int col,int color,vector<vector<int>>&visited,vector<vector<int>>&image)\n    {\n        // it'll ease the work\n        queue<pair<int,int>> q;\n        q.push({row,col});\n        visited[row][col]=1;\n\n        while(!q.empty())\n        {\n            row = q.front().first;\n            col = q.front().second;\n            q.pop();\n\n            // if img is of the starting color.\n            if(image[row][col]==prevcolor) image[row][col]=color;\n\n            // up\n            if(row-1>=0 && !visited[row-1][col] && image[row-1][col]==prevcolor) q.push({row-1,col}),visited[row-1][col]=1, image[row-1][col]=color;\n\n            // right\n            if(col+1<image[0].size() &&  !visited[row][col+1] && image[row][col+1]==prevcolor) q.push({row,col+1}),visited[row][col+1]=1, image[row][col+1]=color;\n\n            //down\n            if(row+1<image.size() && !visited[row+1][col] && image[row+1][col]==prevcolor) q.push({row+1,col}),visited[row+1][col]=1, image[row+1][col]=color;\n\n            // left\n            if(col-1>=0 && !visited[row][col-1] && image[row][col-1]==prevcolor) q.push({row,col-1}),visited[row][col-1]=1, image[row][col-1]=color;\n        }\n    }\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\n          int prevcolor = image[sr][sc];\n\n          // visiting array.\n          vector<vector<int>> visited(image.size(),vector<int>(image[0].size(),0));\n\n          bfs(prevcolor,sr,sc,color,visited,image);\n\n          return image;\n    }\n};",
        "content": "# Algo\\n\\n1.  Make a visited array of n*m\\n2. store the initial color.\\n3. do the traversal\\n4. Use queue data structure. \\n\\n\\n# Complexity\\n- Time complexity: O(N*M)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N*M)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void bfs(int prevcolor,int row,int col,int color,vector<vector<int>>&visited,vector<vector<int>>&image)\\n    {\\n        // it\\'ll ease the work\\n        queue<pair<int,int>> q;\\n        q.push({row,col});\\n        visited[row][col]=1;\\n\\n        while(!q.empty())\\n        {\\n            row = q.front().first;\\n            col = q.front().second;\\n            q.pop();\\n\\n            // if img is of the starting color.\\n            if(image[row][col]==prevcolor) image[row][col]=color;\\n\\n            // up\\n            if(row-1>=0 && !visited[row-1][col] && image[row-1][col]==prevcolor) q.push({row-1,col}),visited[row-1][col]=1, image[row-1][col]=color;\\n\\n            // right\\n            if(col+1<image[0].size() &&  !visited[row][col+1] && image[row][col+1]==prevcolor) q.push({row,col+1}),visited[row][col+1]=1, image[row][col+1]=color;\\n\\n            //down\\n            if(row+1<image.size() && !visited[row+1][col] && image[row+1][col]==prevcolor) q.push({row+1,col}),visited[row+1][col]=1, image[row+1][col]=color;\\n\\n            // left\\n            if(col-1>=0 && !visited[row][col-1] && image[row][col-1]==prevcolor) q.push({row,col-1}),visited[row][col-1]=1, image[row][col-1]=color;\\n        }\\n    }\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n          int prevcolor = image[sr][sc];\\n\\n          // visiting array.\\n          vector<vector<int>> visited(image.size(),vector<int>(image[0].size(),0));\\n\\n          bfs(prevcolor,sr,sc,color,visited,image);\\n\\n          return image;\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "statement separation",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    void bfs(int prevcolor,int row,int col,int color,vector<vector<int>>&visited,vector<vector<int>>&image)\n    {\n        // it'll ease the work\n        queue<pair<int,int>> q;\n        q.push({row,col});\n        visited[row][col]=1;\n        string unclosedString = \"bug introduction\n\n        while(!q.empty())\n        {\n            row = q.front().first;\n            col = q.front().second;\n            q.pop();\n\n            // if img is of the starting color.\n            if(image[row][col]==prevcolor) \n              image[row][col]=color;\n            \n            // up\n            if(row-1>=0 && !visited[row-1][col] && image[row-1][col]==prevcolor) \n              q.push({row-1,col});\n              visited[row-1][col]=1;\n              image[row-1][col]=color;\n\n            // right\n            if(col+1<image[0].size() &&  !visited[row][col+1] && image[row][col+1]==prevcolor) \n              q.push({row,col+1});\n              visited[row][col+1]=1;\n              image[row][col+1]=color;\n\n            //down\n            if(row+1<image.size() && !visited[row+1][col] && image[row+1][col]==prevcolor) \n              q.push({row+1,col});\n              visited[row+1][col]=1; \n              image[row+1][col]=color;\n\n            // left\n            if(col-1>=0 && !visited[row][col-1] && image[row][col-1]==prevcolor) \n              q.push({row,col-1});\n              visited[row][col-1]=1;\n              image[row][col-1]=color;\n        }\n    }\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\n          int prevcolor = image[sr][sc];\n\n          // visiting array.\n          vector<vector<int>> visited(image.size(),vector<int>(image[0].size(),0));\n\n          bfs(prevcolor,sr,sc,color,visited,image);\n\n          return image;\n    }\n};\n"
    },
    {
        "slug": "group-anagrams",
        "description": "Given an array of strings strs, group the anagrams together. You can return the answer in any order.\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.",
        "examples": [
            "Input: strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]\nOutput: [[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]",
            "Input: strs = [\"\"]\nOutput: [[\"\"]]",
            "Input: strs = [\"a\"]\nOutput: [[\"a\"]]"
        ],
        "constraints": "1 <= strs.length <= 104\n0 <= strs[i].length <= 100\nstrs[i] consists of lowercase English letters.",
        "oracle_code": "class Solution {\npublic:\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\n        unordered_map<string,int> m;\n        vector<vector<string>> ans;\n        for(int i=0; i<strs.size(); i++) {\n            string str = strs[i];\n            sort(str.begin(),str.end());\n\n            if(m.find(str) != m.end()) {\n                ans[m[str]].push_back(strs[i]);\n            }\n            else {\n                m[str] = ans.size(); \n                ans.push_back({strs[i]});\n            }\n        }\n        return ans;\n    }\n};",
        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        unordered_map<string,int> m;\\n        vector<vector<string>> ans;\\n        for(int i=0; i<strs.size(); i++) {\\n            string str = strs[i];\\n            sort(str.begin(),str.end());\\n\\n            if(m.find(str) != m.end()) {\\n                ans[m[str]].push_back(strs[i]);\\n            }\\n            else {\\n                m[str] = ans.size(); \\n                ans.push_back({strs[i]});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "operation error",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\n        unordered_map<string,int> m;\n        vector<vector<string>> ans;\n        for(int i=0; i<strs.size(); i++) {\n            string str = strs[i];\n            sort(str.begin(),str.end());\n\n            if(m.find(str) != m.end()) {\n                ans[m[str]].push_back(str);\n            }\n            else {\n                m[str] = ans.size(); \n                ans.push_back({strs[i]});\n                sortMyVec(ans[m[str]]);\n            }\n        }\n        return ans;\n    }\n};\n"
    },
    {
        "slug": "check-if-point-is-reachable",
        "description": "There exists an infinitely large grid. You are currently at point (1, 1), and you need to reach the point (targetX, targetY) using a finite number of steps.\nIn one step, you can move from point (x, y) to any one of the following points:\n\n(x, y - x)\n(x - y, y)\n(2 * x, y)\n(x, 2 * y)\n\nGiven two integers targetX and targetY representing the X-coordinate and Y-coordinate of your final position, return true if you can reach the point from (1, 1) using some number of steps, and false otherwise.",
        "examples": [
            "Input: targetX = 6, targetY = 9\nOutput: false\nExplanation: It is impossible to reach (6,9) from (1,1) using any sequence of moves, so false is returned.",
            "Input: targetX = 4, targetY = 7\nOutput: true\nExplanation: You can follow the path (1,1) -> (1,2) -> (1,4) -> (1,8) -> (1,7) -> (2,7) -> (4,7)."
        ],
        "constraints": "1 <= targetX, targetY\u00a0<= 109",
        "oracle_code": "class Solution {\npublic:\n    bool isReachable(int x, int y) {\n        while(!(x&1)){\n            x >>= 1;\n        }\n        while(!(y&1)){\n            y >>= 1;\n        }\n        return __gcd(x,y)==1;\n    }\n};",
        "content": "```\\nclass Solution {\\npublic:\\n    bool isReachable(int x, int y) {\\n        while(!(x&1)){\\n            x >>= 1;\\n        }\\n        while(!(y&1)){\\n            y >>= 1;\\n        }\\n        return __gcd(x,y)==1;\\n    }\\n};\\n```",
        "level": "hard",
        "type": [
            "== and = confusion",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    bool isReachable(int x, int y) {\n        while(!(x&1)){\n            x >>= 1;\n        }\n        while(!(y&1)){\n            y >>= 1;\n        }\n        return max(x,y)=1;\n    }\n};\n"
    },
    {
        "slug": "best-time-to-buy-and-sell-stock-with-transaction-fee",
        "description": "You are given an array prices where prices[i] is the price of a given stock on the ith day, and an integer fee representing a transaction fee.\nFind the maximum profit you can achieve. You may complete as many transactions as you like, but you need to pay the transaction fee for each transaction.\nNote:\n\nYou may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\nThe transaction fee is only charged once for each stock purchase and sale.",
        "examples": [
            "Input: prices = [1,3,2,8,4,9], fee = 2\nOutput: 8\nExplanation: The maximum profit can be achieved by:\n- Buying at prices[0] = 1\n- Selling at prices[3] = 8\n- Buying at prices[4] = 4\n- Selling at prices[5] = 9\nThe total profit is ((8 - 1) - 2) + ((9 - 4) - 2) = 8.",
            "Input: prices = [1,3,7,5,10,3], fee = 3\nOutput: 6"
        ],
        "constraints": "1 <= prices.length <= 5 * 104\n1 <= prices[i] < 5 * 104\n0 <= fee < 5 * 104",
        "oracle_code": "class Solution {\npublic:\n    int maxProfit(vector<int>& prices, int fee) {\n        int n = prices.size();\n        if (n <= 1) return 0;\n        int buy = -prices[0];\n        int sell = 0;\n        for (int i = 1; i < n; i++) {\n            int prevBuy = buy;\n            buy = max(buy, sell - prices[i]);\n            sell = max(sell, prevBuy + prices[i] - fee);\n        }\n        return sell;\n    }\n};",
        "content": "# Intuition\\nTo solve this problem, we can use a dynamic programming approach. \\n\\n# Approach\\nThe idea is to maintain two variables, buy and sell, which represent the maximum profit you can achieve if you have bought or sold the stock, respectively. Initially, buy is set to the negative of the first price, assuming we buy the stock on the first day. sell is set to zero because we haven\\'t sold any stock yet.\\n\\nThen, for each day starting from the second day, we update buy and sell as follows:\\n\\n- Update buy by taking the maximum value between the previous buy and the difference between sell and the current price (representing the profit we would make if we bought the stock on this day).\\n- Update sell by taking the maximum value between the previous sell and the sum of the previous buy and the current price minus the transaction fee (representing the profit we would make if we sold the stock on this day).\\n\\nFinally, the maximum profit we can achieve is stored in the sell variable, so we return its value.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices, int fee) {\\n        int n = prices.size();\\n        if (n <= 1) return 0;\\n        int buy = -prices[0];\\n        int sell = 0;\\n        for (int i = 1; i < n; i++) {\\n            int prevBuy = buy;\\n            buy = max(buy, sell - prices[i]);\\n            sell = max(sell, prevBuy + prices[i] - fee);\\n        }\\n        return sell;\\n    }\\n};\\n\\n```",
        "level": "medium",
        "type": [
            "conditional statement error",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices, int fee) {\n        int n = prices.length;\n        if (n <= 1) return 0;\n        int buy = -prices[0];\n        int sell = 0;\n        for (int i = 1; i < n; i++) {\n            int prevBuy = buy;\n            buy = max(buy, sell - prices[i]);\n            sell = max(sell, prevBuy + prices[i + 1] - fee);\n        }\n        return sell;\n    }\n};\n"
    },
    {
        "slug": "find-the-minimum-and-maximum-number-of-nodes-between-critical-points",
        "description": "A critical point in a linked list is defined as either a local maxima or a local minima.\nA node is a local maxima if the current node has a value strictly greater than the previous node and the next node.\nA node is a local minima if the current node has a value strictly smaller than the previous node and the next node.\nNote that a node can only be a local maxima/minima if there exists both a previous node and a next node.\nGiven a linked list head, return an array of length 2 containing [minDistance, maxDistance] where minDistance is the minimum distance between any\u00a0two distinct critical points and maxDistance is the maximum distance between any\u00a0two distinct critical points. If there are fewer than two critical points, return [-1, -1].",
        "examples": [
            "Input: head = [3,1]\nOutput: [-1,-1]\nExplanation: There are no critical points in [3,1].",
            "Input: head = [5,3,1,2,5,1,2]\nOutput: [1,3]\nExplanation: There are three critical points:\n- [5,3,1,2,5,1,2]: The third node is a local minima because 1 is less than 3 and 2.\n- [5,3,1,2,5,1,2]: The fifth node is a local maxima because 5 is greater than 2 and 1.\n- [5,3,1,2,5,1,2]: The sixth node is a local minima because 1 is less than 5 and 2.\nThe minimum distance is between the fifth and the sixth node. minDistance = 6 - 5 = 1.\nThe maximum distance is between the third and the sixth node. maxDistance = 6 - 3 = 3.",
            "Input: head = [1,3,2,2,3,2,2,2,7]\nOutput: [3,3]\nExplanation: There are two critical points:\n- [1,3,2,2,3,2,2,2,7]: The second node is a local maxima because 3 is greater than 1 and 2.\n- [1,3,2,2,3,2,2,2,7]: The fifth node is a local maxima because 3 is greater than 2 and 2.\nBoth the minimum and maximum distances are between the second and the fifth node.\nThus, minDistance and maxDistance is 5 - 2 = 3.\nNote that the last node is not considered a local maxima because it does not have a next node."
        ],
        "constraints": "The number of nodes in the list is in the range [2, 105].\n1 <= Node.val <= 105",
        "oracle_code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\n        ios_base::sync_with_stdio(false);\n if(head==NULL || head->next==NULL ||head->next->next==NULL){\n     return {-1,-1};\n }\n        ListNode* temp2=head->next;\n        ListNode* temp3=head->next->next;\n      vector<int>v;\n      int i=2;\n      while(temp3){\n          if((head->val<temp2->val)&&(temp3->val<temp2->val)){\n              v.push_back(i);\n          }\n          else if((head->val>temp2->val)&&(temp3->val>temp2->val)){\n              v.push_back(i);\n          }\n          i++;\n          head=head->next;\n          temp2=temp2->next;\n          temp3=temp3->next;\n      }\n      if(v.size()<2){\n           return {-1,-1};\n      }\n      int mini=INT_MAX;\n      for(int i=1;i<v.size();i++){\n          mini=min(mini,(v[i]-v[i-1]));\n      }\n        return {mini,(v[v.size()-1]-v[0])};\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhen faced with a problem involving linked lists, the first intuition should be to think about how to traverse the list efficiently to extract the required information.\\n\\nIn the case of this problem, the required information is the minimum and maximum distance between any two critical points in the list. A critical point is defined as a node where the value is either the maximum or minimum among its adjacent nodes.\\n\\nTo solve this problem, we need to traverse the list and identify the critical points. Once we have the critical points, we can calculate the distances between them and find the minimum and maximum distances.\\n\\nTherefore, the first intuition for this problem should be to think about how to traverse the list and identify critical points efficiently. We can then use this information to calculate the minimum and maximum distances between critical points.\\n\\n\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe code first checks if the list has at least three nodes, as it is not possible to have a critical point with less than two adjacent nodes. If the list does not meet this condition, the function returns {-1,-1}.\\n\\nThen, the code initializes three pointers, head, temp2, and temp3. The head pointer is used to traverse the list, while temp2 and temp3 are used to check if the current node is a critical point. The i variable is also initialized to 2, as the first two nodes are not considered critical points.\\n\\nNext, the code enters a loop that traverses the list using the temp3 pointer. For each node, the code checks if it is a critical point by comparing its value to the values of its adjacent nodes. If it is a critical point, the current value of i is pushed to a vector v.\\n\\nAfter the loop finishes, the code checks if there are at least two critical points in the list. If there are less than two, the function returns {-1,-1}.\\n\\nIf there are at least two critical points, the code calculates the minimum and maximum distances between adjacent critical points. The minimum distance is the minimum difference between the indices of adjacent critical points in the v vector, and the maximum distance is the difference between the indices of the first and last elements in the v vector.\\n\\nFinally, the function returns a vector containing the minimum and maximum distances as its two elements.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this code is O(n), where n is the length of the input singly-linked list. This is because the code only traverses the list once in the while loop, and performs constant time operations (comparisons, pointer assignments, and vector operations) for each node. The vector operations inside the loop take constant time on average, as the vector is not resized during the loop. Therefore, the overall time complexity of the code is O(n).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of this code is O(1) if we ignore the space used by the input linked list. The code only uses a constant amount of extra space to store three pointers (head, temp2, temp3) and a vector v to store the indices of critical points. The size of v is proportional to the number of critical points in the list, which is at most n-2 (where n is the length of the list), as there can be at most one critical point per node except for the first and last nodes. Therefore, the size of v is bounded by O(n), but since the space used by v is not a function of the input size, we consider it as a constant space usage. Therefore, the overall space complexity of the code is O(1).\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        ios_base::sync_with_stdio(false);\\n if(head==NULL || head->next==NULL ||head->next->next==NULL){\\n     return {-1,-1};\\n }\\n        ListNode* temp2=head->next;\\n        ListNode* temp3=head->next->next;\\n      vector<int>v;\\n      int i=2;\\n      while(temp3){\\n          if((head->val<temp2->val)&&(temp3->val<temp2->val)){\\n              v.push_back(i);\\n          }\\n          else if((head->val>temp2->val)&&(temp3->val>temp2->val)){\\n              v.push_back(i);\\n          }\\n          i++;\\n          head=head->next;\\n          temp2=temp2->next;\\n          temp3=temp3->next;\\n      }\\n      if(v.size()<2){\\n           return {-1,-1};\\n      }\\n      int mini=INT_MAX;\\n      for(int i=1;i<v.size();i++){\\n          mini=min(mini,(v[i]-v[i-1]));\\n      }\\n        return {mini,(v[v.size()-1]-v[0])};\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "indexing error",
            "conditional statement error"
        ],
        "buggy_code": "\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\n        ios_base::sync_with_stdio(false);\n if(head==NULL || head->next==NULL ||head->next->next==NULL){\n     return {-1,-1};\n }\n        ListNode* temp2=head->next;\n        ListNode* temp3=head->next->next;\n      vector<int>v;\n      int i=2;\n      while(head){\n          if((head->val<temp2->val)&&(temp3->val<temp2->val)){\n              v.push_back(i);\n          }\n          else if((head->val>temp2->val)&&(temp3->val<temp2->val)){\n              v.push_back(i);\n          }\n          i++;\n          head=head->next;\n          temp2=temp2->next;\n          temp3=temp3->next;\n      }\n      if(v.size()<2){\n           return {-1,-1};\n      }\n      int mini=INT_MAX;\n      for(int i=1;i<=v.size();i++){\n          mini=min(mini,(v[i]-v[i-1]));\n      }\n        return {mini,(v[v.size()]-v[0])};\n    }\n};\n"
    },
    {
        "slug": "closest-subsequence-sum",
        "description": "You are given an integer array nums and an integer goal.\nYou want to choose a subsequence of nums such that the sum of its elements is the closest possible to goal. That is, if the sum of the subsequence's elements is sum, then you want to minimize the absolute difference abs(sum - goal).\nReturn the minimum possible value of abs(sum - goal).\nNote that a subsequence of an array is an array formed by removing some elements (possibly all or none) of the original array.",
        "examples": [
            "Input: nums = [5,-7,3,5], goal = 6\nOutput: 0\nExplanation: Choose the whole array as a subsequence, with a sum of 6.\nThis is equal to the goal, so the absolute difference is 0.",
            "Input: nums = [7,-9,15,-2], goal = -5\nOutput: 1\nExplanation: Choose the subsequence [7,-9,-2], with a sum of -4.\nThe absolute difference is abs(-4 - (-5)) = abs(1) = 1, which is the minimum.",
            "Input: nums = [1,2,3], goal = -7\nOutput: 7"
        ],
        "constraints": "1 <= nums.length <= 40\n-107 <= nums[i] <= 107\n-109 <= goal <= 109",
        "oracle_code": "class Solution {\npublic:\n    void find(vector<int>&v, int i, int e, int sum, vector<int>&sumv){\n        if(i==e){\n            sumv.push_back(sum);\n            return;\n        }\n        find(v,i+1,e,sum+v[i],sumv);\n        find(v,i+1,e,sum,sumv);\n    }\n        \n    \n    int minAbsDifference(vector<int>& nums, int goal) {\n        int n=nums.size();\n        \n        //Step 1: Divide nums into 2 subarrays of size n/2 and n-n/2\n        \n        vector<int>A,B;\n        for(int i=0;i<n/2;i++)\n            A.push_back(nums[i]);\n        for(int i=n/2;i<n;i++)\n            B.push_back(nums[i]);\n        \n        //Step 2: Find all possible subset sums of A and B\n        \n        vector<int>sumA,sumB;\n        find(A,0,A.size(),0,sumA);\n        find(B,0,B.size(),0,sumB);\n        \n        sort(sumA.begin(),sumA.end());\n        sort(sumB.begin(),sumB.end());\n        \n        //Step 3: Find combinations from sumA & sumB such that abs(sum-goal) is minimized\n        \n        int ans=INT_MAX;\n        \n        for(int i=0;i<sumA.size();i++){\n            int s=sumA[i];\n            int l=0;\n            int r=sumB.size()-1;\n            while(l<=r){\n                int mid=l+(r-l)/2;\n                int sum=s+sumB[mid];\n                if(sum==goal)\n                    return 0;\n                ans=min(ans,abs(sum-goal));\n                if(sum>goal){\n                    r=mid-1;\n                }\n                else{\n                    l=mid+1;\n                }    \n            }\n        }\n        \n        return ans;\n    }\n};",
        "content": "```\\nclass Solution {\\npublic:\\n    void find(vector<int>&v, int i, int e, int sum, vector<int>&sumv){\\n        if(i==e){\\n            sumv.push_back(sum);\\n            return;\\n        }\\n        find(v,i+1,e,sum+v[i],sumv);\\n        find(v,i+1,e,sum,sumv);\\n    }\\n        \\n    \\n    int minAbsDifference(vector<int>& nums, int goal) {\\n        int n=nums.size();\\n        \\n        //Step 1: Divide nums into 2 subarrays of size n/2 and n-n/2\\n        \\n        vector<int>A,B;\\n        for(int i=0;i<n/2;i++)\\n            A.push_back(nums[i]);\\n        for(int i=n/2;i<n;i++)\\n            B.push_back(nums[i]);\\n        \\n        //Step 2: Find all possible subset sums of A and B\\n        \\n        vector<int>sumA,sumB;\\n        find(A,0,A.size(),0,sumA);\\n        find(B,0,B.size(),0,sumB);\\n        \\n        sort(sumA.begin(),sumA.end());\\n        sort(sumB.begin(),sumB.end());\\n        \\n        //Step 3: Find combinations from sumA & sumB such that abs(sum-goal) is minimized\\n        \\n        int ans=INT_MAX;\\n        \\n        for(int i=0;i<sumA.size();i++){\\n            int s=sumA[i];\\n            int l=0;\\n            int r=sumB.size()-1;\\n            while(l<=r){\\n                int mid=l+(r-l)/2;\\n                int sum=s+sumB[mid];\\n                if(sum==goal)\\n                    return 0;\\n                ans=min(ans,abs(sum-goal));\\n                if(sum>goal){\\n                    r=mid-1;\\n                }\\n                else{\\n                    l=mid+1;\\n                }    \\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n**Do upvote if you find it useful!**",
        "level": "hard",
        "type": [
            "undefined keywords from other languages",
            "variable value error"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    void find(vector<int>&v, int i, int e, int sum, vector<int>&sumv){\n        if(i==e){\n            sumv.push_back(sum);\n            return;\n        }\n        find(v,i+1,e,sum+v[i],sumv);\n        \n        find(v,i+1,e,sum+v[i],sumv);\n    }\n        \n    \n    int minAbsDifference(vector<int>& nums, int goal) {\n        int n=nums.length();\n        \n        //Step 1: Divide nums into 2 subarrays of size n/2 and n-n/2\n        \n        vector<int>A,B;\n        for(int i=0;i<n/2;i++)\n            A.push_back(nums[i]);\n        for(int i=n/2;i<n;i++)\n            B.push_back(nums[i]);\n        \n        //Step 2: Find all possible subset sums of A and B\n        \n        vector<int>sumA,sumB;\n        find(A,0,A.size(),0,sumA);\n        find(B,0,B.size(),0,sumB);\n        \n        sort(sumA.begin(),sumA.end());\n        sort(sumB.begin(),sumB.end());\n        \n        //Step 3: Find combinations from sumA & sumB such that abs(sum-goal) is minimized\n        \n        int ans=INT_MAX;\n        \n        for(int i=0;i<sumA.size();i++){\n            int s=sumA[i];\n            int l=0;\n            int r=sumB.size()-1;\n            while(l<=r){\n                int mid=l+(r-l)/2;\n                int sum=s+sumB[mid];\n                if(sum==goal)\n                    return 0;\n                ans=min(ans,abs(sum-goal));\n                if(sum>goal){\n                    r=mid-1;\n                }\n                else{\n                    l=mid+1;\n                }    \n            }\n        }\n        \n        return ans;\n    }\n};\n"
    },
    {
        "slug": "number-of-subarrays-with-gcd-equal-to-k",
        "description": "Given an integer array nums and an integer k, return the number of subarrays of nums where the greatest common divisor of the subarray's elements is k.\nA subarray is a contiguous non-empty sequence of elements within an array.\nThe greatest common divisor of an array is the largest integer that evenly divides all the array elements.",
        "examples": [
            "Input: nums = [9,3,1,2,6,3], k = 3\nOutput: 4\nExplanation: The subarrays of nums where 3 is the greatest common divisor of all the subarray's elements are:\n- [9,3,1,2,6,3]\n- [9,3,1,2,6,3]\n- [9,3,1,2,6,3]\n- [9,3,1,2,6,3]",
            "Input: nums = [4], k = 7\nOutput: 0\nExplanation: There are no subarrays of nums where 7 is the greatest common divisor of all the subarray's elements."
        ],
        "constraints": "1 <= nums.length <= 1000\n1 <= nums[i], k <= 109",
        "oracle_code": "class Solution {\npublic:\n    int subarrayGCD(vector<int>& nums, int k) {\n        \n        int result = 0; // We may not have any subarray.\n        \n        int n = nums.size();\n        \n        for (int l = 0; l < n; l++)\n        {\n            int current_gcd = nums[l]; // Choose a left anchor, mark it as gcd\n            for (int r = l; r < n; r++)\n            {\n                /* \n                We update our current_gcd value in the inner loop. \n                If we somehow reach to k at some point, we'll draw an arrow from our left anchor to the that point. \n                If we found a subarray that has elements with gcd k, increment result.\n                We repeat that steps for each left anchor.\n                */ \n                current_gcd = gcd(current_gcd, nums[r]); \n                if (current_gcd == k)\n                    result++;\n            }\n        }\n        return result;\n    }\n};",
        "content": "```\\nclass Solution {\\npublic:\\n    int subarrayGCD(vector<int>& nums, int k) {\\n        \\n        int result = 0; // We may not have any subarray.\\n        \\n        int n = nums.size();\\n        \\n        for (int l = 0; l < n; l++)\\n        {\\n            int current_gcd = nums[l]; // Choose a left anchor, mark it as gcd\\n            for (int r = l; r < n; r++)\\n            {\\n                /* \\n                We update our current_gcd value in the inner loop. \\n                If we somehow reach to k at some point, we\\'ll draw an arrow from our left anchor to the that point. \\n                If we found a subarray that has elements with gcd k, increment result.\\n                We repeat that steps for each left anchor.\\n                */ \\n                current_gcd = gcd(current_gcd, nums[r]); \\n                if (current_gcd == k)\\n                    result++;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "undefined methods",
            "variable value error"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    int subarrayGCD(vector<int>& nums, int k) {\n        \n        int result = 0; // We may not have any subarray.\n        \n        int n = nums.size();\n        \n        for (int l = 0; l < n; l++)\n        {\n            int current_gcd = nums[l]; // Choose a left anchor, mark it as gcd\n            for (int r = l; r < n; r++)\n            {\n                /* \n                We update our current_gcd value in the inner loop. \n                If we somehow reach to k at some point, we'll draw an arrow from our left anchor to the that point. \n                If we found a subarray that has elements with gcd k, increment result.\n                We repeat that steps for each left anchor.\n                */ \n                current_gcd = customGCD(nums[l], nums[r]); \n                if (current_gcd == k)\n                    result++;\n            }\n        }\n        return result;\n    }\n};\n"
    },
    {
        "slug": "maximum-star-sum-of-a-graph",
        "description": "There is an undirected graph consisting of n nodes numbered from 0 to n - 1. You are given a 0-indexed integer array vals of length n where vals[i] denotes the value of the ith node.\nYou are also given a 2D integer array edges where edges[i] = [ai, bi] denotes that there exists an undirected edge connecting nodes ai and bi.\nA star graph is a subgraph of the given graph having a center node containing 0 or more neighbors. In other words, it is a subset of edges of the given graph such that there exists a common node for all edges.\nThe image below shows star graphs with 3 and 4 neighbors respectively, centered at the blue node.\n\nThe star sum is the sum of the values of all the nodes present in the star graph.\nGiven an integer k, return the maximum star sum of a star graph containing at most k edges.",
        "examples": [
            "Input: vals = [1,2,3,4,10,-10,-20], edges = [[0,1],[1,2],[1,3],[3,4],[3,5],[3,6]], k = 2\nOutput: 16\nExplanation: The above diagram represents the input graph.\nThe star graph with the maximum star sum is denoted by blue. It is centered at 3 and includes its neighbors 1 and 4.\nIt can be shown it is not possible to get a star graph with a sum greater than 16.",
            "Input: vals = [-5], edges = [], k = 0\nOutput: -5\nExplanation: There is only one possible star graph, which is node 0 itself.\nHence, we return -5."
        ],
        "constraints": "n == vals.length\n1 <= n <= 105\n-104 <= vals[i] <= 104\n0 <= edges.length <= min(n * (n - 1) / 2, 105)\nedges[i].length == 2\n0 <= ai, bi <= n - 1\nai != bi\n0 <= k <= n - 1",
        "oracle_code": "class Solution {\npublic:\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) \n    {\n        int n = vals.size();\n        vector<vector<pair<int, int>>>adj(n);\n        for (vector<int>edge : edges)\n        {\n            int startNode = edge[0], startNodeVal = vals[startNode];\n            int endNode = edge[1], endNodeVal = vals[endNode];\n            adj[startNode].push_back({endNodeVal, endNode});\n            adj[endNode].push_back({startNodeVal, startNode});\n        }\n        //========================================================\n        int mxSum = INT_MIN;\n        for (int node = 0; node < n; node++)\n        {\n            sort(adj[node].begin(), adj[node].end()); //sort the neighbors based on increasing \"values\"\n            int neighborSize = adj[node].size();\n            int sum = vals[node];\n            for (int i = neighborSize - 1; i >= 0 && i >= (neighborSize - k); i--) //take k neighbors [start from largest vals]\n            {\n                int val = adj[node][i].first;\n                if (val < 0) break; //if value of neighbor is < 0, it would decrease sum so \"break\", \n\t\t\t\t                     //as the neighbors left to it would also have negative values\n                sum += val;\n            }\n            mxSum = max(mxSum, sum);\n        }\n        //=============================================================\n        return mxSum;\n        \n    }\n};",
        "content": "So a star graph is a graph having **one node [center node] which is connected to all other nodes directly** \\n\\nSo why not try all nodes \"as the center of star graph\"\\nFor each node,\\n  **star graph = node itself(center node)  + all it\\'s direct neighbors**\\n  \\n  Thus for each node treat it is as center node and **find sum of k highest value neighbors**\\n  [Take care of negative values =>  exclude negative values as they would decrease overall sum]\\n  \\n  \\n  \\n```\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) \\n    {\\n        int n = vals.size();\\n        vector<vector<pair<int, int>>>adj(n);\\n        for (vector<int>edge : edges)\\n        {\\n            int startNode = edge[0], startNodeVal = vals[startNode];\\n            int endNode = edge[1], endNodeVal = vals[endNode];\\n            adj[startNode].push_back({endNodeVal, endNode});\\n            adj[endNode].push_back({startNodeVal, startNode});\\n        }\\n        //========================================================\\n        int mxSum = INT_MIN;\\n        for (int node = 0; node < n; node++)\\n        {\\n            sort(adj[node].begin(), adj[node].end()); //sort the neighbors based on increasing \"values\"\\n            int neighborSize = adj[node].size();\\n            int sum = vals[node];\\n            for (int i = neighborSize - 1; i >= 0 && i >= (neighborSize - k); i--) //take k neighbors [start from largest vals]\\n            {\\n                int val = adj[node][i].first;\\n                if (val < 0) break; //if value of neighbor is < 0, it would decrease sum so \"break\", \\n\\t\\t\\t\\t                     //as the neighbors left to it would also have negative values\\n                sum += val;\\n            }\\n            mxSum = max(mxSum, sum);\\n        }\\n        //=============================================================\\n        return mxSum;\\n        \\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "unclosed string",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) \n    {\n        int n = vals.size();\n        vector<vector<pair<int, int>>>adj(n);\n        for (vector<int>edge : edges)\n        {\n            int startNode = edge[0], startNodeVal = vals[startNode];\n            int endNode = edge[1], endNodeVal = vals[endNode];\n            adj[startNode].push_back({endNodeVal, endNode});\n            adj[endNode].push_back({startNodeVal, startNode);\n        }\n        //========================================================\n        int mxSum = INT_MIN;\n        for (int node = 0; node < n; node++)\n        {\n            sort(adj[node].begin(), adj[node].end()); //sort the neighbors based on increasing \"values\"\n            int neighborSize = adj[node].size();\n            int sum = vals[node];\n            for (int i = neighborSize; i >= 0 && i >= (neighborSize - k); i--) \n            {\n                int val = adj[node][i].first;\n                if (val < 0) break; //if value of neighbor is < 0, it would decrease sum so \"break\", \n\t\t\t\t                     //as the neighbors left to it would also have negative values\n                sum += val;\n            }\n            mxSum = max(mxSum, sum);\n        }\n        //=============================================================\n        return mxSum;\n    }\n};\n"
    },
    {
        "slug": "find-if-path-exists-in-graph",
        "description": "There is a bi-directional graph with n vertices, where each vertex is labeled from 0 to n - 1 (inclusive). The edges in the graph are represented as a 2D integer array edges, where each edges[i] = [ui, vi] denotes a bi-directional edge between vertex ui and vertex vi. Every vertex pair is connected by at most one edge, and no vertex has an edge to itself.\nYou want to determine if there is a valid path that exists from vertex source to vertex destination.\nGiven edges and the integers n, source, and destination, return true if there is a valid path from source to destination, or false otherwise.",
        "examples": [
            "Input: n = 3, edges = [[0,1],[1,2],[2,0]], source = 0, destination = 2\nOutput: true\nExplanation: There are two paths from vertex 0 to vertex 2:\n- 0 \u2192 1 \u2192 2\n- 0 \u2192 2",
            "Input: n = 6, edges = [[0,1],[0,2],[3,5],[5,4],[4,3]], source = 0, destination = 5\nOutput: false\nExplanation: There is no path from vertex 0 to vertex 5."
        ],
        "constraints": "1 <= n <= 2 * 105\n0 <= edges.length <= 2 * 105\nedges[i].length == 2\n0 <= ui, vi <= n - 1\nui != vi\n0 <= source, destination <= n - 1\nThere are no duplicate edges.\nThere are no self edges.",
        "oracle_code": "class Solution {\npublic:\n\n    bool validPath(int n, vector<vector<int>>& edges, int source, int destination) {\n        \n        unordered_map<int,vector<int>>mpp;\n        unordered_map<int,bool>vis;\n        \n        for(auto it : edges)\n        {\n             mpp[it[0]].push_back(it[1]);\n             mpp[it[1]].push_back(it[0]);\n             vis[it[0]] = false;\n             vis[it[1]] = false;\n        }\n\n        queue<int>q;\n        q.push(source);\n\n        vis[source] = true;\n\n        while(!q.empty())\n        {\n           int temp = q.front();\n           q.pop();\n\n           vector<int>vec = mpp[temp];\n\n           for(int i = 0;i<vec.size();++i)\n           {\n              if(vis[vec[i]]==true) continue;\n\n              else\n              {\n                 q.push(vec[i]);\n                 vis[vec[i]] = true;\n              }\n\n            }\n\n        }\n\n        return vis[destination];\n    }\n};",
        "content": "\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n\\n    bool validPath(int n, vector<vector<int>>& edges, int source, int destination) {\\n        \\n        unordered_map<int,vector<int>>mpp;\\n        unordered_map<int,bool>vis;\\n        \\n        for(auto it : edges)\\n        {\\n             mpp[it[0]].push_back(it[1]);\\n             mpp[it[1]].push_back(it[0]);\\n             vis[it[0]] = false;\\n             vis[it[1]] = false;\\n        }\\n\\n        queue<int>q;\\n        q.push(source);\\n\\n        vis[source] = true;\\n\\n        while(!q.empty())\\n        {\\n           int temp = q.front();\\n           q.pop();\\n\\n           vector<int>vec = mpp[temp];\\n\\n           for(int i = 0;i<vec.size();++i)\\n           {\\n              if(vis[vec[i]]==true) continue;\\n\\n              else\\n              {\\n                 q.push(vec[i]);\\n                 vis[vec[i]] = true;\\n              }\\n\\n            }\\n\\n        }\\n\\n        return vis[destination];\\n    }\\n};\\n\\n\\n```",
        "level": "easy",
        "type": [
            "indexing error",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n\n    bool validPath(int n, vector<vector<int>>& edges, int source, int destination) {\n        \n        unordered_map<int,vector<int>>mpp;\n        unordered_map<int,bool>vis;\n        \n        for(auto it : edges)\n        {\n             mpp[it[0]].push_back(it[1]);\n             mpp[it[1]].push_back(it[0]);\n             vis[it[0]] = false;\n             vis[it[1]] = false;\n        }\n\n        queue<int>q;\n        q.push(source);\n\n        vis[source] = true;\n\n        while(!q.empty())\n        {\n           int temp = q.front();\n           q.pop();\n\n           vector<int>vec = mpp[temp];\n\n           for(int i = 0;i<=vec.size();++i) \n           {\n              if(vis[vec[i]]==true) continue;\n\n              else\n              {\n                 q.push(vec[i]);\n                 vis[vec[i]] = true;\n              }\n\n            \n        }\n        return vis[destination];\n    }\n};\n"
    },
    {
        "slug": "array-with-elements-not-equal-to-average-of-neighbors",
        "description": "You are given a 0-indexed array nums of distinct integers. You want to rearrange the elements in the array such that every element in the rearranged array is not equal to the average of its neighbors.\nMore formally, the rearranged array should have the property such that for every i in the range 1 <= i < nums.length - 1, (nums[i-1] + nums[i+1]) / 2 is not equal to nums[i].\nReturn any rearrangement of nums that meets the requirements.",
        "examples": [
            "Input: nums = [1,2,3,4,5]\nOutput: [1,2,4,5,3]\nExplanation:\nWhen i=1, nums[i] = 2, and the average of its neighbors is (1+4) / 2 = 2.5.\nWhen i=2, nums[i] = 4, and the average of its neighbors is (2+5) / 2 = 3.5.\nWhen i=3, nums[i] = 5, and the average of its neighbors is (4+3) / 2 = 3.5.",
            "Input: nums = [6,2,0,9,7]\nOutput: [9,7,6,2,0]\nExplanation:\nWhen i=1, nums[i] = 7, and the average of its neighbors is (9+6) / 2 = 7.5.\nWhen i=2, nums[i] = 6, and the average of its neighbors is (7+2) / 2 = 4.5.\nWhen i=3, nums[i] = 2, and the average of its neighbors is (6+0) / 2 = 3."
        ],
        "constraints": "3 <= nums.length <= 105\n0 <= nums[i] <= 105",
        "oracle_code": "class Solution {\npublic:\n    vector<int> rearrangeArray(vector<int>& nums) {\n        int size=nums.size();\n        for(int i=1;i<size-1;i++){\n            if((nums[i-1]<nums[i] && nums[i]<nums[i+1])||(nums[i-1]>nums[i] && nums[i]>nums[i+1]))   //If the array is strictly increasing or decreasing then swap the vlaue at current index  with value at index+1\n                swap(nums[i],nums[i+1]);\n        }\n        return nums;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int size=nums.size();\\n        for(int i=1;i<size-1;i++){\\n            if((nums[i-1]<nums[i] && nums[i]<nums[i+1])||(nums[i-1]>nums[i] && nums[i]>nums[i+1]))   //If the array is strictly increasing or decreasing then swap the vlaue at current index  with value at index+1\\n                swap(nums[i],nums[i+1]);\\n        }\\n        return nums;\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "wrong comment mark",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    vector<int> rearrangeArray(vector<int>& nums) {\n        int size=nums.size();\n        for(int i=1;i<size-1;i++){\n            if((nums[i-1]<nums[i] && nums[i]<nums[i+1])\\(nums[i-1]>nums[i] && nums[i]>nums[i+1]))\n   \n                swap(nums[i],nums[i+2]);\n        }\n        return nums;\n    }\n};\n"
    },
    {
        "slug": "longest-ideal-subsequence",
        "description": "You are given a string s consisting of lowercase letters and an integer k. We call a string t ideal if the following conditions are satisfied:\n\nt is a subsequence of the string s.\nThe absolute difference in the alphabet order of every two adjacent letters in t is less than or equal to k.\n\nReturn the length of the longest ideal string.\nA subsequence is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.\nNote that the alphabet order is not cyclic. For example, the absolute difference in the alphabet order of 'a' and 'z' is 25, not 1.",
        "examples": [
            "Input: s = \"acfgbd\", k = 2\nOutput: 4\nExplanation: The longest ideal string is \"acbd\". The length of this string is 4, so 4 is returned.\nNote that \"acfgbd\" is not ideal because 'c' and 'f' have a difference of 3 in alphabet order.",
            "Input: s = \"abcd\", k = 3\nOutput: 4\nExplanation: The longest ideal string is \"abcd\". The length of this string is 4, so 4 is returned."
        ],
        "constraints": "1 <= s.length <= 105\n0 <= k <= 25\ns consists of lowercase English letters.",
        "oracle_code": "class Solution {\n\n\n   int SolveByMemo(string &s , int &k , int index , int prev , vector<vector<int>> &dp)\n   {\n       if(index == s.length())\n       return 0;\n\n       if(dp[index][prev] != -1)\n       return dp[index][prev];\n\n       int op1 = 0 + SolveByMemo(s, k , index+1 , prev , dp);\n\n       int op2 = 0 ;\n\n       if(prev == 26)\n       op2 = 1 + SolveByMemo(s, k , index+1 , s[index]-'a' , dp);\n       else if(abs(s[index]-'a' - prev) <= k)\n       op2 = 1 + SolveByMemo(s, k , index+1 , s[index]-'a' , dp);\n\n       return dp[index][prev] = max(op1 , op2);\n   }\n\n   int SolveByTab(string &s , int &k )\n   {\n        vector<vector<int>> dp(s.length()+1 , vector<int> (27, 0));\n       \n        for(int index = s.length()-1 ; index>=0 ; index--)\n        {\n            for(int prev = 0 ; prev<= 26 ; prev++)\n            {\n                int op1 = 0 + dp[index+1][prev];\n                int op2 = 0 ;\n\n               if(prev == 26)\n               op2 = 1 + dp[index+1][s[index]-'a'];\n               else if(abs(s[index]-'a' - prev) <= k)\n               op2 = 1 + dp[index+1][s[index]-'a'];\n\n               dp[index][prev] = max(op1 , op2);\n            }\n        }\n\n       return max(dp[0][s[0]-'a'] , dp[0][26]);\n   }\n\n   int SolveByTabSpaceOptimised(string &s , int &k )\n   {\n        vector<int> next(27, 0) ;\n        vector<int> curr(27, 0);\n       \n        for(int index = s.length()-1 ; index>=0 ; index--)\n        {\n            for(int prev = 0 ; prev<= 26 ; prev++)\n            {\n                int op1 = 0 + next[prev];\n                int op2 = 0 ;\n\n               if(prev == 26)\n               op2 = 1 + next[s[index]-'a'];\n               else if(abs(s[index]-'a' - prev) <= k)\n               op2 = 1 + next[s[index]-'a'];\n\n               curr[prev] = max(op1 , op2);\n            }\n            next = curr;\n        }\n\n       return max(curr[s[0]-'a'] , curr[26]);\n   }\n\npublic:\n    int longestIdealString(string s, int k) {\n        \n        // 1. Recursion + Memoization || Top Down Approach\n        // vector<vector<int>> dp(s.length() , vector<int> (27, -1));\n        // return SolveByMemo(s, k , 0 , 26, dp);\n\n        // 2. Tabulation Method || Bottom Up Approach\n        // return SolveByTab(s, k);\n\n        // 3. Space Optimisation using Tabulation\n        return SolveByTabSpaceOptimised(s , k);\n    }\n};",
        "content": "\\n# Approach\\nWe Have Use Three Different Approaches :\\n1. Recursion + Memoization \\n    TC : O(n^2) , SC : O(n)\\n2. Tabulation Method \\n    TC : O(n^2) , SC : O(n)\\n3.  Tabulatuon With SOace Optimised\\n    TC : O(n^2) , SC : O(1) \\n\\n\\n#Note\\nSC In first two methods is On) and not O(n^2) as size is fixed to 27 for each index hence it is Linear Space ,Similarly for 3rd Method we have optimised to constant space as at any instant we onlt need memory of next 27 blocks  only.\\n\\n#Hope You Liekd It and Upvote are appreciated \\n\\n# Code\\n```\\nclass Solution {\\n\\n\\n   int SolveByMemo(string &s , int &k , int index , int prev , vector<vector<int>> &dp)\\n   {\\n       if(index == s.length())\\n       return 0;\\n\\n       if(dp[index][prev] != -1)\\n       return dp[index][prev];\\n\\n       int op1 = 0 + SolveByMemo(s, k , index+1 , prev , dp);\\n\\n       int op2 = 0 ;\\n\\n       if(prev == 26)\\n       op2 = 1 + SolveByMemo(s, k , index+1 , s[index]-\\'a\\' , dp);\\n       else if(abs(s[index]-\\'a\\' - prev) <= k)\\n       op2 = 1 + SolveByMemo(s, k , index+1 , s[index]-\\'a\\' , dp);\\n\\n       return dp[index][prev] = max(op1 , op2);\\n   }\\n\\n   int SolveByTab(string &s , int &k )\\n   {\\n        vector<vector<int>> dp(s.length()+1 , vector<int> (27, 0));\\n       \\n        for(int index = s.length()-1 ; index>=0 ; index--)\\n        {\\n            for(int prev = 0 ; prev<= 26 ; prev++)\\n            {\\n                int op1 = 0 + dp[index+1][prev];\\n                int op2 = 0 ;\\n\\n               if(prev == 26)\\n               op2 = 1 + dp[index+1][s[index]-\\'a\\'];\\n               else if(abs(s[index]-\\'a\\' - prev) <= k)\\n               op2 = 1 + dp[index+1][s[index]-\\'a\\'];\\n\\n               dp[index][prev] = max(op1 , op2);\\n            }\\n        }\\n\\n       return max(dp[0][s[0]-\\'a\\'] , dp[0][26]);\\n   }\\n\\n   int SolveByTabSpaceOptimised(string &s , int &k )\\n   {\\n        vector<int> next(27, 0) ;\\n        vector<int> curr(27, 0);\\n       \\n        for(int index = s.length()-1 ; index>=0 ; index--)\\n        {\\n            for(int prev = 0 ; prev<= 26 ; prev++)\\n            {\\n                int op1 = 0 + next[prev];\\n                int op2 = 0 ;\\n\\n               if(prev == 26)\\n               op2 = 1 + next[s[index]-\\'a\\'];\\n               else if(abs(s[index]-\\'a\\' - prev) <= k)\\n               op2 = 1 + next[s[index]-\\'a\\'];\\n\\n               curr[prev] = max(op1 , op2);\\n            }\\n            next = curr;\\n        }\\n\\n       return max(curr[s[0]-\\'a\\'] , curr[26]);\\n   }\\n\\npublic:\\n    int longestIdealString(string s, int k) {\\n        \\n        // 1. Recursion + Memoization || Top Down Approach\\n        // vector<vector<int>> dp(s.length() , vector<int> (27, -1));\\n        // return SolveByMemo(s, k , 0 , 26, dp);\\n\\n        // 2. Tabulation Method || Bottom Up Approach\\n        // return SolveByTab(s, k);\\n\\n        // 3. Space Optimisation using Tabulation\\n        return SolveByTabSpaceOptimised(s , k);\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "indexing error",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution {\n\n   int SolveByMemo(string &s , int &k , int index , int prev , vector<vector<int>> &dp)\n   {\n       \n       if(dp[index+1][prev] != -1)\n       return dp[index+1][prev];\n\n       \nstring()\n   }\n\n"
    },
    {
        "slug": "check-knight-tour-configuration",
        "description": "There is a knight on an n x n chessboard. In a valid configuration, the knight starts at the top-left cell of the board and visits every cell on the board exactly once.\nYou are given an n x n integer matrix grid consisting of distinct integers from the range [0, n * n - 1] where grid[row][col] indicates that the cell (row, col) is the grid[row][col]th cell that the knight visited. The moves are 0-indexed.\nReturn true if grid represents a valid configuration of the knight's movements or false otherwise.\nNote that a valid knight move consists of moving two squares vertically and one square horizontally, or two squares horizontally and one square vertically. The figure below illustrates all the possible eight moves of a knight from some cell.",
        "examples": [
            "Input: grid = [[0,11,16,5,20],[17,4,19,10,15],[12,1,8,21,6],[3,18,23,14,9],[24,13,2,7,22]]\nOutput: true\nExplanation: The above diagram represents the grid. It can be shown that it is a valid configuration.",
            "Input: grid = [[0,3,6],[5,8,1],[2,7,4]]\nOutput: false\nExplanation: The above diagram represents the grid. The 8th move of the knight is not valid considering its position after the 7th move."
        ],
        "constraints": "n == grid.length == grid[i].length\n3 <= n <= 7\n0 <= grid[row][col] < n * n\nAll integers in grid are unique.",
        "oracle_code": "class Solution {\nprivate:\n    bool helper(vector<vector<int>>& grid, int row, int col, int num){\n        int n = grid.size();\n        if(num == n*n) return true;\n        int i = row-2;\n        int j = col+1;\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row-2;\n        j = col-1;\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 2;\n        j = col - 1;\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 2;\n        j = col + 1;\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 1;\n        j = col + 2;\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row - 1;\n        j = col + 2;\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row - 1;\n        j = col - 2;\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 1;\n        j = col - 2;\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        return false;\n    }\npublic:\n    bool checkValidGrid(vector<vector<int>>& grid) {\n        ios::sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);\n        if(grid[0][0] != 0) return false;\n        return helper(grid,0,0,1);\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    bool helper(vector<vector<int>>& grid, int row, int col, int num){\\n        int n = grid.size();\\n        if(num == n*n) return true;\\n        int i = row-2;\\n        int j = col+1;\\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row-2;\\n        j = col-1;\\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row + 2;\\n        j = col - 1;\\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row + 2;\\n        j = col + 1;\\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row + 1;\\n        j = col + 2;\\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row - 1;\\n        j = col + 2;\\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row - 1;\\n        j = col - 2;\\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row + 1;\\n        j = col - 2;\\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        return false;\\n    }\\npublic:\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(0);\\n        cout.tie(0);\\n        if(grid[0][0] != 0) return false;\\n        return helper(grid,0,0,1);\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "== and = confusion",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution {\nprivate:\n    bool helper(vector<vector<int>>& grid, int row, int col, int num){\n        int n = grid.size();\n        if(num = n*n) return true;\n        int i = row-2;\n        int j = col+1;\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row-2;\n        j = col-1;\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 2;\n        j = col - 1;\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 2;\n        j = col + 1;\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 1;\n        j = col + 2;\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row - 1;\n        j = col + 2;\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row - 1;\n        j = col - 2;\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 1;\n        j = col - 2;\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        return false;\n    }\npublic:\n    bool checkValidGrid(vector<vector<int>>& grid) {\n        sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);\n        if(grid[0][0] != 0) return false;\n        return helper(grid,0,0,1);\n    }\n};\n"
    },
    {
        "slug": "group-anagrams",
        "description": "Given an array of strings strs, group the anagrams together. You can return the answer in any order.\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.",
        "examples": [
            "Input: strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]\nOutput: [[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]",
            "Input: strs = [\"\"]\nOutput: [[\"\"]]",
            "Input: strs = [\"a\"]\nOutput: [[\"a\"]]"
        ],
        "constraints": "1 <= strs.length <= 104\n0 <= strs[i].length <= 100\nstrs[i] consists of lowercase English letters.",
        "oracle_code": "class Solution {\npublic:\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\n        unordered_map<string,int> m;\n        vector<vector<string>> ans;\n        for(int i=0; i<strs.size(); i++) {\n            string str = strs[i];\n            sort(str.begin(),str.end());\n\n            if(m.find(str) != m.end()) {\n                ans[m[str]].push_back(strs[i]);\n            }\n            else {\n                m[str] = ans.size(); \n                ans.push_back({strs[i]});\n            }\n        }\n        return ans;\n    }\n};",
        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        unordered_map<string,int> m;\\n        vector<vector<string>> ans;\\n        for(int i=0; i<strs.size(); i++) {\\n            string str = strs[i];\\n            sort(str.begin(),str.end());\\n\\n            if(m.find(str) != m.end()) {\\n                ans[m[str]].push_back(strs[i]);\\n            }\\n            else {\\n                m[str] = ans.size(); \\n                ans.push_back({strs[i]});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "statement separation",
            "operation error"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\n        unordered_map<string,int> m;\n        vector<vector<string>> ans;\n        for(int i=0; i<strs.size(); i++) \n            string str = strs[i];\n            sort(str.begin(),str.end());\n\n            if(m.find(str) != m.end()) {\n                ans[m[str]].push_back(str);\n            }\n            else {\n                m[str] = ans.size(); \n                ans.push_back({strs[i]});\n            }\n        }\n        return ans;\n    }\n};\n"
    },
    {
        "slug": "binary-string-with-substrings-representing-1-to-n",
        "description": "Given a binary string s and a positive integer n, return true if the binary representation of all the integers in the range [1, n] are substrings of s, or false otherwise.\nA substring is a contiguous sequence of characters within a string.",
        "examples": [
            "Input: s = \"0110\", n = 3\nOutput: true",
            "Input: s = \"0110\", n = 4\nOutput: false"
        ],
        "constraints": "1 <= s.length <= 1000\ns[i] is either '0' or '1'.\n1 <= n <= 109",
        "oracle_code": "class Solution {\npublic:\n    bool queryString(string s, int n)\n     {\n        unordered_set<int> seen;\n        int len = s.length();\n        for(int i=len-1;i>=0;i--)\n        {\n            int num = 0;\n            for(int j=1;j<=min(len-i,31);j++)\n            { \n                num = num*2 + (s[i+j-1] == '1' ? 1 : 0);\n                if(0 < num && num <= n) seen.insert(num);\n            }\n            if(seen.size() == n) return true;\n        }\n        return false;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool queryString(string s, int n)\\n     {\\n        unordered_set<int> seen;\\n        int len = s.length();\\n        for(int i=len-1;i>=0;i--)\\n        {\\n            int num = 0;\\n            for(int j=1;j<=min(len-i,31);j++)\\n            { \\n                num = num*2 + (s[i+j-1] == \\'1\\' ? 1 : 0);\\n                if(0 < num && num <= n) seen.insert(num);\\n            }\\n            if(seen.size() == n) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "undefined methods",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    bool queryString(string s, int n)\n     {\n        unordered_set<int> seen;\n        int len = s.length();\n        bool doesNotExist;\n        string temp = s + doesNotExist;\n        for(int i=len-1;i>=0;i--)\n        {\n            int num = 0;\n            for(int j=1;j<=min(len-i,31);j++)\n            { \n                num = num*2 + (temp[i+j-1] == '1' ? 1 : 0);\n                if(0 < num && num <= n) seen.insert(num);\n            }\n            if(seen.size() == n) return true;\n        }\n        return isAllNumbersSeen();\n    }\n    \n    bool isAllNumbersSeen()\n    {\n        \n    }\n};\n"
    },
    {
        "slug": "middle-of-the-linked-list",
        "description": "Given the head of a singly linked list, return the middle node of the linked list.\nIf there are two middle nodes, return the second middle node.",
        "examples": [
            "Input: head = [1,2,3,4,5]\nOutput: [3,4,5]\nExplanation: The middle node of the list is node 3.",
            "Input: head = [1,2,3,4,5,6]\nOutput: [4,5,6]\nExplanation: Since the list has two middle nodes with values 3 and 4, we return the second one."
        ],
        "constraints": "The number of nodes in the list is in the range [1, 100].\n1 <= Node.val <= 100",
        "oracle_code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* middleNode(ListNode* head) {\n        ListNode* temp = head;\n        ListNode* mid = head;\n        while(temp != NULL && temp -> next != NULL){\n            mid = mid -> next;\n            temp = temp->next-> next;\n        }\n        return mid;\n    }\n};",
        "content": "## INITIALIZE BOTH POINTS FROM HEAD AND THEN TRAVERSE\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# FIRST POINT SHOULD TRAVERSE AT A NORMAL PACE\\n# BUT THE OTHER POINTER (ie. FAST) SHOULD SKIP ONE NODE AND THUS YOU WILL REACH THE SOLUTION IN O(n) TIME COMPLEXITY.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* middleNode(ListNode* head) {\\n        ListNode* temp = head;\\n        ListNode* mid = head;\\n        while(temp != NULL && temp -> next != NULL){\\n            mid = mid -> next;\\n            temp = temp->next-> next;\\n        }\\n        return mid;\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "operation error",
            "wrong comment mark"
        ],
        "buggy_code": "\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* middleNode(ListNode* head) {\n        ListNode* temp = head;\n        ListNode* mid = head;\n        while(temp != NULL && temp -> next != NULL){\n            mid = mid /*-> next;\n            temp = temp->next;\n        }\n        return mid;\n    }\n};\n"
    },
    {
        "slug": "count-of-range-sum",
        "description": "Given an integer array nums and two integers lower and upper, return the number of range sums that lie in [lower, upper] inclusive.\nRange sum S(i, j) is defined as the sum of the elements in nums between indices i and j inclusive, where i <= j.",
        "examples": [
            "Input: nums = [-2,5,-1], lower = -2, upper = 2\nOutput: 3\nExplanation: The three ranges are: [0,0], [2,2], and [0,2] and their respective sums are: -2, -1, 2.",
            "Input: nums = [0], lower = 0, upper = 0\nOutput: 1"
        ],
        "constraints": "1 <= nums.length <= 105\n-231 <= nums[i] <= 231 - 1\n-105 <= lower <= upper <= 105\nThe answer is guaranteed to fit in a 32-bit integer.",
        "oracle_code": "class Solution {\npublic:\n    \n    int countWithMergeSort(vector<long> &sums, int left, int right, int lower, int upper)\n    {\n        int count = 0;\n        \n        if(right - left <= 1)\n        {\n            if(right - left == 1)\n            {\n                return (lower <= sums[left] && sums[left] <= upper);\n            }\n            else\n            {\n                return 0;\n            }\n        }\n        \n        int mid = (left + right)/2;\n        \n        int leftSideSum = countWithMergeSort(sums, left, mid, lower, upper);\n        int rightSideSum = countWithMergeSort(sums, mid, right, lower, upper);\n        \n        \n        int i = left;\n        int j = mid;\n        \n        int n = 0;\n        int m = 0;\n        \n        vector<long> cache(right - left, 0);\n        \n        int k = 0;\n        \n        \n        while(i < mid)\n        {\n            \n\n            while(mid+n < right && sums[mid+n] < sums[i]+lower)\n                {\n                    n++;\n                }\n            \n            while(mid+m < right && sums[mid+m] <= sums[i] + upper)\n                {\n                    m++;\n                }\n            \n            while(j < right && sums[j] < sums[i])\n            {\n                cache[k++] = sums[j++];\n            }\n            \n            cache[k++] = sums[i++];\n            \n            count += m-n;\n        }\n        \n        \n        while(j < right)\n        {\n            cache[k++] = sums[j++];\n        }\n        \n        \n        for(int idx = 0; idx<cache.size(); idx++)\n        {\n            sums[left + idx] = cache[idx];\n        }\n    \n        return leftSideSum + rightSideSum + count;\n        \n    }\n    \n    int countRangeSum(vector<int>& nums, int lower, int upper) {\n        \n        vector<long> prefixSum(nums.size(),0);\n        \n        int n = nums.size();\n        \n        prefixSum[0] = nums[0];\n        \n        for(int i = 1; i<nums.size(); i++)\n        {\n            prefixSum[i] = nums[i] + prefixSum[i-1];\n        }\n        \n        return countWithMergeSort(prefixSum, 0, n, lower, upper);\n    }\n};",
        "content": "Hello, with this post I want to explain the solution to this problem to those who are encountering this problem for the first time (i.e. have not solved any other problems with this pattern), and are **NEW to solving HARD problems** in general. I will be explaining the solution found in this post https://leetcode.com/problems/count-of-range-sum/discuss/1178174/Java-Clean-Merge-Sort-O(N-logN)-Solution-oror-with-detailed-Explanation because this version of the solution applies commonly known concepts which anyone with basic data structures background should be able to grasp **(no BIT, fenwick tree or anything else which usually is not covered in a basic data structures course)**. Moreover, this approach is also applicable to other problems which are linked in the answer, hence it is most suitable for a beginner looking to learn general approaches/patterns.\\n\\nSo, the naive approach, which after some experience with medium problems, particularly like subarray sum etc. should come to one within a few minutes of thinking: Find the array of prefix sums, then use a nested loop to find all the sums which satisfy the given criteria. Of course O(n^2) will give TLE which is why this is HARD. \\n\\nSince I am also a beginner, I thought about it for a while and then moved on to reading a solution to understand what was the next step.\\n\\nI suppose for someone experienced, they may try some patterns with which n^2 problems are simplified, like DP or divide-and-conquer. The point of the hard problem is to start teaching you to inculcate this thinking of approaches when TLE after the naive solution is reached. So here, the mental question that should come to one\\'s mind is, \\n\\n* For DP: If I know the solution to nums[start:i-1], can I calculate the solution to nums[start:i]?\\n* For divide-and-conquer: If I know the solution to nums[start:mid] and nums[mid+1:end] (where mid = (start+end)/2 and end is the length of the array), can I calculate the solution to nums[start:end]?\\n\\nIn this case, it turns out that there is a divide and conquer solution. The solution is similar to **merge sort**.\\n\\nTake the PREFIX SUM array (and not the original array). Let this be called **sums**. \\n\\nIf we have the solution to the left and right halves of the array, we can find the solution to the complete array by finding suitable pairs of prefix sums, one from the left half and the other from the right half, and adding these to the solution from the left and right halves of the array.\\n\\nNow I will quote the crucial step from here: https://leetcode.com/problems/count-of-range-sum/discuss/1178174/Java-Clean-Merge-Sort-O(N-logN)-Solution-oror-with-detailed-Explanation\\n\\nThe merge sort based solution counts the answer while doing the merge. During the merge stage, we have already sorted the left half [start, mid) and right half [mid, end). We then iterate through the left half with index i. For each i, we need to find two indices k and j in the right half where\\n\\n* j is the first index satisfy sums[j] - sums[i] > upper and\\n* k is the first index satisfy sums[k] - sums[i] >= lower.\\n\\nThen the number of sums in [lower, upper] is j-k.\\n\\nTo understand this, consider any prefix sum after x elements. Consider another prefix sum after y elements such that x <= y. Then, if we know sums[x], then for x and y to form a range with a sum within the lower and upper bounds,  then the conditions sums[y] - sums[x] >= lower and sums[y] - sums[x] <= upper, should be satisfied. \\n\\nThis gives the **condition for y** as sums[y] <= sums[x] + upper and sums[y] >= sums[x] + lower, and y >= x.\\n\\nDuring merge sort note that the **relative ordering between the left and right halves is maintained** before the merging, so letting x belong to the left side of the array, y to the right half of the array maintains x <= y.\\n\\nHence if we make the count for each element in the left half of the array during the merge, then the count is guaranteed to be correct. \\n\\nAlso, due to sorted nature of subarrays used during merge, for a given x in the left subarray, since the right subarray is also sorted, it means that the elements within the desired range sums[x] + lower and sums[x] + upper are **found in a contiguous chunk** of the right subarray. \\n\\nMoreover, since the left subarray is also sorted, sums[x] increases with x **(monotonicity)**. This means that every time x is incremented, we can use the indices obtained for the range in the right subarray for the previous x, instead of starting both from 0, since both sums[x] + lower and sums[x] + upper can only increase. \\n\\n In the quoted bullet points above, the updates ensure that at the end of the updating, the indices cover the required range for each index.\\n\\nThe base case here is that a single element will add to the count if the element value lies between lower and upper otherwise the solution will be zero. \\n\\n**To write the solution** after understanding these steps, I used the following approach: Write merge sort in the usual way. Use two indices/pointers m and n starting from the beginning of the right subarray before the merge. At any block where the left subarray index is updated, update these two m and n. Add these to the total count. The function should return the sum of the counts of the left half, right half and the total count during the merge. \\n\\nMy first working solution in which I used the conventional merge sort template where following the main merge step there are two while loops, had to make the counts twice, once in the nested loop and once in the outside loop (since left subarray index is updated in these places). To get the form of the elegant solutions such as in the linked answer, I made the change to use an alternative form of merging where during every loop iteration, an update to the left index is guaranteed, and the merge concludes when the left subarray is completely traversed. \\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int countWithMergeSort(vector<long> &sums, int left, int right, int lower, int upper)\\n    {\\n        int count = 0;\\n        \\n        if(right - left <= 1)\\n        {\\n            if(right - left == 1)\\n            {\\n                return (lower <= sums[left] && sums[left] <= upper);\\n            }\\n            else\\n            {\\n                return 0;\\n            }\\n        }\\n        \\n        int mid = (left + right)/2;\\n        \\n        int leftSideSum = countWithMergeSort(sums, left, mid, lower, upper);\\n        int rightSideSum = countWithMergeSort(sums, mid, right, lower, upper);\\n        \\n        \\n        int i = left;\\n        int j = mid;\\n        \\n        int n = 0;\\n        int m = 0;\\n        \\n        vector<long> cache(right - left, 0);\\n        \\n        int k = 0;\\n        \\n        \\n        while(i < mid)\\n        {\\n            \\n\\n            while(mid+n < right && sums[mid+n] < sums[i]+lower)\\n                {\\n                    n++;\\n                }\\n            \\n            while(mid+m < right && sums[mid+m] <= sums[i] + upper)\\n                {\\n                    m++;\\n                }\\n            \\n            while(j < right && sums[j] < sums[i])\\n            {\\n                cache[k++] = sums[j++];\\n            }\\n            \\n            cache[k++] = sums[i++];\\n            \\n            count += m-n;\\n        }\\n        \\n        \\n        while(j < right)\\n        {\\n            cache[k++] = sums[j++];\\n        }\\n        \\n        \\n        for(int idx = 0; idx<cache.size(); idx++)\\n        {\\n            sums[left + idx] = cache[idx];\\n        }\\n    \\n        return leftSideSum + rightSideSum + count;\\n        \\n    }\\n    \\n    int countRangeSum(vector<int>& nums, int lower, int upper) {\\n        \\n        vector<long> prefixSum(nums.size(),0);\\n        \\n        int n = nums.size();\\n        \\n        prefixSum[0] = nums[0];\\n        \\n        for(int i = 1; i<nums.size(); i++)\\n        {\\n            prefixSum[i] = nums[i] + prefixSum[i-1];\\n        }\\n        \\n        return countWithMergeSort(prefixSum, 0, n, lower, upper);\\n    }\\n};\\n```\\n\\nAny comments or suggestions are welcome as I am also a beginner (took me 3+ hours to get this) who has spent some time in learning/convincing myself of the approach. I tried to address the points which took up a lot of my time while trying to understand some of the other solutions. \\n\\n\\n\\n\\n",
        "level": "hard",
        "type": [
            "undefined methods",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    \n    int countWithMergeSort(vector<long> &sums, int left, int right, int lower, int upper)\n    {\n        int count = 0;\n\n        if(right - left <= 1) {\n            if(right - left == 1) {\n                return (lower <= sums[left] && sums[left] <= upper);\n            }\n            else\n            {\n                return 0;\n            }\n        }\n\n        int mid = (left + right)/2;\n\n        int leftSideSum = countWithMergeSort(sums, left, mid, lower, upper;\n        int rightSideSum = countWithMergeSort(sums, mid, right, lower, upper);\n\n        int i = left;\n        int j = mid;\n\n        int n = 0;\n        int m = 0;\n\n        vector<long> cache(right - left, 0);\n\n        int k = 0;\n\n        while(i < mid)\n        {\n            while(mid+n < right && sums[mid+n] < sums[i]+lower)\n            {\n                n++;\n            }\n\n            while(mid+m < right && sums[mid+m] <= sums[i] + upper)\n            {\n                m++;\n            }\n\n            while(j < right && sums[j] < sums[i])\n            {\n                cache[k++] = sums[j++];\n            }\n\n            cache[k++] = sums[i++];\n\n            count += m-n;\n        }\n\n        while(j < right)\n        {\n            cache[k++] = sums[j++];\n        }\n\n        for(int idx = 0; idx<cache.size(); idx++)\n        {\n            sums[left + idx] = cache[idx];\n        }\n    \n        return leftSideSum + rightSideSum;\n        \n    }\n\n    int countRangeSum(vector<int>& nums, int lower, int upper) {\n        \n        vector<long> prefixSum(nums.size(),0);\n        \n        int n = nums.size();\n        \n        prefixSum[0] = nums[0];\n        \n        for(int i = 1; i<nums.size(); i++)\n        {\n            prefixSum[i] = nums[i] + prefixSum[i-1];\n        }\n        \n        return countWithMergeSort(prefixSum, 0, n, lower, upper);\n    }\n};\n"
    },
    {
        "slug": "most-frequent-even-element",
        "description": "Given an integer array nums, return the most frequent even element.\nIf there is a tie, return the smallest one. If there is no such element, return -1.",
        "examples": [
            "Input: nums = [0,1,2,2,4,4,1]\nOutput: 2\nExplanation:\nThe even elements are 0, 2, and 4. Of these, 2 and 4 appear the most.\nWe return the smallest one, which is 2.",
            "Input: nums = [4,4,4,9,2,4]\nOutput: 4\nExplanation: 4 is the even element appears the most.",
            "Input: nums = [29,47,21,41,13,37,25,7]\nOutput: -1\nExplanation: There is no even element."
        ],
        "constraints": "1 <= nums.length <= 2000\n0 <= nums[i] <= 105",
        "oracle_code": "class Solution {\npublic:\n    int mostFrequentEven(vector<int>& nums) {\n        int n = nums.size(),i;\n        map<int , int> freq;\n        for(auto x:nums){\n            freq[x]++;\n        }\n        int evefreq=0,ans=-1;\n        for(auto y:freq){\n            if(y.first%2==0 && y.second> evefreq){\n                ans=y.first;\n                evefreq=y.second;\n            }\n        }\n        return ans;\n    }\n};",
        "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mostFrequentEven(vector<int>& nums) {\\n        int n = nums.size(),i;\\n        map<int , int> freq;\\n        for(auto x:nums){\\n            freq[x]++;\\n        }\\n        int evefreq=0,ans=-1;\\n        for(auto y:freq){\\n            if(y.first%2==0 && y.second> evefreq){\\n                ans=y.first;\\n                evefreq=y.second;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "colon missing",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    int mostFrequentEven(vector<int>& nums) {\n        int n = nums.size(),i;\n        map<int , int> freq;\n        for(auto x:nums\n            freq[x]++;\n        }\n        int evefreq=0,ans=-1;\n        for(auto y:freq){\n            if(y.first%2==0 && y.second> evefreq){\n                ans=y.first;\n                evefreq=y.second;\n            }\n        }\n        return ans;\n    }\n};\n"
    },
    {
        "slug": "maximum-gap",
        "description": "Given an integer array nums, return the maximum difference between two successive elements in its sorted form. If the array contains less than two elements, return 0.\nYou must write an algorithm that runs in linear time and uses linear extra space.",
        "examples": [
            "Input: nums = [3,6,9,1]\nOutput: 3\nExplanation: The sorted form of the array is [1,3,6,9], either (3,6) or (6,9) has the maximum difference 3.",
            "Input: nums = [10]\nOutput: 0\nExplanation: The array contains less than 2 elements, therefore return 0."
        ],
        "constraints": "1 <= nums.length <= 105\n0 <= nums[i] <= 109",
        "oracle_code": "class Solution {\npublic:\n\nvector<int> countsort(vector<int> &nums)\n{\n    int n = nums.size();\n    map<int, int> m;\n    for (int i = 0; i < n; i++ )\n        m[nums[i]]++;\n\n    nums.clear();\n    for (auto it : m)\n    {\n        int cnt = it.second;\n        while (cnt--)\n        {\n            nums.push_back(it.first);\n        }\n    }\n    return nums;\n}\n\nint maximumGap(vector<int> &nums)\n{\n    int n = nums.size();\n    if (n < 2)\n        return 0;\n    vector<int> sortednums = countsort(nums);\n\n    int maxgap = INT_MIN;\n    for (int i = 1; i < n; i++)\n    {\n        int currgap = sortednums[i] - sortednums[i - 1];\n        maxgap = max(maxgap, currgap);\n    }\n\n    return maxgap;\n}\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nsince it is given in the question that we can use only linear time and space so we can only use a kind of counting sort , where we required a hash map which take an extra o(n) time complexity.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn counting sort first we required an hash map where we store the frequency of each element and after storing the frequency we just need to fill the original array based on there frequency , here we use an map not unordered map because the map is store value in sorted order.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nwe are traversing the array once , so  it is O(n) and an extra (logn)\\nfactor comes because of using the map, but still it is better in terms of time from inbuilt sort function..\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n) we are using only an map so the total extra space is equal to the size of map.\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\nvector<int> countsort(vector<int> &nums)\\n{\\n    int n = nums.size();\\n    map<int, int> m;\\n    for (int i = 0; i < n; i++ )\\n        m[nums[i]]++;\\n\\n    nums.clear();\\n    for (auto it : m)\\n    {\\n        int cnt = it.second;\\n        while (cnt--)\\n        {\\n            nums.push_back(it.first);\\n        }\\n    }\\n    return nums;\\n}\\n\\nint maximumGap(vector<int> &nums)\\n{\\n    int n = nums.size();\\n    if (n < 2)\\n        return 0;\\n    vector<int> sortednums = countsort(nums);\\n\\n    int maxgap = INT_MIN;\\n    for (int i = 1; i < n; i++)\\n    {\\n        int currgap = sortednums[i] - sortednums[i - 1];\\n        maxgap = max(maxgap, currgap);\\n    }\\n\\n    return maxgap;\\n}\\n};\\n```",
        "level": "medium",
        "type": [
            "wrong comment mark",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n\nvector<int> countsort(vector<int> &nums)\n{\n    int n = nums.size();\n    map<int, int> m;\n    for (int i = 0; /**/ i /*/ < n; i++ )\n        m[nums[i]]++;\n\n    nums.clear();\n    for (auto it : m)\n    {\n        int cnt = it.second;\n        while (cnt--\n        {\n            nums.push_back(it.first);\n        }\n    }\n    return nums;\n}\n\nint maximumGap(vector<int> &nums)\n{\n    int n = nums.size();\n    if (n < 2)\n        return 0;\n    vector<int> sortednums = countsort(nums);\n\n    int maxgap = INT_MIN;\n    for (int i = 1; i < n; i++)\n    {\n        int currgap = sortednums[i] - sortednums[i - 1];\n        maxgap = max(maxgap, currgap);\n    }\n\n    return maxgap;\n}\n};\n"
    },
    {
        "slug": "climbing-stairs",
        "description": "You are climbing a staircase. It takes n steps to reach the top.\nEach time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?",
        "examples": [
            "Input: n = 2\nOutput: 2\nExplanation: There are two ways to climb to the top.\n1. 1 step + 1 step\n2. 2 steps",
            "Input: n = 3\nOutput: 3\nExplanation: There are three ways to climb to the top.\n1. 1 step + 1 step + 1 step\n2. 1 step + 2 steps\n3. 2 steps + 1 step"
        ],
        "constraints": "1 <= n <= 45",
        "oracle_code": "class Solution {\npublic:\n    int solve(int n,vector<int> &dp){\n        //base case\n        if(n<=2)\n          return n;\n        \n        if(dp[n]!=-1) \n          return dp[n]; \n        \n        dp[n]=solve(n-1,dp)+solve(n-2,dp);\n        return dp[n];\n    }\n    int climbStairs(int n) {\n        if(n<=2)\n         return n;\n        vector<int> dp(n+1);\n        for(int i=0;i<=n;i++)\n         dp[i]=-1;\n        \n        return solve(n,dp);\n    }\n};",
        "content": "# Intuition\\nUsing Top - Down Approach -> Recursion + Memorization.\\n\\n# Approach\\nStoring the values of overlapping sub - problems in a vector.\\n\\n# Complexity\\n- Time complexity:\\nO(n) -> As we are visiting all values of n atleast 1 time.\\n\\n- Space complexity:\\nO(n) + O(n)  - > (Recursive calls + Array of size n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int n,vector<int> &dp){\\n        //base case\\n        if(n<=2)\\n          return n;\\n        \\n        if(dp[n]!=-1) \\n          return dp[n]; \\n        \\n        dp[n]=solve(n-1,dp)+solve(n-2,dp);\\n        return dp[n];\\n    }\\n    int climbStairs(int n) {\\n        if(n<=2)\\n         return n;\\n        vector<int> dp(n+1);\\n        for(int i=0;i<=n;i++)\\n         dp[i]=-1;\\n        \\n        return solve(n,dp);\\n    }\\n};\\n```\\n\\n# Intuition\\nUsing Bottom - up Approach -> Tabulation.\\n\\n# Approach\\nStoring the values of overlapping sub - problems in a vector.\\n\\n# Complexity\\n- Time complexity:\\nO(n) -> As we are traversing the vector atleast 1 time.\\n\\n- Space complexity:\\nO(n) - > (Array of size n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n<=2)\\n         return n;\\n        vector<int> dp(n+1);\\n        dp[0]=0;\\n        dp[1]=1;\\n        dp[2]=2;\\n        for(int i=3;i<=n;i++)\\n         dp[i]=dp[i-1]+dp[i-2];\\n        \\n        return dp[n];\\n    }\\n};\\n```\\n\\n# Python Code :\\nContributed by : Aarya_R\\n\\n# Complexity\\n- Time complexity:\\nO(n) -> As we are traversing the vector atleast 1 time.\\n\\n- Space complexity:\\nO(1) \\n```\\ndef climbStairs(self, n):\\n        prev = 1\\n        prev2 = 0\\n        for i in range(1, n+1):\\n            curi = prev + prev2\\n            prev2 = prev\\n            prev = curi\\n        return prev \\n```\\n![upvote.jfif](https://assets.leetcode.com/users/images/995d917b-6ea2-4b6b-8baa-6ce7bc6441fd_1676965776.537627.jpeg)\\n\\n",
        "level": "easy",
        "type": [
            "indexing error",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    int solve(int n,vector<int> &dp){\n        //base case\n        if(n<=2)\n          return n;\n        \n        if(dp[n]!=-1) \n          return dp[n]; \n        \n        dp[n]=solve(n-1,dp)+solve(n-2,dp);\n        return dp[n];\n    }\n    int climbStairs(int n) {\n        if(n<=2)\n         return n;\n        array<int> dp(n);\n        for(int i=0;i<=n;i++)\n         dp[i]=-1;\n        \n        return solve(n,dp);\n    }\n};\n"
    },
    {
        "slug": "maximum-rows-covered-by-columns",
        "description": "You are given a 0-indexed m x n binary matrix matrix and an integer numSelect, which denotes the number of distinct columns you must select from matrix.\nLet us consider s = {c1, c2, ...., cnumSelect} as the set of columns selected by you. A row row is covered by s if:\n\nFor each cell matrix[row][col] (0 <= col <= n - 1) where matrix[row][col] == 1, col is present in s or,\nNo cell in row has a value of 1.\n\nYou need to choose numSelect columns such that the number of rows that are covered is maximized.\nReturn the maximum number of rows that can be covered by a set of numSelect columns.",
        "examples": [
            "Input: matrix = [[0,0,0],[1,0,1],[0,1,1],[0,0,1]], numSelect = 2\nOutput: 3\nExplanation: One possible way to cover 3 rows is shown in the diagram above.\nWe choose s = {0, 2}.\n- Row 0 is covered because it has no occurrences of 1.\n- Row 1 is covered because the columns with value 1, i.e. 0 and 2 are present in s.\n- Row 2 is not covered because matrix[2][1] == 1 but 1 is not present in s.\n- Row 3 is covered because matrix[2][2] == 1 and 2 is present in s.\nThus, we can cover three rows.\nNote that s = {1, 2} will also cover 3 rows, but it can be shown that no more than three rows can be covered.",
            "Input: matrix = [[1],[0]], numSelect = 1\nOutput: 2\nExplanation: Selecting the only column will result in both rows being covered since the entire matrix is selected.\nTherefore, we return 2."
        ],
        "constraints": "m == matrix.length\nn == matrix[i].length\n1 <= m, n <= 12\nmatrix[i][j] is either 0 or 1.\n1 <= numSelect\u00a0<= n",
        "oracle_code": "class Solution {\npublic:\n    // Global Vector to all possible column combinations\n    vector<vector<int>>comb;\n\t\n    // Function to find the number of rows a particular column combination can capture\n    int find(vector<vector<int>>& mat1)\n    {\n        int c = 0;\n        for(int i = 0; i < mat1.size(); i++)\n        {\n            int flg = 0;\n            for(int j = 0; j < mat1[0].size(); j++)\n                if(mat1[i][j] == 1)\n                    flg = 1;\n            if(flg == 0)\n                c++;\n        }\n        return c;\n    }\n    \n\t// Function to Traverse for each Column Combination Present\n    int find_ans(vector<vector<int>>& mat)\n    {\n        int ans = 0;\n        for(int i = 0; i < comb.size(); i++)\n        {\n            vector<int>temp = comb[i];\n            vector<vector<int>> mat1 = mat;\n            for(int j = 0; j < temp.size(); j++)\n            {\n                int col_val = temp[j];\n                for(int k = 0; k < mat1.size(); k++)\n                    mat1[k][col_val] = 0;\n            }\n            ans = max(ans, find(mat1));\n        }\n        return ans;\n    }\n    // Function to Find all possible column combinations\n    void helper(vector<vector<int>>& mat, int cols, int count, int idx, vector<int>tans)\n    {\n        int col = mat[0].size();\n        if(count == cols)\n        {\n            comb.push_back(tans);\n            return;\n        }\n        if(idx >= col)\n            return;\n        \n        helper(mat, cols, count, idx+1, tans);\n        tans.push_back(idx);\n        helper(mat, cols, count+1, idx+1, tans);\n    }\n    \n    int maximumRows(vector<vector<int>>& mat, int cols) {\n        \n        vector<int>tans;\n        helper(mat, cols, 0, 0, tans);\n        return find_ans(mat);\n    }\n};",
        "content": "```\\nclass Solution {\\npublic:\\n    // Global Vector to all possible column combinations\\n    vector<vector<int>>comb;\\n\\t\\n    // Function to find the number of rows a particular column combination can capture\\n    int find(vector<vector<int>>& mat1)\\n    {\\n        int c = 0;\\n        for(int i = 0; i < mat1.size(); i++)\\n        {\\n            int flg = 0;\\n            for(int j = 0; j < mat1[0].size(); j++)\\n                if(mat1[i][j] == 1)\\n                    flg = 1;\\n            if(flg == 0)\\n                c++;\\n        }\\n        return c;\\n    }\\n    \\n\\t// Function to Traverse for each Column Combination Present\\n    int find_ans(vector<vector<int>>& mat)\\n    {\\n        int ans = 0;\\n        for(int i = 0; i < comb.size(); i++)\\n        {\\n            vector<int>temp = comb[i];\\n            vector<vector<int>> mat1 = mat;\\n            for(int j = 0; j < temp.size(); j++)\\n            {\\n                int col_val = temp[j];\\n                for(int k = 0; k < mat1.size(); k++)\\n                    mat1[k][col_val] = 0;\\n            }\\n            ans = max(ans, find(mat1));\\n        }\\n        return ans;\\n    }\\n    // Function to Find all possible column combinations\\n    void helper(vector<vector<int>>& mat, int cols, int count, int idx, vector<int>tans)\\n    {\\n        int col = mat[0].size();\\n        if(count == cols)\\n        {\\n            comb.push_back(tans);\\n            return;\\n        }\\n        if(idx >= col)\\n            return;\\n        \\n        helper(mat, cols, count, idx+1, tans);\\n        tans.push_back(idx);\\n        helper(mat, cols, count+1, idx+1, tans);\\n    }\\n    \\n    int maximumRows(vector<vector<int>>& mat, int cols) {\\n        \\n        vector<int>tans;\\n        helper(mat, cols, 0, 0, tans);\\n        return find_ans(mat);\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "variable value error",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    vector<vector<int>>comb;    \n    int find(vector<vector<int>>& mat1)\n    {\n        int c = 0;\n        for(int i = 0; i < mat1.size(); i++)\n        {\n            int flg = 0;\n            for(int j = 0; j < mat1[0].size(); j++\n                if(mat1[i][j] == 1)\n                    flg = 1;\n            if(flg == 0)\n                c++;\n        }\n        return c;\n    }\n    int find_ans(vector<vector<int>>& mat)\n    {\n        int ans = 0;\n        for(int i = 0; i < comb.size(); i++)\n        {\n            vector<int>temp = comb[i];\n            vector<vector<int>> mat1 = mat;\n            for(int j = 0; j < temp.size(); j++)\n            {\n                int col_val = temp[j];\n                for(int k = 0; k < mat1.size(); k++)\n                    mat1[k][col_val] = 1;\n            }\n            ans = max(ans, find(mat1));\n        }\n        return ans;\n    }\n    void helper(vector<vector<int>>& mat, int cols, int count, int idx, vector<int>tans)\n    {\n        int col = mat[0].size();\n        if(count == cols)\n        {\n            comb.push_back(tans);\n            return;\n        }\n        if(idx >= col)\n            return;\n        \n        helper(mat, cols, count, idx+1, tans);\n        tans.push_back(idx);\n        helper(mat, cols, count+1, idx+1, tans);\n    }\n    int maximumRows(vector<vector<int>>& mat, int cols) {\n        vector<int>tans;\n        helper(mat, cols, 0, 0, tans);\n        return find_ans(mat);\n    }\n};\n"
    },
    {
        "slug": "reverse-odd-levels-of-binary-tree",
        "description": "Given the root of a perfect binary tree, reverse the node values at each odd level of the tree.\n\nFor example, suppose the node values at level 3 are [2,1,3,4,7,11,29,18], then it should become [18,29,11,7,4,3,1,2].\n\nReturn the root of the reversed tree.\nA binary tree is perfect if all parent nodes have two children and all leaves are on the same level.\nThe level of a node is the number of edges along the path between it and the root node.",
        "examples": [
            "Input: root = [2,3,5,8,13,21,34]\nOutput: [2,5,3,8,13,21,34]\nExplanation: \nThe tree has only one odd level.\nThe nodes at level 1 are 3, 5 respectively, which are reversed and become 5, 3.",
            "Input: root = [7,13,11]\nOutput: [7,11,13]\nExplanation: \nThe nodes at level 1 are 13, 11, which are reversed and become 11, 13.",
            "Input: root = [0,1,2,0,0,0,0,1,1,1,1,2,2,2,2]\nOutput: [0,2,1,0,0,0,0,2,2,2,2,1,1,1,1]\nExplanation: \nThe odd levels have non-zero values.\nThe nodes at level 1 were 1, 2, and are 2, 1 after the reversal.\nThe nodes at level 3 were 1, 1, 1, 1, 2, 2, 2, 2, and are 2, 2, 2, 2, 1, 1, 1, 1 after the reversal."
        ],
        "constraints": "The number of nodes in the tree is in the range [1, 214].\n0 <= Node.val <= 105\nroot is a perfect binary tree.",
        "oracle_code": "class Solution {\npublic:\n    TreeNode* reverseOddLevels(TreeNode* root) {\n        queue<TreeNode*> q;\n        q.push(root);\n        int x = 1,n,i,z;\n        vector<TreeNode*> tmp;\n        TreeNode* node;\n        while(!q.empty()){\n            tmp.clear();\n            n = q.size();\n            // cout<<n<<\" \";\n            while(n--){\n                node = q.front();q.pop();\n                // cout<<node->val<<\" \";\n                if(x==0){\n                    tmp.push_back(node);\n                }\n                if(node->left)\n                    q.push(node->left);\n                if(node->right){\n                    q.push(node->right);\n                }\n            }\n            n = tmp.size();\n            for(i = 0; i < n/2; i++){\n                z = tmp[i]->val;\n                tmp[i]->val = tmp[n-1-i]->val;\n                tmp[n-1-i]->val = z;\n            }\n            x ^= 1;\n            n = 0;\n        }\n        return root;\n    }\n};",
        "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* reverseOddLevels(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        int x = 1,n,i,z;\\n        vector<TreeNode*> tmp;\\n        TreeNode* node;\\n        while(!q.empty()){\\n            tmp.clear();\\n            n = q.size();\\n            // cout<<n<<\" \";\\n            while(n--){\\n                node = q.front();q.pop();\\n                // cout<<node->val<<\" \";\\n                if(x==0){\\n                    tmp.push_back(node);\\n                }\\n                if(node->left)\\n                    q.push(node->left);\\n                if(node->right){\\n                    q.push(node->right);\\n                }\\n            }\\n            n = tmp.size();\\n            for(i = 0; i < n/2; i++){\\n                z = tmp[i]->val;\\n                tmp[i]->val = tmp[n-1-i]->val;\\n                tmp[n-1-i]->val = z;\\n            }\\n            x ^= 1;\\n            n = 0;\\n        }\\n        return root;\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "statement separation",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    TreeNode* reverseOddLevels(TreeNode* root) {\n        queue<TreeNode*> q;\n        q.push(root);\n        int x = 1,n,i,z;\n        vector<TreeNode*> tmp;\n        TreeNode* node;\n        while(!q.empty()){\n            tmp.clear();\n            n = q.size();\n            while(n--)node = q.front();q.pop();\n                if(x==0){\n                    tmp.push_back(node);\n                }\n                if(node->left)\n                    q.push(node->left);\n                if(node->right){\n                    q.push(node->right);\n                }\n            n = tmp.size();\n            for(i = 0; i <= n/2; i++){\n                z = tmp[i]->val;\n                tmp[i]->val = tmp[n-1-i]->val;\n                tmp[n-1-i]->val = z;\n            }\n            x ^= 1;\n            n = 0;\n        }\n        return root;\n    }\n};\n"
    },
    {
        "slug": "perfect-squares",
        "description": "Given an integer n, return the least number of perfect square numbers that sum to n.\nA perfect square is an integer that is the square of an integer; in other words, it is the product of some integer with itself. For example, 1, 4, 9, and 16 are perfect squares while 3 and 11 are not.",
        "examples": [
            "Input: n = 12\nOutput: 3\nExplanation: 12 = 4 + 4 + 4.",
            "Input: n = 13\nOutput: 2\nExplanation: 13 = 4 + 9."
        ],
        "constraints": "1 <= n <= 104",
        "oracle_code": "class Solution {\npublic:\n\n    // declare a dp\n\n    int dp[105][10005];\n\n    int helper(vector<int>& arr, int i, int n, int sum)\n    {\n        // base case\n\n        if(sum == 0)\n        {\n            return 0;\n        }\n\n        if(i >= n || sum < 0)\n        {\n            return INT_MAX - 1000;\n        }\n\n        // if already calculated\n\n        if(dp[i][sum] != -1)\n        {\n            return dp[i][sum];\n        }\n\n        // at each ith element we have two options either include or exclude\n\n        int mini = INT_MAX;\n\n        // inclusion part\n\n        if(arr[i] <= sum)\n        {\n            mini = min(mini, 1 + helper(arr, i, n, sum - arr[i]));\n        }\n\n        // exclusion part\n\n        mini = min(mini, helper(arr, i + 1, n, sum));\n\n        // store the res in dp\n\n        return dp[i][sum] = mini;\n    }\n\n    int numSquares(int n) {\n\n        vector<int> arr;\n\n        // find all the squares between 1 to n\n\n        for(int i = 1; i * i <= n; i++)\n        {\n            arr.push_back(i * i);\n        }\n\n        // initialize dp with -1\n\n        memset(dp, -1, sizeof(dp));\n\n        return helper(arr, 0, arr.size(), n);\n    }\n};",
        "content": "* ***Using Recursion && Memoization***\\n\\n* ***Time Complexity :- O(N * sqrt(N))***\\n\\n* ***Space Complexity :- O(N * sqrt(N))***\\n\\n* ***There are sqrt(N), squares between 1 to N***\\n\\n```\\nclass Solution {\\npublic:\\n\\n    // declare a dp\\n\\n    int dp[105][10005];\\n\\n    int helper(vector<int>& arr, int i, int n, int sum)\\n    {\\n        // base case\\n\\n        if(sum == 0)\\n        {\\n            return 0;\\n        }\\n\\n        if(i >= n || sum < 0)\\n        {\\n            return INT_MAX - 1000;\\n        }\\n\\n        // if already calculated\\n\\n        if(dp[i][sum] != -1)\\n        {\\n            return dp[i][sum];\\n        }\\n\\n        // at each ith element we have two options either include or exclude\\n\\n        int mini = INT_MAX;\\n\\n        // inclusion part\\n\\n        if(arr[i] <= sum)\\n        {\\n            mini = min(mini, 1 + helper(arr, i, n, sum - arr[i]));\\n        }\\n\\n        // exclusion part\\n\\n        mini = min(mini, helper(arr, i + 1, n, sum));\\n\\n        // store the res in dp\\n\\n        return dp[i][sum] = mini;\\n    }\\n\\n    int numSquares(int n) {\\n\\n        vector<int> arr;\\n\\n        // find all the squares between 1 to n\\n\\n        for(int i = 1; i * i <= n; i++)\\n        {\\n            arr.push_back(i * i);\\n        }\\n\\n        // initialize dp with -1\\n\\n        memset(dp, -1, sizeof(dp));\\n\\n        return helper(arr, 0, arr.size(), n);\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "conditional statement error",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n\n    int dp[105][10005];\n\n    int helper(vector<int>& arr, int i, int n, int sum)\n    {\n        if(i >= n || sum <= 0) \n        {\n            return INT_MAX - 1000;\n        }\n\n        if(dp[i][sum] != -1)\n        {\n            return dp[i][sum];\n        }\n\n        int mini = INT_MAX;\n\n        if(arr[i] <= sum)\n        {\n            mini = min(mini, 1 + helper(arr, i, n, sum - arr[i]));\n        }\n\n        mini = min(mini, helper(arr, i + 1, n, sum));\n\n        return dp[i][sum] = mini;\n    }\n\n    int numSquares(int n) {\n\n        vector<int> arr;\n\n        for(int i = 1; i * i <= n; i++)\n        {\n            arr.push_back(i * i);\n        }\n\n        memset(dp, -1, sizeof(dp));\n\n        \n        print(helper(arr, 0, arr.size(), n));\n    }\n};\n"
    },
    {
        "slug": "valid-number",
        "description": "A valid number can be split up into these components (in order):\n\nA decimal number or an integer.\n(Optional) An 'e' or 'E', followed by an integer.\n\nA decimal number can be split up into these components (in order):\n\n(Optional) A sign character (either '+' or '-').\nOne of the following formats:\n\t\nOne or more digits, followed by a dot '.'.\nOne or more digits, followed by a dot '.', followed by one or more digits.\nA dot '.', followed by one or more digits.\n\n\n\nAn integer can be split up into these components (in order):\n\n(Optional) A sign character (either '+' or '-').\nOne or more digits.\n\nFor example, all the following are valid numbers: [\"2\", \"0089\", \"-0.1\", \"+3.14\", \"4.\", \"-.9\", \"2e10\", \"-90E3\", \"3e+7\", \"+6e-1\", \"53.5e93\", \"-123.456e789\"], while the following are not valid numbers: [\"abc\", \"1a\", \"1e\", \"e3\", \"99e2.5\", \"--6\", \"-+3\", \"95a54e53\"].\nGiven a string s, return true if s is a valid number.",
        "examples": [
            "Input: s = \"0\"\nOutput: true",
            "Input: s = \"e\"\nOutput: false",
            "Input: s = \".\"\nOutput: false"
        ],
        "constraints": "1 <= s.length <= 20\ns consists of only English letters (both uppercase and lowercase), digits (0-9), plus '+', minus '-', or dot '.'.",
        "oracle_code": "class Solution {\npublic:\n    bool isNumber(string s) {\n        int n = s.length();\n        int i = 0;\n\n        // Skip leading white space\n        while (i < n && isspace(s[i])) {\n            i++;\n        }\n\n        // Check optional sign\n        if (i < n && (s[i] == '+' || s[i] == '-')) {\n            i++;\n        }\n\n        // Check digits before decimal point\n        bool hasDigits = false;\n        while (i < n && isdigit(s[i])) {\n            i++;\n            hasDigits = true;\n        }\n\n        // Check optional decimal point and digits after it\n        if (i < n && s[i] == '.') {\n            i++;\n            while (i < n && isdigit(s[i])) {\n                i++;\n                hasDigits = true;\n            }\n        }\n\n        // Check optional exponent part\n        if (hasDigits && i < n && (s[i] == 'e' || s[i] == 'E')) {\n            i++;\n\n            // Check optional sign in exponent\n            if (i < n && (s[i] == '+' || s[i] == '-')) {\n                i++;\n            }\n\n            bool hasExponentDigits = false;\n            while (i < n && isdigit(s[i])) {\n                i++;\n                hasExponentDigits = true;\n            }\n\n            // The exponent must have at least one digit\n            if (!hasExponentDigits) {\n                return false;\n            }\n        }\n\n        // Check trailing white space\n        while (i < n && isspace(s[i])) {\n            i++;\n        }\n\n        // The number is valid if we consumed the entire string and found at least one digit\n        return i == n && hasDigits;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isNumber(string s) {\\n        int n = s.length();\\n        int i = 0;\\n\\n        // Skip leading white space\\n        while (i < n && isspace(s[i])) {\\n            i++;\\n        }\\n\\n        // Check optional sign\\n        if (i < n && (s[i] == \\'+\\' || s[i] == \\'-\\')) {\\n            i++;\\n        }\\n\\n        // Check digits before decimal point\\n        bool hasDigits = false;\\n        while (i < n && isdigit(s[i])) {\\n            i++;\\n            hasDigits = true;\\n        }\\n\\n        // Check optional decimal point and digits after it\\n        if (i < n && s[i] == \\'.\\') {\\n            i++;\\n            while (i < n && isdigit(s[i])) {\\n                i++;\\n                hasDigits = true;\\n            }\\n        }\\n\\n        // Check optional exponent part\\n        if (hasDigits && i < n && (s[i] == \\'e\\' || s[i] == \\'E\\')) {\\n            i++;\\n\\n            // Check optional sign in exponent\\n            if (i < n && (s[i] == \\'+\\' || s[i] == \\'-\\')) {\\n                i++;\\n            }\\n\\n            bool hasExponentDigits = false;\\n            while (i < n && isdigit(s[i])) {\\n                i++;\\n                hasExponentDigits = true;\\n            }\\n\\n            // The exponent must have at least one digit\\n            if (!hasExponentDigits) {\\n                return false;\\n            }\\n        }\\n\\n        // Check trailing white space\\n        while (i < n && isspace(s[i])) {\\n            i++;\\n        }\\n\\n        // The number is valid if we consumed the entire string and found at least one digit\\n        return i == n && hasDigits;\\n    }\\n};\\n```",
        "level": "hard",
        "type": [
            "conditional statement error",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    bool isNumber(string s) {\n        int n = s.length();\n        int i = 0;\n\n        // Skip leading white space\n        while (i < n && isspace(s[i])) {\n            i++;\n        }\n\n        // Check optional sign\n        if (i < n && (s[i] == '+' || s[i] == '-')) {\n            i++;\n        }\n\n        // Check digits before decimal point\n        bool hasDigits = false;\n        while (i < n && isdigit(s[i])) {\n            i++;\n            hasDigits = true;\n        }\n\n        // Check optional decimal point and digits after it\n        if (i < n && s[i] == '.') {\n            i++;\n            while (i < n && isdigit(s[i] {\n                i++;\n                hasDigits = true;\n            }\n        }\n\n        // Check optional exponent part\n        if (hasDigits && i < n && (s[i] == 'e' || s[i] == 'E')) {\n            i++;\n\n            // Check optional sign in exponent\n            if (i < n && (s[i] == '+' || s[i] == '-')) {\n                i++;\n            }\n\n            bool hasExponentDigits = false;\n            while (i < n && isdigit(s[i])) {\n                i++;\n                hasExponentDigits = true;\n            }\n\n            // The exponent must have at least one digit\n            if (!hasDigits) {\n                return false;\n            }\n        }\n\n        // Check trailing white space\n        while (i < n && isspace(s[i])) {\n            i++;\n        }\n\n        // The number is valid if we consumed the entire string and found at least one digit\n        return i == n && hasDigits;\n    }\n};\n"
    },
    {
        "slug": "maximum-number-of-ways-to-partition-an-array",
        "description": "You are given a 0-indexed integer array nums of length n. The number of ways to partition nums is the number of pivot indices that satisfy both conditions:\n\n1 <= pivot < n\nnums[0] + nums[1] + ... + nums[pivot - 1] == nums[pivot] + nums[pivot + 1] + ... + nums[n - 1]\n\nYou are also given an integer k. You can choose to change the value of one element of nums to k, or to leave the array unchanged.\nReturn the maximum possible number of ways to partition nums to satisfy both conditions after changing at most one element.",
        "examples": [
            "Input: nums = [2,-1,2], k = 3\nOutput: 1\nExplanation: One optimal approach is to change nums[0] to k. The array becomes [3,-1,2].\nThere is one way to partition the array:\n- For pivot = 2, we have the partition [3,-1 | 2]: 3 + -1 == 2.",
            "Input: nums = [0,0,0], k = 1\nOutput: 2\nExplanation: The optimal approach is to leave the array unchanged.\nThere are two ways to partition the array:\n- For pivot = 1, we have the partition [0 | 0,0]: 0 == 0 + 0.\n- For pivot = 2, we have the partition [0,0 | 0]: 0 + 0 == 0.",
            "Input: nums = [22,4,-25,-20,-15,15,-16,7,19,-10,0,-13,-14], k = -33\nOutput: 4\nExplanation: One optimal approach is to change nums[2] to k. The array becomes [22,4,-33,-20,-15,15,-16,7,19,-10,0,-13,-14].\nThere are four ways to partition the array."
        ],
        "constraints": "n == nums.length\n2 <= n <= 105\n-105 <= k, nums[i] <= 105",
        "oracle_code": "class Solution {\npublic:\n    long long int getSum(vector<int> &nums){\n        long long int temp = 0;\n        for(auto &i : nums) temp += i;\n        return temp;\n    }\n\n    bool check(unordered_map<long long int, pair<int, int>> &mp, long long int val, int pivot, bool flag){\n        \n        // If flag, then we need to change element from right subarray\n        if(flag){\n            if(mp[val].second >= pivot) return true;\n            return false;\n        }\n\n        // Else we need to change element from left subarray\n        else{\n            if(mp[val].first < pivot) return true;\n            return false;\n        }\n    }\n\n    int waysToPartition(vector<int>& nums, int k) {\n        unordered_map<long long int, pair<int, int>> mp;\n        unordered_map<long long int, pair<int, int>> count;\n\n        // mp stores first and last occurence of an element\n        for(int i=0; i<nums.size(); i++){\n            if(mp.find(nums[i]) == mp.end()){\n                mp[nums[i]].first = i;\n            }\n            mp[nums[i]].second = i;\n        }\n\n        long long int totSum = getSum(nums);\n        long long int left = nums[0];\n        int ans = 0;\n\n        for(int i=1; i<nums.size(); i++){\n            long long int right = totSum - left;\n\n            if(left == right){\n                ans++;\n            }\n            else{\n                long long int diff = left - right;\n\n                // num is the value of element we need to change with k wo satisfy the condition\n                long long int num = k - diff;\n\n                if(mp.find(num) != mp.end()){\n                    if(check(mp, num, i, 1)){\n\n                        // count.second means we have got the element in right subarray with which we can replace our k\n                        count[num].second++;\n                    }\n                }\n\n                diff = right - left;\n                num = k - diff;\n\n                if(mp.find(num) != mp.end()){\n                    if(check(mp, num, i, 0)){\n\n                        // count.first means we got element in left subarray to get replaced \n\n                        count[num].first++; \n                    }\n                }\n            }\n\n            left += nums[i];\n\n            // Suppose there is an element which was on the right side earlier but now as we moving, it came to the left side, so update left usage with it\n            count[nums[i]].first = max(count[nums[i]].first, count[nums[i]].second);\n        }\n\n        int maxi = INT_MIN;\n        for(auto [i,j] : count){\n            maxi = max(maxi, max(j.first, j.second));\n        }\n\n        return max(maxi, ans);\n    }\n};",
        "content": "# Intuition\\nTry to play between left and right subarray in form of variables.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long int getSum(vector<int> &nums){\\n        long long int temp = 0;\\n        for(auto &i : nums) temp += i;\\n        return temp;\\n    }\\n\\n    bool check(unordered_map<long long int, pair<int, int>> &mp, long long int val, int pivot, bool flag){\\n        \\n        // If flag, then we need to change element from right subarray\\n        if(flag){\\n            if(mp[val].second >= pivot) return true;\\n            return false;\\n        }\\n\\n        // Else we need to change element from left subarray\\n        else{\\n            if(mp[val].first < pivot) return true;\\n            return false;\\n        }\\n    }\\n\\n    int waysToPartition(vector<int>& nums, int k) {\\n        unordered_map<long long int, pair<int, int>> mp;\\n        unordered_map<long long int, pair<int, int>> count;\\n\\n        // mp stores first and last occurence of an element\\n        for(int i=0; i<nums.size(); i++){\\n            if(mp.find(nums[i]) == mp.end()){\\n                mp[nums[i]].first = i;\\n            }\\n            mp[nums[i]].second = i;\\n        }\\n\\n        long long int totSum = getSum(nums);\\n        long long int left = nums[0];\\n        int ans = 0;\\n\\n        for(int i=1; i<nums.size(); i++){\\n            long long int right = totSum - left;\\n\\n            if(left == right){\\n                ans++;\\n            }\\n            else{\\n                long long int diff = left - right;\\n\\n                // num is the value of element we need to change with k wo satisfy the condition\\n                long long int num = k - diff;\\n\\n                if(mp.find(num) != mp.end()){\\n                    if(check(mp, num, i, 1)){\\n\\n                        // count.second means we have got the element in right subarray with which we can replace our k\\n                        count[num].second++;\\n                    }\\n                }\\n\\n                diff = right - left;\\n                num = k - diff;\\n\\n                if(mp.find(num) != mp.end()){\\n                    if(check(mp, num, i, 0)){\\n\\n                        // count.first means we got element in left subarray to get replaced \\n\\n                        count[num].first++; \\n                    }\\n                }\\n            }\\n\\n            left += nums[i];\\n\\n            // Suppose there is an element which was on the right side earlier but now as we moving, it came to the left side, so update left usage with it\\n            count[nums[i]].first = max(count[nums[i]].first, count[nums[i]].second);\\n        }\\n\\n        int maxi = INT_MIN;\\n        for(auto [i,j] : count){\\n            maxi = max(maxi, max(j.first, j.second));\\n        }\\n\\n        return max(maxi, ans);\\n    }\\n};\\n```",
        "level": "hard",
        "type": [
            "indexing error",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    long long int getSum(vector<int> &nums){\n        long long int temp = 0;\n        for(auto &i : nums) temp += i;\n        return temp;\n    }\n\n    bool check(unordered_map<long long int, pair<int, int>> &mp, long long int val, int pivot, bool flag){\n        \n        if(flag){\n            if(mp[val].second >= pivot) return true;\n            return false;\n        }\n        else{\n            if(mp[val].first < pivot) return true;\n            return false;\n        }\n    }\n\n    int waysToPartition(vector<int>& nums, int k) {\n        unordered_map<long long int, pair<int, int>> mp;\n        unordered_map<long long int, pair<int, int>> count;\n\n        for(int i=0; i<=nums.size(); i++){\n            if(mp.find(nums[i]) == mp.end()){\n                mp[nums[i]].first = i;\n            }\n            mp[nums[i]].second = i;\n        }\n\n        long long int totSum = calculateSum(nums);\n        long long int left = nums[0];\n        int ans = 0;\n\n        for(int i=1; i<nums.size(); i++){\n            long long int right = totSum - left;\n\n            if(left == right){\n                ans++;\n            }\n            else{\n                long long int diff = left - right;\n                long long int num = k - diff;\n\n                if(mp.find(num) != mp.end()){\n                    if(check(mp, num, i, 1)){\n                        count[num].second++;\n                    }\n                }\n\n                diff = right - left;\n                num = k - diff;\n\n                if(mp.find(num) != mp.end()){\n                    if(check(mp, num, i, 0)){\n                        count[num].first++; \n                    }\n                }\n            }\n\n            left += nums[i];\n            count[nums[i]].first = max(count[nums[i]].first, count[nums[i]].second);\n        }\n\n        int maxi = INT_MIN;\n        for(auto [i,j] : count){\n            maxi = max(maxi, max(j.first, j.second));\n        }\n\n        return max(maxi, ans);\n    }\n};\n"
    },
    {
        "slug": "minimum-incompatibility",
        "description": "You are given an integer array nums\u200b\u200b\u200b and an integer k. You are asked to distribute this array into k subsets of equal size such that there are no two equal elements in the same subset.\nA subset's incompatibility is the difference between the maximum and minimum elements in that array.\nReturn the minimum possible sum of incompatibilities of the k subsets after distributing the array optimally, or return -1 if it is not possible.\nA subset is a group integers that appear in the array with no particular order.",
        "examples": [
            "Input: nums = [1,2,1,4], k = 2\nOutput: 4\nExplanation: The optimal distribution of subsets is [1,2] and [1,4].\nThe incompatibility is (2-1) + (4-1) = 4.\nNote that [1,1] and [2,4] would result in a smaller sum, but the first subset contains 2 equal elements.",
            "Input: nums = [6,3,8,1,3,1,2,2], k = 4\nOutput: 6\nExplanation: The optimal distribution of subsets is [1,2], [2,3], [6,8], and [1,3].\nThe incompatibility is (2-1) + (3-2) + (8-6) + (3-1) = 6.",
            "Input: nums = [5,3,3,6,3,3], k = 3\nOutput: -1\nExplanation: It is impossible to distribute nums into 3 subsets where no two elements are equal in the same subset."
        ],
        "constraints": "1 <= k <= nums.length <= 16\nnums.length is divisible by k\n1 <= nums[i] <= nums.length",
        "oracle_code": "class Solution {\npublic:\n    const int inf = 0x3f3f3f3f;\n    int minimumIncompatibility(vector<int>& nums, int k) {\n      int n = nums.size();\n      int sz = n/k; // size of every group\n      //dp(mask, i) select mask, pre select i\n      //if (bit set of mask) == sz, select first available\n      //else select first after i available\n      sort(nums.begin(), nums.end());\n      int dp[1<<n][n];\n      memset(dp, inf, sizeof(dp));\n      for (int i = 0; i < n; ++i) { dp[0][i] = 0; }\n      for (int m = 0; m < (1<<n)-1; ++m) {\n        int cnt = __builtin_popcount(m);\n        for (int i = 0; i < n; ++i) {\n          if (dp[m][i] == inf) { continue; }\n          if (cnt%sz == 0) {\n            int j = __builtin_ffs(~m)-1;\n            dp[m|(1<<j)][j] = min(dp[m|(1<<j)][j],dp[m][i]);\n          } else {\n            for (int j = i+1; j < n; ++j) {\n              if (m&(1<<j) || nums[j] == nums[i]) { continue; }\n              dp[m|(1<<j)][j] = min(dp[m|(1<<j)][j],dp[m][i]+nums[j]-nums[i]);\n            }\n          }\n        }\n      }\n      return dp[(1<<n)-1][n-1] == inf? -1: dp[(1<<n)-1][n-1];\n    }\n};",
        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    const int inf = 0x3f3f3f3f;\\n    int minimumIncompatibility(vector<int>& nums, int k) {\\n      int n = nums.size();\\n      int sz = n/k; // size of every group\\n      //dp(mask, i) select mask, pre select i\\n      //if (bit set of mask) == sz, select first available\\n      //else select first after i available\\n      sort(nums.begin(), nums.end());\\n      int dp[1<<n][n];\\n      memset(dp, inf, sizeof(dp));\\n      for (int i = 0; i < n; ++i) { dp[0][i] = 0; }\\n      for (int m = 0; m < (1<<n)-1; ++m) {\\n        int cnt = __builtin_popcount(m);\\n        for (int i = 0; i < n; ++i) {\\n          if (dp[m][i] == inf) { continue; }\\n          if (cnt%sz == 0) {\\n            int j = __builtin_ffs(~m)-1;\\n            dp[m|(1<<j)][j] = min(dp[m|(1<<j)][j],dp[m][i]);\\n          } else {\\n            for (int j = i+1; j < n; ++j) {\\n              if (m&(1<<j) || nums[j] == nums[i]) { continue; }\\n              dp[m|(1<<j)][j] = min(dp[m|(1<<j)][j],dp[m][i]+nums[j]-nums[i]);\\n            }\\n          }\\n        }\\n      }\\n      return dp[(1<<n)-1][n-1] == inf? -1: dp[(1<<n)-1][n-1];\\n    }\\n};\\n```",
        "level": "hard",
        "type": [
            "== and = confusion",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    const int inf = 0x3f3f3f3f;\n    int minimumIncompatibility(vector<int>& nums, int k) {\n      int n = nums.size();\n      int sz = n/k; // size of every group\n      sort(nums.begin(), nums.end());\n      int dp[1<<n][n+1];  \n      memset(dp, inf, sizeof(dp));\n      for (int i = 0; i <= n; ++i) { dp[0][i] = 0; }  \n      for (int m = 0; m < (1<<n)-1; ++m) {\n        int cnt = __builtin_popcount(m);\n        for (int i = 0; i <= n; ++i) {  \n          if (dp[m][i] == inf) { continue; }\n          if (cnt%sz == 0) {\n            int j = __builtin_ffs(~m)-1;\n            dp[m|(1<<j)][j] = dp[m|(1<<j)][j]; \n          } else {\n            for (int j = i+1; j <= n; ++j) { \n              if (m&(1<<j) || nums[j] == nums[i]) { continue; }\n              dp[m|(1<<j)][j] = min(dp[m|(1<<j)][j],dp[m][i]+nums[j]-nums[i]);\n            }\n          }\n        }\n      }\n      return dp[(1<<n)-1][n] == inf? -1: dp[(1<<n)-1][n];  \n    }\n};\n"
    },
    {
        "slug": "minimum-cost-for-tickets",
        "description": "You have planned some train traveling one year in advance. The days of the year in which you will travel are given as an integer array days. Each day is an integer from 1 to 365.\nTrain tickets are sold in three different ways:\n\na 1-day pass is sold for costs[0] dollars,\na 7-day pass is sold for costs[1] dollars, and\na 30-day pass is sold for costs[2] dollars.\n\nThe passes allow that many days of consecutive travel.\n\nFor example, if we get a 7-day pass on day 2, then we can travel for 7 days: 2, 3, 4, 5, 6, 7, and 8.\n\nReturn the minimum number of dollars you need to travel every day in the given list of days.",
        "examples": [
            "Input: days = [1,4,6,7,8,20], costs = [2,7,15]\nOutput: 11\nExplanation: For example, here is one way to buy passes that lets you travel your travel plan:\nOn day 1, you bought a 1-day pass for costs[0] = $2, which covered day 1.\nOn day 3, you bought a 7-day pass for costs[1] = $7, which covered days 3, 4, ..., 9.\nOn day 20, you bought a 1-day pass for costs[0] = $2, which covered day 20.\nIn total, you spent $11 and covered all the days of your travel.",
            "Input: days = [1,2,3,4,5,6,7,8,9,10,30,31], costs = [2,7,15]\nOutput: 17\nExplanation: For example, here is one way to buy passes that lets you travel your travel plan:\nOn day 1, you bought a 30-day pass for costs[2] = $15 which covered days 1, 2, ..., 30.\nOn day 31, you bought a 1-day pass for costs[0] = $2 which covered day 31.\nIn total, you spent $17 and covered all the days of your travel."
        ],
        "constraints": "1 <= days.length <= 365\n1 <= days[i] <= 365\ndays is in strictly increasing order.\ncosts.length == 3\n1 <= costs[i] <= 1000",
        "oracle_code": "class Solution {\npublic:\n    int helper(vector<int>&costs,vector<int>&days,int ind,vector<int>&dp){\n        if(ind<0){return 0;}\n        if(dp[days[ind]]!=-1){return dp[days[ind]];}\n        int daypoint=costs[0]+helper(costs,days,ind-1,dp);\n        int indweek=upper_bound(days.begin(),days.end(),days[ind]-7)-days.begin();\n        indweek--;\n        int weekpoint=costs[1]+helper(costs,days,indweek,dp);\n        int indmonth=upper_bound(days.begin(),days.end(),days[ind]-30)-days.begin();\n        indmonth--;\n        int monthpoint=costs[2]+helper(costs,days,indmonth,dp);\n        return dp[days[ind]]=min({daypoint,weekpoint,monthpoint});\n    }\n\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\n        int n=days.size();\n        vector<int>dp(366,-1);\n        return helper(costs,days,n-1,dp);\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. --> apply dp on 365 days..similar to striver soln\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int helper(vector<int>&costs,vector<int>&days,int ind,vector<int>&dp){\\n        if(ind<0){return 0;}\\n        if(dp[days[ind]]!=-1){return dp[days[ind]];}\\n        int daypoint=costs[0]+helper(costs,days,ind-1,dp);\\n        int indweek=upper_bound(days.begin(),days.end(),days[ind]-7)-days.begin();\\n        indweek--;\\n        int weekpoint=costs[1]+helper(costs,days,indweek,dp);\\n        int indmonth=upper_bound(days.begin(),days.end(),days[ind]-30)-days.begin();\\n        indmonth--;\\n        int monthpoint=costs[2]+helper(costs,days,indmonth,dp);\\n        return dp[days[ind]]=min({daypoint,weekpoint,monthpoint});\\n    }\\n\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int n=days.size();\\n        vector<int>dp(366,-1);\\n        return helper(costs,days,n-1,dp);\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "variable value error",
            "colon missing"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    int helper(vector<int>&costs,vector<int>&days,int ind,vector<int>&dp){\n        if(ind<0){return 0;}\n        if(dp[days[ind]]!=-1){return dp[days[ind]];}\n        int daypoint=costs[0]+helper(costs,days,ind-1,dp)\n        int indweek=upper_bound(days.begin(),days.end(),days[ind-1]-7)-days.begin();\n        indweek--;\n        int weekpoint=costs[1]+helper(costs,days,indweek,dp);\n        int indmonth=upper_bound(days.begin(),days.end(),days[ind-1]-30)-days.begin();\n        indmonth--;\n        int monthpoint=costs[2]+helper(costs,days,indmonth,dp);\n        return dp[days[ind]]=min({daypoint,weekpoint,monthpoint});\n    }\n\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\n        int n=days.size();\n        vector<int>dp(366,-1);\n        return helper(costs,days,n-1,dp);\n    }\n};\n"
    },
    {
        "slug": "remove-outermost-parentheses",
        "description": "A valid parentheses string is either empty \"\", \"(\" + A + \")\", or A + B, where A and B are valid parentheses strings, and + represents string concatenation.\n\nFor example, \"\", \"()\", \"(())()\", and \"(()(()))\" are all valid parentheses strings.\n\nA valid parentheses string s is primitive if it is nonempty, and there does not exist a way to split it into s = A + B, with A and B nonempty valid parentheses strings.\nGiven a valid parentheses string s, consider its primitive decomposition: s = P1 + P2 + ... + Pk, where Pi are primitive valid parentheses strings.\nReturn s after removing the outermost parentheses of every primitive string in the primitive decomposition of s.",
        "examples": [
            "Input: s = \"(()())(())\"\nOutput: \"()()()\"\nExplanation: \nThe input string is \"(()())(())\", with primitive decomposition \"(()())\" + \"(())\".\nAfter removing outer parentheses of each part, this is \"()()\" + \"()\" = \"()()()\".",
            "Input: s = \"(()())(())(()(()))\"\nOutput: \"()()()()(())\"\nExplanation: \nThe input string is \"(()())(())(()(()))\", with primitive decomposition \"(()())\" + \"(())\" + \"(()(()))\".\nAfter removing outer parentheses of each part, this is \"()()\" + \"()\" + \"()(())\" = \"()()()()(())\".",
            "Input: s = \"()()\"\nOutput: \"\"\nExplanation: \nThe input string is \"()()\", with primitive decomposition \"()\" + \"()\".\nAfter removing outer parentheses of each part, this is \"\" + \"\" = \"\"."
        ],
        "constraints": "1 <= s.length <= 105\ns[i] is either '(' or ')'.\ns is a valid parentheses string.",
        "oracle_code": "class Solution {\npublic:\n    string removeOuterParentheses(string s) {\n        stack<char> st;\n        string res=\"\";\n        for(int i=0;i<s.size();i++){\n            if(s[i]=='(' && st.empty()){\n                st.push(s[i]);\n            }\n            else if(s[i]=='('){\n                st.push(s[i]);\n                res+=s[i];\n            }\n            else{\n                st.pop();\n                if(st.size()){\n                    res+=s[i];\n                }\n            }\n        }\n        return res;\n    }\n};",
        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        stack<char> st;\\n        string res=\"\";\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'(\\' && st.empty()){\\n                st.push(s[i]);\\n            }\\n            else if(s[i]==\\'(\\'){\\n                st.push(s[i]);\\n                res+=s[i];\\n            }\\n            else{\\n                st.pop();\\n                if(st.size()){\\n                    res+=s[i];\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "== and = confusion",
            "colon missing"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    string removeOuterParentheses(string s) {\n        stack<char> st;\n        string res=\"\";\n        for(int i=0;i<s.size();i++)\n            if(s[i]=='(' && st.empty())\n                st.push(s[i]);\n            else if(s[i]=='(')\n                st.push(s[i]);\n                res+=s[i];\n            else{\n                st.pop();\n                if(st.size())\n                    res+=s[i];\n                }\n        }\n        =1return res;\n    }\n};\n\n"
    },
    {
        "slug": "find-all-numbers-disappeared-in-an-array",
        "description": "Given an array nums of n integers where nums[i] is in the range [1, n], return an array of all the integers in the range [1, n] that do not appear in nums.",
        "examples": [
            "Input: nums = [4,3,2,7,8,2,3,1]\nOutput: [5,6]",
            "Input: nums = [1,1]\nOutput: [2]"
        ],
        "constraints": "n == nums.length\n1 <= n <= 105\n1 <= nums[i] <= n",
        "oracle_code": "class Solution {\npublic:\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\n        int n = nums.size();\n        int i = 0;\n        while (i<n) {\n            if (nums[i] != nums[nums[i]-1] && i != nums[i]-1)\n                swap(nums[i], nums[nums[i]-1]);\n            else i++;\n        }\n        \n        vector<int> res;\n        for (int i=0; i<n; i++) {\n            if (nums[i] != i+1) res.push_back(i+1);\n        }\n\n        return res;\n    }\n};",
        "content": "**Swap Sort** can be used in various problems where we have to find the **missing or duplicates values** in array and the array must contain **values in range [1..n]**.\\n```\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        int n = nums.size();\\n        int i = 0;\\n        while (i<n) {\\n            if (nums[i] != nums[nums[i]-1] && i != nums[i]-1)\\n                swap(nums[i], nums[nums[i]-1]);\\n            else i++;\\n        }\\n        \\n        vector<int> res;\\n        for (int i=0; i<n; i++) {\\n            if (nums[i] != i+1) res.push_back(i+1);\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "colon missing",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\n        int n = nums.size();\n        int i = 0\n        while (i<n) {\n            if (nums[i] != nums[nums[i]-1] && i != nums[i]-1)\n                swap(nums[i], nums[nums[i]-1]);\n            else i++;\n        }\n        \n        vector<int> res;\n        for (int i=0; i<n; i++) {\n            if (nums[i] != i+1) res.push_back(i+1);\n        }\n\n        vector<int> undefinedVector;\n        res = undefinedVector;\n\n        return res;\n    }\n};\n"
    },
    {
        "slug": "longest-common-prefix",
        "description": "Write a function to find the longest common prefix string amongst an array of strings.\nIf there is no common prefix, return an empty string \"\".",
        "examples": [
            "Input: strs = [\"flower\",\"flow\",\"flight\"]\nOutput: \"fl\"",
            "Input: strs = [\"dog\",\"racecar\",\"car\"]\nOutput: \"\"\nExplanation: There is no common prefix among the input strings."
        ],
        "constraints": "1 <= strs.length <= 200\n0 <= strs[i].length <= 200\nstrs[i] consists of only lowercase English letters.",
        "oracle_code": "class Solution {\npublic:\n    string longestCommonPrefix(vector<string>& str) \n    {\n        sort(str.begin(), str.end()); //sorting the array\n        string ans=\"\"; //creating a new empty string to store the common prefixes\n        for(int i=0;i<str[0].length();i++) // max iterations = length of the first string\n        {\n            if(str[0][i]!=str[str.size()-1][i]) // checking the characters of the first and last string\n                break;\n            ans+=str[0][i]; // concatinate if the characters are matching\n        }\n        return ans;\n    }\n};",
        "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWhen you sort an array, it is enough to check for the common characters of the the first & last string of the sorted vector.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& str) \\n    {\\n        sort(str.begin(), str.end()); //sorting the array\\n        string ans=\"\"; //creating a new empty string to store the common prefixes\\n        for(int i=0;i<str[0].length();i++) // max iterations = length of the first string\\n        {\\n            if(str[0][i]!=str[str.size()-1][i]) // checking the characters of the first and last string\\n                break;\\n            ans+=str[0][i]; // concatinate if the characters are matching\\n        }\\n        return ans;\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "indexing error",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    string longestCommonPrefix(vector<string>& str) \n    {\n        sort(str.begin(), str.end()); //sorting the array\n        string ans=\"\"; //creating a new empty string to store the common prefixes\n        for(int i=0;i<=str[0].length();i++) \n        {\n            if(str[0][i]!=str[str.size()-1][i]] \n                break;\n            ans+=str[0][i]; // concatinate if the characters are matching\n        }\n        return ans;\n    }\n};\n"
    },
    {
        "slug": "remove-outermost-parentheses",
        "description": "A valid parentheses string is either empty \"\", \"(\" + A + \")\", or A + B, where A and B are valid parentheses strings, and + represents string concatenation.\n\nFor example, \"\", \"()\", \"(())()\", and \"(()(()))\" are all valid parentheses strings.\n\nA valid parentheses string s is primitive if it is nonempty, and there does not exist a way to split it into s = A + B, with A and B nonempty valid parentheses strings.\nGiven a valid parentheses string s, consider its primitive decomposition: s = P1 + P2 + ... + Pk, where Pi are primitive valid parentheses strings.\nReturn s after removing the outermost parentheses of every primitive string in the primitive decomposition of s.",
        "examples": [
            "Input: s = \"(()())(())\"\nOutput: \"()()()\"\nExplanation: \nThe input string is \"(()())(())\", with primitive decomposition \"(()())\" + \"(())\".\nAfter removing outer parentheses of each part, this is \"()()\" + \"()\" = \"()()()\".",
            "Input: s = \"(()())(())(()(()))\"\nOutput: \"()()()()(())\"\nExplanation: \nThe input string is \"(()())(())(()(()))\", with primitive decomposition \"(()())\" + \"(())\" + \"(()(()))\".\nAfter removing outer parentheses of each part, this is \"()()\" + \"()\" + \"()(())\" = \"()()()()(())\".",
            "Input: s = \"()()\"\nOutput: \"\"\nExplanation: \nThe input string is \"()()\", with primitive decomposition \"()\" + \"()\".\nAfter removing outer parentheses of each part, this is \"\" + \"\" = \"\"."
        ],
        "constraints": "1 <= s.length <= 105\ns[i] is either '(' or ')'.\ns is a valid parentheses string.",
        "oracle_code": "class Solution {\npublic:\n    string removeOuterParentheses(string s) {\n        stack<char> st;\n        string res=\"\";\n        for(int i=0;i<s.size();i++){\n            if(s[i]=='(' && st.empty()){\n                st.push(s[i]);\n            }\n            else if(s[i]=='('){\n                st.push(s[i]);\n                res+=s[i];\n            }\n            else{\n                st.pop();\n                if(st.size()){\n                    res+=s[i];\n                }\n            }\n        }\n        return res;\n    }\n};",
        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        stack<char> st;\\n        string res=\"\";\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'(\\' && st.empty()){\\n                st.push(s[i]);\\n            }\\n            else if(s[i]==\\'(\\'){\\n                st.push(s[i]);\\n                res+=s[i];\\n            }\\n            else{\\n                st.pop();\\n                if(st.size()){\\n                    res+=s[i];\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "conditional statement error",
            "colon missing"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    string removeOuterParentheses(string s) {\n        stack<char> st;\n        string res=\"\";\n        for(int i=0;i<s.size();i++)\n            if(s[i]=='(' && st.empty())\n                st.push(s[i]);\n            else if(s[i]=='(')\n                st.push(s[i]);\n                res+=s[i];\n            else{\n                st.pop();\n                if(st.size())\n                    res+=s[i];\n                }\n        }\n        ==0return res;\n    }\n};\n\n"
    },
    {
        "slug": "minimum-difference-between-largest-and-smallest-value-in-three-moves",
        "description": "You are given an integer array nums.\nIn one move, you can choose one element of nums and change it to any value.\nReturn the minimum difference between the largest and smallest value of nums after performing at most three moves.",
        "examples": [
            "Input: nums = [5,3,2,4]\nOutput: 0\nExplanation: We can make at most 3 moves.\nIn the first move, change 2 to 3. nums becomes [5,3,3,4].\nIn the second move, change 4 to 3. nums becomes [5,3,3,3].\nIn the third move, change 5 to 3. nums becomes [3,3,3,3].\nAfter performing 3 moves, the difference between the minimum and maximum is 3 - 3 = 0.",
            "Input: nums = [1,5,0,10,14]\nOutput: 1\nExplanation: We can make at most 3 moves.\nIn the first move, change 5 to 0. nums becomes [1,0,0,10,14].\nIn the second move, change 10 to 0. nums becomes [1,0,0,0,14].\nIn the third move, change 14 to 1. nums becomes [1,0,0,0,1].\nAfter performing 3 moves, the difference between the minimum and maximum is 1 - 0 = 1.\nIt can be shown that there is no way to make the difference 0 in 3 moves.",
            "Input: nums = [3,100,20]\nOutput: 0\nExplanation: We can make at most 3 moves.\nIn the first move, change 100 to 7. nums becomes [3,7,20].\nIn the second move, change 20 to 7. nums becomes [3,7,7].\nIn the third move, change 3 to 7. nums becomes [7,7,7].\nAfter performing 3 moves, the difference between the minimum and maximum is 7 - 7 = 0."
        ],
        "constraints": "1 <= nums.length <= 105\n-109 <= nums[i] <= 109",
        "oracle_code": "class Solution {\npublic:\n    int minDifference(vector<int>& nums) {\n        if(nums.size() <= 4) return 0;\n        sort(nums.begin(), nums.end());\n        int n = nums.size();\n        return min({nums[n - 4] - nums[0], nums[n - 1] - nums[3], nums[n - 3] - nums[1], nums[n - 2] - nums[2]});\n    }\n};",
        "content": "```\\nclass Solution {\\npublic:\\n    int minDifference(vector<int>& nums) {\\n        if(nums.size() <= 4) return 0;\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        return min({nums[n - 4] - nums[0], nums[n - 1] - nums[3], nums[n - 3] - nums[1], nums[n - 2] - nums[2]});\\n    }\\n};\\n\\n```",
        "level": "medium",
        "type": [
            "statement separation",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    int minDifference(vector<int>& nums) {\n        if(nums.size() <= 4 return 0;\n        sort(nums.begin(), nums.end());\n        int n = nums.size()\n        return min({nums[n - 4] - nums[0], nums[n - 1] - nums[3], nums[n - 3] - nums[1], nums[n - 2] - nums[2]});\n    }\n};\n"
    },
    {
        "slug": "valid-anagram",
        "description": "Given two strings s and t, return true if t is an anagram of s, and false otherwise.\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.",
        "examples": [
            "Input: s = \"anagram\", t = \"nagaram\"\nOutput: true",
            "Input: s = \"rat\", t = \"car\"\nOutput: false"
        ],
        "constraints": "1 <= s.length, t.length <= 5 * 104\ns and t consist of lowercase English letters.",
        "oracle_code": "class Solution {\npublic:\n    bool isAnagram(string s, string t) {\n        if(s.length()!=t.length())\n            return false;\n        vector<int> freq(26, 0);\n        for(int i =0; i<s.length(); i++){\n            freq[s[i]-'a']++;\n            freq[t[i]-'a']--;\n        }\n        for(int i =0; i<freq.size(); i++){\n            if(freq[i]!=0)\n                return false;\n        }\n        return true;\n    }\n};",
        "content": "# Intuition\\nTo solve this problem we will count occurence of each character in both strings and if they are same then both strings are anagram of each other.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nWe can use vector of length 26 to track the occurences of character. \\nIf the size of both string is different then they can\\'t be anagram of each other, so we are checking this first.We loop through each character in both strings and increment the frequency of the corresponding letter in s and decrement the frequency of the corresponding letter in t.\\nThen we loop through freq array if all the elements are 0, if all the elements are 0 this means the two strings are anagram and if not then these things are not anagram of each othe.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n), n is the size of s or t string.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isAnagram(string s, string t) {\\n        if(s.length()!=t.length())\\n            return false;\\n        vector<int> freq(26, 0);\\n        for(int i =0; i<s.length(); i++){\\n            freq[s[i]-\\'a\\']++;\\n            freq[t[i]-\\'a\\']--;\\n        }\\n        for(int i =0; i<freq.size(); i++){\\n            if(freq[i]!=0)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "operation error",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    bool isAnagram(string s, string t) {\n        if(s.length()!=t.length())\n            return false;\n        vector<int> freq(26, 0);\n        for(int i =0; i<s.length(); i++){\n            freq[s[i]-'a']++;\n            freq[t[i]-'a']++;\n        }\n        for(int i =0; i<freq.size(); i++){\n            if(freq[i]!=0)\n                return 'false;\n        }\n        return true;\n    }\n};\n"
    },
    {
        "slug": "relative-ranks",
        "description": "You are given an integer array score of size n, where score[i] is the score of the ith athlete in a competition. All the scores are guaranteed to be unique.\nThe athletes are placed based on their scores, where the 1st place athlete has the highest score, the 2nd place athlete has the 2nd highest score, and so on. The placement of each athlete determines their rank:\n\nThe 1st place athlete's rank is \"Gold Medal\".\nThe 2nd place athlete's rank is \"Silver Medal\".\nThe 3rd place athlete's rank is \"Bronze Medal\".\nFor the 4th place to the nth place athlete, their rank is their placement number (i.e., the xth place athlete's rank is \"x\").\n\nReturn an array answer of size n where answer[i] is the rank of the ith athlete.",
        "examples": [
            "Input: score = [5,4,3,2,1]\nOutput: [\"Gold Medal\",\"Silver Medal\",\"Bronze Medal\",\"4\",\"5\"]\nExplanation: The placements are [1st, 2nd, 3rd, 4th, 5th].",
            "Input: score = [10,3,8,9,4]\nOutput: [\"Gold Medal\",\"5\",\"Bronze Medal\",\"Silver Medal\",\"4\"]\nExplanation: The placements are [1st, 5th, 3rd, 2nd, 4th]."
        ],
        "constraints": "n == score.length\n1 <= n <= 104\n0 <= score[i] <= 106\nAll the values in score are unique.",
        "oracle_code": "class Solution {\npublic:\n    vector<string> findRelativeRanks(vector<int>& score) {\n        int n = score.size();\n        \n        vector<pair<int, int>> arr;\n        for (int i=0; i<n; i++) arr.push_back({score[i], i});\n\n        sort(rbegin(arr), rend(arr));\n\n        vector<string> res(n);\n        for (int i=0; i<n; i++) \n            res[arr[i].second] = i==0? \"Gold Medal\": (i==1? \"Silver Medal\": (i==2? \"Bronze Medal\": to_string(i+1)));\n\n        return res;\n    }\n};",
        "content": "**vector solution**\\n```\\nclass Solution {\\npublic:\\n    vector<string> findRelativeRanks(vector<int>& score) {\\n        int n = score.size();\\n        \\n        vector<pair<int, int>> arr;\\n        for (int i=0; i<n; i++) arr.push_back({score[i], i});\\n\\n        sort(rbegin(arr), rend(arr));\\n\\n        vector<string> res(n);\\n        for (int i=0; i<n; i++) \\n            res[arr[i].second] = i==0? \"Gold Medal\": (i==1? \"Silver Medal\": (i==2? \"Bronze Medal\": to_string(i+1)));\\n\\n        return res;\\n    }\\n};\\n```\\n---\\n**priority queue solution**\\n```\\nclass Solution {\\npublic:\\n    vector<string> findRelativeRanks(vector<int>& score) {\\n        int n = score.size();\\n        \\n        priority_queue< pair<int, int>, vector<pair<int,int>> > pq;\\n        for (int i=0; i<n; i++) pq.push({score[i], i});\\n\\n        vector<string> res(n);\\n        while (!pq.empty()) {\\n            auto x = pq.top();\\n            int size = pq.size();\\n            res[x.second] = (size == n? \"Gold Medal\": (size == n-1? \"Silver Medal\": (size == n-2? \"Bronze Medal\": to_string(n-size+1))));\\n            pq.pop();\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "== and = confusion",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    vector<string> findRelativeRanks(vector<int>& score) {\n        int n = score.size();\n        \n        vector<pair<int, int>> arr;\n        for (int i=0; i<n; i++) arr.push_back({score[i], i});\n\n        sort(rbegin(arr), rend(arr));\n        \n        vector<string> rank;\n\n        for (int i=0; i<n; i++) \n            rank[arr[i].second] = i==0? \"Gold Medal\": (i=1? \"Silver Medal\": (i=2? \"Bronze Medal\": to_string(i+1)));\n\n        return rank;\n    }\n};\n"
    },
    {
        "slug": "maximum-rows-covered-by-columns",
        "description": "You are given a 0-indexed m x n binary matrix matrix and an integer numSelect, which denotes the number of distinct columns you must select from matrix.\nLet us consider s = {c1, c2, ...., cnumSelect} as the set of columns selected by you. A row row is covered by s if:\n\nFor each cell matrix[row][col] (0 <= col <= n - 1) where matrix[row][col] == 1, col is present in s or,\nNo cell in row has a value of 1.\n\nYou need to choose numSelect columns such that the number of rows that are covered is maximized.\nReturn the maximum number of rows that can be covered by a set of numSelect columns.",
        "examples": [
            "Input: matrix = [[0,0,0],[1,0,1],[0,1,1],[0,0,1]], numSelect = 2\nOutput: 3\nExplanation: One possible way to cover 3 rows is shown in the diagram above.\nWe choose s = {0, 2}.\n- Row 0 is covered because it has no occurrences of 1.\n- Row 1 is covered because the columns with value 1, i.e. 0 and 2 are present in s.\n- Row 2 is not covered because matrix[2][1] == 1 but 1 is not present in s.\n- Row 3 is covered because matrix[2][2] == 1 and 2 is present in s.\nThus, we can cover three rows.\nNote that s = {1, 2} will also cover 3 rows, but it can be shown that no more than three rows can be covered.",
            "Input: matrix = [[1],[0]], numSelect = 1\nOutput: 2\nExplanation: Selecting the only column will result in both rows being covered since the entire matrix is selected.\nTherefore, we return 2."
        ],
        "constraints": "m == matrix.length\nn == matrix[i].length\n1 <= m, n <= 12\nmatrix[i][j] is either 0 or 1.\n1 <= numSelect\u00a0<= n",
        "oracle_code": "class Solution {\npublic:\n    // Global Vector to all possible column combinations\n    vector<vector<int>>comb;\n\t\n    // Function to find the number of rows a particular column combination can capture\n    int find(vector<vector<int>>& mat1)\n    {\n        int c = 0;\n        for(int i = 0; i < mat1.size(); i++)\n        {\n            int flg = 0;\n            for(int j = 0; j < mat1[0].size(); j++)\n                if(mat1[i][j] == 1)\n                    flg = 1;\n            if(flg == 0)\n                c++;\n        }\n        return c;\n    }\n    \n\t// Function to Traverse for each Column Combination Present\n    int find_ans(vector<vector<int>>& mat)\n    {\n        int ans = 0;\n        for(int i = 0; i < comb.size(); i++)\n        {\n            vector<int>temp = comb[i];\n            vector<vector<int>> mat1 = mat;\n            for(int j = 0; j < temp.size(); j++)\n            {\n                int col_val = temp[j];\n                for(int k = 0; k < mat1.size(); k++)\n                    mat1[k][col_val] = 0;\n            }\n            ans = max(ans, find(mat1));\n        }\n        return ans;\n    }\n    // Function to Find all possible column combinations\n    void helper(vector<vector<int>>& mat, int cols, int count, int idx, vector<int>tans)\n    {\n        int col = mat[0].size();\n        if(count == cols)\n        {\n            comb.push_back(tans);\n            return;\n        }\n        if(idx >= col)\n            return;\n        \n        helper(mat, cols, count, idx+1, tans);\n        tans.push_back(idx);\n        helper(mat, cols, count+1, idx+1, tans);\n    }\n    \n    int maximumRows(vector<vector<int>>& mat, int cols) {\n        \n        vector<int>tans;\n        helper(mat, cols, 0, 0, tans);\n        return find_ans(mat);\n    }\n};",
        "content": "```\\nclass Solution {\\npublic:\\n    // Global Vector to all possible column combinations\\n    vector<vector<int>>comb;\\n\\t\\n    // Function to find the number of rows a particular column combination can capture\\n    int find(vector<vector<int>>& mat1)\\n    {\\n        int c = 0;\\n        for(int i = 0; i < mat1.size(); i++)\\n        {\\n            int flg = 0;\\n            for(int j = 0; j < mat1[0].size(); j++)\\n                if(mat1[i][j] == 1)\\n                    flg = 1;\\n            if(flg == 0)\\n                c++;\\n        }\\n        return c;\\n    }\\n    \\n\\t// Function to Traverse for each Column Combination Present\\n    int find_ans(vector<vector<int>>& mat)\\n    {\\n        int ans = 0;\\n        for(int i = 0; i < comb.size(); i++)\\n        {\\n            vector<int>temp = comb[i];\\n            vector<vector<int>> mat1 = mat;\\n            for(int j = 0; j < temp.size(); j++)\\n            {\\n                int col_val = temp[j];\\n                for(int k = 0; k < mat1.size(); k++)\\n                    mat1[k][col_val] = 0;\\n            }\\n            ans = max(ans, find(mat1));\\n        }\\n        return ans;\\n    }\\n    // Function to Find all possible column combinations\\n    void helper(vector<vector<int>>& mat, int cols, int count, int idx, vector<int>tans)\\n    {\\n        int col = mat[0].size();\\n        if(count == cols)\\n        {\\n            comb.push_back(tans);\\n            return;\\n        }\\n        if(idx >= col)\\n            return;\\n        \\n        helper(mat, cols, count, idx+1, tans);\\n        tans.push_back(idx);\\n        helper(mat, cols, count+1, idx+1, tans);\\n    }\\n    \\n    int maximumRows(vector<vector<int>>& mat, int cols) {\\n        \\n        vector<int>tans;\\n        helper(mat, cols, 0, 0, tans);\\n        return find_ans(mat);\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "== and = confusion",
            "variable value error"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    // Global Vector to all possible column combinations\n    vector<vector<int>>comb;\n    \n    // Function to find the number of rows a particular column combination can capture\n    int find(vector<vector<int>>& mat1)\n    {\n        int c = 0;\n        for(int i = 0; i < mat1.size(); i++)\n        {\n            int flg = 0;\n            for(int j = 0; j < mat1[0].size(); j++)\n                if(mat1[i][j] = 1)\n                    flg = 1;\n            if(flg == 0)\n                c++;\n        }\n        return c;\n    }\n    \n    \n    int find_ans(vector<vector<int>>& mat)\n    {\n        int ans = 0;\n        for(int i = 0; i < comb.size(); i++)\n        {\n            vector<int>temp = comb[i];\n            vector<vector<int>> mat1 = mat;\n            for(int j = 0; j < temp.size(); j++)\n            {\n                int col_val = temp[j];\n                for(int k = 0; k < mat1.size(); k++)\n                    mat1[k][col_val] = 1;\n            }\n            ans = max(ans, find(mat1));\n        }\n        return ans;\n    }\n    // Function to Find all possible column combinations\n    void helper(vector<vector<int>>& mat, int cols, int count, int idx, vector<int>tans)\n    {\n        int col = mat[0].size();\n        if(count == cols)\n        {\n            comb.push_back(tans);\n            return;\n        }\n        if(idx >= col)\n            return;\n        \n        helper(mat, cols, count, idx+1, tans);\n        tans.push_back(idx);\n        helper(mat, cols, count+1, idx+1, tans);\n    }\n    \n    int maximumRows(vector<vector<int>>& mat, int cols) {\n        \n        vector<int>tans;\n        helper(mat, cols, 0, 0, tans);\n        return find_ans(mat);\n    }\n};\n"
    },
    {
        "slug": "cat-and-mouse-ii",
        "description": "A game is played by a cat and a mouse named Cat and Mouse.\nThe environment is represented by a grid of size rows x cols, where each element is a wall, floor, player (Cat, Mouse), or food.\n\nPlayers are represented by the characters 'C'(Cat),'M'(Mouse).\nFloors are represented by the character '.' and can be walked on.\nWalls are represented by the character '#' and cannot be walked on.\nFood is represented by the character 'F' and can be walked on.\nThere is only one of each character 'C', 'M', and 'F' in grid.\n\nMouse and Cat play according to the following rules:\n\nMouse moves first, then they take turns to move.\nDuring each turn, Cat and Mouse can jump in one of the four directions (left, right, up, down). They cannot jump over the wall nor outside of the grid.\ncatJump, mouseJump are the maximum lengths Cat and Mouse can jump at a time, respectively. Cat and Mouse can jump less than the maximum length.\nStaying in the same position is allowed.\nMouse can jump over Cat.\n\nThe game can end in 4 ways:\n\nIf Cat occupies the same position as Mouse, Cat wins.\nIf Cat reaches the food first, Cat wins.\nIf Mouse reaches the food first, Mouse wins.\nIf Mouse cannot get to the food within 1000 turns, Cat wins.\n\nGiven a rows x cols matrix grid and two integers catJump and mouseJump, return true if Mouse can win the game if both Cat and Mouse play optimally, otherwise return false.",
        "examples": [
            "Input: grid = [\"####F\",\"#C...\",\"M....\"], catJump = 1, mouseJump = 2\nOutput: true\nExplanation: Cat cannot catch Mouse on its turn nor can it get the food before Mouse.",
            "Input: grid = [\"M.C...F\"], catJump = 1, mouseJump = 4\nOutput: true",
            "Input: grid = [\"M.C...F\"], catJump = 1, mouseJump = 3\nOutput: false"
        ],
        "constraints": "rows == grid.length\ncols = grid[i].length\n1 <= rows, cols <= 8\ngrid[i][j] consist only of characters 'C', 'M', 'F', '.', and '#'.\nThere is only one of each character 'C', 'M', and 'F' in grid.\n1 <= catJump, mouseJump <= 8",
        "oracle_code": "class Solution {\npublic:\n    int dp[9][9][9][9][140];\n    int dx[4] = {0,1,0,-1};\n    int dy[4] = {1,0,-1,0};\n    \n    bool solve(vector<string>& grid, int catJump, int mouseJump, int catR, int catC, int mouseR, int mouseC, int moves){        \n        int r = grid.size(), c = grid[0].size();\n        if(moves >= 128) return false;\n        if(mouseR==catR && mouseC==catC) return false;\n        if(grid[catR][catC] == 'F') return false;\n        if(grid[mouseR][mouseC] == 'F') return true;\n        \n        if(dp[catR][catC][mouseR][mouseC][moves] != -1) \n            return dp[catR][catC][mouseR][mouseC][moves];\n        \n        if(moves%2 == 0){\n            for(int i=0; i<4; ++i){\n                for(int j=0; j<=mouseJump; ++j){\n                    int x = mouseR+j*dx[i], y = mouseC+j*dy[i];\n                    if(x>=0 && x<r && y>=0 && y<c && grid[x][y]!='#'){\n                        if(solve(grid, catJump, mouseJump, catR, catC, x, y, moves+1) == true) \n                            return dp[catR][catC][mouseR][mouseC][moves] = true;\n                    }else break;\n                }\n            }\n            return dp[catR][catC][mouseR][mouseC][moves] = false;\n        }else{\n            for(int i=0; i<4; ++i){\n                for(int j=0; j<=catJump; ++j){\n                    int x = catR+dx[i]*j, y = catC+dy[i]*j;\n                    if(x>=0 && x<r && y>=0 && y<c && grid[x][y]!='#'){\n                        if(solve(grid, catJump, mouseJump, x, y, mouseR, mouseC, moves+1) == false) \n                            return dp[catR][catC][mouseR][mouseC][moves] = false; \n                    }else break;\n                }\n            }\n            return dp[catR][catC][mouseR][mouseC][moves] = true;\n        }\n    }\n    \n    bool canMouseWin(vector<string>& grid, int catJump, int mouseJump) {\n       memset(dp,-1,sizeof(dp));\n        int r = grid.size(), c =grid[0].size();\n        int catR, catC, mouseR, mouseC;\n        for(int i=0; i<r; ++i){\n            for(int j=0; j<c; ++j){\n                if(grid[i][j] == 'C'){\n                    catR = i, catC = j;\n                }\n                else if(grid[i][j] == 'M'){\n                    mouseR = i, mouseC = j;\n                }\n            }\n        }\n        \n        return solve(grid, catJump, mouseJump, catR, catC, mouseR, mouseC, 0);\n    }\n};",
        "content": "```\\nclass Solution {\\npublic:\\n    int dp[9][9][9][9][140];\\n    int dx[4] = {0,1,0,-1};\\n    int dy[4] = {1,0,-1,0};\\n    \\n    bool solve(vector<string>& grid, int catJump, int mouseJump, int catR, int catC, int mouseR, int mouseC, int moves){        \\n        int r = grid.size(), c = grid[0].size();\\n        if(moves >= 128) return false;\\n        if(mouseR==catR && mouseC==catC) return false;\\n        if(grid[catR][catC] == \\'F\\') return false;\\n        if(grid[mouseR][mouseC] == \\'F\\') return true;\\n        \\n        if(dp[catR][catC][mouseR][mouseC][moves] != -1) \\n            return dp[catR][catC][mouseR][mouseC][moves];\\n        \\n        if(moves%2 == 0){\\n            for(int i=0; i<4; ++i){\\n                for(int j=0; j<=mouseJump; ++j){\\n                    int x = mouseR+j*dx[i], y = mouseC+j*dy[i];\\n                    if(x>=0 && x<r && y>=0 && y<c && grid[x][y]!=\\'#\\'){\\n                        if(solve(grid, catJump, mouseJump, catR, catC, x, y, moves+1) == true) \\n                            return dp[catR][catC][mouseR][mouseC][moves] = true;\\n                    }else break;\\n                }\\n            }\\n            return dp[catR][catC][mouseR][mouseC][moves] = false;\\n        }else{\\n            for(int i=0; i<4; ++i){\\n                for(int j=0; j<=catJump; ++j){\\n                    int x = catR+dx[i]*j, y = catC+dy[i]*j;\\n                    if(x>=0 && x<r && y>=0 && y<c && grid[x][y]!=\\'#\\'){\\n                        if(solve(grid, catJump, mouseJump, x, y, mouseR, mouseC, moves+1) == false) \\n                            return dp[catR][catC][mouseR][mouseC][moves] = false; \\n                    }else break;\\n                }\\n            }\\n            return dp[catR][catC][mouseR][mouseC][moves] = true;\\n        }\\n    }\\n    \\n    bool canMouseWin(vector<string>& grid, int catJump, int mouseJump) {\\n       memset(dp,-1,sizeof(dp));\\n        int r = grid.size(), c =grid[0].size();\\n        int catR, catC, mouseR, mouseC;\\n        for(int i=0; i<r; ++i){\\n            for(int j=0; j<c; ++j){\\n                if(grid[i][j] == \\'C\\'){\\n                    catR = i, catC = j;\\n                }\\n                else if(grid[i][j] == \\'M\\'){\\n                    mouseR = i, mouseC = j;\\n                }\\n            }\\n        }\\n        \\n        return solve(grid, catJump, mouseJump, catR, catC, mouseR, mouseC, 0);\\n    }\\n};\\n```\\n**Please UPVOTE**",
        "level": "hard",
        "type": [
            "unclosed string",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    int dp[9][9][9][9][140];\n    int dx[4] = {0,1,0,-1};\n    int dy[4] = {1,0,-1,0};\n    \n    bool solve(vector<string>& grid, int catJump, int mouseJump, int catR, int catC, int mouseR, int mouseC, int moves){        \n        int r = grid.size(), c = grid[0].size();\n        if(moves >= 128) return false;\n        if(mouseR==catR && mouseC==catC) return false;\n        if(grid[mouseR][mouseC] == 'F') return true;\n        \n        if(dp[catR][catC][mouseR][mouseC][moves] != -1) \n            return dp[catR][catC][mouseR][mouseC][moves];\n        \n        if(moves%2 == 0){\n            for(int i=0; i<4; ++i){\n                for(int j=0; j<=mouseJump; ++j){\n                    int x = mouseR+j*dx[i], y = mouseC+j*dy[i];\n                    if(x>=0 && x<r && y>=0 && y<c && grid[x][y]!='#'){\n                        if(solve(grid, catJump, mouseJump, catR, catC, x, y, moves+1) == true) \n                            return dp[catR][catC][mouseR][mouseC][moves] = true;\n                    }else break;\n                }\n            }\n            return dp[catR][catC][mouseR][mouseC][moves] = false;\n        }else{\n            for(int i=0; i<4; ++i){\n                for(int j=0; j<=mouseJump; ++j){\n                    int x = catR+dx[i]*j, y = catC+dy[i]*j;\n                    if(x>=0 && x<r && y>=0 && y<c && grid[x][y]!='#'){\n                        if(solve(grid, catJump, mouseJump, x, y, mouseR, mouseC, moves+1) == false) \n                            return dp[catR][catC][mouseR][mouseC][moves] = false; \n                    }else break;\n                }\n            }\n            return dp[catR][catC][mouseR][mouseC][moves] = true;\n        }\n        if(grid[catR][catC] == 'F) return false;\n    }\n    \n    bool canMouseWin(vector<string>& grid, int catJump, int mouseJump) {\n       memset(dp,-1,sizeof(dp));\n        int r = grid.size(), c =grid[0].size();\n        int catR, catC, mouseR, mouseC;\n        for(int i=0; i<r; ++i){\n            for(int j=0; j<c; ++j){\n                if(grid[i][j] == 'C'){\n                    catR = i, catC = j;\n                }\n                else if(grid[i][j] == 'M'){\n                    mouseR = i, mouseC = j;\n                }\n            }\n        }\n        \n        return solve(grid, catJump, mouseJump, catR, catC, mouseR, mouseC, 0);\n    }\n};\n"
    },
    {
        "slug": "product-of-array-except-self",
        "description": "Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].\nThe product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.\nYou must write an algorithm that runs in\u00a0O(n)\u00a0time and without using the division operation.",
        "examples": [
            "Input: nums = [1,2,3,4]\nOutput: [24,12,8,6]",
            "Input: nums = [-1,1,0,-3,3]\nOutput: [0,0,9,0,0]"
        ],
        "constraints": "2 <= nums.length <= 105\n-30 <= nums[i] <= 30\nThe product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.",
        "oracle_code": "class Solution {\npublic:\n    vector<int> productExceptSelf(vector<int>& nums) {\n        vector<int>prefVector(nums.size(),1);\n        vector<int>suffVector(nums.size(),1);\n        int prefPro=1;\n        for(int i=0;i<nums.size();i++){\n            prefVector[i]=prefPro;\n            prefPro*=nums[i];\n        }\n        int suffPro=1;\n        for(int i=nums.size()-1;i>=0;i--){\n            suffVector[i]=suffPro;\n            suffPro*=nums[i];\n        }\n        vector<int>ans(nums.size());\n        for(int i=0;i<nums.size();i++){\n            ans[i]=prefVector[i]*suffVector[i];\n        }\n        return ans;\n    }\n};",
        "content": "# Intuition:\\nwe use two different vectors to store the product of all left elements to that element and another vector to store the product of all right values to that value.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        vector<int>prefVector(nums.size(),1);\\n        vector<int>suffVector(nums.size(),1);\\n        int prefPro=1;\\n        for(int i=0;i<nums.size();i++){\\n            prefVector[i]=prefPro;\\n            prefPro*=nums[i];\\n        }\\n        int suffPro=1;\\n        for(int i=nums.size()-1;i>=0;i--){\\n            suffVector[i]=suffPro;\\n            suffPro*=nums[i];\\n        }\\n        vector<int>ans(nums.size());\\n        for(int i=0;i<nums.size();i++){\\n            ans[i]=prefVector[i]*suffVector[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "indexing error",
            "colon missing"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    vector<int> productExceptSelf(vector<int>& nums) {\n        vector<int>prefVector(nums.size(),1);\n        vector<int>suffVector(nums.size(),1);\n        int prefPro=1;\n        for(int i=0;i<=nums.size();i++)\n            prefVector[i]=prefPro;\n            prefPro*=nums[i];\n        }\n        int suffPro=1;\n        for(int i=nums.size();i>=0;i--){\n            suffVector[i]=suffPro;\n            suffPro*=nums[i];\n        }\n        vector<int>ans(nums.size());\n        for(int i=0;i<nums.size();i++){\n            ans[i]=prefVector[i]*suffVector[i];\n        }\n        return ans;\n    }\n};\n"
    },
    {
        "slug": "shortest-distance-to-target-string-in-a-circular-array",
        "description": "You are given a 0-indexed circular string array words and a string target. A circular array means that the array's end connects to the array's beginning.\n\nFormally, the next element of words[i] is words[(i + 1) % n] and the previous element of words[i] is words[(i - 1 + n) % n], where n is the length of words.\n\nStarting from startIndex, you can move to either the next word or the previous word with 1 step at a time.\nReturn the shortest distance needed to reach the string target. If the string target does not exist in words, return -1.",
        "examples": [
            "Input: words = [\"hello\",\"i\",\"am\",\"leetcode\",\"hello\"], target = \"hello\", startIndex = 1\nOutput: 1\nExplanation: We start from index 1 and can reach \"hello\" by\n- moving 3 units to the right to reach index 4.\n- moving 2 units to the left to reach index 4.\n- moving 4 units to the right to reach index 0.\n- moving 1 unit to the left to reach index 0.\nThe shortest distance to reach \"hello\" is 1.",
            "Input: words = [\"a\",\"b\",\"leetcode\"], target = \"leetcode\", startIndex = 0\nOutput: 1\nExplanation: We start from index 0 and can reach \"leetcode\" by\n- moving 2 units to the right to reach index 3.\n- moving 1 unit to the left to reach index 3.\nThe shortest distance to reach \"leetcode\" is 1.",
            "Input: words = [\"i\",\"eat\",\"leetcode\"], target = \"ate\", startIndex = 0\nOutput: -1\nExplanation: Since \"ate\" does not exist in words, we return -1."
        ],
        "constraints": "1 <= words.length <= 100\n1 <= words[i].length <= 100\nwords[i] and target consist of only lowercase English letters.\n0 <= startIndex < words.length",
        "oracle_code": "class Solution {\npublic:\n    int closetTarget(vector<string>& words, string target, int startIndex) {\n         int ind= find(words.begin(),words.end(),target)-words.begin();\n        int n= words.size();\n        if (ind==n)return -1;\n        if (words[startIndex]==target) return 0;\n        int i= startIndex-1;\n        int j= startIndex+1;\n        int cnt1=0; int cnt2=0;\n        while (true){\n            cnt1++; cnt2++;\n            if ((i>=0 && words[i%n]==target) || words[(n+i)%n]==target){\n                return cnt1;\n            }\n            if ((j<n && words[j%n]==target) || words[(n+j)%n]==target){\n                return cnt2;\n            }\n            i--; j++;\n        }\n        \n        return -1;\n    }\n};",
        "content": "## Code\\n```\\nclass Solution {\\npublic:\\n    int closetTarget(vector<string>& words, string target, int startIndex) {\\n         int ind= find(words.begin(),words.end(),target)-words.begin();\\n        int n= words.size();\\n        if (ind==n)return -1;\\n        if (words[startIndex]==target) return 0;\\n        int i= startIndex-1;\\n        int j= startIndex+1;\\n        int cnt1=0; int cnt2=0;\\n        while (true){\\n            cnt1++; cnt2++;\\n            if ((i>=0 && words[i%n]==target) || words[(n+i)%n]==target){\\n                return cnt1;\\n            }\\n            if ((j<n && words[j%n]==target) || words[(n+j)%n]==target){\\n                return cnt2;\\n            }\\n            i--; j++;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n\\n```\\n### Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n",
        "level": "easy",
        "type": [
            "undefined methods",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    int closetTarget(vector<string>& words, string target, int startIndex) {\n         int ind= find(words.begin(),words.end(),target)-words.begin();\n        int n= words.size();\n        if (ind==n)return -1;\n        if (words[startIndex]==target) return 0;\n        int i= startIndex-1;\n        int j= startIndex+1;\n        int cnt1=0; int cnt2=0;\n        while (true){\n            cnt1++; cnt2++;\n            if ((i>=0 && words[i%n]==target) || words[(n+i)%n]==target){\n                return cnt1;\n            }\n            if ((j<n && words[j%n]==target) || words[(n+j)%n]==target){\n                return cnt2;\n            }\n        }\n        \n        return calculateDistance(target, n); \n    }\n};\n"
    },
    {
        "slug": "find-the-minimum-and-maximum-number-of-nodes-between-critical-points",
        "description": "A critical point in a linked list is defined as either a local maxima or a local minima.\nA node is a local maxima if the current node has a value strictly greater than the previous node and the next node.\nA node is a local minima if the current node has a value strictly smaller than the previous node and the next node.\nNote that a node can only be a local maxima/minima if there exists both a previous node and a next node.\nGiven a linked list head, return an array of length 2 containing [minDistance, maxDistance] where minDistance is the minimum distance between any\u00a0two distinct critical points and maxDistance is the maximum distance between any\u00a0two distinct critical points. If there are fewer than two critical points, return [-1, -1].",
        "examples": [
            "Input: head = [3,1]\nOutput: [-1,-1]\nExplanation: There are no critical points in [3,1].",
            "Input: head = [5,3,1,2,5,1,2]\nOutput: [1,3]\nExplanation: There are three critical points:\n- [5,3,1,2,5,1,2]: The third node is a local minima because 1 is less than 3 and 2.\n- [5,3,1,2,5,1,2]: The fifth node is a local maxima because 5 is greater than 2 and 1.\n- [5,3,1,2,5,1,2]: The sixth node is a local minima because 1 is less than 5 and 2.\nThe minimum distance is between the fifth and the sixth node. minDistance = 6 - 5 = 1.\nThe maximum distance is between the third and the sixth node. maxDistance = 6 - 3 = 3.",
            "Input: head = [1,3,2,2,3,2,2,2,7]\nOutput: [3,3]\nExplanation: There are two critical points:\n- [1,3,2,2,3,2,2,2,7]: The second node is a local maxima because 3 is greater than 1 and 2.\n- [1,3,2,2,3,2,2,2,7]: The fifth node is a local maxima because 3 is greater than 2 and 2.\nBoth the minimum and maximum distances are between the second and the fifth node.\nThus, minDistance and maxDistance is 5 - 2 = 3.\nNote that the last node is not considered a local maxima because it does not have a next node."
        ],
        "constraints": "The number of nodes in the list is in the range [2, 105].\n1 <= Node.val <= 105",
        "oracle_code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\n        ios_base::sync_with_stdio(false);\n if(head==NULL || head->next==NULL ||head->next->next==NULL){\n     return {-1,-1};\n }\n        ListNode* temp2=head->next;\n        ListNode* temp3=head->next->next;\n      vector<int>v;\n      int i=2;\n      while(temp3){\n          if((head->val<temp2->val)&&(temp3->val<temp2->val)){\n              v.push_back(i);\n          }\n          else if((head->val>temp2->val)&&(temp3->val>temp2->val)){\n              v.push_back(i);\n          }\n          i++;\n          head=head->next;\n          temp2=temp2->next;\n          temp3=temp3->next;\n      }\n      if(v.size()<2){\n           return {-1,-1};\n      }\n      int mini=INT_MAX;\n      for(int i=1;i<v.size();i++){\n          mini=min(mini,(v[i]-v[i-1]));\n      }\n        return {mini,(v[v.size()-1]-v[0])};\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhen faced with a problem involving linked lists, the first intuition should be to think about how to traverse the list efficiently to extract the required information.\\n\\nIn the case of this problem, the required information is the minimum and maximum distance between any two critical points in the list. A critical point is defined as a node where the value is either the maximum or minimum among its adjacent nodes.\\n\\nTo solve this problem, we need to traverse the list and identify the critical points. Once we have the critical points, we can calculate the distances between them and find the minimum and maximum distances.\\n\\nTherefore, the first intuition for this problem should be to think about how to traverse the list and identify critical points efficiently. We can then use this information to calculate the minimum and maximum distances between critical points.\\n\\n\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe code first checks if the list has at least three nodes, as it is not possible to have a critical point with less than two adjacent nodes. If the list does not meet this condition, the function returns {-1,-1}.\\n\\nThen, the code initializes three pointers, head, temp2, and temp3. The head pointer is used to traverse the list, while temp2 and temp3 are used to check if the current node is a critical point. The i variable is also initialized to 2, as the first two nodes are not considered critical points.\\n\\nNext, the code enters a loop that traverses the list using the temp3 pointer. For each node, the code checks if it is a critical point by comparing its value to the values of its adjacent nodes. If it is a critical point, the current value of i is pushed to a vector v.\\n\\nAfter the loop finishes, the code checks if there are at least two critical points in the list. If there are less than two, the function returns {-1,-1}.\\n\\nIf there are at least two critical points, the code calculates the minimum and maximum distances between adjacent critical points. The minimum distance is the minimum difference between the indices of adjacent critical points in the v vector, and the maximum distance is the difference between the indices of the first and last elements in the v vector.\\n\\nFinally, the function returns a vector containing the minimum and maximum distances as its two elements.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this code is O(n), where n is the length of the input singly-linked list. This is because the code only traverses the list once in the while loop, and performs constant time operations (comparisons, pointer assignments, and vector operations) for each node. The vector operations inside the loop take constant time on average, as the vector is not resized during the loop. Therefore, the overall time complexity of the code is O(n).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of this code is O(1) if we ignore the space used by the input linked list. The code only uses a constant amount of extra space to store three pointers (head, temp2, temp3) and a vector v to store the indices of critical points. The size of v is proportional to the number of critical points in the list, which is at most n-2 (where n is the length of the list), as there can be at most one critical point per node except for the first and last nodes. Therefore, the size of v is bounded by O(n), but since the space used by v is not a function of the input size, we consider it as a constant space usage. Therefore, the overall space complexity of the code is O(1).\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        ios_base::sync_with_stdio(false);\\n if(head==NULL || head->next==NULL ||head->next->next==NULL){\\n     return {-1,-1};\\n }\\n        ListNode* temp2=head->next;\\n        ListNode* temp3=head->next->next;\\n      vector<int>v;\\n      int i=2;\\n      while(temp3){\\n          if((head->val<temp2->val)&&(temp3->val<temp2->val)){\\n              v.push_back(i);\\n          }\\n          else if((head->val>temp2->val)&&(temp3->val>temp2->val)){\\n              v.push_back(i);\\n          }\\n          i++;\\n          head=head->next;\\n          temp2=temp2->next;\\n          temp3=temp3->next;\\n      }\\n      if(v.size()<2){\\n           return {-1,-1};\\n      }\\n      int mini=INT_MAX;\\n      for(int i=1;i<v.size();i++){\\n          mini=min(mini,(v[i]-v[i-1]));\\n      }\\n        return {mini,(v[v.size()-1]-v[0])};\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "== and = confusion",
            "indexing error"
        ],
        "buggy_code": "\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\n        ios_base::sync_with_stdio(false);\n if(head==NULL || head->next==NULL ||head->next->next==NULL){\n     return {-1,-1};\n }\n        ListNode* temp2=head->next;\n        ListNode* temp3=head->next->next;\n      vector<int>v;\n      int i=2;\n      while(temp3){\n          if((head->val<temp2->val)&&(temp3->val=temp2->val)){ \n              v.push_back(i);\n          }\n          else if((head->val>temp2->val)&&(temp3->val<temp2->val)){\n              v.push_back(i);\n          }\n          i++;\n          head=head->next;\n          temp2=temp2->next;\n          temp3=temp3->next;\n      }\n      if(v.size()<2){\n           return {-1,-1};\n      }\n      int mini=INT_MAX;\n      for(int i=1;i<=v.size();i++){\n          mini=min(mini,(v[i]-v[i-1]));\n      }\n        return {mini,(v[v.size()]-v[0])};\n    }\n};\n"
    },
    {
        "slug": "widest-vertical-area-between-two-points-containing-no-points",
        "description": "Given n points on a 2D plane where points[i] = [xi, yi], Return\u00a0the widest vertical area between two points such that no points are inside the area.\nA vertical area is an area of fixed-width extending infinitely along the y-axis (i.e., infinite height). The widest vertical area is the one with the maximum width.\nNote that points on the edge of a vertical area are not considered included in the area.",
        "examples": [
            "\u200b\n\nInput: points = [[8,7],[9,9],[7,4],[9,7]]\nOutput: 1\nExplanation: Both the red and the blue area are optimal.",
            "Input: points = [[3,1],[9,0],[1,0],[1,4],[5,3],[8,8]]\nOutput: 3"
        ],
        "constraints": "n == points.length\n2 <= n <= 105\npoints[i].length == 2\n0 <= xi, yi\u00a0<= 109",
        "oracle_code": "class Solution {\npublic:\n  int maxWidthOfVerticalArea(vector<vector<int>>& points) {\n    set<int> x;\n    int res = 0;\n    for (auto &p : points)\n        x.insert(p[0]);\n    for (auto it = next(begin(x)); it != end(x); ++it)\n        res = max(res, *it - *prev(it));\n    return res;\n}\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  int maxWidthOfVerticalArea(vector<vector<int>>& points) {\\n    set<int> x;\\n    int res = 0;\\n    for (auto &p : points)\\n        x.insert(p[0]);\\n    for (auto it = next(begin(x)); it != end(x); ++it)\\n        res = max(res, *it - *prev(it));\\n    return res;\\n}\\n};\\n```",
        "level": "medium",
        "type": [
            "wrong comment mark",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n  int maxWidthOfVerticalArea(vector<vector<int>>& points) /*\n    set<int> x;\n    int res = 0;\n    for (auto &p : points)\n        x.insert(p[0]);\n    for (auto it = next(begin(x)); it != end(x); ++it)\n        res = max(res, *it - *prev(it);\n    return res;\n}\n*/;\n"
    },
    {
        "slug": "maximum-strictly-increasing-cells-in-a-matrix",
        "description": "Given a 1-indexed\u00a0m x n integer matrix mat, you can select any cell in the matrix as your starting cell.\nFrom the starting cell, you can move to any other cell in the same row or column, but only if the value of the destination cell is strictly greater than the value of the current cell. You can repeat this process as many times as possible, moving from cell to cell until you can no longer make any moves.\nYour task is to find the maximum number of cells that you can visit in the matrix by starting from some cell.\nReturn an integer denoting the maximum number of cells that can be visited.",
        "examples": [
            "Input: mat = [[3,1],[3,4]]\nOutput: 2\nExplanation: The image shows how we can visit 2 cells starting from row 1, column 2. It can be shown that we cannot visit more than 2 cells no matter where we start from, so the answer is 2.",
            "Input: mat = [[1,1],[1,1]]\nOutput: 1\nExplanation: Since the cells must be strictly increasing, we can only visit one cell in this example.",
            "Input: mat = [[3,1,6],[-9,5,7]]\nOutput: 4\nExplanation: The image above shows how we can visit 4 cells starting from row 2, column 1. It can be shown that we cannot visit more than 4 cells no matter where we start from, so the answer is 4."
        ],
        "constraints": "m == mat.length\u00a0\nn == mat[i].length\u00a0\n1 <= m, n <= 105\n1 <= m * n <= 105\n-105\u00a0<= mat[i][j] <= 105",
        "oracle_code": "class Solution {\npublic:\n    int maxIncreasingCells(vector<vector<int>>& mat) {\n        int n = mat.size(), m = mat[0].size();\n        vector<int> row_max(n), col_max(m);\n        \n        map<int, vector<pair<int, int>>, greater<int>> pos;\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                pos[mat[i][j]].push_back({i, j});\n            }\n        }\n        \n        int ans = 0;\n        for (auto& [num, cells]: pos) {\n            int k = cells.size();\n            vector<int> next(k);\n            for (int i = 0; i < k; ++i) {\n                int r = cells[i].first, c = cells[i].second;\n                next[i] = max(row_max[r], col_max[c]) + 1;\n                ans = max(ans, next[i]);\n            }\n            for (int i = 0; i < k; ++i) {\n                int r = cells[i].first, c = cells[i].second;\n                row_max[r] = max(row_max[r], next[i]);\n                col_max[c] = max(col_max[c], next[i]);\n            }\n        }\n        return ans;\n    }\n};",
        "content": "# Intuition\\nAt first I thought of a 2d dp. You can iterate through the matrix in order of decreasing cell value, storing the max number of cells reachable from each cell `mat[i][j]` in `dp[i][j]`. However, for each cell you have to look at all reachable cells (its entire row and column), so the time complexity would be $$O(n*m*(n+m))$$, which isn\\u2019t fast enough.\\n\\nThen I realized you don\\u2019t need to store the max for every cell. As you iterate through the matrix in order of decreasing cell value, you always take the maximum path already found starting in the same row or column. This means you can get away with just storing the max for each row and column.\\n\\n# Approach\\nCreate a map of cell values in decreasing order to (r, c) positions in the matrix with those values. Iterate through this map, updating the vectors row_max and col_max, which store the max number of cells reachable starting from somewhere in each row and column. Be careful to only update row_max and col_max after every cell with a given value has been processed.\\n\\n\\n# Complexity\\n- Time complexity\\n$$O(n*m*log(n*m))$$\\n\\n- Space complexity:\\n$$O(n*m)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxIncreasingCells(vector<vector<int>>& mat) {\\n        int n = mat.size(), m = mat[0].size();\\n        vector<int> row_max(n), col_max(m);\\n        \\n        map<int, vector<pair<int, int>>, greater<int>> pos;\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < m; ++j) {\\n                pos[mat[i][j]].push_back({i, j});\\n            }\\n        }\\n        \\n        int ans = 0;\\n        for (auto& [num, cells]: pos) {\\n            int k = cells.size();\\n            vector<int> next(k);\\n            for (int i = 0; i < k; ++i) {\\n                int r = cells[i].first, c = cells[i].second;\\n                next[i] = max(row_max[r], col_max[c]) + 1;\\n                ans = max(ans, next[i]);\\n            }\\n            for (int i = 0; i < k; ++i) {\\n                int r = cells[i].first, c = cells[i].second;\\n                row_max[r] = max(row_max[r], next[i]);\\n                col_max[c] = max(col_max[c], next[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
        "level": "hard",
        "type": [
            "operation error",
            "wrong comment mark"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    int maxIncreasingCells(vector<vector<int>>& mat) {\n        int n = mat.size(), m = mat[0].size();\n        /*vector<int>*/ row_max(n), col_max(m);\n        \n        map<int, vector<pair<int, int>>, greater<int>> pos;\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                pos[mat[i][j]].push_back({i, j});\n            }\n        }\n        \n        int ans = 0;\n        for (auto& [num, cells]: pos) {\n            int k = cells.size();\n            vector<int> next(k);\n            for (int i = 0; i < k; ++i) {\n                int r = cells[i].first, c = cells[i].second;\n                next[i] = min(row_max[r], col_max[c]) + 1;\n                ans = max(ans, next[i]);\n            }\n            for (int i = 0; i < k; ++i) {\n                int r = cells[i].first, c = cells[i].second;\n                row_max[r] = max(row_max[r], next[i]);\n                col_max[c] = max(col_max[c], next[i]);\n            }\n        }\n        return ans;\n    }\n};\n"
    },
    {
        "slug": "distance-between-bus-stops",
        "description": "A bus\u00a0has n stops numbered from 0 to n - 1 that form\u00a0a circle. We know the distance between all pairs of neighboring stops where distance[i] is the distance between the stops number\u00a0i and (i + 1) % n.\nThe bus goes along both directions\u00a0i.e. clockwise and counterclockwise.\nReturn the shortest distance between the given\u00a0start\u00a0and destination\u00a0stops.",
        "examples": [
            "Input: distance = [1,2,3,4], start = 0, destination = 1\r\nOutput: 1\r\nExplanation: Distance between 0 and 1 is 1 or 9, minimum is 1.",
            "Input: distance = [1,2,3,4], start = 0, destination = 2\r\nOutput: 3\r\nExplanation: Distance between 0 and 2 is 3 or 7, minimum is 3.",
            "Input: distance = [1,2,3,4], start = 0, destination = 3\r\nOutput: 4\r\nExplanation: Distance between 0 and 3 is 6 or 4, minimum is 4."
        ],
        "constraints": "1 <= n\u00a0<= 10^4\ndistance.length == n\n0 <= start, destination < n\n0 <= distance[i] <= 10^4",
        "oracle_code": "class Solution {\npublic:\n    int distanceBetweenBusStops(vector<int>& distance, int start, int destination) {\n        int i, dis1=0, dis2=0, j, temp;\n\n        // Swapping the values of start and destination, if destination is smaller than start\n        if(start>destination)\n        {\n            temp = start;\n            start = destination;\n            destination = temp;\n        }\n\n        //Checking Forward distance\n        for(i=start ; i<destination ; i++)\n        {\n            dis1 += distance[i];\n        }\n\n        //Checking Backward distance\n        i = start-1;\n        j = distance.size()-destination+start;\n        while(j>0)\n        {\n            if(i<0)\n            {\n                dis2 += distance[distance.size()+i];\n            }\n            else\n                dis2 += distance[i];\n            i--;\n            j--;\n        }\n\n        // Result\n        if(dis1<dis2)\n            return dis1;\n        return dis2;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int distanceBetweenBusStops(vector<int>& distance, int start, int destination) {\\n        int i, dis1=0, dis2=0, j, temp;\\n\\n        // Swapping the values of start and destination, if destination is smaller than start\\n        if(start>destination)\\n        {\\n            temp = start;\\n            start = destination;\\n            destination = temp;\\n        }\\n\\n        //Checking Forward distance\\n        for(i=start ; i<destination ; i++)\\n        {\\n            dis1 += distance[i];\\n        }\\n\\n        //Checking Backward distance\\n        i = start-1;\\n        j = distance.size()-destination+start;\\n        while(j>0)\\n        {\\n            if(i<0)\\n            {\\n                dis2 += distance[distance.size()+i];\\n            }\\n            else\\n                dis2 += distance[i];\\n            i--;\\n            j--;\\n        }\\n\\n        // Result\\n        if(dis1<dis2)\\n            return dis1;\\n        return dis2;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/07016b53-8ada-4070-aab3-3dbdab28415c_1682917170.9058347.jpeg)\\n",
        "level": "easy",
        "type": [
            "indexing error",
            "colon missing"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    int distanceBetweenBusStops(vector<int>& distance, int start, int destination) {\n        int i, dis1=0, dis2=0, j, temp;\n\n        // Swapping the values of start and destination, if destination is smaller than start\n        if(start>destination)\n        {\n            temp = start;\n            start = destination;\n            destination = temp;\n        }\n\n        //Checking Forward distance\n        for(i=start ; i<=destination ; i++)\n        {\n            dis1 += distance[i];\n        }\n\n        //Checking Backward distance\n        i = start-1;\n        j = distance.size()-destination+start;\n        while(j>0)\n        {\n            if(i<0)\n            {\n                dis2 += distance[distance.size()+i];\n            }\n            else\n                dis2 += distance[i]\n            i--;\n            j--;\n        }\n\n        // Result\n        if(dis1<dis2)\n            return dis1;\n        return dis2;\n    }\n};\n"
    },
    {
        "slug": "check-knight-tour-configuration",
        "description": "There is a knight on an n x n chessboard. In a valid configuration, the knight starts at the top-left cell of the board and visits every cell on the board exactly once.\nYou are given an n x n integer matrix grid consisting of distinct integers from the range [0, n * n - 1] where grid[row][col] indicates that the cell (row, col) is the grid[row][col]th cell that the knight visited. The moves are 0-indexed.\nReturn true if grid represents a valid configuration of the knight's movements or false otherwise.\nNote that a valid knight move consists of moving two squares vertically and one square horizontally, or two squares horizontally and one square vertically. The figure below illustrates all the possible eight moves of a knight from some cell.",
        "examples": [
            "Input: grid = [[0,11,16,5,20],[17,4,19,10,15],[12,1,8,21,6],[3,18,23,14,9],[24,13,2,7,22]]\nOutput: true\nExplanation: The above diagram represents the grid. It can be shown that it is a valid configuration.",
            "Input: grid = [[0,3,6],[5,8,1],[2,7,4]]\nOutput: false\nExplanation: The above diagram represents the grid. The 8th move of the knight is not valid considering its position after the 7th move."
        ],
        "constraints": "n == grid.length == grid[i].length\n3 <= n <= 7\n0 <= grid[row][col] < n * n\nAll integers in grid are unique.",
        "oracle_code": "class Solution {\nprivate:\n    bool helper(vector<vector<int>>& grid, int row, int col, int num){\n        int n = grid.size();\n        if(num == n*n) return true;\n        int i = row-2;\n        int j = col+1;\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row-2;\n        j = col-1;\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 2;\n        j = col - 1;\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 2;\n        j = col + 1;\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 1;\n        j = col + 2;\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row - 1;\n        j = col + 2;\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row - 1;\n        j = col - 2;\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 1;\n        j = col - 2;\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        return false;\n    }\npublic:\n    bool checkValidGrid(vector<vector<int>>& grid) {\n        ios::sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);\n        if(grid[0][0] != 0) return false;\n        return helper(grid,0,0,1);\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    bool helper(vector<vector<int>>& grid, int row, int col, int num){\\n        int n = grid.size();\\n        if(num == n*n) return true;\\n        int i = row-2;\\n        int j = col+1;\\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row-2;\\n        j = col-1;\\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row + 2;\\n        j = col - 1;\\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row + 2;\\n        j = col + 1;\\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row + 1;\\n        j = col + 2;\\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row - 1;\\n        j = col + 2;\\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row - 1;\\n        j = col - 2;\\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row + 1;\\n        j = col - 2;\\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        return false;\\n    }\\npublic:\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(0);\\n        cout.tie(0);\\n        if(grid[0][0] != 0) return false;\\n        return helper(grid,0,0,1);\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "wrong comment mark",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\nprivate:\n    bool helper(vector<vector<int>>& grid, int row, int col, int num){\n        int n \n        if(num == n*n) return true;\n        int i = row-2;\n        int j = col+1;\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row-2;\n        j = col-1;\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 2;\n        j = col - 1;\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 2;\n        j = col + 1;\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 1;\n        j = col + 2;\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row - 1;\n        j = col + 2;\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row - 1;\n        j = col - 2;\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 1;\n        j = col - 2;\n        if(i<n && j>=0 && grid[i][j] == num) return methodNotFound(grid,i,j,num+1);\n\n        return false;\n    }\npublic:\n    bool checkValidGrid(vector<vector<int>>& grid) {\n        ios::sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);\n        if(grid[0][0] != 0) return false;\n        return helper(grid,0,0,1);\n    }\n};\n"
    },
    {
        "slug": "maximum-gap",
        "description": "Given an integer array nums, return the maximum difference between two successive elements in its sorted form. If the array contains less than two elements, return 0.\nYou must write an algorithm that runs in linear time and uses linear extra space.",
        "examples": [
            "Input: nums = [3,6,9,1]\nOutput: 3\nExplanation: The sorted form of the array is [1,3,6,9], either (3,6) or (6,9) has the maximum difference 3.",
            "Input: nums = [10]\nOutput: 0\nExplanation: The array contains less than 2 elements, therefore return 0."
        ],
        "constraints": "1 <= nums.length <= 105\n0 <= nums[i] <= 109",
        "oracle_code": "class Solution {\npublic:\n\nvector<int> countsort(vector<int> &nums)\n{\n    int n = nums.size();\n    map<int, int> m;\n    for (int i = 0; i < n; i++ )\n        m[nums[i]]++;\n\n    nums.clear();\n    for (auto it : m)\n    {\n        int cnt = it.second;\n        while (cnt--)\n        {\n            nums.push_back(it.first);\n        }\n    }\n    return nums;\n}\n\nint maximumGap(vector<int> &nums)\n{\n    int n = nums.size();\n    if (n < 2)\n        return 0;\n    vector<int> sortednums = countsort(nums);\n\n    int maxgap = INT_MIN;\n    for (int i = 1; i < n; i++)\n    {\n        int currgap = sortednums[i] - sortednums[i - 1];\n        maxgap = max(maxgap, currgap);\n    }\n\n    return maxgap;\n}\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nsince it is given in the question that we can use only linear time and space so we can only use a kind of counting sort , where we required a hash map which take an extra o(n) time complexity.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn counting sort first we required an hash map where we store the frequency of each element and after storing the frequency we just need to fill the original array based on there frequency , here we use an map not unordered map because the map is store value in sorted order.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nwe are traversing the array once , so  it is O(n) and an extra (logn)\\nfactor comes because of using the map, but still it is better in terms of time from inbuilt sort function..\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n) we are using only an map so the total extra space is equal to the size of map.\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\nvector<int> countsort(vector<int> &nums)\\n{\\n    int n = nums.size();\\n    map<int, int> m;\\n    for (int i = 0; i < n; i++ )\\n        m[nums[i]]++;\\n\\n    nums.clear();\\n    for (auto it : m)\\n    {\\n        int cnt = it.second;\\n        while (cnt--)\\n        {\\n            nums.push_back(it.first);\\n        }\\n    }\\n    return nums;\\n}\\n\\nint maximumGap(vector<int> &nums)\\n{\\n    int n = nums.size();\\n    if (n < 2)\\n        return 0;\\n    vector<int> sortednums = countsort(nums);\\n\\n    int maxgap = INT_MIN;\\n    for (int i = 1; i < n; i++)\\n    {\\n        int currgap = sortednums[i] - sortednums[i - 1];\\n        maxgap = max(maxgap, currgap);\\n    }\\n\\n    return maxgap;\\n}\\n};\\n```",
        "level": "medium",
        "type": [
            "indexing error",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n\nvector<int> countsort(vector<int> &nums)\n{\n    int n = nums.size();\n    map<int, int> m;\n    for (int i = 0; i < n; i++ )\n        m[nums[i]]++;\n\n    nums.clear();\n    for (auto it : m)\n    {\n        int cnt = it.second;\n        while (cnt--\n        {\n            nums.push_back(it.first);\n        }\n    }\n    return nums;\n}\n\nint maximumGap(vector<int> &nums)\n{\n    int n = nums.size();\n    if (n < 2)\n        return 0;\n    vector<int> sortednums = countsort(nums);\n\n    int maxgap = INT_MIN;\n    for (int i = 1; i <= n; i++)\n    {\n        int currgap = sortednums[i] - sortednums[i - 1];\n        maxgap = max(maxgap, currgap);\n    }\n\n    return maxgap;\n}\n};\n"
    },
    {
        "slug": "power-of-heroes",
        "description": "You are given a 0-indexed integer array nums representing the strength of some heroes. The power of a group of heroes is defined as follows:\n\nLet i0, i1, ... ,ik be the indices of the heroes in a group. Then, the power of this group is max(nums[i0], nums[i1], ... ,nums[ik])2 * min(nums[i0], nums[i1], ... ,nums[ik]).\n\nReturn the sum of the power of all non-empty groups of heroes possible. Since the sum could be very large, return it modulo 109 + 7.",
        "examples": [
            "Input: nums = [2,1,4]\nOutput: 141\nExplanation: \n1st\u00a0group: [2] has power = 22\u00a0* 2 = 8.\n2nd\u00a0group: [1] has power = 12 * 1 = 1. \n3rd\u00a0group: [4] has power = 42 * 4 = 64. \n4th\u00a0group: [2,1] has power = 22 * 1 = 4. \n5th\u00a0group: [2,4] has power = 42 * 2 = 32. \n6th\u00a0group: [1,4] has power = 42 * 1 = 16. \n\u200b\u200b\u200b\u200b\u200b\u200b\u200b7th\u00a0group: [2,1,4] has power = 42\u200b\u200b\u200b\u200b\u200b\u200b\u200b * 1 = 16. \nThe sum of powers of all groups is 8 + 1 + 64 + 4 + 32 + 16 + 16 = 141.",
            "Input: nums = [1,1,1]\nOutput: 7\nExplanation: A total of 7 groups are possible, and the power of each group will be 1. Therefore, the sum of the powers of all groups is 7."
        ],
        "constraints": "1 <= nums.length <= 105\n1 <= nums[i] <= 109",
        "oracle_code": "class Solution {\n    const int M = 1000000007;\n    int mul(long long x, long long y) {\n        return x * y % M;\n    }\n    \n    int add(int x, int y) {\n        if ((x += y) >= M) {\n            x -= M;\n        }\n        return x; \n    }\n\npublic:\n    int sumOfPower(vector<int>& nums) {\n        sort(nums.begin(), nums.end());\n        const int n = nums.size();\n        int r = mul(mul(nums[0], nums[0]), nums[0]);\n        for (int i = 1, last = 0; i < n; ++i) {\n            last = add(nums[i - 1], add(last, last));\n            r = add(r, mul(add(last, nums[i]), mul(nums[i], nums[i])));\n        }\n        \n        return r;\n    }\n};",
        "content": "# Intuition\\nJust sort\\n\\n# Approach\\nJust sort\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\nC++\\n```\\nclass Solution {\\n    const int M = 1000000007;\\n    int mul(long long x, long long y) {\\n        return x * y % M;\\n    }\\n    \\n    int add(int x, int y) {\\n        if ((x += y) >= M) {\\n            x -= M;\\n        }\\n        return x; \\n    }\\n\\npublic:\\n    int sumOfPower(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        const int n = nums.size();\\n        int r = mul(mul(nums[0], nums[0]), nums[0]);\\n        for (int i = 1, last = 0; i < n; ++i) {\\n            last = add(nums[i - 1], add(last, last));\\n            r = add(r, mul(add(last, nums[i]), mul(nums[i], nums[i])));\\n        }\\n        \\n        return r;\\n    }\\n};\\n```\\n\\n\\nJava\\n```\\n\\nclass Solution {\\n    private final int M = 1000000007;\\n    private int mul(long x, long y) {\\n        return (int) (x * y % M);\\n    }\\n\\n    private int add(int x, int y) {\\n        if ((x += y) >= M) {\\n            x -= M;\\n        }\\n        return x; \\n    }\\n\\n    public int sumOfPower(int[] nums) {\\n        Arrays.sort(nums);\\n        final int n = nums.length;\\n        int r = mul(mul(nums[0], nums[0]), nums[0]);\\n        for (int i = 1, last = 0; i < n; ++i) {\\n            last = add(nums[i - 1], add(last, last));\\n            r = add(r, mul(add(last, nums[i]), mul(nums[i], nums[i])));\\n        }\\n\\n        return r;\\n    }\\n}\\n\\n```\\n\\nPython3\\n\\n```\\nclass Solution:\\n    def sumOfPower(self, nums: List[int]) -> int:\\n        M = 1000000007\\n        def mul(x: int, y: int) -> int:\\n            return x * y % M\\n        \\n        def add(x: int, y: int) -> int:\\n            x += y\\n            if x >= M:\\n                x -= M\\n            return x; \\n        nums.sort()\\n        n = len(nums)\\n        r = mul(mul(nums[0], nums[0]), nums[0])\\n        last = 0\\n        for i in range(1, n):\\n            last = add(nums[i - 1], add(last, last));\\n            r = add(r, mul(add(last, nums[i]), mul(nums[i], nums[i])));\\n        return r;\\n\\n        \\n```\\n",
        "level": "hard",
        "type": [
            "conditional statement error",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\n    const int M = 1000000007;\n    int mul(long long x, long long y) {\n        return x * y % M;\n    }\n    \n    int add(int x, int y) {\n        if ((x += y) >= M) {\n            x -= M;\n        }\n        return x; \n    }\n\npublic:\n    int sumOfPower(vector<int>& nums) {\n        sort(nums.begin(), nums.end());\n        const int n = nums.size();\n        int r = mul(mul(nums[0], nums[0]), nums[0]);\n        last = add(nums[i - 1], add(last, last));\n        for (int i = 0; i < n; ++i) {\n            r = add(r, mul(add(last, nums[i]), mul(nums[i], nums[i])));\n        }\n        \n        return r;\n    }\n};\n"
    },
    {
        "slug": "closest-nodes-queries-in-a-binary-search-tree",
        "description": "You are given the root of a binary search tree and an array queries of size n consisting of positive integers.\nFind a 2D array answer of size n where answer[i] = [mini, maxi]:\n\nmini is the largest value in the tree that is smaller than or equal to queries[i]. If a such value does not exist, add -1 instead.\nmaxi is the smallest value in the tree that is greater than or equal to queries[i]. If a such value does not exist, add -1 instead.\n\nReturn the array answer.",
        "examples": [
            "Input: root = [6,2,13,1,4,9,15,null,null,null,null,null,null,14], queries = [2,5,16]\nOutput: [[2,2],[4,6],[15,-1]]\nExplanation: We answer the queries in the following way:\n- The largest number that is smaller or equal than 2 in the tree is 2, and the smallest number that is greater or equal than 2 is still 2. So the answer for the first query is [2,2].\n- The largest number that is smaller or equal than 5 in the tree is 4, and the smallest number that is greater or equal than 5 is 6. So the answer for the second query is [4,6].\n- The largest number that is smaller or equal than 16 in the tree is 15, and the smallest number that is greater or equal than 16 does not exist. So the answer for the third query is [15,-1].",
            "Input: root = [4,null,9], queries = [3]\nOutput: [[-1,4]]\nExplanation: The largest number that is smaller or equal to 3 in the tree does not exist, and the smallest number that is greater or equal to 3 is 4. So the answer for the query is [-1,4]."
        ],
        "constraints": "The number of nodes in the tree is in the range [2, 105].\n1 <= Node.val <= 106\nn == queries.length\n1 <= n <= 105\n1 <= queries[i] <= 106",
        "oracle_code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\n \nclass Solution {\npublic:\n        void dfs(TreeNode* root, vector<int>& bv){\n            if (root==NULL)return;\n            if (root->left)dfs(root->left,bv);\n            bv.push_back(root->val);\n            if (root->right)dfs(root->right,bv);\n        }\n\t\t\n        int min1(vector<int>& bv, int val){\n            int ans= -1;\n            int i=0; int j= bv.size()-1;\n            while (i<=j){\n                int mid= i+ (j-i)/2;\n                if (val== bv[mid])return val;\n                if (val> bv[mid]){\n                    ans= bv[mid];\n                    i= mid+1;\n                }\n                else j= mid-1;\n            }\n            return ans;\n        }\n\t\t\n    int max1(vector<int>& bv,int val){\n        int ans= -1;\n        int i=0; int j= bv.size()-1;\n        while (i<=j){\n            int mid= i+ (j-i)/2;\n            if (val== bv[mid])return val;\n            if (val < bv[mid]){\n                ans= bv[mid];\n                j= mid-1;\n            }\n            else i= mid+1;\n        }\n        return ans;\n    }\n\t\n        vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\n        vector<int> bv;\n        vector<vector<int>> ans;\n        //dfs se sorted list banate hai.\n        dfs(root,bv);\n        for (auto q: queries){\n            int lb= min1(bv,q);\n            int ub= max1(bv,q);\n            ans.push_back({lb,ub});\n        }\n        return ans;\n    }\n    \n};",
        "content": "Here is my C++ solution :-\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n \\nclass Solution {\\npublic:\\n        void dfs(TreeNode* root, vector<int>& bv){\\n            if (root==NULL)return;\\n            if (root->left)dfs(root->left,bv);\\n            bv.push_back(root->val);\\n            if (root->right)dfs(root->right,bv);\\n        }\\n\\t\\t\\n        int min1(vector<int>& bv, int val){\\n            int ans= -1;\\n            int i=0; int j= bv.size()-1;\\n            while (i<=j){\\n                int mid= i+ (j-i)/2;\\n                if (val== bv[mid])return val;\\n                if (val> bv[mid]){\\n                    ans= bv[mid];\\n                    i= mid+1;\\n                }\\n                else j= mid-1;\\n            }\\n            return ans;\\n        }\\n\\t\\t\\n    int max1(vector<int>& bv,int val){\\n        int ans= -1;\\n        int i=0; int j= bv.size()-1;\\n        while (i<=j){\\n            int mid= i+ (j-i)/2;\\n            if (val== bv[mid])return val;\\n            if (val < bv[mid]){\\n                ans= bv[mid];\\n                j= mid-1;\\n            }\\n            else i= mid+1;\\n        }\\n        return ans;\\n    }\\n\\t\\n        vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        vector<int> bv;\\n        vector<vector<int>> ans;\\n        //dfs se sorted list banate hai.\\n        dfs(root,bv);\\n        for (auto q: queries){\\n            int lb= min1(bv,q);\\n            int ub= max1(bv,q);\\n            ans.push_back({lb,ub});\\n        }\\n        return ans;\\n    }\\n    \\n};\\n```",
        "level": "medium",
        "type": [
            "conditional statement error",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\n\nclass Solution {\npublic:\n        void dfs(TreeNode* root, List<int>& bv){\n            if (root==NULL)return;\n            if (root->left)dfs(root->left,bv);\n            bv.add(root->val);\n            if (root->right)dfs(root->right,bv);\n        }\n\t\t\n        int min1(List<int>& bv, int val){\n            int ans= -1;\n            int i=0; int j= bv.size()-1;\n            while (i<=j){\n                int mid= i+ (j-i)/2;\n                if (val== bv[mid])return val;\n                ans= bv[mid];\n                i= mid+1;\n            }\n            return ans;\n        }\n\t\t\n    int max1(vector<int>& bv,int val){\n        int ans= -1;\n        int i=0; int j= bv.size()-1;\n        while (i<=j){\n            int mid= i+ (j-i)/2;\n            if (val== bv[mid])return val;\n            if (val < bv[mid]){\n                ans= bv[mid];\n                j= mid-1;\n            }\n            else i= mid+1;\n        }\n        return ans;\n    }\n\t\n        vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\n        vector<int> bv;\n        vector<vector<int>> ans;\n        dfs(root,bv);\n        for (auto q: queries){\n            int lb= min1(bv,q);\n            int ub= max1(LisArayListArayListLisLisArayListArayListbv,q);\n            ans.add({lb,ub});\n        }\n        return ans;\n    }\n    \n};\n"
    },
    {
        "slug": "check-knight-tour-configuration",
        "description": "There is a knight on an n x n chessboard. In a valid configuration, the knight starts at the top-left cell of the board and visits every cell on the board exactly once.\nYou are given an n x n integer matrix grid consisting of distinct integers from the range [0, n * n - 1] where grid[row][col] indicates that the cell (row, col) is the grid[row][col]th cell that the knight visited. The moves are 0-indexed.\nReturn true if grid represents a valid configuration of the knight's movements or false otherwise.\nNote that a valid knight move consists of moving two squares vertically and one square horizontally, or two squares horizontally and one square vertically. The figure below illustrates all the possible eight moves of a knight from some cell.",
        "examples": [
            "Input: grid = [[0,11,16,5,20],[17,4,19,10,15],[12,1,8,21,6],[3,18,23,14,9],[24,13,2,7,22]]\nOutput: true\nExplanation: The above diagram represents the grid. It can be shown that it is a valid configuration.",
            "Input: grid = [[0,3,6],[5,8,1],[2,7,4]]\nOutput: false\nExplanation: The above diagram represents the grid. The 8th move of the knight is not valid considering its position after the 7th move."
        ],
        "constraints": "n == grid.length == grid[i].length\n3 <= n <= 7\n0 <= grid[row][col] < n * n\nAll integers in grid are unique.",
        "oracle_code": "class Solution {\nprivate:\n    bool helper(vector<vector<int>>& grid, int row, int col, int num){\n        int n = grid.size();\n        if(num == n*n) return true;\n        int i = row-2;\n        int j = col+1;\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row-2;\n        j = col-1;\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 2;\n        j = col - 1;\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 2;\n        j = col + 1;\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 1;\n        j = col + 2;\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row - 1;\n        j = col + 2;\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row - 1;\n        j = col - 2;\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 1;\n        j = col - 2;\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        return false;\n    }\npublic:\n    bool checkValidGrid(vector<vector<int>>& grid) {\n        ios::sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);\n        if(grid[0][0] != 0) return false;\n        return helper(grid,0,0,1);\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    bool helper(vector<vector<int>>& grid, int row, int col, int num){\\n        int n = grid.size();\\n        if(num == n*n) return true;\\n        int i = row-2;\\n        int j = col+1;\\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row-2;\\n        j = col-1;\\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row + 2;\\n        j = col - 1;\\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row + 2;\\n        j = col + 1;\\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row + 1;\\n        j = col + 2;\\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row - 1;\\n        j = col + 2;\\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row - 1;\\n        j = col - 2;\\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row + 1;\\n        j = col - 2;\\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        return false;\\n    }\\npublic:\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(0);\\n        cout.tie(0);\\n        if(grid[0][0] != 0) return false;\\n        return helper(grid,0,0,1);\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "== and = confusion",
            "wrong comment mark"
        ],
        "buggy_code": "\nclass Solution {\nprivate:\n    bool helper(vector<vector<int>>& grid, int row, int col, int num){\n        int n \n        if(num = n*n) return true;\n        int i = row-2;\n        int j = col+1;\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row-2;\n        j = col-1;\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 2;\n        j = col - 1;\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 2;\n        j = col + 1;\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 1;\n        j = col + 2;\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row - 1;\n        j = col + 2;\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row - 1;\n        j = col - 2;\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 1;\n        j = col - 2;\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        return false;\n    }\npublic:\n    bool checkValidGrid(vector<vector<int>>& grid) {\n        ios::sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);\n        if(grid[0][0] != 0) return false;\n        return helper(grid,0,0,1);\n    }\n};\n"
    },
    {
        "slug": "relative-ranks",
        "description": "You are given an integer array score of size n, where score[i] is the score of the ith athlete in a competition. All the scores are guaranteed to be unique.\nThe athletes are placed based on their scores, where the 1st place athlete has the highest score, the 2nd place athlete has the 2nd highest score, and so on. The placement of each athlete determines their rank:\n\nThe 1st place athlete's rank is \"Gold Medal\".\nThe 2nd place athlete's rank is \"Silver Medal\".\nThe 3rd place athlete's rank is \"Bronze Medal\".\nFor the 4th place to the nth place athlete, their rank is their placement number (i.e., the xth place athlete's rank is \"x\").\n\nReturn an array answer of size n where answer[i] is the rank of the ith athlete.",
        "examples": [
            "Input: score = [5,4,3,2,1]\nOutput: [\"Gold Medal\",\"Silver Medal\",\"Bronze Medal\",\"4\",\"5\"]\nExplanation: The placements are [1st, 2nd, 3rd, 4th, 5th].",
            "Input: score = [10,3,8,9,4]\nOutput: [\"Gold Medal\",\"5\",\"Bronze Medal\",\"Silver Medal\",\"4\"]\nExplanation: The placements are [1st, 5th, 3rd, 2nd, 4th]."
        ],
        "constraints": "n == score.length\n1 <= n <= 104\n0 <= score[i] <= 106\nAll the values in score are unique.",
        "oracle_code": "class Solution {\npublic:\n    vector<string> findRelativeRanks(vector<int>& score) {\n        int n = score.size();\n        \n        vector<pair<int, int>> arr;\n        for (int i=0; i<n; i++) arr.push_back({score[i], i});\n\n        sort(rbegin(arr), rend(arr));\n\n        vector<string> res(n);\n        for (int i=0; i<n; i++) \n            res[arr[i].second] = i==0? \"Gold Medal\": (i==1? \"Silver Medal\": (i==2? \"Bronze Medal\": to_string(i+1)));\n\n        return res;\n    }\n};",
        "content": "**vector solution**\\n```\\nclass Solution {\\npublic:\\n    vector<string> findRelativeRanks(vector<int>& score) {\\n        int n = score.size();\\n        \\n        vector<pair<int, int>> arr;\\n        for (int i=0; i<n; i++) arr.push_back({score[i], i});\\n\\n        sort(rbegin(arr), rend(arr));\\n\\n        vector<string> res(n);\\n        for (int i=0; i<n; i++) \\n            res[arr[i].second] = i==0? \"Gold Medal\": (i==1? \"Silver Medal\": (i==2? \"Bronze Medal\": to_string(i+1)));\\n\\n        return res;\\n    }\\n};\\n```\\n---\\n**priority queue solution**\\n```\\nclass Solution {\\npublic:\\n    vector<string> findRelativeRanks(vector<int>& score) {\\n        int n = score.size();\\n        \\n        priority_queue< pair<int, int>, vector<pair<int,int>> > pq;\\n        for (int i=0; i<n; i++) pq.push({score[i], i});\\n\\n        vector<string> res(n);\\n        while (!pq.empty()) {\\n            auto x = pq.top();\\n            int size = pq.size();\\n            res[x.second] = (size == n? \"Gold Medal\": (size == n-1? \"Silver Medal\": (size == n-2? \"Bronze Medal\": to_string(n-size+1))));\\n            pq.pop();\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "== and = confusion",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    vector<string> findRelativeRanks(vector<int>& score) {\n        int n = score.size();\n        \n        vector<pair<int, int>> arr;\n        for (int i=0; i<n; i++) arr.push_back({score[i], i});\n\n        sort(rbegin(arr), rend(arr));\n\n        vector<string> res(n);\n        for (int i=0; i<n; i++) \n            res[arr[i].second] = i==0? \"Gold Medal\": (i=1? \"Silver Medal\": (i=2? \"Bronze Medal\": to_s(i+1)));\n\n        return res;\n    }\n};\n"
    },
    {
        "slug": "unique-binary-search-trees",
        "description": "Given an integer n, return the number of structurally unique BST's (binary search trees) which has exactly n nodes of unique values from 1 to n.",
        "examples": [
            "Input: n = 3\nOutput: 5",
            "Input: n = 1\nOutput: 1"
        ],
        "constraints": "1 <= n <= 19",
        "oracle_code": "class Solution {\npublic:\nint solve(int n)\n{\n    vector<int>dp(n+1,0);    \n    dp[0]=dp[1]=1;\n    for(int i=2;i<=n;i++)\n    {\n        for(int j= 1;j<=i;j++)\n        {\n            dp[i]+= dp[j-1]*dp[i-j];\n        }\n    }\n        return dp[n];\n}\n    int numTrees(int n) {\n    return solve(n); \n    }\n};",
        "content": "# Homework for you\\nSolve using catalan number and comment the code \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe main function numTrees(n) takes an integer n as input and returns the total number of unique binary search trees that can be formed with n nodes.\\n\\nThe helper function solve(n) takes an integer n (representing the number of nodes to form a binary search tree) and returns the number of unique binary search trees that can be formed with n nodes.\\n\\nIn the helper function solve, it initializes a vector dp of size n + 1 with all elements set to 0. The vector dp will be used to store the number of unique binary search trees for i nodes.\\n\\nInitialize dp[0] and dp[1] to 1 since there is only one way to form binary search trees with 0 and 1 nodes (empty tree and single-node tree).\\n\\nIterate from i = 2 up to n. For each i, calculate the number of unique binary search trees using the Catalan number formula: dp[i] = dp[0] * dp[i - 1] + dp[1] * dp[i - 2] + ... + dp[i - 1] * dp[0]. This calculation is done by considering each element j as the root and multiplying the number of unique binary search trees for the left subtree (with j - 1 nodes) and the right subtree (with i - j nodes).\\n\\nReturn dp[n], which represents the total number of unique binary search trees with n nodes.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:0(n*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint solve(int n)\\n{\\n    vector<int>dp(n+1,0);    \\n    dp[0]=dp[1]=1;\\n    for(int i=2;i<=n;i++)\\n    {\\n        for(int j= 1;j<=i;j++)\\n        {\\n            dp[i]+= dp[j-1]*dp[i-j];\\n        }\\n    }\\n        return dp[n];\\n}\\n    int numTrees(int n) {\\n    return solve(n); \\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "conditional statement error",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution {\npublic:\nint solve(int n)\n{\n    vector<int>dp(n+1,0);    \n    dp[0]=dp[1]=1;\n    for(int i=2;i<=n;i++)\n    {\n        for(int j= 0;j<=i;j++)\n        {\n            dp[i]+= dp[j-1]*dp[i-j];\n        }\n    return dp[n];\n    }\n    int numTrees(int n) {\n    return solve(n); \n    }\n};\n"
    },
    {
        "slug": "group-anagrams",
        "description": "Given an array of strings strs, group the anagrams together. You can return the answer in any order.\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.",
        "examples": [
            "Input: strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]\nOutput: [[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]",
            "Input: strs = [\"\"]\nOutput: [[\"\"]]",
            "Input: strs = [\"a\"]\nOutput: [[\"a\"]]"
        ],
        "constraints": "1 <= strs.length <= 104\n0 <= strs[i].length <= 100\nstrs[i] consists of lowercase English letters.",
        "oracle_code": "class Solution {\npublic:\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\n        unordered_map<string,int> m;\n        vector<vector<string>> ans;\n        for(int i=0; i<strs.size(); i++) {\n            string str = strs[i];\n            sort(str.begin(),str.end());\n\n            if(m.find(str) != m.end()) {\n                ans[m[str]].push_back(strs[i]);\n            }\n            else {\n                m[str] = ans.size(); \n                ans.push_back({strs[i]});\n            }\n        }\n        return ans;\n    }\n};",
        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        unordered_map<string,int> m;\\n        vector<vector<string>> ans;\\n        for(int i=0; i<strs.size(); i++) {\\n            string str = strs[i];\\n            sort(str.begin(),str.end());\\n\\n            if(m.find(str) != m.end()) {\\n                ans[m[str]].push_back(strs[i]);\\n            }\\n            else {\\n                m[str] = ans.size(); \\n                ans.push_back({strs[i]});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "undefined methods",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\n        unordered_map<string,int> m;\n        vector<vector<string>> ans;\n        for(int i=0; i<strs.size(); i++) {\n            string str = strs[i];\n            sort(str.begin(),str.end());\n\n            if(m.find(str) != m.end()) {\n                ans[m[str].push_back(strs[i]);\n            }\n            else {\n                m[str] = ans.size(); \n                ans.push_back({strs[i]});\n                sortMyVec(ans[m[str]]);\n            }\n        }\n        return ans;\n    }\n};\n"
    },
    {
        "slug": "shortest-path-with-alternating-colors",
        "description": "You are given an integer n, the number of nodes in a directed graph where the nodes are labeled from 0 to n - 1. Each edge is red or blue in this graph, and there could be self-edges and parallel edges.\nYou are given two arrays redEdges and blueEdges where:\n\nredEdges[i] = [ai, bi] indicates that there is a directed red edge from node ai to node bi in the graph, and\nblueEdges[j] = [uj, vj] indicates that there is a directed blue edge from node uj to node vj in the graph.\n\nReturn an array answer of length n, where each answer[x] is the length of the shortest path from node 0 to node x such that the edge colors alternate along the path, or -1 if such a path does not exist.",
        "examples": [
            "Input: n = 3, redEdges = [[0,1],[1,2]], blueEdges = []\nOutput: [0,1,-1]",
            "Input: n = 3, redEdges = [[0,1]], blueEdges = [[2,1]]\nOutput: [0,1,-1]"
        ],
        "constraints": "1 <= n <= 100\n0 <= redEdges.length,\u00a0blueEdges.length <= 400\nredEdges[i].length == blueEdges[j].length == 2\n0 <= ai, bi, uj, vj < n",
        "oracle_code": "class Solution {\npublic:\n    vector<int> shortestAlternatingPaths(int n,vector<vector<int>>&redEdges,vector<vector<int>>& blueEdges) \n    {\n        multiset<int>temp;\n        vector<multiset<int>>redchilds(n,temp),bluechilds(n,temp);\n        for(auto j:redEdges)\n        {\n            redchilds[j[0]].insert(j[1]);\n        }\n        for(auto j:blueEdges)\n        {\n            bluechilds[j[0]].insert(j[1]);\n        }\n        vector<int>ans;\n        for(int i=0;i<n;i++)\n        {\n            //BFS for all\n            vector<multiset<int>>reds=redchilds,blues=bluechilds;\n            queue<pair<char,int>>visit;\n            visit.push({'n',0});//neutral='n'\n            int steps=0;\n            while(!visit.empty())\n            {\n                bool justbreak=false;\n                int n=visit.size();\n                for(int j=0;j<n;j++)\n                {\n                    pair<char,int>x=visit.front();\n                    visit.pop();\n                    if(x.second==i)\n                    {\n                        ans.push_back(steps);\n                        justbreak=true;\n                        break;\n                    }\n                    if(x.first=='n')\n                    {\n                        for(auto j:reds[x.second])\n                        {\n                            visit.push({'r',j});\n                            auto itr1=reds[x.second].find(j);\n                            reds[x.second].erase(itr1);\n                        }\n                        for(auto j:blues[x.second])\n                        {\n                            visit.push({'b',j});//blue='b'\n                            auto itr1=blues[x.second].find(j);\n                            blues[x.second].erase(itr1);\n                        }\n                    }\n                    else if(x.first=='b')\n                    {\n                        for(auto j:reds[x.second])\n                        {\n                            visit.push({'r',j});//red='r'\n                            auto itr1=reds[x.second].find(j);\n                            reds[x.second].erase(itr1);\n                        }\n                    }\n                    else if(x.first=='r')\n                    {\n                        for(auto j:blues[x.second])\n                        {\n                            visit.push({'b',j});\n                            auto itr1=blues[x.second].find(j);\n                            blues[x.second].erase(itr1);\n                        }\n                    }\n                }\n                if(justbreak)\n                {\n                    break;\n                }\n                steps++;\n            }\n            if(i==ans.size())\n            {\n                ans.push_back(-1);\n            }\n        }\n        return ans;\n    }\n};",
        "content": "*E denotes number of Edges*\\n\\n# Complexity\\n- Time complexity:\\nO((N^2)+(N)*(E)*LOG(E))\\n\\n- Space complexity:\\nO(E)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> shortestAlternatingPaths(int n,vector<vector<int>>&redEdges,vector<vector<int>>& blueEdges) \\n    {\\n        multiset<int>temp;\\n        vector<multiset<int>>redchilds(n,temp),bluechilds(n,temp);\\n        for(auto j:redEdges)\\n        {\\n            redchilds[j[0]].insert(j[1]);\\n        }\\n        for(auto j:blueEdges)\\n        {\\n            bluechilds[j[0]].insert(j[1]);\\n        }\\n        vector<int>ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            //BFS for all\\n            vector<multiset<int>>reds=redchilds,blues=bluechilds;\\n            queue<pair<char,int>>visit;\\n            visit.push({\\'n\\',0});//neutral=\\'n\\'\\n            int steps=0;\\n            while(!visit.empty())\\n            {\\n                bool justbreak=false;\\n                int n=visit.size();\\n                for(int j=0;j<n;j++)\\n                {\\n                    pair<char,int>x=visit.front();\\n                    visit.pop();\\n                    if(x.second==i)\\n                    {\\n                        ans.push_back(steps);\\n                        justbreak=true;\\n                        break;\\n                    }\\n                    if(x.first==\\'n\\')\\n                    {\\n                        for(auto j:reds[x.second])\\n                        {\\n                            visit.push({\\'r\\',j});\\n                            auto itr1=reds[x.second].find(j);\\n                            reds[x.second].erase(itr1);\\n                        }\\n                        for(auto j:blues[x.second])\\n                        {\\n                            visit.push({\\'b\\',j});//blue=\\'b\\'\\n                            auto itr1=blues[x.second].find(j);\\n                            blues[x.second].erase(itr1);\\n                        }\\n                    }\\n                    else if(x.first==\\'b\\')\\n                    {\\n                        for(auto j:reds[x.second])\\n                        {\\n                            visit.push({\\'r\\',j});//red=\\'r\\'\\n                            auto itr1=reds[x.second].find(j);\\n                            reds[x.second].erase(itr1);\\n                        }\\n                    }\\n                    else if(x.first==\\'r\\')\\n                    {\\n                        for(auto j:blues[x.second])\\n                        {\\n                            visit.push({\\'b\\',j});\\n                            auto itr1=blues[x.second].find(j);\\n                            blues[x.second].erase(itr1);\\n                        }\\n                    }\\n                }\\n                if(justbreak)\\n                {\\n                    break;\\n                }\\n                steps++;\\n            }\\n            if(i==ans.size())\\n            {\\n                ans.push_back(-1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "unclosed string",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    vector<int> shortestAlternatingPaths(int n,vector<vector<int>>&redEdges,vector<vector<int>>& blueEdges) \n    {\n        multiset<int>temp;\n        vector<multiset<int>>redchilds(n,temp),bluechilds(n,temp);\n        for(auto j:redEdges)\n        {\n            redchilds[j[0]].insert(j[1]);\n        }\n        for(auto j:blueEdges)\n        {\n            bluechilds[j[0]].insert(j[1]);\n        }\n        vector<int>ans;\n        for(int i=0;i<n;i++)\n        {\n            //BFS for all\n            vector<multiset<int>>reds=redchilds,blues=bluechilds;\n            queue<pair<char,int>>visit;\n            visit.push({'n',0});//neutral='n'\n            int steps=0;\n            while(!visit.empty()\n            {\n                bool justbreak=false;\n                int n=visit.size();\n                for(int j=0;j<n;j++)\n                {\n                    pair<char,int>x=visit.front();\n                    visit.pop();\n                    if(x.second==i)\n                    {\n                        ans.push_back(steps);\n                        justbreak=true;\n                        break;\n                    }\n                    if(x.first=='n')\n                    {\n                        for(auto j:reds[x.second])\n                        {\n                            visit.push({'r\",j});\n                            auto itr1=reds[x.second].find(j);\n                            reds[x.second].erase(itr1);\n                        }\n                        for(auto j:blues[x.second])\n                        {\n                            visit.push({'b',j});//blue='b'\n                            auto itr1=blues[x.second].find(j);\n                            blues[x.second].erase(itr1);\n                        }\n                    }\n                    else if(x.first=='b')\n                    {\n                        for(auto j:reds[x.second])\n                        {\n                            visit.push({'r',j});//red='r'\n                            auto itr1=reds[x.second].find(j);\n                            reds[x.second].erase(itr1);\n                        }\n                    }\n                    else if(x.first=='r')\n                    {\n                        for(auto j:blues[x.second])\n                        {\n                            visit.push({'b',j});\n                            auto itr1=blues[x.second].find(j);\n                            blues[x.second].erase(itr1);\n                        }\n                    }\n                }\n                if(justbreak)\n                {\n                    break;\n                }\n                steps++;\n            }\n            if(i==ans.size())\n            {\n                ans.push_back(-1);\n            }\n        }\n        return ans;\n    }\n};\n"
    },
    {
        "slug": "reverse-vowels-of-a-string",
        "description": "Given a string s, reverse only all the vowels in the string and return it.\nThe vowels are 'a', 'e', 'i', 'o', and 'u', and they can appear in both lower and upper cases, more than once.",
        "examples": [
            "Input: s = \"hello\"\nOutput: \"holle\"",
            "Input: s = \"leetcode\"\nOutput: \"leotcede\""
        ],
        "constraints": "1 <= s.length <= 3 * 105\ns consist of printable ASCII characters.",
        "oracle_code": "class Solution {\npublic:\n    string reverseVowels(string s) {\n        \n        vector<char> v;\n        for(int i = 0 ; i < s.length(); i++)\n        {\n            if(s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u'\n              || s[i] == 'A' || s[i] == 'E' || s[i] == 'O' || s[i] == 'I' || s[i] == 'U')\n                v.push_back(s[i]);\n        }\n        reverse(v.begin(), v.end());\n        int rev = 0;\n        for(int i = 0 ; i < s.length(); i++)\n        {\n            if(s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u'\n              || s[i] == 'A' || s[i] == 'E' || s[i] == 'O' || s[i] == 'I' || s[i] == 'U'){\n                s[i] = v[rev];\n                rev++;\n            }\n        }\n        return s;\n    }\n};",
        "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        \\n        vector<char> v;\\n        for(int i = 0 ; i < s.length(); i++)\\n        {\\n            if(s[i] == \\'a\\' || s[i] == \\'e\\' || s[i] == \\'i\\' || s[i] == \\'o\\' || s[i] == \\'u\\'\\n              || s[i] == \\'A\\' || s[i] == \\'E\\' || s[i] == \\'O\\' || s[i] == \\'I\\' || s[i] == \\'U\\')\\n                v.push_back(s[i]);\\n        }\\n        reverse(v.begin(), v.end());\\n        int rev = 0;\\n        for(int i = 0 ; i < s.length(); i++)\\n        {\\n            if(s[i] == \\'a\\' || s[i] == \\'e\\' || s[i] == \\'i\\' || s[i] == \\'o\\' || s[i] == \\'u\\'\\n              || s[i] == \\'A\\' || s[i] == \\'E\\' || s[i] == \\'O\\' || s[i] == \\'I\\' || s[i] == \\'U\\'){\\n                s[i] = v[rev];\\n                rev++;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
        "level": "easy",
        "type": [
            "== and = confusion",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    string reverseVowels(string s) {\n        \n        vector<char> v;\n        for(int i = 0 ; i < s.length(); i++)\n        {\n            if(s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u\n              || s[i] == 'A' || s[i] == 'E' || s[i] == 'O' || s[i] == 'I' || s[i] == 'U')\n                v.push_back(s[i]);\n        }\n        reverse(v.begin(), v.end());\n        int rev = 0;\n        for(int i = 0 ; i < s.length(); i++)\n        {\n            if(s[i] = 'a' || s[i] = 'e' || s[i] = 'i' || s[i] = 'o' || s[i] = 'u\n              || s[i] = 'A' || s[i] = 'E' || s[i] = 'O' || s[i] = 'I' || s[i] = 'U'){\n                s[i] = v[rev];\n                rev++;\n            }\n        }\n        return s;\n    }\n};\n"
    },
    {
        "slug": "sort-an-array",
        "description": "Given an array of integers nums, sort the array in ascending order and return it.\nYou must solve the problem without using any built-in functions in O(nlog(n)) time complexity and with the smallest space complexity possible.",
        "examples": [
            "Input: nums = [5,2,3,1]\nOutput: [1,2,3,5]\nExplanation: After sorting the array, the positions of some numbers are not changed (for example, 2 and 3), while the positions of other numbers are changed (for example, 1 and 5).",
            "Input: nums = [5,1,1,2,0,0]\nOutput: [0,0,1,1,2,5]\nExplanation: Note that the values of nums are not necessairly unique."
        ],
        "constraints": "1 <= nums.length <= 5 * 104\n-5 * 104 <= nums[i] <= 5 * 104",
        "oracle_code": "class Solution {\npublic:\n    void merge(int low, int mid, int high, vector<int> &nums) {\n        if (low >= high) \n        return;\n        int l = low, r = mid + 1, k = 0, size = high - low + 1;\n        vector<int> sorted(size, 0);\n        while (l <= mid and r <= high)\n            sorted[k++] = nums[l] < nums[r] ? nums[l++] : nums[r++];\n        while (l <= mid) \n            sorted[k++] = nums[l++];\n        while (r <= high) \n            sorted[k++] = nums[r++];\n        for (k = 0; k < size; k++)\n            nums[k + low] = sorted[k];\n    }\n\n    void mergeSort(vector<int>& nums, int start, int end){\n        if(start < end){\n            int mid = start + (end - start) / 2;\n            mergeSort(nums, start, mid);\n            mergeSort(nums, mid + 1, end);\n            merge(start, mid, end, nums);\n        }\n    }\n\n    vector<int> sortArray(vector<int>& nums) {\n        mergeSort(nums, 0, nums.size()-1);\n        return nums;\n    }\n};",
        "content": "# Approach\\nThis is an implementation of the merge sort algorithm in C++. The merge sort algorithm uses a divide-and-conquer approach to sort a given array by recursively dividing the input array into two halves, sorting them separately, and then merging them back together in the correct order.\\n\\nThe merge function takes in four parameters: low, mid, high, and nums. low and high represent the indices of the start and end of the subarray that needs to be merged, respectively. mid represents the index of the middle element of the subarray. nums is a reference to the vector of integers that needs to be sorted.\\n\\nIn the merge function, a new vector sorted of size high - low + 1 is created to store the sorted subarray. The two halves of the subarray are then compared and merged into sorted using a while loop. Finally, the sorted subarray is copied back into the original array nums using a for loop.\\n\\nThe mergeSort function takes in three parameters: nums, start, and end. nums is a reference to the vector of integers that needs to be sorted. start and end represent the indices of the start and end of the subarray that needs to be sorted, respectively. In the mergeSort function, the input subarray is recursively divided into two halves using mid, and each half is sorted using the mergeSort function. The merge function is then called to merge the two sorted halves back together in the correct order.\\n\\nFinally, the sortArray function takes in a reference to the vector of integers that needs to be sorted and calls the mergeSort function to sort the entire array. It then returns the sorted array.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void merge(int low, int mid, int high, vector<int> &nums) {\\n        if (low >= high) \\n        return;\\n        int l = low, r = mid + 1, k = 0, size = high - low + 1;\\n        vector<int> sorted(size, 0);\\n        while (l <= mid and r <= high)\\n            sorted[k++] = nums[l] < nums[r] ? nums[l++] : nums[r++];\\n        while (l <= mid) \\n            sorted[k++] = nums[l++];\\n        while (r <= high) \\n            sorted[k++] = nums[r++];\\n        for (k = 0; k < size; k++)\\n            nums[k + low] = sorted[k];\\n    }\\n\\n    void mergeSort(vector<int>& nums, int start, int end){\\n        if(start < end){\\n            int mid = start + (end - start) / 2;\\n            mergeSort(nums, start, mid);\\n            mergeSort(nums, mid + 1, end);\\n            merge(start, mid, end, nums);\\n        }\\n    }\\n\\n    vector<int> sortArray(vector<int>& nums) {\\n        mergeSort(nums, 0, nums.size()-1);\\n        return nums;\\n    }\\n};",
        "level": "medium",
        "type": [
            "indexing error",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    void merge(int low, int mid, int high, vector<int> &nums) {\n        if (low >= high) \n        return;\n        int l = low, r = mid + 1, k = 0, size = high - low + 1;\n        vector<int> sorted(size, 0);\n        while (l <= mid and r <= high)\n            sorted[k++] = nums[l] < nums[r] ? nums[l++] : nums[r++];\n        while (l <= mid) \n            sorted[k++] = nums[l++];\n        while (r <= high) \n            sorted[k++] = nums[r++];\n        for (k = 0; k <= size; k++)\n            nums[k + low] = sorted[k];\n    }\n\n    void mergeSort(vector<int>& nums, int start, int end){\n        if(start < end){\n            int mid = start + (end - start) / 2;\n            mergeSort(nums, start, mid+1); \n            mergeSort(nums, mid + 1, end);\n            merge(start, mid, end, nums);\n        }\n    }\n\n    vector<int> sortArray(vector<int>& nums) {\n        mergeSort(nums, 0, nums.size()-1);\n        return nums;\n    }\n};\n"
    },
    {
        "slug": "shortest-path-with-alternating-colors",
        "description": "You are given an integer n, the number of nodes in a directed graph where the nodes are labeled from 0 to n - 1. Each edge is red or blue in this graph, and there could be self-edges and parallel edges.\nYou are given two arrays redEdges and blueEdges where:\n\nredEdges[i] = [ai, bi] indicates that there is a directed red edge from node ai to node bi in the graph, and\nblueEdges[j] = [uj, vj] indicates that there is a directed blue edge from node uj to node vj in the graph.\n\nReturn an array answer of length n, where each answer[x] is the length of the shortest path from node 0 to node x such that the edge colors alternate along the path, or -1 if such a path does not exist.",
        "examples": [
            "Input: n = 3, redEdges = [[0,1],[1,2]], blueEdges = []\nOutput: [0,1,-1]",
            "Input: n = 3, redEdges = [[0,1]], blueEdges = [[2,1]]\nOutput: [0,1,-1]"
        ],
        "constraints": "1 <= n <= 100\n0 <= redEdges.length,\u00a0blueEdges.length <= 400\nredEdges[i].length == blueEdges[j].length == 2\n0 <= ai, bi, uj, vj < n",
        "oracle_code": "class Solution {\npublic:\n    vector<int> shortestAlternatingPaths(int n,vector<vector<int>>&redEdges,vector<vector<int>>& blueEdges) \n    {\n        multiset<int>temp;\n        vector<multiset<int>>redchilds(n,temp),bluechilds(n,temp);\n        for(auto j:redEdges)\n        {\n            redchilds[j[0]].insert(j[1]);\n        }\n        for(auto j:blueEdges)\n        {\n            bluechilds[j[0]].insert(j[1]);\n        }\n        vector<int>ans;\n        for(int i=0;i<n;i++)\n        {\n            //BFS for all\n            vector<multiset<int>>reds=redchilds,blues=bluechilds;\n            queue<pair<char,int>>visit;\n            visit.push({'n',0});//neutral='n'\n            int steps=0;\n            while(!visit.empty())\n            {\n                bool justbreak=false;\n                int n=visit.size();\n                for(int j=0;j<n;j++)\n                {\n                    pair<char,int>x=visit.front();\n                    visit.pop();\n                    if(x.second==i)\n                    {\n                        ans.push_back(steps);\n                        justbreak=true;\n                        break;\n                    }\n                    if(x.first=='n')\n                    {\n                        for(auto j:reds[x.second])\n                        {\n                            visit.push({'r',j});\n                            auto itr1=reds[x.second].find(j);\n                            reds[x.second].erase(itr1);\n                        }\n                        for(auto j:blues[x.second])\n                        {\n                            visit.push({'b',j});//blue='b'\n                            auto itr1=blues[x.second].find(j);\n                            blues[x.second].erase(itr1);\n                        }\n                    }\n                    else if(x.first=='b')\n                    {\n                        for(auto j:reds[x.second])\n                        {\n                            visit.push({'r',j});//red='r'\n                            auto itr1=reds[x.second].find(j);\n                            reds[x.second].erase(itr1);\n                        }\n                    }\n                    else if(x.first=='r')\n                    {\n                        for(auto j:blues[x.second])\n                        {\n                            visit.push({'b',j});\n                            auto itr1=blues[x.second].find(j);\n                            blues[x.second].erase(itr1);\n                        }\n                    }\n                }\n                if(justbreak)\n                {\n                    break;\n                }\n                steps++;\n            }\n            if(i==ans.size())\n            {\n                ans.push_back(-1);\n            }\n        }\n        return ans;\n    }\n};",
        "content": "*E denotes number of Edges*\\n\\n# Complexity\\n- Time complexity:\\nO((N^2)+(N)*(E)*LOG(E))\\n\\n- Space complexity:\\nO(E)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> shortestAlternatingPaths(int n,vector<vector<int>>&redEdges,vector<vector<int>>& blueEdges) \\n    {\\n        multiset<int>temp;\\n        vector<multiset<int>>redchilds(n,temp),bluechilds(n,temp);\\n        for(auto j:redEdges)\\n        {\\n            redchilds[j[0]].insert(j[1]);\\n        }\\n        for(auto j:blueEdges)\\n        {\\n            bluechilds[j[0]].insert(j[1]);\\n        }\\n        vector<int>ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            //BFS for all\\n            vector<multiset<int>>reds=redchilds,blues=bluechilds;\\n            queue<pair<char,int>>visit;\\n            visit.push({\\'n\\',0});//neutral=\\'n\\'\\n            int steps=0;\\n            while(!visit.empty())\\n            {\\n                bool justbreak=false;\\n                int n=visit.size();\\n                for(int j=0;j<n;j++)\\n                {\\n                    pair<char,int>x=visit.front();\\n                    visit.pop();\\n                    if(x.second==i)\\n                    {\\n                        ans.push_back(steps);\\n                        justbreak=true;\\n                        break;\\n                    }\\n                    if(x.first==\\'n\\')\\n                    {\\n                        for(auto j:reds[x.second])\\n                        {\\n                            visit.push({\\'r\\',j});\\n                            auto itr1=reds[x.second].find(j);\\n                            reds[x.second].erase(itr1);\\n                        }\\n                        for(auto j:blues[x.second])\\n                        {\\n                            visit.push({\\'b\\',j});//blue=\\'b\\'\\n                            auto itr1=blues[x.second].find(j);\\n                            blues[x.second].erase(itr1);\\n                        }\\n                    }\\n                    else if(x.first==\\'b\\')\\n                    {\\n                        for(auto j:reds[x.second])\\n                        {\\n                            visit.push({\\'r\\',j});//red=\\'r\\'\\n                            auto itr1=reds[x.second].find(j);\\n                            reds[x.second].erase(itr1);\\n                        }\\n                    }\\n                    else if(x.first==\\'r\\')\\n                    {\\n                        for(auto j:blues[x.second])\\n                        {\\n                            visit.push({\\'b\\',j});\\n                            auto itr1=blues[x.second].find(j);\\n                            blues[x.second].erase(itr1);\\n                        }\\n                    }\\n                }\\n                if(justbreak)\\n                {\\n                    break;\\n                }\\n                steps++;\\n            }\\n            if(i==ans.size())\\n            {\\n                ans.push_back(-1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "== and = confusion",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    vector<int> shortestAlternatingPaths(int n,vector<vector<int>>&redEdges,vector<vector<int>>& blueEdges) \n    {\n        multiset<int>temp;\n        vector<multiset<int>>redchilds(n,temp),bluechilds(n,temp);\n        for(auto j:redEdges)\n        {\n            redchilds[j[0]].insert(j[1]);\n        }\n        for(auto j:blueEdges)\n        {\n            bluechilds[j[0]].insert(j[1]);\n        }\n        vector<int>ans;\n        for(int i=0;i<n;i++)\n        {\n            //BFS for all\n            vector<multiset<int>>reds=redchilds,blues=bluechilds;\n            queue<pair<char,int>>visit;\n            visit.push({'n',0});//neutral='n'\n            int steps=0;\n            while(!visit.empty())\n            {\n                bool justbreak=false;\n                int n=visit.size();\n                for(int j=0;j<n;j++)\n                {\n                    pair<char,int>x=visit.front();\n                    visit.pop();\n                    if(x.second=i)\n                    {\n                        ans.push_back(steps);\n                        justbreak=true;\n                        break;\n                    }\n                    if(x.first=='n')\n                    {\n                        for(auto j:reds[x.second])\n                        {\n                            visit.push({'r',j});\n                            auto itr1=reds[x.second].find(j);\n                            reds[x.second].erase(itr1);\n                        }\n                        for(auto j:blues[x.second])\n                        {\n                            visit.push({'b',j});//blue='b'\n                            auto itr1=blues[x.second].find(j);\n                            unknownFunction(itr1); \n                            blues[x.second].erase(itr1);\n                        }\n                    }\n                    else if(x.first=='b')\n                    {\n                        for(auto j:reds[x.second])\n                        {\n                            visit.push({'r',j});//red='r'\n                            auto itr1=reds[x.second].find(j);\n                            reds[x.second].erase(itr1);\n                        }\n                    }\n                    else if(x.first=='r')\n                    {\n                        for(auto j:blues[x.second])\n                        {\n                            visit.push({'b',j});\n                            auto itr1=blues[x.second].find(j);\n                            blues[x.second].erase(itr1);\n                        }\n                    }\n                }\n                if(justbreak)\n                {\n                    break;\n                }\n                steps++;\n            }\n            if(i==ans.size())\n            {\n                ans.push_back(-1);\n            }\n        }\n        return ans;\n    }\n};\n"
    },
    {
        "slug": "target-sum",
        "description": "You are given an integer array nums and an integer target.\nYou want to build an expression out of nums by adding one of the symbols '+' and '-' before each integer in nums and then concatenate all the integers.\n\nFor example, if nums = [2, 1], you can add a '+' before 2 and a '-' before 1 and concatenate them to build the expression \"+2-1\".\n\nReturn the number of different expressions that you can build, which evaluates to target.",
        "examples": [
            "Input: nums = [1,1,1,1,1], target = 3\nOutput: 5\nExplanation: There are 5 ways to assign symbols to make the sum of nums be target 3.\n-1 + 1 + 1 + 1 + 1 = 3\n+1 - 1 + 1 + 1 + 1 = 3\n+1 + 1 - 1 + 1 + 1 = 3\n+1 + 1 + 1 - 1 + 1 = 3\n+1 + 1 + 1 + 1 - 1 = 3",
            "Input: nums = [1], target = 1\nOutput: 1"
        ],
        "constraints": "1 <= nums.length <= 20\n0 <= nums[i] <= 1000\n0 <= sum(nums[i]) <= 1000\n-1000 <= target <= 1000",
        "oracle_code": "class Solution {\npublic:\n    int findTargetSumWays(vector<int>& nums, int target) {\n        // idx, target -> no of ways\n        map<pair<int, int>, int> memo;\n        return dp(nums, target, 0, memo); \n    }\n\nprivate:\n    int dp(vector<int>& nums, int target, int idx, map<pair<int, int>, int>& memo) {\n        if (idx == nums.size()) return target == 0;\n        if (memo.count({idx, target})) return memo[{idx, target}];\n\n        int positive = dp(nums, target + nums[idx], idx + 1, memo);\n        int negative = dp(nums, target - nums[idx], idx + 1, memo);\n\n        return memo[{idx, target}] = positive + negative;\n    }\n};",
        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        // idx, target -> no of ways\\n        map<pair<int, int>, int> memo;\\n        return dp(nums, target, 0, memo); \\n    }\\n\\nprivate:\\n    int dp(vector<int>& nums, int target, int idx, map<pair<int, int>, int>& memo) {\\n        if (idx == nums.size()) return target == 0;\\n        if (memo.count({idx, target})) return memo[{idx, target}];\\n\\n        int positive = dp(nums, target + nums[idx], idx + 1, memo);\\n        int negative = dp(nums, target - nums[idx], idx + 1, memo);\\n\\n        return memo[{idx, target}] = positive + negative;\\n    }\\n};\\n```",
        "level": "medium",
        "type": [
            "undefined methods",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution {\npublic:\n    int findTargetSumWays(vector<int>& nums, int target) {\n        // idx, target -> no of ways\n        map<pair<int, int>, int> memo;\n        int objVal;\n        return objVal.calculate(nums, target, 0, memo); \n    }\n\nprivate:\n    int dp(vector<int>& nums, int target, int idx, map<pair<int, int>, int>& memo) {\n        if (idx == nums.size()) return target == 0;\n        if (memo.count({idx, target})) return memo[{idx, target}];\n\n        int positive = dp(nums, target + nums[idx], idx + 1, memo);\n        int negative = dp(nums, target - nums[idx], idx + 1, memo);\n\n        return memo[{idx, target}] = positive + negative;\n    }\n};\n"
    }
]